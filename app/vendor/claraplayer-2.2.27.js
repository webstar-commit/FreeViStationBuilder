(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["claraplayer"] = factory();
	else
		root["claraplayer"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/*!*************************!*\
  !*** multi claraplayer ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./src/player */390);


/***/ },
/* 1 */,
/* 2 */
/*!******************************************************!*\
  !*** ./~/babel-runtime/helpers/toConsumableArray.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _from = __webpack_require__(/*! ../core-js/array/from */ 3);

	var _from2 = _interopRequireDefault(_from);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }

	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 3 */
/*!***********************************************!*\
  !*** ./~/babel-runtime/core-js/array/from.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/array/from */ 4), __esModule: true };

/***/ },
/* 4 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/array/from.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.string.iterator */ 5);
	__webpack_require__(/*! ../../modules/es6.array.from */ 49);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Array.from;

/***/ },
/* 5 */
/*!**************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.string.iterator.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(/*! ./_string-at */ 6)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(/*! ./_iter-define */ 9)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 6 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_string-at.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(/*! ./_to-integer */ 7)
	  , defined   = __webpack_require__(/*! ./_defined */ 8);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 7 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-integer.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 8 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_defined.js ***!
  \***************************************************************/
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 9 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-define.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(/*! ./_library */ 10)
	  , $export        = __webpack_require__(/*! ./_export */ 11)
	  , redefine       = __webpack_require__(/*! ./_redefine */ 26)
	  , hide           = __webpack_require__(/*! ./_hide */ 16)
	  , has            = __webpack_require__(/*! ./_has */ 27)
	  , Iterators      = __webpack_require__(/*! ./_iterators */ 28)
	  , $iterCreate    = __webpack_require__(/*! ./_iter-create */ 29)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 45)
	  , getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ 47)
	  , ITERATOR       = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';

	var returnThis = function(){ return this; };

	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 10 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_library.js ***!
  \***************************************************************/
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 11 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_export.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(/*! ./_global */ 12)
	  , core      = __webpack_require__(/*! ./_core */ 13)
	  , ctx       = __webpack_require__(/*! ./_ctx */ 14)
	  , hide      = __webpack_require__(/*! ./_hide */ 16)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	module.exports = $export;

/***/ },
/* 12 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_global.js ***!
  \**************************************************************/
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 13 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_core.js ***!
  \************************************************************/
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 14 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_ctx.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(/*! ./_a-function */ 15);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 15 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_a-function.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 16 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_hide.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(/*! ./_object-dp */ 17)
	  , createDesc = __webpack_require__(/*! ./_property-desc */ 25);
	module.exports = __webpack_require__(/*! ./_descriptors */ 21) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 17 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-dp.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(/*! ./_an-object */ 18)
	  , IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ 20)
	  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ 24)
	  , dP             = Object.defineProperty;

	exports.f = __webpack_require__(/*! ./_descriptors */ 21) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 18 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_an-object.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./_is-object */ 19);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 19 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_is-object.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 20 */
/*!**********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_ie8-dom-define.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(/*! ./_descriptors */ 21) && !__webpack_require__(/*! ./_fails */ 22)(function(){
	  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ 23)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 21 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_descriptors.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(/*! ./_fails */ 22)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 22 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_fails.js ***!
  \*************************************************************/
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 23 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_dom-create.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , document = __webpack_require__(/*! ./_global */ 12).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 24 */
/*!********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-primitive.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(/*! ./_is-object */ 19);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 25 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_property-desc.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 26 */
/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_redefine.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./_hide */ 16);

/***/ },
/* 27 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_has.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 28 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iterators.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 29 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-create.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(/*! ./_object-create */ 30)
	  , descriptor     = __webpack_require__(/*! ./_property-desc */ 25)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 45)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(/*! ./_hide */ 16)(IteratorPrototype, __webpack_require__(/*! ./_wks */ 46)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 30 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-create.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(/*! ./_an-object */ 18)
	  , dPs         = __webpack_require__(/*! ./_object-dps */ 31)
	  , enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ 43)
	  , IE_PROTO    = __webpack_require__(/*! ./_shared-key */ 40)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(/*! ./_dom-create */ 23)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(/*! ./_html */ 44).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 31 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-dps.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(/*! ./_object-dp */ 17)
	  , anObject = __webpack_require__(/*! ./_an-object */ 18)
	  , getKeys  = __webpack_require__(/*! ./_object-keys */ 32);

	module.exports = __webpack_require__(/*! ./_descriptors */ 21) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 32 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-keys.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(/*! ./_object-keys-internal */ 33)
	  , enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ 43);

	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 33 */
/*!****************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-keys-internal.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(/*! ./_has */ 27)
	  , toIObject    = __webpack_require__(/*! ./_to-iobject */ 34)
	  , arrayIndexOf = __webpack_require__(/*! ./_array-includes */ 37)(false)
	  , IE_PROTO     = __webpack_require__(/*! ./_shared-key */ 40)('IE_PROTO');

	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 34 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-iobject.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(/*! ./_iobject */ 35)
	  , defined = __webpack_require__(/*! ./_defined */ 8);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 35 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iobject.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(/*! ./_cof */ 36);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 36 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_cof.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 37 */
/*!**********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_array-includes.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(/*! ./_to-iobject */ 34)
	  , toLength  = __webpack_require__(/*! ./_to-length */ 38)
	  , toIndex   = __webpack_require__(/*! ./_to-index */ 39);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 38 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-length.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(/*! ./_to-integer */ 7)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 39 */
/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-index.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(/*! ./_to-integer */ 7)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 40 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_shared-key.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(/*! ./_shared */ 41)('keys')
	  , uid    = __webpack_require__(/*! ./_uid */ 42);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 41 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_shared.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(/*! ./_global */ 12)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 42 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_uid.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 43 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_enum-bug-keys.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 44 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_html.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./_global */ 12).document && document.documentElement;

/***/ },
/* 45 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_set-to-string-tag.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(/*! ./_object-dp */ 17).f
	  , has = __webpack_require__(/*! ./_has */ 27)
	  , TAG = __webpack_require__(/*! ./_wks */ 46)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 46 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_wks.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(/*! ./_shared */ 41)('wks')
	  , uid        = __webpack_require__(/*! ./_uid */ 42)
	  , Symbol     = __webpack_require__(/*! ./_global */ 12).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;

/***/ },
/* 47 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gpo.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(/*! ./_has */ 27)
	  , toObject    = __webpack_require__(/*! ./_to-object */ 48)
	  , IE_PROTO    = __webpack_require__(/*! ./_shared-key */ 40)('IE_PROTO')
	  , ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 48 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-object.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(/*! ./_defined */ 8);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 49 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.array.from.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(/*! ./_ctx */ 14)
	  , $export        = __webpack_require__(/*! ./_export */ 11)
	  , toObject       = __webpack_require__(/*! ./_to-object */ 48)
	  , call           = __webpack_require__(/*! ./_iter-call */ 50)
	  , isArrayIter    = __webpack_require__(/*! ./_is-array-iter */ 51)
	  , toLength       = __webpack_require__(/*! ./_to-length */ 38)
	  , createProperty = __webpack_require__(/*! ./_create-property */ 52)
	  , getIterFn      = __webpack_require__(/*! ./core.get-iterator-method */ 53);

	$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ 55)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 50 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-call.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(/*! ./_an-object */ 18);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 51 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_is-array-iter.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(/*! ./_iterators */ 28)
	  , ITERATOR   = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , ArrayProto = Array.prototype;

	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 52 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_create-property.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(/*! ./_object-dp */ 17)
	  , createDesc      = __webpack_require__(/*! ./_property-desc */ 25);

	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 53 */
/*!*******************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/core.get-iterator-method.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(/*! ./_classof */ 54)
	  , ITERATOR  = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , Iterators = __webpack_require__(/*! ./_iterators */ 28);
	module.exports = __webpack_require__(/*! ./_core */ 13).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 54 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_classof.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(/*! ./_cof */ 36)
	  , TAG = __webpack_require__(/*! ./_wks */ 46)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};

	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 55 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-detect.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }

	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 56 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/object/assign.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/assign */ 57), __esModule: true };

/***/ },
/* 57 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/assign.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.assign */ 58);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.assign;

/***/ },
/* 58 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.assign.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(/*! ./_export */ 11);

	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(/*! ./_object-assign */ 59)});

/***/ },
/* 59 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-assign.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(/*! ./_object-keys */ 32)
	  , gOPS     = __webpack_require__(/*! ./_object-gops */ 60)
	  , pIE      = __webpack_require__(/*! ./_object-pie */ 61)
	  , toObject = __webpack_require__(/*! ./_to-object */ 48)
	  , IObject  = __webpack_require__(/*! ./_iobject */ 35)
	  , $assign  = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(/*! ./_fails */ 22)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 60 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gops.js ***!
  \*******************************************************************/
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 61 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-pie.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 62 */,
/* 63 */,
/* 64 */
/*!********************************!*\
  !*** ./~/three/three.extra.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var THREE = __webpack_require__(/*! ./three */ 65);
	// File:examples/js/pmrem/PMREMGenerator.js

	/**
	 * @author Prashant Sharma / spidersharma03
	 * @author Ben Houston / bhouston, https://clara.io
	 *
	 * To avoid cube map seams, I create an extra pixel around each face. This way when the cube map is
	 * sampled by an application later(with a little care by sampling the centre of the texel), the extra 1 border
	 *	of pixels makes sure that there is no seams artifacts present. This works perfectly for cubeUV format as
	 *	well where the 6 faces can be arranged in any manner whatsoever.
	 * Code in the beginning of fragment shader's main function does this job for a given resolution.
	 *	Run Scene_PMREM_Test.html in the examples directory to see the sampling from the cube lods generated
	 *	by this class.
	 */

	THREE.PMREMGenerator = function( sourceTexture, samplesPerLevel, resolution ) {

		this.sourceTexture = sourceTexture;
		this.resolution = ( resolution !== undefined ) ? resolution : 256; // NODE: 256 is currently hard coded in the glsl code for performance reasons
		this.samplesPerLevel = ( samplesPerLevel !== undefined ) ? samplesPerLevel : 16;

		var monotonicEncoding = ( sourceTexture.encoding === THREE.LinearEncoding ) ||
			( sourceTexture.encoding === THREE.GammaEncoding ) || ( sourceTexture.encoding === THREE.sRGBEncoding );

		this.sourceTexture.minFilter = ( monotonicEncoding ) ? THREE.LinearFilter : THREE.NearestFilter;
		this.sourceTexture.magFilter = ( monotonicEncoding ) ? THREE.LinearFilter : THREE.NearestFilter;
		this.sourceTexture.generateMipmaps = this.sourceTexture.generateMipmaps && monotonicEncoding;

		this.cubeLods = [];

		var size = this.resolution;
		var params = {		format: this.sourceTexture.format,
			magFilter: this.sourceTexture.magFilter,
			minFilter: this.sourceTexture.minFilter,
			type: this.sourceTexture.type,
			generateMipmaps: this.sourceTexture.generateMipmaps,
			anisotropy: this.sourceTexture.anisotropy,
			encoding: this.sourceTexture.encoding
		 };

		// how many LODs fit in the given CubeUV Texture.
		this.numLods = Math.log( size ) / Math.log( 2 ) - 2;  // IE11 doesn't support Math.log2

		for ( var i = 0; i < this.numLods; i ++ ) {

			var renderTarget = new THREE.WebGLRenderTargetCube( size, size, params );
			renderTarget.texture.name = "PMREMGenerator.cube" + i;
			this.cubeLods.push( renderTarget );
			size = Math.max( 16, size / 2 );

		}

		this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0.0, 1000 );

		this.shader = this.getShader();
		this.shader.defines['SAMPLES_PER_LEVEL'] = this.samplesPerLevel;
		this.planeMesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2, 0 ), this.shader );
		this.planeMesh.material.side = THREE.DoubleSide;
		this.scene = new THREE.Scene();
		this.scene.add( this.planeMesh );
		this.scene.add( this.camera );

		this.shader.uniforms[ 'envMap' ].value = this.sourceTexture;
		this.shader.envMap = this.sourceTexture;

	};

	THREE.PMREMGenerator.prototype = {

		constructor : THREE.PMREMGenerator,

		/*
		 * Prashant Sharma / spidersharma03: More thought and work is needed here.
		 * Right now it's a kind of a hack to use the previously convolved map to convolve the current one.
		 * I tried to use the original map to convolve all the lods, but for many textures(specially the high frequency)
		 * even a high number of samples(1024) dosen't lead to satisfactory results.
		 * By using the previous convolved maps, a lower number of samples are generally sufficient(right now 32, which
		 * gives okay results unless we see the reflection very carefully, or zoom in too much), however the math
		 * goes wrong as the distribution function tries to sample a larger area than what it should be. So I simply scaled
		 * the roughness by 0.9(totally empirical) to try to visually match the original result.
		 * The condition "if(i <5)" is also an attemt to make the result match the original result.
		 * This method requires the most amount of thinking I guess. Here is a paper which we could try to implement in future::
		 * http://http.developer.nvidia.com/GPUGems3/gpugems3_ch20.html
		 */
		update: function( renderer ) {

			this.shader.uniforms[ 'envMap' ].value = this.sourceTexture;
			this.shader.envMap = this.sourceTexture;

			var gammaInput = renderer.gammaInput;
			var gammaOutput = renderer.gammaOutput;
			var toneMapping = renderer.toneMapping;
			var toneMappingExposure = renderer.toneMappingExposure;

			renderer.toneMapping = THREE.LinearToneMapping;
			renderer.toneMappingExposure = 1.0;
			renderer.gammaInput = false;
			renderer.gammaOutput = false;

			for ( var i = 0; i < this.numLods; i ++ ) {

				var r = i / ( this.numLods - 1 );
				this.shader.uniforms[ 'roughness' ].value = r * 0.9; // see comment above, pragmatic choice
				this.shader.uniforms[ 'queryScale' ].value.x = ( i == 0 ) ? -1 : 1;
				var size = this.cubeLods[ i ].width;
				this.shader.uniforms[ 'mapSize' ].value = size;
				this.renderToCubeMapTarget( renderer, this.cubeLods[ i ] );

				if ( i < 5 ) this.shader.uniforms[ 'envMap' ].value = this.cubeLods[ i ].texture;

			}

			renderer.toneMapping = toneMapping;
			renderer.toneMappingExposure = toneMappingExposure;
			renderer.gammaInput = gammaInput;
			renderer.gammaOutput = gammaOutput;

		},

		renderToCubeMapTarget: function( renderer, renderTarget ) {

			for ( var i = 0; i < 6; i ++ ) {

				this.renderToCubeMapTargetFace( renderer, renderTarget, i )

			}

		},

		renderToCubeMapTargetFace: function( renderer, renderTarget, faceIndex ) {

			renderTarget.activeCubeFace = faceIndex;
			this.shader.uniforms[ 'faceIndex' ].value = faceIndex;
			renderer.render( this.scene, this.camera, renderTarget, true );

		},

		getShader: function() {

			return new THREE.ShaderMaterial( {

				defines: {
					"SAMPLES_PER_LEVEL": 20,
				},

				uniforms: {
					"faceIndex": { value: 0 },
					"roughness": { value: 0.5 },
					"mapSize": { value: 0.5 },
					"envMap": { value: null },
					"queryScale": { value: new THREE.Vector3( 1, 1, 1 ) },
					"testColor": { value: new THREE.Vector3( 1, 1, 1 ) },
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\n\
					varying vec2 vUv;\n\
					uniform int faceIndex;\n\
					uniform float roughness;\n\
					uniform samplerCube envMap;\n\
					uniform float mapSize;\n\
					uniform vec3 testColor;\n\
					uniform vec3 queryScale;\n\
					\n\
					float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\
						float a = ggxRoughness + 0.0001;\n\
						a *= a;\n\
						return ( 2.0 / a - 2.0 );\n\
					}\n\
					vec3 ImportanceSamplePhong(vec2 uv, mat3 vecSpace, float specPow) {\n\
						float phi = uv.y * 2.0 * PI;\n\
						float cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\
						float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\
						vec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\
						return vecSpace * sampleDir;\n\
					}\n\
					vec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\n\
					{\n\
						float a = Roughness * Roughness;\n\
						float Phi = 2.0 * PI * uv.x;\n\
						float CosTheta = sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\n\
						float SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\
						return vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\n\
					}\n\
					mat3 matrixFromVector(vec3 n) {\n\
						float a = 1.0 / (1.0 + n.z);\n\
						float b = -n.x * n.y * a;\n\
						vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\
						vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\
						return mat3(b1, b2, n);\n\
					}\n\
					\n\
					vec4 testColorMap(float Roughness) {\n\
						vec4 color;\n\
						if(faceIndex == 0)\n\
							color = vec4(1.0,0.0,0.0,1.0);\n\
						else if(faceIndex == 1)\n\
							color = vec4(0.0,1.0,0.0,1.0);\n\
						else if(faceIndex == 2)\n\
							color = vec4(0.0,0.0,1.0,1.0);\n\
						else if(faceIndex == 3)\n\
							color = vec4(1.0,1.0,0.0,1.0);\n\
						else if(faceIndex == 4)\n\
							color = vec4(0.0,1.0,1.0,1.0);\n\
						else\n\
							color = vec4(1.0,0.0,1.0,1.0);\n\
						color *= ( 1.0 - Roughness );\n\
						return color;\n\
					}\n\
					void main() {\n\
						vec3 sampleDirection;\n\
						vec2 uv = vUv*2.0 - 1.0;\n\
						float offset = -1.0/mapSize;\n\
						const float a = -1.0;\n\
						const float b = 1.0;\n\
						float c = -1.0 + offset;\n\
						float d = 1.0 - offset;\n\
						float bminusa = b - a;\n\
						uv.x = (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\n\
						uv.y = (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\n\
						if (faceIndex==0) {\n\
							sampleDirection = vec3(1.0, -uv.y, -uv.x);\n\
						} else if (faceIndex==1) {\n\
							sampleDirection = vec3(-1.0, -uv.y, uv.x);\n\
						} else if (faceIndex==2) {\n\
							sampleDirection = vec3(uv.x, 1.0, uv.y);\n\
						} else if (faceIndex==3) {\n\
							sampleDirection = vec3(uv.x, -1.0, -uv.y);\n\
						} else if (faceIndex==4) {\n\
							sampleDirection = vec3(uv.x, -uv.y, 1.0);\n\
						} else {\n\
							sampleDirection = vec3(-uv.x, -uv.y, -1.0);\n\
						}\n\
						mat3 vecSpace = matrixFromVector(normalize(sampleDirection * queryScale));\n\
						vec3 rgbColor = vec3(0.0);\n\
						const int NumSamples = SAMPLES_PER_LEVEL;\n\
						vec3 vect;\n\
						float weight = 0.0;\n\
						for( int i = 0; i < NumSamples; i ++ ) {\n\
							float sini = sin(float(i));\n\
							float cosi = cos(float(i));\n\
							float r = rand(vec2(sini, cosi));\n\
							vect = ImportanceSampleGGX(vec2(float(i) / float(NumSamples), r), vecSpace, roughness);\n\
							float dotProd = dot(vect, normalize(sampleDirection));\n\
							weight += dotProd;\n\
							vec3 color = envMapTexelToLinear(textureCube(envMap,vect)).rgb;\n\
							rgbColor.rgb += color;\n\
						}\n\
						rgbColor /= float(NumSamples);\n\
						//rgbColor = testColorMap( roughness ).rgb;\n\
						gl_FragColor = linearToOutputTexel( vec4( rgbColor, 1.0 ) );\n\
					}",
				blending: THREE.CustomBlending,
				blendSrc: THREE.OneFactor,
				blendDst: THREE.ZeroFactor,
				blendSrcAlpha: THREE.OneFactor,
				blendDstAlpha: THREE.ZeroFactor,
				blendEquation: THREE.AddEquation
			} );

		}

	};

	// File:examples/js/pmrem/PMREMCubeUVPacker.js

	/**
	 * @author Prashant Sharma / spidersharma03
	 * @author Ben Houston / bhouston, https://clara.io
	 *
	 * This class takes the cube lods(corresponding to different roughness values), and creates a single cubeUV
	 * Texture. The format for a given roughness set of faces is simply::
	 * +X+Y+Z
	 * -X-Y-Z
	 * For every roughness a mip map chain is also saved, which is essential to remove the texture artifacts due to
	 * minification.
	 * Right now for every face a PlaneMesh is drawn, which leads to a lot of geometry draw calls, but can be replaced
	 * later by drawing a single buffer and by sending the appropriate faceIndex via vertex attributes.
	 * The arrangement of the faces is fixed, as assuming this arrangement, the sampling function has been written.
	 */


	THREE.PMREMCubeUVPacker = function( cubeTextureLods, numLods ) {

		this.cubeLods = cubeTextureLods;
		this.numLods = numLods;
		var size = cubeTextureLods[ 0 ].width * 4;

		var sourceTexture = cubeTextureLods[ 0 ].texture;
		var params = {
			format: sourceTexture.format,
			magFilter: sourceTexture.magFilter,
			minFilter: sourceTexture.minFilter,
			type: sourceTexture.type,
			generateMipmaps: sourceTexture.generateMipmaps,
			anisotropy: sourceTexture.anisotropy,
			encoding: sourceTexture.encoding
		};

		if( sourceTexture.encoding === THREE.RGBM16Encoding ) {
			params.magFilter = THREE.LinearFilter;
			params.minFilter = THREE.LinearFilter;
		}

		this.CubeUVRenderTarget = new THREE.WebGLRenderTarget( size, size, params );
		this.CubeUVRenderTarget.texture.name = "PMREMCubeUVPacker.cubeUv";
		this.CubeUVRenderTarget.texture.mapping = THREE.CubeUVReflectionMapping;
		this.camera = new THREE.OrthographicCamera( - size * 0.5, size * 0.5, - size * 0.5, size * 0.5, 0.0, 1000 );

		this.scene = new THREE.Scene();
		this.scene.add( this.camera );

		this.objects = [];
		var xOffset = 0;
		var faceOffsets = [];
		faceOffsets.push( new THREE.Vector2( 0, 0 ) );
		faceOffsets.push( new THREE.Vector2( 1, 0 ) );
		faceOffsets.push( new THREE.Vector2( 2, 0 ) );
		faceOffsets.push( new THREE.Vector2( 0, 1 ) );
		faceOffsets.push( new THREE.Vector2( 1, 1 ) );
		faceOffsets.push( new THREE.Vector2( 2, 1 ) );
		var yOffset = 0;
		var textureResolution = size;
		size = cubeTextureLods[ 0 ].width;

		var offset2 = 0;
		var c = 4.0;
		this.numLods = Math.log( cubeTextureLods[ 0 ].width ) / Math.log( 2 ) - 2; // IE11 doesn't support Math.log2
		for ( var i = 0; i < this.numLods; i ++ ) {

			var offset1 = ( textureResolution - textureResolution / c ) * 0.5;
			if ( size > 16 )
			c *= 2;
			var nMips = size > 16 ? 6 : 1;
			var mipOffsetX = 0;
			var mipOffsetY = 0;
			var mipSize = size;

			for ( var j = 0; j < nMips; j ++ ) {

				// Mip Maps
				for ( var k = 0; k < 6; k ++ ) {

					// 6 Cube Faces
					var material = this.getShader();
					material.uniforms[ 'envMap' ].value = this.cubeLods[ i ].texture;
					material.envMap = this.cubeLods[ i ].texture;
					material.uniforms[ 'faceIndex' ].value = k;
					material.uniforms[ 'mapSize' ].value = mipSize;
					var color = material.uniforms[ 'testColor' ].value;
					//color.copy(testColor[j]);
					var planeMesh = new THREE.Mesh(
					new THREE.PlaneGeometry( mipSize, mipSize, 0 ),
					material );
					planeMesh.position.x = faceOffsets[ k ].x * mipSize - offset1 + mipOffsetX;
					planeMesh.position.y = faceOffsets[ k ].y * mipSize - offset1 + offset2 + mipOffsetY;
					planeMesh.material.side = THREE.DoubleSide;
					this.scene.add( planeMesh );
					this.objects.push( planeMesh );

				}
				mipOffsetY += 1.75 * mipSize;
				mipOffsetX += 1.25 * mipSize;
				mipSize /= 2;

			}
			offset2 += 2 * size;
			if ( size > 16 )
			size /= 2;

		}

	};

	THREE.PMREMCubeUVPacker.prototype = {

		constructor : THREE.PMREMCubeUVPacker,

		update: function( renderer ) {

			var gammaInput = renderer.gammaInput;
			var gammaOutput = renderer.gammaOutput;
			var toneMapping = renderer.toneMapping;
			var toneMappingExposure = renderer.toneMappingExposure;
			renderer.gammaInput = false;
			renderer.gammaOutput = false;
			renderer.toneMapping = THREE.LinearToneMapping;
			renderer.toneMappingExposure = 1.0;
			renderer.render( this.scene, this.camera, this.CubeUVRenderTarget, false );

			renderer.toneMapping = toneMapping;
			renderer.toneMappingExposure = toneMappingExposure;
			renderer.gammaInput = gammaInput;
			renderer.gammaOutput = gammaOutput;

		},

		getShader: function() {

			var shaderMaterial = new THREE.ShaderMaterial( {

				uniforms: {
					"faceIndex": { value: 0 },
					"mapSize": { value: 0 },
					"envMap": { value: null },
					"testColor": { value: new THREE.Vector3( 1, 1, 1 ) }
				},

				vertexShader:
					"precision highp float;\
					varying vec2 vUv;\
					void main() {\
						vUv = uv;\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\
					}",

				fragmentShader:
					"precision highp float;\
					varying vec2 vUv;\
					uniform samplerCube envMap;\
					uniform float mapSize;\
					uniform vec3 testColor;\
					uniform int faceIndex;\
					\
					void main() {\
						vec3 sampleDirection;\
						vec2 uv = vUv;\
						uv = uv * 2.0 - 1.0;\
						uv.y *= -1.0;\
						if(faceIndex == 0) {\
							sampleDirection = normalize(vec3(1.0, uv.y, -uv.x));\
						} else if(faceIndex == 1) {\
							sampleDirection = normalize(vec3(uv.x, 1.0, uv.y));\
						} else if(faceIndex == 2) {\
							sampleDirection = normalize(vec3(uv.x, uv.y, 1.0));\
						} else if(faceIndex == 3) {\
							sampleDirection = normalize(vec3(-1.0, uv.y, uv.x));\
						} else if(faceIndex == 4) {\
							sampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));\
						} else {\
							sampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));\
						}\
						vec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\
						gl_FragColor = linearToOutputTexel( color );\
					}",

				blending: THREE.CustomBlending,
				premultipliedAlpha: false,
				blendSrc: THREE.OneFactor,
				blendDst: THREE.ZeroFactor,
				blendSrcAlpha: THREE.OneFactor,
				blendDstAlpha: THREE.ZeroFactor,
				blendEquation: THREE.AddEquation

			} );

			return shaderMaterial;

		}

	};

	// File:examples/js/shaders/CopyShader.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Full-screen textured quad shader
	 */

	THREE.CopyShader = {

		uniforms: {

			"tDiffuse": { value: null },
			"opacity":  { value: 1.0 }

		},

		vertexShader: [

			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform float opacity;",

			"uniform sampler2D tDiffuse;",

			"varying vec2 vUv;",

			"void main() {",

				"vec4 texel = texture2D( tDiffuse, vUv );",
				"gl_FragColor = opacity * texel;",

			"}"

		].join( "\n" )

	};

	// File:examples/js/shaders/CompositeShader.js

	/**
	 * @author bhouston / http://clara.io
	 *
	 * Various composite operations
	 */

	THREE.CompositeShader = {

	  defines: {

			"BLENDING": THREE.NoBlending

	  },

		uniforms: {

	    "tSource": { type: "t", value: null },
	    "opacitySource": { type: "f", value: 1.0 },

			"tDestination": { type: "t", value: null },
	    "opacityDestination": { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

	    "uniform sampler2D tSource;",
	    "uniform float opacitySource;",

			"uniform sampler2D tDestination;",
	    "uniform float opacityDestination;",

			"varying vec2 vUv;",

			"void main() {",

				"vec4 d = opacityDestination * texture2D( tDestination, vUv );",
				"vec4 s = opacitySource * texture2D( tSource, vUv );",

	      // all blending modes are implemented assuming premultiplied values

	      "#if (BLENDING == " + THREE.NormalBlending + ")",

	        "gl_FragColor = d * ( 1.0 - s.a ) + s;",

	      "#elif (BLENDING == " + THREE.AdditiveBlending + ")",

	        "gl_FragColor = d + s;",

	      "#elif (BLENDING == " + THREE.SubtractiveBlending + ")",

	        "gl_FragColor = d - s;",

	      "#elif (BLENDING == " + THREE.MultiplyBlending + ")",

	        "gl_FragColor = d * s;",

	      "#else", // THREE.NoBlending

	        "gl_FragColor = s;",

	      "#endif",

			"}"

		].join( "\n" )

	};

	// File:examples/js/shaders/GlossyMirrorShader.js

	THREE.GlossyMirrorShader = {

		defines: {
			"SPECULAR_MAP": 0,
			"ROUGHNESS_MAP": 0,
			"GLOSSY_REFLECTIONS": 1,
			"REFLECTION_LOD_LEVELS": 4,
			"PERSPECTIVE_CAMERA": 1
		},

		uniforms: {

		 	"metalness": { type: "f", value: 0.0 },

		 	"specularColor": { type: "c", value: new THREE.Color( 0xffffff ) },
			"tSpecular": { type: "t", value: null },

			"tReflection": { type: "t", value: null },
			"tReflection1": { type: "t", value: null },
			"tReflection2": { type: "t", value: null },
			"tReflection3": { type: "t", value: null },
			"tReflection4": { type: "t", value: null },
			"tReflectionDepth": { type: "t", value: null },

			"roughness": { type: "f", value: 0.0 },
		 	"distanceFade": { type: "f", value: 0.01 },
		 	"fresnelStrength": { type: "f", value: 1.0 },

			"reflectionTextureMatrix" : { type: "m4", value: new THREE.Matrix4() },
			"mirrorCameraWorldMatrix": { type: "m4", value: new THREE.Matrix4() },
			"mirrorCameraProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
			"mirrorCameraInverseProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
			"mirrorCameraNear": { type: "f", value: 0 },
			"mirrorCameraFar": { type: "f", value: 0 },
			"screenSize": { type: "v2", value: new THREE.Vector2() },
			"mirrorNormal": { type: "v3", value: new THREE.Vector3() },
			"mirrorWorldPosition": { type: "v3", value: new THREE.Vector3() }
		},

		vertexShader: [

			"uniform mat4 reflectionTextureMatrix;",

			"varying vec4 mirrorCoord;",
			"varying vec3 vecPosition;",
			"varying vec3 worldNormal;",
			"varying vec2 vUv;",

			"void main() {",
				"vUv = uv;",
				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
				"vecPosition = cameraPosition - worldPosition.xyz;",
				"worldNormal = (modelMatrix * vec4(normal,0.0)).xyz;",
				"mirrorCoord = reflectionTextureMatrix * worldPosition;",

				"gl_Position = projectionMatrix * mvPosition;",

			"}"

		].join( "\n" ),

		blending: THREE.NormalBlending,
		transparent: true,

		fragmentShader: [

			"#include <common>",
			"#include <packing>",
			"#include <bsdfs>",

			"uniform float roughness;",
			"#if ROUGHNESS_MAP == 1",
				"uniform sampler2D tRoughness;",
			"#endif",

			"uniform float metalness;",
			"uniform float distanceFade;",
			"uniform float fresnelStrength;",

			"uniform vec3 specularColor;",
			"#if SPECULAR_MAP == 1",
				"uniform sampler2D tSpecular;",
			"#endif",

			"uniform sampler2D tReflection;",
			"#if GLOSSY_REFLECTIONS == 1",
				"uniform sampler2D tReflection1;",
				"uniform sampler2D tReflection2;",
				"uniform sampler2D tReflection3;",
				"uniform sampler2D tReflection4;",
				"uniform sampler2D tReflectionDepth;",
			"#endif",

			"varying vec3 vecPosition;",
			"varying vec3 worldNormal;",
			"varying vec2 vUv;",

			"varying vec4 mirrorCoord;",
			"uniform mat4 mirrorCameraProjectionMatrix;",
	 		"uniform mat4 mirrorCameraInverseProjectionMatrix;",
			"uniform mat4 mirrorCameraWorldMatrix;",
			"uniform float mirrorCameraNear;",
			"uniform float mirrorCameraFar;",
			"uniform vec2 screenSize;",
			"uniform vec3 mirrorNormal;",
			"uniform vec3 mirrorWorldPosition;",

			"#if GLOSSY_REFLECTIONS == 1",

				"float getReflectionDepth() {",

					"return unpackRGBAToDepth( texture2DProj( tReflectionDepth, mirrorCoord ) );",

		 		"}",

				"float getReflectionViewZ( const in float reflectionDepth ) {",
					"#if PERSPECTIVE_CAMERA == 1",
		 				"return perspectiveDepthToViewZ( reflectionDepth, mirrorCameraNear, mirrorCameraFar );",
					"#else",
						"return orthographicDepthToViewZ( reflectionDepth, mirrorCameraNear, mirrorCameraFar );",
					"#endif",
		 		"}",

		 		"vec3 getReflectionViewPosition( const in vec2 screenPosition, const in float reflectionDepth, const in float reflectionViewZ ) {",

		 			"float clipW = mirrorCameraProjectionMatrix[2][3] * reflectionViewZ + mirrorCameraProjectionMatrix[3][3];",
		 			"vec4 clipPosition = vec4( ( vec3( screenPosition, reflectionDepth ) - 0.5 ) * 2.0, 1.0 );",
		 			"clipPosition *= clipW;", // unprojection.
					"return ( mirrorCameraInverseProjectionMatrix * clipPosition ).xyz;",

		 		"}",

			"#endif",

			"vec4 getReflection( const in vec4 mirrorCoord, const in float lodLevel ) {",

				"#if GLOSSY_REFLECTIONS == 0",

					"return texture2DProj( tReflection, mirrorCoord );",

				"#else",

					"vec4 color0, color1;",
					"float alpha;",

					"if( lodLevel < 1.0 ) {",
						"color0 = texture2DProj( tReflection, mirrorCoord );",
						"color1 = texture2DProj( tReflection1, mirrorCoord );",
						"alpha = lodLevel;",
					"}",
					"else if( lodLevel < 2.0) {",
						"color0 = texture2DProj( tReflection1, mirrorCoord );",
						"color1 = texture2DProj( tReflection2, mirrorCoord );",
						"alpha = lodLevel - 1.0;",
					"}",
					"else if( lodLevel < 3.0 ) {",
						"color0 = texture2DProj( tReflection2, mirrorCoord );",
						"color1 = texture2DProj( tReflection3, mirrorCoord );",
						"alpha = lodLevel - 2.0;",
					"}",
					"else {",
						"color0 = texture2DProj( tReflection3, mirrorCoord );",
						"color1 = color0;",
						"alpha = 0.0;",
					"}",

					"return mix( color0, color1, alpha );",

				"#endif",

			"}",

			"void main() {",

				"vec3 specular = specularColor;",
				"#if SPECULAR_MAP == 1",
					"specular *= texture2D( tSpecular, vUv );",
				"#endif",

				"float fade = 1.0;",

				"#if GLOSSY_REFLECTIONS == 1",

					"float localRoughness = roughness;",
					"#if ROUGHNESS_MAP == 1",
						"localRoughness *= texture2D( tRoughness, vUv ).r;",
					"#endif",

					"vec2 screenPosition = gl_FragCoord.xy / screenSize;",
					"float reflectionDepth = getReflectionDepth();",
					"float reflectionViewZ = getReflectionViewZ( reflectionDepth );",

					"vec3 reflectionViewPosition = getReflectionViewPosition( screenPosition, reflectionDepth, reflectionViewZ );",
					"vec3 reflectionWorldPosition = ( mirrorCameraWorldMatrix * vec4( reflectionViewPosition, 1.0 ) ).xyz;",

					"vec3 closestPointOnMirror = projectOnPlane( reflectionWorldPosition, mirrorWorldPosition, mirrorNormal );",

					"vec3 pointOnMirror = linePlaneIntersect( cameraPosition, normalize( reflectionWorldPosition - cameraPosition ), mirrorWorldPosition, mirrorNormal );",
					"float distance = length( closestPointOnMirror - reflectionWorldPosition );",

					"localRoughness = localRoughness * distance * 0.2;",
					"float lodLevel = localRoughness;",

					"fade = 1.0 - smoothstep( 0.0, 1.0, distanceFade * distance * 0.2 );",
				"#else",

					"float lodLevel = 0.0;",

				"#endif",

				"vec4 reflection = getReflection( mirrorCoord, lodLevel );",

				// apply dieletric-conductor model parameterized by metalness parameter.
				"float dotNV = clamp( dot( normalize( worldNormal ), normalize( vecPosition ) ), EPSILON, 1.0 );",
				"specular = mix( vec3( 0.05 ), specular, metalness );",
				// TODO: Invert fresnel.
				"vec3 fresnel;",
				"if( fresnelStrength < 0.0 ) {",
					"fresnel = mix( specular, specular * pow( dotNV, 2.0 ), -fresnelStrength ) * pow( 1.0 - roughness, 2.0 );",
				"} else {",
					"fresnel = mix( specular, F_Schlick( specular, dotNV ), fresnelStrength ) * pow( 1.0 - roughness, 2.0 );",
				"}",
				"gl_FragColor = vec4( reflection.rgb, fresnel * fade * reflection.a );", // fresnel controls alpha


			"}"

			].join( "\n" )

	};

	// File:examples/js/shaders/SAOShader.js

	/**
	 * @author bhouston / http://clara.io/
	 *
	 * Scalable Ambient Occlusion
	 *
	 */

	THREE.ShaderChunk['sao'] = [

	"#include <packing>",

	"float getDepth( const in vec2 screenPosition ) {",

		"#if DEPTH_PACKING == 1",
			"return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
		"#else",
			"return texture2D( tDepth, screenPosition ).x;",
		"#endif",

	"}",

	"vec4 setDepth( const in float depth ) {",

		"#if DEPTH_PACKING == 1",
			"return packDepthToRGBA( depth );",
		"#else",
			"return vec4( depth, 0, 0, 0 );",
		"#endif",

	"}",

	"float getViewZ( const in float depth ) {",

		"#if PERSPECTIVE_CAMERA == 1",
			"return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
		"#else",
			"return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
		"#endif",

	"}"

	].join( "\n" );

	THREE.SAOShader = {

		blending: THREE.NoBlending,

		defines: {
			'NUM_SAMPLES': 13,
			'NUM_RINGS': 7,
			"NORMAL_TEXTURE": 0,
			"DIFFUSE_TEXTURE": 1,
			"DEPTH_PACKING": 1,
			"DEPTH_MIPS": 0,
			"PERSPECTIVE_CAMERA": 1
		},

		extensions: {
			'derivatives': true
		},

		uniforms: {

			"tDepth":       { type: "t", value: null },
			"tDepth1":       { type: "t", value: null },
			"tDepth2":       { type: "t", value: null },
			"tDepth3":       { type: "t", value: null },

			"tDiffuse":     { type: "t", value: null },
			"tNormal":      { type: "t", value: null },
			"size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },

			"cameraNear":   { type: "f", value: 1 },
			"cameraFar":    { type: "f", value: 100 },
			"cameraProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
			"cameraInverseProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },

			"intensity":    { type: "f", value: 0.1 },

			"occlusionSphereWorldRadius": { type: "f", value: 100.0 },
			"worldToScreenRatio": { type: "v2", value: new THREE.Vector2( 1, 1 ) },
			"randomSeed":   { type: "f", value: 0.0 }
		},

		vertexShader: [

			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [


			"#include <common>",

			"varying vec2 vUv;",

			"#if DIFFUSE_TEXTURE == 1",
				"uniform sampler2D tDiffuse;",
			"#endif",

			"#define MAX_MIP_LEVEL 3",

			"uniform sampler2D tDepth;",

			"#if DEPTH_MIPS == 1",
				"uniform sampler2D tDepth1;",
				"uniform sampler2D tDepth2;",
				"uniform sampler2D tDepth3;",
			"#endif",

			"#if NORMAL_TEXTURE == 1",
				"uniform sampler2D tNormal;",
			"#endif",

			"uniform float cameraNear;",
			"uniform float cameraFar;",
			"uniform mat4 cameraProjectionMatrix;",
			"uniform mat4 cameraInverseProjectionMatrix;",

			"uniform float intensity;",
			"uniform float occlusionSphereWorldRadius;",
			"uniform vec2 size;",
			"uniform vec2 worldToScreenRatio;",
			"uniform float randomSeed;",


			"#include <sao>",

			"vec4 getDefaultColor( const in vec2 screenPosition ) {",

				"#if DIFFUSE_TEXTURE == 1",
					"return texture2D( tDiffuse, vUv );",
				"#else",
					"return vec4( 1.0 );",
				"#endif",

			"}",

			"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {",

				"float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];",
				"vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );",
				"clipPosition *= clipW;", // unprojection.
				"return ( cameraInverseProjectionMatrix * clipPosition ).xyz;",

			"}",

			"vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {",

				"#if NORMAL_TEXTURE == 1",
					"return -unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );",
				"#else",
					"return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );",
				"#endif",

			"}",

			"float getDepthMIP( const in vec2 screenPosition, const int mipLevel ) {",

				"vec4 rawDepth;",
				"#if DEPTH_MIPS == 0",
					"rawDepth = texture2D( tDepth, screenPosition );",
				"#else",
					"if( mipLevel == 0 ) {",
						"rawDepth = texture2D( tDepth, screenPosition );",
					"}",
					"else if( mipLevel == 1 ) {",
						"rawDepth = texture2D( tDepth1, screenPosition );",
					"}",
					"else if( mipLevel == 2 ) {",
						"rawDepth = texture2D( tDepth2, screenPosition );",
					"}",
					"else {",
						"rawDepth = texture2D( tDepth3, screenPosition );",
					"}",
				"#endif",

				"#if DEPTH_PACKING == 1",
					"return unpackRGBAToDepth( rawDepth );",
				"#else",
					"return rawDepth.x;",
				"#endif",

			"}",

			"float scaleDividedByCameraFar;",
			"float minResolutionMultipliedByCameraFar;",
			"float errorCorrectionFactor;",

			"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {",

				"vec3 viewDelta = sampleViewPosition - centerViewPosition;",
				"float viewDistance2 = dot( viewDelta, viewDelta );",

				"return max( ( dot( centerViewNormal, viewDelta ) + centerViewPosition.z * 0.001 ) / ( viewDistance2 + 0.0001 ), 0.0 );// * smoothstep( pow2( occlusionSphereWorldRadius ), 0.0, viewDistance2 );",

			"}",

			/*
			"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {",

				"vec3 viewDelta = sampleViewPosition - centerViewPosition;",
				"float viewDistance2 = dot( viewDelta, viewDelta );",

				"return max( pow3( pow2( occlusionSphereWorldRadius ) - viewDistance2 ), 0.0 ) *",
					"max( ( dot( centerViewNormal, viewDelta ) - 0.01 * occlusionSphereWorldRadius ) / ( viewDistance2 + 0.0001 ), 0.0 );",

			"}",*/

			//"const float maximumScreenRadius = 10.0;",

			"int getMipLevel( const in vec2 occlusionSphereScreenRadius ) {",
	    		"return int( clamp( floor( log2( length( occlusionSphereScreenRadius * size ) ) - 4.0 ), 0.0, 3.0 ) );",
			"}",

			// moving costly divides into consts
			"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );",
			"const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );",

			"float getAmbientOcclusion( const in vec3 centerViewPosition ) {",

				// precompute some variables require in getOcclusion.
				"vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );",

				"vec2 invSize = 1.0 / size;",

				"vec2 occlusionSphereScreenRadius = occlusionSphereWorldRadius * worldToScreenRatio / centerViewPosition.z;",

				// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
				"float random = rand( vUv + randomSeed );",
				"float angle = random * PI2;",
				"float radiusStep = INV_NUM_SAMPLES;",
				"float radius = radiusStep * ( 0.5 + random );",

				"float occlusionSum = 0.0;",

				"for( int i = 0; i < NUM_SAMPLES; i ++ ) {",
					"radius = (float(i) + 0.5) * radiusStep;",
					"vec2 sampleUvOffset = vec2( cos( angle ), sin( angle ) ) * radius * occlusionSphereScreenRadius * 1.0;",

					// round to nearest true sample to avoid misalignments between viewZ and normals, etc.
					"sampleUvOffset = floor( sampleUvOffset * size + vec2( 0.5 ) ) * invSize;",
					"if( sampleUvOffset.x == 0.0 && sampleUvOffset.y == 0.0 ) continue;",

					"angle += ANGLE_STEP;",

					"vec2 sampleUv = vUv + sampleUvOffset;",

					"if( sampleUv.x <= 0.0 || sampleUv.y <= 0.0 || sampleUv.x >= 1.0 || sampleUv.y >= 1.0 ) continue;", // skip points outside of texture.

					//"int depthMipLevel = getMipLevel( radius * occlusionSphereScreenRadius );",
					"float sampleDepth = getDepthMIP( sampleUv, int( 4.0 * radius ) );",
					"if( sampleDepth >= ( 1.0 - EPSILON ) ) {",
						"continue;",
					"}",

					"float sampleViewZ = getViewZ( sampleDepth );",
					"vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );",
					"occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );",

				"}",

				"return occlusionSum * intensity * 2.0 * occlusionSphereWorldRadius / ( float( NUM_SAMPLES ) );",
				//"return occlusionSum * intensity * 5.0 / ( float( NUM_SAMPLES ) * pow( occlusionSphereWorldRadius, 6.0 ) );",

			"}",


			"void main() {",

				"float centerDepth = getDepth( vUv );",
				"if( centerDepth >= ( 1.0 - EPSILON ) ) {",
					"discard;",
				"}",

			/*	"float mipDepth = unpackRGBAToDepth( texture2D( tDepth3, vUv ) );",
				"gl_FragColor.xyz = vec3( (centerDepth - mipDepth) * 50.0 + 0.5 );",
				"gl_FragColor.a = 1.0;",
				"return;",*/

				"float centerViewZ = getViewZ( centerDepth );",
				"vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );",

				"float ambientOcclusion = getAmbientOcclusion( viewPosition );",

				//"gl_FragColor = getDefaultColor( vUv );",

				"gl_FragColor = packDepthToRGBA( centerDepth );",
				"gl_FragColor.x = max( 1.0 - ambientOcclusion, 0.0 );",

			"}"

		].join( "\n" )

	};

	// source: http://g3d.cs.williams.edu/websvn/filedetails.php?repname=g3d&path=%2FG3D10%2Fdata-files%2Fshader%2FAmbientOcclusion%2FAmbientOcclusion_minify.pix
	THREE.SAODepthMinifyShader = {

		blending: THREE.NoBlending,

		defines: {
			"DEPTH_PACKING": 1,
		//	"JITTERED_SAMPLING": 1
		},

		uniforms: {

			"tDepth":	{ type: "t", value: null },
			"cameraNear":   { type: "f", value: 1 },
			"cameraFar":    { type: "f", value: 100 },
			"size": { type: "v2", value: new THREE.Vector2( 256, 256 ) },

		},

		vertexShader: [

			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [


			"#include <common>",
			"#include <packing>",

			"varying vec2 vUv;",

			"uniform sampler2D tDepth;",
			"uniform vec2 size;",
			"uniform float cameraNear;",
			"uniform float cameraFar;",

			"void main() {",

	/*		g3d_FragColor.mask = texelFetch(
				CSZ_buffer,
				clamp(
					ssP * 2 + ivec2(ssP.y & 1, ssP.x & 1),
					ivec2(0),
					textureSize(CSZ_buffer, previousMIPNumber) - ivec2(1)),
				previousMIPNumber).mask;

		 }*/

		 		"vec2 uv = vUv;",

			//	"uv += ( round( vec2( rand( vUv * size ), rand( vUv * size + vec2( 0.333, 2.0 ) ) ) ) - 0.5 ) / size;",
				"vec2 invSize = 0.5 / size;",

				// NOTE: no need for depth decoding if nearest interpolation is used.
			/*	"float viewZ = 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, -1.0 ) ) ), cameraNear, cameraFar );",
				"viewZ += 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, 1.0 ) ) ), cameraNear, cameraFar );",
				"viewZ += 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, 1.0 ) ) ), cameraNear, cameraFar );",
				"viewZ += 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, -1.0 ) ) ), cameraNear, cameraFar );",
				"viewZ *= 0.25;",
				"gl_FragColor = packDepthToRGBA( viewZToPerspectiveDepth( 1.0 / viewZ, cameraNear, cameraFar ) );",*/
				"float depth = unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, -1.0 ) ) );",
				"depth += unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, 1.0 ) ) );",
				"depth += unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, 1.0 ) ) );",
				"depth += unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, -1.0 ) ) );",
				"depth *= 0.25;",
				"gl_FragColor = packDepthToRGBA( depth );",
			"}"

		].join( "\n" )

	};

	THREE.SAOBilaterialFilterShader = {

		blending: THREE.NoBlending,

		defines: {
			"PERSPECTIVE_CAMERA": 1,
			"KERNEL_SAMPLE_RADIUS": 4,
		},

		uniforms: {

			"tAODepth":	{ type: "t", value: null },
			"tAONormal":	{ type: "t", value: null },
			"size": { type: "v2", value: new THREE.Vector2( 256, 256 ) },

			"kernelDirection": { type: "v2", value: new THREE.Vector2( 1, 0 ) },

			"cameraNear":   { type: "f", value: 1 },
			"cameraFar":    { type: "f", value: 100 },
			"edgeSharpness":    { type: "f", value: 3 },
			"packOutput":    { type: "f", value: 1 }

		},

		vertexShader: [

			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"#include <common>",

			"varying vec2 vUv;",

			"uniform sampler2D tAODepth;",
			"uniform sampler2D tAONormal;",
			"uniform vec2 size;",

			"uniform float cameraNear;",
			"uniform float cameraFar;",
			"uniform float edgeSharpness;",
			"uniform int packOutput;",

			"uniform vec2 kernelDirection;",

			"#include <packing>",

			"float getViewZ( const in float depth ) {",

				"#if PERSPECTIVE_CAMERA == 1",
					"return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
				"#else",
					"return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
				"#endif",

			"}",

			"void addTapInfluence( const in vec2 tapUv, const in vec3 centerNormal, const in float centerViewZ, const in float kernelWeight, inout float aoSum, inout float weightSum ) {",

				"vec4 depthTexel = texture2D( tAODepth, tapUv );",
				"float ao = depthTexel.r;",
				"depthTexel.r = 1.0;",
				"float depth = unpackRGBAToDepth( depthTexel );",

				"if( depth >= ( 1.0 - EPSILON ) ) {",
					"return;",
				"}",

				"float tapViewZ = -getViewZ( depth );",
				"float depthWeight = max(0.0, 1.0 - (edgeSharpness * 20.0) * abs(tapViewZ - centerViewZ));",

				"vec3 normal = unpackRGBToNormal(texture2D(tAONormal, tapUv).rgb);",
				"float normalCloseness = dot(normal, centerNormal);",
				"float k_normal = 4.0;",
				"float normalError = (1.0 - pow4( normalCloseness )) * k_normal;",
				"float normalWeight = max((1.0 - edgeSharpness * normalError), 0.00);",

				"float tapWeight = kernelWeight * ( depthWeight + normalWeight );",

				"aoSum += ao * tapWeight;",
				"weightSum += tapWeight;",
			"}",

			"float normpdf(in float x, in float sigma) {",
				"return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;",
			"}",

			"void main() {",

				"vec4 depthTexel = texture2D( tAODepth, vUv );",
				"float ao = depthTexel.r;",
				"depthTexel.r = 1.0;",
				"float depth = unpackRGBAToDepth( depthTexel );",
				"if( depth >= ( 1.0 - EPSILON ) ) {",
					"discard;",
				"}",

				"float centerViewZ = -getViewZ( depth );",

				"float weightSum = normpdf(0.0, 5.0) + 0.1;",
				"float aoSum = ao * weightSum;",

				"vec2 uvIncrement = ( kernelDirection / size );",

				"vec2 rTapUv = vUv, lTapUv = vUv;",
				"vec3 normalCenter = unpackRGBToNormal(texture2D(tAONormal, vUv).rgb);",

				"for( int i = 1; i <= KERNEL_SAMPLE_RADIUS; i ++ ) {",

					"float kernelWeight = normpdf(float(i), 5.0) + 0.1;",

					"rTapUv += uvIncrement;",
					"addTapInfluence( rTapUv, normalCenter, centerViewZ, kernelWeight, aoSum, weightSum );",

					"lTapUv -= uvIncrement;",
					"addTapInfluence( lTapUv, normalCenter, centerViewZ, kernelWeight, aoSum, weightSum );",

				"}",

				"ao = aoSum / weightSum;",
				"if( packOutput == 1 ) {",
					"gl_FragColor = depthTexel;",
					"gl_FragColor.r = ao;",
				"}",
				"else {",
					"gl_FragColor = vec4( vec3( ao ), 1.0 );",
				"}",

			"}"

		].join( "\n" )

	};

	// File:examples/js/shaders/BlurShader.js

	/**
	 * @author bhouston / http://clara.io
	 *
	 * For a horizontal blur, use X_STEP 1, Y_STEP 0
	 * For a vertical blur, use X_STEP 0, Y_STEP 1
	 *
	 */

	THREE.BlurShader = {

		defines: {

			"KERNEL_RADIUS": 4

		},

		uniforms: {

			"tDiffuse":         { type: "t", value: null },
			"size":             { type: "v2", value: new THREE.Vector2( 512, 512 ) },
			"sampleUvOffsets":  { type: "v2v", value: [ new THREE.Vector2( 0, 0 ) ] },
			"sampleWeights":    { type: "1fv", value: [ 1.0 ] },

		},

		vertexShader: [

			"#include <common>",

			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform sampler2D tDiffuse;",
			"uniform vec2 size;",

			"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];",
			"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];",

			"varying vec2 vUv;",

			"void main() {",

				"vec2 invSize = 1.0 / size;",

				"float weightSum = sampleWeights[0];",
				"vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;",

				"for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {",

					"float weight = sampleWeights[i];",
					"vec2 sampleUvOffset = sampleUvOffsets[i] * invSize;",
					"diffuseSum += ( texture2D( tDiffuse, vUv + sampleUvOffset ) + texture2D( tDiffuse, vUv - sampleUvOffset ) ) * weight;",
					"weightSum += 2.0 * weight;",

				"}",

				"gl_FragColor =diffuseSum / weightSum;",

			"}"

		].join( "\n" )

	};


	THREE.BlurShaderUtils = {

		createSampleWeights: function( kernelRadius, stdDev ) {

			var gaussian = function( x, stdDev ) {
				return Math.exp( - ( x*x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );
			};

			var weights = [];

			for( var i = 0; i <= kernelRadius; i ++ ) {
				weights.push( gaussian( i, stdDev ) );
			}

			return weights;
		},

		createSampleOffsets: function( kernelRadius, uvIncrement ) {

			var offsets = [];

			for( var i = 0; i <= kernelRadius; i ++ ) {
				offsets.push( uvIncrement.clone().multiplyScalar( i ) );
			}

			return offsets;

		},

		configure: function( material, kernelRadius, stdDev, uvIncrement ) {

			kernelRadius = kernelRadius | 0;

			if( ( material.defines[ 'KERNEL_RADIUS' ] !== kernelRadius ) || ( material.stdDev != stdDev ) ) {

				material.defines[ 'KERNEL_RADIUS' ] = kernelRadius;
				material.uniforms[ 'sampleUvOffsets' ].value = THREE.BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );
				material.uniforms[ 'sampleWeights' ].value = THREE.BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );

				material.uvIncrement = uvIncrement;
				material.stdDev = stdDev;

				material.needsUpdate = true;
			}

		}

	};

	// File:examples/js/shaders/LuminosityHighPassShader.js

	/**
	 * @author bhouston / http://clara.io/
	 *
	 * Luminosity
	 * http://en.wikipedia.org/wiki/Luminosity
	 */

	THREE.LuminosityHighPassShader = {

	  shaderID: "luminosityHighPass",

		uniforms: {

			"tDiffuse": { type: "t", value: null },
			"luminosityThreshold": { type: "f", value: 1.0 },
			"smoothWidth": { type: "f", value: 1.0 },
			"defaultColor": { type: "c", value: new THREE.Color( 0x000000 ) },
			"defaultOpacity":  { type: "f", value: 0.0 }

		},

		vertexShader: [

			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform sampler2D tDiffuse;",
			"uniform vec3 defaultColor;",
			"uniform float defaultOpacity;",
			"uniform float luminosityThreshold;",
			"uniform float smoothWidth;",

			"varying vec2 vUv;",

			"void main() {",

				"vec4 texel = texture2D( tDiffuse, vUv );",

				"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

				"float v = dot( texel.xyz, luma );",

				"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );",

				"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );",

				"gl_FragColor = mix( outputColor, texel, alpha );",

			"}"

		].join("\n")

	};

	// File:examples/js/postprocessing/EffectComposer.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.EffectComposer = function ( renderer, renderTarget ) {

		this.renderer = renderer;

		if ( renderTarget === undefined ) {

			var parameters = {
				minFilter: THREE.LinearFilter,
				magFilter: THREE.LinearFilter,
				format: THREE.RGBAFormat,
				stencilBuffer: false
			};
			var size = renderer.getSize();
			renderTarget = new THREE.WebGLRenderTarget( size.width, size.height, parameters );
			renderTarget.texture.name = "EffectComposer.rt1";
		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.renderTarget2.texture.name = "EffectComposer.rt2";

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		this.passes = [];

		if ( THREE.CopyShader === undefined )
			console.error( "THREE.EffectComposer relies on THREE.CopyShader" );

		this.copyPass = new THREE.ShaderPass( THREE.CopyShader );

	};

	Object.assign( THREE.EffectComposer.prototype, {

		swapBuffers: function() {

			var tmp = this.readBuffer;
			this.readBuffer = this.writeBuffer;
			this.writeBuffer = tmp;

		},

		addPass: function ( pass ) {

			this.passes.push( pass );

			var size = this.renderer.getSize();
			pass.setSize( size.width, size.height );

		},

		insertPass: function ( pass, index ) {

			this.passes.splice( index, 0, pass );

		},

		render: function ( delta ) {

			var maskActive = false;

			var pass, i, il = this.passes.length;

			for ( i = 0; i < il; i ++ ) {

				pass = this.passes[ i ];

				if ( pass.enabled === false ) continue;

				pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

				if ( pass.needsSwap ) {

					if ( maskActive ) {

						var context = this.renderer.context;

						context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

						this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

						context.stencilFunc( context.EQUAL, 1, 0xffffffff );

					}

					this.swapBuffers();

				}

				if ( THREE.MaskPass !== undefined ) {

					if ( pass instanceof THREE.MaskPass ) {

						maskActive = true;

					} else if ( pass instanceof THREE.ClearMaskPass ) {

						maskActive = false;

					}

				}

			}

		},

		reset: function ( renderTarget ) {

			if ( renderTarget === undefined ) {

				var size = this.renderer.getSize();

				renderTarget = this.renderTarget1.clone();
				renderTarget.setSize( size.width, size.height );

			}

			this.renderTarget1.dispose();
			this.renderTarget2.dispose();
			this.renderTarget1 = renderTarget;
			this.renderTarget2 = renderTarget.clone();

			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;

		},

		setSize: function ( width, height ) {

			this.renderTarget1.setSize( width, height );
			this.renderTarget2.setSize( width, height );

			for ( var i = 0; i < this.passes.length; i ++ ) {

				this.passes[i].setSize( width, height );

			}

		}

	} );


	THREE.Pass = function () {

		// if set to true, the pass is processed by the composer
		this.enabled = true;

		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;

		// if set to true, the pass clears its buffer before rendering
		this.clear = false;

		// if set to true, the result of the pass is rendered to screen
		this.renderToScreen = false;

	};

	Object.assign( THREE.Pass.prototype, {

		setSize: function( width, height ) {},

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			console.error( "THREE.Pass: .render() must be implemented in derived pass." );

		}

	} );

	// File:examples/js/postprocessing/RenderPass.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

		THREE.Pass.call( this );

		this.scene = scene;
		this.camera = camera;

		this.overrideMaterial = overrideMaterial;

		this.clearColor = clearColor;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

		this.clear = true;
		this.clearDepth = false;
		this.needsSwap = false;

	};

	THREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.RenderPass,

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			var oldAutoClear = renderer.autoClear;
			renderer.autoClear = false;

			this.scene.overrideMaterial = this.overrideMaterial;

			var oldClearColor, oldClearAlpha;

			if ( this.clearColor !== undefined ) {

				oldClearColor = renderer.getClearColor();
				oldClearAlpha = renderer.getClearAlpha();

				renderer.setClearColor( this.clearColor, this.clearAlpha );

			}

			if ( this.clearDepth ) {

				renderer.clearDepth();

			}

			renderer.renderOverride( this.overrideMaterial, this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );

			if ( this.clearColor ) {

				renderer.setClearColor( oldClearColor, oldClearAlpha );

			}

			this.scene.overrideMaterial = null;
			renderer.autoClear = oldAutoClear;

		}

	} );

	// File:examples/js/postprocessing/MaskPass.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MaskPass = function ( scene, camera ) {

		THREE.Pass.call( this );

		this.scene = scene;
		this.camera = camera;

		this.clear = true;
		this.needsSwap = false;

		this.inverse = false;

	};

	THREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.MaskPass,

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			var context = renderer.context;
			var state = renderer.state;

			// don't update color or depth

			state.buffers.color.setMask( false );
			state.buffers.depth.setMask( false );

			// lock buffers

			state.buffers.color.setLocked( true );
			state.buffers.depth.setLocked( true );

			// set up stencil

			var writeValue, clearValue;

			if ( this.inverse ) {

				writeValue = 0;
				clearValue = 1;

			} else {

				writeValue = 1;
				clearValue = 0;

			}

			state.buffers.stencil.setTest( true );
			state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
			state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
			state.buffers.stencil.setClear( clearValue );

			// draw into the stencil buffer

			renderer.render( this.scene, this.camera, readBuffer, this.clear );
			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

			// unlock color and depth buffer for subsequent rendering

			state.buffers.color.setLocked( false );
			state.buffers.depth.setLocked( false );

			// only render where stencil is set to 1

			state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
			state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );

		}

	} );


	THREE.ClearMaskPass = function () {

		THREE.Pass.call( this );

		this.needsSwap = false;

	};

	THREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );

	Object.assign( THREE.ClearMaskPass.prototype, {

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			renderer.state.buffers.stencil.setTest( false );

		}

	} );

	// File:examples/js/postprocessing/ShaderPass.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ShaderPass = function ( shader, textureID ) {

		THREE.Pass.call( this );

		this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

		if ( shader instanceof THREE.ShaderMaterial ) {

			this.uniforms = shader.uniforms;

			this.material = shader;

		} else if ( shader ) {

			this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			this.material = new THREE.ShaderMaterial( {

				defines: shader.defines || {},
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader

			} );

		}

		this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		this.scene = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
		this.quad.frustumCulled = false; // Avoid getting clipped
		this.scene.add( this.quad );

	};

	THREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.ShaderPass,

		render: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			if ( this.uniforms[ this.textureID ] ) {

				this.uniforms[ this.textureID ].value = readBuffer.texture;

			}

			if ( this.renderToScreen ) {

				renderer.renderPass( this.material );

			} else {

				renderer.renderPass( this.material, writeBuffer, this.clear );

			}

		}

	} );

	// File:examples/js/postprocessing/SAOPass.js

	/**
	*
	* Scalable Ambient Occlusion
	*
	* @author bhouston / http://clara.io/
	*
	*
	*/

	THREE.SAOPass = function ( scene, camera ) {

		THREE.Pass.call( this );

		this.scene = scene;
		this.camera = camera;

		this.intensity = 0.5;
		this.implicitNormals = false; // explicit normals requires or there are artifacts on mobile.
		this.occlusionSphereWorldRadius = 20;
		this.blurEnabled = true;
		this.outputOverride = null; // 'beauty', 'depth', 'sao'
		this.depthMIPs = false;
		this.downSamplingRatio = 2;
		this.blurKernelSize = (this.downSamplingRatio === 1) ? 8 : 6;
		this.edgeSharpness = 1;

		/*
		if ( false && renderer.extensions.get('WEBGL_depth_texture') ) {

			console.log( "using depth extension");

			this.depthTexture = optionalBuffers.depthTexture || new THREE.DepthTexture();
			this.depthTexture.type = isWebGL2 ? THREE.FloatType : THREE.UnsignedShortType;
			this.depthTexture.minFilter = THREE.NearestFilter;
			this.depthTexture.maxFilter = THREE.NearestFilter;

			this.beautyRenderTarget.depthBuffer = true;
			this.beautyRenderTarget.depthTexture = this.depthTexture;

		}*/

		this.depthMaterial = new THREE.MeshDepthMaterial();
		this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
		this.depthMaterial.blending = THREE.NoBlending;
		this.depthMaterial.side = THREE.DoubleSide;

		this.normalMaterial = new THREE.MeshNormalMaterial();
		this.normalMaterial.side = this.depthMaterial.side; // both normal and depth materials bot need to render with the same sidedness

		if ( THREE.SAOShader === undefined )	console.error( "THREE.SAOPass relies on THREE.SAOShader" );
		if ( THREE.CopyShader === undefined )	console.error( "THREE.SAOPass relies on THREE.CopyShader" );

		this.depthMinifyMaterial = new THREE.ShaderMaterial( THREE.SAODepthMinifyShader );
		this.depthMinifyMaterial.uniforms = THREE.UniformsUtils.clone( this.depthMinifyMaterial.uniforms );
		this.depthMinifyMaterial.defines = Object.assign( {}, this.depthMinifyMaterial.defines );
		this.depthMinifyMaterial.blending = THREE.NoBlending;

		this.saoMaterial = new THREE.ShaderMaterial( THREE.SAOShader );
		this.saoMaterial.uniforms = THREE.UniformsUtils.clone( this.saoMaterial.uniforms );
		this.saoMaterial.defines = Object.assign( {}, this.saoMaterial.defines );
		this.saoMaterial.defines[ 'DIFFUSE_TEXTURE' ] = 0;
		this.saoMaterial.defines[ 'NORMAL_TEXTURE' ] = this.implicitNormals ? 0 : 1;
		this.saoMaterial.defines[ 'MODE' ] = 2;

		this.bilateralFilterMaterial = new THREE.ShaderMaterial( THREE.SAOBilaterialFilterShader );
		this.bilateralFilterMaterial.uniforms = THREE.UniformsUtils.clone( this.bilateralFilterMaterial.uniforms );
		this.bilateralFilterMaterial.defines = Object.assign( {}, this.bilateralFilterMaterial.defines );
		this.bilateralFilterMaterial.blending = THREE.NoBlending;
		this.bilateralFilterMaterial.premultipliedAlpha = true;

		this.bilateralUpsamplerMaterial = this.getBilateralUpsamplerMaterial();

		this.copyMaterial = new THREE.ShaderMaterial( THREE.CopyShader );
		this.copyMaterial.uniforms = THREE.UniformsUtils.clone( this.copyMaterial.uniforms );
		this.copyMaterial.uniforms['opacity'].value = 1.0;
		this.copyMaterial.blending = THREE.NoBlending;
		this.copyMaterial.premultipliedAlpha = true;
		this.copyMaterial.transparent = true;
		this.copyMaterial.depthTest = false;
		this.copyMaterial.depthWrite = false;

	};

	THREE.SAOPass.prototype = {

		dispose: function() {

			if( this.saoRenderTarget ) {
				this.saoRenderTarget.dispose();
				this.saoRenderTarget = null;
			}
			if( this.blurIntermediateRenderTarget ) {
				this.blurIntermediateRenderTarget.dispose();
				this.blurIntermediateRenderTarget = null;
			}
			if( this.depthRenderTarget ) {
				this.depthRenderTarget.dispose();
				this.depthRenderTarget = null;
			}
			if( this.depth1RenderTarget ) {
				this.depth1RenderTarget.dispose();
				this.depth1RenderTarget = null;
			}
			if( this.depth2RenderTarget ) {
				this.depth2RenderTarget.dispose();
				this.depth2RenderTarget = null;
			}
			if( this.depth3RenderTarget ) {
				this.depth3RenderTarget.dispose();
				this.depth3RenderTarget = null;
			}
			if( this.normalRenderTarget ) {
				this.normalRenderTarget.dispose();
				this.normalRenderTarget = null;
			}
			if( this.normalRenderTargetFullRes ) {
				this.normalRenderTargetFullRes.dispose();
				this.normalRenderTargetFullRes = null;
			}
			if( this.depthRenderTargetFullRes ) {
				this.depthRenderTargetFullRes.dispose();
				this.depthRenderTargetFullRes = null;
			}
			if( this.saoRenderTargetFullRes ) {
				this.saoRenderTargetFullRes.dispose();
				this.saoRenderTargetFullRes = null;
			}
		},

		setSize: function ( width, height ) {

			if( this.saoRenderTargetFullRes ) this.saoRenderTargetFullRes.setSize( width, height );
			if( this.depthRenderTargetFullRes ) this.depthRenderTargetFullRes.setSize( width, height );
			if( this.normalRenderTargetFullRes ) this.normalRenderTargetFullRes.setSize( width, height );
			width = Math.ceil( width / this.downSamplingRatio );
			height = Math.ceil( height / this.downSamplingRatio );
			if( this.saoRenderTarget ) this.saoRenderTarget.setSize( width, height );
			if( this.blurIntermediateRenderTarget ) this.blurIntermediateRenderTarget.setSize( width, height );
			if( this.depthRenderTarget ) this.depthRenderTarget.setSize( width, height );
			if( this.depth1RenderTarget ) this.depth1RenderTarget.setSize( Math.ceil( width / 2 ), Math.ceil( height / 2 ) );
			if( this.depth2RenderTarget ) this.depth2RenderTarget.setSize( Math.ceil( width / 4 ), Math.ceil( height / 4 ) );
			if( this.depth3RenderTarget ) this.depth3RenderTarget.setSize( Math.ceil( width / 8 ), Math.ceil( height / 8 ) );
			if( this.normalRenderTarget ) this.normalRenderTarget.setSize( width, height );

			this.saoMaterial.uniforms[ 'size' ].value.set( width, height );
			this.bilateralFilterMaterial.uniforms[ 'size' ].value.set( width, height );
			//console.log( 'downsampledsize: ', width, height );
		},

		updateParameters: function( camera ) {

			var vSizeAt1M = 1 / ( Math.tan( THREE.Math.DEG2RAD * camera.fov * 0.5 ) * 2 );
			var sizeAt1M = new THREE.Vector2( vSizeAt1M / camera.aspect, vSizeAt1M );

			this.saoMaterial.uniforms['worldToScreenRatio'].value = sizeAt1M;
			this.saoMaterial.uniforms['intensity'].value = this.intensity;
			this.saoMaterial.uniforms['occlusionSphereWorldRadius'].value = this.occlusionSphereWorldRadius;

			this.depthMinifyMaterial.uniforms[ 'cameraNear' ].value = camera.near;
			this.depthMinifyMaterial.uniforms[ 'cameraFar' ].value = camera.far;

			this.saoMaterial.uniforms[ 'cameraNear' ].value = camera.near;
			this.saoMaterial.uniforms[ 'cameraFar' ].value = camera.far;
			this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = camera.projectionMatrix;
			this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( camera.projectionMatrix );

			this.bilateralFilterMaterial.uniforms[ "cameraNear" ].value = camera.near;
			this.bilateralFilterMaterial.uniforms[ "cameraFar" ].value = camera.far;
		},

		render: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			var width = readBuffer.width, height = readBuffer.height;

			width = Math.ceil( width / this.downSamplingRatio );
			height = Math.ceil( height / this.downSamplingRatio );

			var depthTexture = ( readBuffer.depthBuffer && readBuffer.depthTexture ) ? readBuffer.depthTexture : null;

			if ( ! this.saoRenderTarget ) {

				this.saoRenderTarget = new THREE.WebGLRenderTarget( width, height,
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.saoRenderTargetFullRes = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
						{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.blurIntermediateRenderTarget = new THREE.WebGLRenderTarget( width, height,
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.depth1RenderTarget = new THREE.WebGLRenderTarget( Math.ceil( width / 2 ), Math.ceil( height / 2 ),
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.depth2RenderTarget = new THREE.WebGLRenderTarget( Math.ceil( width / 4 ), Math.ceil( height / 4 ),
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.depth3RenderTarget = new THREE.WebGLRenderTarget( Math.ceil( width / 8 ), Math.ceil( height / 8 ),
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.normalRenderTarget = new THREE.WebGLRenderTarget( width, height,
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.normalRenderTargetFullRes = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
			}

			if( ! depthTexture && ! this.depthRenderTarget ) {

				this.depthRenderTarget = new THREE.WebGLRenderTarget( width, height,
					{ minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
				this.depthRenderTargetFullRes = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
					{ minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );

			}

			this.updateParameters( this.camera );

			var clearColor = renderer.getClearColor(), clearAlpha = renderer.getClearAlpha(), autoClear = renderer.autoClear;
			renderer.autoClear = false;

			if( ! this.renderToScreen ) {

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = readBuffer.texture;
				this.copyMaterial.blending = THREE.NoBlending;

				renderer.renderPass( this.copyMaterial, writeBuffer, true );

			}

			var depthPackingMode = 0;

			if( ! depthTexture ) {

				var oldClearColor = renderer.getClearColor(), oldClearAlpha = renderer.getClearAlpha();
				renderer.setClearColor( 0xffffff, 1.0 );

				renderer.renderOverride( this.depthMaterial, this.scene, this.camera, this.depthRenderTarget, true );

				renderer.setClearColor( 0xffffff, 1.0 );

				if( this.downSamplingRatio !== 1.0 ) {

					renderer.renderOverride( this.depthMaterial, this.scene, this.camera, this.depthRenderTargetFullRes, true );

					renderer.setClearColor( oldClearColor, oldClearAlpha );

				}
				depthTexture = this.depthRenderTarget.texture;
				depthPackingMode = 1;

			}

			if( this.depthMIPs ) {

				this.depthMinifyMaterial.uniforms['tDepth'].value = depthTexture;
				this.depthMinifyMaterial.uniforms['size'].value.set( width, height );
				renderer.renderPass( this.depthMinifyMaterial, this.depth1RenderTarget, true );

				this.depthMinifyMaterial.uniforms['tDepth'].value = this.depth1RenderTarget.texture;
				this.depthMinifyMaterial.uniforms['size'].value.set( Math.ceil( width / 2 ), Math.ceil( height / 2 ) );
				renderer.renderPass( this.depthMinifyMaterial, this.depth2RenderTarget, true );

				this.depthMinifyMaterial.uniforms['tDepth'].value = this.depth2RenderTarget.texture;
				this.depthMinifyMaterial.uniforms['size'].value.set( Math.ceil( width / 4 ), Math.ceil( height / 4 ) );
				renderer.renderPass( this.depthMinifyMaterial, this.depth3RenderTarget, true );

			}

			if( this.outputOverride === "depth" ) {

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = depthTexture;
				this.copyMaterial.blending = THREE.NoBlending;

				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;

			}
			if( this.outputOverride === "depth1" ) {

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.depth1RenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;

				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;

			}
			if( this.outputOverride === "depth2" ) {

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.depth2RenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;

				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;

			}
			if( this.outputOverride === "depth3" ) {

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.depth3RenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;

				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;

			}

			if( ! this.implicitNormals ) {

				var oldClearColor = renderer.getClearColor(), oldClearAlpha = renderer.getClearAlpha();
				renderer.setClearColor( new THREE.Color( 0.5, 0.5, 1.0 ), 1.0 );

				renderer.renderOverride( this.normalMaterial, this.scene, this.camera, this.normalRenderTarget, true );

				if( this.downSamplingRatio !== 1.0 ) {

						renderer.setClearColor( new THREE.Color( 0.5, 0.5, 1.0 ), 1.0 );

						renderer.renderOverride( this.normalMaterial, this.scene, this.camera, this.normalRenderTargetFullRes, true );

				}

				renderer.setClearColor( oldClearColor, oldClearAlpha );

			}

			if( this.outputOverride === "normal" ) {

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;

				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : this.renderToScreen ? null : writeBuffer, true );
				return;

			}

			this.saoMaterial.defines[ 'DEPTH_PACKING' ] = depthPackingMode;
			this.saoMaterial.defines[ 'DEPTH_MIPS' ] = this.depthMIPs ? 1 : 0;
			this.saoMaterial.uniforms[ "tNormal" ].value = this.normalRenderTarget.texture;
			this.saoMaterial.uniforms[ "tDepth" ].value = depthTexture;
			if( this.depthMIPs ) {

				this.saoMaterial.uniforms[ "tDepth1" ].value = this.depth1RenderTarget.texture;
				this.saoMaterial.uniforms[ "tDepth2" ].value = this.depth2RenderTarget.texture;
				this.saoMaterial.uniforms[ "tDepth3" ].value = this.depth3RenderTarget.texture;
			}

			var oldClearColor = renderer.getClearColor(), oldClearAlpha = renderer.getClearAlpha();
			renderer.setClearColor( 0xffffff, 1.0 );

			renderer.renderPass( this.saoMaterial, this.saoRenderTarget, true ); // , 0xffffff, 0.0, "sao"

			if( this.blurEnabled ) {

				this.bilateralFilterMaterial.defines[ 'KERNEL_SAMPLE_RADIUS' ] = this.blurKernelSize;
				this.bilateralFilterMaterial.uniforms[ "tAODepth" ].value = this.saoRenderTarget.texture;
				this.bilateralFilterMaterial.uniforms[ "tAONormal" ].value = this.normalRenderTarget.texture;
				this.bilateralFilterMaterial.uniforms[ "kernelDirection" ].value = new THREE.Vector2( 1, 0 );
				this.bilateralFilterMaterial.uniforms[ "packOutput" ].value = 1;
				this.bilateralFilterMaterial.uniforms[ 'edgeSharpness' ].value = this.edgeSharpness;

				renderer.renderPass( this.bilateralFilterMaterial, this.blurIntermediateRenderTarget, true ); // , 0xffffff, 0.0, "sao vBlur"

				this.bilateralFilterMaterial.uniforms[ "tAODepth" ].value = this.blurIntermediateRenderTarget.texture;
				this.bilateralFilterMaterial.uniforms[ "kernelDirection" ].value = new THREE.Vector2( 0, 1 );
				this.bilateralFilterMaterial.uniforms[ "packOutput" ].value = 0;

				renderer.renderPass( this.bilateralFilterMaterial, this.saoRenderTarget, true ); // 0xffffff, 0.0, "sao hBlur"

			}
			if(this.downSamplingRatio > 1.0)
			{
				//Bilateral Up sampler
				this.bilateralUpsamplerMaterial.uniforms["inputTexture"].value = this.saoRenderTarget.texture;
				this.bilateralUpsamplerMaterial.uniforms["NormalTextureFullRes"].value = this.normalRenderTargetFullRes.texture;
				this.bilateralUpsamplerMaterial.uniforms["DepthTextureFullRes"].value = this.depthRenderTargetFullRes.texture;
				this.bilateralUpsamplerMaterial.uniforms["NormalTextureHalfRes"].value = this.normalRenderTarget.texture;
				this.bilateralUpsamplerMaterial.uniforms["DepthTextureHalfRes"].value = this.depthRenderTarget.texture;
				this.bilateralUpsamplerMaterial.uniforms["texSize"].value = new THREE.Vector2(this.saoRenderTarget.width, this.saoRenderTarget.height);
				this.bilateralUpsamplerMaterial.uniforms["cameraNearFar"].value = new THREE.Vector2(this.camera.near, this.camera.far);
				renderer.renderPass( this.bilateralUpsamplerMaterial, this.saoRenderTargetFullRes, true ); // 0xffffff, 0.0, "sao hBlur"

			}
			renderer.setClearColor( oldClearColor, oldClearAlpha );

			if( this.outputOverride === "sao" ) {

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.downSamplingRatio > 1.0 ? this.saoRenderTargetFullRes.texture
				: this.saoRenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;

				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;

			}

			renderer.autoClear = false;

			this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.downSamplingRatio > 1.0 ? this.saoRenderTargetFullRes.texture
			: this.saoRenderTarget.texture;
			this.copyMaterial.blending = THREE.MultiplyBlending;
			this.copyMaterial.premultipliedAlpha = true;

			renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, false );

			renderer.autoClear = autoClear;
			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha );

		},

		getBilateralUpsamplerMaterial: function(kernelRadius) {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"inputTexture": { value: null },
					"NormalTextureFullRes": { value: null },
					"DepthTextureFullRes": { value: null },
					"NormalTextureHalfRes": { value: null },
					"DepthTextureHalfRes": { value: null },
					"texSize": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
					"cameraNearFar": 	{ value: new THREE.Vector2( 0.5, 0.5 ) },
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\n\
					#include <packing>\n\
					varying vec2 vUv;\n\
					uniform sampler2D inputTexture;\n\
					uniform sampler2D NormalTextureFullRes;\n\
					uniform sampler2D DepthTextureFullRes;\n\
					uniform sampler2D NormalTextureHalfRes;\n\
					uniform sampler2D DepthTextureHalfRes;\n\
					uniform vec2 texSize;\
					uniform vec2 cameraNearFar;\
					\
					void main()\
					{\
						vec2 uvOffsets[4];\
						uvOffsets[0] = vUv + vec2(0.0, 1.0)/texSize;\
						uvOffsets[1] = vUv + vec2(1.0, 0.0)/texSize;\
						uvOffsets[2] = vUv + vec2(-1.0, 0.0)/texSize;\
						uvOffsets[3] = vUv + vec2(0.0, -1.0)/texSize;\
						\
						float depth_weights[4];\
						float depth_hires = unpackRGBAToDepth(texture2D(DepthTextureFullRes, vUv));\
						depth_hires = -perspectiveDepthToViewZ(depth_hires, cameraNearFar.x, cameraNearFar.y);\
						if(depth_hires == 1.0)\
							discard;\
						float depth_coarse1 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[0]));\
						depth_coarse1 = -perspectiveDepthToViewZ(depth_coarse1, cameraNearFar.x, cameraNearFar.y);\
						depth_weights[0] = 1.0 / (0.001 + abs(depth_hires-depth_coarse1));\
						float depth_coarse2 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[1]));\
						depth_coarse2 = -perspectiveDepthToViewZ(depth_coarse2, cameraNearFar.x, cameraNearFar.y);\
						depth_weights[1] = 1.0 / (0.001 + abs(depth_hires-depth_coarse2));\
						float depth_coarse3 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[2]));\
						depth_coarse3 = -perspectiveDepthToViewZ(depth_coarse3, cameraNearFar.x, cameraNearFar.y);\
						depth_weights[2] = 1.0 / (0.001 + abs(depth_hires-depth_coarse3));\
						float depth_coarse4 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[3]));\
						depth_coarse4 = -perspectiveDepthToViewZ(depth_coarse4, cameraNearFar.x, cameraNearFar.y);\
						depth_weights[3] = 1.0 / (0.001 + abs(depth_hires-depth_coarse4));\
						\
						float norm_weights[4];\
						vec3 norm_fullRes = unpackRGBToNormal(texture2D(NormalTextureFullRes, vUv).rgb);\
						vec3 norm_coarse1 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[0]).rgb);\
						norm_weights[0] = pow(abs(dot(norm_coarse1, norm_fullRes)), 32.0);\
						vec3 norm_coarse2 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[1]).rgb);\
						norm_weights[1] = pow(abs(dot(norm_coarse2, norm_fullRes)), 32.0);\
						vec3 norm_coarse3 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[2]).rgb);\
						norm_weights[2] = pow(abs(dot(norm_coarse3, norm_fullRes)), 32.0);\
						vec3 norm_coarse4 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[3]).rgb);\
						norm_weights[3] = pow(abs(dot(norm_coarse4, norm_fullRes)), 32.0);\
						\
						vec3 colorOut = vec3(0.0);\
						float weight_sum = 0.0;\
						float weight = norm_weights[0] * depth_weights[0];\
						colorOut += texture2D(inputTexture, uvOffsets[0]).rgb*weight;\
						weight_sum += weight;\
					  weight = norm_weights[1] * depth_weights[1];\
						colorOut += texture2D(inputTexture, uvOffsets[1]).rgb*weight;\
						weight_sum += weight;\
					  weight = norm_weights[2] * depth_weights[2];\
						colorOut += texture2D(inputTexture, uvOffsets[2]).rgb*weight;\
						weight_sum += weight;\
					  weight = norm_weights[3] * depth_weights[3];\
						colorOut += texture2D(inputTexture, uvOffsets[3]).rgb*weight;\
						weight_sum += weight;\
						colorOut /= weight_sum;\
						gl_FragColor = vec4(colorOut, 1.0);\
					}"
			} );
		}

	};

	// File:examples/js/postprocessing/SSAARenderPass.js

	/**
	*
	* Supersample Anti-Aliasing Render Pass
	*
	* @author bhouston / http://clara.io/
	*
	* This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.
	*
	* References: https://en.wikipedia.org/wiki/Supersampling
	*
	*/

	THREE.SSAARenderPass = function ( scene, camera, clearColor, clearAlpha ) {

		THREE.Pass.call( this );

		this.scene = scene;
		this.camera = camera;

		this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.
		this.unbiased = true;

		this.needsSwap = false;

		// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.
		this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

		if ( THREE.CopyShader === undefined ) console.error( "THREE.SSAARenderPass relies on THREE.CopyShader" );

		this.overMaterial = new THREE.ShaderMaterial( THREE.CopyShader );
		this.overMaterial.uniforms = THREE.UniformsUtils.clone( this.overMaterial.uniforms );
		this.overMaterial.blending = THREE.NormalBlending;
		this.overMaterial.premultipliedAlpha = true;
		this.overMaterial.transparent = true;
		this.overMaterial.depthTest = false;
		this.overMaterial.depthWrite = false;

		this.addMaterial = new THREE.ShaderMaterial( THREE.CopyShader );
		this.addMaterial.uniforms = THREE.UniformsUtils.clone( this.addMaterial.uniforms );
		this.addMaterial.blending = THREE.AdditiveBlending;
		this.addMaterial.premultipliedAlpha = true;
		this.addMaterial.transparent = true;
		this.addMaterial.depthTest = false;
		this.addMaterial.depthWrite = false;

		this.camera2 = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		this.scene2	= new THREE.Scene();
		this.quad2 = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), this.copyMaterial );
		this.quad2.frustumCulled = false; // Avoid getting clipped
		this.scene2.add( this.quad2 );

	};

	THREE.SSAARenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.SSAARenderPass,

		dispose: function() {

			if ( this.sampleRenderTarget ) {
				this.sampleRenderTarget.dispose();
				this.sampleRenderTarget = null;
			}
			if ( this.accumulateRenderTarget ) {
				this.accumulateRenderTarget.dispose();
				this.accumulateRenderTarget = null;
			}

		},

		setSize: function ( width, height ) {

			if ( this.sampleRenderTarget ) this.sampleRenderTarget.setSize( width, height );
			if ( this.accumulateRenderTarget ) this.accumulateRenderTarget.setSize( width, height );

		},

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			if ( ! this.sampleRenderTarget ) {

				this.sampleRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
					{ minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat, name: "SSAARenderPass.sample" } );
				this.accumulateRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
					{ minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat, name: "SSAARenderPass.accumulation" } );

			}

			var jitterOffsets = THREE.SSAARenderPass.JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];

			var autoClear = renderer.autoClear;
			renderer.autoClear = false;

			var oldClearColor = renderer.getClearColor().getHex();
			var oldClearAlpha = renderer.getClearAlpha();

			var baseSampleWeight = 1.0 / jitterOffsets.length;
			var roundingRange = 1 / 32;

			this.addMaterial.uniforms[ "tDiffuse" ].value = this.sampleRenderTarget.texture;


			var width = readBuffer.width, height = readBuffer.height;

			renderer.setClearColor( 0x000000, 0 );

			// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
			for ( var i = 0; i < jitterOffsets.length; i ++ ) {

				var jitterOffset = jitterOffsets[i];
				if ( this.camera.setViewOffset ) {
					this.camera.setViewOffset( width, height,
						jitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625,   // 0.0625 = 1 / 16
						width, height );
				}

				var sampleWeight = baseSampleWeight;
				if( this.unbiased ) {
					// the theory is that equal weights for each sample lead to an accumulation of rounding errors.
					// The following equation varies the sampleWeight per sample so that it is uniformly distributed
					// across a range of values whose rounding errors cancel each other out.
					var uniformCenteredDistribution = ( -0.5 + ( i + 0.5 ) / jitterOffsets.length );
					sampleWeight += roundingRange * uniformCenteredDistribution;
				}

				this.addMaterial.uniforms[ "opacity" ].value = sampleWeight;
				renderer.render( this.scene, this.camera, this.sampleRenderTarget, true );
				renderer.renderPass( this.addMaterial, this.accumulateRenderTarget, ( i === 0 ) );
			}

			if ( this.camera.clearViewOffset ) this.camera.clearViewOffset();

			this.overMaterial.uniforms[ "tDiffuse" ].value = this.accumulateRenderTarget.texture;

			renderer.setClearColor( this.clearColor, this.clearAlpha );
			renderer.renderPass( this.overMaterial, this.renderToScreen ? null : readBuffer, this.clear );

			renderer.autoClear = autoClear;
			renderer.setClearColor( oldClearColor, oldClearAlpha );
		}

	} );

	// These jitter vectors are specified in integers because it is easier.
	// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)
	// before being used, thus these integers need to be scaled by 1/16.
	//
	// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
	THREE.SSAARenderPass.JitterVectors = [
		[
			[ 0, 0 ]
		],
		[
			[ 4, 4 ], [ - 4, - 4 ]
		],
		[
			[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]
		],
		[
			[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],
			[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]
		],
		[
			[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],
			[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],
			[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],
			[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]
		],
		[
			[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],
			[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],
			[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],
			[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],
			[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],
			[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],
			[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],
			[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]
		]
	];

	// File:examples/js/postprocessing/ClearPass.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ClearPass = function ( clearColor, clearAlpha ) {

		THREE.Pass.call( this );

		this.needsSwap = false;

		this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

	};

	THREE.ClearPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.ClearPass,

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			var oldClearColor, oldClearAlpha;

			if ( this.clearColor !== undefined ) {

				oldClearColor = renderer.getClearColor().getHex();
				oldClearAlpha = renderer.getClearAlpha();

				renderer.setClearColor( this.clearColor, this.clearAlpha );

			}

			renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );
			renderer.clear();

			if ( this.clearColor ) {

				renderer.setClearColor( oldClearColor, oldClearAlpha );

			}

		}

	} );

	// File:examples/js/postprocessing/TexturePass.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.TexturePass = function ( map, opacity ) {

		THREE.Pass.call( this );

		if ( THREE.CopyShader === undefined )
			console.error( "THREE.TexturePass relies on THREE.CopyShader" );

		var shader = THREE.CopyShader;

		this.map = map;
		this.opacity = ( opacity !== undefined ) ? opacity : 1.0;

		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		this.material = new THREE.ShaderMaterial( {

			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			depthTest: false,
			depthWrite: false

		} );

		this.needsSwap = false;

		this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		this.scene  = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
		this.quad.frustumCulled = false; // Avoid getting clipped
		this.scene.add( this.quad );

	};

	THREE.TexturePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.TexturePass,

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			var oldAutoClear = renderer.autoClear;
			renderer.autoClear = false;

			this.quad.material = this.material;

			this.uniforms[ "opacity" ].value = this.opacity;
			this.uniforms[ "tDiffuse" ].value = this.map;
			this.material.transparent = ( this.opacity < 1.0 );

			renderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );

			renderer.autoClear = oldAutoClear;
		}

	} );

	// File:examples/js/postprocessing/CubeTexturePass.js

	/**
	 * @author bhouston / http://clara.io/
	 */

	THREE.CubeTexturePass = function ( camera, envMap, opacity ) {

		THREE.Pass.call( this );

		this.camera = camera;

		this.needsSwap = false;

		this.cubeMaterial = new THREE.MeshCubeMaterial();

		this.cubeMesh = new THREE.Mesh(
			new THREE.BoxBufferGeometry( 10, 10, 10 ),
			this.cubeMaterial
		);

		this.envMap = envMap;
		this.envMapIntensity = 1.0;
		this.opacity = ( opacity !== undefined ) ? opacity : 1.0;
		this.roughness = 0.0;

		this.cubeScene = new THREE.Scene();
		this.cubeCamera = new THREE.PerspectiveCamera();
		this.cubeScene.add( this.cubeMesh );

	};

	THREE.CubeTexturePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.CubeTexturePass,

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			var oldAutoClear = renderer.autoClear;
			renderer.autoClear = false;

			this.cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );
			this.cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );

			if( this.cubeMaterial.envMap != this.envMap ) {
				this.cubeMaterial.envMap = this.envMap;
				this.cubeMaterial.needsUpdate = true;
			}
			this.cubeMaterial.envMapIntensity = this.envMapIntensity;
			this.cubeMaterial.roughness = this.roughness;
			this.cubeMaterial.opacity = this.opacity;
			this.cubeMaterial.transparent = ( this.opacity < 1.0 );

			renderer.render( this.cubeScene, this.cubeCamera, this.renderToScreen ? null : readBuffer, this.clear );

			renderer.autoClear = oldAutoClear;

		}

	} );

	// File:examples/js/postprocessing/DofPass.js

	/**
	 * @author spidersharma03 / http://eduperiment.com/
	 */

	THREE.DofPass = function (resolution, renderScene, renderCamera) {

		THREE.Pass.call( this );

		var resolution = ( resolution !== undefined ) ? resolution : new THREE.Vector2(256, 256);
		// render targets
		this.downSampleRes = new THREE.Vector2(Math.round(resolution.x/2), Math.round(resolution.y/2));

		var pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.HalfFloatType, format: THREE.RGBAFormat };

		this.renderTargetColorDownSample = new THREE.WebGLRenderTarget( this.downSampleRes.x, this.downSampleRes.y, pars );
		this.renderTargetColorDownSample.texture.generateMipmaps = false;

		this.renderTargetCoCDownSample = new THREE.WebGLRenderTarget( this.downSampleRes.x, this.downSampleRes.y, pars );
		this.renderTargetCoCDownSample.texture.generateMipmaps = false;

		this.renderTargetBlurTemp = new THREE.WebGLRenderTarget( this.downSampleRes.x, this.downSampleRes.y, pars );
		this.renderTargetBlurTemp.texture.generateMipmaps = false;

		var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

		this.renderTargetDofBlur = new THREE.WebGLRenderTarget( this.downSampleRes.x, this.downSampleRes.y, pars );
		this.renderTargetDofBlur.texture.generateMipmaps = false;
		this.renderTargetDofBlurTemp = new THREE.WebGLRenderTarget( this.downSampleRes.x, this.downSampleRes.y, pars );
		this.renderTargetDofBlurTemp.texture.generateMipmaps = false;

		this.renderTargetDofCombine = new THREE.WebGLRenderTarget( resolution.x, resolution.y, pars );
		this.renderTargetDofCombine.texture.generateMipmaps = false;

		this.needsSwap = false;
		this.oldClearColor = new THREE.Color();
		this.oldClearAlpha = 1;

		this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		this.scene  = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
		this.scene.add( this.quad );

		this.focalDistance = 10.0;
		this.cameraNear = 0.1;
		this.cameraFar = 100;
		this.NearFarBlurScale = new THREE.Vector2(0.1, 0.5);

		this.downSamplingMaterial = this.getColorDownSamplingMaterial();

		this.cocMaterial = this.getCoCMaterial();
		this.cocMaterial.uniforms[ "NearFarBlurScale" ].value = this.NearFarBlurScale;
		this.cocMaterial.uniforms[ "cameraNearFar" ].value = new THREE.Vector2(renderCamera.near, renderCamera.far);
		this.cocMaterial.uniforms[ "focalDistance" ].value = this.focalDistance;

		this.dilateNearCocMaterial = this.getDilateNearCocMaterial();
		this.dilateNearCocMaterial.uniforms[ "NearFarBlurScale" ].value = this.NearFarBlurScale;

		this.dofBlurType = 1;
		this.dofBlurMaterial = (this.dofBlurType === 0) ? this.getDofBlurCircularMaterial() : this.getDofBlurSeperableMaterial();


		this.dofCombineMaterial = this.getDofCombineMaterial();
		this.dofCombineMaterial.uniforms[ "NearFarBlurScale" ].value = this.NearFarBlurScale;
		this.dofCombineMaterial.uniforms[ "cameraNearFar" ].value = new THREE.Vector2(renderCamera.near, renderCamera.far);
		this.dofCombineMaterial.uniforms[ "focalDistance" ].value = this.focalDistance;

		if ( THREE.CopyShader === undefined )
			console.error( "THREE.DofPass relies on THREE.CopyShader" );

		var copyShader = THREE.CopyShader;

		this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );
		this.materialCopy = new THREE.ShaderMaterial( {

			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
		} );

		this.depthMaterial = new THREE.MeshDepthMaterial();
		this.depthMaterial.side = THREE.DoubleSide;
		this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
		this.depthMaterial.blending = THREE.NoBlending;
		this.depthRenderTarget = new THREE.WebGLRenderTarget( resolution.x, resolution.y,
						{ minFilter: THREE.NearesFilter, magFilter: THREE.NearesFilter, format: THREE.RGBAFormat } );
		this.renderScene = renderScene;
		this.renderCamera = renderCamera;
	};

	THREE.DofPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.DofPass,

		setSize: function(width, height) {
			this.downSampleRes = new THREE.Vector2(Math.round(width/2), Math.round(height/2));


			var resx = this.downSampleRes.x;
			var resy = this.downSampleRes.y;

			this.renderTargetColorDownSample.setSize( resx, resy );
			this.renderTargetCoCDownSample.setSize( resx, resy );
			this.renderTargetBlurTemp.setSize( resx, resy );
			this.renderTargetDofBlur.setSize( resx, resy );
			this.renderTargetDofBlurTemp.setSize( resx, resy );
			this.renderTargetDofCombine.setSize( width, height );
			this.depthRenderTarget.setSize( width, height );
		},

		changeBlurType: function(blurType) {
			this.dofBlurType = blurType;
			this.dofBlurMaterial = (this.dofBlurType === 0) ? this.getDofBlurCircularMaterial() : this.getDofBlurSeperableMaterial();	},

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {


			this.dilateNearCocMaterial.uniforms[ "texSize" ].value = this.downSampleRes;
			this.dofBlurMaterial.uniforms[ "texSize" ].value = this.downSampleRes;
			this.dofCombineMaterial.uniforms[ "texSize" ].value = this.downSampleRes;

			this.cocMaterial.uniforms[ "focalDistance" ].value = this.focalDistance;
			this.cocMaterial.uniforms[ "cameraNearFar" ].value.x = this.cameraNear;
			this.cocMaterial.uniforms[ "cameraNearFar" ].value.y = this.cameraFar;

			this.dofCombineMaterial.uniforms[ "focalDistance" ].value = this.focalDistance;
			this.dofCombineMaterial.uniforms[ "cameraNearFar" ].value.x = this.cameraNear;
			this.dofCombineMaterial.uniforms[ "cameraNearFar" ].value.y = this.cameraFar;


			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();
			var oldAutoClear = renderer.autoClear;
			renderer.autoClear = true;

			if ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );

			// Render Scene into depth buffer. This is temporary and should not be done here.
			this.renderScene.overrideMaterial = this.depthMaterial;
			renderer.setClearColor(0xffffff, 1);
			renderer.render( this.renderScene, this.renderCamera, this.depthRenderTarget );
			this.renderScene.overrideMaterial = null;

			// 1. Downsample the Original texture, and store coc in the alpha channel
			this.quad.material = this.downSamplingMaterial;
			this.downSamplingMaterial.uniforms[ "colorTexture" ].value = readBuffer.texture;
			renderer.render( this.scene, this.camera, this.renderTargetColorDownSample );

			this.quad.material = this.cocMaterial;
			this.cocMaterial.uniforms[ "depthTexture" ].value = this.depthRenderTarget.texture;
			renderer.render( this.scene, this.camera, this.renderTargetCoCDownSample );

			// 2. Dilate/Blur Near field coc
			this.quad.material = this.dilateNearCocMaterial;
			this.dilateNearCocMaterial.uniforms[ "cocTexture" ].value = this.renderTargetCoCDownSample.texture;
			this.dilateNearCocMaterial.uniforms[ "depthTexture" ].value = this.depthRenderTarget.texture;
			this.dilateNearCocMaterial.uniforms[ "direction" ].value = new THREE.Vector2(1, 0);
			renderer.render( this.scene, this.camera, this.renderTargetBlurTemp );
			this.dilateNearCocMaterial.uniforms[ "cocTexture" ].value = this.renderTargetBlurTemp.texture;
			this.dilateNearCocMaterial.uniforms[ "direction" ].value = new THREE.Vector2(0, 1);
			renderer.render( this.scene, this.camera, this.renderTargetCoCDownSample );

			// 3. Blur Dof
			if( this.dofBlurType === 0 ){
				this.quad.material = this.dofBlurMaterial;
				this.dofBlurMaterial.uniforms[ "cocTexture" ].value = this.renderTargetCoCDownSample.texture;
				this.dofBlurMaterial.uniforms[ "colorTexture" ].value = this.renderTargetDownSample.texture;
				this.dofBlurMaterial.uniforms[ "depthTexture" ].value = this.depthRenderTarget.texture;
				renderer.render( this.scene, this.camera, this.renderTargetDofBlurTemp );
			}
			else {
				this.quad.material = this.dofBlurMaterial;
				this.dofBlurMaterial.uniforms[ "cocTexture" ].value = this.renderTargetCoCDownSample.texture;
				this.dofBlurMaterial.uniforms[ "colorTexture" ].value = this.renderTargetColorDownSample.texture;
				this.dofBlurMaterial.uniforms[ "direction" ].value = new THREE.Vector2(1, 0);
				renderer.render( this.scene, this.camera, this.renderTargetDofBlur );
				this.dofBlurMaterial.uniforms[ "colorTexture" ].value = this.renderTargetDofBlur.texture;
				this.dofBlurMaterial.uniforms[ "direction" ].value = new THREE.Vector2(0, 1);
				renderer.render( this.scene, this.camera, this.renderTargetDofBlurTemp );
			}
			// 4. Dof Combine
			this.quad.material = this.dofCombineMaterial;
			this.dofCombineMaterial.uniforms[ "cocTexture" ].value = this.renderTargetCoCDownSample.texture;
			this.dofCombineMaterial.uniforms[ "colorTexture" ].value = readBuffer.texture;
			this.dofCombineMaterial.uniforms[ "depthTexture" ].value = this.depthRenderTarget.texture;
			this.dofCombineMaterial.uniforms[ "blurTexture" ].value = this.renderTargetDofBlurTemp.texture;
			renderer.render( this.scene, this.camera, this.renderTargetDofCombine );

			// Copy Pass
			this.quad.material = this.materialCopy;
			this.copyUniforms[ "tDiffuse" ].value = this.renderTargetDofCombine.texture;

			if ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );
			renderer.render( this.scene, this.camera, readBuffer );

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
			renderer.autoClear = oldAutoClear;
		},

		getColorDownSamplingMaterial: function() {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"colorTexture": { value: null },
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\n\
					#include <packing>\n\
					varying vec2 vUv;\n\
					uniform sampler2D colorTexture;\n\
					\
					void main() {\n\
						gl_FragColor = texture2D(colorTexture, vUv);\n\
					}"
			} );
		},

		getCoCMaterial: function() {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"depthTexture": { value: null },
					"NearFarBlurScale": { value: new THREE.Vector2( 0.5, 0.5 ) },
					"cameraNearFar": { value: new THREE.Vector2( 0.1, 100 ) },
					"focalDistance": { value: 1.0 }
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\n\
					#include <packing>\n\
					varying vec2 vUv;\n\
					uniform sampler2D depthTexture;\n\
					uniform vec2 NearFarBlurScale;\
					uniform vec2 cameraNearFar;\
					uniform float focalDistance;\
					const float MAXIMUM_BLUR_SIZE = 8.0;\
					\
					float computeCoc() {\
						vec4 packDepth = texture2D(depthTexture, vUv).rgba;\
						if(packDepth.x == 1.0) return max(NearFarBlurScale.x, NearFarBlurScale.y);\
							float depth = unpackRGBAToDepth(packDepth);\
							depth = -perspectiveDepthToViewZ(depth, cameraNearFar.x, cameraNearFar.y);\
							float coc = (depth - focalDistance)/depth;\
						return (coc > 0.0 ? coc * NearFarBlurScale.y : coc * NearFarBlurScale.x);\
					}\
					\
					void main() {\n\
						gl_FragColor = vec4(0.0, 0.0, 0.0, computeCoc());\n\
					}"
			} );
		},


		getDilateNearCocMaterial: function() {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"cocTexture": { value: null },
					"depthTexture": { value: null },
					"NearFarBlurScale": { value: new THREE.Vector2( 0.5, 0.5 ) },
					"texSize": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
					"direction": 				{ value: new THREE.Vector2( 1, 0 ) },
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\n\
					varying vec2 vUv;\n\
					uniform sampler2D cocTexture;\n\
					uniform sampler2D depthTexture;\n\
					uniform vec2 direction;\
					uniform vec2 texSize;\
					uniform vec2 NearFarBlurScale;\
					const float MAXIMUM_BLUR_SIZE = 8.0;\
					\
					float expandNear(const in vec2 offset, const in bool isBackground) {\
						float coc = 0.0;\
						vec2 sampleOffsets = MAXIMUM_BLUR_SIZE * offset / 5.0;\
						float coc0 = texture2D(cocTexture, vUv).a;\
						float coc1 = texture2D(cocTexture, vUv - 5.0 * sampleOffsets).a;\
						float coc2 = texture2D(cocTexture, vUv - 4.0 * sampleOffsets).a;\
						float coc3 = texture2D(cocTexture, vUv - 3.0 * sampleOffsets).a;\
						float coc4 = texture2D(cocTexture, vUv - 2.0 * sampleOffsets).a;\
						float coc5 = texture2D(cocTexture, vUv - 1.0 * sampleOffsets).a;\
						float coc6 = texture2D(cocTexture, vUv + 1.0 * sampleOffsets).a;\
						float coc7 = texture2D(cocTexture, vUv + 2.0 * sampleOffsets).a;\
						float coc8 = texture2D(cocTexture, vUv + 3.0 * sampleOffsets).a;\
						float coc9 = texture2D(cocTexture, vUv + 4.0 * sampleOffsets).a;\
						float coc10 = texture2D(cocTexture, vUv + 5.0 * sampleOffsets).a;\
							\
						if(isBackground){\
							coc = abs(coc0) * 0.095474 + \
							(abs(coc1) + abs(coc10)) * 0.084264 + \
							(abs(coc2) + abs(coc9)) * 0.088139 + \
							(abs(coc3) + abs(coc8)) * 0.091276 + \
							(abs(coc4) + abs(coc7)) * 0.093585 + \
							(abs(coc5) + abs(coc6)) * 0.094998;\
						} else {\
							coc = min(coc0, 0.0);\
							coc = min(coc1 * 0.3, coc);\
							coc = min(coc2 * 0.5, coc);\
							coc = min(coc3 * 0.75, coc);\
							coc = min(coc4 * 0.8, coc);\
							coc = min(coc5 * 0.95, coc);\
							coc = min(coc6 * 0.95, coc);\
							coc = min(coc7 * 0.8, coc);\
							coc = min(coc8 * 0.75, coc);\
							coc = min(coc9 * 0.5, coc);\
							coc = min(coc10 * 0.3, coc);\
							if(abs(coc0) > abs(coc))\
								coc = coc0;\
						}\
						return coc;\
					}\
					\
					void main() {\n\
						vec2 offset = direction/texSize;\
						float coc = expandNear(offset, texture2D(depthTexture, vUv).x == 1.0);\
						gl_FragColor = vec4(0.0, 0.0, 0.0, coc);\n\
					}"
			} );
		},

		getDofBlurCircularMaterial: function() {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"colorTexture": { value: null },
					"cocTexture": { value: null },
					"depthTexture": { value: null },
					"texSize": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\n\
					varying vec2 vUv;\n\
					uniform sampler2D colorTexture;\n\
					uniform sampler2D cocTexture;\n\
					uniform sampler2D depthTexture;\n\
					uniform vec2 texSize;\
					const float MAXIMUM_BLUR_SIZE = 8.0;\
					\
					vec4 CircularBlur() {\
						\
						const int NUM_SAMPLES = 16;\
						vec2 poisson_disk_samples[NUM_SAMPLES];\
						poisson_disk_samples[0] = vec2(-0.399691779231, 0.728591545584);\
						poisson_disk_samples[1] = vec2(-0.48622557676, -0.84016533712);\
						poisson_disk_samples[2] = vec2(0.770309468987, -0.24906070432);\
						poisson_disk_samples[3] = vec2(0.556596796154, 0.820359876432);\
						poisson_disk_samples[4] = vec2(-0.933902004071, 0.0600539051593);\
						poisson_disk_samples[5] = vec2(0.330144964342, 0.207477293384);\
						poisson_disk_samples[6] = vec2(0.289013230975, -0.686749271417);\
						poisson_disk_samples[7] = vec2(-0.0832470893559, -0.187351643125);\
						poisson_disk_samples[8] = vec2(-0.296314525615, 0.254474834305);\
						poisson_disk_samples[9] = vec2(-0.850977666059, 0.484642744689);\
						poisson_disk_samples[10] = vec2(0.829287915319, 0.2345063545);\
						poisson_disk_samples[11] = vec2(-0.773042143899, -0.543741521254);\
						poisson_disk_samples[12] = vec2(0.0561133030864, 0.928419742597);\
						poisson_disk_samples[13] = vec2(-0.205799249508, -0.562072714492);\
						poisson_disk_samples[14] = vec2(-0.526991665882, -0.193690188118);\
						poisson_disk_samples[15] = vec2(-0.051789270667, -0.935374050821);\
							\
						vec4 cocr = texture2D(cocTexture, vUv);\
							\
						float blurDist = MAXIMUM_BLUR_SIZE * coc.a;\
							\
						float rnd = PI2 * rand( vUv );\
						float costheta = cos(rnd);\
						float sintheta = sin(rnd);\
						vec4 rotationMatrix = vec4(costheta, -sintheta, sintheta, costheta);\
							\
						vec3 colorSum = vec3(0.0);\
						float weightSum = 0.0;\
							\
						for (int i = 0; i < NUM_SAMPLES; i++) {\
							vec2 ofs = poisson_disk_samples[i];\
							ofs = vec2(dot(ofs, rotationMatrix.xy), dot(ofs, rotationMatrix.zw) );\
							vec2 texcoord = vUv + blurDist * ofs / texSize.xy;\
							vec4 sample = texture2D(colorTexture, texcoord);\
							float cocWeight = abs(sample.a);\
							cocWeight *= cocWeight * cocWeight;\
							colorSum += sample.rgb * cocWeight;\
							weightSum += cocWeight;\
						}\
							\
						colorSum /= weightSum;\
							\
						return vec4(colorSum, 1.0);\
					}\
					\
					void main() {\n\
						gl_FragColor = CircularBlur();\n\
					}"
			} );
		},

		getDofBlurSeperableMaterial: function() {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"cocTexture":   { value: null },
					"colorTexture": { value: null },
					"texSize": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
					"direction": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\n\
					varying vec2 vUv;\n\
					uniform sampler2D cocTexture;\n\
					uniform sampler2D colorTexture;\n\
					uniform vec2 texSize;\
					uniform vec2 direction;\
					const float MAXIMUM_BLUR_SIZE = 8.0;\
					\
					const float SIGMA = 5.0;\
					const int NUM_SAMPLES = 4;\
					float normpdf(in float x, in float sigma)\
					{\
						return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\
					}\
					\
					vec4 weightedBlur() { \
						float cocIn = texture2D(cocTexture, vUv).a;\
						float kernelRadius = MAXIMUM_BLUR_SIZE * cocIn;\
						vec2 invSize = 1.0 / texSize;\
						cocIn *= cocIn * cocIn;\
						float centreSpaceWeight = normpdf(0.0, SIGMA) * abs(cocIn);\
						float weightSum = centreSpaceWeight;\
						vec4 centreSample = texture2D(colorTexture, vUv);\
						vec4 diffuseSum = centreSample * weightSum;\
						vec2 delta = invSize * kernelRadius/float(NUM_SAMPLES);\
						for( int i = 1; i <= NUM_SAMPLES; i ++ ) {\
								float spaceWeight = normpdf(float(i), SIGMA);\
								vec2 texcoord = direction * delta * float(i);\
								vec4 rightSample = texture2D( colorTexture, vUv + texcoord);\
								vec4 leftSample = texture2D( colorTexture, vUv - texcoord);\
								float leftCocWeight = abs(texture2D( cocTexture, vUv - texcoord).a);\
								float rightCocWeight = abs(texture2D( cocTexture, vUv + texcoord).a);\
								leftCocWeight *= leftCocWeight * leftCocWeight;\
								rightCocWeight *= rightCocWeight * rightCocWeight;\
								diffuseSum += ( (leftSample * leftCocWeight) + (rightSample * rightCocWeight) ) * spaceWeight;\
								weightSum += (spaceWeight * (leftCocWeight + rightCocWeight));\
						}\
					  return diffuseSum/weightSum;\
					}\
					\
					void main() {\n\
						gl_FragColor = weightedBlur();\n\
					}"
			} );
		},

		getDofCombineMaterial: function() {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"colorTexture": { value: null },
					"blurTexture": { value: null },
					"cocTexture": { value: null },
					"depthTexture": { value: null },
					"NearFarBlurScale": { value: new THREE.Vector2( 0.5, 0.5 ) },
					"texSize": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
					"cameraNearFar": { value: new THREE.Vector2( 0.1, 100 ) },
					"focalDistance" : {value: 20.0 }
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\n\
					#include <packing>\n\
					varying vec2 vUv;\n\
					uniform sampler2D colorTexture;\n\
					uniform sampler2D blurTexture;\n\
					uniform sampler2D cocTexture;\n\
					uniform sampler2D depthTexture;\n\
					uniform vec2 texSize;\
					uniform vec2 NearFarBlurScale;\
					uniform vec2 cameraNearFar;\
					uniform float focalDistance;\
					\
					float computeCoc() {\
						vec4 packedDepth = texture2D(depthTexture, vUv);\
						if(packedDepth.x == 1.0) return max(NearFarBlurScale.x, NearFarBlurScale.y);\
							float depth = unpackRGBAToDepth(packedDepth);\
							depth = -perspectiveDepthToViewZ(depth, cameraNearFar.x, cameraNearFar.y);\
							float coc = (depth - focalDistance)/depth;\
						return (coc > 0.0 ? coc * NearFarBlurScale.y : coc * NearFarBlurScale.x);\
					}\
					\
					void main() {\n\
						vec4 blur = texture2D(blurTexture, vUv);\
						blur += texture2D(blurTexture, vUv + vec2(1.5, 0.5) / texSize);\
						blur += texture2D(blurTexture, vUv + vec2(-0.5, 1.5) / texSize);\
						blur += texture2D(blurTexture, vUv + vec2(-1.5, -0.5) / texSize);\
						blur += texture2D(blurTexture, vUv + vec2(0.5, -1.5) / texSize);\
						blur /= 5.0;\
						float coc = abs(min(texture2D(cocTexture, vUv).a, computeCoc()));\
						coc = clamp(coc * coc * 8.0, 0.0, 1.0);\
						vec4 color = mix(texture2D(colorTexture, vUv), blur, vec4(coc));\
						gl_FragColor = color;\n\
					}"
			} );
		}

	});

	// File:examples/js/postprocessing/UnrealBloomPass.js

	/**
	 * @author spidersharma / http://eduperiment.com/
	 Inspired from Unreal Engine::
	 https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
	 */

	THREE.UnrealBloomPass = function ( resolution, strength, radius, threshold ) {

		THREE.Pass.call( this );

		this.strength = ( strength !== undefined ) ? strength : 1;
		this.radius = radius;
		this.threshold = threshold;
		this.resolution = ( resolution !== undefined ) ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);

		// render targets
		var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
		this.renderTargetsHorizontal = [];
		this.renderTargetsVertical = [];
		this.nMips = 5;
		var resx = Math.round(this.resolution.x/2);
		var resy = Math.round(this.resolution.y/2);

		this.renderTargetBright = new THREE.WebGLRenderTarget( resx, resy, pars );
		this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
		this.renderTargetBright.texture.generateMipmaps = false;

		for( var i=0; i<this.nMips; i++) {

			var renderTarget = new THREE.WebGLRenderTarget( resx, resy, pars );

			renderTarget.texture.name = "UnrealBloomPass.h" + i;
			renderTarget.texture.generateMipmaps = false;

			this.renderTargetsHorizontal.push(renderTarget);

			var renderTarget = new THREE.WebGLRenderTarget( resx, resy, pars );

			renderTarget.texture.name = "UnrealBloomPass.v" + i;
			renderTarget.texture.generateMipmaps = false;

			this.renderTargetsVertical.push(renderTarget);

			resx = Math.round(resx/2);

			resy = Math.round(resy/2);
		}

		// luminosity high pass material

		if ( THREE.LuminosityHighPassShader === undefined )
			console.error( "THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader" );

		var highPassShader = THREE.LuminosityHighPassShader;
		this.highPassUniforms = THREE.UniformsUtils.clone( highPassShader.uniforms );

		this.highPassUniforms[ "luminosityThreshold" ].value = threshold;
		this.highPassUniforms[ "smoothWidth" ].value = 0.05;

		this.materialHighPassFilter = new THREE.ShaderMaterial( {
			uniforms: this.highPassUniforms,
			vertexShader:  highPassShader.vertexShader,
			fragmentShader: highPassShader.fragmentShader,
			defines: {}
		} );

		// Gaussian Blur Materials
		this.separableBlurMaterials = [];
		var kernelSizeArray = [3, 5, 7, 9, 11];
		var resx = Math.round(this.resolution.x/2);
		var resy = Math.round(this.resolution.y/2);

		for( var i=0; i<this.nMips; i++) {

			this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));

			this.separableBlurMaterials[i].uniforms[ "texSize" ].value = new THREE.Vector2(resx, resy);

			resx = Math.round(resx/2);

			resy = Math.round(resy/2);
		}

		// Composite material
		this.compositeMaterial = this.getCompositeMaterial(this.nMips);
		this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
		this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
		this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
		this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
		this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
		this.compositeMaterial.uniforms["bloomStrength"].value = strength;
		this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
		this.compositeMaterial.needsUpdate = true;

		var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
		this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
		this.bloomTintColors = [new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1)
													,new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1)];
		this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;

		// copy material
		if ( THREE.CopyShader === undefined )
			console.error( "THREE.BloomPass relies on THREE.CopyShader" );

		var copyShader = THREE.CopyShader;

		this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );
		this.copyUniforms[ "opacity" ].value = 1.0;

		this.materialCopy = new THREE.ShaderMaterial( {
			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: THREE.AdditiveBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		} );

		this.enabled = true;
		this.needsSwap = false;

		this.oldClearColor = new THREE.Color();
		this.oldClearAlpha = 1;

		this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		this.scene  = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
		this.quad.frustumCulled = false; // Avoid getting clipped
		this.scene.add( this.quad );

	};

	THREE.UnrealBloomPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.UnrealBloomPass,

		dispose: function() {
			for( var i=0; i< this.renderTargetsHorizontal.length(); i++) {
				this.renderTargetsHorizontal[i].dispose();
			}
			for( var i=0; i< this.renderTargetsVertical.length(); i++) {
				this.renderTargetsVertical[i].dispose();
			}
			this.renderTargetBright.dispose();
		},

		setSize: function ( width, height ) {

			var resx = Math.round(width/2);
			var resy = Math.round(height/2);

			this.renderTargetBright.setSize(resx, resy);

			for( var i=0; i<this.nMips; i++) {

				this.renderTargetsHorizontal[i].setSize(resx, resy);
				this.renderTargetsVertical[i].setSize(resx, resy);

				this.separableBlurMaterials[i].uniforms[ "texSize" ].value = new THREE.Vector2(resx, resy);

				resx = Math.round(resx/2);
				resy = Math.round(resy/2);
			}
		},

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();
			var oldAutoClear = renderer.autoClear;
			renderer.autoClear = false;

			renderer.setClearColor( new THREE.Color( 0, 0, 0 ), 0 );

			if ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );

			// 1. Extract Bright Areas
			this.highPassUniforms[ "tDiffuse" ].value = readBuffer.texture;
			this.highPassUniforms[ "luminosityThreshold" ].value = this.threshold;
			this.quad.material = this.materialHighPassFilter;
			renderer.render( this.scene, this.camera, this.renderTargetBright, true );

			// 2. Blur All the mips progressively
			var inputRenderTarget = this.renderTargetBright;

			for(var i=0; i<this.nMips; i++) {

				this.quad.material = this.separableBlurMaterials[i];

				this.separableBlurMaterials[i].uniforms[ "colorTexture" ].value = inputRenderTarget.texture;

				this.separableBlurMaterials[i].uniforms[ "direction" ].value = THREE.UnrealBloomPass.BlurDirectionX;

				renderer.render( this.scene, this.camera, this.renderTargetsHorizontal[i], true );

				this.separableBlurMaterials[i].uniforms[ "colorTexture" ].value = this.renderTargetsHorizontal[i].texture;

				this.separableBlurMaterials[i].uniforms[ "direction" ].value = THREE.UnrealBloomPass.BlurDirectionY;

				renderer.render( this.scene, this.camera, this.renderTargetsVertical[i], true );

				inputRenderTarget = this.renderTargetsVertical[i];
			}

			// Composite All the mips
			this.quad.material = this.compositeMaterial;
			this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
			this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
			this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
			renderer.render( this.scene, this.camera, this.renderTargetsHorizontal[0], true );

			// Blend it additively over the input texture
			this.quad.material = this.materialCopy;
			this.copyUniforms[ "tDiffuse" ].value = this.renderTargetsHorizontal[0].texture;

			if ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );

			renderer.render( this.scene, this.camera, readBuffer );

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
			renderer.autoClear = oldAutoClear;
		},

		getSeperableBlurMaterial: function(kernelRadius) {

			return new THREE.ShaderMaterial( {

				defines: {
					"KERNEL_RADIUS" : kernelRadius,
					"SIGMA" : kernelRadius
				},

				uniforms: {
					"colorTexture": { value: null },
					"texSize": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
					"direction": 				{ value: new THREE.Vector2( 0.5, 0.5 ) }
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\
					varying vec2 vUv;\n\
					uniform sampler2D colorTexture;\n\
					uniform vec2 texSize;\
					uniform vec2 direction;\
					\
					float gaussianPdf(in float x, in float sigma) {\
						return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
					}\
					void main() {\n\
						vec2 invSize = 1.0 / texSize;\
						float fSigma = float(SIGMA);\
						float weightSum = gaussianPdf(0.0, fSigma);\
						vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\
						for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\
							float x = float(i);\
							float w = gaussianPdf(x, fSigma);\
							vec2 uvOffset = direction * invSize * x;\
							vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\
							vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\
							diffuseSum += (sample1 + sample2) * w;\
							weightSum += 2.0 * w;\
						}\
						gl_FragColor = diffuseSum/weightSum;\n\
					}"
			} );
		},

		getCompositeMaterial: function(nMips) {

			return new THREE.ShaderMaterial( {

				defines:{
					"NUM_MIPS" : nMips
				},

				uniforms: {
					"blurTexture1": { value: null },
					"blurTexture2": { value: null },
					"blurTexture3": { value: null },
					"blurTexture4": { value: null },
					"blurTexture5": { value: null },
					"dirtTexture": { value: null },
					"bloomStrength" : { value: 1.0 },
					"bloomFactors" : { value: null },
					"bloomTintColors" : { value: null },
					"bloomRadius" : { value: 0.0 }
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"varying vec2 vUv;\
					uniform sampler2D blurTexture1;\
					uniform sampler2D blurTexture2;\
					uniform sampler2D blurTexture3;\
					uniform sampler2D blurTexture4;\
					uniform sampler2D blurTexture5;\
					uniform sampler2D dirtTexture;\
					uniform float bloomStrength;\
					uniform float bloomRadius;\
					uniform float bloomFactors[NUM_MIPS];\
					uniform vec3 bloomTintColors[NUM_MIPS];\
					\
					float lerpBloomFactor(const in float factor) { \
						float mirrorFactor = 1.2 - factor;\
						return mix(factor, mirrorFactor, bloomRadius);\
					}\
					\
					void main() {\
						gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \
						 							 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \
													 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \
													 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \
													 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\
					}"
			} );
		}

	} );

	THREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2( 1.0, 0.0 );
	THREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2( 0.0, 1.0 );

	// File:examples/js/GlossyMirror.js

	/**
	 * @author spidersharma03
	 * @author bhouston / Ben Houston / ben@clara.io
	 */

	THREE.MirrorHelper = function(mirror) {
	  this.scene = new THREE.Scene();
	  this.cameraOrtho = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	  this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
	  this.scene.add(this.quad);
	  this.mirror = mirror;
	  this.numMipMaps = 4;


	  this.mirrorTextureMipMaps = [];
	  this.tempRenderTargets = [];
	  var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };
	  var mirrorTexture = mirror.mirrorRenderTarget;

	  var width = mirrorTexture.width/2, height = mirrorTexture.height/2;
	  for( var i=0; i<this.numMipMaps; i++) {

	    var mirrorRenderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
	    mirrorRenderTarget.texture.generateMipmaps = false;
	    this.mirrorTextureMipMaps.push(mirrorRenderTarget);

	    var tempRenderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
	    tempRenderTarget.texture.generateMipmaps = false;
	    this.tempRenderTargets.push(tempRenderTarget);

	    width /= 2; height /= 2;
	  }

	  this.vBlurMaterial = new THREE.ShaderMaterial( THREE.BlurShader );
	  this.vBlurMaterial.side = THREE.DoubleSide;
	  this.vBlurMaterial.uniforms[ 'size' ].value.set( mirrorTexture.width/2, mirrorTexture.height/2 );
	  this.vBlurMaterial.blending = THREE.NoBlending;
	  THREE.BlurShaderUtils.configure( this.vBlurMaterial, 5, 3.0, new THREE.Vector2( 0, 1 ) );

	  this.hBlurMaterial = this.vBlurMaterial.clone();
	  this.hBlurMaterial.side = THREE.DoubleSide;
	  this.hBlurMaterial.uniforms[ 'size' ].value.set( mirrorTexture.width/2, mirrorTexture.height/2 );
	  this.hBlurMaterial.blending = THREE.NoBlending;
	  THREE.BlurShaderUtils.configure( this.hBlurMaterial, 5, 3.0, new THREE.Vector2( 1, 0 ) );
	}


	THREE.MirrorHelper.prototype = {

	  constructor: THREE.MirrorHelper,


	  setSize: function( width, height ) {
		  for( var i=0; i<this.numMipMaps; i++) {
		    width /= 2; height /= 2;
		    this.mirrorTextureMipMaps[i].setSize( width, height );
		    this.tempRenderTargets[i].setSize( width, height );
		  }
	  },

	  update: function(renderer) {

	    var textureIn = this.mirror.mirrorRenderTarget;
	    for( var i=0; i<this.numMipMaps; i++) {
	      var renderTarget = this.mirrorTextureMipMaps[i];
	   	  var tempRenderTarget = this.tempRenderTargets[i];

	      this.hBlurMaterial.uniforms[ 'size' ].value.set( textureIn.width, textureIn.height );
	      this.hBlurMaterial.uniforms[ "tDiffuse" ].value = textureIn.texture;
	      this.quad.material = this.hBlurMaterial;
	      renderer.render(this.scene, this.cameraOrtho, tempRenderTarget, true);

	      this.vBlurMaterial.uniforms[ 'size' ].value.set( tempRenderTarget.width, tempRenderTarget.height );
	      this.vBlurMaterial.uniforms[ "tDiffuse" ].value = tempRenderTarget.texture;
	      this.quad.material = this.vBlurMaterial;
	      renderer.render(this.scene, this.cameraOrtho, renderTarget, true);

	      textureIn = renderTarget;
	    }
	  }
	}



	THREE.GlossyMirror = function ( options ) {

		THREE.Object3D.call( this );

		this.name = 'mirror_' + this.id;

		options = options || {};

		this.matrixNeedsUpdate = true;

		var width = options.textureWidth !== undefined ? options.textureWidth : 512;
		var height = options.textureHeight !== undefined ? options.textureHeight : 512;

		this.size = new THREE.Vector3( width, height );

		this.localMirrorNormal = options.localMirrorNormal !== undefined ? options.localMirrorNormal : new THREE.Vector3( 0, 0, 1 );

		this.distanceFade = 0.1;
		this.metalness = 0.0;
		this.specularColor = new THREE.Color( 0xffffff );
		this.roughness = 0.0;
		this.fresnelStrength = 1.0;

		this.mirrorPlane = new THREE.Plane();
		this.mirrorWorldPosition = new THREE.Vector3();
		this.cameraWorldPosition = new THREE.Vector3();
		this.rotationMatrix = new THREE.Matrix4();
		this.lookAtPosition = new THREE.Vector3( 0, 0, - 1 );
		this.matrixNeedsUpdate = true;

		// For debug only, show the normal and plane of the mirror
		var debugMode = options.debugMode !== undefined ? options.debugMode : false;

		if ( debugMode ) {

			var arrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 0, 1 ), new THREE.Vector3( 0, 0, 0 ), 10, 0xffff80 );
			var planeGeometry = new THREE.Geometry();
			planeGeometry.vertices.push( new THREE.Vector3( - 10, - 10, 0 ) );
			planeGeometry.vertices.push( new THREE.Vector3( 10, - 10, 0 ) );
			planeGeometry.vertices.push( new THREE.Vector3( 10, 10, 0 ) );
			planeGeometry.vertices.push( new THREE.Vector3( - 10, 10, 0 ) );
			planeGeometry.vertices.push( planeGeometry.vertices[ 0 ] );
			var plane = new THREE.Line( planeGeometry, new THREE.LineBasicMaterial( { color: 0xffff80 } ) );

			this.add( arrow );
			this.add( plane );

		}

		this.reflectionTextureMatrix = new THREE.Matrix4();

		this.mirrorNormal = new THREE.Vector3();
		var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };

		this.mirrorRenderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
		this.mirrorRenderTarget.texture.name = "GlossyMirror.mirror";

		this.material = new THREE.ShaderMaterial( THREE.GlossyMirrorShader );
		this.material.defines = Object.assign( {}, this.material.defines );
		this.material.uniforms = THREE.UniformsUtils.clone( this.material.uniforms );
		this.material.uniforms.tReflection.value = this.mirrorRenderTarget.texture;
		this.material.uniforms.reflectionTextureMatrix.value = this.reflectionTextureMatrix;

		this.mirrorRenderTarget.texture.generateMipmaps = false;

		this.clipPlane = new THREE.Plane( this.localMirrorNormal, 0 );
		this.originalClipPlane = this.clipPlane.clone();
		this.falseClipPlane = this.clipPlane.clone();
		this.falseClipPlane.constant = 10000;

		this.depthMaterial = new THREE.MeshDepthMaterial();
	 	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	 	this.depthMaterial.blending = THREE.NoBlending;
		this.depthMaterial.side = THREE.FrontSide;

		this.depthRenderTarget = new THREE.WebGLRenderTarget( width, height,
	 					{ minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
		this.depthRenderTarget.texture.generateMipmaps = false;
		this.depthRenderTarget.texture.name = "GlossyMirror.depth";

		this.material.uniforms.tReflectionDepth.value = this.depthRenderTarget.texture;


	  	this.material.uniforms[ 'screenSize' ].value = new THREE.Vector2(width, height);

		this.mirrorHelper = new THREE.MirrorHelper(this);

		this.material.uniforms.tReflection.value = this.mirrorRenderTarget.texture;
		this.material.uniforms.tReflection1.value = this.mirrorHelper.mirrorTextureMipMaps[0].texture;
		this.material.uniforms.tReflection2.value = this.mirrorHelper.mirrorTextureMipMaps[1].texture;
		this.material.uniforms.tReflection3.value = this.mirrorHelper.mirrorTextureMipMaps[2].texture;
		this.material.uniforms.tReflection4.value = this.mirrorHelper.mirrorTextureMipMaps[3].texture;

		this.setSize( width, height );

	};

	THREE.GlossyMirror.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

		constructor: THREE.GlossyMirror,

		setSize: function( width, height ) {

			if( this.size.x !== width || this.size.y !== height ) {

				this.mirrorRenderTarget.setSize( width, height );
				this.depthRenderTarget.setSize( width, height );
				this.mirrorHelper.setSize( width, height );
			 	this.material.uniforms[ 'screenSize' ].value = new THREE.Vector2(width, height);

			 	this.size.set( width, height );
			 	this.matrixNeedsUpdate = true;
			 }

		 	this.matrixNeedsUpdate = true;

		},

		updateReflectionTextureMatrix: function ( camera ) {

			this.updateMatrixWorld();
			camera.updateMatrixWorld();

			this.mirrorWorldPosition.setFromMatrixPosition( this.matrixWorld );
			this.cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

			this.rotationMatrix.extractRotation( this.matrixWorld );

			this.mirrorNormal.copy( this.localMirrorNormal );
			this.mirrorNormal.applyMatrix4( this.rotationMatrix );

			var view = this.mirrorWorldPosition.clone().sub( this.cameraWorldPosition );
			view.reflect( this.mirrorNormal ).negate();
			view.add( this.mirrorWorldPosition );

			this.rotationMatrix.extractRotation( camera.matrixWorld );

			this.lookAtPosition.set( 0, 0, - 1 );
			this.lookAtPosition.applyMatrix4( this.rotationMatrix );
			this.lookAtPosition.add( this.cameraWorldPosition );

			var target = this.mirrorWorldPosition.clone().sub( this.lookAtPosition );
			target.reflect( this.mirrorNormal ).negate();
			target.add( this.mirrorWorldPosition );

			this.up.set( 0, - 1, 0 );
			this.up.applyMatrix4( this.rotationMatrix );
			this.up.reflect( this.mirrorNormal ).negate();

			this.mirrorCamera.position.copy( view );
			this.mirrorCamera.up = this.up;
			this.mirrorCamera.lookAt( target );
			this.mirrorCamera.fov = camera.fov;
			this.mirrorCamera.near = camera.near;
			this.mirrorCamera.far = camera.far;
			this.mirrorCamera.aspect = camera.aspect;

			this.mirrorCamera.updateProjectionMatrix();
			this.mirrorCamera.updateMatrixWorld();
			this.mirrorCamera.matrixWorldInverse.getInverse( this.mirrorCamera.matrixWorld );

			// Update the texture matrix
			this.reflectionTextureMatrix.set( 0.5, 0.0, 0.0, 0.5,
									0.0, 0.5, 0.0, 0.5,
									0.0, 0.0, 0.5, 0.5,
									0.0, 0.0, 0.0, 1.0 );
			this.reflectionTextureMatrix.multiply( this.mirrorCamera.projectionMatrix );
			this.reflectionTextureMatrix.multiply( this.mirrorCamera.matrixWorldInverse );

			this.mirrorPlane.setFromNormalAndCoplanarPoint( this.mirrorNormal, this.mirrorWorldPosition );
			this.mirrorPlane.applyMatrix4( this.mirrorCamera.matrixWorldInverse );


			this.material.uniforms[ 'mirrorCameraProjectionMatrix' ].value.copy( this.mirrorCamera.projectionMatrix );
			this.material.uniforms[ 'mirrorCameraInverseProjectionMatrix' ].value.getInverse( this.mirrorCamera.projectionMatrix );

			this.material.uniforms[ 'mirrorCameraWorldMatrix' ].value.copy( camera.matrixWorld );
			this.material.uniforms[ 'mirrorCameraNear' ].value = this.mirrorCamera.near;
			this.material.uniforms[ 'mirrorCameraFar' ].value = this.mirrorCamera.far;

			this.material.uniforms[ 'mirrorNormal' ].value = this.mirrorNormal;
			this.material.uniforms[ 'mirrorWorldPosition' ].value = this.mirrorWorldPosition;
			this.material.transparent = true;
		},

		render: function ( renderer, scene, camera, width, height ) {

			if ( ! camera instanceof THREE.PerspectiveCamera ) console.error( "THREE.GlossyMirror: camera is not a Perspective Camera!" );

			this.setSize( width, height );

			if( ! this.mirrorCamera ) {
				this.mirrorCamera = camera.clone();
				this.mirrorCamera.matrixAutoUpdate = true;

			}


			if ( this.matrixNeedsUpdate ) this.updateReflectionTextureMatrix( camera );

			this.matrixNeedsUpdate = true;

			// Render the mirrored view of the current scene into the target texture


			if(this.clipPlane !== undefined) {

				this.clipPlane.copy(this.originalClipPlane);

				this.clipPlane.applyMatrix4(this.matrixWorld);
				this.clippingPlanes = [this.clipPlane];
			}

			renderer.clippingPlanes = this.clippingPlanes;

			if ( scene !== undefined && scene instanceof THREE.Scene ) {

				// We can't render ourself to ourself
				var visible = this.material.visible;
				this.material.visible = false;

				renderer.render( scene, this.mirrorCamera, this.mirrorRenderTarget, true );

				this.material.visible = visible;

			}
			scene.overrideMaterial = this.depthMaterial;

			var visible = this.material.visible;

			var oldClearColor = renderer.getClearColor(), oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor(0xffffff, 1);
			this.material.visible = false;

			renderer.render( scene, this.mirrorCamera, this.depthRenderTarget, true );

			scene.overrideMaterial = null;
			renderer.setClearColor( oldClearColor, oldClearAlpha );


			this.material.visible = visible;
			this.material.uniforms.distanceFade.value = this.distanceFade;
			this.material.uniforms.metalness.value = this.metalness;
			this.material.uniforms.fresnelStrength.value = this.fresnelStrength;
			this.material.uniforms.specularColor.value.copy( this.specularColor );
			this.material.uniforms.roughness.value = this.roughness;

			if(this.clipPlane !== undefined) {

				this.clipPlane.copy(this.falseClipPlane);

			}
			if(this.mirrorHelper !== undefined) {

				this.mirrorHelper.update(renderer);

			}
		}

	} );

	// File:examples/js/controls/OrbitControls.js

	/**
	 * @author qiao / https://github.com/qiao
	 * @author mrdoob / http://mrdoob.com
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author erich666 / http://erichaines.com
	 */

	// This set of controls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	//
	//    Orbit - left mouse / touch: one finger move
	//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
	//    Pan - right mouse, or arrow keys / touch: three finger swipe

	THREE.OrbitControls = function ( object, domElement ) {

		this.object = object;

		this.domElement = ( domElement !== undefined ) ? domElement : document;

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new THREE.Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.25;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

		// Set to false to disable use of the keys
		this.enableKeys = true;

		// The four arrow keys
		this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

		// Mouse buttons
		this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			var offset = new THREE.Vector3();

			// so camera.up is the orbit axis
			var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
			var quatInverse = quat.clone().inverse();

			var lastPosition = new THREE.Vector3();
			var lastQuaternion = new THREE.Quaternion();

			return function update() {

				var position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

				spherical.theta += sphericalDelta.theta;
				spherical.phi += sphericalDelta.phi;

				// restrict theta to be between desired limits
				spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				spherical.radius *= scale;

				// restrict radius to be between desired limits
				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

				// move target to panned location
				scope.target.add( panOffset );

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

				}

				scale = 1;
				panOffset.set( 0, 0, 0 );

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

					scope.dispatchEvent( changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
			scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

			scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
			scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
			scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );

			window.removeEventListener( 'keydown', onKeyDown, false );

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		var scope = this;

		var changeEvent = { type: 'change' };
		var startEvent = { type: 'start' };
		var endEvent = { type: 'end' };

		var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

		var state = STATE.NONE;

		var EPS = 0.000001;

		// current position in spherical coordinates
		var spherical = new THREE.Spherical();
		var sphericalDelta = new THREE.Spherical();

		var scale = 1;
		var panOffset = new THREE.Vector3();
		var zoomChanged = false;

		var rotateStart = new THREE.Vector2();
		var rotateEnd = new THREE.Vector2();
		var rotateDelta = new THREE.Vector2();

		var panStart = new THREE.Vector2();
		var panEnd = new THREE.Vector2();
		var panDelta = new THREE.Vector2();

		var dollyStart = new THREE.Vector2();
		var dollyEnd = new THREE.Vector2();
		var dollyDelta = new THREE.Vector2();

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		var panLeft = function () {

			var v = new THREE.Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		var panUp = function () {

			var v = new THREE.Vector3();

			return function panUp( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		var pan = function () {

			var offset = new THREE.Vector3();

			return function pan( deltaX, deltaY ) {

				var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

				if ( scope.object instanceof THREE.PerspectiveCamera ) {

					// perspective
					var position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					var targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we actually don't use screenWidth, since perspective camera is fixed to screen height
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object instanceof THREE.OrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyIn( dollyScale ) {

			if ( scope.object instanceof THREE.PerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( scope.object instanceof THREE.OrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyOut( dollyScale ) {

			if ( scope.object instanceof THREE.PerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( scope.object instanceof THREE.OrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			//console.log( 'handleMouseDownRotate' );

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			//console.log( 'handleMouseDownDolly' );

			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			//console.log( 'handleMouseDownPan' );

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			//console.log( 'handleMouseMoveRotate' );

			rotateEnd.set( event.clientX, event.clientY );
			rotateDelta.subVectors( rotateEnd, rotateStart );

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			// rotating across whole screen goes 360 degrees around
			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			//console.log( 'handleMouseMoveDolly' );

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyIn( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyOut( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			//console.log( 'handleMouseMovePan' );

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseUp( event ) {

			// console.log( 'handleMouseUp' );

		}

		function handleMouseWheel( event ) {

			// console.log( 'handleMouseWheel' );

			if ( event.deltaY < 0 ) {

				dollyOut( getZoomScale() );

			} else if ( event.deltaY > 0 ) {

				dollyIn( getZoomScale() );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			//console.log( 'handleKeyDown' );

			switch ( event.keyCode ) {

				case scope.keys.UP:
					pan( 0, scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.BOTTOM:
					pan( 0, - scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.LEFT:
					pan( scope.keyPanSpeed, 0 );
					scope.update();
					break;

				case scope.keys.RIGHT:
					pan( - scope.keyPanSpeed, 0 );
					scope.update();
					break;

			}

		}

		function handleTouchStartRotate( event ) {

			//console.log( 'handleTouchStartRotate' );

			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		}

		function handleTouchStartDolly( event ) {

			//console.log( 'handleTouchStartDolly' );

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartPan( event ) {

			//console.log( 'handleTouchStartPan' );

			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		}

		function handleTouchMoveRotate( event ) {

			//console.log( 'handleTouchMoveRotate' );

			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
			rotateDelta.subVectors( rotateEnd, rotateStart );

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			// rotating across whole screen goes 360 degrees around
			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleTouchMoveDolly( event ) {

			//console.log( 'handleTouchMoveDolly' );

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleTouchMovePan( event ) {

			//console.log( 'handleTouchMovePan' );

			panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			panDelta.subVectors( panEnd, panStart );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleTouchEnd( event ) {

			//console.log( 'handleTouchEnd' );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onMouseDown( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			if ( event.button === scope.mouseButtons.ORBIT ) {

				if ( scope.enableRotate === false ) return;

				handleMouseDownRotate( event );

				state = STATE.ROTATE;

			} else if ( event.button === scope.mouseButtons.ZOOM ) {

				if ( scope.enableZoom === false ) return;

				handleMouseDownDolly( event );

				state = STATE.DOLLY;

			} else if ( event.button === scope.mouseButtons.PAN ) {

				if ( scope.enablePan === false ) return;

				handleMouseDownPan( event );

				state = STATE.PAN;

			}

			if ( state !== STATE.NONE ) {

				document.addEventListener( 'mousemove', onMouseMove, false );
				document.addEventListener( 'mouseup', onMouseUp, false );

				scope.dispatchEvent( startEvent );

			}

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			if ( state === STATE.ROTATE ) {

				if ( scope.enableRotate === false ) return;

				handleMouseMoveRotate( event );

			} else if ( state === STATE.DOLLY ) {

				if ( scope.enableZoom === false ) return;

				handleMouseMoveDolly( event );

			} else if ( state === STATE.PAN ) {

				if ( scope.enablePan === false ) return;

				handleMouseMovePan( event );

			}

		}

		function onMouseUp( event ) {

			if ( scope.enabled === false ) return;

			handleMouseUp( event );

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );

			scope.dispatchEvent( endEvent );

			state = STATE.NONE;

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

			event.preventDefault();
			event.stopPropagation();

			handleMouseWheel( event );

			scope.dispatchEvent( startEvent ); // not sure why these are here...
			scope.dispatchEvent( endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			if ( scope.enabled === false ) return;

			switch ( event.touches.length ) {

				case 1:	// one-fingered touch: rotate

					if ( scope.enableRotate === false ) return;

					handleTouchStartRotate( event );

					state = STATE.TOUCH_ROTATE;

					break;

				case 2:	// two-fingered touch: dolly

					if ( scope.enableZoom === false ) return;

					handleTouchStartDolly( event );

					state = STATE.TOUCH_DOLLY;

					break;

				case 3: // three-fingered touch: pan

					if ( scope.enablePan === false ) return;

					handleTouchStartPan( event );

					state = STATE.TOUCH_PAN;

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( startEvent );

			}

		}

		function onTouchMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			switch ( event.touches.length ) {

				case 1: // one-fingered touch: rotate

					if ( scope.enableRotate === false ) return;
					if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...

					handleTouchMoveRotate( event );

					break;

				case 2: // two-fingered touch: dolly

					if ( scope.enableZoom === false ) return;
					if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...

					handleTouchMoveDolly( event );

					break;

				case 3: // three-fingered touch: pan

					if ( scope.enablePan === false ) return;
					if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...

					handleTouchMovePan( event );

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onTouchEnd( event ) {

			if ( scope.enabled === false ) return;

			handleTouchEnd( event );

			scope.dispatchEvent( endEvent );

			state = STATE.NONE;

		}

		function onContextMenu( event ) {

			event.preventDefault();

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

		scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

		window.addEventListener( 'keydown', onKeyDown, false );

		// force an update at start

		this.update();

	};

	THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
	THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

	Object.defineProperties( THREE.OrbitControls.prototype, {

		center: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
				return this.target;

			}

		},

		// backward compatibility

		noZoom: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
				return ! this.enableZoom;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
				this.enableZoom = ! value;

			}

		},

		noRotate: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
				return ! this.enableRotate;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
				this.enableRotate = ! value;

			}

		},

		noPan: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
				return ! this.enablePan;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
				this.enablePan = ! value;

			}

		},

		noKeys: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
				return ! this.enableKeys;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
				this.enableKeys = ! value;

			}

		},

		staticMoving: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
				return ! this.enableDamping;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
				this.enableDamping = ! value;

			}

		},

		dynamicDampingFactor: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
				return this.dampingFactor;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
				this.dampingFactor = value;

			}

		}

	} );

	// File:examples/js/ColorToJsonOverride.js

	//override the toJSON function to return serialization to its previous state
	THREE.Color.prototype.toJSON = function() {
	  return { r: this.r, g: this.g, b: this.b };
	}

	// File:examples/js/loaders/RGBELoader.js

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 */

	// https://github.com/mrdoob/three.js/issues/5552
	// http://en.wikipedia.org/wiki/RGBE_image_format

	THREE.HDRLoader = THREE.RGBELoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	// extend THREE.DataTextureLoader
	THREE.RGBELoader.prototype = Object.create( THREE.DataTextureLoader.prototype );

	// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
	THREE.RGBELoader.prototype._parser = function( buffer ) {

		var
			/* return codes for rgbe routines */
			RGBE_RETURN_SUCCESS =  0,
			RGBE_RETURN_FAILURE = - 1,

			/* default error routine.  change this to change error handling */
			rgbe_read_error     = 1,
			rgbe_write_error    = 2,
			rgbe_format_error   = 3,
			rgbe_memory_error   = 4,
			rgbe_error = function( rgbe_error_code, msg ) {

				switch ( rgbe_error_code ) {
					case rgbe_read_error: console.error( "THREE.RGBELoader Read Error: " + ( msg || '' ) );
						break;
					case rgbe_write_error: console.error( "THREE.RGBELoader Write Error: " + ( msg || '' ) );
						break;
					case rgbe_format_error:  console.error( "THREE.RGBELoader Bad File Format: " + ( msg || '' ) );
						break;
					default:
					case rgbe_memory_error:  console.error( "THREE.RGBELoader: Error: " + ( msg || '' ) );
				}
				return RGBE_RETURN_FAILURE;

			},

			/* offsets to red, green, and blue components in a data (float) pixel */
			RGBE_DATA_RED      = 0,
			RGBE_DATA_GREEN    = 1,
			RGBE_DATA_BLUE     = 2,

			/* number of floats per pixel, use 4 since stored in rgba image format */
			RGBE_DATA_SIZE     = 4,

			/* flags indicating which fields in an rgbe_header_info are valid */
			RGBE_VALID_PROGRAMTYPE      = 1,
			RGBE_VALID_FORMAT           = 2,
			RGBE_VALID_DIMENSIONS       = 4,

			NEWLINE = "\n",

			fgets = function( buffer, lineLimit, consume ) {

				lineLimit = ! lineLimit ? 1024 : lineLimit;
				var p = buffer.pos,
					i = - 1, len = 0, s = '', chunkSize = 128,
					chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) )
				;
				while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

					s += chunk; len += chunk.length;
					p += chunkSize;
					chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				}

				if ( - 1 < i ) {

					/*for (i=l-1; i>=0; i--) {
						byteCode = m.charCodeAt(i);
						if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
						else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
						if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
					}*/
					if ( false !== consume ) buffer.pos += len + i + 1;
					return s + chunk.slice( 0, i );

				}
				return false;

			},

			/* minimal header reading.  modify if you want to parse more information */
			RGBE_ReadHeader = function( buffer ) {

				var line, match,

					// regexes to parse header info fields
					magic_token_re = /^#\?(\S+)$/,
					gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

					// RGBE format header struct
					header = {

						valid: 0,                         /* indicate which fields are valid */

						string: '',                       /* the actual header string */

						comments: '',                     /* comments found in header */

						programtype: 'RGBE',              /* listed at beginning of file to identify it
														* after "#?".  defaults to "RGBE" */

						format: '',                       /* RGBE format, default 32-bit_rle_rgbe */

						gamma: 1.0,                       /* image has already been gamma corrected with
														* given gamma.  defaults to 1.0 (no correction) */

						exposure: 1.0,                    /* a value of 1.0 in an image corresponds to
														* <exposure> watts/steradian/m^2.
														* defaults to 1.0 */

						width: 0, height: 0               /* image dimensions, width/height */

					}
				;

				if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

					return rgbe_error( rgbe_read_error, "no header found" );

				}
				/* if you want to require the magic token then uncomment the next line */
				if ( ! ( match = line.match( magic_token_re ) ) ) {

					return rgbe_error( rgbe_format_error, "bad initial token" );

				}
				header.valid |= RGBE_VALID_PROGRAMTYPE;
				header.programtype = match[ 1 ];
				header.string += line + "\n";

				while ( true ) {

					line = fgets( buffer );
					if ( false === line ) break;
					header.string += line + "\n";

					if ( '#' === line.charAt( 0 ) ) {

						header.comments += line + "\n";
						continue; // comment line

					}

					if ( match = line.match( gamma_re ) ) {

						header.gamma = parseFloat( match[ 1 ], 10 );

					}
					if ( match = line.match( exposure_re ) ) {

						header.exposure = parseFloat( match[ 1 ], 10 );

					}
					if ( match = line.match( format_re ) ) {

						header.valid |= RGBE_VALID_FORMAT;
						header.format = match[ 1 ];//'32-bit_rle_rgbe';

					}
					if ( match = line.match( dimensions_re ) ) {

						header.valid |= RGBE_VALID_DIMENSIONS;
						header.height = parseInt( match[ 1 ], 10 );
						header.width = parseInt( match[ 2 ], 10 );

					}

					if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;

				}

				if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

					return rgbe_error( rgbe_format_error, "missing format specifier" );

				}
				if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

					return rgbe_error( rgbe_format_error, "missing image size specifier" );

				}

				return header;

			},

			RGBE_ReadPixels_RLE = function( buffer, w, h ) {

				var data_rgba, offset, pos, count, byteValue,
					scanline_buffer, ptr, ptr_end, i, l, off, isEncodedRun,
					scanline_width = w, num_scanlines = h, rgbeStart
				;

				if (
					// run length encoding is not allowed so read flat
					( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
					// this file is not run length encoded
					( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
				) {

					// return the flat buffer
					return new Uint8Array( buffer );

				}

				if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

					return rgbe_error( rgbe_format_error, "wrong scanline width" );

				}

				data_rgba = new Uint8Array( 4 * w * h );

				if ( ! data_rgba || ! data_rgba.length ) {

					return rgbe_error( rgbe_memory_error, "unable to allocate buffer space" );

				}

				offset = 0; pos = 0; ptr_end = 4 * scanline_width;
				rgbeStart = new Uint8Array( 4 );
				scanline_buffer = new Uint8Array( ptr_end );

				// read in each successive scanline
				while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

					if ( pos + 4 > buffer.byteLength ) {

						return rgbe_error( rgbe_read_error );

					}

					rgbeStart[ 0 ] = buffer[ pos ++ ];
					rgbeStart[ 1 ] = buffer[ pos ++ ];
					rgbeStart[ 2 ] = buffer[ pos ++ ];
					rgbeStart[ 3 ] = buffer[ pos ++ ];

					if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

						return rgbe_error( rgbe_format_error, "bad rgbe scanline format" );

					}

					// read each of the four channels for the scanline into the buffer
					// first red, then green, then blue, then exponent
					ptr = 0;
					while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

						count = buffer[ pos ++ ];
						isEncodedRun = count > 128;
						if ( isEncodedRun ) count -= 128;

						if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

							return rgbe_error( rgbe_format_error, "bad scanline data" );

						}

						if ( isEncodedRun ) {

							// a (encoded) run of the same value
							byteValue = buffer[ pos ++ ];
							for ( i = 0; i < count; i ++ ) {

								scanline_buffer[ ptr ++ ] = byteValue;

							}
							//ptr += count;

						} else {

							// a literal-run
							scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
							ptr += count; pos += count;

						}

					}


					// now convert data from buffer into rgba
					// first red, then green, then blue, then exponent (alpha)
					l = scanline_width; //scanline_buffer.byteLength;
					for ( i = 0; i < l; i ++ ) {

						off = 0;
						data_rgba[ offset ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
						offset += 4;

					}

					num_scanlines --;

				}

				return data_rgba;

			}
		;

		var byteArray = new Uint8Array( buffer ),
			byteLength = byteArray.byteLength;
		byteArray.pos = 0;
		var rgbe_header_info = RGBE_ReadHeader( byteArray );

		if ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {

			var w = rgbe_header_info.width,
				h = rgbe_header_info.height
				, image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h )
			;
			if ( RGBE_RETURN_FAILURE !== image_rgba_data ) {

				return {
					width: w, height: h,
					data: image_rgba_data,
					header: rgbe_header_info.string,
					gamma: rgbe_header_info.gamma,
					exposure: rgbe_header_info.exposure,
					format: THREE.RGBEFormat, // handled as THREE.RGBAFormat in shaders
					type: THREE.UnsignedByteType
				};

			}

		}
		return null;

	};

	// File:examples/js/cameras/CombinedCamera.js

	/**
	 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
	 *
	 *		A general perpose camera, for setting FOV, Lens Focal Length,
	 *		and switching between perspective and orthographic views easily.
	 *		Use this only if you do not wish to manage
	 *		both a Orthographic and Perspective Camera
	 *
	 */


	THREE.CombinedCamera = function ( width, height, fov, near, far) {

		THREE.Camera.call( this );
		// perspective
		this.fov = fov;
		this.far = far;
		this.near = near;
		//orthographic
		this.left = - width / 2;
		this.right = width / 2;
		this.top = height / 2;
		this.bottom = - height / 2;

		this.aspect =  width / height;
		this.zoom = 1;
		this.focus = 10;
		this.view = null;
		this.hyperfocusOffset = 0;
		this.hyperfocusScale = 0.5;
		// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects

		this.cameraO = new THREE.OrthographicCamera( this.left, this.right, this.top, this.bottom, this.near, this.far );
		this.cameraP = new THREE.PerspectiveCamera( this.fov, this.aspect, this.near, this.far );

		this.toPerspective();

	};

	THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.CombinedCamera.prototype.constructor = THREE.CombinedCamera;

	THREE.CombinedCamera.prototype.toPerspective = function () {

		// Switches to the Perspective Camera

		this.cameraP.near = this.near;
		this.cameraP.far = this.far;
		this.cameraP.aspect = this.aspect;
		this.cameraP.fov =  this.fov;
		this.cameraP.zoom = this.zoom;
		this.cameraP.view = this.view;
		this.cameraP.focus = this.focus;

		this.cameraP.updateProjectionMatrix();

		this.projectionMatrix = this.cameraP.projectionMatrix;

		this.inPerspectiveMode = true;
		this.inOrthographicMode = false;

	};

	THREE.CombinedCamera.prototype.toOrthographic = function () {

		// Switches to the Orthographic camera estimating viewport from Perspective

		var fov = this.fov;
		var aspect = this.aspect;

		var halfHeight = Math.tan( fov * Math.PI / 180 / 2 ) * (this.hyperfocusOffset + this.hyperfocusScale * ( this.near + this.far ));
		var halfWidth = halfHeight * aspect;

		this.cameraO.near = this.near;
		this.cameraO.far = this.far;
		this.cameraO.left = - halfWidth;
		this.cameraO.right = halfWidth;
		this.cameraO.top = halfHeight;
		this.cameraO.bottom = - halfHeight;

		this.cameraO.zoom = this.zoom;
		this.cameraO.view = this.view;

		this.cameraO.updateProjectionMatrix();

		this.projectionMatrix = this.cameraO.projectionMatrix;

		this.inPerspectiveMode = false;
		this.inOrthographicMode = true;

	};


	THREE.CombinedCamera.prototype.setSize = function( width, height ) {

		this.aspect = width / height;
		this.left = - width / 2;
		this.right = width / 2;
		this.top = height / 2;
		this.bottom = - height / 2;

	};


	THREE.CombinedCamera.prototype.setFov = function( fov ) {

		this.fov = fov;

		if ( this.inPerspectiveMode ) {

			this.toPerspective();

		} else {

			this.toOrthographic();

		}

	};

	THREE.CombinedCamera.prototype.copy = function ( source ) {

		THREE.Camera.prototype.copy.call( this, source );

		this.fov = source.fov;
		this.far = source.far;
		this.near = source.near;

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );
		this.aspect = source.aspect;
		this.hyperfocusOffset = source.hyperfocusOffset;
		this.hyperfocusScale = source.hyperfocusScale;

		this.cameraO.copy(source.cameraO);
		this.cameraP.copy(source.cameraP);

		this.inOrthographicMode = source.inOrthographicMode;
		this.inPerspectiveMode = source.inPerspectiveMode;

		return this;

	};

	THREE.CombinedCamera.prototype.setViewOffset = function( fullWidth, fullHeight, x, y, width, height ) {

		this.view = {
			fullWidth: fullWidth,
			fullHeight: fullHeight,
			offsetX: x,
			offsetY: y,
			width: width,
			height: height
		};

		if ( this.inPerspectiveMode ) {

			this.aspect = fullWidth / fullHeight;

			this.toPerspective();

		} else {

			this.toOrthographic();

		}

	};

	THREE.CombinedCamera.prototype.clearViewOffset = function() {

		this.view = null;
		this.updateProjectionMatrix();

	};
	// For maintaining similar API with PerspectiveCamera

	THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {

		if ( this.inPerspectiveMode ) {

			this.toPerspective();

		} else {

			this.toPerspective();
			this.toOrthographic();

		}

	};

	/*
	* Uses Focal Length (in mm) to estimate and set FOV
	* 35mm (full frame) camera is used if frame size is not specified;
	* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	*/
	THREE.CombinedCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		if ( filmGauge === undefined ) filmGauge = 35;

		var vExtentSlope = 0.5 * filmGauge /
				( focalLength * Math.max( this.cameraP.aspect, 1 ) );

		var fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );

		this.setFov( fov );

		return fov;

	};


	THREE.CombinedCamera.prototype.setZoom = function( zoom ) {

		this.zoom = zoom;

		if ( this.inPerspectiveMode ) {

			this.toPerspective();

		} else {

			this.toOrthographic();

		}

	};

	THREE.CombinedCamera.prototype.toFrontView = function() {

		this.rotation.x = 0;
		this.rotation.y = 0;
		this.rotation.z = 0;

		this.position.x = 0;
		this.position.y = 0;
		this.position.z = -15;
		// should we be modifing the matrix instead?

	};

	THREE.CombinedCamera.prototype.toBackView = function() {

		this.rotation.x = 0;
		this.rotation.y = Math.PI;
		this.rotation.z = 0;

		this.position.x = 0;
		this.position.y = 0;
		this.position.z = 15;

	};

	THREE.CombinedCamera.prototype.toLeftView = function() {

		this.rotation.x = 0;
		this.rotation.y = - Math.PI / 2;
		this.rotation.z = 0;

		this.position.x = -15;
		this.position.y = 0;
		this.position.z = 0;

	};

	THREE.CombinedCamera.prototype.toRightView = function() {

		this.rotation.x = 0;
		this.rotation.y = Math.PI / 2;
		this.rotation.z = 0;

		this.position.x = 15;
		this.position.y = 0;
		this.position.z = 0;

	};

	THREE.CombinedCamera.prototype.toTopView = function() {

		this.rotation.x = - Math.PI / 2;
		this.rotation.y = 0;
		this.rotation.z = 0;

		this.position.x = 0;
		this.position.y = 15;
		this.position.z = 0;

	};

	THREE.CombinedCamera.prototype.toBottomView = function() {

		this.rotation.x = Math.PI / 2;
		this.rotation.y = 0;
		this.rotation.z = 0;

		this.position.x = 0;
		this.position.y = -15;
		this.position.z = 0;

	};

	THREE.CombinedCamera.prototype.toPerspectiveView = function() {

		this.rotation.x = - Math.PI / 4;
		this.rotation.y = - Math.PI / 4;
		this.rotation.z = 0;

		this.position.x = 4;
		this.position.y = 4;
		this.position.z = 4;

	};

	// File:examples/js/effects/ParallaxBarrierEffect.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author marklundin / http://mark-lundin.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ParallaxBarrierEffect = function ( renderer ) {

		var _camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

		var _scene = new THREE.Scene();

		var _stereo = new THREE.StereoCamera();

		var _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };

		var _renderTargetL = new THREE.WebGLRenderTarget( 512, 512, _params );
		var _renderTargetR = new THREE.WebGLRenderTarget( 512, 512, _params );

		var _material = new THREE.ShaderMaterial( {

			uniforms: {

				"mapLeft": { value: _renderTargetL.texture },
				"mapRight": { value: _renderTargetR.texture }

			},

			vertexShader: [

				"varying vec2 vUv;",

				"void main() {",

				"	vUv = vec2( uv.x, uv.y );",
				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform sampler2D mapLeft;",
				"uniform sampler2D mapRight;",
				"varying vec2 vUv;",

				"void main() {",

				"	vec2 uv = vUv;",

				"	if ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {",

				"		gl_FragColor = texture2D( mapLeft, uv );",

				"	} else {",

				"		gl_FragColor = texture2D( mapRight, uv );",

				"	}",

				"}"

			].join( "\n" )

		} );

		var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), _material );
		_scene.add( mesh );

		this.setSize = function ( width, height ) {

			renderer.setSize( width, height );

			var pixelRatio = renderer.getPixelRatio();

			_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );
			_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );

		};

		this.render = function ( scene, camera ) {

			scene.updateMatrixWorld();

			if ( camera.parent === null ) camera.updateMatrixWorld();

			_stereo.update( camera );

			renderer.render( scene, _stereo.cameraL, _renderTargetL, true );
			renderer.render( scene, _stereo.cameraR, _renderTargetR, true );
			renderer.render( _scene, _camera );

		};

	};

	// File:examples/js/effects/StereoEffect.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @authod mrdoob / http://mrdoob.com/
	 * @authod arodic / http://aleksandarrodic.com/
	 * @authod fonserbc / http://fonserbc.github.io/
	*/

	THREE.StereoEffect = function ( renderer ) {

		var _stereo = new THREE.StereoCamera();
		_stereo.aspect = 0.5;

		this.setEyeSeparation = function ( eyeSep ) {

			_stereo.eyeSep = eyeSep;

		};

		this.setSize = function ( width, height ) {

			renderer.setSize( width, height );

		};

		this.render = function ( scene, camera ) {

			scene.updateMatrixWorld();

			if ( camera.parent === null ) camera.updateMatrixWorld();

			_stereo.update( camera );

			var size = renderer.getSize();

			if ( renderer.autoClear ) renderer.clear();
			renderer.setScissorTest( true );

			renderer.setScissor( 0, 0, size.width / 2, size.height );
			renderer.setViewport( 0, 0, size.width / 2, size.height );
			renderer.render( scene, _stereo.cameraL );

			renderer.setScissor( size.width / 2, 0, size.width / 2, size.height );
			renderer.setViewport( size.width / 2, 0, size.width / 2, size.height );
			renderer.render( scene, _stereo.cameraR );

			renderer.setScissorTest( false );

		};

	};

	// File:examples/js/shaders/FXAAShader.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author davidedc / http://www.sketchpatch.net/
	 *
	 * NVIDIA FXAA by Timothy Lottes
	 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
	 * - WebGL port by @supereggbert
	 * http://www.glge.org/demos/fxaa/
	 */

	THREE.FXAAShader = {

		uniforms: {

			"tDiffuse":   { value: null },
			"resolution": { value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

		},

		vertexShader: [

			"void main() {",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform sampler2D tDiffuse;",
			"uniform vec2 resolution;",

			"#define FXAA_REDUCE_MIN   (1.0/128.0)",
			"#define FXAA_REDUCE_MUL   (1.0/8.0)",
			"#define FXAA_SPAN_MAX     8.0",

			"void main() {",

				"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
				"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
				"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
				"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
				"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
				"vec3 rgbM  = rgbaM.xyz;",
				"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

				"float lumaNW = dot( rgbNW, luma );",
				"float lumaNE = dot( rgbNE, luma );",
				"float lumaSW = dot( rgbSW, luma );",
				"float lumaSE = dot( rgbSE, luma );",
				"float lumaM  = dot( rgbM,  luma );",
				"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
				"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",

				"vec2 dir;",
				"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
				"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",

				"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",

				"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
				"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
					  "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
							"dir * rcpDirMin)) * resolution;",
				"vec4 rgbA = (1.0/2.0) * (",
	        	"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +",
				"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));",
	    		"vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (",
				"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +",
	      		"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));",
	    		"float lumaB = dot(rgbB, vec4(luma, 0.0));",

				"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",

					"gl_FragColor = rgbA;",

				"} else {",
					"gl_FragColor = rgbB;",

				"}",

			"}"

		].join( "\n" )

	};

	// File:examples/js/postprocessing/OutlinePass.js

	/**
	 * @author spidersharma / http://eduperiment.com/
	 */

	THREE.OutlinePass = function ( resolution, scene, camera, selectedObjects ) {

		this.renderScene = scene;
		this.renderCamera = camera;
		this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];
		this.visibleEdgeColor = new THREE.Color( 1, 1, 1 );
		this.hiddenEdgeColor = new THREE.Color( 0.1, 0.04, 0.02 );
		this.edgeGlow = 0.0;
		this.usePatternTexture = false;
		this.edgeThickness = 1.0;
		this.edgeStrength = 3.0;
		this.downSampleRatio = 2;
		this.pulsePeriod = 0;

		THREE.Pass.call( this );

		this.resolution = ( resolution !== undefined ) ? new THREE.Vector2( resolution.x, resolution.y ) : new THREE.Vector2( 256, 256 );

		var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

		var resx = Math.round( this.resolution.x / this.downSampleRatio );
		var resy = Math.round( this.resolution.y / this.downSampleRatio );

		this.maskBufferMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );
		this.maskBufferMaterial.side = THREE.DoubleSide;
		this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );
		this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask";
		this.renderTargetMaskBuffer.texture.generateMipmaps = false;

		this.depthMaterial = new THREE.MeshDepthMaterial();
		this.depthMaterial.side = THREE.DoubleSide;
		this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
		this.depthMaterial.blending = THREE.NoBlending;

		this.prepareMaskMaterial = this.getPrepareMaskMaterial();
		this.prepareMaskMaterial.side = THREE.DoubleSide;

		this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );
		this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth";
		this.renderTargetDepthBuffer.texture.generateMipmaps = false;

		this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget( resx, resy, pars );
		this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample";
		this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;

		this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget( resx, resy, pars );
		this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1";
		this.renderTargetBlurBuffer1.texture.generateMipmaps = false;

		this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );
		this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2";
		this.renderTargetBlurBuffer2.texture.generateMipmaps = false;

		this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
		this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget( resx, resy, pars );
		this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1";
		this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;

		this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );
		this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2";
		this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;

		var MAX_EDGE_THICKNESS = 4;
		var MAX_EDGE_GLOW = 4;

		this.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );
		this.separableBlurMaterial1.uniforms[ "texSize" ].value = new THREE.Vector2( resx, resy );
		this.separableBlurMaterial1.uniforms[ "kernelRadius" ].value = 1;
		this.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );
		this.separableBlurMaterial2.uniforms[ "texSize" ].value = new THREE.Vector2( Math.round( resx / 2 ), Math.round( resy / 2 ) );
		this.separableBlurMaterial2.uniforms[ "kernelRadius" ].value = MAX_EDGE_GLOW;

		// Overlay material
		this.overlayMaterial = this.getOverlayMaterial();

		// copy material
		if ( THREE.CopyShader === undefined )
			console.error( "THREE.OutlinePass relies on THREE.CopyShader" );

		var copyShader = THREE.CopyShader;

		this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );
		this.copyUniforms[ "opacity" ].value = 1.0;

		this.materialCopy = new THREE.ShaderMaterial( {
			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: THREE.NoBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		} );

		this.enabled = true;
		this.needsSwap = false;

		this.oldClearColor = new THREE.Color();
		this.oldClearAlpha = 1;

		this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		this.scene = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
		this.quad.frustumCulled = false; // Avoid getting clipped
		this.scene.add( this.quad );

		this.tempPulseColor1 = new THREE.Color();
		this.tempPulseColor2 = new THREE.Color();
		this.textureMatrix = new THREE.Matrix4();

	};

	THREE.OutlinePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

		constructor: THREE.OutlinePass,

		dispose: function () {

			this.renderTargetMaskBuffer.dispose();
			this.renderTargetDepthBuffer.dispose();
			this.renderTargetMaskDownSampleBuffer.dispose();
			this.renderTargetBlurBuffer1.dispose();
			this.renderTargetBlurBuffer2.dispose();
			this.renderTargetEdgeBuffer1.dispose();
			this.renderTargetEdgeBuffer2.dispose();

		},

		setSize: function ( width, height ) {

			this.renderTargetMaskBuffer.setSize( width, height );

			var resx = Math.round( width / this.downSampleRatio );
			var resy = Math.round( height / this.downSampleRatio );
			this.renderTargetMaskDownSampleBuffer.setSize( resx, resy );
			this.renderTargetBlurBuffer1.setSize( resx, resy );
			this.renderTargetEdgeBuffer1.setSize( resx, resy );
			this.separableBlurMaterial1.uniforms[ "texSize" ].value = new THREE.Vector2( resx, resy );

			resx = Math.round( resx / 2 );
			resy = Math.round( resy / 2 );

			this.renderTargetBlurBuffer2.setSize( resx, resy );
			this.renderTargetEdgeBuffer2.setSize( resx, resy );

			this.separableBlurMaterial2.uniforms[ "texSize" ].value = new THREE.Vector2( resx, resy );

		},

		changeVisibilityOfSelectedObjects: function ( bVisible ) {

			function gatherSelectedMeshesCallBack( object ) {

				if ( object instanceof THREE.Mesh ) object.visible = bVisible;

			}

			for ( var i = 0; i < this.selectedObjects.length; i ++ ) {

				var selectedObject = this.selectedObjects[ i ];
				selectedObject.traverse( gatherSelectedMeshesCallBack );

			}

		},

		changeVisibilityOfNonSelectedObjects: function ( bVisible ) {

			var selectedMeshes = [];

			function gatherSelectedMeshesCallBack( object ) {

				if ( object instanceof THREE.Mesh ) selectedMeshes.push( object );

			}

			for ( var i = 0; i < this.selectedObjects.length; i ++ ) {

				var selectedObject = this.selectedObjects[ i ];
				selectedObject.traverse( gatherSelectedMeshesCallBack );

			}

			function VisibilityChangeCallBack( object ) {

				if ( object instanceof THREE.Mesh ) {

					var bFound = false;

					for ( var i = 0; i < selectedMeshes.length; i ++ ) {

						var selectedObjectId = selectedMeshes[ i ].id;

						if ( selectedObjectId === object.id ) {

							bFound = true;
							break;

						}

					}

					if ( ! bFound ) {

						var visibility = object.visible;

						if ( ! bVisible || object.bVisible ) object.visible = bVisible;

						object.bVisible = visibility;

					}

				}

			}

			this.renderScene.traverse( VisibilityChangeCallBack );

		},

		updateTextureMatrix: function () {

			this.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,
															0.0, 0.5, 0.0, 0.5,
															0.0, 0.0, 0.5, 0.5,
															0.0, 0.0, 0.0, 1.0 );
			this.textureMatrix.multiply( this.renderCamera.projectionMatrix );
			this.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );

		},

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			if ( this.selectedObjects.length === 0 ) return;

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();
			var oldAutoClear = renderer.autoClear;

			renderer.autoClear = false;

			if ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );

			renderer.setClearColor( 0xffffff, 1 );

			// Make selected objects invisible
			this.changeVisibilityOfSelectedObjects( false );

			// 1. Draw Non Selected objects in the depth buffer
			this.renderScene.overrideMaterial = this.depthMaterial;
			renderer.render( this.renderScene, this.renderCamera, this.renderTargetDepthBuffer, true );

			// Make selected objects visible
			this.changeVisibilityOfSelectedObjects( true );

			// Update Texture Matrix for Depth compare
			this.updateTextureMatrix();

			// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
			this.changeVisibilityOfNonSelectedObjects( false );
			this.renderScene.overrideMaterial = this.prepareMaskMaterial;
			this.prepareMaskMaterial.uniforms[ "cameraNearFar" ].value = new THREE.Vector2( this.renderCamera.near, this.renderCamera.far );
			this.prepareMaskMaterial.uniforms[ "depthTexture" ].value = this.renderTargetDepthBuffer.texture;
			this.prepareMaskMaterial.uniforms[ "textureMatrix" ].value = this.textureMatrix;
			renderer.render( this.renderScene, this.renderCamera, this.renderTargetMaskBuffer, true );
			this.renderScene.overrideMaterial = null;
			this.changeVisibilityOfNonSelectedObjects( true );

			// 2. Downsample to Half resolution
			this.quad.material = this.materialCopy;
			this.copyUniforms[ "tDiffuse" ].value = this.renderTargetMaskBuffer.texture;
			renderer.render( this.scene, this.camera, this.renderTargetMaskDownSampleBuffer, true );

			this.tempPulseColor1.copy( this.visibleEdgeColor );
			this.tempPulseColor2.copy( this.hiddenEdgeColor );

			if ( this.pulsePeriod > 0 ) {

				var scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;
				this.tempPulseColor1.multiplyScalar( scalar );
				this.tempPulseColor2.multiplyScalar( scalar );

			}

			// 3. Apply Edge Detection Pass
			this.quad.material = this.edgeDetectionMaterial;
			this.edgeDetectionMaterial.uniforms[ "maskTexture" ].value = this.renderTargetMaskDownSampleBuffer.texture;
			this.edgeDetectionMaterial.uniforms[ "texSize" ].value = new THREE.Vector2( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );
			this.edgeDetectionMaterial.uniforms[ "visibleEdgeColor" ].value = this.tempPulseColor1;
			this.edgeDetectionMaterial.uniforms[ "hiddenEdgeColor" ].value = this.tempPulseColor2;
			renderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer1, true );

			// 4. Apply Blur on Half res
			this.quad.material = this.separableBlurMaterial1;
			this.separableBlurMaterial1.uniforms[ "colorTexture" ].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial1.uniforms[ "direction" ].value = THREE.OutlinePass.BlurDirectionX;
			this.separableBlurMaterial1.uniforms[ "kernelRadius" ].value = this.edgeThickness;
			renderer.render( this.scene, this.camera, this.renderTargetBlurBuffer1, true );
			this.separableBlurMaterial1.uniforms[ "colorTexture" ].value = this.renderTargetBlurBuffer1.texture;
			this.separableBlurMaterial1.uniforms[ "direction" ].value = THREE.OutlinePass.BlurDirectionY;
			renderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer1, true );

			// Apply Blur on quarter res
			this.quad.material = this.separableBlurMaterial2;
			this.separableBlurMaterial2.uniforms[ "colorTexture" ].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial2.uniforms[ "direction" ].value = THREE.OutlinePass.BlurDirectionX;
			renderer.render( this.scene, this.camera, this.renderTargetBlurBuffer2, true );
			this.separableBlurMaterial2.uniforms[ "colorTexture" ].value = this.renderTargetBlurBuffer2.texture;
			this.separableBlurMaterial2.uniforms[ "direction" ].value = THREE.OutlinePass.BlurDirectionY;
			renderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer2, true );

			// Blend it additively over the input texture
			this.quad.material = this.overlayMaterial;
			this.overlayMaterial.uniforms[ "maskTexture" ].value = this.renderTargetMaskBuffer.texture;
			this.overlayMaterial.uniforms[ "edgeTexture1" ].value = this.renderTargetEdgeBuffer1.texture;
			this.overlayMaterial.uniforms[ "edgeTexture2" ].value = this.renderTargetEdgeBuffer2.texture;
			this.overlayMaterial.uniforms[ "patternTexture" ].value = this.patternTexture;
			this.overlayMaterial.uniforms[ "edgeStrength" ].value = this.edgeStrength;
			this.overlayMaterial.uniforms[ "edgeGlow" ].value = this.edgeGlow;
			this.overlayMaterial.uniforms[ "usePatternTexture" ].value = this.usePatternTexture;


			if ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );

			renderer.render( this.scene, this.camera, readBuffer, false );

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
			renderer.autoClear = oldAutoClear;

		},

		getPrepareMaskMaterial: function () {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"depthTexture": { value: null },
					"cameraNearFar": { value: new THREE.Vector2( 0.5, 0.5 ) },
					"textureMatrix": { value: new THREE.Matrix4() }
				},

				vertexShader:
					"varying vec2 vUv;\
					varying vec4 projTexCoord;\
					varying vec4 vPosition;\
					uniform mat4 textureMatrix;\
					void main() {\
						vUv = uv;\
						vPosition = modelViewMatrix * vec4( position, 1.0 );\
						vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\
						projTexCoord = textureMatrix * worldPosition;\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <packing>\
					varying vec2 vUv;\
					varying vec4 vPosition;\
					varying vec4 projTexCoord;\
					uniform sampler2D depthTexture;\
					uniform vec2 cameraNearFar;\
					\
					void main() {\
						float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\
						float viewZ = -perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );\
						float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\
						gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\
					}"
			} );

		},

		getEdgeDetectionMaterial: function () {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"maskTexture": { value: null },
					"texSize": { value: new THREE.Vector2( 0.5, 0.5 ) },
					"visibleEdgeColor": { value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },
					"hiddenEdgeColor": { value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"varying vec2 vUv;\
					uniform sampler2D maskTexture;\
					uniform vec2 texSize;\
					uniform vec3 visibleEdgeColor;\
					uniform vec3 hiddenEdgeColor;\
					\
					void main() {\n\
						vec2 invSize = 1.0 / texSize;\
						vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\
						vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\
						vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\
						vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\
						vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\
						float diff1 = (c1.r - c2.r)*0.5;\
						float diff2 = (c3.r - c4.r)*0.5;\
						float d = length( vec2(diff1, diff2) );\
						float a1 = min(c1.g, c2.g);\
						float a2 = min(c3.g, c4.g);\
						float visibilityFactor = min(a1, a2);\
						vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\
						gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\
					}"
			} );

		},

		getSeperableBlurMaterial: function ( maxRadius ) {

			return new THREE.ShaderMaterial( {

				defines: {
					"MAX_RADIUS": maxRadius,
				},

				uniforms: {
					"colorTexture": { value: null },
					"texSize": { value: new THREE.Vector2( 0.5, 0.5 ) },
					"direction": { value: new THREE.Vector2( 0.5, 0.5 ) },
					"kernelRadius": { value: 1.0 }
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"#include <common>\
					varying vec2 vUv;\
					uniform sampler2D colorTexture;\
					uniform vec2 texSize;\
					uniform vec2 direction;\
					uniform float kernelRadius;\
					\
					float gaussianPdf(in float x, in float sigma) {\
						return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
					}\
					void main() {\
						vec2 invSize = 1.0 / texSize;\
						float weightSum = gaussianPdf(0.0, kernelRadius);\
						vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
						vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\
						vec2 uvOffset = delta;\
						for( int i = 1; i <= MAX_RADIUS; i ++ ) {\
							float w = gaussianPdf(uvOffset.x, kernelRadius);\
							vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
							vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
							diffuseSum += ((sample1 + sample2) * w);\
							weightSum += (2.0 * w);\
							uvOffset += delta;\
						}\
						gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\
					}"
			} );

		},

		getOverlayMaterial: function () {

			return new THREE.ShaderMaterial( {

				uniforms: {
					"maskTexture": { value: null },
					"edgeTexture1": { value: null },
					"edgeTexture2": { value: null },
					"patternTexture": { value: null },
					"edgeStrength": { value: 1.0 },
					"edgeGlow": { value: 1.0 },
					"usePatternTexture": { value: 0.0 }
				},

				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader:
					"varying vec2 vUv;\
					uniform sampler2D maskTexture;\
					uniform sampler2D edgeTexture1;\
					uniform sampler2D edgeTexture2;\
					uniform sampler2D patternTexture;\
					uniform float edgeStrength;\
					uniform float edgeGlow;\
					uniform bool usePatternTexture;\
					\
					void main() {\
						vec4 edgeValue1 = texture2D(edgeTexture1, vUv);\
						vec4 edgeValue2 = texture2D(edgeTexture2, vUv);\
						vec4 maskColor = texture2D(maskTexture, vUv);\
						vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\
						float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\
						vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\
						vec4 finalColor = edgeStrength * maskColor.r * edgeValue;\
						if(usePatternTexture)\
							finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\
						gl_FragColor = finalColor;\
					}",
				blending: THREE.AdditiveBlending,
				depthTest: false,
				depthWrite: false,
				transparent: true
			} );

		}

	} );

	THREE.OutlinePass.BlurDirectionX = new THREE.Vector2( 1.0, 0.0 );
	THREE.OutlinePass.BlurDirectionY = new THREE.Vector2( 0.0, 1.0 );


	module.exports = THREE;


/***/ },
/* 65 */
/*!**************************!*\
  !*** ./~/three/three.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.THREE = global.THREE || {})));
	}(this, (function (exports) { 'use strict';

		// Polyfills

		if ( Number.EPSILON === undefined ) {

			Number.EPSILON = Math.pow( 2, - 52 );

		}

		//

		if ( Math.sign === undefined ) {

			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

			Math.sign = function ( x ) {

				return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

			};

		}

		if ( Function.prototype.name === undefined ) {

			// Missing in IE9-11.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

			Object.defineProperty( Function.prototype, 'name', {

				get: function () {

					return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

				}

			} );

		}

		if ( Object.assign === undefined ) {

			// Missing in IE.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

			( function () {

				Object.assign = function ( target ) {

					'use strict';

					if ( target === undefined || target === null ) {

						throw new TypeError( 'Cannot convert undefined or null to object' );

					}

					var output = Object( target );

					for ( var index = 1; index < arguments.length; index ++ ) {

						var source = arguments[ index ];

						if ( source !== undefined && source !== null ) {

							for ( var nextKey in source ) {

								if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

									output[ nextKey ] = source[ nextKey ];

								}

							}

						}

					}

					return output;

				};

			} )();

		}

		/**
		 * https://github.com/mrdoob/eventdispatcher.js/
		 */

		function EventDispatcher() {}

		EventDispatcher.prototype = {

			addEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) this._listeners = {};

				var listeners = this._listeners;

				if ( listeners[ type ] === undefined ) {

					listeners[ type ] = [];

				}

				if ( listeners[ type ].indexOf( listener ) === - 1 ) {

					listeners[ type ].push( listener );

				}

			},

			hasEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) return false;

				var listeners = this._listeners;

				return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

			},

			removeEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) return;

				var listeners = this._listeners;
				var listenerArray = listeners[ type ];

				if ( listenerArray !== undefined ) {

					var index = listenerArray.indexOf( listener );

					if ( index !== - 1 ) {

						listenerArray.splice( index, 1 );

					}

				}

			},

			dispatchEvent: function ( event ) {

				if ( this._listeners === undefined ) return;

				var listeners = this._listeners;
				var listenerArray = listeners[ event.type ];

				if ( listenerArray !== undefined ) {

					event.target = this;

					var array = [], i = 0;
					var length = listenerArray.length;

					for ( i = 0; i < length; i ++ ) {

						array[ i ] = listenerArray[ i ];

					}

					for ( i = 0; i < length; i ++ ) {

						array[ i ].call( this, event );

					}

				}

			}

		};

		var REVISION = '84dev';
		var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
		var CullFaceNone = 0;
		var CullFaceBack = 1;
		var CullFaceFront = 2;
		var CullFaceFrontBack = 3;
		var FrontFaceDirectionCW = 0;
		var FrontFaceDirectionCCW = 1;
		var BasicShadowMap = 0;
		var PCFShadowMap = 1;
		var PCFSoftShadowMap = 2;
		var PCSSSoftShadowMap = 3;
		var FrontSide = 0;
		var BackSide = 1;
		var DoubleSide = 2;
		var FlatShading = 1;
		var SmoothShading = 2;
		var NoColors = 0;
		var FaceColors = 1;
		var VertexColors = 2;
		var NoBlending = 0;
		var NormalBlending = 1;
		var AdditiveBlending = 2;
		var SubtractiveBlending = 3;
		var MultiplyBlending = 4;
		var CustomBlending = 5;
		var AddEquation = 100;
		var SubtractEquation = 101;
		var ReverseSubtractEquation = 102;
		var MinEquation = 103;
		var MaxEquation = 104;
		var ZeroFactor = 200;
		var OneFactor = 201;
		var SrcColorFactor = 202;
		var OneMinusSrcColorFactor = 203;
		var SrcAlphaFactor = 204;
		var OneMinusSrcAlphaFactor = 205;
		var DstAlphaFactor = 206;
		var OneMinusDstAlphaFactor = 207;
		var DstColorFactor = 208;
		var OneMinusDstColorFactor = 209;
		var SrcAlphaSaturateFactor = 210;
		var NeverDepth = 0;
		var AlwaysDepth = 1;
		var LessDepth = 2;
		var LessEqualDepth = 3;
		var EqualDepth = 4;
		var GreaterEqualDepth = 5;
		var GreaterDepth = 6;
		var NotEqualDepth = 7;
		var MultiplyOperation = 0;
		var MixOperation = 1;
		var AddOperation = 2;
		var NoToneMapping = 0;
		var LinearToneMapping = 1;
		var ReinhardToneMapping = 2;
		var Uncharted2ToneMapping = 3;
		var CineonToneMapping = 4;
		var UVMapping = 300;
		var CubeReflectionMapping = 301;
		var CubeRefractionMapping = 302;
		var EquirectangularReflectionMapping = 303;
		var EquirectangularRefractionMapping = 304;
		var SphericalReflectionMapping = 305;
		var CubeUVReflectionMapping = 306;
		var CubeUVRefractionMapping = 307;
		var RepeatWrapping = 1000;
		var ClampToEdgeWrapping = 1001;
		var MirroredRepeatWrapping = 1002;
		var NearestFilter = 1003;
		var NearestMipMapNearestFilter = 1004;
		var NearestMipMapLinearFilter = 1005;
		var LinearFilter = 1006;
		var LinearMipMapNearestFilter = 1007;
		var LinearMipMapLinearFilter = 1008;
		var UnsignedByteType = 1009;
		var ByteType = 1010;
		var ShortType = 1011;
		var UnsignedShortType = 1012;
		var IntType = 1013;
		var UnsignedIntType = 1014;
		var FloatType = 1015;
		var HalfFloatType = 1016;
		var UnsignedShort4444Type = 1017;
		var UnsignedShort5551Type = 1018;
		var UnsignedShort565Type = 1019;
		var UnsignedInt248Type = 1020;
		var AlphaFormat = 1021;
		var RGBFormat = 1022;
		var RGBAFormat = 1023;
		var LuminanceFormat = 1024;
		var LuminanceAlphaFormat = 1025;
		var RGBEFormat = RGBAFormat;
		var DepthFormat = 1026;
		var DepthStencilFormat = 1027;
		var RGB_S3TC_DXT1_Format = 2001;
		var RGBA_S3TC_DXT1_Format = 2002;
		var RGBA_S3TC_DXT3_Format = 2003;
		var RGBA_S3TC_DXT5_Format = 2004;
		var RGB_PVRTC_4BPPV1_Format = 2100;
		var RGB_PVRTC_2BPPV1_Format = 2101;
		var RGBA_PVRTC_4BPPV1_Format = 2102;
		var RGBA_PVRTC_2BPPV1_Format = 2103;
		var RGB_ETC1_Format = 2151;
		var LoopOnce = 2200;
		var LoopRepeat = 2201;
		var LoopPingPong = 2202;
		var InterpolateDiscrete = 2300;
		var InterpolateLinear = 2301;
		var InterpolateSmooth = 2302;
		var ZeroCurvatureEnding = 2400;
		var ZeroSlopeEnding = 2401;
		var WrapAroundEnding = 2402;
		var TrianglesDrawMode = 0;
		var TriangleStripDrawMode = 1;
		var TriangleFanDrawMode = 2;
		var LinearEncoding = 3000;
		var sRGBEncoding = 3001;
		var GammaEncoding = 3007;
		var RGBEEncoding = 3002;
		var LogLuvEncoding = 3003;
		var RGBM7Encoding = 3004;
		var RGBM16Encoding = 3005;
		var RGBDEncoding = 3006;
		var BasicDepthPacking = 3200;
		var RGBADepthPacking = 3201;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _Math = {

			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,

			generateUUID: function () {

				// http://www.broofa.com/Tools/Math.uuid.htm

				var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
				var uuid = new Array( 36 );
				var rnd = 0, r;

				return function generateUUID() {

					for ( var i = 0; i < 36; i ++ ) {

						if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

							uuid[ i ] = '-';

						} else if ( i === 14 ) {

							uuid[ i ] = '4';

						} else {

							if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
							r = rnd & 0xf;
							rnd = rnd >> 4;
							uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

						}

					}

					return uuid.join( '' );

				};

			}(),

			clamp: function ( value, min, max ) {

				return Math.max( min, Math.min( max, value ) );

			},

			// compute euclidian modulo of m % n
			// https://en.wikipedia.org/wiki/Modulo_operation

			euclideanModulo: function ( n, m ) {

				return ( ( n % m ) + m ) % m;

			},

			// Linear mapping from range <a1, a2> to range <b1, b2>

			mapLinear: function ( x, a1, a2, b1, b2 ) {

				return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

			},

			// https://en.wikipedia.org/wiki/Linear_interpolation

			lerp: function ( x, y, t ) {

				return ( 1 - t ) * x + t * y;

			},

			// http://en.wikipedia.org/wiki/Smoothstep

			smoothstep: function ( x, min, max ) {

				if ( x <= min ) return 0;
				if ( x >= max ) return 1;

				x = ( x - min ) / ( max - min );

				return x * x * ( 3 - 2 * x );

			},

			smootherstep: function ( x, min, max ) {

				if ( x <= min ) return 0;
				if ( x >= max ) return 1;

				x = ( x - min ) / ( max - min );

				return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

			},

			// Random integer from <low, high> interval

			randInt: function ( low, high ) {

				return low + Math.floor( Math.random() * ( high - low + 1 ) );

			},

			// Random float from <low, high> interval

			randFloat: function ( low, high ) {

				return low + Math.random() * ( high - low );

			},

			// Random float from <-range/2, range/2> interval

			randFloatSpread: function ( range ) {

				return range * ( 0.5 - Math.random() );

			},

			degToRad: function ( degrees ) {

				return degrees * _Math.DEG2RAD;

			},

			radToDeg: function ( radians ) {

				return radians * _Math.RAD2DEG;

			},

			isPowerOfTwo: function ( value ) {

				return ( value & ( value - 1 ) ) === 0 && value !== 0;

			},

			nearestPowerOfTwo: function ( value ) {

				return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

			},

			nextPowerOfTwo: function ( value ) {

				value --;
				value |= value >> 1;
				value |= value >> 2;
				value |= value >> 4;
				value |= value >> 8;
				value |= value >> 16;
				value ++;

				return value;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author philogb / http://blog.thejit.org/
		 * @author egraether / http://egraether.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		function Vector2( x, y ) {

			this.x = x || 0;
			this.y = y || 0;

		}

		Vector2.prototype = {

			constructor: Vector2,

			isVector2: true,

			get width() {

				return this.x;

			},

			set width( value ) {

				this.x = value;

			},

			get height() {

				return this.y;

			},

			set height( value ) {

				this.y = value;

			},

			//

			set: function ( x, y ) {

				this.x = x;
				this.y = y;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}

				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;

				return this;

			},

			multiply: function ( v ) {

				this.x *= v.x;
				this.y *= v.y;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				if ( isFinite( scalar ) ) {

					this.x *= scalar;
					this.y *= scalar;

				} else {

					this.x = 0;
					this.y = 0;

				}

				return this;

			},

			divide: function ( v ) {

				this.x /= v.x;
				this.y /= v.y;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );

				return this;

			},

			clamp: function ( min, max ) {

				// This function assumes min < max, if this assumption isn't true it will not operate correctly

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );

				return this;

			},

			clampScalar: function () {

				var min, max;

				return function clampScalar( minVal, maxVal ) {

					if ( min === undefined ) {

						min = new Vector2();
						max = new Vector2();

					}

					min.set( minVal, minVal );
					max.set( maxVal, maxVal );

					return this.clamp( min, max );

				};

			}(),

			clampLength: function ( min, max ) {

				var length = this.length();

				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

			},

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y );

			},

			lengthManhattan: function() {

				return Math.abs( this.x ) + Math.abs( this.y );

			},

			normalize: function () {

				return this.divideScalar( this.length() );

			},

			angle: function () {

				// computes the angle in radians with respect to the positive x-axis

				var angle = Math.atan2( this.y, this.x );

				if ( angle < 0 ) angle += 2 * Math.PI;

				return angle;

			},

			distanceTo: function ( v ) {

				return Math.sqrt( this.distanceToSquared( v ) );

			},

			distanceToSquared: function ( v ) {

				var dx = this.x - v.x, dy = this.y - v.y;
				return dx * dx + dy * dy;

			},

			distanceToManhattan: function ( v ) {

				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

			},

			setLength: function ( length ) {

				return this.multiplyScalar( length / this.length() );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;

				return array;

			},

			fromBufferAttribute: function ( attribute, index, offset ) {

				if ( offset !== undefined ) {

					console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

				}

				this.x = attribute.getX( index );
				this.y = attribute.getY( index );

				return this;

			},

			rotateAround: function ( center, angle ) {

				var c = Math.cos( angle ), s = Math.sin( angle );

				var x = this.x - center.x;
				var y = this.y - center.y;

				this.x = x * c - y * s + center.x;
				this.y = x * s + y * c + center.y;

				return this;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */

		var textureId = 0;

		function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			Object.defineProperty( this, 'id', { value: textureId ++ } );

			this.uuid = _Math.generateUUID();

			this.name = '';

			this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
			this.mipmaps = [];

			this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

			this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
			this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

			this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

			this.format = format !== undefined ? format : RGBAFormat;
			this.type = type !== undefined ? type : UnsignedByteType;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding !== undefined ? encoding : LinearEncoding;

			this.version = 0;
			this.onUpdate = null;

		}

		Texture.DEFAULT_IMAGE = undefined;
		Texture.DEFAULT_MAPPING = UVMapping;

		Texture.prototype = {

			constructor: Texture,

			isTexture: true,

			set needsUpdate( value ) {

				if ( value === true ) this.version ++;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {


				this.name = source.name + " (Copy)";

				this.image = source.image;
				this.mipmaps = source.mipmaps.slice( 0 );

				this.mapping = source.mapping;

				this.wrapS = source.wrapS;
				this.wrapT = source.wrapT;

				this.magFilter = source.magFilter;
				this.minFilter = source.minFilter;

				this.anisotropy = source.anisotropy;

				this.format = source.format;
				this.type = source.type;

				this.offset.copy( source.offset );
				this.repeat.copy( source.repeat );

				this.generateMipmaps = source.generateMipmaps;
				this.premultiplyAlpha = source.premultiplyAlpha;
				this.flipY = source.flipY;
				this.unpackAlignment = source.unpackAlignment;
				this.encoding = source.encoding;

				return this;

			},

			toJSON: function ( meta ) {

				if ( meta.textures[ this.uuid ] !== undefined ) {

					return meta.textures[ this.uuid ];

				}

				function getDataURL( image ) {

					var canvas;

					if ( image.toDataURL !== undefined ) {

						canvas = image;

					} else {

						canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
						canvas.width = image.width;
						canvas.height = image.height;

						canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

					}

					if ( canvas.width > 2048 || canvas.height > 2048 ) {

						return canvas.toDataURL( 'image/jpeg', 0.6 );

					} else {

						return canvas.toDataURL( 'image/png' );

					}

				}

				var output = {
					metadata: {
						version: 4.4,
						type: 'Texture',
						generator: 'Texture.toJSON'
					},

					uuid: this.uuid,
					name: this.name,

					mapping: this.mapping,

					repeat: [ this.repeat.x, this.repeat.y ],
					offset: [ this.offset.x, this.offset.y ],
					wrap: [ this.wrapS, this.wrapT ],

					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,

					flipY: this.flipY
				};

				if ( this.image !== undefined ) {

					// TODO: Move to THREE.Image

					var image = this.image;

					if ( image.uuid === undefined ) {

						image.uuid = _Math.generateUUID(); // UGH

					}

					if ( meta.images[ image.uuid ] === undefined ) {

						meta.images[ image.uuid ] = {
							uuid: image.uuid,
							url: getDataURL( image )
						};

					}

					output.image = image.uuid;

				}

				meta.textures[ this.uuid ] = output;

				return output;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			},

			transformUv: function ( uv ) {

				if ( this.mapping !== UVMapping ) return;

				uv.multiply( this.repeat );
				uv.add( this.offset );

				if ( uv.x < 0 || uv.x > 1 ) {

					switch ( this.wrapS ) {

						case RepeatWrapping:

							uv.x = uv.x - Math.floor( uv.x );
							break;

						case ClampToEdgeWrapping:

							uv.x = uv.x < 0 ? 0 : 1;
							break;

						case MirroredRepeatWrapping:

							if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

								uv.x = Math.ceil( uv.x ) - uv.x;

							} else {

								uv.x = uv.x - Math.floor( uv.x );

							}
							break;

					}

				}

				if ( uv.y < 0 || uv.y > 1 ) {

					switch ( this.wrapT ) {

						case RepeatWrapping:

							uv.y = uv.y - Math.floor( uv.y );
							break;

						case ClampToEdgeWrapping:

							uv.y = uv.y < 0 ? 0 : 1;
							break;

						case MirroredRepeatWrapping:

							if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

								uv.y = Math.ceil( uv.y ) - uv.y;

							} else {

								uv.y = uv.y - Math.floor( uv.y );

							}
							break;

					}

				}

				if ( this.flipY ) {

					uv.y = 1 - uv.y;

				}

			}

		};

		Object.assign( Texture.prototype, EventDispatcher.prototype );

		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Vector4( x, y, z, w ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;

		}

		Vector4.prototype = {

			constructor: Vector4,

			isVector4: true,

			set: function ( x, y, z, w ) {

				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
				this.w = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setZ: function ( z ) {

				this.z = z;

				return this;

			},

			setW: function ( w ) {

				this.w = w;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					case 3: this.w = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}

				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					case 3: return this.w;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y, this.z, this.w );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				this.w = ( v.w !== undefined ) ? v.w : 1;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;
				this.z += s;
				this.w += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
				this.w = a.w + b.w;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;
				this.z -= s;
				this.w -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
				this.w = a.w - b.w;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				if ( isFinite( scalar ) ) {

					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
					this.w *= scalar;

				} else {

					this.x = 0;
					this.y = 0;
					this.z = 0;
					this.w = 0;

				}

				return this;

			},

			applyMatrix4: function ( m ) {

				var x = this.x, y = this.y, z = this.z, w = this.w;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
				this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			setAxisAngleFromQuaternion: function ( q ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

				// q is assumed to be normalized

				this.w = 2 * Math.acos( q.w );

				var s = Math.sqrt( 1 - q.w * q.w );

				if ( s < 0.0001 ) {

					 this.x = 1;
					 this.y = 0;
					 this.z = 0;

				} else {

					 this.x = q.x / s;
					 this.y = q.y / s;
					 this.z = q.z / s;

				}

				return this;

			},

			setAxisAngleFromRotationMatrix: function ( m ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var angle, x, y, z,		// variables for result
					epsilon = 0.01,		// margin to allow for rounding errors
					epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

					te = m.elements,

					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

				if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
				     ( Math.abs( m13 - m31 ) < epsilon ) &&
				     ( Math.abs( m23 - m32 ) < epsilon ) ) {

					// singularity found
					// first check for identity matrix which must have +1 for all terms
					// in leading diagonal and zero in other terms

					if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
					     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
					     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
					     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

						// this singularity is identity matrix so angle = 0

						this.set( 1, 0, 0, 0 );

						return this; // zero angle, arbitrary axis

					}

					// otherwise this singularity is angle = 180

					angle = Math.PI;

					var xx = ( m11 + 1 ) / 2;
					var yy = ( m22 + 1 ) / 2;
					var zz = ( m33 + 1 ) / 2;
					var xy = ( m12 + m21 ) / 4;
					var xz = ( m13 + m31 ) / 4;
					var yz = ( m23 + m32 ) / 4;

					if ( ( xx > yy ) && ( xx > zz ) ) {

						// m11 is the largest diagonal term

						if ( xx < epsilon ) {

							x = 0;
							y = 0.707106781;
							z = 0.707106781;

						} else {

							x = Math.sqrt( xx );
							y = xy / x;
							z = xz / x;

						}

					} else if ( yy > zz ) {

						// m22 is the largest diagonal term

						if ( yy < epsilon ) {

							x = 0.707106781;
							y = 0;
							z = 0.707106781;

						} else {

							y = Math.sqrt( yy );
							x = xy / y;
							z = yz / y;

						}

					} else {

						// m33 is the largest diagonal term so base result on this

						if ( zz < epsilon ) {

							x = 0.707106781;
							y = 0.707106781;
							z = 0;

						} else {

							z = Math.sqrt( zz );
							x = xz / z;
							y = yz / z;

						}

					}

					this.set( x, y, z, angle );

					return this; // return 180 deg rotation

				}

				// as we have reached here there are no singularities so we can handle normally

				var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				                   ( m13 - m31 ) * ( m13 - m31 ) +
				                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

				if ( Math.abs( s ) < 0.001 ) s = 1;

				// prevent divide by zero, should not happen if matrix is orthogonal and should be
				// caught by singularity test above, but I've left it in just in case

				this.x = ( m32 - m23 ) / s;
				this.y = ( m13 - m31 ) / s;
				this.z = ( m21 - m12 ) / s;
				this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

				return this;

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
				this.w = Math.min( this.w, v.w );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
				this.w = Math.max( this.w, v.w );

				return this;

			},

			clamp: function ( min, max ) {

				// This function assumes min < max, if this assumption isn't true it will not operate correctly

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
				this.w = Math.max( min.w, Math.min( max.w, this.w ) );

				return this;

			},

			clampScalar: function () {

				var min, max;

				return function clampScalar( minVal, maxVal ) {

					if ( min === undefined ) {

						min = new Vector4();
						max = new Vector4();

					}

					min.set( minVal, minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal, maxVal );

					return this.clamp( min, max );

				};

			}(),

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
				this.w = Math.floor( this.w );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
				this.w = Math.ceil( this.w );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
				this.w = Math.round( this.w );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
				this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
				this.w = - this.w;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

			},

			lengthManhattan: function () {

				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

			},

			normalize: function () {

				return this.divideScalar( this.length() );

			},

			setLength: function ( length ) {

				return this.multiplyScalar( length / this.length() );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
				this.w += ( v.w - this.w ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
				this.w = array[ offset + 3 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
				array[ offset + 3 ] = this.w;

				return array;

			},

			fromBufferAttribute: function ( attribute, index, offset ) {

				if ( offset !== undefined ) {

					console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

				}

				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );
				this.w = attribute.getW( index );

				return this;

			}

		};

		/**
		 * @author szimek / https://github.com/szimek/
		 * @author alteredq / http://alteredqualia.com/
		 * @author Marius Kintel / https://github.com/kintel
		 */

		/*
		 In options, we can specify:
		 * Texture parameters for an auto-generated target texture
		 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
		*/
		function WebGLRenderTarget( width, height, options ) {

			this.uuid = _Math.generateUUID();

			this.width = width;
			this.height = height;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			options = options || {};

			if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

			this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

			this.texture.name = options.name !== undefined ? options.name : "";

		}

		WebGLRenderTarget.prototype = {

			constructor: WebGLRenderTarget,

			isWebGLRenderTarget: true,

			setSize: function ( width, height ) {

				if ( this.width !== width || this.height !== height ) {

					this.width = width;
					this.height = height;

					this.dispose();

				}

				this.viewport.set( 0, 0, width, height );
				this.scissor.set( 0, 0, width, height );

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.width = source.width;
				this.height = source.height;

				this.viewport.copy( source.viewport );

				this.texture = source.texture.clone();

				this.depthBuffer = source.depthBuffer;
				this.stencilBuffer = source.stencilBuffer;
				this.depthTexture = source.depthTexture;

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		};

		Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype );

		/**
		 * @author alteredq / http://alteredqualia.com
		 */

		function WebGLRenderTargetCube( width, height, options ) {

			WebGLRenderTarget.call( this, width, height, options );

			this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
			this.activeMipMapLevel = 0;

		}

		WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
		WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

		WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */

		function Quaternion( x, y, z, w ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;

		}

		Quaternion.prototype = {

			constructor: Quaternion,

			get x () {

				return this._x;

			},

			set x ( value ) {

				this._x = value;
				this.onChangeCallback();

			},

			get y () {

				return this._y;

			},

			set y ( value ) {

				this._y = value;
				this.onChangeCallback();

			},

			get z () {

				return this._z;

			},

			set z ( value ) {

				this._z = value;
				this.onChangeCallback();

			},

			get w () {

				return this._w;

			},

			set w ( value ) {

				this._w = value;
				this.onChangeCallback();

			},

			set: function ( x, y, z, w ) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._w = w;

				this.onChangeCallback();

				return this;

			},

			clone: function () {

				return new this.constructor( this._x, this._y, this._z, this._w );

			},

			copy: function ( quaternion ) {

				this._x = quaternion.x;
				this._y = quaternion.y;
				this._z = quaternion.z;
				this._w = quaternion.w;

				this.onChangeCallback();

				return this;

			},

			setFromEuler: function ( euler, update ) {

				if ( (euler && euler.isEuler) === false ) {

					throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				// http://www.mathworks.com/matlabcentral/fileexchange/
				// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
				//	content/SpinCalc.m

				var c1 = Math.cos( euler._x / 2 );
				var c2 = Math.cos( euler._y / 2 );
				var c3 = Math.cos( euler._z / 2 );
				var s1 = Math.sin( euler._x / 2 );
				var s2 = Math.sin( euler._y / 2 );
				var s3 = Math.sin( euler._z / 2 );

				var order = euler.order;

				if ( order === 'XYZ' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'YXZ' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				} else if ( order === 'ZXY' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'ZYX' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				} else if ( order === 'YZX' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'XZY' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				}

				if ( update !== false ) this.onChangeCallback();

				return this;

			},

			setFromAxisAngle: function ( axis, angle ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

				// assumes axis is normalized

				var halfAngle = angle / 2, s = Math.sin( halfAngle );

				this._x = axis.x * s;
				this._y = axis.y * s;
				this._z = axis.z * s;
				this._w = Math.cos( halfAngle );

				this.onChangeCallback();

				return this;

			},

			setFromRotationMatrix: function ( m ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var te = m.elements,

					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

					trace = m11 + m22 + m33,
					s;

				if ( trace > 0 ) {

					s = 0.5 / Math.sqrt( trace + 1.0 );

					this._w = 0.25 / s;
					this._x = ( m32 - m23 ) * s;
					this._y = ( m13 - m31 ) * s;
					this._z = ( m21 - m12 ) * s;

				} else if ( m11 > m22 && m11 > m33 ) {

					s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

					this._w = ( m32 - m23 ) / s;
					this._x = 0.25 * s;
					this._y = ( m12 + m21 ) / s;
					this._z = ( m13 + m31 ) / s;

				} else if ( m22 > m33 ) {

					s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

					this._w = ( m13 - m31 ) / s;
					this._x = ( m12 + m21 ) / s;
					this._y = 0.25 * s;
					this._z = ( m23 + m32 ) / s;

				} else {

					s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

					this._w = ( m21 - m12 ) / s;
					this._x = ( m13 + m31 ) / s;
					this._y = ( m23 + m32 ) / s;
					this._z = 0.25 * s;

				}

				this.onChangeCallback();

				return this;

			},

			setFromUnitVectors: function () {

				// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

				// assumes direction vectors vFrom and vTo are normalized

				var v1, r;

				var EPS = 0.000001;

				return function setFromUnitVectors( vFrom, vTo ) {

					if ( v1 === undefined ) v1 = new Vector3();

					r = vFrom.dot( vTo ) + 1;

					if ( r < EPS ) {

						r = 0;

						if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

							v1.set( - vFrom.y, vFrom.x, 0 );

						} else {

							v1.set( 0, - vFrom.z, vFrom.y );

						}

					} else {

						v1.crossVectors( vFrom, vTo );

					}

					this._x = v1.x;
					this._y = v1.y;
					this._z = v1.z;
					this._w = r;

					return this.normalize();

				};

			}(),

			inverse: function () {

				return this.conjugate().normalize();

			},

			conjugate: function () {

				this._x *= - 1;
				this._y *= - 1;
				this._z *= - 1;

				this.onChangeCallback();

				return this;

			},

			dot: function ( v ) {

				return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

			},

			lengthSq: function () {

				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

			},

			length: function () {

				return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

			},

			normalize: function () {

				var l = this.length();

				if ( l === 0 ) {

					this._x = 0;
					this._y = 0;
					this._z = 0;
					this._w = 1;

				} else {

					l = 1 / l;

					this._x = this._x * l;
					this._y = this._y * l;
					this._z = this._z * l;
					this._w = this._w * l;

				}

				this.onChangeCallback();

				return this;

			},

			multiply: function ( q, p ) {

				if ( p !== undefined ) {

					console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
					return this.multiplyQuaternions( q, p );

				}

				return this.multiplyQuaternions( this, q );

			},

			premultiply: function ( q ) {

				return this.multiplyQuaternions( q, this );

			},

			multiplyQuaternions: function ( a, b ) {

				// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

				var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
				var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

				this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
				this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
				this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
				this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

				this.onChangeCallback();

				return this;

			},

			slerp: function ( qb, t ) {

				if ( t === 0 ) return this;
				if ( t === 1 ) return this.copy( qb );

				var x = this._x, y = this._y, z = this._z, w = this._w;

				// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

				var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

				if ( cosHalfTheta < 0 ) {

					this._w = - qb._w;
					this._x = - qb._x;
					this._y = - qb._y;
					this._z = - qb._z;

					cosHalfTheta = - cosHalfTheta;

				} else {

					this.copy( qb );

				}

				if ( cosHalfTheta >= 1.0 ) {

					this._w = w;
					this._x = x;
					this._y = y;
					this._z = z;

					return this;

				}

				var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

				if ( Math.abs( sinHalfTheta ) < 0.001 ) {

					this._w = 0.5 * ( w + this._w );
					this._x = 0.5 * ( x + this._x );
					this._y = 0.5 * ( y + this._y );
					this._z = 0.5 * ( z + this._z );

					return this;

				}

				var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
				var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

				this._w = ( w * ratioA + this._w * ratioB );
				this._x = ( x * ratioA + this._x * ratioB );
				this._y = ( y * ratioA + this._y * ratioB );
				this._z = ( z * ratioA + this._z * ratioB );

				this.onChangeCallback();

				return this;

			},

			equals: function ( quaternion ) {

				return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this._x = array[ offset ];
				this._y = array[ offset + 1 ];
				this._z = array[ offset + 2 ];
				this._w = array[ offset + 3 ];

				this.onChangeCallback();

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._w;

				return array;

			},

			onChange: function ( callback ) {

				this.onChangeCallback = callback;

				return this;

			},

			onChangeCallback: function () {}

		};

		Object.assign( Quaternion, {

			slerp: function( qa, qb, qm, t ) {

				return qm.copy( qa ).slerp( qb, t );

			},

			slerpFlat: function(
					dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

				// fuzz-free, array-based Quaternion SLERP operation

				var x0 = src0[ srcOffset0 + 0 ],
					y0 = src0[ srcOffset0 + 1 ],
					z0 = src0[ srcOffset0 + 2 ],
					w0 = src0[ srcOffset0 + 3 ],

					x1 = src1[ srcOffset1 + 0 ],
					y1 = src1[ srcOffset1 + 1 ],
					z1 = src1[ srcOffset1 + 2 ],
					w1 = src1[ srcOffset1 + 3 ];

				if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

					var s = 1 - t,

						cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

						dir = ( cos >= 0 ? 1 : - 1 ),
						sqrSin = 1 - cos * cos;

					// Skip the Slerp for tiny steps to avoid numeric problems:
					if ( sqrSin > Number.EPSILON ) {

						var sin = Math.sqrt( sqrSin ),
							len = Math.atan2( sin, cos * dir );

						s = Math.sin( s * len ) / sin;
						t = Math.sin( t * len ) / sin;

					}

					var tDir = t * dir;

					x0 = x0 * s + x1 * tDir;
					y0 = y0 * s + y1 * tDir;
					z0 = z0 * s + z1 * tDir;
					w0 = w0 * s + w1 * tDir;

					// Normalize in case we just did a lerp:
					if ( s === 1 - t ) {

						var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

						x0 *= f;
						y0 *= f;
						z0 *= f;
						w0 *= f;

					}

				}

				dst[ dstOffset ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author *kile / http://kile.stravaganza.org/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Vector3( x, y, z ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;

		}

		Vector3.prototype = {

			constructor: Vector3,

			isVector3: true,

			set: function ( x, y, z ) {

				this.x = x;
				this.y = y;
				this.z = z;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setZ: function ( z ) {

				this.z = z;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}

				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y, this.z );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;
				this.z += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;
				this.z -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;

				return this;

			},

			multiply: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
					return this.multiplyVectors( v, w );

				}

				this.x *= v.x;
				this.y *= v.y;
				this.z *= v.z;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				if ( isFinite( scalar ) ) {

					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;

				} else {

					this.x = 0;
					this.y = 0;
					this.z = 0;

				}

				return this;

			},

			multiplyVectors: function ( a, b ) {

				this.x = a.x * b.x;
				this.y = a.y * b.y;
				this.z = a.z * b.z;

				return this;

			},

			applyEuler: function () {

				var quaternion;

				return function applyEuler( euler ) {

					if ( (euler && euler.isEuler) === false ) {

						console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

					}

					if ( quaternion === undefined ) quaternion = new Quaternion();

					return this.applyQuaternion( quaternion.setFromEuler( euler ) );

				};

			}(),

			applyAxisAngle: function () {

				var quaternion;

				return function applyAxisAngle( axis, angle ) {

					if ( quaternion === undefined ) quaternion = new Quaternion();

					return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

				};

			}(),

			applyMatrix3: function ( m ) {

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
				this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
				this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

				return this;

			},

			applyMatrix4: function ( m ) {

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
				var w =  e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ];

				return this.divideScalar( w );

			},

			applyQuaternion: function ( q ) {

				var x = this.x, y = this.y, z = this.z;
				var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

				// calculate quat * vector

				var ix =  qw * x + qy * z - qz * y;
				var iy =  qw * y + qz * x - qx * z;
				var iz =  qw * z + qx * y - qy * x;
				var iw = - qx * x - qy * y - qz * z;

				// calculate result * inverse quat

				this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
				this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
				this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

				return this;

			},

			project: function () {

				var matrix;

				return function project( camera ) {

					if ( matrix === undefined ) matrix = new Matrix4();

					matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
					return this.applyMatrix4( matrix );

				};

			}(),

			unproject: function () {

				var matrix;

				return function unproject( camera ) {

					if ( matrix === undefined ) matrix = new Matrix4();

					matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
					return this.applyMatrix4( matrix );

				};

			}(),

			transformDirection: function ( m ) {

				// input: THREE.Matrix4 affine matrix
				// vector interpreted as a direction

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

				return this.normalize();

			},

			divide: function ( v ) {

				this.x /= v.x;
				this.y /= v.y;
				this.z /= v.z;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );

				return this;

			},

			clamp: function ( min, max ) {

				// This function assumes min < max, if this assumption isn't true it will not operate correctly

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );

				return this;

			},

			clampScalar: function () {

				var min, max;

				return function clampScalar( minVal, maxVal ) {

					if ( min === undefined ) {

						min = new Vector3();
						max = new Vector3();

					}

					min.set( minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal );

					return this.clamp( min, max );

				};

			}(),

			clampLength: function ( min, max ) {

				var length = this.length();

				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

			},

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y + this.z * v.z;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y + this.z * this.z;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

			},

			lengthManhattan: function () {

				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

			},

			normalize: function () {

				return this.divideScalar( this.length() );

			},

			setLength: function ( length ) {

				return this.multiplyScalar( length / this.length() );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			cross: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
					return this.crossVectors( v, w );

				}

				var x = this.x, y = this.y, z = this.z;

				this.x = y * v.z - z * v.y;
				this.y = z * v.x - x * v.z;
				this.z = x * v.y - y * v.x;

				return this;

			},

			crossVectors: function ( a, b ) {

				var ax = a.x, ay = a.y, az = a.z;
				var bx = b.x, by = b.y, bz = b.z;

				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;

				return this;

			},

			projectOnVector: function ( vector ) {

				var scalar = vector.dot( this ) / vector.lengthSq();

				return this.copy( vector ).multiplyScalar( scalar );

			},

			projectOnPlane: function () {

				var v1;

				return function projectOnPlane( planeNormal ) {

					if ( v1 === undefined ) v1 = new Vector3();

					v1.copy( this ).projectOnVector( planeNormal );

					return this.sub( v1 );

				};

			}(),

			reflect: function () {

				// reflect incident vector off plane orthogonal to normal
				// normal is assumed to have unit length

				var v1;

				return function reflect( normal ) {

					if ( v1 === undefined ) v1 = new Vector3();

					return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

				};

			}(),

			angleTo: function ( v ) {

				var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

				// clamp, to handle numerical problems

				return Math.acos( _Math.clamp( theta, - 1, 1 ) );

			},

			distanceTo: function ( v ) {

				return Math.sqrt( this.distanceToSquared( v ) );

			},

			distanceToSquared: function ( v ) {

				var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

				return dx * dx + dy * dy + dz * dz;

			},

			distanceToManhattan: function ( v ) {

				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

			},

			setFromSpherical: function( s ) {

				var sinPhiRadius = Math.sin( s.phi ) * s.radius;

				this.x = sinPhiRadius * Math.sin( s.theta );
				this.y = Math.cos( s.phi ) * s.radius;
				this.z = sinPhiRadius * Math.cos( s.theta );

				return this;

			},

			setFromCylindrical: function( c ) {

				this.x = c.radius * Math.sin( c.theta );
				this.y = c.y;
				this.z = c.radius * Math.cos( c.theta );

				return this;

			},

			setFromMatrixPosition: function ( m ) {

				return this.setFromMatrixColumn( m, 3 );

			},

			setFromMatrixScale: function ( m ) {

				var sx = this.setFromMatrixColumn( m, 0 ).length();
				var sy = this.setFromMatrixColumn( m, 1 ).length();
				var sz = this.setFromMatrixColumn( m, 2 ).length();

				this.x = sx;
				this.y = sy;
				this.z = sz;

				return this;

			},

			setFromMatrixColumn: function ( m, index ) {

				if ( typeof m === 'number' ) {

					console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
					var temp = m;
					m = index;
					index = temp;

				}

				return this.fromArray( m.elements, index * 4 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;

				return array;

			},

			fromBufferAttribute: function ( attribute, index, offset ) {

				if ( offset !== undefined ) {

					console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

				}

				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );

				return this;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author jordi_ros / http://plattsoft.com
		 * @author D1plo1d / http://github.com/D1plo1d
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author timknip / http://www.floorplanner.com/
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Matrix4() {

			this.elements = new Float32Array( [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			] );

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		Matrix4.prototype = {

			constructor: Matrix4,

			isMatrix4: true,

			set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

				var te = this.elements;

				te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
				te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
				te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
				te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

				return this;

			},

			identity: function () {

				this.set(

					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1

				);

				return this;

			},

			clone: function () {

				return new Matrix4().fromArray( this.elements );

			},

			copy: function ( m ) {

				this.elements.set( m.elements );

				return this;

			},

			copyPosition: function ( m ) {

				var te = this.elements;
				var me = m.elements;

				te[ 12 ] = me[ 12 ];
				te[ 13 ] = me[ 13 ];
				te[ 14 ] = me[ 14 ];

				return this;

			},

			extractBasis: function ( xAxis, yAxis, zAxis ) {

				xAxis.setFromMatrixColumn( this, 0 );
				yAxis.setFromMatrixColumn( this, 1 );
				zAxis.setFromMatrixColumn( this, 2 );

				return this;

			},

			makeBasis: function ( xAxis, yAxis, zAxis ) {

				this.set(
					xAxis.x, yAxis.x, zAxis.x, 0,
					xAxis.y, yAxis.y, zAxis.y, 0,
					xAxis.z, yAxis.z, zAxis.z, 0,
					0,       0,       0,       1
				);

				return this;

			},

			extractRotation: function () {

				var v1;

				return function extractRotation( m ) {

					if ( v1 === undefined ) v1 = new Vector3();

					var te = this.elements;
					var me = m.elements;

					var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
					var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
					var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

					te[ 0 ] = me[ 0 ] * scaleX;
					te[ 1 ] = me[ 1 ] * scaleX;
					te[ 2 ] = me[ 2 ] * scaleX;

					te[ 4 ] = me[ 4 ] * scaleY;
					te[ 5 ] = me[ 5 ] * scaleY;
					te[ 6 ] = me[ 6 ] * scaleY;

					te[ 8 ] = me[ 8 ] * scaleZ;
					te[ 9 ] = me[ 9 ] * scaleZ;
					te[ 10 ] = me[ 10 ] * scaleZ;

					return this;

				};

			}(),

			makeRotationFromEuler: function ( euler ) {

				if ( (euler && euler.isEuler) === false ) {

					console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				var te = this.elements;

				var x = euler.x, y = euler.y, z = euler.z;
				var a = Math.cos( x ), b = Math.sin( x );
				var c = Math.cos( y ), d = Math.sin( y );
				var e = Math.cos( z ), f = Math.sin( z );

				if ( euler.order === 'XYZ' ) {

					var ae = a * e, af = a * f, be = b * e, bf = b * f;

					te[ 0 ] = c * e;
					te[ 4 ] = - c * f;
					te[ 8 ] = d;

					te[ 1 ] = af + be * d;
					te[ 5 ] = ae - bf * d;
					te[ 9 ] = - b * c;

					te[ 2 ] = bf - ae * d;
					te[ 6 ] = be + af * d;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'YXZ' ) {

					var ce = c * e, cf = c * f, de = d * e, df = d * f;

					te[ 0 ] = ce + df * b;
					te[ 4 ] = de * b - cf;
					te[ 8 ] = a * d;

					te[ 1 ] = a * f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b;

					te[ 2 ] = cf * b - de;
					te[ 6 ] = df + ce * b;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'ZXY' ) {

					var ce = c * e, cf = c * f, de = d * e, df = d * f;

					te[ 0 ] = ce - df * b;
					te[ 4 ] = - a * f;
					te[ 8 ] = de + cf * b;

					te[ 1 ] = cf + de * b;
					te[ 5 ] = a * e;
					te[ 9 ] = df - ce * b;

					te[ 2 ] = - a * d;
					te[ 6 ] = b;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'ZYX' ) {

					var ae = a * e, af = a * f, be = b * e, bf = b * f;

					te[ 0 ] = c * e;
					te[ 4 ] = be * d - af;
					te[ 8 ] = ae * d + bf;

					te[ 1 ] = c * f;
					te[ 5 ] = bf * d + ae;
					te[ 9 ] = af * d - be;

					te[ 2 ] = - d;
					te[ 6 ] = b * c;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'YZX' ) {

					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

					te[ 0 ] = c * e;
					te[ 4 ] = bd - ac * f;
					te[ 8 ] = bc * f + ad;

					te[ 1 ] = f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b * e;

					te[ 2 ] = - d * e;
					te[ 6 ] = ad * f + bc;
					te[ 10 ] = ac - bd * f;

				} else if ( euler.order === 'XZY' ) {

					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

					te[ 0 ] = c * e;
					te[ 4 ] = - f;
					te[ 8 ] = d * e;

					te[ 1 ] = ac * f + bd;
					te[ 5 ] = a * e;
					te[ 9 ] = ad * f - bc;

					te[ 2 ] = bc * f - ad;
					te[ 6 ] = b * e;
					te[ 10 ] = bd * f + ac;

				}

				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;

				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			},

			makeRotationFromQuaternion: function ( q ) {

				var te = this.elements;

				var x = q.x, y = q.y, z = q.z, w = q.w;
				var x2 = x + x, y2 = y + y, z2 = z + z;
				var xx = x * x2, xy = x * y2, xz = x * z2;
				var yy = y * y2, yz = y * z2, zz = z * z2;
				var wx = w * x2, wy = w * y2, wz = w * z2;

				te[ 0 ] = 1 - ( yy + zz );
				te[ 4 ] = xy - wz;
				te[ 8 ] = xz + wy;

				te[ 1 ] = xy + wz;
				te[ 5 ] = 1 - ( xx + zz );
				te[ 9 ] = yz - wx;

				te[ 2 ] = xz - wy;
				te[ 6 ] = yz + wx;
				te[ 10 ] = 1 - ( xx + yy );

				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;

				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			},

			lookAt: function () {

				var x, y, z;

				return function lookAt( eye, target, up ) {

					if ( x === undefined ) {

						x = new Vector3();
						y = new Vector3();
						z = new Vector3();

					}

					var te = this.elements;

					z.subVectors( eye, target ).normalize();

					if ( z.lengthSq() === 0 ) {

						z.z = 1;

					}

					x.crossVectors( up, z ).normalize();

					if ( x.lengthSq() === 0 ) {

						z.z += 0.0001;
						x.crossVectors( up, z ).normalize();

					}

					y.crossVectors( z, x );


					te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
					te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
					te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

					return this;

				};

			}(),

			multiply: function ( m, n ) {

				if ( n !== undefined ) {

					console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
					return this.multiplyMatrices( m, n );

				}

				return this.multiplyMatrices( this, m );

			},

			premultiply: function ( m ) {

				return this.multiplyMatrices( m, this );

			},

			multiplyMatrices: function ( a, b ) {

				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;

				var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
				var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
				var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
				var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

				var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
				var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
				var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
				var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
				te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
				te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
				te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
				te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
				te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
				te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
				te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
				te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
				te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

				te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
				te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
				te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
				te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

				return this;

			},

			multiplyToArray: function ( a, b, r ) {

				var te = this.elements;

				this.multiplyMatrices( a, b );

				r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
				r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
				r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
				r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

				return this;

			},

			multiplyScalar: function ( s ) {

				var te = this.elements;

				te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
				te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
				te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
				te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

				return this;

			},

			applyToBufferAttribute: function () {

				var v1;

				return function applyToBufferAttribute( attribute ) {

					if ( v1 === undefined ) v1 = new Vector3();

					for ( var i = 0, l = attribute.count; i < l; i ++ ) {

						v1.x = attribute.getX( i );
						v1.y = attribute.getY( i );
						v1.z = attribute.getZ( i );

						v1.applyMatrix4( this );

						attribute.setXYZ( i, v1.x, v1.y, v1.z );

					}

					return attribute;

				};

			}(),

			determinant: function () {

				var te = this.elements;

				var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
				var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
				var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
				var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

				//TODO: make this more efficient
				//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

				return (
					n41 * (
						+ n14 * n23 * n32
						 - n13 * n24 * n32
						 - n14 * n22 * n33
						 + n12 * n24 * n33
						 + n13 * n22 * n34
						 - n12 * n23 * n34
					) +
					n42 * (
						+ n11 * n23 * n34
						 - n11 * n24 * n33
						 + n14 * n21 * n33
						 - n13 * n21 * n34
						 + n13 * n24 * n31
						 - n14 * n23 * n31
					) +
					n43 * (
						+ n11 * n24 * n32
						 - n11 * n22 * n34
						 - n14 * n21 * n32
						 + n12 * n21 * n34
						 + n14 * n22 * n31
						 - n12 * n24 * n31
					) +
					n44 * (
						- n13 * n22 * n31
						 - n11 * n23 * n32
						 + n11 * n22 * n33
						 + n13 * n21 * n32
						 - n12 * n21 * n33
						 + n12 * n23 * n31
					)

				);

			},

			transpose: function () {

				var te = this.elements;
				var tmp;

				tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
				tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
				tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

				tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
				tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
				tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

				return this;

			},

			setPosition: function ( v ) {

				var te = this.elements;

				te[ 12 ] = v.x;
				te[ 13 ] = v.y;
				te[ 14 ] = v.z;

				return this;

			},

			getInverse: function ( m, throwOnDegenerate ) {

				// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
				var te = this.elements,
					me = m.elements,

					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
					n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
					n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
					n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

				var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

				if ( det === 0 ) {

					var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

					if ( throwOnDegenerate === true ) {

						throw new Error( msg );

					} else {

						console.warn( msg );

					}

					return this.identity();

				}

				var detInv = 1 / det;

				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
				te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
				te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

				te[ 4 ] = t12 * detInv;
				te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
				te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
				te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

				te[ 8 ] = t13 * detInv;
				te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
				te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
				te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

				te[ 12 ] = t14 * detInv;
				te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
				te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
				te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

				return this;

			},

			scale: function ( v ) {

				var te = this.elements;
				var x = v.x, y = v.y, z = v.z;

				te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
				te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
				te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
				te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

				return this;

			},

			getMaxScaleOnAxis: function () {

				var te = this.elements;

				var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
				var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
				var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

				return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

			},

			makeTranslation: function ( x, y, z ) {

				this.set(

					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1

				);

				return this;

			},

			makeRotationX: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					1, 0,  0, 0,
					0, c, - s, 0,
					0, s,  c, 0,
					0, 0,  0, 1

				);

				return this;

			},

			makeRotationY: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					 c, 0, s, 0,
					 0, 1, 0, 0,
					- s, 0, c, 0,
					 0, 0, 0, 1

				);

				return this;

			},

			makeRotationZ: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					c, - s, 0, 0,
					s,  c, 0, 0,
					0,  0, 1, 0,
					0,  0, 0, 1

				);

				return this;

			},

			makeRotationAxis: function ( axis, angle ) {

				// Based on http://www.gamedev.net/reference/articles/article1199.asp

				var c = Math.cos( angle );
				var s = Math.sin( angle );
				var t = 1 - c;
				var x = axis.x, y = axis.y, z = axis.z;
				var tx = t * x, ty = t * y;

				this.set(

					tx * x + c, tx * y - s * z, tx * z + s * y, 0,
					tx * y + s * z, ty * y + c, ty * z - s * x, 0,
					tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
					0, 0, 0, 1

				);

				 return this;

			},

			makeScale: function ( x, y, z ) {

				this.set(

					x, 0, 0, 0,
					0, y, 0, 0,
					0, 0, z, 0,
					0, 0, 0, 1

				);

				return this;

			},

			makeShear: function ( x, y, z ) {

				this.set(

					1, y, z, 0,
					x, 1, z, 0,
					x, y, 1, 0,
					0, 0, 0, 1

				);

				return this;

			},

			compose: function ( position, quaternion, scale ) {

				this.makeRotationFromQuaternion( quaternion );
				this.scale( scale );
				this.setPosition( position );

				return this;

			},

			decompose: function () {

				var vector, matrix;

				return function decompose( position, quaternion, scale ) {

					if ( vector === undefined ) {

						vector = new Vector3();
						matrix = new Matrix4();

					}

					var te = this.elements;

					var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
					var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
					var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

					// if determine is negative, we need to invert one scale
					var det = this.determinant();
					if ( det < 0 ) {

						sx = - sx;

					}

					position.x = te[ 12 ];
					position.y = te[ 13 ];
					position.z = te[ 14 ];

					// scale the rotation part

					matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

					var invSX = 1 / sx;
					var invSY = 1 / sy;
					var invSZ = 1 / sz;

					matrix.elements[ 0 ] *= invSX;
					matrix.elements[ 1 ] *= invSX;
					matrix.elements[ 2 ] *= invSX;

					matrix.elements[ 4 ] *= invSY;
					matrix.elements[ 5 ] *= invSY;
					matrix.elements[ 6 ] *= invSY;

					matrix.elements[ 8 ] *= invSZ;
					matrix.elements[ 9 ] *= invSZ;
					matrix.elements[ 10 ] *= invSZ;

					quaternion.setFromRotationMatrix( matrix );

					scale.x = sx;
					scale.y = sy;
					scale.z = sz;

					return this;

				};

			}(),

			makePerspective: function ( left, right, top, bottom, near, far ) {

				if ( far === undefined ) {

					console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

				}

				var te = this.elements;
				var x = 2 * near / ( right - left );
				var y = 2 * near / ( top - bottom );

				var a = ( right + left ) / ( right - left );
				var b = ( top + bottom ) / ( top - bottom );
				var c = - ( far + near ) / ( far - near );
				var d = - 2 * far * near / ( far - near );

				te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
				te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

				return this;

			},

			makeOrthographic: function ( left, right, top, bottom, near, far ) {

				var te = this.elements;
				var w = 1.0 / ( right - left );
				var h = 1.0 / ( top - bottom );
				var p = 1.0 / ( far - near );

				var x = ( right + left ) * w;
				var y = ( top + bottom ) * h;
				var z = ( far + near ) * p;

				te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
				te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

				return this;

			},

			equals: function ( matrix ) {

				var te = this.elements;
				var me = matrix.elements;

				for ( var i = 0; i < 16; i ++ ) {

					if ( te[ i ] !== me[ i ] ) return false;

				}

				return true;

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				for( var i = 0; i < 16; i ++ ) {

					this.elements[ i ] = array[ i + offset ];

				}

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				var te = this.elements;

				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
				array[ offset + 3 ] = te[ 3 ];

				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];

				array[ offset + 8 ]  = te[ 8 ];
				array[ offset + 9 ]  = te[ 9 ];
				array[ offset + 10 ] = te[ 10 ];
				array[ offset + 11 ] = te[ 11 ];

				array[ offset + 12 ] = te[ 12 ];
				array[ offset + 13 ] = te[ 13 ];
				array[ offset + 14 ] = te[ 14 ];
				array[ offset + 15 ] = te[ 15 ];

				return array;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

			Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.flipY = false;

		}

		CubeTexture.prototype = Object.create( Texture.prototype );
		CubeTexture.prototype.constructor = CubeTexture;

		CubeTexture.prototype.isCubeTexture = true;

		Object.defineProperty( CubeTexture.prototype, 'images', {

			get: function () {

				return this.image;

			},

			set: function ( value ) {

				this.image = value;

			}

		} );

		/**
		 * @author tschw
		 *
		 * Uniforms of a program.
		 * Those form a tree structure with a special top-level container for the root,
		 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
		 *
		 *
		 * Properties of inner nodes including the top-level container:
		 *
		 * .seq - array of nested uniforms
		 * .map - nested uniforms by name
		 *
		 *
		 * Methods of all nodes except the top-level container:
		 *
		 * .setValue( gl, value, [renderer] )
		 *
		 * 		uploads a uniform value(s)
		 *  	the 'renderer' parameter is needed for sampler uniforms
		 *
		 *
		 * Static methods of the top-level container (renderer factorizations):
		 *
		 * .upload( gl, seq, values, renderer )
		 *
		 * 		sets uniforms in 'seq' to 'values[id].value'
		 *
		 * .seqWithValue( seq, values ) : filteredSeq
		 *
		 * 		filters 'seq' entries with corresponding entry in values
		 *
		 *
		 * Methods of the top-level container (renderer factorizations):
		 *
		 * .setValue( gl, name, value )
		 *
		 * 		sets uniform with  name 'name' to 'value'
		 *
		 * .set( gl, obj, prop )
		 *
		 * 		sets uniform from object and property with same name than uniform
		 *
		 * .setOptional( gl, obj, prop )
		 *
		 * 		like .set for an optional property of the object
		 *
		 */

		var emptyTexture = new Texture();
		var emptyCubeTexture = new CubeTexture();

		// --- Base for inner nodes (including the root) ---

		function UniformContainer() {

			this.seq = [];
			this.map = {};

		}

		// --- Utilities ---

		// Array Caches (provide typed arrays for temporary by size)

		var arrayCacheF32 = [];
		var arrayCacheI32 = [];

		// Flattening for arrays of vectors and matrices

		function flatten( array, nBlocks, blockSize ) {

			var firstElem = array[ 0 ];

			if ( firstElem <= 0 || firstElem > 0 ) return array;
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983

			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];

			if ( r === undefined ) {

				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;

			}

			if ( nBlocks !== 0 ) {

				firstElem.toArray( r, 0 );

				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

					offset += blockSize;
					array[ i ].toArray( r, offset );

				}

			}

			return r;

		}

		// Texture unit allocation

		function allocTexUnits( renderer, n ) {

			var r = arrayCacheI32[ n ];

			if ( r === undefined ) {

				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;

			}

			for ( var i = 0; i !== n; ++ i )
				r[ i ] = renderer.allocTextureUnit();

			return r;

		}

		// --- Setters ---

		// Note: Defining these methods externally, because they come in a bunch
		// and this way their names minify.

		// Single scalar

		function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
		function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

		// Single float vector (from flat array or THREE.VectorN)

		function setValue2fv( gl, v ) {

			if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
			else gl.uniform2f( this.addr, v.x, v.y );

		}

		function setValue3fv( gl, v ) {

			if ( v.x !== undefined )
				gl.uniform3f( this.addr, v.x, v.y, v.z );
			else if ( v.r !== undefined )
				gl.uniform3f( this.addr, v.r, v.g, v.b );
			else
				gl.uniform3fv( this.addr, v );

		}

		function setValue4fv( gl, v ) {

			if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
			else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

		}

		// Single matrix (from flat array or MatrixN)

		function setValue2fm( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, v.elements || v );

		}

		function setValue3fm( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, v.elements || v );

		}

		function setValue4fm( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, v.elements || v );

		}

		// Single texture (2D / Cube)

		function setValueT1( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTexture2D( v || emptyTexture, unit );

		}

		function setValueT6( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTextureCube( v || emptyCubeTexture, unit );

		}

		// Integer / Boolean vectors or arrays thereof (always flat arrays)

		function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
		function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
		function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

		// Helper to pick the right setter for the singular case

		function getSingularSetter( type ) {

			switch ( type ) {

				case 0x1406: return setValue1f; // FLOAT
				case 0x8b50: return setValue2fv; // _VEC2
				case 0x8b51: return setValue3fv; // _VEC3
				case 0x8b52: return setValue4fv; // _VEC4

				case 0x8b5a: return setValue2fm; // _MAT2
				case 0x8b5b: return setValue3fm; // _MAT3
				case 0x8b5c: return setValue4fm; // _MAT4

				case 0x8b5e: return setValueT1; // SAMPLER_2D
				case 0x8b60: return setValueT6; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		}

		// Array of scalars

		function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
		function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

		// Array of vectors (flat or from THREE classes)

		function setValueV2a( gl, v ) {

			gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

		}

		function setValueV3a( gl, v ) {

			gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

		}

		function setValueV4a( gl, v ) {

			gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

		}

		// Array of matrices (flat or from THREE clases)

		function setValueM2a( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

		}

		function setValueM3a( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

		}

		function setValueM4a( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

		}

		// Array of textures (2D / Cube)

		function setValueT1a( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

			}

		}

		function setValueT6a( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

			}

		}

		// Helper to pick the right setter for a pure (bottom-level) array

		function getPureArraySetter( type ) {

			switch ( type ) {

				case 0x1406: return setValue1fv; // FLOAT
				case 0x8b50: return setValueV2a; // _VEC2
				case 0x8b51: return setValueV3a; // _VEC3
				case 0x8b52: return setValueV4a; // _VEC4

				case 0x8b5a: return setValueM2a; // _MAT2
				case 0x8b5b: return setValueM3a; // _MAT3
				case 0x8b5c: return setValueM4a; // _MAT4

				case 0x8b5e: return setValueT1a; // SAMPLER_2D
				case 0x8b60: return setValueT6a; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		}

		// --- Uniform Classes ---

		function SingleUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

		function PureArrayUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

		function StructuredUniform( id ) {

			this.id = id;

			UniformContainer.call( this ); // mix-in

		}

		StructuredUniform.prototype.setValue = function( gl, value ) {

			// Note: Don't need an extra 'renderer' parameter, since samplers
			// are not allowed in structured uniforms.

			var seq = this.seq;

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ];
				u.setValue( gl, value[ u.id ] );

			}

		};

		// --- Top-level ---

		// Parser - builds up the property tree from the path strings

		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.

		function addUniform( container, uniformObject ) {

			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;

		}

		function parseUniform( activeInfo, addr, container ) {

			var path = activeInfo.name,
				pathLength = path.length;

			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;

			for (; ;) {

				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,

					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];

				if ( idIsIndex ) id = id | 0; // convert to integer

				if ( subscript === undefined ||
						subscript === '[' && matchEnd + 2 === pathLength ) {
					// bare name or "pure" bottom-level array "[0]" suffix

					addUniform( container, subscript === undefined ?
							new SingleUniform( id, activeInfo, addr ) :
							new PureArrayUniform( id, activeInfo, addr ) );

					break;

				} else {
					// step into inner node / create it in case it doesn't exist

					var map = container.map,
						next = map[ id ];

					if ( next === undefined ) {

						next = new StructuredUniform( id );
						addUniform( container, next );

					}

					container = next;

				}

			}

		}

		// Root Container

		function WebGLUniforms( gl, program, renderer ) {

			UniformContainer.call( this );

			this.renderer = renderer;

			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( var i = 0; i !== n; ++ i ) {

				var info = gl.getActiveUniform( program, i ),
					path = info.name,
					addr = gl.getUniformLocation( program, path );

				parseUniform( info, addr, this );

			}

		}

		WebGLUniforms.prototype.setValue = function( gl, name, value ) {

			var u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, value, this.renderer );

		};

		WebGLUniforms.prototype.set = function( gl, object, name ) {

			var u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

		};

		WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

			var v = object[ name ];

			if ( v !== undefined ) this.setValue( gl, name, v );

		};


		// Static interface

		WebGLUniforms.upload = function( gl, seq, values, renderer ) {

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ],
					v = values[ u.id ];

				if ( v.needsUpdate !== false ) {
					// note: always updating when .needsUpdate is undefined

					u.setValue( gl, v.value, renderer );

				}

			}

		};

		WebGLUniforms.seqWithValue = function( seq, values ) {

			var r = [];

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ];
				if ( u.id in values ) r.push( u );

			}

			return r;

		};

		/**
		 * Uniform Utilities
		 */

		var UniformsUtils = {

			merge: function ( uniforms ) {

				var merged = {};

				for ( var u = 0; u < uniforms.length; u ++ ) {

					var tmp = this.clone( uniforms[ u ] );

					for ( var p in tmp ) {

						merged[ p ] = tmp[ p ];

					}

				}

				return merged;

			},

			clone: function ( uniforms_src ) {

				var uniforms_dst = {};

				for ( var u in uniforms_src ) {

					uniforms_dst[ u ] = UniformsUtils.cloneParameters( uniforms_src[ u ] );

				}

				return uniforms_dst;

			},


			cloneParameters: function ( parameters_src ) {

				var parameters_dst = {};

				for ( var p in parameters_src ) {

					parameters_dst[ p ] = UniformsUtils.cloneParameter( parameters_src[ p ] );

				}

				return parameters_dst;

			},

			cloneParameter: function ( parameter_src ) {

				if ( parameter_src && ( parameter_src.isColor ||
					parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
					parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
					parameter_src.isTexture ) ) {

					return parameter_src.clone();

				} else if ( Array.isArray( parameter_src ) ) {

					return parameter_src.slice();

				} else {

					return parameter_src;

				}

			}

		};

		var alphamap_fragment = "#ifdef USE_ALPHAMAP\r\n\r\n#if defined( TEXTURE_SLOTS )\r\n\tvec2 alphaUv = alphaMapUV();\r\n#else\r\n\tvec2 alphaUv = vUv;\r\n#endif\r\n\r\n\tdiffuseColor.a *= alphaMapTexelTransform( texture2D( alphaMap, alphaUv ) ).g;\r\n\r\n#endif\r\n";

		var alphamap_pars_fragment = "#if ! defined( TEXTURE_SLOTS )\r\n\t#ifdef USE_ALPHAMAP\r\n\r\n\t\tuniform sampler2D alphaMap;\r\n\r\n\t#endif\r\n#endif\r\n";

		var alphatest_fragment = "#ifdef ALPHATEST\r\n\r\n\tif ( diffuseColor.a < ALPHATEST ) discard;\r\n\r\n#endif\r\n";

		var aomap_fragment = "#ifdef USE_AOMAP\r\n\r\n#if defined( TEXTURE_SLOTS )\r\n\tvec2 aoUv = aoMapUV();\r\n#else\r\n\tvec2 aoUv = vUv2;\r\n#endif\r\n\r\n\tfloat ambientOcclusion = ( aoMapTexelTransform( texture2D( aoMap, aoUv ) ).r - 1.0 ) * aoMapIntensity + 1.0;\r\n\r\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\r\n\r\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n\r\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\r\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var aomap_pars_fragment = "#ifdef USE_AOMAP\r\n\r\n#if ! defined( TEXTURE_SLOTS )\r\n\tuniform sampler2D aoMap;\r\n#endif\r\n\r\n\tuniform float aoMapIntensity;\r\n\r\n#endif\r\n";

		var begin_vertex = "\r\nvec3 transformed = vec3( position );\r\n";

		var beginnormal_vertex = "\r\nvec3 objectNormal = vec3( normal );\r\n";

		var bsdfs = "\r\n\r\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\r\n\r\n\tif ( decayExponent > 0.0 && cutoffDistance > 0.0 ) {\r\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\r\n\t}\r\n\telse if ( decayExponent < 0.0 ) {\r\n\t\t// this is based upon UE4 light fall as described on page 11 of:\r\n\t\t//  https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\r\n\t\tfloat maxDistanceCutoffFactor = 1.0;\r\n\t\tif( cutoffDistance > 0.0 ) {\r\n\t\t\tmaxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\r\n\t\t}\r\n\t\tfloat distanceFalloff = 1.0 / ( pow2( lightDistance ) + 1.0 );\r\n\r\n\t\treturn maxDistanceCutoffFactor * distanceFalloff;\r\n\t}\r\n\telse {\r\n\t\treturn 1.0;\r\n\t}\r\n}\r\n\r\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n\r\n\treturn RECIPROCAL_PI * diffuseColor;\r\n\r\n} // validated\r\n\r\n\r\nfloat F_Schlick( const in float specular, const in float dotLH ) {\r\n\r\n\t// Original approximation by Christophe Schlick '94\r\n\t//;float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n\r\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\r\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n\r\n\treturn ( 1.0 - specular ) * fresnel + specular;\r\n\r\n} // validated\r\n\r\n\r\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n\r\n\t// Original approximation by Christophe Schlick '94\r\n\t//;float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n\r\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\r\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n\r\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\r\n\r\n} // validated\r\n\r\n\r\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\r\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\r\n// alpha is \"roughness squared\" in Disney’s reparameterization\r\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\r\n\r\n\t// geometry term = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\r\n\r\n\tfloat a2 = pow2( alpha );\r\n\r\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n\r\n\treturn 1.0 / ( gl * gv );\r\n\r\n} // validated\r\n\r\n// from page 12, listing 2 of http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\r\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\r\n\r\n\tfloat a2 = pow2( alpha );\r\n\r\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\r\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n\r\n\treturn 0.5 / max( gv + gl, EPSILON );\r\n}\r\n\r\n\r\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\r\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\r\n// alpha is \"roughness squared\" in Disney’s reparameterization\r\nfloat D_GGX( const in float alpha, const in float dotNH ) {\r\n\r\n\tfloat a2 = pow2( alpha );\r\n\r\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\r\n\r\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\r\n\r\n}\r\n\r\n\r\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\r\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\r\n\r\n\tfloat alpha = pow2( roughness ); // UE4's roughness\r\n\r\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n\r\n\tfloat dotNL = clamp( dot( geometry.normal, incidentLight.direction ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\r\n\tfloat dotNV = clamp( dot( geometry.normal, geometry.viewDir ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\r\n\tfloat dotNH = clamp( dot( geometry.normal, halfDir ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\r\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\r\n\r\n\tvec3 F = F_Schlick( specularColor, dotLH );\r\n\r\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\r\n\r\n\tfloat D = D_GGX( alpha, dotNH );\r\n\r\n\treturn F * ( G * D );\r\n\r\n} // validated\r\n\r\nfloat BRDF_ClearCoat_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in float specular, const in float roughness, out float layerAttenuation ) {\r\n\r\n\tfloat alpha = pow2( roughness ); // UE4's roughness\r\n\r\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n\r\n\tfloat dotNL = clamp( dot( geometry.normal, incidentLight.direction ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\r\n\tfloat dotNV = clamp( dot( geometry.normal, geometry.viewDir ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\r\n\tfloat dotNH = clamp( dot( geometry.normal, halfDir ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\r\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\r\n\r\n\tfloat F = F_Schlick( specular, dotLH );\r\n\r\n\tlayerAttenuation = F;\r\n\r\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\r\n\r\n\tfloat D = D_GGX( alpha, dotNH );\r\n\r\n\treturn F * ( G * D );\r\n\r\n}\r\n\r\n//\r\n// Rect Area Light BRDF Approximations\r\n//\r\n\r\n// Area light computation code adapted from:\r\n// http://blog.selfshadow.com/sandbox/ltc.html\r\n//\r\n// Based on paper:\r\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\r\n// By: Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\r\n// https://eheitzresearch.wordpress.com/415-2/\r\n\r\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\r\n\r\n\tconst float LUT_SIZE  = 64.0;\r\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\r\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\r\n\r\n\tvec3 N = geometry.normal;\r\n\tvec3 V = geometry.viewDir;\r\n\tvec3 P = geometry.position;\r\n\r\n\t// view angle on surface determines which LTC BRDF values we use\r\n\tfloat theta = acos( dot( N, V ) );\r\n\r\n\t// Parameterization of texture:\r\n\t// sqrt(roughness) -> [0,1]\r\n\t// theta -> [0, PI/2]\r\n\tvec2 uv = vec2(\r\n\t\tsqrt( saturate( roughness ) ),\r\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\r\n\r\n\t// Ensure we don't have nonlinearities at the look-up table's edges\r\n\t// see: http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter24.html\r\n\t//      \"Shader Analysis\" section\r\n\tuv = uv * LUT_SCALE + LUT_BIAS;\r\n\r\n\treturn uv;\r\n\r\n}\r\n\r\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\r\n\r\n\t// detect clipping config\r\n\tint config = 0;\r\n\tif ( L[0].z > 0.0 ) config += 1;\r\n\tif ( L[1].z > 0.0 ) config += 2;\r\n\tif ( L[2].z > 0.0 ) config += 4;\r\n\tif ( L[3].z > 0.0 ) config += 8;\r\n\r\n\t// clip\r\n\tn = 0;\r\n\r\n\tif ( config == 0 ) {\r\n\r\n\t\t// clip all\r\n\r\n\t} else if ( config == 1 ) {\r\n\r\n\t\t// V1 clip V2 V3 V4\r\n\t\tn = 3;\r\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\r\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\r\n\r\n\t} else if ( config == 2 ) {\r\n\r\n\t\t// V2 clip V1 V3 V4\r\n\t\tn = 3;\r\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\r\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\r\n\r\n\t} else if ( config == 3 ) {\r\n\r\n\t\t// V1 V2 clip V3 V4\r\n\t\tn = 4;\r\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\r\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\r\n\r\n\t} else if ( config == 4 ) {\r\n\r\n\t\t// V3 clip V1 V2 V4\r\n\t\tn = 3;\r\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\r\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\r\n\r\n\t} else if ( config == 5 ) {\r\n\r\n\t\t// V1 V3 clip V2 V4) impossible\r\n\t\tn = 0;\r\n\r\n\t} else if ( config == 6 ) {\r\n\r\n\t\t// V2 V3 clip V1 V4\r\n\t\tn = 4;\r\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\r\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\r\n\r\n\t} else if ( config == 7 ) {\r\n\r\n\t\t// V1 V2 V3 clip V4\r\n\t\tn = 5;\r\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\r\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\r\n\r\n\t} else if ( config == 8 ) {\r\n\r\n\t\t// V4 clip V1 V2 V3\r\n\t\tn = 3;\r\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\r\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\r\n\t\tL[2] =  L[3];\r\n\r\n\t} else if ( config == 9 ) {\r\n\r\n\t\t// V1 V4 clip V2 V3\r\n\t\tn = 4;\r\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\r\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\r\n\r\n\t} else if ( config == 10 ) {\r\n\r\n\t\t// V2 V4 clip V1 V3) impossible\r\n\t\tn = 0;\r\n\r\n\t} else if ( config == 11 ) {\r\n\r\n\t\t// V1 V2 V4 clip V3\r\n\t\tn = 5;\r\n\t\tL[4] = L[3];\r\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\r\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\r\n\r\n\t} else if ( config == 12 ) {\r\n\r\n\t\t// V3 V4 clip V1 V2\r\n\t\tn = 4;\r\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\r\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\r\n\r\n\t} else if ( config == 13 ) {\r\n\r\n\t\t// V1 V3 V4 clip V2\r\n\t\tn = 5;\r\n\t\tL[4] = L[3];\r\n\t\tL[3] = L[2];\r\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\r\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\r\n\r\n\t} else if ( config == 14 ) {\r\n\r\n\t\t// V2 V3 V4 clip V1\r\n\t\tn = 5;\r\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\r\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\r\n\r\n\t} else if ( config == 15 ) {\r\n\r\n\t\t// V1 V2 V3 V4\r\n\t\tn = 4;\r\n\r\n\t}\r\n\r\n\tif ( n == 3 )\r\n\t\tL[3] = L[0];\r\n\tif ( n == 4 )\r\n\t\tL[4] = L[0];\r\n\r\n}\r\n\r\n// Equation (11) of \"Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\"\r\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\r\n\r\n\tfloat cosTheta = dot( v1, v2 );\r\n\tfloat theta = acos( cosTheta );\r\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\r\n\r\n\trectPoints[0] = pos - halfWidth - halfHeight;\r\n\trectPoints[1] = pos + halfWidth - halfHeight;\r\n\trectPoints[2] = pos + halfWidth + halfHeight;\r\n\trectPoints[3] = pos - halfWidth + halfHeight;\r\n\r\n}\r\n\r\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\r\n\r\n\tvec3 N = geometry.normal;\r\n\tvec3 V = geometry.viewDir;\r\n\tvec3 P = geometry.position;\r\n\r\n\t// construct orthonormal basis around N\r\n\tvec3 T1, T2;\r\n\tT1 = normalize(V - N * dot( V, N ));\r\n\t// TODO (abelnation): I had to negate this cross product to get proper light.  Curious why sample code worked without negation\r\n\tT2 = - cross( N, T1 );\r\n\r\n\t// rotate area light in (T1, T2, N) basis\r\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\r\n\r\n\t// transformed rect relative to surface point\r\n\tvec3 clippedRect[5];\r\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\r\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\r\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\r\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\r\n\r\n\t// clip light rect to horizon, resulting in at most 5 points\r\n\t// we do this because we are integrating the BRDF over the hemisphere centered on the surface points normal\r\n\tint n;\r\n\tclipQuadToHorizon(clippedRect, n);\r\n\r\n\t// light is completely below horizon\r\n\tif ( n == 0 )\r\n\t\treturn vec3( 0, 0, 0 );\r\n\r\n\t// project clipped rect onto sphere\r\n\tclippedRect[0] = normalize( clippedRect[0] );\r\n\tclippedRect[1] = normalize( clippedRect[1] );\r\n\tclippedRect[2] = normalize( clippedRect[2] );\r\n\tclippedRect[3] = normalize( clippedRect[3] );\r\n\tclippedRect[4] = normalize( clippedRect[4] );\r\n\r\n\t// integrate\r\n\t// simplified integration only needs to be evaluated for each edge in the polygon\r\n\tfloat sum = 0.0;\r\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\r\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\r\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\r\n\tif (n >= 4)\r\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\r\n\tif (n == 5)\r\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\r\n\r\n\t// TODO (abelnation): two-sided area light\r\n\t// sum = twoSided ? abs(sum) : max(0.0, sum);\r\n\tsum = max( 0.0, sum );\r\n\t// sum = abs( sum );\r\n\r\n\tvec3 Lo_i = vec3( sum, sum, sum );\r\n\r\n\treturn Lo_i;\r\n\r\n}\r\n\r\nvec3 Rect_Area_Light_Specular_Reflectance(\r\n\t\tconst in GeometricContext geometry,\r\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\r\n\t\tconst in float roughness,\r\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\r\n\r\n\tvec3 rectPoints[4];\r\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\r\n\r\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\r\n\r\n\tvec4 brdfLtcApproxParams, t;\r\n\r\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\r\n\tt = texture2D( ltcMat, uv );\r\n\r\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\r\n\r\n\t// inv(M) matrix referenced by equation (6) in paper\r\n\tmat3 brdfLtcApproxMat = mat3(\r\n\t\tvec3(   1,   0, t.y ),\r\n\t\tvec3(   0, t.z,   0 ),\r\n\t\tvec3( t.w,   0, t.x )\r\n\t);\r\n\r\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\r\n\tspecularReflectance *= brdfLtcScalar;\r\n\r\n\treturn specularReflectance;\r\n\r\n}\r\n\r\nvec3 Rect_Area_Light_Diffuse_Reflectance(\r\n\t\tconst in GeometricContext geometry,\r\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\r\n\r\n\tvec3 rectPoints[4];\r\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\r\n\r\n\tmat3 diffuseBrdfMat = mat3(1);\r\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\r\n\r\n\treturn diffuseReflectance;\r\n\r\n}\r\n// End RectArea BRDF\r\n\r\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\r\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\r\n\r\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\r\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\r\n\r\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\r\n\r\n\tvec4 r = roughness * c0 + c1;\r\n\r\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\r\n\r\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\r\n\r\n\treturn specularColor * AB.x + AB.y;\r\n\r\n} // validated\r\n\r\n\r\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\r\nfloat BRDF_ClearCoat_GGX_Environment( const in GeometricContext geometry, const in float specular, const in float roughness, out float layerAttention ) {\r\n\r\n\tvec3 incidentLightDirection = reflect( geometry.viewDir, geometry.normal );\r\n\tvec3 halfDir = normalize( incidentLightDirection + geometry.viewDir );\r\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\tfloat dotLH = saturate( dot( incidentLightDirection, halfDir ) );\r\n\r\n\tlayerAttention = F_Schlick( specular, dotLH );\r\n\r\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\r\n\r\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\r\n\r\n\tvec4 r = roughness * c0 + c1;\r\n\r\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\r\n\r\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\r\n\r\n\treturn specular * AB.x + AB.y;\r\n\r\n} // validated\r\n\r\n\r\nfloat G_BlinnPhong_Implicit( ) {\r\n\r\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n\treturn 0.25;\r\n\r\n}\r\n\r\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n\r\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n\r\n}\r\n\r\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n\r\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n\r\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\r\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\r\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\r\n\r\n\tvec3 F = F_Schlick( specularColor, dotLH );\r\n\r\n\tfloat G = G_BlinnPhong_Implicit( );\r\n\r\n\tfloat D = D_BlinnPhong( shininess, dotNH );\r\n\r\n\treturn F * ( G * D );\r\n\r\n} // validated\r\n\r\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\r\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\r\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\r\n}\r\n\r\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\r\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\r\n}\r\n";

		var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\r\n\r\n#if ! defined( TEXTURE_SLOTS )\r\n\r\n\tuniform sampler2D bumpMap;\r\n\tuniform float bumpScale;\r\n\r\n#endif\r\n\r\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\r\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\r\n\r\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\r\n\r\n\tvec2 dHdxy_fwd() {\r\n\r\n#if defined( TEXTURE_SLOTS )\r\n\t\tvec2 bumpUv = bumpMapUV();\r\n#else\r\n\t\tvec2 bumpUv = vUv;\r\n#endif\r\n\r\n\t\tvec2 dSTdx = dFdx( bumpUv );\r\n\t\tvec2 dSTdy = dFdy( bumpUv );\r\n\r\n\t\tfloat Hll = bumpMapTexelTransform( texture2D( bumpMap, bumpUv ) ).x;\r\n\t\tfloat dBx = bumpMapTexelTransform( texture2D( bumpMap, bumpUv + dSTdx ) ).x - Hll;\r\n\t\tfloat dBy = bumpMapTexelTransform( texture2D( bumpMap, bumpUv + dSTdy ) ).x - Hll;\r\n\r\n\t\treturn vec2( dBx, dBy );\r\n\r\n\t}\r\n\r\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\r\n\r\n\t\tvec3 vSigmaX = dFdx( surf_pos );\r\n\t\tvec3 vSigmaY = dFdy( surf_pos );\r\n\t\tvec3 vN = surf_norm;\t\t// normalized\r\n\r\n\t\tvec3 R1 = cross( vSigmaY, vN );\r\n\t\tvec3 R2 = cross( vN, vSigmaX );\r\n\r\n\t\tfloat fDet = dot( vSigmaX, R1 );\r\n\r\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\r\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\r\n\r\n\t}\r\n\r\n#endif\r\n";

		var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\r\n\r\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\r\n\r\n\t\tvec4 plane = clippingPlanes[ i ];\r\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\r\n\r\n\t}\r\n\r\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\r\n\r\n\t\tbool clipped = true;\r\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\r\n\t\t\tvec4 plane = clippingPlanes[ i ];\r\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\r\n\t\t}\r\n\r\n\t\tif ( clipped ) discard;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\r\n\r\n\t#if ! defined( VARYING_VVIEWPOSITION )\r\n\t\tvarying vec3 vViewPosition;\r\n\t\t#define VARYING_VVIEWPOSITION 1\r\n\t#endif\r\n\r\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\r\n\r\n#endif\r\n";

		var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\r\n\t#if ! defined( VARYING_VVIEWPOSITION )\r\n    \tvarying vec3 vViewPosition;\r\n    \t#define VARYING_VVIEWPOSITION 1\r\n    #endif\r\n#endif\r\n";

		var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\r\n\tvViewPosition = - mvPosition.xyz;\r\n#endif\r\n\r\n";

		var color_fragment = "#ifdef USE_COLOR\r\n\r\n\tdiffuseColor.rgb *= vColor;\r\n\r\n#endif\r\n";

		var color_pars_fragment = "#ifdef USE_COLOR\r\n\r\n\tvarying vec3 vColor;\r\n\r\n#endif\r\n";

		var color_pars_vertex = "#ifdef USE_COLOR\r\n\r\n\tvarying vec3 vColor;\r\n\r\n#endif\r\n";

		var color_vertex = "#ifdef USE_COLOR\r\n\r\n\tvColor.xyz = color.xyz;\r\n\r\n#endif\r\n";

		var common = "#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nhighp float rand( const in vec2 uv ) {\r\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nstruct IncidentLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n\tbool visible;\r\n};\r\n\r\nstruct ReflectedLight {\r\n\tvec3 directDiffuse;\r\n\tvec3 directSpecular;\r\n\tvec3 indirectDiffuse;\r\n\tvec3 indirectSpecular;\r\n};\r\n\r\nstruct GeometricContext {\r\n\tvec3 position;\r\n\tvec3 normal;\r\n\tvec3 viewDir;\r\n};\r\n\r\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\r\n\r\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\r\n\r\n}\r\n\r\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\r\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\r\n\r\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\r\n\r\n}\r\n\r\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\r\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\r\n\r\n\treturn - distance * planeNormal + point;\r\n\r\n}\r\n\r\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\r\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\r\n\r\n}\r\n\r\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\r\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\r\n\r\n}\r\n\r\nmat3 transpose( const in mat3 v ) {\r\n\r\n\tmat3 tmp;\r\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\r\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\r\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\r\n\r\n\treturn tmp;\r\n\r\n}\r\n";

		var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\r\n\r\n#define cubeUV_textureSize (1024.0)\r\n\r\nint getFaceFromDirection(vec3 direction) {\r\n\tvec3 absDirection = abs(direction);\r\n\tint face = -1;\r\n\tif( absDirection.x > absDirection.z ) {\r\n\t\tif(absDirection.x > absDirection.y )\r\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\r\n\t\telse\r\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\r\n\t}\r\n\telse {\r\n\t\tif(absDirection.z > absDirection.y )\r\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\r\n\t\telse\r\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\r\n\t}\r\n\treturn face;\r\n}\r\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\r\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\r\n\r\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\r\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\r\n\tfloat dxRoughness = dFdx(roughness);\r\n\tfloat dyRoughness = dFdy(roughness);\r\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\r\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\r\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\r\n\t// Clamp the value to the max mip level counts. hard coded to 6 mips\r\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\r\n\tfloat mipLevel = 0.5 * log2(d);\r\n\treturn vec2(floor(mipLevel), fract(mipLevel));\r\n}\r\n\r\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\r\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\r\n\r\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\r\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\r\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\r\n\r\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\r\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\r\n\t// float powScale = exp2(roughnessLevel + mipLevel);\r\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\r\n\t// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\r\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\r\n\t// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\r\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\r\n\r\n\tbool bRes = mipLevel == 0.0;\r\n\tscale =  bRes && (scale < a) ? a : scale;\r\n\r\n\tvec3 r;\r\n\tvec2 offset;\r\n\tint face = getFaceFromDirection(direction);\r\n\r\n\tfloat rcpPowScale = 1.0 / powScale;\r\n\r\n\tif( face == 0) {\r\n\t\tr = vec3(direction.x, -direction.z, direction.y);\r\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\r\n\t}\r\n\telse if( face == 1) {\r\n\t\tr = vec3(direction.y, direction.x, direction.z);\r\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\r\n\t}\r\n\telse if( face == 2) {\r\n\t\tr = vec3(direction.z, direction.x, direction.y);\r\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\r\n\t}\r\n\telse if( face == 3) {\r\n\t\tr = vec3(direction.x, direction.z, direction.y);\r\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\r\n\t}\r\n\telse if( face == 4) {\r\n\t\tr = vec3(direction.y, direction.x, -direction.z);\r\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\r\n\t}\r\n\telse {\r\n\t\tr = vec3(direction.z, -direction.x, direction.y);\r\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\r\n\t}\r\n\tr = normalize(r);\r\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\r\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\r\n\tvec2 base = offset + vec2( texelOffset );\r\n\treturn base + s * ( scale - 2.0 * texelOffset );\r\n}\r\n\r\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\r\n\r\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\r\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\r\n\tfloat r1 = floor(roughnessVal);\r\n\tfloat r2 = r1 + 1.0;\r\n\tfloat t = fract(roughnessVal);\r\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\r\n\tfloat s = mipInfo.y;\r\n\tfloat level0 = mipInfo.x;\r\n\tfloat level1 = level0 + 1.0;\r\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\r\n\r\n\t// round to nearest mipmap if we are not interpolating.\r\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\r\n\r\n\t// Tri linear interpolation.\r\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\r\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\r\n\r\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\r\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\r\n\r\n\tvec4 result = mix(color10, color20, t);\r\n\r\n\treturn vec4(result.rgb, 1.0);\r\n}\r\n\r\n#endif\r\n";

		var defaultnormal_vertex = "#ifdef FLIP_SIDED\r\n\r\n\tobjectNormal = -objectNormal;\r\n\r\n#endif\r\n\r\nvec3 transformedNormal = normalMatrix * objectNormal;\r\n";

		var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\r\n\r\n\tuniform sampler2D displacementMap;\r\n\tuniform float displacementScale;\r\n\tuniform float displacementBias;\r\n\r\n#endif\r\n";

		var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\r\n\r\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\r\n\r\n#endif\r\n";

		var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\r\n\r\n#if defined( TEXTURE_SLOTS )\r\n\tvec2 emissiveUv = emissiveMapUV();\r\n#else\r\n\tvec2 emissiveUv = vUv;\r\n#endif\r\n\r\n\tvec4 emissiveColor = texture2D( emissiveMap, emissiveUv );\r\n\r\n\temissiveColor.rgb = emissiveMapTexelTransform( emissiveMapTexelToLinear( emissiveColor ) ).rgb;\r\n\r\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\r\n\r\n#endif\r\n";

		var emissivemap_pars_fragment = "#if ! defined( TEXTURE_SLOTS )\r\n\t#ifdef USE_EMISSIVEMAP\r\n\r\n\t\tuniform sampler2D emissiveMap;\r\n\r\n\t#endif\r\n#endif\r\n";

		var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\r\n";

		var encodings_pars_fragment = "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\r\n\r\nvec4 LinearToLinear( in vec4 value ) {\r\n  return value;\r\n}\r\n\r\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\r\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\r\n}\r\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\r\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\r\n}\r\n\r\nvec4 sRGBToLinear( in vec4 value ) {\r\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\r\n}\r\nvec4 LinearTosRGB( in vec4 value ) {\r\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\r\n}\r\n\r\nvec4 RGBEToLinear( in vec4 value ) {\r\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\r\n}\r\nvec4 LinearToRGBE( in vec4 value ) {\r\n  float maxComponent = max( max( value.r, value.g ), value.b );\r\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\r\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\r\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\r\n}\r\n\r\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\r\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\r\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\r\n}\r\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\r\n  float maxRGB = max( value.x, max( value.g, value.b ) );\r\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\r\n  M            = ceil( M * 255.0 ) / 255.0;\r\n  return vec4( value.rgb / ( M * maxRange ), M );\r\n}\r\n\r\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\r\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\r\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\r\n}\r\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\r\n    float maxRGB = max( value.x, max( value.g, value.b ) );\r\n    float D      = max( maxRange / maxRGB, 1.0 );\r\n    D            = min( floor( D ) / 255.0, 1.0 );\r\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\r\n}\r\n\r\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\r\n\r\n// M matrix, for encoding\r\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\r\nvec4 LinearToLogLuv( in vec4 value )  {\r\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\r\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\r\n  vec4 vResult;\r\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\r\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\r\n  vResult.w = fract(Le);\r\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\r\n  return vResult;\r\n}\r\n\r\n// Inverse M matrix, for decoding\r\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\r\nvec4 LogLuvToLinear( in vec4 value ) {\r\n  float Le = value.z * 255.0 + value.w;\r\n  vec3 Xp_Y_XYZp;\r\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\r\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\r\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\r\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\r\n  return vec4( max(vRGB, 0.0), 1.0 );\r\n}\r\n";

		var envmap_fragment = "#ifdef USE_ENVMAP\r\n\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n\r\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\r\n\r\n\t\t// Transforming Normal Vectors with the Inverse Transformation\r\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\r\n\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\r\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\r\n\r\n\t\t#else\r\n\r\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\r\n\r\n\t\t#endif\r\n\r\n\t#else\r\n\r\n\t\tvec3 reflectVec = vReflect;\r\n\r\n\t#endif\r\n\r\n\t#ifdef ENVMAP_TYPE_CUBE\r\n\r\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\r\n\r\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n\r\n\t\tvec2 sampleUV;\r\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\r\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\r\n\r\n\t#elif defined( ENVMAP_TYPE_SPHERE )\r\n\r\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\r\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\r\n\r\n\t#else\r\n\r\n\t\tvec4 envColor = vec4( 0.0 );\r\n\r\n\t#endif\r\n\r\n\tenvColor = envMapTexelToLinear( envColor );\r\n\r\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\r\n\r\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\r\n\r\n\t#elif defined( ENVMAP_BLENDING_MIX )\r\n\r\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\r\n\r\n\t#elif defined( ENVMAP_BLENDING_ADD )\r\n\r\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\r\n\tuniform float reflectivity;\r\n\tuniform float envMapIntensity;\r\n#endif\r\n\r\n#ifdef USE_ENVMAP\r\n\r\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\r\n\t\tvarying vec3 vWorldPosition;\r\n\t#endif\r\n\r\n\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\tuniform samplerCube envMap;\r\n\t#else\r\n\t\tuniform sampler2D envMap;\r\n\t#endif\r\n\tuniform float flipEnvMap;\r\n\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\r\n\t\tuniform float refractionRatio;\r\n\t#else\r\n\t\tvarying vec3 vReflect;\r\n\t#endif\r\n\r\n#endif\r\n";

		var envmap_pars_vertex = "#ifdef USE_ENVMAP\r\n\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t#else\r\n\r\n\t\tvarying vec3 vReflect;\r\n\t\tuniform float refractionRatio;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var envmap_vertex = "#ifdef USE_ENVMAP\r\n\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n\r\n\t\tvWorldPosition = worldPosition.xyz;\r\n\r\n\t#else\r\n\r\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\r\n\r\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\r\n\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\r\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\r\n\r\n\t\t#else\r\n\r\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\r\n\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var falloff_fragment = "#ifdef FALLOFF\r\n\r\nfloat falloffModulator = abs( dot( normal, normalize( vViewPosition ) ) );\r\n\r\n// smoothstep: this is a hack, it needs to be fixed.\r\nfalloffModulator = ( falloffModulator * falloffModulator * ( 3.0 - 2.0 * falloffModulator ) );\r\n\r\ndiffuseColor = mix( falloffDiffuseColor, diffuseColor, falloffModulator );\r\n\r\n#endif // FALLOFF\r\n";

		var falloffalphamap_fragment = "#ifdef USE_FALLOFFALPHAMAP\r\n\r\n#if defined( TEXTURE_SLOTS )\r\n\tvec2 falloffAlphaUv = falloffAlphaMapUV();\r\n#else\r\n\tvec2 falloffAlphaUv = vUv;\r\n#endif\r\n\r\n\tfalloffDiffuseColor.a *= falloffAlphaMapTexelTransform( texture2D( falloffAlphaMap, falloffAlphaUv ) ).g;\r\n\r\n#endif\r\n";

		var falloffmap_fragment = "#ifdef USE_FALLOFFMAP\r\n\r\n#if defined( TEXTURE_SLOTS )\r\n\tvec2 falloffMapUv = falloffMapUV();\r\n#else\r\n\tvec2 falloffMapUv = vUv;\r\n#endif\r\n\r\n\tvec4 falloffTexelColor = texture2D( falloffMap, falloffMapUv );\r\n\r\n\tfalloffTexelColor = falloffMapTexelTransform( falloffMapTexelToLinear( falloffTexelColor ) );\r\n\tfalloffDiffuseColor *= falloffTexelColor;\r\n\r\n#endif\r\n";

		var fog_fragment = "#ifdef USE_FOG\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\r\n\r\n\t#endif\r\n\r\n\t#ifdef FOG_EXP2\r\n\r\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\r\n\r\n\t#else\r\n\r\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\r\n\r\n#endif\r\n";

		var fog_pars_fragment = "#ifdef USE_FOG\r\n\r\n\tuniform vec3 fogColor;\r\n\r\n\t#ifdef FOG_EXP2\r\n\r\n\t\tuniform float fogDensity;\r\n\r\n\t#else\r\n\r\n\t\tuniform float fogNear;\r\n\t\tuniform float fogFar;\r\n\t#endif\r\n\r\n#endif\r\n";

		var gradientmap_pars_fragment = "#ifdef TOON\r\n\r\n\tuniform sampler2D gradientMap;\r\n\r\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\r\n\r\n\t\t// dotNL will be from -1.0 to 1.0\r\n\t\tfloat dotNL = dot( normal, lightDirection );\r\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\r\n\r\n\t\t#ifdef USE_GRADIENTMAP\r\n\r\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\r\n\r\n\t\t#else\r\n\r\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\r\n\r\n\t\t#endif\r\n\r\n\r\n\t}\r\n\r\n#endif\r\n";

		var lightmap_fragment = "#ifdef USE_LIGHTMAP\r\n\r\n#if defined( TEXTURE_SLOTS )\r\n\tvec2 lightUv = lightMapUV();\r\n#else\r\n\tvec2 lightUv = vUv2;\r\n#endif\r\n\r\n\treflectedLight.indirectDiffuse += PI * emissiveMapTexelTransform( texture2D( lightMap, lightUv ) ).xyz; // factor of PI should not be present; included here to prevent breakage\r\n\r\n#endif\r\n";

		var lightmap_pars_fragment = "#if ! defined( TEXTURE_SLOTS )\r\n\t#ifdef USE_LIGHTMAP\r\n\r\n\t\tuniform sampler2D lightMap;\r\n\t\tuniform float lightMapIntensity;\r\n\r\n\t#endif\r\n#endif\r\n";

		var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\r\n\r\nGeometricContext geometry;\r\ngeometry.position = mvPosition.xyz;\r\ngeometry.normal = normalize( transformedNormal );\r\ngeometry.viewDir = normalize( -mvPosition.xyz );\r\n\r\nGeometricContext backGeometry;\r\nbackGeometry.position = geometry.position;\r\nbackGeometry.normal = -geometry.normal;\r\nbackGeometry.viewDir = geometry.viewDir;\r\n\r\nvLightFront = vec3( 0.0 );\r\n\r\n#ifdef DOUBLE_SIDED\r\n\tvLightBack = vec3( 0.0 );\r\n#endif\r\n\r\nIncidentLight directLight;\r\nfloat dotNL;\r\nvec3 directLightColor_Diffuse;\r\n\r\n#if NUM_POINT_LIGHTS > 0\r\n\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\r\n\r\n\t\tdotNL = dot( geometry.normal, directLight.direction );\r\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\r\n\r\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\r\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if NUM_SPOT_LIGHTS > 0\r\n\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\r\n\r\n\t\tdotNL = dot( geometry.normal, directLight.direction );\r\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\r\n\r\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\r\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#endif\r\n\t}\r\n\r\n#endif\r\n\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\r\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n\r\n\t\t// TODO (abelnation): implement\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if NUM_DIR_LIGHTS > 0\r\n\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\r\n\r\n\t\tdotNL = dot( geometry.normal, directLight.direction );\r\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\r\n\r\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\r\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if NUM_HEMI_LIGHTS > 0\r\n\r\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n\r\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\r\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n#endif\r\n";

		var lights_pars = "uniform vec3 ambientLightColor;\r\n\r\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\r\n\r\n\tvec3 irradiance = ambientLightColor;\r\n\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\tirradiance *= PI;\r\n\r\n\t#endif\r\n\r\n\treturn irradiance;\r\n\r\n}\r\n\r\n#if NUM_DIR_LIGHTS > 0\r\n\r\n\tstruct DirectionalLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat spreadAngle;\r\n\t\tvec2 shadowMapSize;\r\n\t\tvec3 shadowCameraParams;\r\n\t};\r\n\r\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\r\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\r\n\t\tdirectLight.color = directionalLight.color;\r\n\t\tdirectLight.direction = directionalLight.direction;\r\n\t\tdirectLight.visible = true;\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n#if NUM_POINT_LIGHTS > 0\r\n\r\n\tstruct PointLight {\r\n\t\tvec3 position;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t};\r\n\r\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\r\n\r\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\r\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\r\n\t\tvec3 lVector = pointLight.position - geometry.position;\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tdirectLight.direction = lVector / lightDistance;\r\n\r\n\r\n\t\tdirectLight.color = pointLight.color;\r\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\r\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n#if NUM_SPOT_LIGHTS > 0\r\n\r\n\tstruct SpotLight {\r\n\t\tvec3 position;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t\tvec3 shadowCameraParams;\r\n\t};\r\n\r\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\r\n\r\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\r\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\r\n\r\n\t\tvec3 lVector = spotLight.position - geometry.position;\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tdirectLight.direction = lVector / lightDistance;\r\n\r\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\r\n\r\n\t\tif ( angleCos > spotLight.coneCos ) {\r\n\r\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\r\n\r\n\t\t\tdirectLight.color = spotLight.color;\r\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\r\n\t\t\tdirectLight.visible = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdirectLight.color = vec3( 0.0 );\r\n\t\t\tdirectLight.visible = false;\r\n\r\n\t\t}\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\r\n\tstruct RectAreaLight {\r\n\t\tvec3 color;\r\n\t\tvec3 position;\r\n\t\tvec3 halfWidth;\r\n\t\tvec3 halfHeight;\r\n\t};\r\n\r\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\r\n\t// BRDF approximation Texture is 64x64\r\n\tuniform sampler2D ltcMat; // RGBA Float\r\n\tuniform sampler2D ltcMag; // Alpha Float (only has w component)\r\n\r\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\r\n\r\n#endif\r\n\r\n\r\n#if NUM_HEMI_LIGHTS > 0\r\n\r\n\tstruct HemisphereLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 skyColor;\r\n\t\tvec3 groundColor;\r\n\t};\r\n\r\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\r\n\r\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\r\n\r\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\r\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\r\n\r\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\r\n\r\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\t\tirradiance *= PI;\r\n\r\n\t\t#endif\r\n\r\n\t\treturn irradiance;\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n\r\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\r\n\r\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\r\n\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\r\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\r\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\r\n\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\r\n\r\n\t\t#else\r\n\r\n\t\t\tvec4 envMapColor = vec4( 0.0 );\r\n\r\n\t\t#endif\r\n\r\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\r\n\r\n\t}\r\n\r\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\r\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\r\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\r\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\r\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\r\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\r\n\t\t// clamp to allowable LOD ranges.\r\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\r\n\r\n\t}\r\n\r\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\r\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\r\n\r\n\t\t#else\r\n\r\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\r\n\r\n\t\t#endif\r\n\r\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n\r\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\r\n\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\r\n\r\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n\r\n\t\t\tvec2 sampleUV;\r\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\r\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\r\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\r\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\r\n\r\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\r\n\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\r\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\r\n\t\t#endif\r\n\r\n\t\treturn envMapColor.rgb * envMapIntensity;\r\n\r\n\t}\r\n\r\n#endif\r\n";

		var lights_phong_fragment = "BlinnPhongMaterial material;\r\nmaterial.diffuseColor = diffuseColor.rgb;\r\nmaterial.specularColor = specular;\r\nmaterial.specularShininess = shininess;\r\nmaterial.specularStrength = specularStrength;\r\n";

		var lights_phong_pars_fragment = "#if ! defined( VARYING_VVIEWPOSITION )\r\n    varying vec3 vViewPosition;\r\n    #define VARYING_VVIEWPOSITION 1\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n\r\nstruct BlinnPhongMaterial {\r\n\r\n\tvec3\tdiffuseColor;\r\n\tvec3\tspecularColor;\r\n\tfloat\tspecularShininess;\r\n\tfloat\tspecularStrength;\r\n\r\n};\r\n\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n    void RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n        vec3 matDiffColor = material.diffuseColor;\r\n        vec3 matSpecColor = material.specularColor;\r\n        vec3 lightColor   = rectAreaLight.color;\r\n\r\n        float roughness = BlinnExponentToGGXRoughness( material.specularShininess );\r\n\r\n        // Evaluate Lighting Equation\r\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\r\n                geometry,\r\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\r\n                roughness,\r\n                ltcMat, ltcMag );\r\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\r\n                geometry,\r\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\r\n\r\n        // TODO (abelnation): note why division by 2PI is necessary\r\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\r\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\r\n\r\n    }\r\n#endif\r\n\r\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\t#ifdef TOON\r\n\r\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\r\n\r\n\t#else\r\n\r\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\r\n\t\tvec3 irradiance = dotNL * directLight.color;\r\n\r\n\t#endif\r\n\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\tirradiance *= PI; // punctual light\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\r\n\r\n}\r\n\r\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\r\n}\r\n\r\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\r\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\r\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\r\n\r\n#define Material_LightProbeLOD( material )\t(0)\r\n";

		var lights_physical_fragment = "PhysicalMaterial material;\r\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\r\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\r\n#ifdef STANDARD\r\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\r\n#else\r\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\r\n\tmaterial.clearCoat = saturate( clearCoat );\r\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\r\n#endif\r\n";

		var lights_physical_pars_fragment = "struct PhysicalMaterial {\r\n\r\n\tvec3\tdiffuseColor;\r\n\tfloat\tspecularRoughness;\r\n\tvec3\tspecularColor;\r\n\r\n\t#ifndef STANDARD\r\n\t\tfloat clearCoat;\r\n\t\tfloat clearCoatRoughness;\r\n\t#endif\r\n\r\n};\r\n\r\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\r\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\r\n\r\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\r\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\r\n\r\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\r\n\r\n}\r\n\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n    void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n        vec3 matDiffColor = material.diffuseColor;\r\n        vec3 matSpecColor = material.specularColor;\r\n        vec3 lightColor   = rectAreaLight.color;\r\n        float roughness = material.specularRoughness;\r\n\r\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\r\n                geometry,\r\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\r\n                roughness,\r\n                ltcMat, ltcMag );\r\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\r\n                geometry,\r\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\r\n\r\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec;\r\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\r\n\r\n    }\r\n#endif\r\n\r\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\r\n\r\n\tvec3 irradiance = dotNL * directLight.color;\r\n\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\tirradiance *= PI; // punctual light\r\n\r\n\t#endif\r\n\r\n\tvec3 specularRadiance = irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\r\n\tvec3 diffuseRadiance = irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\r\n\t#ifndef STANDARD\r\n\r\n\t\tfloat layerAttention;\r\n\t\tvec3 clearCoatSpecularRadiance = irradiance * BRDF_ClearCoat_GGX( directLight, geometry, material.clearCoat, material.clearCoatRoughness, layerAttention );\r\n\r\n\t\tspecularRadiance = mix( specularRadiance, clearCoatSpecularRadiance, material.clearCoat );\r\n\t\tdiffuseRadiance = mix( diffuseRadiance, vec3( 0.0 ), material.clearCoat );\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directSpecular += specularRadiance;\r\n\treflectedLight.directDiffuse += diffuseRadiance;\r\n\r\n\r\n}\r\n\r\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\tvec3 diffuseRadiance = irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\r\n\t#ifndef STANDARD\r\n\r\n\t\tdiffuseRadiance = mix( diffuseRadiance, vec3( 0.0 ), material.clearCoat );\r\n\r\n\t#endif\r\n\r\n\treflectedLight.indirectDiffuse += diffuseRadiance;\r\n\r\n}\r\n\r\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\tvec3 specularRadiance = radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\r\n\r\n\t#ifndef STANDARD\r\n\r\n\t\tfloat layerAttention;\r\n\t\tvec3 clearCoatSpecularRadiance = clearCoatRadiance * BRDF_ClearCoat_GGX_Environment( geometry, material.clearCoat, material.clearCoatRoughness, layerAttention );\r\n\r\n\t\tspecularRadiance = mix( specularRadiance, clearCoatSpecularRadiance, material.clearCoat );\r\n\r\n\t#endif\r\n\r\n\treflectedLight.indirectSpecular += specularRadiance;\r\n\r\n}\r\n\r\n#define RE_Direct\t\t\t\tRE_Direct_Physical\r\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\r\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\r\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\r\n\r\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\r\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\r\n\r\n// ref: http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\r\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\r\n\r\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\r\n\r\n}\r\n";

		var lights_template = "//\r\n// This is a template that can be used to light a material, it uses pluggable RenderEquations (RE)\r\n//   for specific lighting scenarios.\r\n//\r\n// Instructions for use:\r\n//  - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\r\n//  - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\r\n//  - Create a material parameter that is to be passed as the third parameter to your lighting functions.\r\n//\r\n// TODO:\r\n//  - Add area light support.\r\n//  - Add sphere light support.\r\n//  - Add diffuse light probe (irradiance cubemap) support.\r\n//\r\n\r\nGeometricContext geometry;\r\n\r\ngeometry.position = - vViewPosition;\r\ngeometry.normal = normal;\r\ngeometry.viewDir = normalize( vViewPosition );\r\n\r\nIncidentLight directLight;\r\n\r\n#ifdef USE_SHADOWMAP\r\n\tinitShadows();\r\n#endif\r\n\r\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tPointLight pointLight;\r\n\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tpointLight = pointLights[ i ];\r\n\r\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\r\n\r\n\t\t#ifdef USE_SHADOWMAP\r\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tSpotLight spotLight;\r\n\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tspotLight = spotLights[ i ];\r\n\r\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\r\n\r\n\t\t#ifdef USE_SHADOWMAP\r\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, 0.0, spotLight.shadowCameraParams, vSpotShadowCoord[ i ], 1 ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tDirectionalLight directionalLight;\r\n\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\r\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\r\n\r\n\t\t#ifdef USE_SHADOWMAP\r\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, 0.0, directionalLight.spreadAngle, directionalLight.shadowCameraParams, vDirectionalShadowCoord[ i ], 0 ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n\r\n\tRectAreaLight rectAreaLight;\r\n\r\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n\r\n\t\trectAreaLight = rectAreaLights[ i ];\r\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\r\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#ifdef USE_LIGHTMAP\r\n\r\n\t\t#if defined( TEXTURE_SLOTS )\r\n\t\t\tvec2 lightUv = lightMapUV();\r\n\t\t\tvec3 lightMapIrradiance = lightMapTexelTransform( texture2D( lightMap, vUv2 ) ).xyz;\r\n\t\t#else\r\n\t\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\t\t#endif\r\n\r\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\r\n\r\n\t\t#endif\r\n\r\n\t\tirradiance += lightMapIrradiance;\r\n\r\n\t#endif\r\n\r\n\t#if ( NUM_HEMI_LIGHTS > 0 )\r\n\r\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n\r\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\r\n\r\n\t\t// TODO, replace 8 with the real maxMIPLevel\r\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\r\n\r\n\t#endif\r\n\r\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\r\n\r\n#endif\r\n\r\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\r\n\r\n\t// TODO, replace 8 with the real maxMIPLevel\r\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\r\n\r\n\t#ifndef STANDARD\r\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\r\n\t#else\r\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\r\n\t#endif\r\n\r\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\r\n\r\n#endif\r\n";

		var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\r\n\r\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\r\n\r\n#endif\r\n";

		var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\r\n\r\n\tuniform float logDepthBufFC;\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tvarying float vFragDepth;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tvarying float vFragDepth;\r\n\r\n\t#endif\r\n\r\n\tuniform float logDepthBufFC;\r\n\r\n#endif\r\n";

		var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\r\n\r\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tvFragDepth = 1.0 + gl_Position.w;\r\n\r\n\t#else\r\n\r\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var map_fragment = "#ifdef USE_MAP\r\n\r\n#if defined( TEXTURE_SLOTS )\r\n\tvec2 mapUv = mapUV();\r\n#else\r\n\tvec2 mapUv = vUv;\r\n#endif\r\n\r\n\tvec4 texelColor = texture2D( map, mapUv );\r\n\r\n\ttexelColor = mapTexelTransform( mapTexelToLinear( texelColor ) );\r\n\tdiffuseColor *= texelColor;\r\n\r\n#endif\r\n";

		var map_pars_fragment = "#if ! defined( TEXTURE_SLOTS )\r\n\t#ifdef USE_MAP\r\n\r\n\t\tuniform sampler2D map;\r\n\r\n\t#endif\r\n#endif\r\n";

		var map_particle_fragment = "#ifdef USE_MAP\r\n\r\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\r\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\r\n\r\n#endif\r\n";

		var map_particle_pars_fragment = "#ifdef USE_MAP\r\n\r\n\tuniform vec4 offsetRepeat;\r\n\tuniform sampler2D map;\r\n\r\n#endif\r\n";

		var metalnessmap_fragment = "float metalnessFactor = metalness;\r\n\r\n#ifdef USE_METALNESSMAP\r\n\r\n\t#if defined( TEXTURE_SLOTS )\r\n\t\tvec2 metalnessUv = metalnessMapUV();\r\n\t#else\r\n\t\tvec2 metalnessUv = vUv;\r\n\t#endif\r\n\r\n\tvec4 texelMetalness = metalnessMapTexelTransform( texture2D( metalnessMap, metalnessUv ) );\r\n\tmetalnessFactor *= texelMetalness.r;\r\n\r\n#endif\r\n";

		var metalnessmap_pars_fragment = "#if ! defined( TEXTURE_SLOTS )\r\n\t#ifdef USE_METALNESSMAP\r\n\r\n\t\tuniform sampler2D metalnessMap;\r\n\r\n\t#endif\r\n#endif\r\n";

		var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\r\n\r\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\r\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\r\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\r\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\r\n\r\n#endif\r\n";

		var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\r\n\r\n\t#ifndef USE_MORPHNORMALS\r\n\r\n\tuniform float morphTargetInfluences[ 8 ];\r\n\r\n\t#else\r\n\r\n\tuniform float morphTargetInfluences[ 4 ];\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\r\n\r\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\r\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\r\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\r\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\r\n\r\n\t#ifndef USE_MORPHNORMALS\r\n\r\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\r\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\r\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\r\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var normal_flip = "#ifdef DOUBLE_SIDED\r\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\r\n#else\r\n\tfloat flipNormal = 1.0;\r\n#endif\r\n";

		var normal_fragment = "#ifdef FLAT_SHADED\r\n\r\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\r\n\r\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\r\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\r\n\tvec3 normal = normalize( cross( fdx, fdy ) );\r\n\r\n#else\r\n\r\n\tvec3 normal = normalize( vNormal ) * flipNormal;\r\n\r\n#endif\r\n\r\n#ifdef USE_NORMALMAP\r\n\r\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\r\n\r\n#elif defined( USE_BUMPMAP )\r\n\r\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\r\n\r\n#endif\r\n";

		var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\r\n\r\n\t#if ! defined( TEXTURE_SLOTS )\r\n\t\tuniform sampler2D normalMap;\r\n\t#endif\r\n\t\tuniform vec2 normalScale;\r\n\r\n\t// Per-Pixel Tangent Space Normal Mapping\r\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\r\n\r\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\r\n\r\n\t\t#if defined( TEXTURE_SLOTS )\r\n\t\t\tvec2 normalUv = normalMapUV();\r\n\t\t#else\r\n\t\t\tvec2 normalUv = vUv;\r\n\t\t#endif\r\n\r\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\r\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\r\n\t\tvec2 st0 = dFdx( normalUv.st );\r\n\t\tvec2 st1 = dFdy( normalUv.st );\r\n\r\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\r\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\r\n\t\tvec3 N = normalize( surf_norm );\r\n\r\n\t\tvec3 mapN = texture2D( normalMap, normalUv ).xyz * 2.0 - 1.0;\r\n\t\tmapN.xy = normalScale * mapN.xy;\r\n\t\tmat3 tsn = mat3( S, T, N );\r\n\t\treturn normalize( tsn * mapN );\r\n\r\n\t}\r\n\r\n#endif\r\n";

		var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\r\n  return normalize( normal ) * 0.5 + 0.5;\r\n}\r\n\r\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n  return 1.0 - 2.0 * rgb.xyz;\r\n}\r\n\r\n\r\n\r\nvec4 packDepthToRGBA( const in highp float v ) {\r\n\r\n  const highp vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\r\n  const highp vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\r\n  highp vec4 res = mod( v * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 ); // vec4 res = fract( depth * bit_shift );\",\r\n  res -= res.xxyz * bit_mask;\r\n  return res;\r\n\r\n\r\n\r\n\r\n}\r\n\r\nfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\r\n  const highp vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\r\n\treturn dot( v, bit_shift );\r\n\r\n  //return dot( v, UnpackFactors );\r\n\r\n}\r\n\r\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n  return ( viewZ + near ) / ( near - far );\r\n}\r\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n  return linearClipZ * ( near - far ) - near;\r\n}\r\n\r\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n}\r\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n}\r\n";

		var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\r\n\r\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\r\n\tgl_FragColor.rgb *= gl_FragColor.a;\r\n\r\n#endif\r\n";

		var project_vertex = "#ifdef USE_SKINNING\r\n\r\n\tvec4 mvPosition = modelViewMatrix * skinned;\r\n\r\n#else\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\r\n\r\n#endif\r\n\r\ngl_Position = projectionMatrix * mvPosition;\r\n";

		var roughnessmap_fragment = "float roughnessFactor = roughness;\r\n\r\n#ifdef USE_ROUGHNESSMAP\r\n\r\n\t#if defined( TEXTURE_SLOTS )\r\n\t\tvec2 roughnessUv = roughnessMapUV();\r\n\t#else\r\n\t\tvec2 roughnessUv = vUv;\r\n\t#endif\r\n\r\n\tvec4 texelRoughness = roughnessMapTexelTransform( texture2D( roughnessMap, roughnessUv ) );\r\n\troughnessFactor *= texelRoughness.r;\r\n\r\n#endif\r\n";

		var roughnessmap_pars_fragment = "#if ! defined( TEXTURE_SLOTS )\r\n\t#ifdef USE_ROUGHNESSMAP\r\n\r\n\t\tuniform sampler2D roughnessMap;\r\n\r\n\t#endif\r\n#endif\r\n";

		var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\r\n\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\r\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\r\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\r\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\r\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\r\n\t#if defined( SHADOWMAP_TYPE_PCSS )\r\n\t\t#define PCSS_QUALITY_LEVEL 5\r\n\t\t#define PCSS_NUM_POISSON_SAMPLES 16\r\n\t\t#define PCSS_ROTATE_POISSON_SAMPLES 1\r\n\r\n\t\tvec2 poissonDisk[PCSS_NUM_POISSON_SAMPLES];\r\n\r\n\t\tvoid initPercentCloserSoftShadow( const in vec2 randomSeed )\t{\r\n\r\n\t\t\tpoissonDisk[0] = vec2(-0.94201624, -0.39906216 );\r\n\t\t\tpoissonDisk[1] = vec2( 0.94558609, -0.76890725 );\r\n\t\t\tpoissonDisk[2] = vec2( -0.094184101, -0.92938870 );\r\n\t\t\tpoissonDisk[3] = vec2( 0.34495938, 0.29387760 );\r\n\t\t\tpoissonDisk[4] = vec2( -0.91588581, 0.45771432 );\r\n\t\t\tpoissonDisk[5] = vec2( -0.81544232, -0.87912464 );\r\n\t\t\tpoissonDisk[6] = vec2( -0.38277543, 0.27676845 );\r\n\t\t\tpoissonDisk[7] = vec2( 0.97484398, 0.75648379 );\r\n\t\t\tpoissonDisk[8] = vec2( 0.44323325, -0.97511554 );\r\n\t\t\tpoissonDisk[9] = vec2( 0.53742981, -0.47373420 );\r\n\t\t\tpoissonDisk[10] = vec2( -0.26496911, -0.41893023 );\r\n\t\t\tpoissonDisk[11] = vec2( 0.79197514, 0.19090188 );\r\n\t\t\tpoissonDisk[12] = vec2( -0.24188840, 0.99706507 );\r\n\t\t\tpoissonDisk[13] = vec2( -0.81409955, 0.91437590 );\r\n\t\t\tpoissonDisk[14] = vec2( 0.19984126, 0.78641367 );\r\n\t\t\tpoissonDisk[15] = vec2( 0.14383161, -0.14100790 );\r\n\t\t}\r\n\r\n\t\tmat2 createRotationMatrix( const in vec2 randomSeed ) {\r\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\r\n\t\t\tfloat c = cos( angle ), s = sin( angle );\r\n\t\t\treturn mat2( c, s, -s, c );\r\n\t\t}\r\n\r\n\t\tfloat penumbraSize( const in float zReceiverLightSpace, const in float zBlockerLightSpace ) { // Parallel plane estimation\r\n\t\t\treturn (zReceiverLightSpace - zBlockerLightSpace) / zBlockerLightSpace;\r\n\t\t}\r\n\r\n\t\tfloat findBlockerLightZ( sampler2D shadowMap, const in vec2 uv, const in float zReceiverClipSpace, const in float zReceiverLightSpace, const in float shadowRadius, const in float spreadAngle, const in vec3 shadowCameraParams, const in vec2 randomSeed, const int lightType ) {\r\n\t\t\t// This uses similar triangles to compute what\r\n\t\t\t// area of the shadow map we should search\r\n\t\t\tfloat lightFrustrumWidth = 2.0 * shadowCameraParams.y * tan(shadowCameraParams.x * 0.5);\r\n\t\t\tfloat searchRadius = 0.0;\r\n\t\t\tsearchRadius = ( lightType == 0) ? zReceiverLightSpace * spreadAngle/shadowCameraParams.x : ( shadowRadius / lightFrustrumWidth ) * ( zReceiverLightSpace - shadowCameraParams.y ) / zReceiverLightSpace;\r\n\t\t\tfloat blockerLightZSum = 0.0;\r\n\t\t\tint numBlockers = 0;\r\n\r\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\r\n\t\t\tfloat s = sin(angle);\r\n\t\t\tfloat c = cos(angle);\r\n\t\t\tfor( int i = 0; i < PCSS_NUM_POISSON_SAMPLES; i++ ) {\r\n\t\t\t#if PCSS_ROTATE_POISSON_SAMPLES == 1\r\n\t\t\t\tvec2 poissonSample = vec2(poissonDisk[i].y * c + poissonDisk[i].x * s, poissonDisk[i].y * -s + poissonDisk[i].x * c);\r\n\t\t\t#else\r\n\t\t\t\tvec2 poissonSample = poissonDisk[i];\r\n\t\t\t#endif\r\n\t\t\t\tfloat shadowMapDepth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonSample * searchRadius ) );\r\n\t\t\t\tif ( shadowMapDepth < zReceiverClipSpace ) {\r\n\t\t\t\t\tblockerLightZSum += shadowMapDepth;\r\n\t\t\t\t\tnumBlockers ++;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif( numBlockers == 0 ) return -1.0;\r\n\r\n\t\t\treturn blockerLightZSum / float( numBlockers );\r\n\t\t}\r\n\r\n\t\tfloat percentCloserFilter( sampler2D shadowMap, vec2 uv, float receiverClipZ, float filterRadius, const in vec2 randomSeed ) {\r\n\t\t\tint numBlockers = 0;\r\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\r\n\t\t\tfloat s = sin(angle);\r\n\t\t\tfloat c = cos(angle);\r\n\r\n\t\t\tfor( int i = 0; i < PCSS_NUM_POISSON_SAMPLES; i ++ ) {\r\n\t\t\t#if PCSS_ROTATE_POISSON_SAMPLES == 1\r\n\t\t\t\tvec2 poissonSample = vec2(poissonDisk[i].y * c + poissonDisk[i].x * s, poissonDisk[i].y * -s + poissonDisk[i].x * c);\r\n\t\t\t#else\r\n\t\t\t\tvec2 poissonSample = poissonDisk[i];\r\n\t\t\t#endif\r\n\t\t\t\tvec2 uvOffset = poissonSample * filterRadius;\r\n\r\n\t\t\t\tfloat blockerClipZ = unpackRGBAToDepth( texture2D( shadowMap, uv + uvOffset ) );\r\n\t\t\t\tif( receiverClipZ <= blockerClipZ ) numBlockers ++;\r\n\r\n\t\t\t\tblockerClipZ = unpackRGBAToDepth( texture2D( shadowMap, uv - uvOffset ) );\r\n\t\t\t\tif( receiverClipZ <= blockerClipZ ) numBlockers ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn float( numBlockers ) / ( 2.0 * float( PCSS_NUM_POISSON_SAMPLES ) );\r\n\t\t}\r\n\r\n\t\tfloat percentCloserSoftShadow( sampler2D shadowMap, const in float shadowRadius, const in float spreadAngle, const in vec3 shadowCameraParams, const in vec4 coords, const int lightType ) {\r\n\r\n\t\t\tvec2 uv = coords.xy;\r\n\t\t\tfloat receiverLightZ = coords.z;\r\n\t\t\tfloat cameraNear = shadowCameraParams.y, cameraFar = shadowCameraParams.z;\r\n\t\t\tfloat zReceiverLightSpace;\r\n\t\t\tif(lightType == 0)\r\n\t\t\t\tzReceiverLightSpace = -orthographicDepthToViewZ( receiverLightZ, cameraNear, cameraFar );\r\n\t\t\telse\r\n\t\t\t\tzReceiverLightSpace = -perspectiveDepthToViewZ( receiverLightZ, cameraNear, cameraFar );\r\n\r\n\t\t\t// STEP 1: blocker search\r\n\t\t\tfloat blockerLightZ = findBlockerLightZ( shadowMap, uv, receiverLightZ, zReceiverLightSpace, shadowRadius, spreadAngle, shadowCameraParams, uv, lightType );\r\n\r\n\t\t\t//There are no occluders so early out (this saves filtering)\r\n\t\t\tif( blockerLightZ == -1.0 ) return 1.0;\r\n\r\n\t\t\tfloat avgBlockerDepthLightSpace;\r\n\t\t\tfloat filterRadius = 0.0;\r\n\r\n\t\t\t// STEP 2: penumbra size\r\n\t\t\tif(lightType == 0) {\r\n\t\t\t\tavgBlockerDepthLightSpace = -orthographicDepthToViewZ( blockerLightZ, cameraNear, cameraFar );\r\n\t\t\t\tfilterRadius = (zReceiverLightSpace - avgBlockerDepthLightSpace) * spreadAngle/shadowCameraParams.x;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tavgBlockerDepthLightSpace = -perspectiveDepthToViewZ( blockerLightZ, cameraNear, cameraFar );\r\n\t\t\t\tfloat penumbraRatio = penumbraSize( zReceiverLightSpace, avgBlockerDepthLightSpace );\r\n\t\t\t\tfloat lightFrustrumWidth = 2.0 * cameraNear * tan(shadowCameraParams.x * 0.5);\r\n\t\t\t\tfilterRadius = penumbraRatio * ( shadowRadius/lightFrustrumWidth ) * cameraNear / zReceiverLightSpace;\r\n\t\t\t}\r\n\t\t\t// STEP 3: filtering\r\n\t\t\treturn percentCloserFilter( shadowMap, uv, receiverLightZ, filterRadius, uv );\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n    #if NUM_RECT_AREA_LIGHTS > 0\r\n        // TODO (abelnation): create uniforms for area light shadows\r\n    #endif\r\n\r\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r\n\r\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t}\r\n\r\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\tfloat a = mix( lb, lt, f.y );\r\n\t\tfloat b = mix( rb, rt, f.y );\r\n\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\treturn c;\r\n\r\n\t}\r\n\r\n\tvoid initShadows() {\r\n\r\n\t\t#if defined( SHADOWMAP_TYPE_PCSS )\r\n\r\n\t\t  initPercentCloserSoftShadow( vViewPosition.xy );\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, float spreadAngle, vec3 shadowCameraParams, vec4 shadowCoord, const int lightType ) {\r\n\r\n\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\tif ( frustumTest ) {\r\n\r\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\treturn (\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\treturn (\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t#elif defined( SHADOWMAP_TYPE_PCSS )\r\n\r\n\t\t  return percentCloserSoftShadow( shadowMap, shadowRadius, spreadAngle, shadowCameraParams, shadowCoord, lightType );\r\n\r\n\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t#endif\r\n\r\n\t\t}\r\n\r\n\t\treturn 1.0;\r\n\r\n\t}\r\n\r\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\r\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\r\n\t// 2D texture:\r\n\t//\r\n\t// xzXZ\r\n\t//  y Y\r\n\t//\r\n\t// Y - Positive y direction\r\n\t// y - Negative y direction\r\n\t// X - Positive x direction\r\n\t// x - Negative x direction\r\n\t// Z - Positive z direction\r\n\t// z - Negative z direction\r\n\t//\r\n\t// Source and test bed:\r\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\r\n\r\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\r\n\r\n\t\t// Number of texels to avoid at the edge of each square\r\n\r\n\t\tvec3 absV = abs( v );\r\n\r\n\t\t// Intersect unit cube\r\n\r\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\r\n\t\tabsV *= scaleToCube;\r\n\r\n\t\t// Apply scale to avoid seams\r\n\r\n\t\t// two texels less per square (one texel will do for NEAREST)\r\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\r\n\r\n\t\t// Unwrap\r\n\r\n\t\t// space: -1 ... 1 range for each square\r\n\t\t//\r\n\t\t// #X##\t\tdim    := ( 4 , 2 )\r\n\t\t//  # #\t\tcenter := ( 1 , 1 )\r\n\r\n\t\tvec2 planar = v.xy;\r\n\r\n\t\tfloat almostATexel = 1.5 * texelSizeY;\r\n\t\tfloat almostOne = 1.0 - almostATexel;\r\n\r\n\t\tif ( absV.z >= almostOne ) {\r\n\r\n\t\t\tif ( v.z > 0.0 )\r\n\t\t\t\tplanar.x = 4.0 - v.x;\r\n\r\n\t\t} else if ( absV.x >= almostOne ) {\r\n\r\n\t\t\tfloat signX = sign( v.x );\r\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\r\n\r\n\t\t} else if ( absV.y >= almostOne ) {\r\n\r\n\t\t\tfloat signY = sign( v.y );\r\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\r\n\t\t\tplanar.y = v.z * signY - 2.0;\r\n\r\n\t\t}\r\n\r\n\t\t// Transform to UV space\r\n\r\n\t\t// scale := 0.5 / dim\r\n\t\t// translate := ( center + 0.5 ) / dim\r\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\r\n\r\n\t}\r\n\r\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\r\n\r\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\r\n\t\t// the distance from the light to the world-space position of the fragment.\r\n\t\tvec3 lightToPosition = shadowCoord.xyz;\r\n\r\n\t\t// bd3D = base direction 3D\r\n\t\tvec3 bd3D = normalize( lightToPosition );\r\n\t\t// dp = distance from light to fragment position\r\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\r\n\r\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\r\n\r\n\t\t\treturn (\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\r\n\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t#else // no percentage-closer filtering\r\n\r\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n#endif\r\n";

		var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\r\n\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\r\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\r\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\r\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\r\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n    #if NUM_RECT_AREA_LIGHTS > 0\r\n\r\n        // TODO (abelnation): uniforms for area light shadows\r\n\r\n    #endif\r\n\r\n#endif\r\n";

		var shadowmap_vertex = "#ifdef USE_SHADOWMAP\r\n\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n    #if NUM_RECT_AREA_LIGHTS > 0\r\n\r\n    // TODO (abelnation): update vAreaShadowCoord with area light info\r\n\r\n    #endif\r\n\r\n#endif\r\n";

		var shadowmask_pars_fragment = "float getShadowMask() {\r\n\r\n\tfloat shadow = 1.0;\r\n\r\n\t#ifdef USE_SHADOWMAP\r\n\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\r\n\tDirectionalLight directionalLight;\r\n\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, 0.0, directionalLight.spreadAngle, directionalLight.shadowCameraParams, vDirectionalShadowCoord[ i ], 0 ) : 1.0;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\r\n\tSpotLight spotLight;\r\n\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tspotLight = spotLights[ i ];\r\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, 0.0, spotLight.shadowCameraParams, vSpotShadowCoord[ i ], 1 ) : 1.0;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\r\n\tPointLight pointLight;\r\n\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tpointLight = pointLights[ i ];\r\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\t#if NUM_RECT_AREA_LIGHTS > 0\r\n\r\n\t// TODO (abelnation): update shadow for Area light\r\n\r\n\t#endif\r\n\r\n\t#endif\r\n\r\n\treturn shadow;\r\n\r\n}\r\n";

		var skinbase_vertex = "#ifdef USE_SKINNING\r\n\r\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\r\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\r\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\r\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\r\n\r\n#endif\r\n";

		var skinning_pars_vertex = "#ifdef USE_SKINNING\r\n\r\n\tuniform mat4 bindMatrix;\r\n\tuniform mat4 bindMatrixInverse;\r\n\r\n\t#ifdef BONE_TEXTURE\r\n\r\n\t\tuniform sampler2D boneTexture;\r\n\t\tuniform int boneTextureWidth;\r\n\t\tuniform int boneTextureHeight;\r\n\r\n\t\tmat4 getBoneMatrix( const in float i ) {\r\n\r\n\t\t\tfloat j = i * 4.0;\r\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\r\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\r\n\r\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\r\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\r\n\r\n\t\t\ty = dy * ( y + 0.5 );\r\n\r\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\r\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\r\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\r\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\r\n\r\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\r\n\r\n\t\t\treturn bone;\r\n\r\n\t\t}\r\n\r\n\t#else\r\n\r\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\r\n\r\n\t\tmat4 getBoneMatrix( const in float i ) {\r\n\r\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\r\n\t\t\treturn bone;\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var skinning_vertex = "#ifdef USE_SKINNING\r\n\r\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\r\n\r\n\tvec4 skinned = vec4( 0.0 );\r\n\tskinned += boneMatX * skinVertex * skinWeight.x;\r\n\tskinned += boneMatY * skinVertex * skinWeight.y;\r\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\r\n\tskinned += boneMatW * skinVertex * skinWeight.w;\r\n\tskinned  = bindMatrixInverse * skinned;\r\n\r\n#endif\r\n";

		var skinnormal_vertex = "#ifdef USE_SKINNING\r\n\r\n\tmat4 skinMatrix = mat4( 0.0 );\r\n\tskinMatrix += skinWeight.x * boneMatX;\r\n\tskinMatrix += skinWeight.y * boneMatY;\r\n\tskinMatrix += skinWeight.z * boneMatZ;\r\n\tskinMatrix += skinWeight.w * boneMatW;\r\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\r\n\r\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\r\n\r\n#endif\r\n";

		var slot_texel_transform_template = "uniform vec2 $SLOT_NAME$TexelTransformParams;\r\n\r\nvec4 $SLOT_NAME$TexelTransform( vec4 value ) {\r\n    value.rgb *= $SLOT_NAME$TexelTransformParams.x;\r\n    value.rgb += vec3( $SLOT_NAME$TexelTransformParams.y );\r\n    return value;\r\n}\r\n";

		var slot_uv_transform_template = "uniform vec4 $SLOT_NAME$UVTransformParams;\r\n\r\nvec2 $SLOT_NAME$UV() {\r\n  vec2 value = $UV_VAR_NAME$;\r\n  value.xy *= $SLOT_NAME$UVTransformParams.xy;\r\n  value.xy += $SLOT_NAME$UVTransformParams.zw;\r\n  return value;\r\n}\r\n";

		var specularmap_fragment = "float specularStrength;\r\n\r\n#ifdef USE_SPECULARMAP\r\n\r\n\t#if defined( TEXTURE_SLOTS )\r\n\t\tvec2 specularUv = specularMapUV();\r\n\t#else\r\n\t\tvec2 specularUv = vUv;\r\n\t#endif\r\n\r\n\tvec4 texelSpecular = specularMapTexelTransform( texture2D( specularMap, specularUv ) );\r\n\tspecularStrength = texelSpecular.r;\r\n\r\n#else\r\n\r\n\tspecularStrength = 1.0;\r\n\r\n#endif\r\n";

		var specularmap_pars_fragment = "#if ! defined( TEXTURE_SLOTS )\r\n\t#ifdef USE_SPECULARMAP\r\n\r\n\t\tuniform sampler2D specularMap;\r\n\r\n\t#endif\r\n#endif\r\n";

		var tonemapping_fragment = "#if defined( TONE_MAPPING )\r\n\r\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\r\n\r\n#endif\r\n";

		var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\nuniform float toneMappingExposure;\r\nuniform float toneMappingWhitePoint;\r\n\r\n// exposure only\r\nvec3 LinearToneMapping( vec3 color ) {\r\n\r\n  return toneMappingExposure * color;\r\n\r\n}\r\n\r\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\r\nvec3 ReinhardToneMapping( vec3 color ) {\r\n\r\n  color *= toneMappingExposure;\r\n  return saturate( color / ( vec3( 1.0 ) + color ) );\r\n\r\n}\r\n\r\n// source: http://filmicgames.com/archives/75\r\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\r\nvec3 Uncharted2ToneMapping( vec3 color ) {\r\n\r\n  // John Hable's filmic operator from Uncharted 2 video game\r\n  color *= toneMappingExposure;\r\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\r\n\r\n}\r\n\r\n// source: http://filmicgames.com/archives/75\r\nvec3 OptimizedCineonToneMapping( vec3 color ) {\r\n\r\n  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n  color *= toneMappingExposure;\r\n  color = max( vec3( 0.0 ), color - 0.004 );\r\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\r\n\r\n}\r\n";

		var uv_pars_fragment = "#if ! defined( TEXTURE_SLOTS )\r\n\r\n\t#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_FALLOFFALPHAMAP )\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )  || defined( USE_FALLOFFMAP ) || defined( USE_FALLOFFALPHAMAP )\r\n\r\n\tvarying vec2 vUv;\r\n\tuniform vec4 offsetRepeat;\r\n\r\n#endif\r\n";

		var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_FALLOFFALPHAMAP )\r\n\r\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\r\n\r\n#endif\r\n";

		var uv2_pars_fragment = "#if ! defined( TEXTURE_SLOTS )\r\n\t#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n\r\n\t\tvarying vec2 vUv2;\r\n\r\n\t#endif\r\n#endif\r\n";

		var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n\r\n\tattribute vec2 uv2;\r\n\tvarying vec2 vUv2;\r\n\r\n#endif\r\n";

		var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n\r\n\tvUv2 = uv2;\r\n\r\n#endif\r\n";

		var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\r\n\r\n\t#ifdef USE_SKINNING\r\n\r\n\t\tvec4 worldPosition = modelMatrix * skinned;\r\n\r\n\t#else\r\n\r\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

		var cube_frag = "uniform samplerCube tCube;\r\nuniform float tFlip;\r\nuniform float opacity;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\r\n\tgl_FragColor.a *= opacity;\r\n\r\n}\r\n";

		var cube_vert = "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n}\r\n";

		var cubeEnv_frag = "uniform float tFlip;\r\nuniform float opacity;\r\nuniform float roughness;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <cube_uv_reflection_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 queryReflectVec = vec3( tFlip * vWorldPosition.x, vWorldPosition.yz );\r\n\r\n\tvec4 envMapColor = vec4( 0.0 );\r\n\r\n\t#if defined( ENVMAP_TYPE_CUBE )\r\n\r\n\t\t#ifdef TEXTURE_LOD_EXT\r\n\r\n\t\t\tenvMapColor = textureCubeLodEXT( envMap, queryReflectVec, roughness * 8.0 );\r\n\r\n\t\t#else\r\n\r\n\t\t\tenvMapColor = textureCube( envMap, queryReflectVec, roughness * 8.0 );\r\n\r\n\t\t#endif\r\n\r\n\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\tenvMapColor.rgb *= envMapIntensity;\r\n\r\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\r\n\t\tenvMapColor = textureCubeUV( queryReflectVec, roughness );\r\n\t\tenvMapColor.rgb *= envMapIntensity;\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = envMapColor;\r\n\tgl_FragColor.a = opacity;\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <logdepthbuf_fragment>\r\n\r\n}\r\n";

		var cubeEnv_vert = "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <clipping_planes_pars_vertex>\r\n\r\n#if NUM_CLIPPING_PLANES == 0\r\n\t#if ! defined( VARYING_VVIEWPOSITION )\r\n   \t\tvarying vec3 vViewPosition;\r\n   \t\t#define VARYING_VVIEWPOSITION 1\r\n   #endif\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n}\r\n";

		var depth_frag = "precision highp float;\r\n\r\n#if DEPTH_PACKING == 3200\r\n\r\n\tuniform float opacity;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tdiffuseColor.a = opacity;\r\n\r\n\t#endif\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\r\n\r\n\t#elif DEPTH_PACKING == 3201\r\n\r\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\r\n\r\n\t#endif\r\n\r\n}\r\n";

		var depth_vert = "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n";

		var distanceRGBA_frag = "uniform vec3 lightPos;\r\nvarying vec4 vWorldPosition;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main () {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\r\n\r\n}\r\n";

		var distanceRGBA_vert = "varying vec4 vWorldPosition;\r\n\r\n#include <common>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <skinbase_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvWorldPosition = worldPosition;\r\n\r\n}\r\n";

		var equirect_frag = "uniform sampler2D tEquirect;\r\nuniform float tFlip;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\t// \tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\r\n\tvec3 direction = normalize( vWorldPosition );\r\n\tvec2 sampleUV;\r\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\r\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\r\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\r\n\r\n}\r\n";

		var equirect_vert = "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n}\r\n";

		var linedashed_frag = "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform float dashSize;\r\nuniform float totalSize;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb; // simple shader\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

		var linedashed_vert = "uniform float scale;\r\nattribute float lineDistance;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\r\n\tvLineDistance = scale * lineDistance;\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n";

		var meshbasic_frag = "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\r\n\t// accumulation (baked indirect lighting only)\r\n\t#ifdef USE_LIGHTMAP\r\n\r\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\r\n\r\n\t#endif\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\r\n\r\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\r\n\r\n\t#include <normal_flip>\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

		var meshbasic_vert = "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_ENVMAP\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <envmap_vertex>\r\n\r\n}\r\n";

		var meshlambert_frag = "uniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float opacity;\r\n\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars>\r\n#include <fog_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#include <lightmap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n\r\n\t#ifdef DOUBLE_SIDED\r\n\r\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.directDiffuse = vLightFront;\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n\r\n\t#include <normal_flip>\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

		var meshlambert_vert = "#define LAMBERT\r\n\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <bsdfs>\r\n#include <lights_pars>\r\n#include <color_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <lights_lambert_vertex>\r\n\t#include <shadowmap_vertex>\r\n\r\n}\r\n";

		var meshphong_frag = "#define PHONG\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <gradientmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars>\r\n#include <lights_phong_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <normal_flip>\r\n\t#include <normal_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_phong_fragment>\r\n\t#include <lights_template>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

		var meshphong_vert = "#define PHONG\r\n\r\n#if ! defined( VARYING_VVIEWPOSITION )\r\n\tvarying vec3 vViewPosition;\r\n\t#define VARYING_VVIEWPOSITION 1\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <shadowmap_vertex>\r\n\r\n}\r\n";

		var meshphysical_frag = "precision highp float;\r\n#define PHYSICAL\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n\r\n#ifndef STANDARD\r\n\tuniform float clearCoat;\r\n\tuniform float clearCoatRoughness;\r\n\r\n\t#ifdef FALLOFF\r\n\t\tuniform vec3 falloffDiffuse;\r\n\t\tuniform float falloffOpacity;\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if ! defined( VARYING_VVIEWPOSITION )\r\n\tvarying vec3 vViewPosition;\r\n\t#define VARYING_VVIEWPOSITION 1\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <lights_pars>\r\n#include <lights_physical_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#ifdef FALLOFF\r\n\t\tvec4 falloffDiffuseColor = vec4( falloffDiffuse, falloffOpacity );\r\n\t#endif\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\r\n\t#include <falloffmap_fragment>\r\n\t#include <falloffalphamap_fragment>\r\n\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_flip>\r\n\t#include <normal_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t#include <falloff_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_template>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

		var meshphysical_vert = "#define PHYSICAL\r\n\r\n#if ! defined( VARYING_VVIEWPOSITION )\r\n\tvarying vec3 vViewPosition;\r\n\t#define VARYING_VVIEWPOSITION 1\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\r\n}\r\n";

		var normal_frag = "#define NORMAL\r\n\r\nuniform float opacity;\r\n\r\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\r\n\r\n\t#if ! defined( VARYING_VVIEWPOSITION )\r\n\t\tvarying vec3 vViewPosition;\r\n\t\t#define VARYING_VVIEWPOSITION 1\r\n\t#endif\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\t#include <normal_flip>\r\n\t#include <normal_fragment>\r\n\r\n   \tgl_FragColor = vec4( packNormalToRGB( vNormal * flipNormal ), opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\r\n}\r\n";

		var normal_vert = "#define NORMAL\r\n\r\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\r\n\r\n\t#if ! defined( VARYING_VVIEWPOSITION )\r\n   \t\tvarying vec3 vViewPosition;\r\n   \t\t#define VARYING_VVIEWPOSITION 1\r\n   #endif\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\t\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n#endif\r\n\r\n}\r\n";

		var points_frag = "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <color_pars_fragment>\r\n#include <map_particle_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_particle_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

		var points_vert = "uniform float size;\r\nuniform float scale;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n\t#ifdef USE_SIZEATTENUATION\r\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\r\n\t#else\r\n\t\tgl_PointSize = size;\r\n\t#endif\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\r\n}\r\n";

		var shadow_frag = "uniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <bsdfs>\r\n#include <lights_pars>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\r\n\r\n}\r\n";

		var shadow_vert = "#include <shadowmap_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\r\n}\r\n";

		var ShaderChunk = {
			alphamap_fragment: alphamap_fragment,
			alphamap_pars_fragment: alphamap_pars_fragment,
			alphatest_fragment: alphatest_fragment,
			aomap_fragment: aomap_fragment,
			aomap_pars_fragment: aomap_pars_fragment,
			begin_vertex: begin_vertex,
			beginnormal_vertex: beginnormal_vertex,
			bsdfs: bsdfs,
			bumpmap_pars_fragment: bumpmap_pars_fragment,
			clipping_planes_fragment: clipping_planes_fragment,
			clipping_planes_pars_fragment: clipping_planes_pars_fragment,
			clipping_planes_pars_vertex: clipping_planes_pars_vertex,
			clipping_planes_vertex: clipping_planes_vertex,
			color_fragment: color_fragment,
			color_pars_fragment: color_pars_fragment,
			color_pars_vertex: color_pars_vertex,
			color_vertex: color_vertex,
			common: common,
			cube_uv_reflection_fragment: cube_uv_reflection_fragment,
			defaultnormal_vertex: defaultnormal_vertex,
			displacementmap_pars_vertex: displacementmap_pars_vertex,
			displacementmap_vertex: displacementmap_vertex,
			emissivemap_fragment: emissivemap_fragment,
			emissivemap_pars_fragment: emissivemap_pars_fragment,
			encodings_fragment: encodings_fragment,
			encodings_pars_fragment: encodings_pars_fragment,
			envmap_fragment: envmap_fragment,
			envmap_pars_fragment: envmap_pars_fragment,
			envmap_pars_vertex: envmap_pars_vertex,
			envmap_vertex: envmap_vertex,
			falloff_fragment: falloff_fragment,
			falloffalphamap_fragment: falloffalphamap_fragment,
			falloffmap_fragment: falloffmap_fragment,
			fog_fragment: fog_fragment,
			fog_pars_fragment: fog_pars_fragment,
			gradientmap_pars_fragment: gradientmap_pars_fragment,
			lightmap_fragment: lightmap_fragment,
			lightmap_pars_fragment: lightmap_pars_fragment,
			lights_lambert_vertex: lights_lambert_vertex,
			lights_pars: lights_pars,
			lights_phong_fragment: lights_phong_fragment,
			lights_phong_pars_fragment: lights_phong_pars_fragment,
			lights_physical_fragment: lights_physical_fragment,
			lights_physical_pars_fragment: lights_physical_pars_fragment,
			lights_template: lights_template,
			logdepthbuf_fragment: logdepthbuf_fragment,
			logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
			logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
			logdepthbuf_vertex: logdepthbuf_vertex,
			map_fragment: map_fragment,
			map_pars_fragment: map_pars_fragment,
			map_particle_fragment: map_particle_fragment,
			map_particle_pars_fragment: map_particle_pars_fragment,
			metalnessmap_fragment: metalnessmap_fragment,
			metalnessmap_pars_fragment: metalnessmap_pars_fragment,
			morphnormal_vertex: morphnormal_vertex,
			morphtarget_pars_vertex: morphtarget_pars_vertex,
			morphtarget_vertex: morphtarget_vertex,
			normal_flip: normal_flip,
			normal_fragment: normal_fragment,
			normalmap_pars_fragment: normalmap_pars_fragment,
			packing: packing,
			premultiplied_alpha_fragment: premultiplied_alpha_fragment,
			project_vertex: project_vertex,
			roughnessmap_fragment: roughnessmap_fragment,
			roughnessmap_pars_fragment: roughnessmap_pars_fragment,
			shadowmap_pars_fragment: shadowmap_pars_fragment,
			shadowmap_pars_vertex: shadowmap_pars_vertex,
			shadowmap_vertex: shadowmap_vertex,
			shadowmask_pars_fragment: shadowmask_pars_fragment,
			skinbase_vertex: skinbase_vertex,
			skinning_pars_vertex: skinning_pars_vertex,
			skinning_vertex: skinning_vertex,
			skinnormal_vertex: skinnormal_vertex,
			slot_texel_transform_template: slot_texel_transform_template,
			slot_uv_transform_template: slot_uv_transform_template,
			specularmap_fragment: specularmap_fragment,
			specularmap_pars_fragment: specularmap_pars_fragment,
			tonemapping_fragment: tonemapping_fragment,
			tonemapping_pars_fragment: tonemapping_pars_fragment,
			uv_pars_fragment: uv_pars_fragment,
			uv_pars_vertex: uv_pars_vertex,
			uv_vertex: uv_vertex,
			uv2_pars_fragment: uv2_pars_fragment,
			uv2_pars_vertex: uv2_pars_vertex,
			uv2_vertex: uv2_vertex,
			worldpos_vertex: worldpos_vertex,

			cube_frag: cube_frag,
			cube_vert: cube_vert,
			cubeEnv_frag: cubeEnv_frag,
			cubeEnv_vert: cubeEnv_vert,
			depth_frag: depth_frag,
			depth_vert: depth_vert,
			distanceRGBA_frag: distanceRGBA_frag,
			distanceRGBA_vert: distanceRGBA_vert,
			equirect_frag: equirect_frag,
			equirect_vert: equirect_vert,
			linedashed_frag: linedashed_frag,
			linedashed_vert: linedashed_vert,
			meshbasic_frag: meshbasic_frag,
			meshbasic_vert: meshbasic_vert,
			meshlambert_frag: meshlambert_frag,
			meshlambert_vert: meshlambert_vert,
			meshphong_frag: meshphong_frag,
			meshphong_vert: meshphong_vert,
			meshphysical_frag: meshphysical_frag,
			meshphysical_vert: meshphysical_vert,
			normal_frag: normal_frag,
			normal_vert: normal_vert,
			points_frag: points_frag,
			points_vert: points_vert,
			shadow_frag: shadow_frag,
			shadow_vert: shadow_vert
		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Color( r, g, b ) {

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string
				return this.set( r );

			}

			return this.setRGB( r, g, b );

		}

		Color.prototype = {

			constructor: Color,

			isColor: true,

			r: 1, g: 1, b: 1,

			set: function ( value ) {

				if ( value && value.isColor ) {

					this.copy( value );

				} else if ( typeof value === 'number' ) {

					this.setHex( value );

				} else if ( typeof value === 'string' ) {

					this.setStyle( value );

				}

				return this;

			},

			setScalar: function ( scalar ) {

				this.r = scalar;
				this.g = scalar;
				this.b = scalar;

				return this;

			},

			setHex: function ( hex ) {

				hex = Math.floor( hex );

				this.r = ( hex >> 16 & 255 ) / 255;
				this.g = ( hex >> 8 & 255 ) / 255;
				this.b = ( hex & 255 ) / 255;

				return this;

			},

			setRGB: function ( r, g, b ) {

				this.r = r;
				this.g = g;
				this.b = b;

				return this;

			},

			setHSL: function () {

				function hue2rgb( p, q, t ) {

					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;

				}

				return function setHSL( h, s, l ) {

					// h,s,l ranges are in 0.0 - 1.0
					h = _Math.euclideanModulo( h, 1 );
					s = _Math.clamp( s, 0, 1 );
					l = _Math.clamp( l, 0, 1 );

					if ( s === 0 ) {

						this.r = this.g = this.b = l;

					} else {

						var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
						var q = ( 2 * l ) - p;

						this.r = hue2rgb( q, p, h + 1 / 3 );
						this.g = hue2rgb( q, p, h );
						this.b = hue2rgb( q, p, h - 1 / 3 );

					}

					return this;

				};

			}(),

			setStyle: function ( style ) {

				function handleAlpha( string ) {

					if ( string === undefined ) return;

					if ( parseFloat( string ) < 1 ) {

						console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

					}

				}


				var m;

				if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

					// rgb / hsl

					var color;
					var name = m[ 1 ];
					var components = m[ 2 ];

					switch ( name ) {

						case 'rgb':
						case 'rgba':

							if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// rgb(255,0,0) rgba(255,0,0,0.5)
								this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
								this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
								this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

								handleAlpha( color[ 5 ] );

								return this;

							}

							if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
								this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
								this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
								this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

								handleAlpha( color[ 5 ] );

								return this;

							}

							break;

						case 'hsl':
						case 'hsla':

							if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
								var h = parseFloat( color[ 1 ] ) / 360;
								var s = parseInt( color[ 2 ], 10 ) / 100;
								var l = parseInt( color[ 3 ], 10 ) / 100;

								handleAlpha( color[ 5 ] );

								return this.setHSL( h, s, l );

							}

							break;

					}

				} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

					// hex color

					var hex = m[ 1 ];
					var size = hex.length;

					if ( size === 3 ) {

						// #ff0
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

						return this;

					} else if ( size === 6 ) {

						// #ff0000
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

						return this;

					}

				}

				if ( style && style.length > 0 ) {

					// color keywords
					var hex = ColorKeywords[ style ];

					if ( hex !== undefined ) {

						// red
						this.setHex( hex );

					} else {

						// unknown color
						console.warn( 'THREE.Color: Unknown color ' + style );

					}

				}

				return this;

			},

			clone: function () {

				return new this.constructor( this.r, this.g, this.b );

			},

			copy: function ( color ) {

				this.r = color.r;
				this.g = color.g;
				this.b = color.b;

				return this;

			},

			copyGammaToLinear: function ( color, gammaFactor ) {

				if ( gammaFactor === undefined ) gammaFactor = 2.0;

				this.r = Math.pow( color.r, gammaFactor );
				this.g = Math.pow( color.g, gammaFactor );
				this.b = Math.pow( color.b, gammaFactor );

				return this;

			},

			copyLinearToGamma: function ( color, gammaFactor ) {

				if ( gammaFactor === undefined ) gammaFactor = 2.0;

				var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

				this.r = Math.pow( color.r, safeInverse );
				this.g = Math.pow( color.g, safeInverse );
				this.b = Math.pow( color.b, safeInverse );

				return this;

			},

			convertGammaToLinear: function () {

				var r = this.r, g = this.g, b = this.b;

				this.r = r * r;
				this.g = g * g;
				this.b = b * b;

				return this;

			},

			convertLinearToGamma: function () {

				this.r = Math.sqrt( this.r );
				this.g = Math.sqrt( this.g );
				this.b = Math.sqrt( this.b );

				return this;

			},

			getHex: function () {

				return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

			},

			getHexString: function () {

				return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

			},

			getHSL: function ( optionalTarget ) {

				// h,s,l ranges are in 0.0 - 1.0

				var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

				var r = this.r, g = this.g, b = this.b;

				var max = Math.max( r, g, b );
				var min = Math.min( r, g, b );

				var hue, saturation;
				var lightness = ( min + max ) / 2.0;

				if ( min === max ) {

					hue = 0;
					saturation = 0;

				} else {

					var delta = max - min;

					saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

					switch ( max ) {

						case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
						case g: hue = ( b - r ) / delta + 2; break;
						case b: hue = ( r - g ) / delta + 4; break;

					}

					hue /= 6;

				}

				hsl.h = hue;
				hsl.s = saturation;
				hsl.l = lightness;

				return hsl;

			},

			getStyle: function () {

				return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

			},

			offsetHSL: function ( h, s, l ) {

				var hsl = this.getHSL();

				hsl.h += h; hsl.s += s; hsl.l += l;

				this.setHSL( hsl.h, hsl.s, hsl.l );

				return this;

			},

			add: function ( color ) {

				this.r += color.r;
				this.g += color.g;
				this.b += color.b;

				return this;

			},

			addColors: function ( color1, color2 ) {

				this.r = color1.r + color2.r;
				this.g = color1.g + color2.g;
				this.b = color1.b + color2.b;

				return this;

			},

			addScalar: function ( s ) {

				this.r += s;
				this.g += s;
				this.b += s;

				return this;

			},

			sub: function( color ) {

				this.r = Math.max( 0, this.r - color.r );
				this.g = Math.max( 0, this.g - color.g );
				this.b = Math.max( 0, this.b - color.b );

				return this;

			},

			multiply: function ( color ) {

				this.r *= color.r;
				this.g *= color.g;
				this.b *= color.b;

				return this;

			},

			multiplyScalar: function ( s ) {

				this.r *= s;
				this.g *= s;
				this.b *= s;

				return this;

			},

			lerp: function ( color, alpha ) {

				this.r += ( color.r - this.r ) * alpha;
				this.g += ( color.g - this.g ) * alpha;
				this.b += ( color.b - this.b ) * alpha;

				return this;

			},

			equals: function ( c ) {

				return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.r = array[ offset ];
				this.g = array[ offset + 1 ];
				this.b = array[ offset + 2 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.r;
				array[ offset + 1 ] = this.g;
				array[ offset + 2 ] = this.b;

				return array;

			},

			toJSON: function () {

				return this.getHex();

			}

		};

		var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { data: data, width: width, height: height };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.generateMipmaps  = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

		DataTexture.prototype = Object.create( Texture.prototype );
		DataTexture.prototype.constructor = DataTexture;

		DataTexture.prototype.isDataTexture = true;

		/**
		 * Uniforms library for shared webgl shaders
		 */

		var UniformsLib = {

			common: {

				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },

				"map": { value: null },
				"mapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"mapTexelTransformParams": { value: new Vector2( 1, 0 ) },
				"offsetRepeat": { value: new Vector4( 0, 0, 1, 1 ) },

				"specularMap": { value: null },
				"specularMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"specularMapTexelTransformParams": { value: new Vector2( 1, 0 ) },

				"alphaMap": { value: null },
				"alphaMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"alphaMapTexelTransformParams": { value: new Vector2( 1, 0 ) },

				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				reflectivity: { value: 1.0 },
				refractionRatio: { value: 0.98 }

			},

			aomap: {

				"aoMap": { value: null },
				"aoMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"aoMapTexelTransformParams": { value: new Vector2( 1, 0 ) },
				"aoMapIntensity": { value: 1 }

			},

			lightmap: {

				"lightMap": { value: null },
				"lightMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"lightMapTexelTransformParams": { value: new Vector2( 1, 0 ) },
				"lightMapIntensity": { value: 1 }

			},

			emissivemap: {

				"emissiveMap": { value: null },
				"emissiveMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"emissiveMapTexelTransformParams": { value: new Vector2( 1, 0 ) }

			},

			bumpmap: {

				"bumpMap": { value: null },
				"bumpScale": { value: 1 },
				"bumpMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"bumpMapTexelTransformParams": { value: new Vector2( 1, 0 ) }

			},

			normalmap: {

				"normalMap": { value: null },
				"normalScale": { value: new Vector2( 1, 1 ) }, // for backwards compatibility
				"normalMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"normalMapTexelTransformParams": { value: new Vector2( 1, 0 ) }

			},

			displacementmap: {

				"displacementMap": { value: null },
				"displacementScale": { value: 1 }, // for backwards compatibility
				"displacementBias": { value: 0 }, // for backwards compatibility
				"displacementMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"displacementMapTexelTransformParams": { value: new Vector2( 1, 0 ) }

			},


			falloffmap: {

				"falloffMap": { value: null },
				"falloffMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"falloffMapTexelTransformParams": { value: new Vector2( 1, 0 ) }

			},

			falloffalphamap: {

				"falloffAlphaMap": { value: null },
				"falloffAlphaMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"falloffAlphaMapTexelTransformParams": { value: new Vector2( 1, 0 ) }

			},

			roughnessmap: {

				"roughnessMap": { value: null },
				"roughnessMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"roughnessMapTexelTransformParams": { value: new Vector2( 1, 0 ) }

			},

			metalnessmap: {

				"metalnessMap": { value: null },
				"metalnessMapUVTransformParams": { value: new Vector4( 0, 0, 1, 1 ) },
				"metalnessMapTexelTransformParams": { value: new Vector2( 1, 0 ) }

			},

			gradientmap: {

				gradientMap: { value: null }

			},

			fog: {

				fogDensity: { value: 0.00025 },
				fogNear: { value: 1 },
				fogFar: { value: 2000 },
				fogColor: { value: new Color( 0xffffff ) }

			},

			lights: {

				ambientLightColor: { value: [] },

				directionalLights: { value: [], properties: {
					direction: {},
					color: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowSpreadAngle: {},
					shadowCameraParams: {}
				} },

				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },

				spotLights: { value: [], properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraParams: {}
				} },

				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },

				pointLights: { value: [], properties: {
					color: {},
					position: {},
					decay: {},
					distance: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },

				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },

				hemisphereLights: { value: [], properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				} },

		        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		        rectAreaLights: { value: [], properties: {
		            color: {},
		            position: {},
		            width: {},
		            height: {},
		        } }

			},

			points: {

				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
				size: { value: 1.0 },
				scale: { value: 1.0 },
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 */

		var ShaderLib = {

			basic: {

				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.fog
				] ),

				vertexShader: ShaderChunk.meshbasic_vert,
				fragmentShader: ShaderChunk.meshbasic_frag

			},

			lambert: {

				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) }
					}
				] ),

				vertexShader: ShaderChunk.meshlambert_vert,
				fragmentShader: ShaderChunk.meshlambert_frag

			},

			phong: {

				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.gradientmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						specular: { value: new Color( 0x111111 ) },
						shininess: { value: 30 }
					}
				] ),

				vertexShader: ShaderChunk.meshphong_vert,
				fragmentShader: ShaderChunk.meshphong_frag

			},

			standard: {

				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.roughnessmap,
					UniformsLib.metalnessmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0 },
						envMapIntensity: { value: 1 } // temporary
					}
				] ),

				vertexShader: ShaderChunk.meshphysical_vert,
				fragmentShader: ShaderChunk.meshphysical_frag

			},

			points: {

				uniforms: UniformsUtils.merge( [
					UniformsLib.points,
					UniformsLib.fog
				] ),

				vertexShader: ShaderChunk.points_vert,
				fragmentShader: ShaderChunk.points_frag

			},

			dashed: {

				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.fog,
					{
						scale: { value: 1 },
						dashSize: { value: 1 },
						totalSize: { value: 2 }
					}
				] ),

				vertexShader: ShaderChunk.linedashed_vert,
				fragmentShader: ShaderChunk.linedashed_frag

			},

			depth: {

				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.displacementmap
				] ),

				vertexShader: ShaderChunk.depth_vert,
				fragmentShader: ShaderChunk.depth_frag

			},

			normal: {

				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					{
						opacity: { value: 1.0 }
					}
				] ),

				vertexShader: ShaderChunk.normal_vert,
				fragmentShader: ShaderChunk.normal_frag

			},

			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */

			cube: {

				uniforms: {
					tCube: { value: null },
					tFlip: { value: - 1 },
					opacity: { value: 1.0 }
				},

				vertexShader: ShaderChunk.cube_vert,
				fragmentShader: ShaderChunk.cube_frag

			},

			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */

			equirect: {

				uniforms: {
					tEquirect: { value: null },
					tFlip: { value: - 1 }
				},

				vertexShader: ShaderChunk.equirect_vert,
				fragmentShader: ShaderChunk.equirect_frag

			},

			distanceRGBA: {

				uniforms: {
					lightPos: { value: new Vector3() }
				},

				vertexShader: ShaderChunk.distanceRGBA_vert,
				fragmentShader: ShaderChunk.distanceRGBA_frag

			}

		};

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		ShaderLib.cubeEnv = {


			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				ShaderLib.standard.uniforms,
				{
					envMap: { value: null },
					envMapIntensity: { value: 1.0 },
					tFlip: { value: - 1 },
					opacity: { value: 1.0 },
					roughness: { value: 0.0 }
				}
			] ),

			vertexShader: ShaderChunk.cubeEnv_vert,
			fragmentShader: ShaderChunk.cubeEnv_frag

		};

		ShaderLib.physical = {

			uniforms: UniformsUtils.merge( [
				ShaderLib.standard.uniforms,
				UniformsLib.falloffmap,
				UniformsLib.falloffalphamap,
				{
					falloffDiffuse: { value: new Color( 0xffffff ) },
					falloffOpacity: { value: 0 },
					clearCoat: { value: 0 },
					clearCoatRoughness: { value: 0 }
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		};

		/**
		 * @author bhouston / http://clara.io
		 */

		function Box2( min, max ) {

			this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

		}

		Box2.prototype = {

			constructor: Box2,

			set: function ( min, max ) {

				this.min.copy( min );
				this.max.copy( max );

				return this;

			},

			setFromPoints: function ( points ) {

				this.makeEmpty();

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					this.expandByPoint( points[ i ] );

				}

				return this;

			},

			setFromCenterAndSize: function () {

				var v1 = new Vector2();

				return function setFromCenterAndSize( center, size ) {

					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( box ) {

				this.min.copy( box.min );
				this.max.copy( box.max );

				return this;

			},

			makeEmpty: function () {

				this.min.x = this.min.y = + Infinity;
				this.max.x = this.max.y = - Infinity;

				return this;

			},

			isEmpty: function () {

				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

			},

			getCenter: function ( optionalTarget ) {

				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

			},

			getSize: function ( optionalTarget ) {

				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

			},

			expandByPoint: function ( point ) {

				this.min.min( point );
				this.max.max( point );

				return this;

			},

			expandByVector: function ( vector ) {

				this.min.sub( vector );
				this.max.add( vector );

				return this;

			},

			expandByScalar: function ( scalar ) {

				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );

				return this;

			},

			containsPoint: function ( point ) {

				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ? false : true;

			},

			containsBox: function ( box ) {

				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y;

			},

			getParameter: function ( point, optionalTarget ) {

				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.

				var result = optionalTarget || new Vector2();

				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y )
				);

			},

			intersectsBox: function ( box ) {

				// using 6 splitting planes to rule out intersections.
				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

			},

			clampPoint: function ( point, optionalTarget ) {

				var result = optionalTarget || new Vector2();
				return result.copy( point ).clamp( this.min, this.max );

			},

			distanceToPoint: function () {

				var v1 = new Vector2();

				return function distanceToPoint( point ) {

					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();

				};

			}(),

			intersect: function ( box ) {

				this.min.max( box.min );
				this.max.min( box.max );

				return this;

			},

			union: function ( box ) {

				this.min.min( box.min );
				this.max.max( box.max );

				return this;

			},

			translate: function ( offset ) {

				this.min.add( offset );
				this.max.add( offset );

				return this;

			},

			equals: function ( box ) {

				return box.min.equals( this.min ) && box.max.equals( this.max );

			}

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function LensFlarePlugin( renderer, flares ) {

			var gl = renderer.context;
			var state = renderer.state;

			var vertexBuffer, elementBuffer;
			var shader, program, attributes, uniforms;

			var tempTexture, occlusionTexture;

			function init() {

				var vertices = new Float32Array( [
					- 1, - 1,  0, 0,
					 1, - 1,  1, 0,
					 1,  1,  1, 1,
					- 1,  1,  0, 1
				] );

				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );

				// buffers

				vertexBuffer     = gl.createBuffer();
				elementBuffer    = gl.createBuffer();

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

				// textures

				tempTexture      = gl.createTexture();
				occlusionTexture = gl.createTexture();

				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"uniform sampler2D occlusionMap;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if ( renderType == 2 ) {",

								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							// pink square

							"if ( renderType == 0 ) {",

								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

							// restore

							"} else if ( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

				program = createProgram( shader );

				attributes = {
					vertex: gl.getAttribLocation ( program, "position" ),
					uv:     gl.getAttribLocation ( program, "uv" )
				};

				uniforms = {
					renderType:     gl.getUniformLocation( program, "renderType" ),
					map:            gl.getUniformLocation( program, "map" ),
					occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
					opacity:        gl.getUniformLocation( program, "opacity" ),
					color:          gl.getUniformLocation( program, "color" ),
					scale:          gl.getUniformLocation( program, "scale" ),
					rotation:       gl.getUniformLocation( program, "rotation" ),
					screenPosition: gl.getUniformLocation( program, "screenPosition" )
				};

			}

			/*
			 * Render lens flares
			 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
			 *         reads these back and calculates occlusion.
			 */

			this.render = function ( scene, camera, viewport ) {

				if ( flares.length === 0 ) return;

				var tempPosition = new Vector3();

				var invAspect = viewport.w / viewport.z,
					halfViewportWidth = viewport.z * 0.5,
					halfViewportHeight = viewport.w * 0.5;

				var size = 16 / viewport.w,
					scale = new Vector2( size * invAspect, size );

				var screenPosition = new Vector3( 1, 1, 0 ),
					screenPositionPixels = new Vector2( 1, 1 );

				var validArea = new Box2();

				validArea.min.set( viewport.x, viewport.y );
				validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

				if ( program === undefined ) {

					init();

				}

				gl.useProgram( program );

				state.initAttributes();
				state.enableAttribute( attributes.vertex );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();

				// loop through all lens flares to update their occlusion and positions
				// setup gl and common used attribs/uniforms

				gl.uniform1i( uniforms.occlusionMap, 0 );
				gl.uniform1i( uniforms.map, 1 );

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

				state.disable( gl.CULL_FACE );
				state.setDepthWrite( false );

				for ( var i = 0, l = flares.length; i < l; i ++ ) {

					size = 16 / viewport.w;
					scale.set( size * invAspect, size );

					// calc object screen position

					var flare = flares[ i ];

					tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

					tempPosition.applyMatrix4( camera.matrixWorldInverse );
					tempPosition.applyMatrix4( camera.projectionMatrix );

					// setup arrays for gl programs

					screenPosition.copy( tempPosition );

					// horizontal and vertical coordinate of the lower left corner of the pixels to copy

					screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
					screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

					// screen cull

					if ( validArea.containsPoint( screenPositionPixels ) === true ) {

						// save current RGB to temp texture

						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, null );
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


						// render pink quad

						gl.uniform1i( uniforms.renderType, 0 );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

						state.disable( gl.BLEND );
						state.enable( gl.DEPTH_TEST );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


						// copy result to occlusionMap

						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


						// restore graphics

						gl.uniform1i( uniforms.renderType, 1 );
						state.disable( gl.DEPTH_TEST );

						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


						// update object positions

						flare.positionScreen.copy( screenPosition );

						if ( flare.customUpdateCallback ) {

							flare.customUpdateCallback( flare );

						} else {

							flare.updateLensFlares();

						}

						// render flares

						gl.uniform1i( uniforms.renderType, 2 );
						state.enable( gl.BLEND );

						for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

							var sprite = flare.lensFlares[ j ];

							if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

								screenPosition.x = sprite.x;
								screenPosition.y = sprite.y;
								screenPosition.z = sprite.z;

								size = sprite.size * sprite.scale / viewport.w;

								scale.x = size * invAspect;
								scale.y = size;

								gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
								gl.uniform2f( uniforms.scale, scale.x, scale.y );
								gl.uniform1f( uniforms.rotation, sprite.rotation );

								gl.uniform1f( uniforms.opacity, sprite.opacity );
								gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

								state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
								renderer.setTexture2D( sprite.texture, 1 );

								gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

							}

						}

					}

				}

				// restore gl

				state.enable( gl.CULL_FACE );
				state.enable( gl.DEPTH_TEST );
				state.setDepthWrite( true );

				renderer.resetGLState();

			};

			function createProgram( shader ) {

				var program = gl.createProgram();

				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );

				var prefix = "precision " + renderer.getPrecision() + " float;\n";

				gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
				gl.shaderSource( vertexShader, prefix + shader.vertexShader );

				gl.compileShader( fragmentShader );
				gl.compileShader( vertexShader );

				gl.attachShader( program, fragmentShader );
				gl.attachShader( program, vertexShader );

				gl.linkProgram( program );

				return program;

			}

		}

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function SpritePlugin( renderer, sprites ) {

			var gl = renderer.context;
			var state = renderer.state;

			var vertexBuffer, elementBuffer;
			var program, attributes, uniforms;

			var texture;

			// decompose matrixWorld

			var spritePosition = new Vector3();
			var spriteRotation = new Quaternion();
			var spriteScale = new Vector3();

			function init() {

				var vertices = new Float32Array( [
					- 0.5, - 0.5,  0, 0,
					  0.5, - 0.5,  1, 0,
					  0.5,   0.5,  1, 1,
					- 0.5,   0.5,  0, 1
				] );

				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );

				vertexBuffer  = gl.createBuffer();
				elementBuffer = gl.createBuffer();

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

				program = createProgram();

				attributes = {
					position:			gl.getAttribLocation ( program, 'position' ),
					uv:					gl.getAttribLocation ( program, 'uv' )
				};

				uniforms = {
					uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
					uvScale:			gl.getUniformLocation( program, 'uvScale' ),

					rotation:			gl.getUniformLocation( program, 'rotation' ),
					scale:				gl.getUniformLocation( program, 'scale' ),

					color:				gl.getUniformLocation( program, 'color' ),
					map:				gl.getUniformLocation( program, 'map' ),
					opacity:			gl.getUniformLocation( program, 'opacity' ),

					modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
					projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

					fogType:			gl.getUniformLocation( program, 'fogType' ),
					fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
					fogNear:			gl.getUniformLocation( program, 'fogNear' ),
					fogFar:				gl.getUniformLocation( program, 'fogFar' ),
					fogColor:			gl.getUniformLocation( program, 'fogColor' ),

					alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
				};

				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = 8;
				canvas.height = 8;

				var context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 0, 8, 8 );

				texture = new Texture( canvas );
				texture.needsUpdate = true;

			}

			this.render = function ( scene, camera ) {

				if ( sprites.length === 0 ) return;

				// setup gl

				if ( program === undefined ) {

					init();

				}

				gl.useProgram( program );

				state.initAttributes();
				state.enableAttribute( attributes.position );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();

				state.disable( gl.CULL_FACE );
				state.enable( gl.BLEND );

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

				gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

				state.activeTexture( gl.TEXTURE0 );
				gl.uniform1i( uniforms.map, 0 );

				var oldFogType = 0;
				var sceneFogType = 0;
				var fog = scene.fog;

				if ( fog ) {

					gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

					if ( fog.isFog ) {

						gl.uniform1f( uniforms.fogNear, fog.near );
						gl.uniform1f( uniforms.fogFar, fog.far );

						gl.uniform1i( uniforms.fogType, 1 );
						oldFogType = 1;
						sceneFogType = 1;

					} else if ( fog.isFogExp2 ) {

						gl.uniform1f( uniforms.fogDensity, fog.density );

						gl.uniform1i( uniforms.fogType, 2 );
						oldFogType = 2;
						sceneFogType = 2;

					}

				} else {

					gl.uniform1i( uniforms.fogType, 0 );
					oldFogType = 0;
					sceneFogType = 0;

				}


				// update positions and sort

				for ( var i = 0, l = sprites.length; i < l; i ++ ) {

					var sprite = sprites[ i ];

					sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
					sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

				}

				sprites.sort( painterSortStable );

				// render all sprites

				var scale = [];

				for ( var i = 0, l = sprites.length; i < l; i ++ ) {

					var sprite = sprites[ i ];
					var material = sprite.material;

					if ( material.visible === false ) continue;

					gl.uniform1f( uniforms.alphaTest, material.alphaTest );
					gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

					sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

					scale[ 0 ] = spriteScale.x;
					scale[ 1 ] = spriteScale.y;

					var fogType = 0;

					if ( scene.fog && material.fog ) {

						fogType = sceneFogType;

					}

					if ( oldFogType !== fogType ) {

						gl.uniform1i( uniforms.fogType, fogType );
						oldFogType = fogType;

					}

					if ( material.map !== null ) {

						gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
						gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

					} else {

						gl.uniform2f( uniforms.uvOffset, 0, 0 );
						gl.uniform2f( uniforms.uvScale, 1, 1 );

					}

					gl.uniform1f( uniforms.opacity, material.opacity );
					gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

					gl.uniform1f( uniforms.rotation, material.rotation );
					gl.uniform2fv( uniforms.scale, scale );

					state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
					state.setDepthTest( material.depthTest );
					state.setDepthWrite( material.depthWrite );

					if ( material.map ) {

						renderer.setTexture2D( material.map, 0 );

					} else {

						renderer.setTexture2D( texture, 0 );

					}

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

				}

				// restore gl

				state.enable( gl.CULL_FACE );

				renderer.resetGLState();

			};

			function createProgram() {

				var program = gl.createProgram();

				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

				gl.shaderSource( vertexShader, [

					'precision ' + renderer.getPrecision() + ' float;',

					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform float rotation;',
					'uniform vec2 scale;',
					'uniform vec2 uvOffset;',
					'uniform vec2 uvScale;',

					'attribute vec2 position;',
					'attribute vec2 uv;',

					'varying vec2 vUV;',

					'void main() {',

						'vUV = uvOffset + uv * uvScale;',

						'vec2 alignedPosition = position * scale;',

						'vec2 rotatedPosition;',
						'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
						'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

						'vec4 finalPosition;',

						'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
						'finalPosition.xy += rotatedPosition;',
						'finalPosition = projectionMatrix * finalPosition;',

						'gl_Position = finalPosition;',

					'}'

				].join( '\n' ) );

				gl.shaderSource( fragmentShader, [

					'precision ' + renderer.getPrecision() + ' float;',

					'uniform vec3 color;',
					'uniform sampler2D map;',
					'uniform float opacity;',

					'uniform int fogType;',
					'uniform vec3 fogColor;',
					'uniform float fogDensity;',
					'uniform float fogNear;',
					'uniform float fogFar;',
					'uniform float alphaTest;',

					'varying vec2 vUV;',

					'void main() {',

						'vec4 texture = texture2D( map, vUV );',

						'if ( texture.a < alphaTest ) discard;',

						'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

						'if ( fogType > 0 ) {',

							'float depth = gl_FragCoord.z / gl_FragCoord.w;',
							'float fogFactor = 0.0;',

							'if ( fogType == 1 ) {',

								'fogFactor = smoothstep( fogNear, fogFar, depth );',

							'} else {',

								'const float LOG2 = 1.442695;',
								'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
								'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

							'}',

							'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

						'}',

					'}'

				].join( '\n' ) );

				gl.compileShader( vertexShader );
				gl.compileShader( fragmentShader );

				gl.attachShader( program, vertexShader );
				gl.attachShader( program, fragmentShader );

				gl.linkProgram( program );

				return program;

			}

			function painterSortStable( a, b ) {

				if ( a.renderOrder !== b.renderOrder ) {

					return a.renderOrder - b.renderOrder;

				} else if ( a.z !== b.z ) {

					return b.z - a.z;

				} else {

					return b.id - a.id;

				}

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		var materialId = 0;

		function Material() {

			Object.defineProperty( this, 'id', { value: materialId ++ } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'Material';

			this.fog = true;
			this.lights = true;

			this.blending = NormalBlending;
			this.side = FrontSide;
			this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
			this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

			this.opacity = 1;
			this.transparent = false;

			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;

			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;

			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;

			this.colorWrite = true;

			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;

			this.alphaTest = 0;
			this.premultipliedAlpha = false;

			this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

			this.visible = true;

			this._needsUpdate = true;

			this.version = 0;

		}

		Material.prototype = {

			constructor: Material,

			isMaterial: true,

			get needsUpdate() {

				return this._needsUpdate;

			},

			set needsUpdate( value ) {

				if ( value === true ) this.update();
				this._needsUpdate = value;
				this.version ++;

			},

			setValues: function ( values ) {

				if ( values === undefined ) return;

				for ( var key in values ) {

					var newValue = values[ key ];

					if ( newValue === undefined ) {

						console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
						continue;

					}

					var currentValue = this[ key ];

					if ( currentValue === undefined ) {

						console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
						continue;

					}

					if ( currentValue && currentValue.isColor ) {

						currentValue.set( newValue );

					} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

						currentValue.copy( newValue );

					} else if ( key === 'overdraw' ) {

						// ensure overdraw is backwards-compatible with legacy boolean type
						this[ key ] = Number( newValue );

					} else {

						this[ key ] = newValue;

					}

				}

			},

			toJSON: function ( meta ) {

				var isRoot = meta === undefined;

				if ( isRoot ) {

					meta = {
						textures: {},
						images: {}
					};

				}

				var data = {
					metadata: {
						version: 4.4,
						type: 'Material',
						generator: 'Material.toJSON'
					}
				};

				// standard Material serialization
				data.uuid = this.uuid;
				data.type = this.type;

				if ( this.name !== '' ) data.name = this.name;

				if ( this.color && this.color.isColor ) data.color = this.color.getHex();

				if ( this.roughness !== undefined ) data.roughness = this.roughness;
				if ( this.metalness !== undefined ) data.metalness = this.metalness;

				if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
				if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
				if ( this.shininess !== undefined ) data.shininess = this.shininess;
				if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
				if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

				if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
				if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
				if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
				if ( this.bumpMap && this.bumpMap.isTexture ) {

					data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
					data.bumpScale = this.bumpScale;

				}
				if ( this.normalMap && this.normalMap.isTexture ) {

					data.normalMap = this.normalMap.toJSON( meta ).uuid;
					data.normalScale = this.normalScale.toArray();

				}
				if ( this.displacementMap && this.displacementMap.isTexture ) {

					data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
					data.displacementScale = this.displacementScale;
					data.displacementBias = this.displacementBias;

				}
				if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
				if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

				if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
				if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

				if ( this.envMap && this.envMap.isTexture ) {

					data.envMap = this.envMap.toJSON( meta ).uuid;
					data.reflectivity = this.reflectivity; // Scale behind envMap

				}

				if ( this.gradientMap && this.gradientMap.isTexture ) {

					data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

				}

				if ( this.size !== undefined ) data.size = this.size;
				if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

				if ( this.blending !== NormalBlending ) data.blending = this.blending;
				if ( this.shading !== SmoothShading ) data.shading = this.shading;
				if ( this.side !== FrontSide ) data.side = this.side;
				if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

				if ( this.opacity < 1 ) data.opacity = this.opacity;
				if ( this.transparent === true ) data.transparent = this.transparent;

				data.depthFunc = this.depthFunc;
				data.depthTest = this.depthTest;
				data.depthWrite = this.depthWrite;

				if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
				if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
				if ( this.wireframe === true ) data.wireframe = this.wireframe;
				if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
				if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
				if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

				data.skinning = this.skinning;
				data.morphTargets = this.morphTargets;

				// TODO: Copied from Object3D.toJSON

				function extractFromCache( cache ) {

					var values = [];

					for ( var key in cache ) {

						var data = cache[ key ];
						delete data.metadata;
						values.push( data );

					}

					return values;

				}

				if ( isRoot ) {

					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );

					if ( textures.length > 0 ) data.textures = textures;
					if ( images.length > 0 ) data.images = images;

				}

				return data;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.name = source.name;

				this.fog = source.fog;
				this.lights = source.lights;

				this.blending = source.blending;
				this.side = source.side;
				this.shading = source.shading;
				this.vertexColors = source.vertexColors;

				this.opacity = source.opacity;
				this.transparent = source.transparent;

				this.blendSrc = source.blendSrc;
				this.blendDst = source.blendDst;
				this.blendEquation = source.blendEquation;
				this.blendSrcAlpha = source.blendSrcAlpha;
				this.blendDstAlpha = source.blendDstAlpha;
				this.blendEquationAlpha = source.blendEquationAlpha;

				this.depthFunc = source.depthFunc;
				this.depthTest = source.depthTest;
				this.depthWrite = source.depthWrite;

				this.colorWrite = source.colorWrite;

				this.precision = source.precision;

				this.polygonOffset = source.polygonOffset;
				this.polygonOffsetFactor = source.polygonOffsetFactor;
				this.polygonOffsetUnits = source.polygonOffsetUnits;

				this.alphaTest = source.alphaTest;

				this.premultipliedAlpha = source.premultipliedAlpha;

				this.overdraw = source.overdraw;

				this.visible = source.visible;
				this.clipShadows = source.clipShadows;
				this.clipIntersection = source.clipIntersection;

				var srcPlanes = source.clippingPlanes,
					dstPlanes = null;

				if ( srcPlanes !== null ) {

					var n = srcPlanes.length;
					dstPlanes = new Array( n );

					for ( var i = 0; i !== n; ++ i )
						dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

				this.clippingPlanes = dstPlanes;

				return this;

			},

			update: function () {

				this.dispatchEvent( { type: 'update' } );

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		};

		Object.assign( Material.prototype, EventDispatcher.prototype );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  defines: { "label" : "value" },
		 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
		 *
		 *  fragmentShader: <string>,
		 *  vertexShader: <string>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  lights: <bool>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function ShaderMaterial( parameters ) {

			Material.call( this );

			this.type = 'ShaderMaterial';

			this.defines = {};
			this.uniforms = {};

			this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
			this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

			this.linewidth = 1;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes

			this.skinning = false; // set to use skinning attribute streams
			this.morphTargets = false; // set to use morph targets
			this.morphNormals = false; // set to use morph normals

			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};

			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};

			this.index0AttributeName = undefined;

			if ( parameters !== undefined ) {

				if ( parameters.attributes !== undefined ) {

					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

				}

				this.setValues( parameters );

			}

		}

		ShaderMaterial.prototype = Object.create( Material.prototype );
		ShaderMaterial.prototype.constructor = ShaderMaterial;

		ShaderMaterial.prototype.isShaderMaterial = true;

		ShaderMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;

			this.uniforms = UniformsUtils.clone( source.uniforms );

			this.defines = source.defines;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.lights = source.lights;
			this.clipping = source.clipping;

			this.skinning = source.skinning;

			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.extensions = source.extensions;

			return this;

		};

		ShaderMaterial.prototype.toJSON = function ( meta ) {

			var data = Material.prototype.toJSON.call( this, meta );

			data.uniforms = this.uniforms;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;

			return data;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / https://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */

		function MeshDepthMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.skinning = false;
			this.morphTargets = false;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;
			this.lights = false;

			// far clipping plane in both RGBA and Basic encoding
			this.clearColor = new Color( 1.0, 1.0, 1.0 );
			this.clearAlpha = 1.0;

			this.setValues( parameters );

		}

		MeshDepthMaterial.prototype = Object.create( Material.prototype );
		MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

		MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

		MeshDepthMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.depthPacking = source.depthPacking;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.clearColor = source.clearColor;
			this.clearAlpha = source.clearAlpha;

			return this;

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Box3( min, max ) {

			this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

		}

		Box3.prototype = {

			constructor: Box3,

			isBox3: true,

			set: function ( min, max ) {

				this.min.copy( min );
				this.max.copy( max );

				return this;

			},

			setFromArray: function ( array ) {

				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;

				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var x = array[ i ];
					var y = array[ i + 1 ];
					var z = array[ i + 2 ];

					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;

					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;

				}

				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );

			},

			setFromBufferAttribute: function ( attribute ) {

				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;

				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					var x = attribute.getX( i );
					var y = attribute.getY( i );
					var z = attribute.getZ( i );

					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;

					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;

				}

				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );

			},

			setFromPoints: function ( points ) {

				this.makeEmpty();

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					this.expandByPoint( points[ i ] );

				}

				return this;

			},

			setFromCenterAndSize: function () {

				var v1 = new Vector3();

				return function setFromCenterAndSize( center, size ) {

					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );

					return this;

				};

			}(),

			setFromObject: function () {

				// Computes the world-axis-aligned bounding box of an object (including its children),
				// accounting for both the object's, and children's, world transforms

				var v1 = new Vector3();

				return function setFromObject( object ) {

					var scope = this;

					object.updateMatrixWorld( true );

					this.makeEmpty();

					object.traverse( function ( node ) {

						var i, l;

						var geometry = node.geometry;

						if ( geometry !== undefined ) {

							if ( geometry.isGeometry ) {

								var vertices = geometry.vertices;

								for ( i = 0, l = vertices.length; i < l; i ++ ) {

									v1.copy( vertices[ i ] );
									v1.applyMatrix4( node.matrixWorld );

									scope.expandByPoint( v1 );

								}

							} else if ( geometry.isBufferGeometry ) {

								var attribute = geometry.attributes.position;

								if ( attribute !== undefined ) {

									for ( i = 0, l = attribute.count; i < l; i ++ ) {

										v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

										scope.expandByPoint( v1 );

									}

								}

							}

						}

					} );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( box ) {

				this.min.copy( box.min );
				this.max.copy( box.max );

				return this;

			},

			makeEmpty: function () {

				this.min.x = this.min.y = this.min.z = + Infinity;
				this.max.x = this.max.y = this.max.z = - Infinity;

				return this;

			},

			isEmpty: function () {

				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

			},

			getCenter: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

			},

			getSize: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

			},

			expandByPoint: function ( point ) {

				this.min.min( point );
				this.max.max( point );

				return this;

			},

			expandByVector: function ( vector ) {

				this.min.sub( vector );
				this.max.add( vector );

				return this;

			},

			expandByScalar: function ( scalar ) {

				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );

				return this;

			},

			containsPoint: function ( point ) {

				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ||
					point.z < this.min.z || point.z > this.max.z ? false : true;

			},

			containsBox: function ( box ) {

				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y &&
					this.min.z <= box.min.z && box.max.z <= this.max.z;

			},

			getParameter: function ( point, optionalTarget ) {

				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.

				var result = optionalTarget || new Vector3();

				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y ),
					( point.z - this.min.z ) / ( this.max.z - this.min.z )
				);

			},

			intersectsBox: function ( box ) {

				// using 6 splitting planes to rule out intersections.
				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ||
					box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

			},

			intersectsSphere: ( function () {

				var closestPoint;

				return function intersectsSphere( sphere ) {

					if ( closestPoint === undefined ) closestPoint = new Vector3();

					// Find the point on the AABB closest to the sphere center.
					this.clampPoint( sphere.center, closestPoint );

					// If that point is inside the sphere, the AABB and sphere intersect.
					return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

				};

			} )(),

			intersectsPlane: function ( plane ) {

				// We compute the minimum and maximum dot product values. If those values
				// are on the same side (back or front) of the plane, then there is no intersection.

				var min, max;

				if ( plane.normal.x > 0 ) {

					min = plane.normal.x * this.min.x;
					max = plane.normal.x * this.max.x;

				} else {

					min = plane.normal.x * this.max.x;
					max = plane.normal.x * this.min.x;

				}

				if ( plane.normal.y > 0 ) {

					min += plane.normal.y * this.min.y;
					max += plane.normal.y * this.max.y;

				} else {

					min += plane.normal.y * this.max.y;
					max += plane.normal.y * this.min.y;

				}

				if ( plane.normal.z > 0 ) {

					min += plane.normal.z * this.min.z;
					max += plane.normal.z * this.max.z;

				} else {

					min += plane.normal.z * this.max.z;
					max += plane.normal.z * this.min.z;

				}

				return ( min <= plane.constant && max >= plane.constant );

			},

			clampPoint: function ( point, optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.copy( point ).clamp( this.min, this.max );

			},

			distanceToPoint: function () {

				var v1 = new Vector3();

				return function distanceToPoint( point ) {

					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();

				};

			}(),

			getBoundingSphere: function () {

				var v1 = new Vector3();

				return function getBoundingSphere( optionalTarget ) {

					var result = optionalTarget || new Sphere();

					this.getCenter( result.center );

					result.radius = this.getSize( v1 ).length() * 0.5;

					return result;

				};

			}(),

			intersect: function ( box ) {

				this.min.max( box.min );
				this.max.min( box.max );

				// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
				if( this.isEmpty() ) this.makeEmpty();

				return this;

			},

			union: function ( box ) {

				this.min.min( box.min );
				this.max.max( box.max );

				return this;

			},

			applyMatrix4: function () {

				var points = [
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3()
				];

				return function applyMatrix4( matrix ) {

					// transform of empty box is an empty box.
					if( this.isEmpty() ) return this;

					// NOTE: I am using a binary pattern to specify all 2^3 combinations below
					points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
					points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
					points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
					points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
					points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
					points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
					points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
					points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

					this.setFromPoints( points );

					return this;

				};

			}(),

			translate: function ( offset ) {

				this.min.add( offset );
				this.max.add( offset );

				return this;

			},

			equals: function ( box ) {

				return box.min.equals( this.min ) && box.max.equals( this.max );

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Sphere( center, radius ) {

			this.center = ( center !== undefined ) ? center : new Vector3();
			this.radius = ( radius !== undefined ) ? radius : 0;

		}

		Sphere.prototype = {

			constructor: Sphere,

			set: function ( center, radius ) {

				this.center.copy( center );
				this.radius = radius;

				return this;

			},

			setFromPoints: function () {

				var box = new Box3();

				return function setFromPoints( points, optionalCenter ) {

					var center = this.center;

					if ( optionalCenter !== undefined ) {

						center.copy( optionalCenter );

					} else {

						box.setFromPoints( points ).getCenter( center );

					}

					var maxRadiusSq = 0;

					for ( var i = 0, il = points.length; i < il; i ++ ) {

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

					}

					this.radius = Math.sqrt( maxRadiusSq );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( sphere ) {

				this.center.copy( sphere.center );
				this.radius = sphere.radius;

				return this;

			},

			empty: function () {

				return ( this.radius <= 0 );

			},

			containsPoint: function ( point ) {

				return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

			},

			distanceToPoint: function ( point ) {

				return ( point.distanceTo( this.center ) - this.radius );

			},

			intersectsSphere: function ( sphere ) {

				var radiusSum = this.radius + sphere.radius;

				return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

			},

			intersectsBox: function ( box ) {

				return box.intersectsSphere( this );

			},

			intersectsPlane: function ( plane ) {

				// We use the following equation to compute the signed distance from
				// the center of the sphere to the plane.
				//
				// distance = q * n - d
				//
				// If this distance is greater than the radius of the sphere,
				// then there is no intersection.

				return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

			},

			clampPoint: function ( point, optionalTarget ) {

				var deltaLengthSq = this.center.distanceToSquared( point );

				var result = optionalTarget || new Vector3();

				result.copy( point );

				if ( deltaLengthSq > ( this.radius * this.radius ) ) {

					result.sub( this.center ).normalize();
					result.multiplyScalar( this.radius ).add( this.center );

				}

				return result;

			},

			getBoundingBox: function ( optionalTarget ) {

				var box = optionalTarget || new Box3();

				box.set( this.center, this.center );
				box.expandByScalar( this.radius );

				return box;

			},

			applyMatrix4: function ( matrix ) {

				this.center.applyMatrix4( matrix );
				this.radius = this.radius * matrix.getMaxScaleOnAxis();

				return this;

			},

			translate: function ( offset ) {

				this.center.add( offset );

				return this;

			},

			equals: function ( sphere ) {

				return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 * @author tschw
		 */

		function Matrix3() {

			this.elements = new Float32Array( [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			] );

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		Matrix3.prototype = {

			constructor: Matrix3,

			isMatrix3: true,

			set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

				var te = this.elements;

				te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
				te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
				te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

				return this;

			},

			identity: function () {

				this.set(

					1, 0, 0,
					0, 1, 0,
					0, 0, 1

				);

				return this;

			},

			clone: function () {

				return new this.constructor().fromArray( this.elements );

			},

			copy: function ( m ) {

				var me = m.elements;

				this.set(

					me[ 0 ], me[ 3 ], me[ 6 ],
					me[ 1 ], me[ 4 ], me[ 7 ],
					me[ 2 ], me[ 5 ], me[ 8 ]

				);

				return this;

			},

			setFromMatrix4: function( m ) {

				var me = m.elements;

				this.set(

					me[ 0 ], me[ 4 ], me[  8 ],
					me[ 1 ], me[ 5 ], me[  9 ],
					me[ 2 ], me[ 6 ], me[ 10 ]

				);

				return this;

			},

			applyToBufferAttribute: function () {

				var v1;

				return function applyToBufferAttribute( attribute ) {

					if ( v1 === undefined ) v1 = new Vector3();

					for ( var i = 0, l = attribute.count; i < l; i ++ ) {

						v1.x = attribute.getX( i );
						v1.y = attribute.getY( i );
						v1.z = attribute.getZ( i );

						v1.applyMatrix3( this );

						attribute.setXYZ( i, v1.x, v1.y, v1.z );

					}

					return attribute;

				};

			}(),

			multiplyScalar: function ( s ) {

				var te = this.elements;

				te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
				te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
				te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

				return this;

			},

			determinant: function () {

				var te = this.elements;

				var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
					d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
					g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

				return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

			},

			getInverse: function ( matrix, throwOnDegenerate ) {

				if ( matrix && matrix.isMatrix4 ) {

					console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

				}

				var me = matrix.elements,
					te = this.elements,

					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
					n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
					n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,

					det = n11 * t11 + n21 * t12 + n31 * t13;

				if ( det === 0 ) {

					var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

					if ( throwOnDegenerate === true ) {

						throw new Error( msg );

					} else {

						console.warn( msg );

					}

					return this.identity();
				}

				var detInv = 1 / det;

				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
				te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

				te[ 3 ] = t12 * detInv;
				te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
				te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

				te[ 6 ] = t13 * detInv;
				te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
				te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

				return this;

			},

			transpose: function () {

				var tmp, m = this.elements;

				tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
				tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
				tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

				return this;

			},

			getNormalMatrix: function ( matrix4 ) {

				return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

			},

			transposeIntoArray: function ( r ) {

				var m = this.elements;

				r[ 0 ] = m[ 0 ];
				r[ 1 ] = m[ 3 ];
				r[ 2 ] = m[ 6 ];
				r[ 3 ] = m[ 1 ];
				r[ 4 ] = m[ 4 ];
				r[ 5 ] = m[ 7 ];
				r[ 6 ] = m[ 2 ];
				r[ 7 ] = m[ 5 ];
				r[ 8 ] = m[ 8 ];

				return this;

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				for( var i = 0; i < 9; i ++ ) {

					this.elements[ i ] = array[ i + offset ];

				}

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				var te = this.elements;

				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];

				array[ offset + 3 ] = te[ 3 ];
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];

				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
				array[ offset + 8 ]  = te[ 8 ];

				return array;

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 */

		function Plane( normal, constant ) {

			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;

		}

		Plane.prototype = {

			constructor: Plane,

			set: function ( normal, constant ) {

				this.normal.copy( normal );
				this.constant = constant;

				return this;

			},

			setComponents: function ( x, y, z, w ) {

				this.normal.set( x, y, z );
				this.constant = w;

				return this;

			},

			setFromNormalAndCoplanarPoint: function ( normal, point ) {

				this.normal.copy( normal );
				this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

				return this;

			},

			setFromCoplanarPoints: function () {

				var v1 = new Vector3();
				var v2 = new Vector3();

				return function setFromCoplanarPoints( a, b, c ) {

					var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

					// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

					this.setFromNormalAndCoplanarPoint( normal, a );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( plane ) {

				this.normal.copy( plane.normal );
				this.constant = plane.constant;

				return this;

			},

			normalize: function () {

				// Note: will lead to a divide by zero if the plane is invalid.

				var inverseNormalLength = 1.0 / this.normal.length();
				this.normal.multiplyScalar( inverseNormalLength );
				this.constant *= inverseNormalLength;

				return this;

			},

			negate: function () {

				this.constant *= - 1;
				this.normal.negate();

				return this;

			},

			distanceToPoint: function ( point ) {

				return this.normal.dot( point ) + this.constant;

			},

			distanceToSphere: function ( sphere ) {

				return this.distanceToPoint( sphere.center ) - sphere.radius;

			},

			projectPoint: function ( point, optionalTarget ) {

				return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

			},

			orthoPoint: function ( point, optionalTarget ) {

				var perpendicularMagnitude = this.distanceToPoint( point );

				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

			},

			intersectLine: function () {

				var v1 = new Vector3();

				return function intersectLine( line, optionalTarget ) {

					var result = optionalTarget || new Vector3();

					var direction = line.delta( v1 );

					var denominator = this.normal.dot( direction );

					if ( denominator === 0 ) {

						// line is coplanar, return origin
						if ( this.distanceToPoint( line.start ) === 0 ) {

							return result.copy( line.start );

						}

						// Unsure if this is the correct method to handle this case.
						return undefined;

					}

					var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

					if ( t < 0 || t > 1 ) {

						return undefined;

					}

					return result.copy( direction ).multiplyScalar( t ).add( line.start );

				};

			}(),

			intersectsLine: function ( line ) {

				// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

				var startSign = this.distanceToPoint( line.start );
				var endSign = this.distanceToPoint( line.end );

				return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

			},

			intersectsBox: function ( box ) {

				return box.intersectsPlane( this );

			},

			intersectsSphere: function ( sphere ) {

				return sphere.intersectsPlane( this );

			},

			coplanarPoint: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( - this.constant );

			},

			applyMatrix4: function () {

				var v1 = new Vector3();
				var m1 = new Matrix3();

				return function applyMatrix4( matrix, optionalNormalMatrix ) {

					var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

					// transform normal based on theory here:
					// http://www.songho.ca/opengl/gl_normaltransform.html
					var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
					var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

					// recalculate constant (like in setFromNormalAndCoplanarPoint)
					this.constant = - referencePoint.dot( normal );

					return this;

				};

			}(),

			translate: function ( offset ) {

				this.constant = this.constant - offset.dot( this.normal );

				return this;

			},

			equals: function ( plane ) {

				return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / http://clara.io
		 */

		function Frustum( p0, p1, p2, p3, p4, p5 ) {

			this.planes = [

				( p0 !== undefined ) ? p0 : new Plane(),
				( p1 !== undefined ) ? p1 : new Plane(),
				( p2 !== undefined ) ? p2 : new Plane(),
				( p3 !== undefined ) ? p3 : new Plane(),
				( p4 !== undefined ) ? p4 : new Plane(),
				( p5 !== undefined ) ? p5 : new Plane()

			];

		}

		Frustum.prototype = {

			constructor: Frustum,

			set: function ( p0, p1, p2, p3, p4, p5 ) {

				var planes = this.planes;

				planes[ 0 ].copy( p0 );
				planes[ 1 ].copy( p1 );
				planes[ 2 ].copy( p2 );
				planes[ 3 ].copy( p3 );
				planes[ 4 ].copy( p4 );
				planes[ 5 ].copy( p5 );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( frustum ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					planes[ i ].copy( frustum.planes[ i ] );

				}

				return this;

			},

			setFromMatrix: function ( m ) {

				var planes = this.planes;
				var me = m.elements;
				var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
				var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
				var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
				var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

				planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
				planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
				planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
				planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
				planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

				return this;

			},

			intersectsObject: function () {

				var sphere = new Sphere();

				return function intersectsObject( object ) {

					var geometry = object.geometry;

					if ( geometry.boundingSphere === null )
						geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere )
						.applyMatrix4( object.matrixWorld );

					return this.intersectsSphere( sphere );

				};

			}(),

			intersectsSprite: function () {

				var sphere = new Sphere();

				return function intersectsSprite( sprite ) {

					sphere.center.set( 0, 0, 0 );
					sphere.radius = 0.7071067811865476;
					sphere.applyMatrix4( sprite.matrixWorld );

					return this.intersectsSphere( sphere );

				};

			}(),

			intersectsSphere: function ( sphere ) {

				var planes = this.planes;
				var center = sphere.center;
				var negRadius = - sphere.radius;

				for ( var i = 0; i < 6; i ++ ) {

					var distance = planes[ i ].distanceToPoint( center );

					if ( distance < negRadius ) {

						return false;

					}

				}

				return true;

			},

			intersectsBox: function () {

				var p1 = new Vector3(),
					p2 = new Vector3();

				return function intersectsBox( box ) {

					var planes = this.planes;

					for ( var i = 0; i < 6 ; i ++ ) {

						var plane = planes[ i ];

						p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
						p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
						p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
						p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
						p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
						p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

						var d1 = plane.distanceToPoint( p1 );
						var d2 = plane.distanceToPoint( p2 );

						// if both outside plane, no intersection

						if ( d1 < 0 && d2 < 0 ) {

							return false;

						}

					}

					return true;

				};

			}(),


			containsPoint: function ( point ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					if ( planes[ i ].distanceToPoint( point ) < 0 ) {

						return false;

					}

				}

				return true;

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

			var _gl = _renderer.context,
			_state = _renderer.state,
			_frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),

			_lightShadows = _lights.shadows,

			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),

			_renderList = [],

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

			_materialCache = {};

			var cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];

			var cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];

			var cube2DViewPorts = [
				new Vector4(), new Vector4(), new Vector4(),
				new Vector4(), new Vector4(), new Vector4()
			];

			// init

			var depthMaterialTemplate = new MeshDepthMaterial();
			depthMaterialTemplate.depthPacking = RGBADepthPacking;
			depthMaterialTemplate.clipping = true;

			var distanceShader = ShaderLib[ "distanceRGBA" ];
			var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );

			for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

				var useMorphing = ( i & _MorphingFlag ) !== 0;
				var useSkinning = ( i & _SkinningFlag ) !== 0;

				var depthMaterial = depthMaterialTemplate.clone();
				depthMaterial.morphTargets = useMorphing;
				depthMaterial.skinning = useSkinning;

				_depthMaterials[ i ] = depthMaterial;

				var distanceMaterial = new ShaderMaterial( {
					defines: {
						'USE_SHADOWMAP': ''
					},
					uniforms: distanceUniforms,
					vertexShader: distanceShader.vertexShader,
					fragmentShader: distanceShader.fragmentShader,
					morphTargets: useMorphing,
					skinning: useSkinning,
					clipping: true
				} );

				_distanceMaterials[ i ] = distanceMaterial;

			}

			//

			var scope = this;

			this.enabled = false;

			this.autoUpdate = true;
			this.needsUpdate = false;

			this.type = PCFShadowMap;

			this.renderReverseSided = true;
			this.renderSingleSided = true;

			this.render = function ( scene, camera ) {

				if ( scope.enabled === false ) return;
				if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

				if ( _lightShadows.length === 0 ) return;

				// Set GL state for depth map.
				_state.buffers.color.setClear( 1, 1, 1, 1 );
				_state.disable( _gl.BLEND );
				_state.setDepthTest( true );
				_state.setScissorTest( false );

				// render depth map

				var faceCount, isPointLight;

				for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

					var light = _lightShadows[ i ];
					var shadow = light.shadow;

					if ( shadow === undefined ) {

						console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
						continue;

					}

					var shadowCamera = shadow.camera;

					_shadowMapSize.copy( shadow.mapSize );
					_shadowMapSize.min( _maxShadowMapSize );

					if ( light && light.isPointLight ) {

						faceCount = 6;
						isPointLight = true;

						var vpWidth = _shadowMapSize.x;
						var vpHeight = _shadowMapSize.y;

						// These viewports map a cube-map onto a 2D texture with the
						// following orientation:
						//
						//  xzXZ
						//   y Y
						//
						// X - Positive x direction
						// x - Negative x direction
						// Y - Positive y direction
						// y - Negative y direction
						// Z - Positive z direction
						// z - Negative z direction

						// positive X
						cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
						// negative X
						cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
						// positive Z
						cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
						// negative Z
						cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
						// positive Y
						cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
						// negative Y
						cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

						_shadowMapSize.x *= 4.0;
						_shadowMapSize.y *= 2.0;

					} else {

						faceCount = 1;
						isPointLight = false;

					}

					if ( shadow.map === null ) {

						var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat, name: ( light.name + ".shadowMap" ) };

						shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

						shadowCamera.updateProjectionMatrix();

					}

					if ( shadow.isSpotLightShadow || shadow.isDirectionalLightShadow ) {

						shadow.update( light );

					}

					// TODO (abelnation / sam-g-steel): is this needed?
					if (shadow && shadow.isRectAreaLightShadow ) {

						shadow.update( light );

					}

					var shadowMap = shadow.map;
					var shadowMatrix = shadow.matrix;

					_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
					shadowCamera.position.copy( _lightPositionWorld );

					_renderer.setRenderTarget( shadowMap );
					_renderer.clear();

					// render shadow map for each cube face (if omni-directional) or
					// run a single pass if not

					for ( var face = 0; face < faceCount; face ++ ) {

						if ( isPointLight ) {

							_lookTarget.copy( shadowCamera.position );
							_lookTarget.add( cubeDirections[ face ] );
							shadowCamera.up.copy( cubeUps[ face ] );
							shadowCamera.lookAt( _lookTarget );

							var vpDimensions = cube2DViewPorts[ face ];
							_state.viewport( vpDimensions );

						} else {

							_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
							shadowCamera.lookAt( _lookTarget );

						}

						shadowCamera.updateMatrixWorld();
						shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

						// compute shadow matrix

						shadowMatrix.set(
							0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0
						);

						shadowMatrix.multiply( shadowCamera.projectionMatrix );
						shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

						// update camera matrices and frustum

						_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
						_frustum.setFromMatrix( _projScreenMatrix );

						// set object matrices & frustum culling

						_renderList.length = 0;

						projectObject( scene, camera, shadowCamera );

						// render shadow map
						// render regular objects

						for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

							var object = _renderList[ j ];
							var geometry = _objects.update( object );
							var material = object.material;

							if ( material && material.isMultiMaterial ) {

								var groups = geometry.groups;
								var materials = material.materials;

								for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

									var group = groups[ k ];
									var groupMaterial = materials[ group.materialIndex ];

									if ( groupMaterial.visible === true ) {

										var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
										_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

									}

								}

							} else {

								var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

							}

						}

					}

				}

				// Restore GL state.
				var clearColor = _renderer.getClearColor(),
				clearAlpha = _renderer.getClearAlpha();
				_renderer.setClearColor( clearColor, clearAlpha );

				scope.needsUpdate = false;

			};

			function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

				var geometry = object.geometry;

				var result = null;

				var materialVariants = _depthMaterials;
				var customMaterial = object.customDepthMaterial;

				if ( isPointLight ) {

					materialVariants = _distanceMaterials;
					customMaterial = object.customDistanceMaterial;

				}

				if ( ! customMaterial ) {

					var useMorphing = false;

					if ( material.morphTargets ) {

						if ( geometry && geometry.isBufferGeometry ) {

							useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

						} else if ( geometry && geometry.isGeometry ) {

							useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

						}

					}

					var useSkinning = object.isSkinnedMesh && material.skinning;

					var variantIndex = 0;

					if ( useMorphing ) variantIndex |= _MorphingFlag;
					if ( useSkinning ) variantIndex |= _SkinningFlag;

					result = materialVariants[ variantIndex ];

				} else {

					result = customMaterial;

				}

				if ( _renderer.localClippingEnabled &&
					 material.clipShadows === true &&
						material.clippingPlanes.length !== 0 ) {

					// in this case we need a unique material instance reflecting the
					// appropriate state

					var keyA = result.uuid, keyB = material.uuid;

					var materialsForVariant = _materialCache[ keyA ];

					if ( materialsForVariant === undefined ) {

						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;

					}

					var cachedMaterial = materialsForVariant[ keyB ];

					if ( cachedMaterial === undefined ) {

						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;

					}

					result = cachedMaterial;

				}

				result.visible = material.visible;
				result.wireframe = material.wireframe;

				var side = material.side;

				if ( scope.renderSingleSided && side == DoubleSide ) {

					side = FrontSide;

				}

				if ( scope.renderReverseSided ) {

					if ( side === FrontSide ) side = BackSide;
					else if ( side === BackSide ) side = FrontSide;

				}

				result.side = side;

				result.clipShadows = material.clipShadows;
				result.clippingPlanes = material.clippingPlanes;

				result.wireframeLinewidth = material.wireframeLinewidth;
				result.linewidth = material.linewidth;

				if ( isPointLight && result.uniforms.lightPos !== undefined ) {

					result.uniforms.lightPos.value.copy( lightPositionWorld );

				}

				return result;

			}

			function projectObject( object, camera, shadowCamera ) {

				if ( object.visible === false ) return;

				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

				if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

					if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

						var material = object.material;

						if ( material.visible === true ) {

							object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
							_renderList.push( object );

						}

					}

				}

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera, shadowCamera );

				}

			}

		}

		/**
		 * @author bhouston / http://clara.io
		 */

		function Ray( origin, direction ) {

			this.origin = ( origin !== undefined ) ? origin : new Vector3();
			this.direction = ( direction !== undefined ) ? direction : new Vector3();

		}

		Ray.prototype = {

			constructor: Ray,

			set: function ( origin, direction ) {

				this.origin.copy( origin );
				this.direction.copy( direction );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( ray ) {

				this.origin.copy( ray.origin );
				this.direction.copy( ray.direction );

				return this;

			},

			at: function ( t, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

			},

			lookAt: function ( v ) {

				this.direction.copy( v ).sub( this.origin ).normalize();

				return this;

			},

			recast: function () {

				var v1 = new Vector3();

				return function recast( t ) {

					this.origin.copy( this.at( t, v1 ) );

					return this;

				};

			}(),

			closestPointToPoint: function ( point, optionalTarget ) {

				var result = optionalTarget || new Vector3();
				result.subVectors( point, this.origin );
				var directionDistance = result.dot( this.direction );

				if ( directionDistance < 0 ) {

					return result.copy( this.origin );

				}

				return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			},

			distanceToPoint: function ( point ) {

				return Math.sqrt( this.distanceSqToPoint( point ) );

			},

			distanceSqToPoint: function () {

				var v1 = new Vector3();

				return function distanceSqToPoint( point ) {

					var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

					// point behind the ray

					if ( directionDistance < 0 ) {

						return this.origin.distanceToSquared( point );

					}

					v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

					return v1.distanceToSquared( point );

				};

			}(),

			distanceSqToSegment: function () {

				var segCenter = new Vector3();
				var segDir = new Vector3();
				var diff = new Vector3();

				return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
					// It returns the min distance between the ray and the segment
					// defined by v0 and v1
					// It can also set two optional targets :
					// - The closest point on the ray
					// - The closest point on the segment

					segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
					segDir.copy( v1 ).sub( v0 ).normalize();
					diff.copy( this.origin ).sub( segCenter );

					var segExtent = v0.distanceTo( v1 ) * 0.5;
					var a01 = - this.direction.dot( segDir );
					var b0 = diff.dot( this.direction );
					var b1 = - diff.dot( segDir );
					var c = diff.lengthSq();
					var det = Math.abs( 1 - a01 * a01 );
					var s0, s1, sqrDist, extDet;

					if ( det > 0 ) {

						// The ray and segment are not parallel.

						s0 = a01 * b1 - b0;
						s1 = a01 * b0 - b1;
						extDet = segExtent * det;

						if ( s0 >= 0 ) {

							if ( s1 >= - extDet ) {

								if ( s1 <= extDet ) {

									// region 0
									// Minimum at interior points of ray and segment.

									var invDet = 1 / det;
									s0 *= invDet;
									s1 *= invDet;
									sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

								} else {

									// region 1

									s1 = segExtent;
									s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
									sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

								}

							} else {

								// region 5

								s1 = - segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							if ( s1 <= - extDet ) {

								// region 4

								s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							} else if ( s1 <= extDet ) {

								// region 3

								s0 = 0;
								s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = s1 * ( s1 + 2 * b1 ) + c;

							} else {

								// region 2

								s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						}

					} else {

						// Ray and segment are parallel.

						s1 = ( a01 > 0 ) ? - segExtent : segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

					if ( optionalPointOnRay ) {

						optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

					}

					if ( optionalPointOnSegment ) {

						optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

					}

					return sqrDist;

				};

			}(),

			intersectSphere: function () {

				var v1 = new Vector3();

				return function intersectSphere( sphere, optionalTarget ) {

					v1.subVectors( sphere.center, this.origin );
					var tca = v1.dot( this.direction );
					var d2 = v1.dot( v1 ) - tca * tca;
					var radius2 = sphere.radius * sphere.radius;

					if ( d2 > radius2 ) return null;

					var thc = Math.sqrt( radius2 - d2 );

					// t0 = first intersect point - entrance on front of sphere
					var t0 = tca - thc;

					// t1 = second intersect point - exit point on back of sphere
					var t1 = tca + thc;

					// test to see if both t0 and t1 are behind the ray - if so, return null
					if ( t0 < 0 && t1 < 0 ) return null;

					// test to see if t0 is behind the ray:
					// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
					// in order to always return an intersect point that is in front of the ray.
					if ( t0 < 0 ) return this.at( t1, optionalTarget );

					// else t0 is in front of the ray, so return the first collision point scaled by t0
					return this.at( t0, optionalTarget );

				};

			}(),

			intersectsSphere: function ( sphere ) {

				return this.distanceToPoint( sphere.center ) <= sphere.radius;

			},

			distanceToPlane: function ( plane ) {

				var denominator = plane.normal.dot( this.direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( plane.distanceToPoint( this.origin ) === 0 ) {

						return 0;

					}

					// Null is preferable to undefined since undefined means.... it is undefined

					return null;

				}

				var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

				// Return if the ray never intersects the plane

				return t >= 0 ? t :  null;

			},

			intersectPlane: function ( plane, optionalTarget ) {

				var t = this.distanceToPlane( plane );

				if ( t === null ) {

					return null;

				}

				return this.at( t, optionalTarget );

			},



			intersectsPlane: function ( plane ) {

				// check if the ray lies on the plane first

				var distToPoint = plane.distanceToPoint( this.origin );

				if ( distToPoint === 0 ) {

					return true;

				}

				var denominator = plane.normal.dot( this.direction );

				if ( denominator * distToPoint < 0 ) {

					return true;

				}

				// ray origin is behind the plane (and is pointing behind it)

				return false;

			},

			intersectBox: function ( box, optionalTarget ) {

				var tmin, tmax, tymin, tymax, tzmin, tzmax;

				var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;

				var origin = this.origin;

				if ( invdirx >= 0 ) {

					tmin = ( box.min.x - origin.x ) * invdirx;
					tmax = ( box.max.x - origin.x ) * invdirx;

				} else {

					tmin = ( box.max.x - origin.x ) * invdirx;
					tmax = ( box.min.x - origin.x ) * invdirx;

				}

				if ( invdiry >= 0 ) {

					tymin = ( box.min.y - origin.y ) * invdiry;
					tymax = ( box.max.y - origin.y ) * invdiry;

				} else {

					tymin = ( box.max.y - origin.y ) * invdiry;
					tymax = ( box.min.y - origin.y ) * invdiry;

				}

				if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

				// These lines also handle the case where tmin or tmax is NaN
				// (result of 0 * Infinity). x !== x returns true if x is NaN

				if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

				if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

				if ( invdirz >= 0 ) {

					tzmin = ( box.min.z - origin.z ) * invdirz;
					tzmax = ( box.max.z - origin.z ) * invdirz;

				} else {

					tzmin = ( box.max.z - origin.z ) * invdirz;
					tzmax = ( box.min.z - origin.z ) * invdirz;

				}

				if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

				if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

				if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

				//return point closest to the ray (positive side)

				if ( tmax < 0 ) return null;

				return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

			},

			intersectsBox: ( function () {

				var v = new Vector3();

				return function intersectsBox( box ) {

					return this.intersectBox( box, v ) !== null;

				};

			} )(),

			intersectTriangle: function () {

				// Compute the offset origin, edges, and normal.
				var diff = new Vector3();
				var edge1 = new Vector3();
				var edge2 = new Vector3();
				var normal = new Vector3();

				return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

					edge1.subVectors( b, a );
					edge2.subVectors( c, a );
					normal.crossVectors( edge1, edge2 );

					// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
					// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
					//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
					//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
					//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
					var DdN = this.direction.dot( normal );
					var sign;

					if ( DdN > 0 ) {

						if ( backfaceCulling ) return null;
						sign = 1;

					} else if ( DdN < 0 ) {

						sign = - 1;
						DdN = - DdN;

					} else {

						return null;

					}

					diff.subVectors( this.origin, a );
					var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

					// b1 < 0, no intersection
					if ( DdQxE2 < 0 ) {

						return null;

					}

					var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

					// b2 < 0, no intersection
					if ( DdE1xQ < 0 ) {

						return null;

					}

					// b1+b2 > 1, no intersection
					if ( DdQxE2 + DdE1xQ > DdN ) {

						return null;

					}

					// Line intersects triangle, check if ray does.
					var QdN = - sign * diff.dot( normal );

					// t < 0, no intersection
					if ( QdN < 0 ) {

						return null;

					}

					// Ray intersects triangle.
					return this.at( QdN / DdN, optionalTarget );

				};

			}(),

			applyMatrix4: function ( matrix4 ) {

				this.direction.add( this.origin ).applyMatrix4( matrix4 );
				this.origin.applyMatrix4( matrix4 );
				this.direction.sub( this.origin );
				this.direction.normalize();

				return this;

			},

			equals: function ( ray ) {

				return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */

		function Euler( x, y, z, order ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;

		}

		Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

		Euler.DefaultOrder = 'XYZ';

		Euler.prototype = {

			constructor: Euler,

			isEuler: true,

			get x () {

				return this._x;

			},

			set x ( value ) {

				this._x = value;
				this.onChangeCallback();

			},

			get y () {

				return this._y;

			},

			set y ( value ) {

				this._y = value;
				this.onChangeCallback();

			},

			get z () {

				return this._z;

			},

			set z ( value ) {

				this._z = value;
				this.onChangeCallback();

			},

			get order () {

				return this._order;

			},

			set order ( value ) {

				this._order = value;
				this.onChangeCallback();

			},

			set: function ( x, y, z, order ) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._order = order || this._order;

				this.onChangeCallback();

				return this;

			},

			clone: function () {

				return new this.constructor( this._x, this._y, this._z, this._order );

			},

			copy: function ( euler ) {

				this._x = euler._x;
				this._y = euler._y;
				this._z = euler._z;
				this._order = euler._order;

				this.onChangeCallback();

				return this;

			},

			setFromRotationMatrix: function ( m, order, update ) {

				var clamp = _Math.clamp;

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var te = m.elements;
				var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
				var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
				var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

				order = order || this._order;

				if ( order === 'XYZ' ) {

					this._y = Math.asin( clamp( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.99999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

				} else if ( order === 'YXZ' ) {

					this._x = Math.asin( - clamp( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.99999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

				} else if ( order === 'ZXY' ) {

					this._x = Math.asin( clamp( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.99999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

				} else if ( order === 'ZYX' ) {

					this._y = Math.asin( - clamp( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.99999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

				} else if ( order === 'YZX' ) {

					this._z = Math.asin( clamp( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.99999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

				} else if ( order === 'XZY' ) {

					this._z = Math.asin( - clamp( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.99999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

				} else {

					console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

				}

				this._order = order;

				if ( update !== false ) this.onChangeCallback();

				return this;

			},

			setFromQuaternion: function () {

				var matrix;

				return function setFromQuaternion( q, order, update ) {

					if ( matrix === undefined ) matrix = new Matrix4();

					matrix.makeRotationFromQuaternion( q );

					return this.setFromRotationMatrix( matrix, order, update );

				};

			}(),

			setFromVector3: function ( v, order ) {

				return this.set( v.x, v.y, v.z, order || this._order );

			},

			reorder: function () {

				// WARNING: this discards revolution information -bhouston

				var q = new Quaternion();

				return function reorder( newOrder ) {

					q.setFromEuler( this );

					return this.setFromQuaternion( q, newOrder );

				};

			}(),

			equals: function ( euler ) {

				return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

			},

			fromArray: function ( array ) {

				this._x = array[ 0 ];
				this._y = array[ 1 ];
				this._z = array[ 2 ];
				if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

				this.onChangeCallback();

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._order;

				return array;

			},

			toVector3: function ( optionalResult ) {

				if ( optionalResult ) {

					return optionalResult.set( this._x, this._y, this._z );

				} else {

					return new Vector3( this._x, this._y, this._z );

				}

			},

			onChange: function ( callback ) {

				this.onChangeCallback = callback;

				return this;

			},

			onChangeCallback: function () {}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Layers() {

			this.mask = 1;

		}

		Layers.prototype = {

			constructor: Layers,

			set: function ( channel ) {

				this.mask = 1 << channel;

			},

			enable: function ( channel ) {

				this.mask |= 1 << channel;

			},

			toggle: function ( channel ) {

				this.mask ^= 1 << channel;

			},

			disable: function ( channel ) {

				this.mask &= ~ ( 1 << channel );

			},

			test: function ( layers ) {

				return ( this.mask & layers.mask ) !== 0;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author elephantatwork / www.elephantatwork.ch
		 */

		var object3DId = 0;

		function Object3D() {

			Object.defineProperty( this, 'id', { value: object3DId ++ } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'Object3D';

			this.parent = null;
			this.children = [];

			this.up = Object3D.DefaultUp.clone();

			var position = new Vector3();
			var rotation = new Euler();
			var quaternion = new Quaternion();
			var scale = new Vector3( 1, 1, 1 );

			function onRotationChange() {

				quaternion.setFromEuler( rotation, false );

			}

			function onQuaternionChange() {

				rotation.setFromQuaternion( quaternion, undefined, false );

			}

			rotation.onChange( onRotationChange );
			quaternion.onChange( onQuaternionChange );

			Object.defineProperties( this, {
				position: {
					enumerable: true,
					value: position
				},
				rotation: {
					enumerable: true,
					value: rotation
				},
				quaternion: {
					enumerable: true,
					value: quaternion
				},
				scale: {
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );

			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();

			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;

			this.layers = new Layers();
			this.visible = true;

			this.castShadow = false;
			this.receiveShadow = false;

			this.frustumCulled = true;
			this.renderOrder = 0;

			this.userData = {};

			this.onBeforeRender = function () {};
			this.onAfterRender = function () {};

		}

		Object3D.DefaultUp = new Vector3( 0, 1, 0 );
		Object3D.DefaultMatrixAutoUpdate = true;

		Object3D.prototype = {

			constructor: Object3D,

			isObject3D: true,

			applyMatrix: function ( matrix ) {

				this.matrix.multiplyMatrices( matrix, this.matrix );

				this.matrix.decompose( this.position, this.quaternion, this.scale );

			},

			setRotationFromAxisAngle: function ( axis, angle ) {

				// assumes axis is normalized

				this.quaternion.setFromAxisAngle( axis, angle );

			},

			setRotationFromEuler: function ( euler ) {

				this.quaternion.setFromEuler( euler, true );

			},

			setRotationFromMatrix: function ( m ) {

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				this.quaternion.setFromRotationMatrix( m );

			},

			setRotationFromQuaternion: function ( q ) {

				// assumes q is normalized

				this.quaternion.copy( q );

			},

			rotateOnAxis: function () {

				// rotate object on axis in object space
				// axis is assumed to be normalized

				var q1 = new Quaternion();

				return function rotateOnAxis( axis, angle ) {

					q1.setFromAxisAngle( axis, angle );

					this.quaternion.multiply( q1 );

					return this;

				};

			}(),

			rotateX: function () {

				var v1 = new Vector3( 1, 0, 0 );

				return function rotateX( angle ) {

					return this.rotateOnAxis( v1, angle );

				};

			}(),

			rotateY: function () {

				var v1 = new Vector3( 0, 1, 0 );

				return function rotateY( angle ) {

					return this.rotateOnAxis( v1, angle );

				};

			}(),

			rotateZ: function () {

				var v1 = new Vector3( 0, 0, 1 );

				return function rotateZ( angle ) {

					return this.rotateOnAxis( v1, angle );

				};

			}(),

			translateOnAxis: function () {

				// translate object by distance along axis in object space
				// axis is assumed to be normalized

				var v1 = new Vector3();

				return function translateOnAxis( axis, distance ) {

					v1.copy( axis ).applyQuaternion( this.quaternion );

					this.position.add( v1.multiplyScalar( distance ) );

					return this;

				};

			}(),

			translateX: function () {

				var v1 = new Vector3( 1, 0, 0 );

				return function translateX( distance ) {

					return this.translateOnAxis( v1, distance );

				};

			}(),

			translateY: function () {

				var v1 = new Vector3( 0, 1, 0 );

				return function translateY( distance ) {

					return this.translateOnAxis( v1, distance );

				};

			}(),

			translateZ: function () {

				var v1 = new Vector3( 0, 0, 1 );

				return function translateZ( distance ) {

					return this.translateOnAxis( v1, distance );

				};

			}(),

			localToWorld: function ( vector ) {

				return vector.applyMatrix4( this.matrixWorld );

			},

			worldToLocal: function () {

				var m1 = new Matrix4();

				return function worldToLocal( vector ) {

					return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

				};

			}(),

			lookAt: function () {

				// This routine does not support objects with rotated and/or translated parent(s)

				var m1 = new Matrix4();

				return function lookAt( vector ) {

					m1.lookAt( vector, this.position, this.up );

					this.quaternion.setFromRotationMatrix( m1 );

				};

			}(),

			add: function ( object ) {

				if ( arguments.length > 1 ) {

					for ( var i = 0; i < arguments.length; i ++ ) {

						this.add( arguments[ i ] );

					}

					return this;

				}

				if ( object === this ) {

					console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
					return this;

				}

				if ( ( object && object.isObject3D ) ) {

					if ( object.parent !== null ) {

						object.parent.remove( object );

					}

					object.parent = this;
					object.dispatchEvent( { type: 'added' } );

					this.children.push( object );

				} else {

					console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

				}

				return this;

			},

			remove: function ( object ) {

				if ( arguments.length > 1 ) {

					for ( var i = 0; i < arguments.length; i ++ ) {

						this.remove( arguments[ i ] );

					}

				}

				var index = this.children.indexOf( object );

				if ( index !== - 1 ) {

					object.parent = null;

					object.dispatchEvent( { type: 'removed' } );

					this.children.splice( index, 1 );

				}

			},

			getObjectById: function ( id ) {

				return this.getObjectByProperty( 'id', id );

			},

			getObjectByName: function ( name ) {

				return this.getObjectByProperty( 'name', name );

			},

			getObjectByProperty: function ( name, value ) {

				if ( this[ name ] === value ) return this;

				for ( var i = 0, l = this.children.length; i < l; i ++ ) {

					var child = this.children[ i ];
					var object = child.getObjectByProperty( name, value );

					if ( object !== undefined ) {

						return object;

					}

				}

				return undefined;

			},

			getWorldPosition: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.updateMatrixWorld( true );

				return result.setFromMatrixPosition( this.matrixWorld );

			},

			getWorldQuaternion: function () {

				var position = new Vector3();
				var scale = new Vector3();

				return function getWorldQuaternion( optionalTarget ) {

					var result = optionalTarget || new Quaternion();

					this.updateMatrixWorld( true );

					this.matrixWorld.decompose( position, result, scale );

					return result;

				};

			}(),

			getWorldRotation: function () {

				var quaternion = new Quaternion();

				return function getWorldRotation( optionalTarget ) {

					var result = optionalTarget || new Euler();

					this.getWorldQuaternion( quaternion );

					return result.setFromQuaternion( quaternion, this.rotation.order, false );

				};

			}(),

			getWorldScale: function () {

				var position = new Vector3();
				var quaternion = new Quaternion();

				return function getWorldScale( optionalTarget ) {

					var result = optionalTarget || new Vector3();

					this.updateMatrixWorld( true );

					this.matrixWorld.decompose( position, quaternion, result );

					return result;

				};

			}(),

			getWorldDirection: function () {

				var quaternion = new Quaternion();

				return function getWorldDirection( optionalTarget ) {

					var result = optionalTarget || new Vector3();

					this.getWorldQuaternion( quaternion );

					return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

				};

			}(),

			raycast: function () {},

			traverse: function ( callback ) {

				callback( this );

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].traverse( callback );

				}

			},

			traverseVisible: function ( callback ) {

				if ( this.visible === false ) return;

				callback( this );

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].traverseVisible( callback );

				}

			},

			traverseAncestors: function ( callback ) {

				var parent = this.parent;

				if ( parent !== null ) {

					callback( parent );

					parent.traverseAncestors( callback );

				}

			},

			updateMatrix: function () {

				this.matrix.compose( this.position, this.quaternion, this.scale );

				this.matrixWorldNeedsUpdate = true;

			},

			updateMatrixWorld: function ( force ) {

				if ( this.matrixAutoUpdate === true ) this.updateMatrix();

				if ( this.matrixWorldNeedsUpdate === true || force === true ) {

					if ( this.parent === null ) {

						this.matrixWorld.copy( this.matrix );

					} else {

						this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

					}

					this.matrixWorldNeedsUpdate = false;

					force = true;

				}

				// update children

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( force );

				}

			},

			toJSON: function ( meta ) {

				// meta is '' when called from JSON.stringify
				var isRootObject = ( meta === undefined || meta === '' );

				var output = {};

				// meta is a hash used to collect geometries, materials.
				// not providing it implies that this is the root object
				// being serialized.
				if ( isRootObject ) {

					// initialize meta obj
					meta = {
						geometries: {},
						materials: {},
						textures: {},
						images: {}
					};

					output.metadata = {
						version: 4.4,
						type: 'Object',
						generator: 'Object3D.toJSON'
					};

				}

				// standard Object3D serialization

				var object = {};

				object.uuid = this.uuid;
				object.type = this.type;

				if ( this.name !== '' ) object.name = this.name;
				if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
				if ( this.castShadow === true ) object.castShadow = true;
				if ( this.receiveShadow === true ) object.receiveShadow = true;
				if ( this.visible === false ) object.visible = false;

				object.matrix = this.matrix.toArray();

				//

				if ( this.geometry !== undefined ) {

					if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

						meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

					}

					object.geometry = this.geometry.uuid;

				}

				if ( this.material !== undefined ) {

					if ( meta.materials[ this.material.uuid ] === undefined ) {

						meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

					}

					object.material = this.material.uuid;

				}

				//

				if ( this.children.length > 0 ) {

					object.children = [];

					for ( var i = 0; i < this.children.length; i ++ ) {

						object.children.push( this.children[ i ].toJSON( meta ).object );

					}

				}

				if ( isRootObject ) {

					var geometries = extractFromCache( meta.geometries );
					var materials = extractFromCache( meta.materials );
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );

					if ( geometries.length > 0 ) output.geometries = geometries;
					if ( materials.length > 0 ) output.materials = materials;
					if ( textures.length > 0 ) output.textures = textures;
					if ( images.length > 0 ) output.images = images;

				}

				output.object = object;

				return output;

				// extract data from the cache hash
				// remove metadata on each item
				// and return as array
				function extractFromCache( cache ) {

					var values = [];
					for ( var key in cache ) {

						var data = cache[ key ];
						delete data.metadata;
						values.push( data );

					}
					return values;

				}

			},

			clone: function ( recursive ) {

				return new this.constructor().copy( this, recursive );

			},

			copy: function ( source, recursive ) {

				if ( recursive === undefined ) recursive = true;

				this.name = source.name;

				this.up.copy( source.up );

				this.position.copy( source.position );
				this.quaternion.copy( source.quaternion );
				this.scale.copy( source.scale );

				this.matrix.copy( source.matrix );
				this.matrixWorld.copy( source.matrixWorld );

				this.matrixAutoUpdate = source.matrixAutoUpdate;
				this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

				this.layers.mask = source.layers.mask;
				this.visible = source.visible;

				this.castShadow = source.castShadow;
				this.receiveShadow = source.receiveShadow;

				this.frustumCulled = source.frustumCulled;
				this.renderOrder = source.renderOrder;

				this.userData = JSON.parse( JSON.stringify( source.userData ) );

				if ( recursive === true ) {

					for ( var i = 0; i < source.children.length; i ++ ) {

						var child = source.children[ i ];
						this.add( child.clone() );

					}

				}

				return this;

			}

		};

		Object.assign( Object3D.prototype, EventDispatcher.prototype );

		/**
		 * @author bhouston / http://clara.io
		 */

		function Line3( start, end ) {

			this.start = ( start !== undefined ) ? start : new Vector3();
			this.end = ( end !== undefined ) ? end : new Vector3();

		}

		Line3.prototype = {

			constructor: Line3,

			set: function ( start, end ) {

				this.start.copy( start );
				this.end.copy( end );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( line ) {

				this.start.copy( line.start );
				this.end.copy( line.end );

				return this;

			},

			getCenter: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

			},

			delta: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.subVectors( this.end, this.start );

			},

			distanceSq: function () {

				return this.start.distanceToSquared( this.end );

			},

			distance: function () {

				return this.start.distanceTo( this.end );

			},

			at: function ( t, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				return this.delta( result ).multiplyScalar( t ).add( this.start );

			},

			closestPointToPointParameter: function () {

				var startP = new Vector3();
				var startEnd = new Vector3();

				return function closestPointToPointParameter( point, clampToLine ) {

					startP.subVectors( point, this.start );
					startEnd.subVectors( this.end, this.start );

					var startEnd2 = startEnd.dot( startEnd );
					var startEnd_startP = startEnd.dot( startP );

					var t = startEnd_startP / startEnd2;

					if ( clampToLine ) {

						t = _Math.clamp( t, 0, 1 );

					}

					return t;

				};

			}(),

			closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

				var t = this.closestPointToPointParameter( point, clampToLine );

				var result = optionalTarget || new Vector3();

				return this.delta( result ).multiplyScalar( t ).add( this.start );

			},

			applyMatrix4: function ( matrix ) {

				this.start.applyMatrix4( matrix );
				this.end.applyMatrix4( matrix );

				return this;

			},

			equals: function ( line ) {

				return line.start.equals( this.start ) && line.end.equals( this.end );

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Triangle( a, b, c ) {

			this.a = ( a !== undefined ) ? a : new Vector3();
			this.b = ( b !== undefined ) ? b : new Vector3();
			this.c = ( c !== undefined ) ? c : new Vector3();

		}

		Triangle.normal = function () {

			var v0 = new Vector3();

			return function normal( a, b, c, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				result.subVectors( c, b );
				v0.subVectors( a, b );
				result.cross( v0 );

				var resultLengthSq = result.lengthSq();
				if ( resultLengthSq > 0 ) {

					return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

				}

				return result.set( 0, 0, 0 );

			};

		}();

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		Triangle.barycoordFromPoint = function () {

			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );

				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				var result = optionalTarget || new Vector3();

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return result.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return result.set( 1 - u - v, v, u );

			};

		}();

		Triangle.containsPoint = function () {

			var v1 = new Vector3();

			return function containsPoint( point, a, b, c ) {

				var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

				return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

			};

		}();

		Triangle.prototype = {

			constructor: Triangle,

			set: function ( a, b, c ) {

				this.a.copy( a );
				this.b.copy( b );
				this.c.copy( c );

				return this;

			},

			setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

				this.a.copy( points[ i0 ] );
				this.b.copy( points[ i1 ] );
				this.c.copy( points[ i2 ] );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( triangle ) {

				this.a.copy( triangle.a );
				this.b.copy( triangle.b );
				this.c.copy( triangle.c );

				return this;

			},

			area: function () {

				var v0 = new Vector3();
				var v1 = new Vector3();

				return function area() {

					v0.subVectors( this.c, this.b );
					v1.subVectors( this.a, this.b );

					return v0.cross( v1 ).length() * 0.5;

				};

			}(),

			midpoint: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

			},

			normal: function ( optionalTarget ) {

				return Triangle.normal( this.a, this.b, this.c, optionalTarget );

			},

			plane: function ( optionalTarget ) {

				var result = optionalTarget || new Plane();

				return result.setFromCoplanarPoints( this.a, this.b, this.c );

			},

			barycoordFromPoint: function ( point, optionalTarget ) {

				return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

			},

			containsPoint: function ( point ) {

				return Triangle.containsPoint( point, this.a, this.b, this.c );

			},

			closestPointToPoint: function () {

				var plane, edgeList, projectedPoint, closestPoint;

				return function closestPointToPoint( point, optionalTarget ) {

					if ( plane === undefined ) {

						plane = new Plane();
						edgeList = [ new Line3(), new Line3(), new Line3() ];
						projectedPoint = new Vector3();
						closestPoint = new Vector3();

					}

					var result = optionalTarget || new Vector3();
					var minDistance = Infinity;

					// project the point onto the plane of the triangle

					plane.setFromCoplanarPoints( this.a, this.b, this.c );
					plane.projectPoint( point, projectedPoint );

					// check if the projection lies within the triangle

					if( this.containsPoint( projectedPoint ) === true ) {

						// if so, this is the closest point

						result.copy( projectedPoint );

					} else {

						// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

						edgeList[ 0 ].set( this.a, this.b );
						edgeList[ 1 ].set( this.b, this.c );
						edgeList[ 2 ].set( this.c, this.a );

						for( var i = 0; i < edgeList.length; i ++ ) {

							edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

							var distance = projectedPoint.distanceToSquared( closestPoint );

							if( distance < minDistance ) {

								minDistance = distance;

								result.copy( closestPoint );

							}

						}

					}

					return result;

				};

			}(),

			equals: function ( triangle ) {

				return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Face3( a, b, c, normal, color, materialIndex ) {

			this.a = a;
			this.b = b;
			this.c = c;

			this.normal = (normal && normal.isVector3) ? normal : new Vector3();
			this.vertexNormals = Array.isArray( normal ) ? normal : [];

			this.color = (color && color.isColor) ? color : new Color();
			this.vertexColors = Array.isArray( color ) ? color : [];

			this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

		}

		Face3.prototype = {

			constructor: Face3,

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.a = source.a;
				this.b = source.b;
				this.c = source.c;

				this.normal.copy( source.normal );
				this.color.copy( source.color );

				this.materialIndex = source.materialIndex;

				for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

					this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

				}

				for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

					this.vertexColors[ i ] = source.vertexColors[ i ].clone();

				}

				return this;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  shading: THREE.SmoothShading,
		 *  depthTest: <bool>,
		 *  depthWrite: <bool>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>
		 * }
		 */

		function MeshBasicMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;

			this.lights = false;

			this.setValues( parameters );

		}

		MeshBasicMaterial.prototype = Object.create( Material.prototype );
		MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

		MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

		MeshBasicMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferAttribute( array, itemSize, normalized ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.uuid = _Math.generateUUID();

			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;

			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };

			this.onUploadCallback = function () {};

			this.version = 0;

		}

		BufferAttribute.prototype = {

			constructor: BufferAttribute,

			isBufferAttribute: true,

			set needsUpdate( value ) {

				if ( value === true ) this.version ++;

			},

			setArray: function ( array ) {

				if ( Array.isArray( array ) ) {

					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

				}

				this.count = array !== undefined ? array.length / this.itemSize : 0;
				this.array = array;

			},

			setDynamic: function ( value ) {

				this.dynamic = value;

				return this;

			},

			copy: function ( source ) {

				this.array = new source.array.constructor( source.array );
				this.itemSize = source.itemSize;
				this.count = source.count;
				this.normalized = source.normalized;

				this.dynamic = source.dynamic;

				return this;

			},

			copyAt: function ( index1, attribute, index2 ) {

				index1 *= this.itemSize;
				index2 *= attribute.itemSize;

				for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

					this.array[ index1 + i ] = attribute.array[ index2 + i ];

				}

				return this;

			},

			copyArray: function ( array ) {

				this.array.set( array );

				return this;

			},

			copyColorsArray: function ( colors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = colors.length; i < l; i ++ ) {

					var color = colors[ i ];

					if ( color === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
						color = new Color();

					}

					array[ offset ++ ] = color.r;
					array[ offset ++ ] = color.g;
					array[ offset ++ ] = color.b;

				}

				return this;

			},

			copyIndicesArray: function ( indices ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					var index = indices[ i ];

					array[ offset ++ ] = index.a;
					array[ offset ++ ] = index.b;
					array[ offset ++ ] = index.c;

				}

				return this;

			},

			copyVector2sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
						vector = new Vector2();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;

				}

				return this;

			},

			copyVector3sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
						vector = new Vector3();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;

				}

				return this;

			},

			copyVector4sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
						vector = new Vector4();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
					array[ offset ++ ] = vector.w;

				}

				return this;

			},

			set: function ( value, offset ) {

				if ( offset === undefined ) offset = 0;

				this.array.set( value, offset );

				return this;

			},

			getX: function ( index ) {

				return this.array[ index * this.itemSize ];

			},

			setX: function ( index, x ) {

				this.array[ index * this.itemSize ] = x;

				return this;

			},

			getY: function ( index ) {

				return this.array[ index * this.itemSize + 1 ];

			},

			setY: function ( index, y ) {

				this.array[ index * this.itemSize + 1 ] = y;

				return this;

			},

			getZ: function ( index ) {

				return this.array[ index * this.itemSize + 2 ];

			},

			setZ: function ( index, z ) {

				this.array[ index * this.itemSize + 2 ] = z;

				return this;

			},

			getW: function ( index ) {

				return this.array[ index * this.itemSize + 3 ];

			},

			setW: function ( index, w ) {

				this.array[ index * this.itemSize + 3 ] = w;

				return this;

			},

			setXY: function ( index, x, y ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;

				return this;

			},

			setXYZ: function ( index, x, y, z ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;

				return this;

			},

			setXYZW: function ( index, x, y, z, w ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
				this.array[ index + 3 ] = w;

				return this;

			},

			onUpload: function ( callback ) {

				this.onUploadCallback = callback;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			}

		};

		//

		function Int8BufferAttribute( array, itemSize ) {

			BufferAttribute.call( this, new Int8Array( array ), itemSize );

		}

		Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


		function Uint8BufferAttribute( array, itemSize ) {

			BufferAttribute.call( this, new Uint8Array( array ), itemSize );

		}

		Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


		function Uint8ClampedBufferAttribute( array, itemSize ) {

			BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize );

		}

		Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


		function Int16BufferAttribute( array, itemSize ) {

			BufferAttribute.call( this, new Int16Array( array ), itemSize );

		}

		Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


		function Uint16BufferAttribute( array, itemSize ) {

			BufferAttribute.call( this, new Uint16Array( array ), itemSize );

		}

		Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


		function Int32BufferAttribute( array, itemSize ) {

			BufferAttribute.call( this, new Int32Array( array ), itemSize );

		}

		Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


		function Uint32BufferAttribute( array, itemSize ) {

			BufferAttribute.call( this, new Uint32Array( array ), itemSize );

		}

		Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


		function Float32BufferAttribute( array, itemSize ) {

			BufferAttribute.call( this, new Float32Array( array ), itemSize );

		}

		Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


		function Float64BufferAttribute( array, itemSize ) {

			BufferAttribute.call( this, new Float64Array( array ), itemSize );

		}

		Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function DirectGeometry() {

			this.indices = [];
			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];

			this.groups = [];

			this.morphTargets = {};

			this.skinWeights = [];
			this.skinIndices = [];

			// this.lineDistances = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			// update flags

			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;

		}

		Object.assign( DirectGeometry.prototype, {

			computeGroups: function ( geometry ) {

				var group;
				var groups = [];
				var materialIndex = undefined;

				var faces = geometry.faces;

				for ( var i = 0; i < faces.length; i ++ ) {

					var face = faces[ i ];

					// materials

					if ( face.materialIndex !== materialIndex ) {

						materialIndex = face.materialIndex;

						if ( group !== undefined ) {

							group.count = ( i * 3 ) - group.start;
							groups.push( group );

						}

						group = {
							start: i * 3,
							materialIndex: materialIndex
						};

					}

				}

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				this.groups = groups;

			},

			fromGeometry: function ( geometry ) {

				var faces = geometry.faces;
				var vertices = geometry.vertices;
				var faceVertexUvs = geometry.faceVertexUvs;

				var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
				var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

				// morphs

				var morphTargets = geometry.morphTargets;
				var morphTargetsLength = morphTargets.length;

				var morphTargetsPosition;

				if ( morphTargetsLength > 0 ) {

					morphTargetsPosition = [];

					for ( var i = 0; i < morphTargetsLength; i ++ ) {

						morphTargetsPosition[ i ] = [];

					}

					this.morphTargets.position = morphTargetsPosition;

				}

				var morphNormals = geometry.morphNormals;
				var morphNormalsLength = morphNormals.length;

				var morphTargetsNormal;

				if ( morphNormalsLength > 0 ) {

					morphTargetsNormal = [];

					for ( var i = 0; i < morphNormalsLength; i ++ ) {

						morphTargetsNormal[ i ] = [];

					}

					this.morphTargets.normal = morphTargetsNormal;

				}

				// skins

				var skinIndices = geometry.skinIndices;
				var skinWeights = geometry.skinWeights;

				var hasSkinIndices = skinIndices.length === vertices.length;
				var hasSkinWeights = skinWeights.length === vertices.length;

				//

				for ( var i = 0; i < faces.length; i ++ ) {

					var face = faces[ i ];

					this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

					} else {

						var normal = face.normal;

						this.normals.push( normal, normal, normal );

					}

					var vertexColors = face.vertexColors;

					if ( vertexColors.length === 3 ) {

						this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

					} else {

						var color = face.color;

						this.colors.push( color, color, color );

					}

					if ( hasFaceVertexUv === true ) {

						var vertexUvs = faceVertexUvs[ 0 ][ i ];

						if ( vertexUvs !== undefined ) {

							this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

						} else {

							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

							this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

						}

					}

					if ( hasFaceVertexUv2 === true ) {

						var vertexUvs = faceVertexUvs[ 1 ][ i ];

						if ( vertexUvs !== undefined ) {

							this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

						} else {

							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

							this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

						}

					}

					// morphs

					for ( var j = 0; j < morphTargetsLength; j ++ ) {

						var morphTarget = morphTargets[ j ].vertices;

						morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

					}

					for ( var j = 0; j < morphNormalsLength; j ++ ) {

						var morphNormal = morphNormals[ j ].vertexNormals[ i ];

						morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

					}

					// skins

					if ( hasSkinIndices ) {

						this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

					}

					if ( hasSkinWeights ) {

						this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

					}

				}

				this.computeGroups( geometry );

				this.verticesNeedUpdate = geometry.verticesNeedUpdate;
				this.normalsNeedUpdate = geometry.normalsNeedUpdate;
				this.colorsNeedUpdate = geometry.colorsNeedUpdate;
				this.uvsNeedUpdate = geometry.uvsNeedUpdate;
				this.groupsNeedUpdate = geometry.groupsNeedUpdate;

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author bhouston / http://clara.io
		 */

		var count = 0;
		function GeometryIdCount() { return count++; }

		function Geometry() {

			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'Geometry';

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];

			this.morphTargets = [];
			this.morphNormals = [];

			this.skinWeights = [];
			this.skinIndices = [];

			this.lineDistances = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			// update flags

			this.elementsNeedUpdate = false;
			this.verticesNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.lineDistancesNeedUpdate = false;
			this.groupsNeedUpdate = false;

		}

		Geometry.prototype = {

			constructor: Geometry,

			isGeometry: true,

			applyMatrix: function ( matrix ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

					var vertex = this.vertices[ i ];
					vertex.applyMatrix4( matrix );

				}

				for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

					var face = this.faces[ i ];
					face.normal.applyMatrix3( normalMatrix ).normalize();

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

					}

				}

				if ( this.boundingBox !== null ) {

					this.computeBoundingBox();

				}

				if ( this.boundingSphere !== null ) {

					this.computeBoundingSphere();

				}

				this.verticesNeedUpdate = true;
				this.normalsNeedUpdate = true;

				return this;

			},

			rotateX: function () {

				// rotate geometry around world x-axis

				var m1;

				return function rotateX( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationX( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateY: function () {

				// rotate geometry around world y-axis

				var m1;

				return function rotateY( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationY( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateZ: function () {

				// rotate geometry around world z-axis

				var m1;

				return function rotateZ( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationZ( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			translate: function () {

				// translate geometry

				var m1;

				return function translate( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeTranslation( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			scale: function () {

				// scale geometry

				var m1;

				return function scale( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeScale( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			lookAt: function () {

				var obj;

				return function lookAt( vector ) {

					if ( obj === undefined ) obj = new Object3D();

					obj.lookAt( vector );

					obj.updateMatrix();

					this.applyMatrix( obj.matrix );

				};

			}(),

			fromBufferGeometry: function ( geometry ) {

				var scope = this;

				var indices = geometry.index !== null ? geometry.index.array : undefined;
				var attributes = geometry.attributes;

				var positions = attributes.position.array;
				var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
				var colors = attributes.color !== undefined ? attributes.color.array : undefined;
				var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
				var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

				if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

				var tempNormals = [];
				var tempUVs = [];
				var tempUVs2 = [];

				for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

					scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

					if ( normals !== undefined ) {

						tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

					}

					if ( colors !== undefined ) {

						scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

					}

					if ( uvs !== undefined ) {

						tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

					}

					if ( uvs2 !== undefined ) {

						tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

					}

				}

				function addFace( a, b, c, materialIndex ) {

					var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
					var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

					var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

					scope.faces.push( face );

					if ( uvs !== undefined ) {

						scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

					}

					if ( uvs2 !== undefined ) {

						scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

					}

				}

				if ( indices !== undefined ) {

					var groups = geometry.groups;

					if ( groups.length > 0 ) {

						for ( var i = 0; i < groups.length; i ++ ) {

							var group = groups[ i ];

							var start = group.start;
							var count = group.count;

							for ( var j = start, jl = start + count; j < jl; j += 3 ) {

								addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

							}

						}

					} else {

						for ( var i = 0; i < indices.length; i += 3 ) {

							addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

						}

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

				this.computeFaceNormals();

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				return this;

			},

			center: function () {

				this.computeBoundingBox();

				var offset = this.boundingBox.getCenter().negate();

				this.translate( offset.x, offset.y, offset.z );

				return offset;

			},

			normalize: function () {

				this.computeBoundingSphere();

				var center = this.boundingSphere.center;
				var radius = this.boundingSphere.radius;

				var s = radius === 0 ? 1 : 1.0 / radius;

				var matrix = new Matrix4();
				matrix.set(
					s, 0, 0, - s * center.x,
					0, s, 0, - s * center.y,
					0, 0, s, - s * center.z,
					0, 0, 0, 1
				);

				this.applyMatrix( matrix );

				return this;

			},

			computeFaceNormals: function () {

				var cb = new Vector3(), ab = new Vector3();

				for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

					var face = this.faces[ f ];

					var vA = this.vertices[ face.a ];
					var vB = this.vertices[ face.b ];
					var vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					cb.normalize();

					face.normal.copy( cb );

				}

			},

			computeVertexNormals: function ( areaWeighted ) {

				if ( areaWeighted === undefined ) areaWeighted = true;

				var v, vl, f, fl, face, vertices;

				vertices = new Array( this.vertices.length );

				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

					vertices[ v ] = new Vector3();

				}

				if ( areaWeighted ) {

					// vertex normals weighted by triangle areas
					// http://www.iquilezles.org/www/articles/normals/normals.htm

					var vA, vB, vC;
					var cb = new Vector3(), ab = new Vector3();

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];

						cb.subVectors( vC, vB );
						ab.subVectors( vA, vB );
						cb.cross( ab );

						vertices[ face.a ].add( cb );
						vertices[ face.b ].add( cb );
						vertices[ face.c ].add( cb );

					}

				} else {

					this.computeFaceNormals();

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );

					}

				}

				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

					vertices[ v ].normalize();

				}

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						vertexNormals[ 0 ].copy( vertices[ face.a ] );
						vertexNormals[ 1 ].copy( vertices[ face.b ] );
						vertexNormals[ 2 ].copy( vertices[ face.c ] );

					} else {

						vertexNormals[ 0 ] = vertices[ face.a ].clone();
						vertexNormals[ 1 ] = vertices[ face.b ].clone();
						vertexNormals[ 2 ] = vertices[ face.c ].clone();

					}

				}

				if ( this.faces.length > 0 ) {

					this.normalsNeedUpdate = true;

				}

			},

			computeFlatVertexNormals: function () {

				var f, fl, face;

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						vertexNormals[ 0 ].copy( face.normal );
						vertexNormals[ 1 ].copy( face.normal );
						vertexNormals[ 2 ].copy( face.normal );

					} else {

						vertexNormals[ 0 ] = face.normal.clone();
						vertexNormals[ 1 ] = face.normal.clone();
						vertexNormals[ 2 ] = face.normal.clone();

					}

				}

				if ( this.faces.length > 0 ) {

					this.normalsNeedUpdate = true;

				}

			},

			computeMorphNormals: function () {

				var i, il, f, fl, face;

				// save original normals
				// - create temp variables on first access
				//   otherwise just copy (for faster repeated calls)

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					if ( ! face.__originalFaceNormal ) {

						face.__originalFaceNormal = face.normal.clone();

					} else {

						face.__originalFaceNormal.copy( face.normal );

					}

					if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

					for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

						if ( ! face.__originalVertexNormals[ i ] ) {

							face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

						} else {

							face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

						}

					}

				}

				// use temp geometry to compute face and vertex normals for each morph

				var tmpGeo = new Geometry();
				tmpGeo.faces = this.faces;

				for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

					// create on first access

					if ( ! this.morphNormals[ i ] ) {

						this.morphNormals[ i ] = {};
						this.morphNormals[ i ].faceNormals = [];
						this.morphNormals[ i ].vertexNormals = [];

						var dstNormalsFace = this.morphNormals[ i ].faceNormals;
						var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

						var faceNormal, vertexNormals;

						for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

							faceNormal = new Vector3();
							vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

							dstNormalsFace.push( faceNormal );
							dstNormalsVertex.push( vertexNormals );

						}

					}

					var morphNormals = this.morphNormals[ i ];

					// set vertices to morph target

					tmpGeo.vertices = this.morphTargets[ i ].vertices;

					// compute morph normals

					tmpGeo.computeFaceNormals();
					tmpGeo.computeVertexNormals();

					// store morph normals

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						faceNormal = morphNormals.faceNormals[ f ];
						vertexNormals = morphNormals.vertexNormals[ f ];

						faceNormal.copy( face.normal );

						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );

					}

				}

				// restore original normals

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					face.normal = face.__originalFaceNormal;
					face.vertexNormals = face.__originalVertexNormals;

				}

			},

			computeLineDistances: function () {

				var d = 0;
				var vertices = this.vertices;

				for ( var i = 0, il = vertices.length; i < il; i ++ ) {

					if ( i > 0 ) {

						d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

					}

					this.lineDistances[ i ] = d;

				}

			},

			computeBoundingBox: function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				this.boundingBox.setFromPoints( this.vertices );

			},

			computeBoundingSphere: function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				this.boundingSphere.setFromPoints( this.vertices );

			},

			merge: function ( geometry, matrix, materialIndexOffset ) {

				if ( ( geometry && geometry.isGeometry ) === false ) {

					console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
					return;

				}

				var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;

				if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

				if ( matrix !== undefined ) {

					normalMatrix = new Matrix3().getNormalMatrix( matrix );

				}

				// vertices

				for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

					var vertex = vertices2[ i ];

					var vertexCopy = vertex.clone();

					if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

					vertices1.push( vertexCopy );

				}

				// colors

				for ( var i = 0, il = colors2.length; i < il; i ++ ) {

					colors1.push( colors2[ i ].clone() );

				}

				// faces

				for ( i = 0, il = faces2.length; i < il; i ++ ) {

					var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

					faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
					faceCopy.normal.copy( face.normal );

					if ( normalMatrix !== undefined ) {

						faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

					}

					for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

						normal = faceVertexNormals[ j ].clone();

						if ( normalMatrix !== undefined ) {

							normal.applyMatrix3( normalMatrix ).normalize();

						}

						faceCopy.vertexNormals.push( normal );

					}

					faceCopy.color.copy( face.color );

					for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

						color = faceVertexColors[ j ];
						faceCopy.vertexColors.push( color.clone() );

					}

					faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

					faces1.push( faceCopy );

				}

				// uvs

				for ( i = 0, il = uvs2.length; i < il; i ++ ) {

					var uv = uvs2[ i ], uvCopy = [];

					if ( uv === undefined ) {

						continue;

					}

					for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

						uvCopy.push( uv[ j ].clone() );

					}

					uvs1.push( uvCopy );

				}

			},

			mergeMesh: function ( mesh ) {

				if ( ( mesh && mesh.isMesh ) === false ) {

					console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
					return;

				}

				mesh.matrixAutoUpdate && mesh.updateMatrix();

				this.merge( mesh.geometry, mesh.matrix );

			},

			/*
			 * Checks for duplicate vertices with hashmap.
			 * Duplicated vertices are removed
			 * and faces' vertices are updated.
			 */

			mergeVertices: function () {

				var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
				var unique = [], changes = [];

				var v, key;
				var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
				var precision = Math.pow( 10, precisionPoints );
				var i, il, face;
				var indices, j, jl;

				for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

					v = this.vertices[ i ];
					key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

					if ( verticesMap[ key ] === undefined ) {

						verticesMap[ key ] = i;
						unique.push( this.vertices[ i ] );
						changes[ i ] = unique.length - 1;

					} else {

						//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
						changes[ i ] = changes[ verticesMap[ key ] ];

					}

				}


				// if faces are completely degenerate after merging vertices, we
				// have to remove them from the geometry.
				var faceIndicesToRemove = [];

				for ( i = 0, il = this.faces.length; i < il; i ++ ) {

					face = this.faces[ i ];

					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];

					indices = [ face.a, face.b, face.c ];

					// if any duplicate vertices are found in a Face3
					// we have to remove the face as nothing can be saved
					for ( var n = 0; n < 3; n ++ ) {

						if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

							faceIndicesToRemove.push( i );
							break;

						}

					}

				}

				for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

					var idx = faceIndicesToRemove[ i ];

					this.faces.splice( idx, 1 );

					for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

						this.faceVertexUvs[ j ].splice( idx, 1 );

					}

				}

				// Use unique set of vertices

				var diff = this.vertices.length - unique.length;
				this.vertices = unique;
				return diff;

			},

			sortFacesByMaterialIndex: function () {

				var faces = this.faces;
				var length = faces.length;

				// tag faces

				for ( var i = 0; i < length; i ++ ) {

					faces[ i ]._id = i;

				}

				// sort faces

				function materialIndexSort( a, b ) {

					return a.materialIndex - b.materialIndex;

				}

				faces.sort( materialIndexSort );

				// sort uvs

				var uvs1 = this.faceVertexUvs[ 0 ];
				var uvs2 = this.faceVertexUvs[ 1 ];

				var newUvs1, newUvs2;

				if ( uvs1 && uvs1.length === length ) newUvs1 = [];
				if ( uvs2 && uvs2.length === length ) newUvs2 = [];

				for ( var i = 0; i < length; i ++ ) {

					var id = faces[ i ]._id;

					if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
					if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

				}

				if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
				if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

			},

			toJSON: function () {

				var data = {
					metadata: {
						version: 4.4,
						type: 'Geometry',
						generator: 'Geometry.toJSON'
					}
				};

				// standard Geometry serialization

				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;

				if ( this.parameters !== undefined ) {

					var parameters = this.parameters;

					for ( var key in parameters ) {

						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

					}

					return data;

				}

				var vertices = [];

				for ( var i = 0; i < this.vertices.length; i ++ ) {

					var vertex = this.vertices[ i ];
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

				var faces = [];
				var normals = [];
				var normalsHash = {};
				var colors = [];
				var colorsHash = {};
				var uvs = [];
				var uvsHash = {};

				for ( var i = 0; i < this.faces.length; i ++ ) {

					var face = this.faces[ i ];

					var hasMaterial = true;
					var hasFaceUv = false; // deprecated
					var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
					var hasFaceNormal = face.normal.length() > 0;
					var hasFaceVertexNormal = face.vertexNormals.length > 0;
					var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
					var hasFaceVertexColor = face.vertexColors.length > 0;

					var faceType = 0;

					faceType = setBit( faceType, 0, 0 ); // isQuad
					faceType = setBit( faceType, 1, hasMaterial );
					faceType = setBit( faceType, 2, hasFaceUv );
					faceType = setBit( faceType, 3, hasFaceVertexUv );
					faceType = setBit( faceType, 4, hasFaceNormal );
					faceType = setBit( faceType, 5, hasFaceVertexNormal );
					faceType = setBit( faceType, 6, hasFaceColor );
					faceType = setBit( faceType, 7, hasFaceVertexColor );

					faces.push( faceType );
					faces.push( face.a, face.b, face.c );
					faces.push( face.materialIndex );

					if ( hasFaceVertexUv ) {

						var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

						faces.push(
							getUvIndex( faceVertexUvs[ 0 ] ),
							getUvIndex( faceVertexUvs[ 1 ] ),
							getUvIndex( faceVertexUvs[ 2 ] )
						);

					}

					if ( hasFaceNormal ) {

						faces.push( getNormalIndex( face.normal ) );

					}

					if ( hasFaceVertexNormal ) {

						var vertexNormals = face.vertexNormals;

						faces.push(
							getNormalIndex( vertexNormals[ 0 ] ),
							getNormalIndex( vertexNormals[ 1 ] ),
							getNormalIndex( vertexNormals[ 2 ] )
						);

					}

					if ( hasFaceColor ) {

						faces.push( getColorIndex( face.color ) );

					}

					if ( hasFaceVertexColor ) {

						var vertexColors = face.vertexColors;

						faces.push(
							getColorIndex( vertexColors[ 0 ] ),
							getColorIndex( vertexColors[ 1 ] ),
							getColorIndex( vertexColors[ 2 ] )
						);

					}

				}

				function setBit( value, position, enabled ) {

					return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

				}

				function getNormalIndex( normal ) {

					var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

					if ( normalsHash[ hash ] !== undefined ) {

						return normalsHash[ hash ];

					}

					normalsHash[ hash ] = normals.length / 3;
					normals.push( normal.x, normal.y, normal.z );

					return normalsHash[ hash ];

				}

				function getColorIndex( color ) {

					var hash = color.r.toString() + color.g.toString() + color.b.toString();

					if ( colorsHash[ hash ] !== undefined ) {

						return colorsHash[ hash ];

					}

					colorsHash[ hash ] = colors.length;
					colors.push( color.getHex() );

					return colorsHash[ hash ];

				}

				function getUvIndex( uv ) {

					var hash = uv.x.toString() + uv.y.toString();

					if ( uvsHash[ hash ] !== undefined ) {

						return uvsHash[ hash ];

					}

					uvsHash[ hash ] = uvs.length / 2;
					uvs.push( uv.x, uv.y );

					return uvsHash[ hash ];

				}

				data.data = {};

				data.data.vertices = vertices;
				data.data.normals = normals;
				if ( colors.length > 0 ) data.data.colors = colors;
				if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
				data.data.faces = faces;

				return data;

			},

			clone: function () {

				/*
				// Handle primitives

				var parameters = this.parameters;

				if ( parameters !== undefined ) {

					var values = [];

					for ( var key in parameters ) {

						values.push( parameters[ key ] );

					}

					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;

				}

				return new this.constructor().copy( this );
				*/

				return new Geometry().copy( this );

			},

			copy: function ( source ) {

				this.vertices = [];
				this.faces = [];
				this.faceVertexUvs = [ [] ];
				this.colors = [];

				var vertices = source.vertices;

				for ( var i = 0, il = vertices.length; i < il; i ++ ) {

					this.vertices.push( vertices[ i ].clone() );

				}

				var colors = source.colors;

				for ( var i = 0, il = colors.length; i < il; i ++ ) {

					this.colors.push( colors[ i ].clone() );

				}

				var faces = source.faces;

				for ( var i = 0, il = faces.length; i < il; i ++ ) {

					this.faces.push( faces[ i ].clone() );

				}

				for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

					var faceVertexUvs = source.faceVertexUvs[ i ];

					if ( this.faceVertexUvs[ i ] === undefined ) {

						this.faceVertexUvs[ i ] = [];

					}

					for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

						var uvs = faceVertexUvs[ j ], uvsCopy = [];

						for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

							var uv = uvs[ k ];

							uvsCopy.push( uv.clone() );

						}

						this.faceVertexUvs[ i ].push( uvsCopy );

					}

				}

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		};

		Object.assign( Geometry.prototype, EventDispatcher.prototype );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferGeometry() {

			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'BufferGeometry';

			this.index = null;
			this.attributes = {};

			this.morphAttributes = {};

			this.groups = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			this.drawRange = { start: 0, count: Infinity };

		}

		BufferGeometry.prototype = {

			constructor: BufferGeometry,

			isBufferGeometry: true,

			getIndex: function () {

				return this.index;

			},

			setIndex: function ( index ) {

				this.index = index;

			},

			addAttribute: function ( name, attribute ) {

				if ( ( attribute && attribute.isBufferAttribute ) === false && ( attribute && attribute.isInterleavedBufferAttribute ) === false ) {

					console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

					this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

					return;

				}

				if ( name === 'index' ) {

					console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
					this.setIndex( attribute );

					return;

				}

				this.attributes[ name ] = attribute;

				return this;

			},

			getAttribute: function ( name ) {

				return this.attributes[ name ];

			},

			removeAttribute: function ( name ) {

				delete this.attributes[ name ];

				return this;

			},

			addGroup: function ( start, count, materialIndex ) {

				this.groups.push( {

					start: start,
					count: count,
					materialIndex: materialIndex !== undefined ? materialIndex : 0

				} );

			},

			clearGroups: function () {

				this.groups = [];

			},

			setDrawRange: function ( start, count ) {

				this.drawRange.start = start;
				this.drawRange.count = count;

			},

			applyMatrix: function ( matrix ) {

				var position = this.attributes.position;

				if ( position !== undefined ) {

					matrix.applyToBufferAttribute( position );
					position.needsUpdate = true;

				}

				var normal = this.attributes.normal;

				if ( normal !== undefined ) {

					var normalMatrix = new Matrix3().getNormalMatrix( matrix );

					normalMatrix.applyToBufferAttribute( normal );
					normal.needsUpdate = true;

				}

				if ( this.boundingBox !== null ) {

					this.computeBoundingBox();

				}

				if ( this.boundingSphere !== null ) {

					this.computeBoundingSphere();

				}

				return this;

			},

			rotateX: function () {

				// rotate geometry around world x-axis

				var m1;

				return function rotateX( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationX( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateY: function () {

				// rotate geometry around world y-axis

				var m1;

				return function rotateY( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationY( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateZ: function () {

				// rotate geometry around world z-axis

				var m1;

				return function rotateZ( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationZ( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			translate: function () {

				// translate geometry

				var m1;

				return function translate( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeTranslation( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			scale: function () {

				// scale geometry

				var m1;

				return function scale( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeScale( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			lookAt: function () {

				var obj;

				return function lookAt( vector ) {

					if ( obj === undefined ) obj = new Object3D();

					obj.lookAt( vector );

					obj.updateMatrix();

					this.applyMatrix( obj.matrix );

				};

			}(),

			center: function () {

				this.computeBoundingBox();

				var offset = this.boundingBox.getCenter().negate();

				this.translate( offset.x, offset.y, offset.z );

				return offset;

			},

			setFromObject: function ( object ) {

				// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

				var geometry = object.geometry;

				if ( object.isPoints || object.isLine ) {

					var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
					var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

					this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
					this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

					if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

						var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

						this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

					}

					if ( geometry.boundingSphere !== null ) {

						this.boundingSphere = geometry.boundingSphere.clone();

					}

					if ( geometry.boundingBox !== null ) {

						this.boundingBox = geometry.boundingBox.clone();

					}

				} else if ( object.isMesh ) {

					if ( geometry && geometry.isGeometry ) {

						this.fromGeometry( geometry );

					}

				}

				return this;

			},

			updateFromObject: function ( object ) {

				var geometry = object.geometry;

				if ( object.isMesh ) {

					var direct = geometry.__directGeometry;

					if ( geometry.elementsNeedUpdate === true ) {

						direct = undefined;
						geometry.elementsNeedUpdate = false;

					}

					if ( direct === undefined ) {

						return this.fromGeometry( geometry );

					}

					direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
					direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
					direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
					direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
					direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

					geometry.verticesNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.groupsNeedUpdate = false;

					geometry = direct;

				}

				var attribute;

				if ( geometry.verticesNeedUpdate === true ) {

					attribute = this.attributes.position;

					if ( attribute !== undefined ) {

						attribute.copyVector3sArray( geometry.vertices );
						attribute.needsUpdate = true;

					}

					geometry.verticesNeedUpdate = false;

				}

				if ( geometry.normalsNeedUpdate === true ) {

					attribute = this.attributes.normal;

					if ( attribute !== undefined ) {

						attribute.copyVector3sArray( geometry.normals );
						attribute.needsUpdate = true;

					}

					geometry.normalsNeedUpdate = false;

				}

				if ( geometry.colorsNeedUpdate === true ) {

					attribute = this.attributes.color;

					if ( attribute !== undefined ) {

						attribute.copyColorsArray( geometry.colors );
						attribute.needsUpdate = true;

					}

					geometry.colorsNeedUpdate = false;

				}

				if ( geometry.uvsNeedUpdate ) {

					attribute = this.attributes.uv;

					if ( attribute !== undefined ) {

						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;

					}

					geometry.uvsNeedUpdate = false;

				}

				if ( geometry.lineDistancesNeedUpdate ) {

					attribute = this.attributes.lineDistance;

					if ( attribute !== undefined ) {

						attribute.copyArray( geometry.lineDistances );
						attribute.needsUpdate = true;

					}

					geometry.lineDistancesNeedUpdate = false;

				}

				if ( geometry.groupsNeedUpdate ) {

					geometry.computeGroups( object.geometry );
					this.groups = geometry.groups;

					geometry.groupsNeedUpdate = false;

				}

				return this;

			},

			fromGeometry: function ( geometry ) {

				geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

				return this.fromDirectGeometry( geometry.__directGeometry );

			},

			fromDirectGeometry: function ( geometry ) {

				var positions = new Float32Array( geometry.vertices.length * 3 );
				this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

				if ( geometry.normals.length > 0 ) {

					var normals = new Float32Array( geometry.normals.length * 3 );
					this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

				}

				if ( geometry.colors.length > 0 ) {

					var colors = new Float32Array( geometry.colors.length * 3 );
					this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

				}

				if ( geometry.uvs.length > 0 ) {

					var uvs = new Float32Array( geometry.uvs.length * 2 );
					this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

				}

				if ( geometry.uvs2.length > 0 ) {

					var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
					this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

				}

				if ( geometry.indices.length > 0 ) {

					var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
					var indices = new TypeArray( geometry.indices.length * 3 );
					this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

				}

				// groups

				this.groups = geometry.groups;

				// morphs

				for ( var name in geometry.morphTargets ) {

					var array = [];
					var morphTargets = geometry.morphTargets[ name ];

					for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

						var morphTarget = morphTargets[ i ];

						var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

						array.push( attribute.copyVector3sArray( morphTarget ) );

					}

					this.morphAttributes[ name ] = array;

				}

				// skinning

				if ( geometry.skinIndices.length > 0 ) {

					var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
					this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

				}

				if ( geometry.skinWeights.length > 0 ) {

					var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
					this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

				}

				//

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

				return this;

			},

			computeBoundingBox: function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				var position = this.attributes.position;

				if ( position !== undefined ) {

					this.boundingBox.setFromBufferAttribute( position );

				} else {

					this.boundingBox.makeEmpty();

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

				}

			},

			computeBoundingSphere: function () {

				var box = new Box3();
				var vector = new Vector3();

				return function computeBoundingSphere() {

					if ( this.boundingSphere === null ) {

						this.boundingSphere = new Sphere();

					}

					var position = this.attributes.position;

					if ( position ) {

						var center = this.boundingSphere.center;

						box.setFromBufferAttribute( position );
						box.getCenter( center );

						// hoping to find a boundingSphere with a radius smaller than the
						// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

						var maxRadiusSq = 0;

						for ( var i = 0, il = position.count; i < il; i ++ ) {

							vector.x = position.getX( i );
							vector.y = position.getY( i );
							vector.z = position.getZ( i );
							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

						}

						this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

						if ( isNaN( this.boundingSphere.radius ) ) {

							console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

						}

					}

				};

			}(),

			computeFaceNormals: function () {

				// backwards compatibility

			},

			computeVertexNormals: function () {

				var index = this.index;
				var attributes = this.attributes;
				var groups = this.groups;

				if ( attributes.position ) {

					var positions = attributes.position.array;

					if ( attributes.normal === undefined ) {

						this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

					} else {

						// reset existing normals to zero

						var array = attributes.normal.array;

						for ( var i = 0, il = array.length; i < il; i ++ ) {

							array[ i ] = 0;

						}

					}

					var normals = attributes.normal.array;

					var vA, vB, vC;
					var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
					var cb = new Vector3(), ab = new Vector3();

					// indexed elements

					if ( index ) {

						var indices = index.array;

						if ( groups.length === 0 ) {

							this.addGroup( 0, indices.length );

						}

						for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

							var group = groups[ j ];

							var start = group.start;
							var count = group.count;

							for ( var i = start, il = start + count; i < il; i += 3 ) {

								vA = indices[ i + 0 ] * 3;
								vB = indices[ i + 1 ] * 3;
								vC = indices[ i + 2 ] * 3;

								pA.fromArray( positions, vA );
								pB.fromArray( positions, vB );
								pC.fromArray( positions, vC );

								cb.subVectors( pC, pB );
								ab.subVectors( pA, pB );
								cb.cross( ab );

								normals[ vA ] += cb.x;
								normals[ vA + 1 ] += cb.y;
								normals[ vA + 2 ] += cb.z;

								normals[ vB ] += cb.x;
								normals[ vB + 1 ] += cb.y;
								normals[ vB + 2 ] += cb.z;

								normals[ vC ] += cb.x;
								normals[ vC + 1 ] += cb.y;
								normals[ vC + 2 ] += cb.z;

							}

						}

					} else {

						// non-indexed elements (unconnected triangle soup)

						for ( var i = 0, il = positions.length; i < il; i += 9 ) {

							pA.fromArray( positions, i );
							pB.fromArray( positions, i + 3 );
							pC.fromArray( positions, i + 6 );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ i ] = cb.x;
							normals[ i + 1 ] = cb.y;
							normals[ i + 2 ] = cb.z;

							normals[ i + 3 ] = cb.x;
							normals[ i + 4 ] = cb.y;
							normals[ i + 5 ] = cb.z;

							normals[ i + 6 ] = cb.x;
							normals[ i + 7 ] = cb.y;
							normals[ i + 8 ] = cb.z;

						}

					}

					this.normalizeNormals();

					attributes.normal.needsUpdate = true;

				}

			},

			merge: function ( geometry, offset ) {

				if ( ( geometry && geometry.isBufferGeometry ) === false ) {

					console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
					return;

				}

				if ( offset === undefined ) offset = 0;

				var attributes = this.attributes;

				for ( var key in attributes ) {

					if ( geometry.attributes[ key ] === undefined ) continue;

					var attribute1 = attributes[ key ];
					var attributeArray1 = attribute1.array;

					var attribute2 = geometry.attributes[ key ];
					var attributeArray2 = attribute2.array;

					var attributeSize = attribute2.itemSize;

					for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

						attributeArray1[ j ] = attributeArray2[ i ];

					}

				}

				return this;

			},

			normalizeNormals: function () {

				var normals = this.attributes.normal.array;

				var x, y, z, n;

				for ( var i = 0, il = normals.length; i < il; i += 3 ) {

					x = normals[ i ];
					y = normals[ i + 1 ];
					z = normals[ i + 2 ];

					n = 1.0 / Math.sqrt( x * x + y * y + z * z );

					normals[ i ] *= n;
					normals[ i + 1 ] *= n;
					normals[ i + 2 ] *= n;

				}

			},

			toNonIndexed: function () {

				if ( this.index === null ) {

					console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
					return this;

				}

				var geometry2 = new BufferGeometry();

				var indices = this.index.array;
				var attributes = this.attributes;

				for ( var name in attributes ) {

					var attribute = attributes[ name ];

					var array = attribute.array;
					var itemSize = attribute.itemSize;

					var array2 = new array.constructor( indices.length * itemSize );

					var index = 0, index2 = 0;

					for ( var i = 0, l = indices.length; i < l; i ++ ) {

						index = indices[ i ] * itemSize;

						for ( var j = 0; j < itemSize; j ++ ) {

							array2[ index2 ++ ] = array[ index ++ ];

						}

					}

					geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

				}

				return geometry2;

			},

			toJSON: function () {

				var data = {
					metadata: {
						version: 4.4,
						type: 'BufferGeometry',
						generator: 'BufferGeometry.toJSON'
					}
				};

				// standard BufferGeometry serialization

				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;

				if ( this.parameters !== undefined ) {

					var parameters = this.parameters;

					for ( var key in parameters ) {

						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

					}

					return data;

				}

				data.data = { attributes: {} };

				var index = this.index;

				if ( index !== null ) {

					var array = Array.prototype.slice.call( index.array );

					data.data.index = {
						type: index.array.constructor.name,
						array: array
					};

				}

				var attributes = this.attributes;

				for ( var key in attributes ) {

					var attribute = attributes[ key ];

					var array = Array.prototype.slice.call( attribute.array );

					data.data.attributes[ key ] = {
						itemSize: attribute.itemSize,
						type: attribute.array.constructor.name,
						array: array,
						normalized: attribute.normalized
					};

				}

				var groups = this.groups;

				if ( groups.length > 0 ) {

					data.data.groups = JSON.parse( JSON.stringify( groups ) );

				}

				var boundingSphere = this.boundingSphere;

				if ( boundingSphere !== null ) {

					data.data.boundingSphere = {
						center: boundingSphere.center.toArray(),
						radius: boundingSphere.radius
					};

				}

				return data;

			},

			clone: function () {

				/*
				// Handle primitives

				var parameters = this.parameters;

				if ( parameters !== undefined ) {

					var values = [];

					for ( var key in parameters ) {

						values.push( parameters[ key ] );

					}

					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;

				}

				return new this.constructor().copy( this );
				*/

				return new BufferGeometry().copy( this );

			},

			copy: function ( source ) {

				var name, i, l;

				// reset

				this.index = null;
				this.attributes = {};
				this.morphAttributes = {};
				this.groups = [];
				this.boundingBox = null;
				this.boundingSphere = null;

				// name

				this.name = source.name;

				// index

				var index = source.index;

				if ( index !== null ) {

					this.setIndex( index.clone() );

				}

				// attributes

				var attributes = source.attributes;

				for ( name in attributes ) {

					var attribute = attributes[ name ];
					this.addAttribute( name, attribute.clone() );

				}

				// morph attributes

				var morphAttributes = source.morphAttributes;

				for ( name in morphAttributes ) {

					var array = [];
					var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

					for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

						array.push( morphAttribute[ i ].clone() );

					}

					this.morphAttributes[ name ] = array;

				}

				// groups

				var groups = source.groups;

				for ( i = 0, l = groups.length; i < l; i ++ ) {

					var group = groups[ i ];
					this.addGroup( group.start, group.count, group.materialIndex );

				}

				// bounding box

				var boundingBox = source.boundingBox;

				if ( boundingBox !== null ) {

					this.boundingBox = boundingBox.clone();

				}

				// bounding sphere

				var boundingSphere = source.boundingSphere;

				if ( boundingSphere !== null ) {

					this.boundingSphere = boundingSphere.clone();

				}

				// draw range

				this.drawRange.start = source.drawRange.start;
				this.drawRange.count = source.drawRange.count;

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		};

		BufferGeometry.MaxIndex = 65535;

		Object.assign( BufferGeometry.prototype, EventDispatcher.prototype );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author jonobr1 / http://jonobr1.com/
		 */

		function Mesh( geometry, material ) {

			Object3D.call( this );

			this.type = 'Mesh';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

			this.drawMode = TrianglesDrawMode;

			this.updateMorphTargets();

		}

		Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Mesh,

			isMesh: true,

			setDrawMode: function ( value ) {

				this.drawMode = value;

			},

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.drawMode = source.drawMode;

				return this;

			},

			updateMorphTargets: function () {

				var morphTargets = this.geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

					}

				}

			},

			raycast: ( function () {

				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();

				var vA = new Vector3();
				var vB = new Vector3();
				var vC = new Vector3();

				var tempA = new Vector3();
				var tempB = new Vector3();
				var tempC = new Vector3();

				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				var barycoord = new Vector3();

				var intersectionPoint = new Vector3();
				var intersectionPointWorld = new Vector3();

				function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

					Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

					uv1.multiplyScalar( barycoord.x );
					uv2.multiplyScalar( barycoord.y );
					uv3.multiplyScalar( barycoord.z );

					uv1.add( uv2 ).add( uv3 );

					return uv1.clone();

				}

				function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

					var intersect;
					var material = object.material;

					if ( material.side === BackSide ) {

						intersect = ray.intersectTriangle( pC, pB, pA, true, point );

					} else {

						intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

					}

					if ( intersect === null ) return null;

					intersectionPointWorld.copy( point );
					intersectionPointWorld.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

					if ( distance < raycaster.near || distance > raycaster.far ) return null;

					return {
						distance: distance,
						point: intersectionPointWorld.clone(),
						object: object
					};

				}

				function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

					vA.fromBufferAttribute( position, a );
					vB.fromBufferAttribute( position, b );
					vC.fromBufferAttribute( position, c );

					var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

					if ( intersection ) {

						if ( uv ) {

							uvA.fromBufferAttribute( uv, a );
							uvB.fromBufferAttribute( uv, b );
							uvC.fromBufferAttribute( uv, c );

							intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC, uvA, uvB, uvC );

						}

						intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
						intersection.faceIndex = a;

					}

					return intersection;

				}

				return function raycast( raycaster, intersects ) {

					var geometry = this.geometry;
					var material = this.material;
					var matrixWorld = this.matrixWorld;

					if ( material === undefined ) return;

					// Checking boundingSphere distance to ray

					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );

					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

					//

					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

					// Check boundingBox before continuing

					if ( geometry.boundingBox !== null ) {

						if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

					}

					var intersection;

					if ( geometry.isBufferGeometry ) {

						var a, b, c;
						var index = geometry.index;
						var position = geometry.attributes.position;
						var uv = geometry.attributes.uv;
						var i, l;

						if ( index !== null ) {

							// indexed buffer geometry

							for ( i = 0, l = index.count; i < l; i += 3 ) {

								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );

								intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
									intersects.push( intersection );

								}

							}

						} else {

							// non-indexed buffer geometry

							for ( i = 0, l = position.count; i < l; i += 3 ) {

								a = i;
								b = i + 1;
								c = i + 2;

								intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

								if ( intersection ) {

									intersection.index = a; // triangle number in positions buffer semantics
									intersects.push( intersection );

								}

							}

						}

					} else if ( geometry.isGeometry ) {

						var fvA, fvB, fvC;
						var isFaceMaterial = ( material && material.isMultiMaterial );
						var materials = isFaceMaterial === true ? material.materials : null;

						var vertices = geometry.vertices;
						var faces = geometry.faces;
						var uvs;

						var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
						if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

						for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

							var face = faces[ f ];
							var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

							if ( faceMaterial === undefined ) continue;

							fvA = vertices[ face.a ];
							fvB = vertices[ face.b ];
							fvC = vertices[ face.c ];

							if ( faceMaterial.morphTargets === true ) {

								var morphTargets = geometry.morphTargets;
								var morphInfluences = this.morphTargetInfluences;

								vA.set( 0, 0, 0 );
								vB.set( 0, 0, 0 );
								vC.set( 0, 0, 0 );

								for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

									var influence = morphInfluences[ t ];

									if ( influence === 0 ) continue;

									var targets = morphTargets[ t ].vertices;

									vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
									vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
									vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

								}

								vA.add( fvA );
								vB.add( fvB );
								vC.add( fvC );

								fvA = vA;
								fvB = vB;
								fvC = vC;

							}

							intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

							if ( intersection ) {

								if ( uvs ) {

									var uvs_f = uvs[ f ];
									uvA.copy( uvs_f[ 0 ] );
									uvB.copy( uvs_f[ 1 ] );
									uvC.copy( uvs_f[ 2 ] );

									intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

								}

								intersection.face = face;
								intersection.faceIndex = f;
								intersects.push( intersection );

							}

						}

					}

				};

			}() ),

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

			BufferGeometry.call( this );

			this.type = 'BoxBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			var scope = this;

			// segments
			widthSegments = Math.floor( widthSegments ) || 1;
			heightSegments = Math.floor( heightSegments ) || 1;
			depthSegments = Math.floor( depthSegments ) || 1;

			// these are used to calculate buffer length
			var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
			var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );

			// buffers
			var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
			var vertices = new Float32Array( vertexCount * 3 );
			var normals = new Float32Array( vertexCount * 3 );
			var uvs = new Float32Array( vertexCount * 2 );

			// offset variables
			var vertexBufferOffset = 0;
			var uvBufferOffset = 0;
			var indexBufferOffset = 0;
			var numberOfVertices = 0;

			// group variables
			var groupStart = 0;

			// build each side of the box geometry
			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
			buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
			buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

			// build geometry
			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

			// helper functions

			function calculateVertexCount( w, h, d ) {

				var vertices = 0;

				// calculate the amount of vertices for each side (plane)
				vertices += (w + 1) * (h + 1) * 2; // xy
				vertices += (w + 1) * (d + 1) * 2; // xz
				vertices += (d + 1) * (h + 1) * 2; // zy

				return vertices;

			}

			function calculateIndexCount( w, h, d ) {

				var index = 0;

				// calculate the amount of squares for each side
				index += w * h * 2; // xy
				index += w * d * 2; // xz
				index += d * h * 2; // zy

				return index * 6; // two triangles per square => six vertices per square

			}

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				var segmentWidth	= width / gridX;
				var segmentHeight = height / gridY;

				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;

				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;

				var vertexCounter = 0;
				var groupCount = 0;

				var vector = new Vector3();

				// generate vertices, normals and uvs

				for ( var iy = 0; iy < gridY1; iy ++ ) {

					var y = iy * segmentHeight - heightHalf;

					for ( var ix = 0; ix < gridX1; ix ++ ) {

						var x = ix * segmentWidth - widthHalf;

						// set values to correct vector component
						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer
						vertices[ vertexBufferOffset ] = vector.x;
						vertices[ vertexBufferOffset + 1 ] = vector.y;
						vertices[ vertexBufferOffset + 2 ] = vector.z;

						// set values to correct vector component
						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer
						normals[ vertexBufferOffset ] = vector.x;
						normals[ vertexBufferOffset + 1 ] = vector.y;
						normals[ vertexBufferOffset + 2 ] = vector.z;

						// uvs
						uvs[ uvBufferOffset ] = ix / gridX;
						uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

						// update offsets and counters
						vertexBufferOffset += 3;
						uvBufferOffset += 2;
						vertexCounter += 1;

					}

				}

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( iy = 0; iy < gridY; iy ++ ) {

					for ( ix = 0; ix < gridX; ix ++ ) {

						// indices
						var a = numberOfVertices + ix + gridX1 * iy;
						var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// face one
						indices[ indexBufferOffset ] = a;
						indices[ indexBufferOffset + 1 ] = b;
						indices[ indexBufferOffset + 2 ] = d;

						// face two
						indices[ indexBufferOffset + 3 ] = b;
						indices[ indexBufferOffset + 4 ] = c;
						indices[ indexBufferOffset + 5 ] = d;

						// update offsets and counters
						indexBufferOffset += 6;
						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups
				groupStart += groupCount;

				// update total number of vertices
				numberOfVertices += vertexCounter;

			}

		}

		BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */

		function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

			BufferGeometry.call( this );

			this.type = 'PlaneBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			var width_half = width / 2;
			var height_half = height / 2;

			var gridX = Math.floor( widthSegments ) || 1;
			var gridY = Math.floor( heightSegments ) || 1;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var segment_width = width / gridX;
			var segment_height = height / gridY;

			var vertices = new Float32Array( gridX1 * gridY1 * 3 );
			var normals = new Float32Array( gridX1 * gridY1 * 3 );
			var uvs = new Float32Array( gridX1 * gridY1 * 2 );

			var offset = 0;
			var offset2 = 0;

			for ( var iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segment_height - height_half;

				for ( var ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segment_width - width_half;

					vertices[ offset ] = x;
					vertices[ offset + 1 ] = - y;

					normals[ offset + 2 ] = 1;

					uvs[ offset2 ] = ix / gridX;
					uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

					offset += 3;
					offset2 += 2;

				}

			}

			offset = 0;

			var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

			for ( var iy = 0; iy < gridY; iy ++ ) {

				for ( var ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					indices[ offset ] = a;
					indices[ offset + 1 ] = b;
					indices[ offset + 2 ] = d;

					indices[ offset + 3 ] = b;
					indices[ offset + 4 ] = c;
					indices[ offset + 5 ] = d;

					offset += 6;

				}

			}

			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

		}

		PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

		/**
		 * @author Ben Houston / bhouston / http://clara.io
		 *
		 */

		function MaterialMap( name, uvChannel, uvTransform, texelTransform ) {

		  this.name = name || "unnamed";

		  this.texture = null;

		  this.uvChannel = uvChannel || 0;

		  this.uvTransform = uvTransform || false;
		  this.uvOffset = new Vector2( 0, 0 );
		  this.uvRepeat = new Vector2( 1.0, 1.0 );
		  //this.uvRotation = 0;  - not implemented because offset/repeat fix in a vec4 uniform, rotation doesn't.

		  this.texelTransform = uvTransform || false;
		  this.texelScale = 1.0;
		  this.texelOffset = 0.0;
		  this.texelInvert = false;

		}

		MaterialMap.prototype = {

		  constructor: MaterialMap,

		  copy: function ( source ) {

		    this.name = source.name;

		  	this.texture = source.texture;

		    this.uvChannel = source.uvChannel;

		    this.uvTransform = source.uvTransform;
		    this.uvOffset = source.uvOffset;
		    this.uvRepeat = source.uvRepeat;
		    //this.uvRotation = source.uvRotation;

		    this.texelTransform = source.texelTransform;
		    this.texelScale = source.texelScale;
		    this.texelOffset = source.texelOffset;
		    this.texelInvert = source.texelInvert;

		  	return this;

		  },

		  // bakes all the input texel parameters into just two.
		  getFlattenedTexelTransform: function( optionalTexelTransform ) {
		      var texelTransform = optionalTexelTransform || {};
		      if( this.texelInvert ) {
		        texelTransform.texelScale = -this.texelScale;
		        texelTransform.texelOffset = this.texelScale + this.texelOffset;
		      }
		      else {
		        texelTransform.texelScale = this.texelScale;
		        texelTransform.texelOffset = this.texelOffset;
		      }
		      return texelTransform;
		  }

		};

		MaterialMap.SupportedMapNames = [
			'map', 'lightMap', 'aoMap', 'emissiveMap', 'specularMap', 'bumpMap', 'normalMap', 'roughnessMap', 'metalnessMap', 'alphaMap', 'displacementMap', 'falloffMap', 'falloffAlphaMap'
		];
		MaterialMap.SupportedMapSlotNames = [];
		MaterialMap.SupportedMapUVNames = [];
		MaterialMap.SupportedMapTexelNames = [];

		for( var i = 0; i < MaterialMap.SupportedMapNames.length; i ++ ) {
		  var name = MaterialMap.SupportedMapNames [i];
		  MaterialMap.SupportedMapSlotNames.push( name + 'Slot' );
		  MaterialMap.SupportedMapUVNames.push( name + 'UVTransformParams' );
		  MaterialMap.SupportedMapTexelNames.push( name + 'TexelTransformParams' );
		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function Camera() {

			Object3D.call( this );

			this.type = 'Camera';

			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();

		}

		Camera.prototype = Object.create( Object3D.prototype );
		Camera.prototype.constructor = Camera;

		Camera.prototype.isCamera = true;

		Camera.prototype.getWorldDirection = function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			};

		}();

		Camera.prototype.lookAt = function () {

			// This routine does not support cameras with rotated and/or translated parent(s)

			var m1 = new Matrix4();

			return function lookAt( vector ) {

				m1.lookAt( this.position, vector, this.up );

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}();

		Camera.prototype.clone = function () {

			return new this.constructor().copy( this );

		};

		Camera.prototype.copy = function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author greggman / http://games.greggman.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author tschw
		 */

		function PerspectiveCamera( fov, aspect, near, far ) {

			Camera.call( this );

			this.type = 'PerspectiveCamera';

			this.fov = fov !== undefined ? fov : 50;
			this.zoom = 1;

			this.near = near !== undefined ? near : 0.1;
			this.far = far !== undefined ? far : 2000;
			this.focus = 10;

			this.aspect = aspect !== undefined ? aspect : 1;
			this.view = null;

			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();

		}

		PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

			constructor: PerspectiveCamera,

			isPerspectiveCamera: true,

			copy: function ( source ) {

				Camera.prototype.copy.call( this, source );

				this.fov = source.fov;
				this.zoom = source.zoom;

				this.near = source.near;
				this.far = source.far;
				this.focus = source.focus;

				this.aspect = source.aspect;
				this.view = source.view === null ? null : Object.assign( {}, source.view );

				this.filmGauge = source.filmGauge;
				this.filmOffset = source.filmOffset;

				return this;

			},

			/**
			 * Sets the FOV by focal length in respect to the current .filmGauge.
			 *
			 * The default film gauge is 35, so that the focal length can be specified for
			 * a 35mm (full frame) camera.
			 *
			 * Values for focal length and film gauge must have the same unit.
			 */
			setFocalLength: function ( focalLength ) {

				// see http://www.bobatkins.com/photography/technical/field_of_view.html
				var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

				this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
				this.updateProjectionMatrix();

			},

			/**
			 * Calculates the focal length from the current .fov and .filmGauge.
			 */
			getFocalLength: function () {

				var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

				return 0.5 * this.getFilmHeight() / vExtentSlope;

			},

			getEffectiveFOV: function () {

				return _Math.RAD2DEG * 2 * Math.atan(
						Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

			},

			getFilmWidth: function () {

				// film not completely covered in portrait format (aspect < 1)
				return this.filmGauge * Math.min( this.aspect, 1 );

			},

			getFilmHeight: function () {

				// film not completely covered in landscape format (aspect > 1)
				return this.filmGauge / Math.max( this.aspect, 1 );

			},

			/**
			 * Sets an offset in a larger frustum. This is useful for multi-window or
			 * multi-monitor/multi-machine setups.
			 *
			 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
			 * the monitors are in grid like this
			 *
			 *   +---+---+---+
			 *   | A | B | C |
			 *   +---+---+---+
			 *   | D | E | F |
			 *   +---+---+---+
			 *
			 * then for each monitor you would call it like this
			 *
			 *   var w = 1920;
			 *   var h = 1080;
			 *   var fullWidth = w * 3;
			 *   var fullHeight = h * 2;
			 *
			 *   --A--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
			 *   --B--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
			 *   --C--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
			 *   --D--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
			 *   --E--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
			 *   --F--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
			 *
			 *   Note there is no reason monitors have to be the same size or in a grid.
			 */
			setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

				if( ! fullWidth ) {
					this.view = null;
					return;
				}

				this.aspect = fullWidth / fullHeight;

				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};

				this.updateProjectionMatrix();

			},

			clearViewOffset: function() {

				this.view = null;
				this.updateProjectionMatrix();

			},

			updateProjectionMatrix: function () {

				var near = this.near,
					top = near * Math.tan(
							_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
					height = 2 * top,
					width = this.aspect * height,
					left = - 0.5 * width,
					view = this.view;

				if ( view !== null ) {

					var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;

					left += view.offsetX * width / fullWidth;
					top -= view.offsetY * height / fullHeight;
					width *= view.width / fullWidth;
					height *= view.height / fullHeight;

				}

				var skew = this.filmOffset;
				if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

				this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.fov = this.fov;
				data.object.zoom = this.zoom;

				data.object.near = this.near;
				data.object.far = this.far;
				data.object.focus = this.focus;

				data.object.aspect = this.aspect;

				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

				data.object.filmGauge = this.filmGauge;
				data.object.filmOffset = this.filmOffset;

				return data;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author arose / http://github.com/arose
		 */

		function OrthographicCamera( left, right, top, bottom, near, far ) {

			Camera.call( this );

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;

			this.near = ( near !== undefined ) ? near : 0.1;
			this.far = ( far !== undefined ) ? far : 2000;

			this.updateProjectionMatrix();

		}

		OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

			constructor: OrthographicCamera,

			isOrthographicCamera: true,

			copy: function ( source ) {

				Camera.prototype.copy.call( this, source );

				this.left = source.left;
				this.right = source.right;
				this.top = source.top;
				this.bottom = source.bottom;
				this.near = source.near;
				this.far = source.far;

				this.zoom = source.zoom;
				this.view = source.view === null ? null : Object.assign( {}, source.view );

				return this;

			},

			setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};

				this.updateProjectionMatrix();

			},

			clearViewOffset: function() {

				this.view = null;
				this.updateProjectionMatrix();

			},

			updateProjectionMatrix: function () {

				var dx = ( this.right - this.left ) / ( 2 * this.zoom );
				var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
				var cx = ( this.right + this.left ) / 2;
				var cy = ( this.top + this.bottom ) / 2;

				var left = cx - dx;
				var right = cx + dx;
				var top = cy + dy;
				var bottom = cy - dy;

				if ( this.view !== null ) {

					var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
					var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
					var scaleW = ( this.right - this.left ) / this.view.width;
					var scaleH = ( this.top - this.bottom ) / this.view.height;

					left += scaleW * ( this.view.offsetX / zoomW );
					right = left + scaleW * ( this.view.width / zoomW );
					top -= scaleH * ( this.view.offsetY / zoomH );
					bottom = top - scaleH * ( this.view.height / zoomH );

				}

				this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.zoom = this.zoom;
				data.object.left = this.left;
				data.object.right = this.right;
				data.object.top = this.top;
				data.object.bottom = this.bottom;
				data.object.near = this.near;
				data.object.far = this.far;

				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

				return data;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

			var mode;

			function setMode( value ) {

				mode = value;

			}

			var type, size;

			function setIndex( index ) {

				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

					type = gl.UNSIGNED_INT;
					size = 4;

				} else if ( index.array instanceof Uint16Array ) {

					type = gl.UNSIGNED_SHORT;
					size = 2;

				} else {

					type = gl.UNSIGNED_BYTE;
					size = 1;
				}

			}

			function render( start, count ) {

				gl.drawElements( mode, count, type, start * size );

				infoRender.calls ++;
				infoRender.vertices += count;

				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

			}

			function renderInstances( geometry, start, count ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

				extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;

				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

			}

			return {

				setMode: setMode,
				setIndex: setIndex,
				render: render,
				renderInstances: renderInstances

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLBufferRenderer( gl, extensions, infoRender ) {

			var mode;

			function setMode( value ) {

				mode = value;

			}

			function render( start, count ) {

				gl.drawArrays( mode, start, count );

				infoRender.calls ++;
				infoRender.vertices += count;

				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

			}

			function renderInstances( geometry ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

				var position = geometry.attributes.position;

				var count = 0;

				if ( position.isInterleavedBufferAttribute ) {

					count = position.data.count;

					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

				} else {

					count = position.count;

					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

				}

				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;

				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

			}

			return {
				setMode: setMode,
				render: render,
				renderInstances: renderInstances
			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLLights() {

			var lights = {};

			return {

				get: function ( light ) {

					if ( lights[ light.id ] !== undefined ) {

						return lights[ light.id ];

					}

					var uniforms;

					switch ( light.type ) {

						case 'DirectionalLight':
							console.warn( "ShadowSpreadAngle initilized but may not match other names used.");
							uniforms = {
								direction: new Vector3(),
								color: new Color(),

								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowSpreadAngle: 0,
								shadowMapSize: new Vector2(),
								shadowCameraParams: new Vector3()
							};
							break;

						case 'SpotLight':
							console.warn( "shadowCameraFovNearFar and shadowCameraParams are both initilized but may not match other names used.");
							uniforms = {
								position: new Vector3(),
								direction: new Vector3(),
								color: new Color(),
								distance: 0,
								coneCos: 0,
								penumbraCos: 0,
								decay: 0,

								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2(),
								shadowCameraFovNearFar: new Vector3(),
								shadowCameraParams: new Vector3()
							};
							break;

						case 'PointLight':
							uniforms = {
								position: new Vector3(),
								color: new Color(),
								distance: 0,
								decay: 0,

								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;

						case 'HemisphereLight':
							uniforms = {
								direction: new Vector3(),
								skyColor: new Color(),
								groundColor: new Color()
							};
							break;

						case 'RectAreaLight':
							uniforms = {
								color: new Color(),
								position: new Vector3(),
								halfWidth: new Vector3(),
								halfHeight: new Vector3()
								// TODO (abelnation): set RectAreaLight shadow uniforms
							};
							break;

					}

					lights[ light.id ] = uniforms;

					return uniforms;

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function addLineNumbers( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		}

		function WebGLShader( gl, type, string ) {

			var shader = gl.createShader( type );

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			if ( gl.getShaderInfoLog( shader ) !== '' ) {

				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var programIdCount = 0;

		function getEncodingComponents( encoding ) {

			switch ( encoding ) {

				case LinearEncoding:
					return [ 'Linear','( value )' ];
				case sRGBEncoding:
					return [ 'sRGB','( value )' ];
				case RGBEEncoding:
					return [ 'RGBE','( value )' ];
				case RGBM7Encoding:
					return [ 'RGBM','( value, 7.0 )' ];
				case RGBM16Encoding:
					return [ 'RGBM','( value, 16.0 )' ];
				case RGBDEncoding:
					return [ 'RGBD','( value, 256.0 )' ];
				case GammaEncoding:
					return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
				default:
					throw new Error( 'unsupported encoding: ' + encoding );

			}

		}

		function getTexelDecodingFunction( functionName, encoding ) {

			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

		}

		function getTexelEncodingFunction( functionName, encoding ) {

			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

		}

		function getTexelTransformFunction( mapName, map ) {

			if( ! map || ! map.texelTransform ) {
				return "vec4 " + mapName + "TexelTransform( vec4 value ) { return value; }\n";
			}

			var transform = map.getFlattenedTexelTransform();
			var template = ShaderChunk[ 'slot_texel_transform_template' ];
			var result = template.replace( /\$SLOT_NAME\$/g, mapName );
			return result;

		}

		function getUVFunction( mapName, map, isVertexShader ) {

			var uvVariableName = ( isVertexShader ) ? "uv" : "vUv";
			if( map && map.uvChannel > 0 ) {
				uvVariableName += ( map.uvChannel + 1 );
			}

			if( ! map || ! map.uvTransform ) {
				return "vec2 " + mapName + "UV() { return " + uvVariableName + "; }\n";
			}

			var transform = map.getFlattenedTexelTransform();
			var template = ShaderChunk[ 'slot_uv_transform_template' ];
			var result = template.replace( /\$SLOT_NAME\$/g, mapName );
			result = result.replace( /\$UV_VAR_NAME\$/g, uvVariableName );
			return result;

		}

		function getToneMappingFunction( functionName, toneMapping ) {

			var toneMappingName;

			switch ( toneMapping ) {

				case LinearToneMapping:
					toneMappingName = "Linear";
					break;

				case ReinhardToneMapping:
					toneMappingName = "Reinhard";
					break;

				case Uncharted2ToneMapping:
					toneMappingName = "Uncharted2";
					break;

				case CineonToneMapping:
					toneMappingName = "OptimizedCineon";
					break;

				default:
					throw new Error( 'unsupported toneMapping: ' + toneMapping );

			}

			return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

		}

		function generateExtensions( extensions, parameters, rendererExtensions ) {

			extensions = extensions || {};

			var chunks = [
				( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
			];

			return chunks.filter( filterEmptyLine ).join( '\n' );

		}

		function generateDefines( defines ) {

			var chunks = [];

			for ( var name in defines ) {

				var value = defines[ name ];

				if ( value === false ) continue;

				chunks.push( '#define ' + name + ' ' + value );

			}

			return chunks.join( '\n' );

		}

		function fetchAttributeLocations( gl, program, identifiers ) {

			var attributes = {};

			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveAttrib( program, i );
				var name = info.name;

				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

				attributes[ name ] = gl.getAttribLocation( program, name );

			}

			return attributes;

		}

		function filterEmptyLine( string ) {

			return string !== '';

		}

		function replaceLightNums( string, parameters ) {

			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

		}

		function parseIncludes( string ) {

			var pattern = /#include +<([\w\d.]+)>/g;

			function replace( match, include ) {

				var replace = ShaderChunk[ include ];

				if ( replace === undefined ) {

					throw new Error( 'Can not resolve #include <' + include + '>' );

				}

				return parseIncludes( replace );

			}

			return string.replace( pattern, replace );

		}

		function unrollLoops( string ) {

			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

			function replace( match, start, end, snippet ) {

				var unroll = '';

				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

				}

				return unroll;

			}

			return string.replace( pattern, replace );

		}

		function WebGLProgram( renderer, code, material, parameters ) {

			var gl = renderer.context;

			var extensions = material.extensions;
			var defines = material.defines;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if ( parameters.shadowMapType === PCFShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if ( parameters.shadowMapType === PCSSSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCSS';

			} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			}

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

			if ( parameters.envMap ) {

				switch ( material.envMap.mapping ) {

					case CubeReflectionMapping:
					case CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case CubeUVReflectionMapping:
					case CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;

					case EquirectangularReflectionMapping:
					case EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

				switch ( material.envMap.mapping ) {

					case CubeRefractionMapping:
					case EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

				switch ( material.combine ) {

					case MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

			// console.log( 'building new program ' );

			//

			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

			var customDefines = generateDefines( defines );

			//

			var program = gl.createProgram();

			var prefixVertex, prefixFragment;

			if ( material.isRawShaderMaterial ) {

				prefixVertex = [

					customDefines,

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					customExtensions,
					customDefines,

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

			} else {

				prefixVertex = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_BONES ' + parameters.maxBones,

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
					parameters.falloffMap && parameters.falloff ? '#define USE_FALLOFFMAP' : '',
					parameters.falloffAlphaMap && parameters.falloff ? '#define USE_FALLOFFALPHAMAP' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					customExtensions,

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

					parameters.falloff ? '#define FALLOFF' : '',
					parameters.falloffMap && parameters.falloff ? '#define USE_FALLOFFMAP' : '',
					parameters.falloffAlphaMap && parameters.falloff ? '#define USE_FALLOFFALPHAMAP' : '',

					//parameters.flatShading ? '#define FLAT_SHADED' : '',

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
					'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

					parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.falloffMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
					parameters.falloffMapEncoding ? getTexelDecodingFunction( 'falloffMapTexelToLinear', parameters.falloffMapEncoding ) : '',
					parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',


					parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',

					( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
					( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
					( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

					'\n'

					].filter( filterEmptyLine ).join( '\n' );


				var supportedMapNames = MaterialMap.SupportedMapNames;

				var mapUVChannelsCode = "";
				var mapTexelTransformCode = "";
				var mapUvChannels = {};
				for( var i = 0; i < supportedMapNames.length; i ++ ) {
					var mapName = supportedMapNames[i];
					var map = material[ mapName + 'Slot' ];
					if( material[ mapName ] || ( map && map.texture ) ) {
						if( map && ! mapUvChannels[ map.uvChannel ]) mapUvChannels[ map.uvChannel ] = true;
						mapTexelTransformCode += getTexelTransformFunction( mapName, map );
						mapUVChannelsCode += "uniform sampler2D " + mapName + ";\n";
						mapUVChannelsCode += getUVFunction( mapName, map, false );
					}
				}
				if( Object.keys( mapUvChannels ).length > 0 ) {
					var mapUVPrefix = "";
					mapUVPrefix += "#define TEXTURE_SLOTS\n";
					for( var uvChannel in mapUvChannels ) {
						uvChannel = parseInt( uvChannel );
						var uvChannelName = "vUv";
						if( uvChannel > 0 ) uvChannelName += '' + ( uvChannel + 1 );
						mapUVPrefix += "varying vec2 " + uvChannelName + ";\n";
					}
					prefixFragment += mapUVPrefix + mapUVChannelsCode;
				}
				prefixFragment += mapTexelTransformCode;

			}

			vertexShader = parseIncludes( vertexShader, parameters );
			vertexShader = replaceLightNums( vertexShader, parameters );

			fragmentShader = parseIncludes( fragmentShader, parameters );
			fragmentShader = replaceLightNums( fragmentShader, parameters );

			if ( ! material.isShaderMaterial ) {

				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );

			}

			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;

			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );

			var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );

			// Force a particular attribute to index 0.

			if ( material.index0AttributeName !== undefined ) {

				gl.bindAttribLocation( program, 0, material.index0AttributeName );

			} else if ( parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );

			}

			gl.linkProgram( program );

			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

			var runnable = true;
			var haveDiagnostics = true;

			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				console.log( '**VERTEX**', vertexGlsl, "----------------------------------------------------------", gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
				console.log( '**FRAGMENT**', fragmentGlsl, "----------------------------------------------------------", gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,
					material: material,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

			// clean up

			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );

			// set up caching for uniform locations

			var cachedUniforms;

			this.getUniforms = function() {

				if ( cachedUniforms === undefined ) {

					cachedUniforms =
						new WebGLUniforms( gl, program, renderer );

				}

				return cachedUniforms;

			};

			// set up caching for attribute locations

			var cachedAttributes;

			this.getAttributes = function() {

				if ( cachedAttributes === undefined ) {

					cachedAttributes = fetchAttributeLocations( gl, program );

				}

				return cachedAttributes;

			};

			// free resource

			this.destroy = function() {

				gl.deleteProgram( program );
				this.program = undefined;

			};

			// DEPRECATED

			Object.defineProperties( this, {

				uniforms: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();

					}
				},

				attributes: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();

					}
				}

			} );


			//

			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLPrograms( renderer, capabilities ) {

			var programs = [];

			var shaderIDs = {
				MeshDepthMaterial: 'depth',
				MeshNormalMaterial: 'normal',
				MeshBasicMaterial: 'basic',
				MeshLambertMaterial: 'lambert',
				MeshPhongMaterial: 'phong',
				MeshToonMaterial: 'phong',
				MeshStandardMaterial: 'physical',
				MeshPhysicalMaterial: 'physical',
				MeshCubeMaterial: 'cubeEnv',
				LineBasicMaterial: 'basic',
				LineDashedMaterial: 'dashed',
				PointsMaterial: 'points'
			};

			var parameterNames = [
				"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
				"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
				"roughnessMap", "metalnessMap", "gradientMap",
				"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
				"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
				"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
				"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
				"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
				"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
				"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", 'falloff', 'falloffMap', 'falloffAlphaMap'
			];

			var supportedMaps = MaterialMap.SupportedMapNames;
			for( var i = 0; i < supportedMaps.length; i ++ ) {
				var name = supportedMaps[i];
				parameterNames.push( name );
				parameterNames.push( name + 'UVChannel' );
				parameterNames.push( name + 'UVTransform' );
				parameterNames.push( name + 'TexelTransform' );
			}

			function allocateBones( object ) {

				if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

					return 1024;

				} else {

					// default for when object is not specified
					// ( for example when prebuilding shader to be used with multiple objects )
					//
					//  - leave some extra space for other uniforms
					//  - limit here is ANGLE's 254 max uniform vectors
					//    (up to 54 should be safe)

					var nVertexUniforms = capabilities.maxVertexUniforms;
					var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

					var maxBones = nVertexMatrices;

					if ( object !== undefined && (object && object.isSkinnedMesh) ) {

						maxBones = Math.min( object.skeleton.bones.length, maxBones );

						if ( maxBones < object.skeleton.bones.length ) {

							console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

						}

					}

					return maxBones;

				}

			}

			function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

				var encoding;

				if ( ! map ) {

					encoding = LinearEncoding;

				} else if ( map.isTexture ) {

					encoding = map.encoding;

				} else if ( map.isWebGLRenderTarget ) {

					console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
					encoding = map.texture.encoding;

				}

				// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
				if ( encoding === LinearEncoding && gammaOverrideLinear ) {

					encoding = GammaEncoding;

				}

				return encoding;

			}

			this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {

				var shaderID = shaderIDs[ material.type ];

				// heuristics to create shader parameters according to lights in the scene
				// (not to blow over maxLights budget)

				var maxBones = allocateBones( object );
				var precision = renderer.getPrecision();

				if ( material.precision !== null ) {

					precision = capabilities.getMaxPrecision( material.precision );

					if ( precision !== material.precision ) {

						console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

					}

				}

				var currentRenderTarget = renderer.getCurrentRenderTarget();

				var parameters = {

					shaderID: shaderID,

					precision: precision,
					supportsVertexTextures: capabilities.vertexTextures,
					outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
					mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
					envMap: !!material.envMap,
					envMapMode: material.envMap && material.envMap.mapping,
					envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
					envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
					emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),

					falloff: material.falloff,
					falloffMapEncoding: getTextureEncodingFromMap( material.falloffMap, renderer.gammaInput ),

					gradientMap: !! material.gradientMap,

					combine: material.combine,

					vertexColors: material.vertexColors,

					fog: !! fog,
					useFog: material.fog,
					fogExp: (fog && fog.isFogExp2),

					flatShading: material.shading === FlatShading,

					sizeAttenuation: material.sizeAttenuation,
					logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

					skinning: material.skinning,
					maxBones: maxBones,
					useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

					morphTargets: material.morphTargets,
					morphNormals: material.morphNormals,
					maxMorphTargets: renderer.maxMorphTargets,
					maxMorphNormals: renderer.maxMorphNormals,

					numDirLights: lights.directional.length,
					numPointLights: lights.point.length,
					numSpotLights: lights.spot.length,
					numRectAreaLights: lights.rectArea.length,
					numHemiLights: lights.hemi.length,

					numClippingPlanes: nClipPlanes,
					numClipIntersection: nClipIntersection,

					shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
					shadowMapType: renderer.shadowMap.type,

					toneMapping: renderer.toneMapping,
					physicallyCorrectLights: renderer.physicallyCorrectLights,

					premultipliedAlpha: material.premultipliedAlpha,

					alphaTest: material.alphaTest,
					doubleSided: material.side === DoubleSide,
					flipSided: material.side === BackSide,

					depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

				};

				var supportedMapNames = MaterialMap.SupportedMapNames;

				for( var i = 0; i < supportedMapNames.length; i ++ ) {
					var mapName = supportedMapNames[i];
					var mapSlotName = MaterialMap.SupportedMapSlotNames[i];
					// backwards compatibility
					parameters[mapName] = !! material[ mapName ];

					// new functional for slot-based maps
					var map = material[ mapSlotName ];
					parameters[mapName + "UVChannel" ] = ( map !== undefined ) ? map.uvChannel : 0;
					parameters[mapName + "UVTransform" ] = ( map !== undefined ) ? map.uvTransform : false;
					parameters[mapName + "TexelTransform" ] = ( map !== undefined ) ? map.texelTransform : false;
				}

				return parameters;

			};

			this.getProgramCode = function ( material, parameters ) {

				var array = [];

				if ( parameters.shaderID ) {

					array.push( parameters.shaderID );

				} else {

					array.push( material.fragmentShader );
					array.push( material.vertexShader );

				}

				if ( material.defines !== undefined ) {

					for ( var name in material.defines ) {

						array.push( name );
						array.push( material.defines[ name ] );

					}

				}

				for ( var i = 0; i < parameterNames.length; i ++ ) {

					array.push( parameters[ parameterNames[ i ] ] );

				}

				return array.join();

			};

			this.acquireProgram = function ( material, parameters, code ) {

				var program;

				// Check if code has been already compiled
				for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

					var programInfo = programs[ p ];

					if ( programInfo.code === code ) {

						program = programInfo;
						++ program.usedTimes;

						break;

					}

				}

				if ( program === undefined ) {

					program = new WebGLProgram( renderer, code, material, parameters );
					programs.push( program );

				}

				return program;

			};

			this.releaseProgram = function( program ) {

				if ( -- program.usedTimes === 0 ) {

					// Remove from unordered set
					var i = programs.indexOf( program );
					programs[ i ] = programs[ programs.length - 1 ];
					programs.pop();

					// Free WebGL resources
					program.destroy();

				}

			};

			// Exposed for resource monitoring & error feedback via renderer.info:
			this.programs = programs;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLGeometries( gl, properties, info ) {

			var geometries = {};

			function onGeometryDispose( event ) {

				var geometry = event.target;
				var buffergeometry = geometries[ geometry.id ];

				if ( buffergeometry.index !== null ) {

					deleteAttribute( buffergeometry.index );

				}

				deleteAttributes( buffergeometry.attributes );

				geometry.removeEventListener( 'dispose', onGeometryDispose );

				delete geometries[ geometry.id ];

				// TODO

				var property = properties.get( geometry );

				if ( property.wireframe ) {

					deleteAttribute( property.wireframe );

				}

				properties.delete( geometry );

				var bufferproperty = properties.get( buffergeometry );

				if ( bufferproperty.wireframe ) {

					deleteAttribute( bufferproperty.wireframe );

				}

				properties.delete( buffergeometry );

				//

				info.memory.geometries --;

			}

			function getAttributeBuffer( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					return properties.get( attribute.data ).__webglBuffer;

				}

				return properties.get( attribute ).__webglBuffer;

			}

			function deleteAttribute( attribute ) {

				var buffer = getAttributeBuffer( attribute );

				if ( buffer !== undefined ) {

					gl.deleteBuffer( buffer );
					removeAttributeBuffer( attribute );

				}

			}

			function deleteAttributes( attributes ) {

				for ( var name in attributes ) {

					deleteAttribute( attributes[ name ] );

				}

			}

			function removeAttributeBuffer( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					properties.delete( attribute.data );

				} else {

					properties.delete( attribute );

				}

			}

			return {

				get: function ( object ) {

					var geometry = object.geometry;

					if ( geometries[ geometry.id ] !== undefined ) {

						return geometries[ geometry.id ];

					}

					geometry.addEventListener( 'dispose', onGeometryDispose );

					var buffergeometry;

					if ( geometry.isBufferGeometry ) {

						buffergeometry = geometry;

					} else if ( geometry.isGeometry ) {

						if ( geometry._bufferGeometry === undefined ) {

							geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

						}

						buffergeometry = geometry._bufferGeometry;

					}

					geometries[ geometry.id ] = buffergeometry;

					info.memory.geometries ++;

					return buffergeometry;

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLObjects( gl, properties, info ) {

			var geometries = new WebGLGeometries( gl, properties, info );

			//

			function update( object ) {

				// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

				var geometry = geometries.get( object );

				if ( object.geometry.isGeometry ) {

					geometry.updateFromObject( object );

				}

				var index = geometry.index;
				var attributes = geometry.attributes;

				if ( index !== null ) {

					updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

				}

				for ( var name in attributes ) {

					updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

				}

				// morph targets

				var morphAttributes = geometry.morphAttributes;

				for ( var name in morphAttributes ) {

					var array = morphAttributes[ name ];

					for ( var i = 0, l = array.length; i < l; i ++ ) {

						updateAttribute( array[ i ], gl.ARRAY_BUFFER );

					}

				}

				return geometry;

			}

			function updateAttribute( attribute, bufferType ) {

				var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;

				var attributeProperties = properties.get( data );

				if ( attributeProperties.__webglBuffer === undefined ) {

					createBuffer( attributeProperties, data, bufferType );

				} else if ( attributeProperties.version !== data.version ) {

					updateBuffer( attributeProperties, data, bufferType );

				}

			}

			function createBuffer( attributeProperties, data, bufferType ) {

				attributeProperties.__webglBuffer = gl.createBuffer();
				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

				var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

				gl.bufferData( bufferType, data.array, usage );

				var type = gl.FLOAT;
				var array = data.array;

				if ( array instanceof Float32Array ) {

					type = gl.FLOAT;

				} else if ( array instanceof Float64Array ) {

					console.warn( "Unsupported data buffer format: Float64Array" );

				} else if ( array instanceof Uint16Array ) {

					type = gl.UNSIGNED_SHORT;

				} else if ( array instanceof Int16Array ) {

					type = gl.SHORT;

				} else if ( array instanceof Uint32Array ) {

					type = gl.UNSIGNED_INT;

				} else if ( array instanceof Int32Array ) {

					type = gl.INT;

				} else if ( array instanceof Int8Array ) {

					type = gl.BYTE;

				} else if ( array instanceof Uint8Array ) {

					type = gl.UNSIGNED_BYTE;

				}

				attributeProperties.bytesPerElement = array.BYTES_PER_ELEMENT;
				attributeProperties.type = type;
				attributeProperties.version = data.version;

				data.onUploadCallback();

			}

			function updateBuffer( attributeProperties, data, bufferType ) {

				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

				if ( data.dynamic === false ) {

					gl.bufferData( bufferType, data.array, gl.STATIC_DRAW );

				} else if ( data.updateRange.count === - 1 ) {

					// Not using update ranges

					gl.bufferSubData( bufferType, 0, data.array );

				} else if ( data.updateRange.count === 0 ) {

					console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

				} else {

					gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
									  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

					data.updateRange.count = 0; // reset range

				}

				attributeProperties.version = data.version;

			}

			function getAttributeBuffer( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					return properties.get( attribute.data ).__webglBuffer;

				}

				return properties.get( attribute ).__webglBuffer;

			}

			function getAttributeProperties( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					return properties.get( attribute.data );

				}

				return properties.get( attribute );

			}

			function getWireframeAttribute( geometry ) {

				var property = properties.get( geometry );

				if ( property.wireframe !== undefined ) {

					return property.wireframe;

				}

				var indices = [];

				var index = geometry.index;
				var attributes = geometry.attributes;
				var position = attributes.position;

				// console.time( 'wireframe' );

				if ( index !== null ) {

					var edges = {};
					var array = index.array;

					for ( var i = 0, l = array.length; i < l; i += 3 ) {

						var a = array[ i + 0 ];
						var b = array[ i + 1 ];
						var c = array[ i + 2 ];

						indices.push( a, b, b, c, c, a );

					}

				} else {

					var array = attributes.position.array;

					for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

						var a = i + 0;
						var b = i + 1;
						var c = i + 2;

						indices.push( a, b, b, c, c, a );

					}

				}

				// console.timeEnd( 'wireframe' );

				var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
				var attribute = new BufferAttribute( new TypeArray( indices ), 1 );

				updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

				property.wireframe = attribute;

				return attribute;

			}

			return {

				getAttributeBuffer: getAttributeBuffer,
				getAttributeProperties: getAttributeProperties,
				getWireframeAttribute: getWireframeAttribute,

				update: update

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

			var _infoMemory = info.memory;
			var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

			//

			function clampToMaxSize( image, maxSize ) {

				if ( image.width > maxSize || image.height > maxSize ) {

					// Warning: Scaling through the canvas will only work with images that use
					// premultiplied alpha.

					var scale = maxSize / Math.max( image.width, image.height );

					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = Math.floor( image.width * scale );
					canvas.height = Math.floor( image.height * scale );

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

					console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

					return canvas;

				}

				return image;

			}

			function isPowerOfTwo( image ) {

				return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

			}

			function makePowerOfTwo( image ) {

				if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = _Math.nearestPowerOfTwo( image.width );
					canvas.height = _Math.nearestPowerOfTwo( image.height );

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, canvas.width, canvas.height );

					console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

					return canvas;

				}

				return image;

			}

			function textureNeedsPowerOfTwo( texture ) {

				return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
					( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

			}

			// Fallback filters for non-power-of-2 textures

			function filterFallback( f ) {

				if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

					return _gl.NEAREST;

				}

				return _gl.LINEAR;

			}

			//

			function onTextureDispose( event ) {

				var texture = event.target;

				texture.removeEventListener( 'dispose', onTextureDispose );

				deallocateTexture( texture );

				_infoMemory.textures --;


			}

			function onRenderTargetDispose( event ) {

				var renderTarget = event.target;

				renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

				deallocateRenderTarget( renderTarget );

				_infoMemory.textures --;

			}

			//

			function deallocateTexture( texture ) {

				var textureProperties = properties.get( texture );

				if ( texture.image && textureProperties.__image__webglTextureCube ) {

					// cube texture

					_gl.deleteTexture( textureProperties.__image__webglTextureCube );

				} else {

					// 2D texture

					if ( textureProperties.__webglInit === undefined ) return;

					_gl.deleteTexture( textureProperties.__webglTexture );

				}

				// remove all webgl properties
				properties.delete( texture );

			}

			function deallocateRenderTarget( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );

				if ( ! renderTarget ) return;

				if ( textureProperties.__webglTexture !== undefined ) {

					_gl.deleteTexture( textureProperties.__webglTexture );

				}

				if ( renderTarget.depthTexture ) {

					renderTarget.depthTexture.dispose();

				}

				if ( renderTarget.isWebGLRenderTargetCube ) {

					for ( var i = 0; i < 6; i ++ ) {

						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
						if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

					}

				} else {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

				}

				properties.delete( renderTarget.texture );
				properties.delete( renderTarget );

			}

			//


			 var textureUpdateUndefinedWarning = false;
			 var textureUpdateIncompleteWarning = false;

			function setTexture2D( texture, slot ) {

				var textureProperties = properties.get( texture );

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					var image = texture.image;

					if ( image === undefined ) {

						if( ! textureUpdateUndefinedWarning ) {
							console.trace( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
							textureUpdateUndefinedWarning = true;
						}

					} else if ( image.complete === false ) {

						if( ! textureUpdateIncompleteWarning ) {
							console.trace( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
							textureUpdateIncompleteWarning = true;
						}

					} else {

						uploadTexture( textureProperties, texture, slot );
						return;

					}

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			}

			function setTextureCube( texture, slot ) {

				var textureProperties = properties.get( texture );

				if ( texture.image.length === 6 ) {

					if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

						if ( ! textureProperties.__image__webglTextureCube ) {

							texture.addEventListener( 'dispose', onTextureDispose );

							textureProperties.__image__webglTextureCube = _gl.createTexture();

							_infoMemory.textures ++;

						}

						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

						_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

						var isCompressed = ( texture && texture.isCompressedTexture );
						var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

						var cubeImage = [];

						for ( var i = 0; i < 6; i ++ ) {

							if ( ! isCompressed && ! isDataTexture ) {

								cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

							} else {

								cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

							}

						}

						var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = paramThreeToGL( texture.format ),
						glType = paramThreeToGL( texture.type );

						setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

						for ( var i = 0; i < 6; i ++ ) {

							if ( ! isCompressed ) {

								if ( isDataTexture ) {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

								}

							} else {

								var mipmap, mipmaps = cubeImage[ i ].mipmaps;

								for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

									mipmap = mipmaps[ j ];

									if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

										if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

											state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

										} else {

											console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

										}

									} else {

										state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

									}

								}

							}

						}

						if ( texture.generateMipmaps && isPowerOfTwoImage ) {

							_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

						}

						textureProperties.__version = texture.version;

						if ( texture.onUpdate ) texture.onUpdate( texture );

					} else {

						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					}

				}

			}

			function setTextureCubeDynamic( texture, slot ) {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

			}

			function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

				var extension;

				if ( isPowerOfTwoImage ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

				} else {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

					if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

					}

					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

					if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

					}

				}

				extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension ) {

					if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
					if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

					if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

						_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
						properties.get( texture ).__currentAnisotropy = texture.anisotropy;

					}

				}

			}

			function uploadTexture( textureProperties, texture, slot ) {

				if ( textureProperties.__webglInit === undefined ) {

					textureProperties.__webglInit = true;

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__webglTexture = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

				var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

				if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

					image = makePowerOfTwo( image );

				}

				var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

				var mipmap, mipmaps = texture.mipmaps;

				if ( texture.isDepthTexture ) {

					// populate depth texture with dummy data

					var internalFormat = _gl.DEPTH_COMPONENT;

					if ( texture.type === FloatType ) {

						if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
						internalFormat = _gl.DEPTH_COMPONENT32F;

					} else if ( _isWebGL2 ) {

						// WebGL 2.0 requires signed internalformat for glTexImage2D
						internalFormat = _gl.DEPTH_COMPONENT16;

					}

					if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						        console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

							texture.type = UnsignedShortType;
							glType = paramThreeToGL( texture.type );

						}

					}

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.format === DepthStencilFormat ) {

						internalFormat = _gl.DEPTH_STENCIL;

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedInt248Type ) {

						        console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

							texture.type = UnsignedInt248Type;
							glType = paramThreeToGL( texture.type );

						}

					}

					state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

				} else if ( texture.isDataTexture ) {

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

						texture.generateMipmaps = false;

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isCompressedTexture ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

							if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

								state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {

								console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				} else {

					// regular Texture (image, video, canvas)

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

						}

						texture.generateMipmaps = false;

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

					}

				}

				if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			// Render targets

			// Setup storage for target texture and bind it to correct framebuffer
			function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

				var glFormat = paramThreeToGL( renderTarget.texture.format );
				var glType = paramThreeToGL( renderTarget.texture.type );
				state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
			function setupRenderBufferStorage( renderbuffer, renderTarget ) {

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

				if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

				} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

				} else {

					// FIXME: We don't support !depth !stencil
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

			}

			// Setup resources for a Depth Texture for a FBO (needs an extension)
			function setupDepthTexture( framebuffer, renderTarget ) {

				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

					throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

				}

				// upload an empty depth texture with framebuffer size
				if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
						renderTarget.depthTexture.image.width !== renderTarget.width ||
						renderTarget.depthTexture.image.height !== renderTarget.height ) {
					renderTarget.depthTexture.image.width = renderTarget.width;
					renderTarget.depthTexture.image.height = renderTarget.height;
					renderTarget.depthTexture.needsUpdate = true;
				}

				setTexture2D( renderTarget.depthTexture, 0 );

				var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

				if ( renderTarget.depthTexture.format === DepthFormat ) {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				} else {

					throw new Error('Unknown depthTexture format')

				}

			}

			// Setup GL resources for a non-texture depth buffer
			function setupDepthRenderbuffer( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );

				var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

				if ( renderTarget.depthTexture ) {

					if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

					setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

				} else {

					if ( isCube ) {

						renderTargetProperties.__webglDepthbuffer = [];

						for ( var i = 0; i < 6; i ++ ) {

							_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
							renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

						}

					} else {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

					}

				}

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			// Set up GL resources for the render target
			function setupRenderTarget( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures ++;

				var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

				// Setup framebuffer

				if ( isCube ) {

					renderTargetProperties.__webglFramebuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

					}

				} else {

					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				}

				// Setup color buffer

				if ( isCube ) {

					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

					}

					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

				} else {

					state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
					state.bindTexture( _gl.TEXTURE_2D, null );

				}

				// Setup depth and stencil buffers

				if ( renderTarget.depthBuffer ) {

					setupDepthRenderbuffer( renderTarget );

				}

			}

			function updateRenderTargetMipmap( renderTarget ) {

				var texture = renderTarget.texture;

				if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
						texture.minFilter !== NearestFilter &&
						texture.minFilter !== LinearFilter ) {

					var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					var webglTexture = properties.get( texture ).__webglTexture;

					state.bindTexture( target, webglTexture );
					_gl.generateMipmap( target );
					state.bindTexture( target, null );

				}

			}

			this.setTexture2D = setTexture2D;
			this.setTextureCube = setTextureCube;
			this.setTextureCubeDynamic = setTextureCubeDynamic;
			this.setupRenderTarget = setupRenderTarget;
			this.updateRenderTargetMipmap = updateRenderTargetMipmap;

		}

		/**
		 * @author fordacious / fordacious.github.io
		 */

		function WebGLProperties() {

			var properties = {};

			return {

				get: function ( object ) {

					var uuid = object.uuid;
					var map = properties[ uuid ];

					if ( map === undefined ) {

						map = {};
						properties[ uuid ] = map;

					}

					return map;

				},

				delete: function ( object ) {

					delete properties[ object.uuid ];

				},

				clear: function () {

					properties = {};

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLState( gl, extensions, paramThreeToGL ) {

			function ColorBuffer() {

				var locked = false;

				var color = new Vector4();
				var currentColorMask = null;
				var currentColorClear = new Vector4();

				return {

					setMask: function ( colorMask ) {

						if ( currentColorMask !== colorMask && ! locked ) {

							gl.colorMask( colorMask, colorMask, colorMask, colorMask );
							currentColorMask = colorMask;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( r, g, b, a, premultipliedAlpha ) {

						if ( premultipliedAlpha === true ) {

							r *= a; g *= a; b *= a;

						}

						color.set( r, g, b, a );

						if ( currentColorClear.equals( color ) === false ) {

							gl.clearColor( r, g, b, a );
							currentColorClear.copy( color );

						}

					},

					reset: function () {

						locked = false;

						currentColorMask = null;
						currentColorClear.set( 0, 0, 0, 1 );

					}

				};

			}

			function DepthBuffer() {

				var locked = false;

				var currentDepthMask = null;
				var currentDepthFunc = null;
				var currentDepthClear = null;

				return {

					setTest: function ( depthTest ) {

						if ( depthTest ) {

							enable( gl.DEPTH_TEST );

						} else {

							disable( gl.DEPTH_TEST );

						}

					},

					setMask: function ( depthMask ) {

						if ( currentDepthMask !== depthMask && ! locked ) {

							gl.depthMask( depthMask );
							currentDepthMask = depthMask;

						}

					},

					setFunc: function ( depthFunc ) {

						if ( currentDepthFunc !== depthFunc ) {

							if ( depthFunc ) {

								switch ( depthFunc ) {

									case NeverDepth:

										gl.depthFunc( gl.NEVER );
										break;

									case AlwaysDepth:

										gl.depthFunc( gl.ALWAYS );
										break;

									case LessDepth:

										gl.depthFunc( gl.LESS );
										break;

									case LessEqualDepth:

										gl.depthFunc( gl.LEQUAL );
										break;

									case EqualDepth:

										gl.depthFunc( gl.EQUAL );
										break;

									case GreaterEqualDepth:

										gl.depthFunc( gl.GEQUAL );
										break;

									case GreaterDepth:

										gl.depthFunc( gl.GREATER );
										break;

									case NotEqualDepth:

										gl.depthFunc( gl.NOTEQUAL );
										break;

									default:

										gl.depthFunc( gl.LEQUAL );

								}

							} else {

								gl.depthFunc( gl.LEQUAL );

							}

							currentDepthFunc = depthFunc;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( depth ) {

						if ( currentDepthClear !== depth ) {

							gl.clearDepth( depth );
							currentDepthClear = depth;

						}

					},

					reset: function () {

						locked = false;

						currentDepthMask = null;
						currentDepthFunc = null;
						currentDepthClear = null;

					}

				};

			}

			function StencilBuffer() {

				var locked = false;

				var currentStencilMask = null;
				var currentStencilFunc = null;
				var currentStencilRef = null;
				var currentStencilFuncMask = null;
				var currentStencilFail = null;
				var currentStencilZFail = null;
				var currentStencilZPass = null;
				var currentStencilClear = null;

				return {

					setTest: function ( stencilTest ) {

						if ( stencilTest ) {

							enable( gl.STENCIL_TEST );

						} else {

							disable( gl.STENCIL_TEST );

						}

					},

					setMask: function ( stencilMask ) {

						if ( currentStencilMask !== stencilMask && ! locked ) {

							gl.stencilMask( stencilMask );
							currentStencilMask = stencilMask;

						}

					},

					setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

						if ( currentStencilFunc !== stencilFunc ||
						     currentStencilRef 	!== stencilRef 	||
						     currentStencilFuncMask !== stencilMask ) {

							gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

							currentStencilFunc = stencilFunc;
							currentStencilRef = stencilRef;
							currentStencilFuncMask = stencilMask;

						}

					},

					setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

						if ( currentStencilFail	 !== stencilFail 	||
						     currentStencilZFail !== stencilZFail ||
						     currentStencilZPass !== stencilZPass ) {

							gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

							currentStencilFail = stencilFail;
							currentStencilZFail = stencilZFail;
							currentStencilZPass = stencilZPass;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( stencil ) {

						if ( currentStencilClear !== stencil ) {

							gl.clearStencil( stencil );
							currentStencilClear = stencil;

						}

					},

					reset: function () {

						locked = false;

						currentStencilMask = null;
						currentStencilFunc = null;
						currentStencilRef = null;
						currentStencilFuncMask = null;
						currentStencilFail = null;
						currentStencilZFail = null;
						currentStencilZPass = null;
						currentStencilClear = null;

					}

				};

			}

			//

			var colorBuffer = new ColorBuffer();
			var depthBuffer = new DepthBuffer();
			var stencilBuffer = new StencilBuffer();

			var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var newAttributes = new Uint8Array( maxVertexAttributes );
			var enabledAttributes = new Uint8Array( maxVertexAttributes );
			var attributeDivisors = new Uint8Array( maxVertexAttributes );

			var capabilities = {};

			var compressedTextureFormats = null;

			var currentBlending = null;
			var currentBlendEquation = null;
			var currentBlendSrc = null;
			var currentBlendDst = null;
			var currentBlendEquationAlpha = null;
			var currentBlendSrcAlpha = null;
			var currentBlendDstAlpha = null;
			var currentPremultipledAlpha = false;

			var currentFlipSided = null;
			var currentCullFace = null;

			var currentLineWidth = null;

			var currentPolygonOffsetFactor = null;
			var currentPolygonOffsetUnits = null;

			var currentScissorTest = null;

			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

			var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
			var lineWidthAvailable = parseFloat( version ) >= 1.0;

			var currentTextureSlot = null;
			var currentBoundTextures = {};

			var currentScissor = new Vector4();
			var currentViewport = new Vector4();

			function createTexture( type, target, count ) {

				var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
				var texture = gl.createTexture();

				gl.bindTexture( type, texture );
				gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
				gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

				for ( var i = 0; i < count; i ++ ) {

					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

				}

				return texture;

			}

			var emptyTextures = {};
			emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
			emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

			//

			function init() {

				colorBuffer.setClear( 0, 0, 0, 1 );
				depthBuffer.setClear( 1 );
				stencilBuffer.setClear( 0 );

				enable( gl.DEPTH_TEST );
				setDepthFunc( LessEqualDepth );

				setFlipSided( false );
				setCullFace( CullFaceBack );
				enable( gl.CULL_FACE );

				enable( gl.BLEND );
				setBlending( NormalBlending );

			}

			function initAttributes() {

				for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

					newAttributes[ i ] = 0;

				}

			}

			function enableAttribute( attribute ) {

				newAttributes[ attribute ] = 1;

				if ( enabledAttributes[ attribute ] === 0 ) {

					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;

				}

				if ( attributeDivisors[ attribute ] !== 0 ) {

					var extension = extensions.get( 'ANGLE_instanced_arrays' );

					extension.vertexAttribDivisorANGLE( attribute, 0 );
					attributeDivisors[ attribute ] = 0;

				}

			}

			function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {

				newAttributes[ attribute ] = 1;

				if ( enabledAttributes[ attribute ] === 0 ) {

					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;

				}

				if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

					extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
					attributeDivisors[ attribute ] = meshPerAttribute;

				}

			}

			function disableUnusedAttributes() {

				for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

					if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;

					}

				}

			}

			function enable( id ) {

				if ( capabilities[ id ] !== true ) {

					gl.enable( id );
					capabilities[ id ] = true;

				}

			}

			function disable( id ) {

				if ( capabilities[ id ] !== false ) {

					gl.disable( id );
					capabilities[ id ] = false;

				}

			}

			function getCompressedTextureFormats() {

				if ( compressedTextureFormats === null ) {

					compressedTextureFormats = [];

					if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

						var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

						for ( var i = 0; i < formats.length; i ++ ) {

							compressedTextureFormats.push( formats[ i ] );

						}

					}

				}

				return compressedTextureFormats;

			}

			function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

				if ( blending !== NoBlending ) {

					enable( gl.BLEND );

				} else {

					disable( gl.BLEND );

				}

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( blending === AdditiveBlending ) {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

						} else {

							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

						}

					} else if ( blending === SubtractiveBlending ) {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

						} else {

							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

						}

					} else if ( blending === MultiplyBlending ) {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

						} else {

							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

						}

					} else {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

						} else {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

						}

					}

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				if ( blending === CustomBlending ) {

					blendEquationAlpha = blendEquationAlpha || blendEquation;
					blendSrcAlpha = blendSrcAlpha || blendSrc;
					blendDstAlpha = blendDstAlpha || blendDst;

					if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

						gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

						currentBlendEquation = blendEquation;
						currentBlendEquationAlpha = blendEquationAlpha;
						console.log("setting custom blend state", blendEquation, blendEquationAlpha );
					}

					if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

						gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
						console.log("setting custom blend state", blendSrc, blendDst, blendSrcAlpha, blendDstAlpha );

						currentBlendSrc = blendSrc;
						currentBlendDst = blendDst;
						currentBlendSrcAlpha = blendSrcAlpha;
						currentBlendDstAlpha = blendDstAlpha;

					}

				} else {

					currentBlendEquation = null;
					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendEquationAlpha = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

				}

			}

			// TODO Deprecate

			function setColorWrite( colorWrite ) {

				colorBuffer.setMask( colorWrite );

			}

			function setDepthTest( depthTest ) {

				depthBuffer.setTest( depthTest );

			}

			function setDepthWrite( depthWrite ) {

				depthBuffer.setMask( depthWrite );

			}

			function setDepthFunc( depthFunc ) {

				depthBuffer.setFunc( depthFunc );

			}

			function setStencilTest( stencilTest ) {

				stencilBuffer.setTest( stencilTest );

			}

			function setStencilWrite( stencilWrite ) {

				stencilBuffer.setMask( stencilWrite );

			}

			function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

				stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );

			}

			function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

				stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );

			}

			//

			function setFlipSided( flipSided ) {

				if ( currentFlipSided !== flipSided ) {

					if ( flipSided ) {

						gl.frontFace( gl.CW );

					} else {

						gl.frontFace( gl.CCW );

					}

					currentFlipSided = flipSided;

				}

			}

			function setCullFace( cullFace ) {

				if ( cullFace !== CullFaceNone ) {

					enable( gl.CULL_FACE );

					if ( cullFace !== currentCullFace ) {

						if ( cullFace === CullFaceBack ) {

							gl.cullFace( gl.BACK );

						} else if ( cullFace === CullFaceFront ) {

							gl.cullFace( gl.FRONT );

						} else {

							gl.cullFace( gl.FRONT_AND_BACK );

						}

					}

				} else {

					disable( gl.CULL_FACE );

				}

				currentCullFace = cullFace;

			}

			function setLineWidth( width ) {

				if ( width !== currentLineWidth ) {

					if ( lineWidthAvailable ) gl.lineWidth( width );

					currentLineWidth = width;

				}

			}

			function setPolygonOffset( polygonOffset, factor, units ) {

				if ( polygonOffset ) {

					enable( gl.POLYGON_OFFSET_FILL );

					if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

						gl.polygonOffset( factor, units );

						currentPolygonOffsetFactor = factor;
						currentPolygonOffsetUnits = units;

					}

				} else {

					disable( gl.POLYGON_OFFSET_FILL );

				}

			}

			function getScissorTest() {

				return currentScissorTest;

			}

			function setScissorTest( scissorTest ) {

				currentScissorTest = scissorTest;

				if ( scissorTest ) {

					enable( gl.SCISSOR_TEST );

				} else {

					disable( gl.SCISSOR_TEST );

				}

			}

			// texture

			function activeTexture( webglSlot ) {

				if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

				if ( currentTextureSlot !== webglSlot ) {

					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;

				}

			}

			function bindTexture( webglType, webglTexture ) {

				if ( currentTextureSlot === null ) {

					activeTexture();

				}

				var boundTexture = currentBoundTextures[ currentTextureSlot ];

				if ( boundTexture === undefined ) {

					boundTexture = { type: undefined, texture: undefined };
					currentBoundTextures[ currentTextureSlot ] = boundTexture;

				}

				if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

					gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

					boundTexture.type = webglType;
					boundTexture.texture = webglTexture;

				}

			}

			function compressedTexImage2D() {

				try {

					gl.compressedTexImage2D.apply( gl, arguments );

				} catch ( error ) {

					console.error( error );

				}

			}

			function texImage2D() {

				try {

					gl.texImage2D.apply( gl, arguments );

				} catch ( error ) {

					console.error( error );

				}

			}

			//

			function scissor( scissor ) {

				if ( currentScissor.equals( scissor ) === false ) {

					gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
					currentScissor.copy( scissor );

				}

			}

			function viewport( viewport ) {

				if ( currentViewport.equals( viewport ) === false ) {

					gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
					currentViewport.copy( viewport );

				}

			}

			//

			function reset() {

				for ( var i = 0; i < enabledAttributes.length; i ++ ) {

					if ( enabledAttributes[ i ] === 1 ) {

						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;

					}

				}

				capabilities = {};

				compressedTextureFormats = null;

				currentTextureSlot = null;
				currentBoundTextures = {};

				currentBlending = null;

				currentFlipSided = null;
				currentCullFace = null;

				colorBuffer.reset();
				depthBuffer.reset();
				stencilBuffer.reset();

			}

			return {

				buffers: {
					color: colorBuffer,
					depth: depthBuffer,
					stencil: stencilBuffer
				},

				init: init,
				initAttributes: initAttributes,
				enableAttribute: enableAttribute,
				enableAttributeAndDivisor: enableAttributeAndDivisor,
				disableUnusedAttributes: disableUnusedAttributes,
				enable: enable,
				disable: disable,
				getCompressedTextureFormats: getCompressedTextureFormats,

				setBlending: setBlending,

				setColorWrite: setColorWrite,
				setDepthTest: setDepthTest,
				setDepthWrite: setDepthWrite,
				setDepthFunc: setDepthFunc,
				setStencilTest: setStencilTest,
				setStencilWrite: setStencilWrite,
				setStencilFunc: setStencilFunc,
				setStencilOp: setStencilOp,

				setFlipSided: setFlipSided,
				setCullFace: setCullFace,

				setLineWidth: setLineWidth,
				setPolygonOffset: setPolygonOffset,

				getScissorTest: getScissorTest,
				setScissorTest: setScissorTest,

				activeTexture: activeTexture,
				bindTexture: bindTexture,
				compressedTexImage2D: compressedTexImage2D,
				texImage2D: texImage2D,

				scissor: scissor,
				viewport: viewport,

				reset: reset

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLCapabilities( gl, extensions, parameters ) {

			var maxAnisotropy;

			function getMaxAnisotropy() {

				if ( maxAnisotropy !== undefined ) return maxAnisotropy;

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension !== null ) {

					maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

				} else {

					maxAnisotropy = 0;

				}

				return maxAnisotropy;

			}

			function getMaxPrecision( precision ) {

				if ( precision === 'highp' ) {

					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

						return 'highp';

					}

					precision = 'mediump';

				}

				if ( precision === 'mediump' ) {

					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

						return 'mediump';

					}

				}

				return 'lowp';

			}

			var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
			var maxPrecision = getMaxPrecision( precision );

			if ( maxPrecision !== precision ) {

				console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
				precision = maxPrecision;

			}

			var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
			var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
			var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
			var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

			var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
			var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
			var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

			var vertexTextures = maxVertexTextures > 0;
			var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
			var floatVertexTextures = vertexTextures && floatFragmentTextures;

			return {

				getMaxAnisotropy: getMaxAnisotropy,
				getMaxPrecision: getMaxPrecision,

				precision: precision,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				maxTextures: maxTextures,
				maxVertexTextures: maxVertexTextures,
				maxTextureSize: maxTextureSize,
				maxCubemapSize: maxCubemapSize,

				maxAttributes: maxAttributes,
				maxVertexUniforms: maxVertexUniforms,
				maxVaryings: maxVaryings,
				maxFragmentUniforms: maxFragmentUniforms,

				vertexTextures: vertexTextures,
				floatFragmentTextures: floatFragmentTextures,
				floatVertexTextures: floatVertexTextures

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLExtensions( gl ) {

			var extensions = {};

			return {

				get: function ( name ) {

					if ( extensions[ name ] !== undefined ) {

						return extensions[ name ];

					}

					var extension;

					switch ( name ) {

						case 'WEBGL_depth_texture':
							extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
							break;

						case 'EXT_texture_filter_anisotropic':
							extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
							break;

						case 'WEBGL_compressed_texture_s3tc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
							break;

						case 'WEBGL_compressed_texture_pvrtc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
							break;

						case 'WEBGL_compressed_texture_etc1':
							extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
							break;

						default:
							extension = gl.getExtension( name );

					}

					if ( extension === null ) {

						console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

					}

					extensions[ name ] = extension;

					return extension;

				}

			};

		}

		/**
		 * @author tschw
		 */

		function WebGLClipping() {

			var scope = this,

				globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false,

				plane = new Plane(),
				viewNormalMatrix = new Matrix3(),

				uniform = { value: null, needsUpdate: false };

			this.uniform = uniform;
			this.numPlanes = 0;
			this.numIntersection = 0;

			this.init = function( planes, enableLocalClipping, camera ) {

				var enabled =
					planes.length !== 0 ||
					enableLocalClipping ||
					// enable state of previous frame - the clipping code has to
					// run another frame in order to reset the state:
					numGlobalPlanes !== 0 ||
					localClippingEnabled;

				localClippingEnabled = enableLocalClipping;

				globalState = projectPlanes( planes, camera, 0 );
				numGlobalPlanes = planes.length;

				return enabled;

			};

			this.beginShadows = function() {

				renderingShadows = true;
				projectPlanes( null );

			};

			this.endShadows = function() {

				renderingShadows = false;
				resetGlobalState();

			};

			this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

				if ( ! localClippingEnabled ||
						planes === null || planes.length === 0 ||
						renderingShadows && ! clipShadows ) {
					// there's no local clipping

					if ( renderingShadows ) {
						// there's no global clipping

						projectPlanes( null );

					} else {

						resetGlobalState();
					}

				} else {

					var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4,

						dstArray = cache.clippingState || null;

					uniform.value = dstArray; // ensure unique state

					dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

					for ( var i = 0; i !== lGlobal; ++ i ) {

						dstArray[ i ] = globalState[ i ];

					}

					cache.clippingState = dstArray;
					this.numIntersection = clipIntersection ? this.numPlanes : 0;
					this.numPlanes += nGlobal;

				}


			};

			function resetGlobalState() {

				if ( uniform.value !== globalState ) {

					uniform.value = globalState;
					uniform.needsUpdate = numGlobalPlanes > 0;

				}

				scope.numPlanes = numGlobalPlanes;
				scope.numIntersection = 0;

			}

			function projectPlanes( planes, camera, dstOffset, skipTransform ) {

				var nPlanes = planes !== null ? planes.length : 0,
					dstArray = null;

				if ( nPlanes !== 0 ) {

					dstArray = uniform.value;

					if ( skipTransform !== true || dstArray === null ) {

						var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;

						viewNormalMatrix.getNormalMatrix( viewMatrix );

						if ( dstArray === null || dstArray.length < flatSize ) {

							dstArray = new Float32Array( flatSize );

						}

						for ( var i = 0, i4 = dstOffset;
											i !== nPlanes; ++ i, i4 += 4 ) {

							plane.copy( planes[ i ] ).
									applyMatrix4( viewMatrix, viewNormalMatrix );

							plane.normal.toArray( dstArray, i4 );
							dstArray[ i4 + 3 ] = plane.constant;

						}

					}

					uniform.value = dstArray;
					uniform.needsUpdate = true;

				}

				scope.numPlanes = nPlanes;

				return dstArray;

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Scene () {

			Object3D.call( this );

			this.type = 'Scene';

			this.background = null;
			this.fog = null;
			this.overrideMaterial = null;

			this.autoUpdate = true; // checked by the renderer

		}

		Scene.prototype = Object.create( Object3D.prototype );

		Scene.prototype.constructor = Scene;

		Scene.prototype.copy = function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		};

		Scene.prototype.toJSON = function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		};

		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 * @author tschw
		 */

		function WebGLRenderer( parameters ) {

			console.log( 'THREE.WebGLRenderer', REVISION );

			parameters = parameters || {};

			var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
				_context = parameters.context !== undefined ? parameters.context : null,

				_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
				_depth = parameters.depth !== undefined ? parameters.depth : true,
				_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
				_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
				_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
				_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

			var lights = [];

			var opaqueObjects = [];
			var opaqueObjectsLastIndex = - 1;
			var transparentObjects = [];
			var transparentObjectsLastIndex = - 1;

			var morphInfluences = new Float32Array( 8 );

			var sprites = [];
			var lensFlares = [];

			var passScene = null, passCamera = null, passQuad = null;

			// public properties

			this.domElement = _canvas;
			this.context = null;

			// clearing

			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;

			// scene graph

			this.sortObjects = true;

			// user-defined clipping

			this.clippingPlanes = [];
			this.localClippingEnabled = false;

			// physically based shading

			this.gammaFactor = 2.0;	// for backwards compatibility
			this.gammaInput = false;
			this.gammaOutput = false;

			// physical lights

			this.physicallyCorrectLights = false;

			// tone mapping

			this.toneMapping = LinearToneMapping;
			this.toneMappingExposure = 1.0;
			this.toneMappingWhitePoint = 1.0;

			// morphs

			this.maxMorphTargets = 8;
			this.maxMorphNormals = 4;

			// flags

			this.autoScaleCubemaps = true;
			this.autoResizeTextures = false;

			// internal properties

			var _this = this,

				// internal state cache

				_currentProgram = null,
				_currentRenderTarget = null,
				_currentFramebuffer = null,
				_currentMaterialId = - 1,
				_currentGeometryProgram = '',
				_currentCamera = null,

				_currentScissor = new Vector4(),
				_currentScissorTest = null,

				_currentViewport = new Vector4(),

				//

				_usedTextureUnits = 0,

				//

				_clearColor = new Color( 0x000000 ),
				_clearAlpha = 0,

				_width = _canvas.width,
				_height = _canvas.height,

				_pixelRatio = 1,

				_scissor = new Vector4( 0, 0, _width, _height ),
				_scissorTest = false,

				_viewport = new Vector4( 0, 0, _width, _height ),

				// frustum

				_frustum = new Frustum(),

				// clipping

				_clipping = new WebGLClipping(),
				_clippingEnabled = false,
				_localClippingEnabled = false,

				_sphere = new Sphere(),

				// camera matrices cache

				_projScreenMatrix = new Matrix4(),

				_vector3 = new Vector3(),
				_matrix4 = new Matrix4(),
				_matrix42 = new Matrix4(),

				// light arrays cache

				_lights = {

					hash: '',

				ambient: [ 0, 0, 0 ],
				directional: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				rectArea: [],
				point: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],

					shadows: []

				},

				// info

				_infoRender = {

					calls: 0,
					vertices: 0,
					faces: 0,
					points: 0

				};

			this.info = {

				render: _infoRender,
				memory: {

					geometries: 0,
					textures: 0

				},
				programs: null

			};


			// initialize

			var _gl;

			try {

				var attributes = {
					alpha: _alpha,
					depth: _depth,
					stencil: _stencil,
					antialias: _antialias,
					premultipliedAlpha: _premultipliedAlpha,
					preserveDrawingBuffer: _preserveDrawingBuffer
				};

				_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

				if ( _gl === null ) {

					if ( _canvas.getContext( 'webgl' ) !== null ) {

						throw 'Error creating WebGL context with your selected attributes.';

					} else {

						throw 'Error creating WebGL context.';

					}

				}

				// Some experimental-webgl implementations do not have getShaderPrecisionFormat

				if ( _gl.getShaderPrecisionFormat === undefined ) {

					_gl.getShaderPrecisionFormat = function () {

						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

					};

				}

				_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

			} catch ( error ) {

				console.error( 'THREE.WebGLRenderer: ' + error );

			}

			var extensions = new WebGLExtensions( _gl );

			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'ANGLE_instanced_arrays' );

			if ( extensions.get( 'OES_element_index_uint' ) ) {

				BufferGeometry.MaxIndex = 4294967296;

			}

			var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			var state = new WebGLState( _gl, extensions, paramThreeToGL );
			var properties = new WebGLProperties();
			var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
			var objects = new WebGLObjects( _gl, properties, this.info );
			var programCache = new WebGLPrograms( this, capabilities );
			var lightCache = new WebGLLights();

			this.info.programs = programCache.programs;

			var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
			var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

			//

			var backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
			var backgroundCamera2 = new PerspectiveCamera();
			var backgroundPlaneMesh = new Mesh(
				new PlaneBufferGeometry( 2, 2 ),
				new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
			);
			var backgroundBoxShader = ShaderLib[ 'cube' ];
			var backgroundBoxMesh = new Mesh(
				new BoxBufferGeometry( 5, 5, 5 ),
				new ShaderMaterial( {
					uniforms: backgroundBoxShader.uniforms,
					vertexShader: backgroundBoxShader.vertexShader,
					fragmentShader: backgroundBoxShader.fragmentShader,
					side: BackSide,
					depthTest: false,
					depthWrite: false,
					fog: false
				} )
			);

			//

			function getTargetPixelRatio() {

				return _currentRenderTarget === null ? _pixelRatio : 1;

			}

			function setDefaultGLState() {

				state.init();

				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

				state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

			}

			function resetGLState() {

				_currentProgram = null;
				_currentCamera = null;

				_currentGeometryProgram = '';
				_currentMaterialId = - 1;

				state.reset();

			}

			setDefaultGLState();

			this.context = _gl;
			this.capabilities = capabilities;
			this.extensions = extensions;
			this.properties = properties;
			this.state = state;

			// shadow map

			var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

			this.shadowMap = shadowMap;


			// Plugins

			var spritePlugin = new SpritePlugin( this, sprites );
			var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

			// API

			this.getContext = function () {

				return _gl;

			};

			this.getContextAttributes = function () {

				return _gl.getContextAttributes();

			};

			this.forceContextLoss = function () {

				extensions.get( 'WEBGL_lose_context' ).loseContext();

			};

			this.getMaxAnisotropy = function () {

				return capabilities.getMaxAnisotropy();

			};

			this.getPrecision = function () {

				return capabilities.precision;

			};

			this.getPixelRatio = function () {

				return _pixelRatio;

			};

			this.setPixelRatio = function ( value ) {

				if ( value === undefined ) return;

				_pixelRatio = value;

				this.setSize( _viewport.z, _viewport.w, false );

			};

			this.getSize = function () {

				return {
					width: _width,
					height: _height
				};

			};

			this.setSize = function ( width, height, updateStyle ) {

				_width = width;
				_height = height;

				_canvas.width = width * _pixelRatio;
				_canvas.height = height * _pixelRatio;

				if ( updateStyle !== false ) {

					_canvas.style.width = width + 'px';
					_canvas.style.height = height + 'px';

				}

				this.setViewport( 0, 0, width, height );

			};

			this.setViewport = function ( x, y, width, height ) {

				state.viewport( _viewport.set( x, y, width, height ) );

			};

			this.setScissor = function ( x, y, width, height ) {

				state.scissor( _scissor.set( x, y, width, height ) );

			};

			this.setScissorTest = function ( boolean ) {

				state.setScissorTest( _scissorTest = boolean );

			};

			// Clearing

			this.getClearColor = function () {

				return _clearColor;

			};

			this.setClearColor = function ( color, alpha ) {

				_clearColor.set( color );

				_clearAlpha = alpha !== undefined ? alpha : 1;

				state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

			};

			this.getClearAlpha = function () {

				return _clearAlpha;

			};

			this.setClearAlpha = function ( alpha ) {

				_clearAlpha = alpha;

				state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

			};

			this.clear = function ( color, depth, stencil ) {

				var bits = 0;

				if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
				if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
				if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

				_gl.clear( bits );

			};

			this.clearColor = function () {

				this.clear( true, false, false );

			};

			this.clearDepth = function () {

				this.clear( false, true, false );

			};

			this.clearStencil = function () {

				this.clear( false, false, true );

			};

			this.clearTarget = function ( renderTarget, color, depth, stencil ) {

				this.setRenderTarget( renderTarget );
				this.clear( color, depth, stencil );

			};

			// Reset

			this.resetGLState = resetGLState;

			this.dispose = function() {

				transparentObjects = [];
				transparentObjectsLastIndex = -1;
				opaqueObjects = [];
				opaqueObjectsLastIndex = -1;

				_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

			};

			// Events

			function onContextLost( event ) {

				event.preventDefault();

				resetGLState();
				setDefaultGLState();

				properties.clear();

			}

			function onMaterialDispose( event ) {

				var material = event.target;

				material.removeEventListener( 'dispose', onMaterialDispose );

				deallocateMaterial( material );

			}

			// Buffer deallocation

			function deallocateMaterial( material ) {

				releaseMaterialProgramReference( material );

				properties.delete( material );

			}


			function releaseMaterialProgramReference( material ) {

				var programInfo = properties.get( material ).program;

				material.program = undefined;

				if ( programInfo !== undefined ) {

					programCache.releaseProgram( programInfo );

				}

			}

			// Buffer rendering

			this.renderBufferImmediate = function ( object, program, material ) {

				state.initAttributes();

				var buffers = properties.get( object );

				if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
				if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
				if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
				if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

				var attributes = program.getAttributes();

				if ( object.hasPositions ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( object.hasNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

					if ( ! material.isMeshPhongMaterial &&
						! material.isMeshStandardMaterial &&
						! material.isMeshNormalMaterial &&
						material.shading === FlatShading ) {

						for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

							var array = object.normalArray;

							var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
							var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
							var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

							array[ i + 0 ] = nx;
							array[ i + 1 ] = ny;
							array[ i + 2 ] = nz;

							array[ i + 3 ] = nx;
							array[ i + 4 ] = ny;
							array[ i + 5 ] = nz;

							array[ i + 6 ] = nx;
							array[ i + 7 ] = ny;
							array[ i + 8 ] = nz;

						}

					}

					_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.normal );

					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( object.hasUvs && material.map ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.uv );

					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				}

				if ( object.hasColors && material.vertexColors !== NoColors ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.color );

					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				}

				state.disableUnusedAttributes();

				_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

				object.count = 0;

			};

			this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

				setMaterial( material );

				var program = setProgram( camera, fog, material, object );

				var updateBuffers = false;
				var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

				if ( geometryProgram !== _currentGeometryProgram ) {

					_currentGeometryProgram = geometryProgram;
					updateBuffers = true;

				}

				// morph targets

				var morphTargetInfluences = object.morphTargetInfluences;

				if ( morphTargetInfluences !== undefined ) {

					var activeInfluences = [];

					for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

						var influence = morphTargetInfluences[ i ];
						activeInfluences.push( [ influence, i ] );

					}

					activeInfluences.sort( absNumericalSort );

					if ( activeInfluences.length > 8 ) {

						activeInfluences.length = 8;

					}

					var morphAttributes = geometry.morphAttributes;

					for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

						var influence = activeInfluences[ i ];
						morphInfluences[ i ] = influence[ 0 ];

						if ( influence[ 0 ] !== 0 ) {

							var index = influence[ 1 ];

							if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
							if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

						} else {

							if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
							if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

						}

					}

					for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

						morphInfluences[ i ] = 0.0;

					}

					program.getUniforms().setValue(
						_gl, 'morphTargetInfluences', morphInfluences );

					updateBuffers = true;

				}

				//

				var index = geometry.index;
				var position = geometry.attributes.position;
				var rangeFactor = 1;

				if ( material.wireframe === true ) {

					index = objects.getWireframeAttribute( geometry );
					rangeFactor = 2;

				}

				var renderer;

				if ( index !== null ) {

					renderer = indexedBufferRenderer;
					renderer.setIndex( index );

				} else {

					renderer = bufferRenderer;

				}

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry );

					if ( index !== null ) {

						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

					}

				}

				//

				var dataCount = 0;

				if ( index !== null ) {

					dataCount = index.count;

				} else if ( position !== undefined ) {

					dataCount = position.count;

				}

				var rangeStart = geometry.drawRange.start * rangeFactor;
				var rangeCount = geometry.drawRange.count * rangeFactor;

				var groupStart = group !== null ? group.start * rangeFactor : 0;
				var groupCount = group !== null ? group.count * rangeFactor : Infinity;

				var drawStart = Math.max( rangeStart, groupStart );
				var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

				var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

				if ( drawCount === 0 ) return;

				//

				if ( object.isMesh ) {

					if ( material.wireframe === true ) {

						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );

					} else {

						switch ( object.drawMode ) {

							case TrianglesDrawMode:
								renderer.setMode( _gl.TRIANGLES );
								break;

							case TriangleStripDrawMode:
								renderer.setMode( _gl.TRIANGLE_STRIP );
								break;

							case TriangleFanDrawMode:
								renderer.setMode( _gl.TRIANGLE_FAN );
								break;

						}

					}


				} else if ( object.isLine ) {

					var lineWidth = material.linewidth;

					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

					state.setLineWidth( lineWidth * getTargetPixelRatio() );

					if ( object.isLineSegments ) {

						renderer.setMode( _gl.LINES );

					} else {

						renderer.setMode( _gl.LINE_STRIP );

					}

				} else if ( object.isPoints ) {

					renderer.setMode( _gl.POINTS );

				}

				if ( geometry && geometry.isInstancedBufferGeometry ) {

					if ( geometry.maxInstancedCount > 0 ) {

						renderer.renderInstances( geometry, drawStart, drawCount );

					}

				} else {

					renderer.render( drawStart, drawCount );

				}

			};

			function setupVertexAttributes( material, program, geometry, startIndex ) {

				var extension;

				if ( geometry && geometry.isInstancedBufferGeometry ) {

					extension = extensions.get( 'ANGLE_instanced_arrays' );

					if ( extension === null ) {

						console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
						return;

					}

				}

				if ( startIndex === undefined ) startIndex = 0;

				state.initAttributes();

				var geometryAttributes = geometry.attributes;

				var programAttributes = program.getAttributes();

				var materialDefaultAttributeValues = material.defaultAttributeValues;

				for ( var name in programAttributes ) {

					var programAttribute = programAttributes[ name ];

					if ( programAttribute >= 0 ) {

						var geometryAttribute = geometryAttributes[ name ];

						if ( geometryAttribute !== undefined ) {

							var normalized = geometryAttribute.normalized;
							var size = geometryAttribute.itemSize;

							var attributeProperties = objects.getAttributeProperties( geometryAttribute );

							var buffer = attributeProperties.__webglBuffer;
							var type = attributeProperties.type;
							var bytesPerElement = attributeProperties.bytesPerElement;

							if ( geometryAttribute.isInterleavedBufferAttribute ) {

								var data = geometryAttribute.data;
								var stride = data.stride;
								var offset = geometryAttribute.offset;

								if ( data && data.isInstancedInterleavedBuffer ) {

									state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

									if ( geometry.maxInstancedCount === undefined ) {

										geometry.maxInstancedCount = data.meshPerAttribute * data.count;

									}

								} else {

									state.enableAttribute( programAttribute );

								}

								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );

							} else {

								if ( geometryAttribute.isInstancedBufferAttribute ) {

									state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

									if ( geometry.maxInstancedCount === undefined ) {

										geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

									}

								} else {

									state.enableAttribute( programAttribute );

								}

								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );

							}

						} else if ( materialDefaultAttributeValues !== undefined ) {

							var value = materialDefaultAttributeValues[ name ];

							if ( value !== undefined ) {

								switch ( value.length ) {

									case 2:
										_gl.vertexAttrib2fv( programAttribute, value );
										break;

									case 3:
										_gl.vertexAttrib3fv( programAttribute, value );
										break;

									case 4:
										_gl.vertexAttrib4fv( programAttribute, value );
										break;

									default:
										_gl.vertexAttrib1fv( programAttribute, value );

								}

							}

						}

					}

				}

				state.disableUnusedAttributes();

			}

			// Sorting

			function absNumericalSort( a, b ) {

				return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

			}

			function painterSortStable( a, b ) {

				if ( a.object.renderOrder !== b.object.renderOrder ) {

					return a.object.renderOrder - b.object.renderOrder;

				} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {

					return a.material.program.id - b.material.program.id;

				} else if ( a.material.id !== b.material.id ) {

					return a.material.id - b.material.id;

				} else if ( a.z !== b.z ) {

					return a.z - b.z;

				} else {

					return a.id - b.id;

				}

			}

			function reversePainterSortStable( a, b ) {

				if ( a.object.renderOrder !== b.object.renderOrder ) {

					return a.object.renderOrder - b.object.renderOrder;

				} if ( a.z !== b.z ) {

					return b.z - a.z;

				} else {

					return a.id - b.id;

				}

			}

			// Rendering

			this.renderOverride = function ( overrideMaterial, scene, camera, renderTarget, forceClear ) {

				scene.overrideMaterial = overrideMaterial;
				this.render( scene, camera, renderTarget, forceClear );
				scene.overrideMaterial = null;

			};

			this.renderPass = function ( passMaterial, renderTarget, forceClear ) {

				if( passScene === null ) {
					passCamera = new OrthographicCamera( -1, 1, 1, -1, 0, 1 );
					passQuad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
					passScene = new Scene();
					passScene.add( passQuad );
				}

				passQuad.material = passMaterial;
				this.render( passScene, passCamera, renderTarget, forceClear );
				passQuad.material = null;

			};


			this.render = function ( scene, camera, renderTarget, forceClear ) {

				if ( camera !== undefined && camera.isCamera !== true ) {

					console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;

				}

				// reset caching for this frame

				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
				_currentCamera = null;

				// update scene graph

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

				// update camera matrices and frustum

				if ( camera.parent === null ) camera.updateMatrixWorld();

				camera.matrixWorldInverse.getInverse( camera.matrixWorld );

				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				lights.length = 0;

				opaqueObjectsLastIndex = - 1;
				transparentObjectsLastIndex = - 1;

				sprites.length = 0;
				lensFlares.length = 0;

				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

				projectObject( scene, camera );

				opaqueObjects.length = opaqueObjectsLastIndex + 1;
				transparentObjects.length = transparentObjectsLastIndex + 1;

				if ( _this.sortObjects === true ) {

					opaqueObjects.sort( painterSortStable );
					transparentObjects.sort( reversePainterSortStable );

				}

				//

				if ( _clippingEnabled ) _clipping.beginShadows();

				setupShadows( lights );

				shadowMap.render( scene, camera );

				setupLights( lights, camera );

				if ( _clippingEnabled ) _clipping.endShadows();

				//

				_infoRender.calls = 0;
				_infoRender.vertices = 0;
				_infoRender.faces = 0;
				_infoRender.points = 0;

				if ( renderTarget === undefined ) {

					renderTarget = null;

				}

				//console.log( "render() renderTarget: ", renderTarget );

				this.setRenderTarget( renderTarget );

				//

				var background = scene.background;
				background = null;

				if ( background === null ) {

					state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

				} else if ( background && background.isColor ) {

					state.buffers.color.setClear( background.r, background.g, background.b, 1, _premultipliedAlpha );
					forceClear = true;

				}

				if ( this.autoClear || forceClear ) {

					this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

				}

				if ( background && background.isCubeTexture ) {

					backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );

					backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
					backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );

					backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
					backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

					objects.update( backgroundBoxMesh );

					_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

				} else if ( background && background.isTexture ) {

					backgroundPlaneMesh.material.map = background;

					objects.update( backgroundPlaneMesh );

					_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

				}

				//

				if ( scene.overrideMaterial ) {

					var overrideMaterial = scene.overrideMaterial;

					renderObjects( opaqueObjects, scene, camera, overrideMaterial );
					renderObjects( transparentObjects, scene, camera, overrideMaterial );

				} else {

					// opaque pass (front-to-back order)

					state.setBlending( NoBlending );
					renderObjects( opaqueObjects, scene, camera );

					// transparent pass (back-to-front order)

					renderObjects( transparentObjects, scene, camera );

				}

				// custom render plugins (post pass)

				spritePlugin.render( scene, camera );
				lensFlarePlugin.render( scene, camera, _currentViewport );

				// Generate mipmap if we're using any kind of mipmap filtering

				if ( renderTarget ) {

					textures.updateRenderTargetMipmap( renderTarget );

				}

				// Ensure depth buffer writing is enabled so it can be cleared on next render

				state.setDepthTest( true );
				state.setDepthWrite( true );
				state.setColorWrite( true );

				// _gl.finish();

			};

			function pushRenderItem( object, geometry, material, z, group ) {

				var array, index;

				// allocate the next position in the appropriate array

				if ( material.transparent ) {

					array = transparentObjects;
					index = ++ transparentObjectsLastIndex;

				} else {

					array = opaqueObjects;
					index = ++ opaqueObjectsLastIndex;

				}

				// recycle existing render item or grow the array

				var renderItem = array[ index ];

				if ( renderItem !== undefined ) {

					renderItem.id = object.id;
					renderItem.object = object;
					renderItem.geometry = geometry;
					renderItem.material = material;
					renderItem.z = _vector3.z;
					renderItem.group = group;

				} else {

					renderItem = {
						id: object.id,
						object: object,
						geometry: geometry,
						material: material,
						z: _vector3.z,
						group: group
					};

					// assert( index === array.length );
					array.push( renderItem );

				}

			}

			// TODO Duplicated code (Frustum)

			function isObjectViewable( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();

				_sphere.copy( geometry.boundingSphere ).
				applyMatrix4( object.matrixWorld );

				return isSphereViewable( _sphere );

			}

			function isSpriteViewable( sprite ) {

				_sphere.center.set( 0, 0, 0 );
				_sphere.radius = 0.7071067811865476;
				_sphere.applyMatrix4( sprite.matrixWorld );

				return isSphereViewable( _sphere );

			}

			function isSphereViewable( sphere ) {

				if ( ! _frustum.intersectsSphere( sphere ) ) return false;

				var numPlanes = _clipping.numPlanes;

				if ( numPlanes === 0 ) return true;

				var planes = _this.clippingPlanes,

					center = sphere.center,
					negRad = - sphere.radius,
					i = 0;

				do {

					// out when deeper than radius in the negative halfspace
					if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

				} while ( ++ i !== numPlanes );

				return true;

			}

			function projectObject( object, camera ) {

				if ( object.visible === false ) return;

				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

				if ( visible ) {

					if ( object.isLight ) {

						lights.push( object );

					} else if ( object.isSprite ) {

						if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

							sprites.push( object );

						}

					} else if ( object.isLensFlare ) {

						lensFlares.push( object );

					} else if ( object.isImmediateRenderObject ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyMatrix4( _projScreenMatrix );

						}

						pushRenderItem( object, null, object.material, _vector3.z, null );

					} else if ( object.isMesh || object.isLine || object.isPoints ) {

						if ( object.isSkinnedMesh ) {

							object.skeleton.update();

						}

						if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

							var material = object.material;

							if ( material.visible === true ) {

								if ( _this.sortObjects === true ) {

									_vector3.setFromMatrixPosition( object.matrixWorld );
									_vector3.applyMatrix4( _projScreenMatrix );

								}

								var geometry = objects.update( object );

								if ( material.isMultiMaterial ) {

									var groups = geometry.groups;
									var materials = material.materials;

									for ( var i = 0, l = groups.length; i < l; i ++ ) {

										var group = groups[ i ];
										var groupMaterial = materials[ group.materialIndex ];

										if ( groupMaterial.visible === true ) {

											pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

										}

									}

								} else {

									pushRenderItem( object, geometry, material, _vector3.z, null );

								}

							}

						}

					}

				}

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera );

				}

			}

			function renderObjects( renderList, scene, camera, overrideMaterial ) {

				for ( var i = 0, l = renderList.length; i < l; i ++ ) {

					var renderItem = renderList[ i ];

					var object = renderItem.object;
					var geometry = renderItem.geometry;
					var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
					var group = renderItem.group;

					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
					object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

					object.onBeforeRender( _this, scene, camera, geometry, material, group );

					if ( object.isImmediateRenderObject ) {

						setMaterial( material );

						var program = setProgram( camera, scene.fog, material, object );

						_currentGeometryProgram = '';

						object.render( function ( object ) {

							_this.renderBufferImmediate( object, program, material );

						} );

					} else {

						_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

					}

					object.onAfterRender( _this, scene, camera, geometry, material, group );


				}

			}

			function initMaterial( material, fog, object ) {

				var materialProperties = properties.get( material );

				var parameters = programCache.getParameters(
					material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );

				var code = programCache.getProgramCode( material, parameters );

				var program = materialProperties.program;
				var programChange = true;

				if ( program === undefined ) {

					// new material
					material.addEventListener( 'dispose', onMaterialDispose );

				} else if ( program.code !== code ) {

					// changed glsl or parameters
					releaseMaterialProgramReference( material );

				} else if ( parameters.shaderID !== undefined ) {

					// same glsl and uniform list
					return;

				} else {

					// only rebuild uniform list
					programChange = false;

				}

				if ( programChange ) {

					if ( parameters.shaderID ) {

						var shader = ShaderLib[ parameters.shaderID ];

						materialProperties.__webglShader = {
							name: material.type,
							uniforms: UniformsUtils.clone( shader.uniforms ),
							vertexShader: shader.vertexShader,
							fragmentShader: shader.fragmentShader
						};

					} else {

						materialProperties.__webglShader = {
							name: material.type,
							uniforms: material.uniforms,
							vertexShader: material.vertexShader,
							fragmentShader: material.fragmentShader
						};

					}

					material.__webglShader = materialProperties.__webglShader;

					program = programCache.acquireProgram( material, parameters, code );

					materialProperties.program = program;
					material.program = program;

				}

				var attributes = program.getAttributes();

				if ( material.morphTargets ) {

					material.numSupportedMorphTargets = 0;

					for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

						if ( attributes[ 'morphTarget' + i ] >= 0 ) {

							material.numSupportedMorphTargets ++;

						}

					}

				}

				if ( material.morphNormals ) {

					material.numSupportedMorphNormals = 0;

					for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

						if ( attributes[ 'morphNormal' + i ] >= 0 ) {

							material.numSupportedMorphNormals ++;

						}

					}

				}

				var uniforms = materialProperties.__webglShader.uniforms;

				if ( ! material.isShaderMaterial &&
					! material.isRawShaderMaterial ||
					material.clipping === true ) {

					materialProperties.numClippingPlanes = _clipping.numPlanes;
					materialProperties.numIntersection = _clipping.numIntersection;
					uniforms.clippingPlanes = _clipping.uniform;

				}

				materialProperties.fog = fog;

				// store the light setup it was created for

				materialProperties.lightsHash = _lights.hash;

				if ( material.lights ) {

					// wire up the material to this renderer's lighting state

					uniforms.ambientLightColor.value = _lights.ambient;
					uniforms.directionalLights.value = _lights.directional;
					uniforms.spotLights.value = _lights.spot;
					uniforms.rectAreaLights.value = _lights.rectArea;
					uniforms.pointLights.value = _lights.point;
					uniforms.hemisphereLights.value = _lights.hemi;

					uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
					uniforms.spotShadowMap.value = _lights.spotShadowMap;
					uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
					uniforms.pointShadowMap.value = _lights.pointShadowMap;
					uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
					// TODO (abelnation): add area lights shadow info to uniforms

				}

				var progUniforms = materialProperties.program.getUniforms(),
					uniformsList =
						WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

				materialProperties.uniformsList = uniformsList;

			}

			function setMaterial( material ) {

				material.side === DoubleSide
					? state.disable( _gl.CULL_FACE )
					: state.enable( _gl.CULL_FACE );

				state.setFlipSided( material.side === BackSide );

				material.transparent === true
					? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
					: state.setBlending( NoBlending );

				state.setDepthFunc( material.depthFunc );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
				state.setColorWrite( material.colorWrite );
				state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			}

			function setProgram( camera, fog, material, object ) {

				_usedTextureUnits = 0;

				var materialProperties = properties.get( material );

				if ( _clippingEnabled ) {

					if ( _localClippingEnabled || camera !== _currentCamera ) {

						var useCache =
							camera === _currentCamera &&
							material.id === _currentMaterialId;

						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						_clipping.setState(
							material.clippingPlanes, material.clipIntersection, material.clipShadows,
							camera, materialProperties, useCache );

					}

				}

				if ( material.needsUpdate === false ) {

					if ( materialProperties.program === undefined ) {

						material.needsUpdate = true;

					} else if ( material.fog && materialProperties.fog !== fog ) {

						material.needsUpdate = true;

					} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

						material.needsUpdate = true;

					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
						materialProperties.numIntersection  !== _clipping.numIntersection ) ) {

						material.needsUpdate = true;

					}

				}

				if ( material.needsUpdate ) {

					initMaterial( material, fog, object );
					material.needsUpdate = false;

				}

				var refreshProgram = false;
				var refreshMaterial = false;
				var refreshLights = false;

				var program = materialProperties.program,
					p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.__webglShader.uniforms;

				if ( program.id !== _currentProgram ) {

					_gl.useProgram( program.program );
					_currentProgram = program.id;

					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;

				}

				if ( material.id !== _currentMaterialId ) {

					_currentMaterialId = material.id;

					refreshMaterial = true;

				}

				if ( refreshProgram || camera !== _currentCamera ) {

					p_uniforms.set( _gl, camera, 'projectionMatrix' );

					if ( capabilities.logarithmicDepthBuffer ) {

						p_uniforms.setValue( _gl, 'logDepthBufFC',
							2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

					}


					if ( camera !== _currentCamera ) {

						_currentCamera = camera;

						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:

						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done

					}

					// load material specific uniforms
					// (shader material also gets them for the sake of genericity)

					if ( material.isShaderMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshStandardMaterial ||
						material.envMap ) {

						var uCamPos = p_uniforms.map.cameraPosition;

						if ( uCamPos !== undefined ) {

							uCamPos.setValue( _gl,
								_vector3.setFromMatrixPosition( camera.matrixWorld ) );

						}

					}

					if ( material.isMeshPhongMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ||
						material.skinning ) {

						p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

					}

					p_uniforms.set( _gl, _this, 'toneMappingExposure' );
					p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

				}

				// skinning uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone texture must go before other textures
				// not sure why, but otherwise weird things happen

				if ( material.skinning ) {

					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

					var skeleton = object.skeleton;

					if ( skeleton ) {

						if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

							p_uniforms.set( _gl, skeleton, 'boneTexture' );
							p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
							p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

						} else {

							p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

						}

					}

				}

				if ( refreshMaterial ) {

					if ( material.lights ) {

						// the current material requires lighting info

						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required

						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

					}

					// refresh uniforms common to several materials

					if ( fog && material.fog ) {

						refreshUniformsFog( m_uniforms, fog );

					}

					if ( material.isMeshBasicMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshStandardMaterial ||
						material.isMeshDepthMaterial ||
						material.isMeshNormalMaterial ||
						material.isMeshCubeMaterial ) {

						refreshUniformsCommon( m_uniforms, material );

					}

					// refresh single material specific uniforms

					if ( material.isLineBasicMaterial ) {

						refreshUniformsLine( m_uniforms, material );

					} else if ( material.isLineDashedMaterial ) {

						refreshUniformsLine( m_uniforms, material );
						refreshUniformsDash( m_uniforms, material );

					} else if ( material.isPointsMaterial ) {

						refreshUniformsPoints( m_uniforms, material );

					} else if ( material.isMeshCubeMaterial ) {

						refreshUniformsCube( m_uniforms, material );

					} else if ( material.isMeshLambertMaterial ) {

						refreshUniformsLambert( m_uniforms, material );

					} else if ( material.isMeshToonMaterial ) {

						refreshUniformsToon( m_uniforms, material );

					} else if ( material.isMeshPhongMaterial ) {

						refreshUniformsPhong( m_uniforms, material );

					} else if ( material.isMeshPhysicalMaterial ) {

						refreshUniformsPhysical( m_uniforms, material );

					} else if ( material.isMeshStandardMaterial ) {

						refreshUniformsStandard( m_uniforms, material );

					} else if ( material.isMeshDepthMaterial ) {

						if ( material.displacementMap ) {

							m_uniforms.displacementMap.value = material.displacementMap;
							m_uniforms.displacementScale.value = material.displacementScale;
							m_uniforms.displacementBias.value = material.displacementBias;

						}

					} else if ( material.isMeshNormalMaterial ) {

						refreshUniformsNormal( m_uniforms, material );

					}

					// RectAreaLight Texture
					// TODO (mrdoob): Find a nicer implementation

					if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE;
					if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE;

					WebGLUniforms.upload(
						_gl, materialProperties.uniformsList, m_uniforms, _this );

				}


				// common matrices

				p_uniforms.set( _gl, object, 'modelViewMatrix' );
				p_uniforms.set( _gl, object, 'normalMatrix' );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

				return program;

			}

			// Uniforms (refresh uniforms objects)

			var texelTransform = { texelScale: 0, texelOffset: 0 };

			function refreshUniformsCommon( uniforms, material ) {

				uniforms.opacity.value = material.opacity;

				uniforms.diffuse.value = material.color;

				if ( material.emissive ) {

					uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

				}

				var supportedMapNames = MaterialMap.SupportedMapNames;
				var supportedMapSlotNames = MaterialMap.SupportedMapSlotNames;
				var supportedMapUVNames = MaterialMap.SupportedMapUVNames;
				var supportedMapTexelNames = MaterialMap.SupportedMapTexelNames;

				if( ! material.usedSlots || material.usedSlotsVersion != material.version ) {
					material.usedSlots = [];
					for( var i = 0, il = supportedMapNames.length; i < il; i ++ ) {
						var mapName = supportedMapNames[i];
						var mapSlotName = supportedMapSlotNames[i];

						var map = material[ mapSlotName ];

						material.usedSlots.push( {
							index: i,
							mapUniform: uniforms[mapName],
							uvUniform: uniforms[ supportedMapUVNames[i] ],
							texelUniform: uniforms[ supportedMapTexelNames[i] ]
						} );
					}
					material.usedSlotsVersion = material.version;
				}

				for( var j = 0, jl = material.usedSlots.length; j < jl; j ++ ) {
					var usedSlots = material.usedSlots[j];
					var i = usedSlots.index;

					var mapName = supportedMapNames[i];
					var mapSlotName = supportedMapSlotNames[i];

					var map = material[ mapSlotName ];
					if( map ) {
						usedSlots.mapUniform.value = map.texture;
						if( map.texture ) {
							if( map.uvTransform ) {
								var value = usedSlots.uvUniform.value;
								value.set(
									map.uvRepeat.x,
									map.uvRepeat.y,
									map.uvOffset.x,
									map.uvOffset.y );
							}
							if( map.texelTransform ) {
								texelTransform = map.getFlattenedTexelTransform( texelTransform );
								usedSlots.texelUniform.value.set( texelTransform.texelScale, texelTransform.texelOffset );
							}
						}
					}
					else if( material[ mapName ] ) {
						uniforms[mapName].value = material[mapName];
					}
				}
				//uniforms.map.value = material.map;
				//uniforms.specularMap.value = material.specularMap;
				//uniforms.alphaMap.value = material.alphaMap;

				if ( material.lightMap ) {

					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;

				}

				if ( material.aoMap ) {

					//uniforms.aoMap.value = material.aoMap;
					uniforms.aoMapIntensity.value = material.aoMapIntensity;

				}

				// uv repeat and offset setting priorities
				// 1. color map
				// 2. specular map
				// 3. normal map
				// 4. bump map
				// 5. alpha map
				// 6. emissive map

				var uvScaleMap;

				if ( material.map ) {

					uvScaleMap = material.map;

				} else if ( material.specularMap ) {

					uvScaleMap = material.specularMap;

				} else if ( material.displacementMap ) {

					uvScaleMap = material.displacementMap;

				} else if ( material.normalMap ) {

					uvScaleMap = material.normalMap;

				} else if ( material.bumpMap ) {

					uvScaleMap = material.bumpMap;

				} else if ( material.roughnessMap ) {

					uvScaleMap = material.roughnessMap;

				} else if ( material.metalnessMap ) {

					uvScaleMap = material.metalnessMap;

				} else if ( material.alphaMap ) {

					uvScaleMap = material.alphaMap;

				} else if ( material.emissiveMap ) {

					uvScaleMap = material.emissiveMap;

				}

				if ( uvScaleMap !== undefined ) {

					// backwards compatibility
					if ( uvScaleMap.isWebGLRenderTarget ) {

						uvScaleMap = uvScaleMap.texture;

					}

					var offset = uvScaleMap.offset;
					var repeat = uvScaleMap.repeat;

					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

				}

				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			function refreshUniformsCube ( uniforms, material ) {

				uniforms.roughness.value = material.roughness;
				uniforms.opacity.value = material.opacity;
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

			function refreshUniformsLine( uniforms, material ) {

				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;

			}

			function refreshUniformsDash( uniforms, material ) {

				uniforms.dashSize.value = material.dashSize;
				uniforms.totalSize.value = material.dashSize + material.gapSize;
				uniforms.scale.value = material.scale;

			}

			function refreshUniformsPoints( uniforms, material ) {

				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
				uniforms.size.value = material.size * _pixelRatio;
				uniforms.scale.value = _height * 0.5;

				uniforms.map.value = material.map;

				if ( material.map !== null ) {

					var offset = material.map.offset;
					var repeat = material.map.repeat;

					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

				}

			}

			function refreshUniformsFog( uniforms, fog ) {

				uniforms.fogColor.value = fog.color;

				if ( fog.isFog ) {

					uniforms.fogNear.value = fog.near;
					uniforms.fogFar.value = fog.far;

				} else if ( fog.isFogExp2 ) {

					uniforms.fogDensity.value = fog.density;

				}

			}

			function refreshUniformsLambert( uniforms, material ) {

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

			}

			function refreshUniformsPhong( uniforms, material ) {

				uniforms.specular.value = material.specular;
				uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

			}

			function refreshUniformsToon( uniforms, material ) {

				refreshUniformsPhong( uniforms, material );

				if ( material.gradientMap ) {

					uniforms.gradientMap.value = material.gradientMap;

				}

			}

			function refreshUniformsStandard( uniforms, material ) {

				uniforms.roughness.value = material.roughness;
				uniforms.metalness.value = material.metalness;

				if ( material.roughnessMap ) {

					uniforms.roughnessMap.value = material.roughnessMap;

				}

				if ( material.metalnessMap ) {

					uniforms.metalnessMap.value = material.metalnessMap;

				}

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

				if ( material.envMap ) {

					//uniforms.envMap.value = material.envMap; // part of uniforms common
					uniforms.envMapIntensity.value = material.envMapIntensity;

				}

			}

			function refreshUniformsPhysical( uniforms, material ) {

				uniforms.falloffDiffuse.value = material.falloffColor;
				if ( material.falloffMap ) {
					uniforms.falloffMap.value = material.falloffMap;
				}

				uniforms.falloffOpacity.value = material.falloffOpacity;
				if ( material.falloffAlphaMap ) {
					uniforms.falloffAlphaMap.value = material.falloffAlphaMap;
				}

				uniforms.clearCoat.value = material.clearCoat;
				uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

				refreshUniformsStandard( uniforms, material );

			}

			function refreshUniformsNormal( uniforms, material ) {

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

			}

			// If uniforms are marked as clean, they don't need to be loaded to the GPU.

			function markUniformsLightsNeedsUpdate( uniforms, value ) {

				uniforms.ambientLightColor.needsUpdate = value;

				uniforms.directionalLights.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.rectAreaLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;

			}

			// Lighting

			function setupShadows( lights ) {

				var lightShadowsLength = 0;

				for ( var i = 0, l = lights.length; i < l; i ++ ) {

					var light = lights[ i ];

					if ( light.castShadow ) {

						_lights.shadows[ lightShadowsLength ++ ] = light;

					}

				}

				_lights.shadows.length = lightShadowsLength;

			}

			function setupLights( lights, camera ) {

				var l, ll, light,
					r = 0, g = 0, b = 0,
					color,
					intensity,
					distance,
					shadowMap,

					viewMatrix = camera.matrixWorldInverse,

				directionalLength = 0,
				pointLength = 0,
				spotLength = 0,
				rectAreaLength = 0,
				hemiLength = 0;

				for ( l = 0, ll = lights.length; l < ll; l ++ ) {

					light = lights[ l ];

					color = light.color;
					intensity = light.intensity;
					distance = light.distance;

					shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

					if ( light.isAmbientLight ) {

						r += color.r * intensity;
						g += color.g * intensity;
						b += color.b * intensity;

					} else if ( light.isDirectionalLight ) {

						var uniforms = lightCache.get( light );

						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );

						uniforms.shadow = light.castShadow;

						if ( light.castShadow ) {

							uniforms.shadowBias = light.shadow.bias;
							uniforms.spreadAngle = light.shadow.spreadAngle;
							uniforms.shadowMapSize = light.shadow.mapSize;
							uniforms.shadowCameraParams = light.shadow.cameraParams;

						}

						_lights.directionalShadowMap[ directionalLength ] = shadowMap;
						_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
						_lights.directional[ directionalLength ++ ] = uniforms;

					} else if ( light.isSpotLight ) {

						var uniforms = lightCache.get( light );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						uniforms.color.copy( color ).multiplyScalar( intensity );
						uniforms.distance = distance;

						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );

						uniforms.coneCos = Math.cos( light.angle );
						uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

						uniforms.shadow = light.castShadow;

						if ( light.castShadow ) {

							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
							uniforms.shadowCameraParams = light.shadow.cameraParams;

						}

						_lights.spotShadowMap[ spotLength ] = shadowMap;
						_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
						_lights.spot[ spotLength ++ ] = uniforms;

					} else if ( light.isRectAreaLight ) {

						var uniforms = lightCache.get( light );

						// (a) intensity controls irradiance of entire light
						uniforms.color
							.copy( color )
							.multiplyScalar( intensity / ( light.width * light.height ) );

						// (b) intensity controls the radiance per light area
						// uniforms.color.copy( color ).multiplyScalar( intensity );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						// extract local rotation of light to derive width/height half vectors
						_matrix42.identity();
						_matrix4.copy( light.matrixWorld );
						_matrix4.premultiply( viewMatrix );
						_matrix42.extractRotation( _matrix4 );

						uniforms.halfWidth.set( light.width * 0.5,                0.0, 0.0 );
						uniforms.halfHeight.set(              0.0, light.height * 0.5, 0.0 );

						uniforms.halfWidth.applyMatrix4( _matrix42 );
						uniforms.halfHeight.applyMatrix4( _matrix42 );

						// TODO (abelnation): RectAreaLight distance?
						// uniforms.distance = distance;

						_lights.rectArea[ rectAreaLength ++ ] = uniforms;

					} else if ( light.isPointLight ) {

						var uniforms = lightCache.get( light );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.distance = light.distance;
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

						uniforms.shadow = light.castShadow;

						if ( light.castShadow ) {

							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;

						}

						_lights.pointShadowMap[ pointLength ] = shadowMap;

						if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

							_lights.pointShadowMatrix[ pointLength ] = new Matrix4();

						}

						// for point lights we set the shadow matrix to be a translation-only matrix
						// equal to inverse of the light's position
						_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
						_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

						_lights.point[ pointLength ++ ] = uniforms;

					} else if ( light.isHemisphereLight ) {

						var uniforms = lightCache.get( light );

						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						uniforms.direction.transformDirection( viewMatrix );
						uniforms.direction.normalize();

						uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
						uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

						_lights.hemi[ hemiLength ++ ] = uniforms;

					}

				}

				_lights.ambient[ 0 ] = r;
				_lights.ambient[ 1 ] = g;
				_lights.ambient[ 2 ] = b;

				_lights.directional.length = directionalLength;
				_lights.spot.length = spotLength;
				_lights.rectArea.length = rectAreaLength;
				_lights.point.length = pointLength;
				_lights.hemi.length = hemiLength;

				// TODO (sam-g-steel) why aren't we using join
				_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;

			}

			// GL state setting

			this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

				state.setCullFace( cullFace );
				state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

			};

			// Textures

			function allocTextureUnit() {

				var textureUnit = _usedTextureUnits;

				if ( textureUnit >= capabilities.maxTextures ) {

					console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

				}

				_usedTextureUnits += 1;

				return textureUnit;

			}

			this.allocTextureUnit = allocTextureUnit;

			// this.setTexture2D = setTexture2D;
			this.setTexture2D = ( function() {

				var warned = false;

				// backwards compatibility: peel texture.texture
				return function setTexture2D( texture, slot ) {

					if ( texture && texture.isWebGLRenderTarget ) {

						if ( ! warned ) {

							console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.", texture );
							warned = true;

						}

						texture = texture.texture;

					}

					textures.setTexture2D( texture, slot );

				};

			}() );

			this.setTexture = ( function() {

				var warned = false;

				return function setTexture( texture, slot ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
						warned = true;

					}

					textures.setTexture2D( texture, slot );

				};

			}() );

			this.setTextureCube = ( function() {

				var warned = false;

				return function setTextureCube( texture, slot ) {

					// backwards compatibility: peel texture.texture
					if ( texture && texture.isWebGLRenderTargetCube ) {

						if ( ! warned ) {

							console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.", texture );
							warned = true;

						}

						texture = texture.texture;

					}

					// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
					// TODO: unify these code paths
					if ( ( texture && texture.isCubeTexture ) ||
						( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

						// CompressedTexture can have Array in image :/

						// this function alone should take care of cube textures
						textures.setTextureCube( texture, slot );

					} else {

						// assumed: texture property of THREE.WebGLRenderTargetCube

						textures.setTextureCubeDynamic( texture, slot );

					}

				};

			}() );

			this.getCurrentRenderTarget = function() {

				return _currentRenderTarget;

			};

			this.setRenderTarget = function ( renderTarget ) {

				_currentRenderTarget = renderTarget;

				if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( renderTarget );

				}

				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				var framebuffer;

				if ( renderTarget ) {

					var renderTargetProperties = properties.get( renderTarget );

					if ( isCube ) {

						framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

					} else {

						framebuffer = renderTargetProperties.__webglFramebuffer;

					}

					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;

					_currentViewport.copy( renderTarget.viewport );

				} else {

					framebuffer = null;

					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
					_currentScissorTest = _scissorTest;

					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

				}

				if ( _currentFramebuffer !== framebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
					_currentFramebuffer = framebuffer;

				}

				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );

				state.viewport( _currentViewport );

				if ( isCube ) {

					var textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

				}

			};

			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

				if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;

				}

				var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( framebuffer ) {

					var restore = false;

					if ( framebuffer !== _currentFramebuffer ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

						restore = true;

					}

					try {

						var texture = renderTarget.texture;
						var textureFormat = texture.format;
						var textureType = texture.type;

						if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;

						}

						if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
							! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
							! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;

						}

						if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

							// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

							if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

								_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

							}

						} else {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

						}

					} finally {

						if ( restore ) {

							_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

						}

					}

				}

			};

			// MaterialMap three.js constants to WebGL constants

			function paramThreeToGL( p ) {

				var extension;

				if ( p === RepeatWrapping ) return _gl.REPEAT;
				if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
				if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

				if ( p === NearestFilter ) return _gl.NEAREST;
				if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
				if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

				if ( p === LinearFilter ) return _gl.LINEAR;
				if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
				if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

				if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
				if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
				if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
				if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

				if ( p === ByteType ) return _gl.BYTE;
				if ( p === ShortType ) return _gl.SHORT;
				if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
				if ( p === IntType ) return _gl.INT;
				if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
				if ( p === FloatType ) return _gl.FLOAT;

				if ( p === HalfFloatType ) {

					extension = extensions.get( 'OES_texture_half_float' );

					if ( extension !== null ) return extension.HALF_FLOAT_OES;

				}

				if ( p === AlphaFormat ) return _gl.ALPHA;
				if ( p === RGBFormat ) return _gl.RGB;
				if ( p === RGBAFormat ) return _gl.RGBA;
				if ( p === LuminanceFormat ) return _gl.LUMINANCE;
				if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
				if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
				if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

				if ( p === AddEquation ) return _gl.FUNC_ADD;
				if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
				if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

				if ( p === ZeroFactor ) return _gl.ZERO;
				if ( p === OneFactor ) return _gl.ONE;
				if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
				if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
				if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
				if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
				if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
				if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

				if ( p === DstColorFactor ) return _gl.DST_COLOR;
				if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
				if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

				if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
					p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

					}

				}

				if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
					p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

					if ( extension !== null ) {

						if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
						if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
						if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
						if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

					}

				}

				if ( p === RGB_ETC1_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

					if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

				}

				if ( p === MinEquation || p === MaxEquation ) {

					extension = extensions.get( 'EXT_blend_minmax' );

					if ( extension !== null ) {

						if ( p === MinEquation ) return extension.MIN_EXT;
						if ( p === MaxEquation ) return extension.MAX_EXT;

					}

				}

				if ( p === UnsignedInt248Type ) {

					extension = extensions.get( 'WEBGL_depth_texture' );

					if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

				}

				return 0;

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function FogExp2 ( color, density ) {

			this.name = '';

			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;

		}

		FogExp2.prototype.isFogExp2 = true;

		FogExp2.prototype.clone = function () {

			return new FogExp2( this.color.getHex(), this.density );

		};

		FogExp2.prototype.toJSON = function ( meta ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Fog ( color, near, far ) {

			this.name = '';

			this.color = new Color( color );

			this.near = ( near !== undefined ) ? near : 1;
			this.far = ( far !== undefined ) ? far : 1000;

		}

		Fog.prototype.isFog = true;

		Fog.prototype.clone = function () {

			return new Fog( this.color.getHex(), this.near, this.far );

		};

		Fog.prototype.toJSON = function ( meta ) {

			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function LensFlare( texture, size, distance, blending, color ) {

			Object3D.call( this );

			this.lensFlares = [];

			this.positionScreen = new Vector3();
			this.customUpdateCallback = undefined;

			if ( texture !== undefined ) {

				this.add( texture, size, distance, blending, color );

			}

		}

		LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: LensFlare,

			isLensFlare: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.positionScreen.copy( source.positionScreen );
				this.customUpdateCallback = source.customUpdateCallback;

				for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

					this.lensFlares.push( source.lensFlares[ i ] );

				}

				return this;

			},

			add: function ( texture, size, distance, blending, color, opacity ) {

				if ( size === undefined ) size = - 1;
				if ( distance === undefined ) distance = 0;
				if ( opacity === undefined ) opacity = 1;
				if ( color === undefined ) color = new Color( 0xffffff );
				if ( blending === undefined ) blending = NormalBlending;

				distance = Math.min( distance, Math.max( 0, distance ) );

				this.lensFlares.push( {
					texture: texture,	// THREE.Texture
					size: size, 		// size in pixels (-1 = use texture.width)
					distance: distance, 	// distance (0-1) from light source (0=at light source)
					x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
					scale: 1, 		// scale
					rotation: 0, 		// rotation
					opacity: opacity,	// opacity
					color: color,		// color
					blending: blending	// blending
				} );

			},

			/*
			 * Update lens flares update positions on all flares based on the screen position
			 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
			 */

			updateLensFlares: function () {

				var f, fl = this.lensFlares.length;
				var flare;
				var vecX = - this.positionScreen.x * 2;
				var vecY = - this.positionScreen.y * 2;

				for ( f = 0; f < fl; f ++ ) {

					flare = this.lensFlares[ f ];

					flare.x = this.positionScreen.x + vecX * flare.distance;
					flare.y = this.positionScreen.y + vecY * flare.distance;

					flare.wantedRotation = flare.x * Math.PI * 0.25;
					flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

				}

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *	uvOffset: new THREE.Vector2(),
		 *	uvScale: new THREE.Vector2()
		 * }
		 */

		function SpriteMaterial( parameters ) {

			Material.call( this );

			this.type = 'SpriteMaterial';

			this.color = new Color( 0xffffff );
			this.map = null;

			this.rotation = 0;

			this.fog = false;
			this.lights = false;

			this.setValues( parameters );

		}

		SpriteMaterial.prototype = Object.create( Material.prototype );
		SpriteMaterial.prototype.constructor = SpriteMaterial;

		SpriteMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.map = source.map;

			this.rotation = source.rotation;

			return this;

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Sprite( material ) {

			Object3D.call( this );

			this.type = 'Sprite';

			this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		}

		Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Sprite,

			isSprite: true,

			raycast: ( function () {

				var matrixPosition = new Vector3();

				return function raycast( raycaster, intersects ) {

					matrixPosition.setFromMatrixPosition( this.matrixWorld );

					var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
					var guessSizeSq = this.scale.x * this.scale.y / 4;

					if ( distanceSq > guessSizeSq ) {

						return;

					}

					intersects.push( {

						distance: Math.sqrt( distanceSq ),
						point: this.position,
						face: null,
						object: this

					} );

				};

			}() ),

			clone: function () {

				return new this.constructor( this.material ).copy( this );

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LOD() {

			Object3D.call( this );

			this.type = 'LOD';

			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				}
			} );

		}


		LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: LOD,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source, false );

				var levels = source.levels;

				for ( var i = 0, l = levels.length; i < l; i ++ ) {

					var level = levels[ i ];

					this.addLevel( level.object.clone(), level.distance );

				}

				return this;

			},

			addLevel: function ( object, distance ) {

				if ( distance === undefined ) distance = 0;

				distance = Math.abs( distance );

				var levels = this.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					if ( distance < levels[ l ].distance ) {

						break;

					}

				}

				levels.splice( l, 0, { distance: distance, object: object } );

				this.add( object );

			},

			getObjectForDistance: function ( distance ) {

				var levels = this.levels;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance < levels[ i ].distance ) {

						break;

					}

				}

				return levels[ i - 1 ].object;

			},

			raycast: ( function () {

				var matrixPosition = new Vector3();

				return function raycast( raycaster, intersects ) {

					matrixPosition.setFromMatrixPosition( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( matrixPosition );

					this.getObjectForDistance( distance ).raycast( raycaster, intersects );

				};

			}() ),

			update: function () {

				var v1 = new Vector3();
				var v2 = new Vector3();

				return function update( camera ) {

					var levels = this.levels;

					if ( levels.length > 1 ) {

						v1.setFromMatrixPosition( camera.matrixWorld );
						v2.setFromMatrixPosition( this.matrixWorld );

						var distance = v1.distanceTo( v2 );

						levels[ 0 ].object.visible = true;

						for ( var i = 1, l = levels.length; i < l; i ++ ) {

							if ( distance >= levels[ i ].distance ) {

								levels[ i - 1 ].object.visible = false;
								levels[ i ].object.visible = true;

							} else {

								break;

							}

						}

						for ( ; i < l; i ++ ) {

							levels[ i ].object.visible = false;

						}

					}

				};

			}(),

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.levels = [];

				var levels = this.levels;

				for ( var i = 0, l = levels.length; i < l; i ++ ) {

					var level = levels[ i ];

					data.object.levels.push( {
						object: level.object.uuid,
						distance: level.distance
					} );

				}

				return data;

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author michael guerrero / http://realitymeltdown.com
		 * @author ikerr / http://verold.com
		 */

		function Skeleton( bones, boneInverses, useVertexTexture ) {

			this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

			this.identityMatrix = new Matrix4();

			// copy the bone array

			bones = bones || [];

			this.bones = bones.slice( 0 );

			// create a bone texture or an array of floats

			if ( this.useVertexTexture ) {

				// layout (1 matrix = 4 pixels)
				//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
				//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
				//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
				//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
				//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


				var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
				size = _Math.nextPowerOfTwo( Math.ceil( size ) );
				size = Math.max( size, 4 );

				this.boneTextureWidth = size;
				this.boneTextureHeight = size;

				this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
				this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );

			} else {

				this.boneMatrices = new Float32Array( 16 * this.bones.length );

			}

			// use the supplied bone inverses or calculate the inverses

			if ( boneInverses === undefined ) {

				this.calculateInverses();

			} else {

				if ( this.bones.length === boneInverses.length ) {

					this.boneInverses = boneInverses.slice( 0 );

				} else {

					console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

					this.boneInverses = [];

					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

						this.boneInverses.push( new Matrix4() );

					}

				}

			}

		}

		Object.assign( Skeleton.prototype, {

			calculateInverses: function () {

				this.boneInverses = [];

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					var inverse = new Matrix4();

					if ( this.bones[ b ] ) {

						inverse.getInverse( this.bones[ b ].matrixWorld );

					}

					this.boneInverses.push( inverse );

				}

			},

			pose: function () {

				var bone;

				// recover the bind-time world matrices

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					bone = this.bones[ b ];

					if ( bone ) {

						bone.matrixWorld.getInverse( this.boneInverses[ b ] );

					}

				}

				// compute the local matrices, positions, rotations and scales

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					bone = this.bones[ b ];

					if ( bone ) {

						if ( bone.parent && bone.parent.isBone ) {

							bone.matrix.getInverse( bone.parent.matrixWorld );
							bone.matrix.multiply( bone.matrixWorld );

						} else {

							bone.matrix.copy( bone.matrixWorld );

						}

						bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

					}

				}

			},

			update: ( function () {

				var offsetMatrix = new Matrix4();

				return function update() {

					// flatten bone matrices to array

					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

						// compute the offset between the current and the original transform

						var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

						offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
						offsetMatrix.toArray( this.boneMatrices, b * 16 );

					}

					if ( this.useVertexTexture ) {

						this.boneTexture.needsUpdate = true;

					}

				};

			} )(),

			clone: function () {

				return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */

		function Bone() {

			Object3D.call( this );

			this.type = 'Bone';

		}

		Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Bone,

			isBone: true

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */

		function SkinnedMesh( geometry, material, useVertexTexture ) {

			Mesh.call( this, geometry, material );

			this.type = 'SkinnedMesh';

			this.bindMode = "attached";
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();

			// init bones

			// TODO: remove bone creation as there is no reason (other than
			// convenience) for THREE.SkinnedMesh to do this.

			var bones = [];

			if ( this.geometry && this.geometry.bones !== undefined ) {

				var bone, gbone;

				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

					gbone = this.geometry.bones[ b ];

					bone = new Bone();
					bones.push( bone );

					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

				}

				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

					gbone = this.geometry.bones[ b ];

					if ( gbone.parent !== - 1 && gbone.parent !== null &&
							bones[ gbone.parent ] !== undefined ) {

						bones[ gbone.parent ].add( bones[ b ] );

					} else {

						this.add( bones[ b ] );

					}

				}

			}

			this.normalizeSkinWeights();

			this.updateMatrixWorld( true );
			this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

		}


		SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

			constructor: SkinnedMesh,

			isSkinnedMesh: true,

			bind: function( skeleton, bindMatrix ) {

				this.skeleton = skeleton;

				if ( bindMatrix === undefined ) {

					this.updateMatrixWorld( true );

					this.skeleton.calculateInverses();

					bindMatrix = this.matrixWorld;

				}

				this.bindMatrix.copy( bindMatrix );
				this.bindMatrixInverse.getInverse( bindMatrix );

			},

			pose: function () {

				this.skeleton.pose();

			},

			normalizeSkinWeights: function () {

				if ( this.geometry && this.geometry.isGeometry ) {

					for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

						var sw = this.geometry.skinWeights[ i ];

						var scale = 1.0 / sw.lengthManhattan();

						if ( scale !== Infinity ) {

							sw.multiplyScalar( scale );

						} else {

							sw.set( 1, 0, 0, 0 ); // do something reasonable

						}

					}

				} else if ( this.geometry && this.geometry.isBufferGeometry ) {

					var vec = new Vector4();

					var skinWeight = this.geometry.attributes.skinWeight;

					for ( var i = 0; i < skinWeight.count; i ++ ) {

						vec.x = skinWeight.getX( i );
						vec.y = skinWeight.getY( i );
						vec.z = skinWeight.getZ( i );
						vec.w = skinWeight.getW( i );

						var scale = 1.0 / vec.lengthManhattan();

						if ( scale !== Infinity ) {

							vec.multiplyScalar( scale );

						} else {

							vec.set( 1, 0, 0, 0 ); // do something reasonable

						}

						skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

					}

				}

			},

			updateMatrixWorld: function( force ) {

				Mesh.prototype.updateMatrixWorld.call( this, true );

				if ( this.bindMode === "attached" ) {

					this.bindMatrixInverse.getInverse( this.matrixWorld );

				} else if ( this.bindMode === "detached" ) {

					this.bindMatrixInverse.getInverse( this.bindMatrix );

				} else {

					console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

				}

			},

			clone: function() {

				return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *  linecap: "round",
		 *  linejoin: "round"
		 * }
		 */

		function LineBasicMaterial( parameters ) {

			Material.call( this );

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.lights = false;

			this.setValues( parameters );

		}

		LineBasicMaterial.prototype = Object.create( Material.prototype );
		LineBasicMaterial.prototype.constructor = LineBasicMaterial;

		LineBasicMaterial.prototype.isLineBasicMaterial = true;

		LineBasicMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Line( geometry, material, mode ) {

			if ( mode === 1 ) {

				console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
				return new LineSegments( geometry, material );

			}

			Object3D.call( this );

			this.type = 'Line';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

		}

		Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Line,

			isLine: true,

			raycast: ( function () {

				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();

				return function raycast( raycaster, intersects ) {

					var precision = raycaster.linePrecision;
					var precisionSq = precision * precision;

					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;

					// Checking boundingSphere distance to ray

					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );

					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

					//

					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

					var vStart = new Vector3();
					var vEnd = new Vector3();
					var interSegment = new Vector3();
					var interRay = new Vector3();
					var step = (this && this.isLineSegments) ? 2 : 1;

					if ( geometry.isBufferGeometry ) {

						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;

						if ( index !== null ) {

							var indices = index.array;

							for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

								var a = indices[ i ];
								var b = indices[ i + 1 ];

								vStart.fromArray( positions, a * 3 );
								vEnd.fromArray( positions, b * 3 );

								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

								if ( distSq > precisionSq ) continue;

								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

								var distance = raycaster.ray.origin.distanceTo( interRay );

								if ( distance < raycaster.near || distance > raycaster.far ) continue;

								intersects.push( {

									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this

								} );

							}

						} else {

							for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

								vStart.fromArray( positions, 3 * i );
								vEnd.fromArray( positions, 3 * i + 3 );

								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

								if ( distSq > precisionSq ) continue;

								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

								var distance = raycaster.ray.origin.distanceTo( interRay );

								if ( distance < raycaster.near || distance > raycaster.far ) continue;

								intersects.push( {

									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this

								} );

							}

						}

					} else if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;
						var nbVertices = vertices.length;

						for ( var i = 0; i < nbVertices - 1; i += step ) {

							var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				};

			}() ),

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LineSegments( geometry, material ) {

			Line.call( this, geometry, material );

			this.type = 'LineSegments';

		}

		LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

			constructor: LineSegments,

			isLineSegments: true

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  size: <float>,
		 *  sizeAttenuation: <bool>
		 * }
		 */

		function PointsMaterial( parameters ) {

			Material.call( this );

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.lights = false;

			this.setValues( parameters );

		}

		PointsMaterial.prototype = Object.create( Material.prototype );
		PointsMaterial.prototype.constructor = PointsMaterial;

		PointsMaterial.prototype.isPointsMaterial = true;

		PointsMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			return this;

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Points( geometry, material ) {

			Object3D.call( this );

			this.type = 'Points';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

		}

		Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Points,

			isPoints: true,

			raycast: ( function () {

				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();

				return function raycast( raycaster, intersects ) {

					var object = this;
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
					var threshold = raycaster.params.Points.threshold;

					// Checking boundingSphere distance to ray

					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );

					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

					//

					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

					var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
					var localThresholdSq = localThreshold * localThreshold;
					var position = new Vector3();

					function testPoint( point, index ) {

						var rayPointDistanceSq = ray.distanceSqToPoint( point );

						if ( rayPointDistanceSq < localThresholdSq ) {

							var intersectPoint = ray.closestPointToPoint( point );
							intersectPoint.applyMatrix4( matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectPoint );

							if ( distance < raycaster.near || distance > raycaster.far ) return;

							intersects.push( {

								distance: distance,
								distanceToRay: Math.sqrt( rayPointDistanceSq ),
								point: intersectPoint.clone(),
								index: index,
								face: null,
								object: object

							} );

						}

					}

					if ( geometry.isBufferGeometry ) {

						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;

						if ( index !== null ) {

							var indices = index.array;

							for ( var i = 0, il = indices.length; i < il; i ++ ) {

								var a = indices[ i ];

								position.fromArray( positions, a * 3 );

								testPoint( position, a );

							}

						} else {

							for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

								position.fromArray( positions, i * 3 );

								testPoint( position, i );

							}

						}

					} else {

						var vertices = geometry.vertices;

						for ( var i = 0, l = vertices.length; i < l; i ++ ) {

							testPoint( vertices[ i ], i );

						}

					}

				};

			}() ),

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Group() {

			Object3D.call( this );

			this.type = 'Group';

		}

		Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Group

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.generateMipmaps = false;

			var scope = this;

			function update() {

				requestAnimationFrame( update );

				if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

					scope.needsUpdate = true;

				}

			}

			update();

		}

		VideoTexture.prototype = Object.create( Texture.prototype );
		VideoTexture.prototype.constructor = VideoTexture;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;

			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false;

			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;

		}

		CompressedTexture.prototype = Object.create( Texture.prototype );
		CompressedTexture.prototype.constructor = CompressedTexture;

		CompressedTexture.prototype.isCompressedTexture = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.needsUpdate = true;

		}

		CanvasTexture.prototype = Object.create( Texture.prototype );
		CanvasTexture.prototype.constructor = CanvasTexture;

		/**
		 * @author Matt DesLauriers / @mattdesl
		 * @author atix / arthursilber.de
		 */

		function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

			format = format !== undefined ? format : DepthFormat;

			if ( format !== DepthFormat && format !== DepthStencilFormat ) {

				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

			}

			if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
			if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.image = { width: width, height: height };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.flipY = false;
			this.generateMipmaps	= false;

		}

		DepthTexture.prototype = Object.create( Texture.prototype );
		DepthTexture.prototype.constructor = DepthTexture;
		DepthTexture.prototype.isDepthTexture = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WireframeGeometry( geometry ) {

			BufferGeometry.call( this );

			var edge = [ 0, 0 ], hash = {};

			function sortFunction( a, b ) {

				return a - b;

			}

			var keys = [ 'a', 'b', 'c' ];

			if ( geometry && geometry.isGeometry ) {

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var numEdges = 0;

				// allocate maximal size
				var edges = new Uint32Array( 6 * faces.length );

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = face[ keys[ j ] ];
						edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numEdges; i < l; i ++ ) {

					for ( var j = 0; j < 2; j ++ ) {

						var vertex = vertices[ edges [ 2 * i + j ] ];

						var index = 6 * i + 3 * j;
						coords[ index + 0 ] = vertex.x;
						coords[ index + 1 ] = vertex.y;
						coords[ index + 2 ] = vertex.z;

					}

				}

				this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

			} else if ( geometry && geometry.isBufferGeometry ) {

				if ( geometry.index !== null ) {

					// Indexed BufferGeometry

					var indices = geometry.index.array;
					var vertices = geometry.attributes.position;
					var groups = geometry.groups;
					var numEdges = 0;

					if ( groups.length === 0 ) {

						geometry.addGroup( 0, indices.length );

					}

					// allocate maximal size
					var edges = new Uint32Array( 2 * indices.length );

					for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

						var group = groups[ o ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							for ( var j = 0; j < 3; j ++ ) {

								edge[ 0 ] = indices[ i + j ];
								edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
								edge.sort( sortFunction );

								var key = edge.toString();

								if ( hash[ key ] === undefined ) {

									edges[ 2 * numEdges ] = edge[ 0 ];
									edges[ 2 * numEdges + 1 ] = edge[ 1 ];
									hash[ key ] = true;
									numEdges ++;

								}

							}

						}

					}

					var coords = new Float32Array( numEdges * 2 * 3 );

					for ( var i = 0, l = numEdges; i < l; i ++ ) {

						for ( var j = 0; j < 2; j ++ ) {

							var index = 6 * i + 3 * j;
							var index2 = edges[ 2 * i + j ];

							coords[ index + 0 ] = vertices.getX( index2 );
							coords[ index + 1 ] = vertices.getY( index2 );
							coords[ index + 2 ] = vertices.getZ( index2 );

						}

					}

					this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

				} else {

					// non-indexed BufferGeometry

					var vertices = geometry.attributes.position.array;
					var numEdges = vertices.length / 3;
					var numTris = numEdges / 3;

					var coords = new Float32Array( numEdges * 2 * 3 );

					for ( var i = 0, l = numTris; i < l; i ++ ) {

						for ( var j = 0; j < 3; j ++ ) {

							var index = 18 * i + 6 * j;

							var index1 = 9 * i + 3 * j;
							coords[ index + 0 ] = vertices[ index1 ];
							coords[ index + 1 ] = vertices[ index1 + 1 ];
							coords[ index + 2 ] = vertices[ index1 + 2 ];

							var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
							coords[ index + 3 ] = vertices[ index2 ];
							coords[ index + 4 ] = vertices[ index2 + 1 ];
							coords[ index + 5 ] = vertices[ index2 + 2 ];

						}

					}

					this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

				}

			}

		}

		WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
		WireframeGeometry.prototype.constructor = WireframeGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */

		function ParametricBufferGeometry( func, slices, stacks ) {

			BufferGeometry.call( this );

			this.type = 'ParametricBufferGeometry';

			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};

			// generate vertices and uvs

			var vertices = [];
			var uvs = [];

			var i, j, p;
			var u, v;

			var sliceCount = slices + 1;

			for ( i = 0; i <= stacks; i ++ ) {

				v = i / stacks;

				for ( j = 0; j <= slices; j ++ ) {

					u = j / slices;

					p = func( u, v );
					vertices.push( p.x, p.y, p.z );

					uvs.push( u, v );

				}

			}

			// generate indices

			var indices = [];
			var a, b, c, d;

			for ( i = 0; i < stacks; i ++ ) {

				for ( j = 0; j < slices; j ++ ) {

					a = i * sliceCount + j;
					b = i * sliceCount + j + 1;
					c = ( i + 1 ) * sliceCount + j + 1;
					d = ( i + 1 ) * sliceCount + j;

					// faces one and two

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( new ( indices.length > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 ) );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// generate normals

			this.computeVertexNormals();

		}

		ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

		/**
		 * @author zz85 / https://github.com/zz85
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */

		function ParametricGeometry( func, slices, stacks ) {

			Geometry.call( this );

			this.type = 'ParametricGeometry';

			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};

			this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
			this.mergeVertices();

		}

		ParametricGeometry.prototype = Object.create( Geometry.prototype );
		ParametricGeometry.prototype.constructor = ParametricGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

			BufferGeometry.call( this );

			this.type = 'PolyhedronBufferGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			radius = radius || 1;
			detail = detail || 0;

			// default buffer data

			var vertexBuffer = [];
			var uvBuffer = [];

			// the subdivision creates the vertex buffer data

			subdivide( detail );

			// all vertices should lie on a conceptual sphere with a given radius

			appplyRadius( radius );

			// finally, create the uv data

			generateUVs();

			// build non-indexed geometry

			this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
			this.normalizeNormals();

			this.boundingSphere = new Sphere( new Vector3(), radius );

			// helper functions

			function subdivide( detail ) {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				// iterate over all faces and apply a subdivison with the given detail value

				for ( var i = 0; i < indices.length; i += 3 ) {

					// get the vertices of the face

					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );

					// perform subdivision

					subdivideFace( a, b, c, detail );

				}

			}

			function subdivideFace( a, b, c, detail ) {

				var cols = Math.pow( 2, detail );

				// we use this multidimensional array as a data structure for creating the subdivision

				var v = [];

				var i, j;

				// construct all of the vertices for this subdivision

				for ( i = 0 ; i <= cols; i ++ ) {

					v[ i ] = [];

					var aj = a.clone().lerp( c, i / cols );
					var bj = b.clone().lerp( c, i / cols );

					var rows = cols - i;

					for ( j = 0; j <= rows; j ++ ) {

						if ( j === 0 && i === cols ) {

							v[ i ][ j ] = aj;

						} else {

							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

						}

					}

				}

				// construct all of the faces

				for ( i = 0; i < cols ; i ++ ) {

					for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

						var k = Math.floor( j / 2 );

						if ( j % 2 === 0 ) {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );

						} else {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );

						}

					}

				}

			}

			function appplyRadius( radius ) {

				var vertex = new Vector3();

				// iterate over the entire buffer and apply the radius to each vertex

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					vertex.normalize().multiplyScalar( radius );

					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;

				}

			}

			function generateUVs() {

				var vertex = new Vector3();

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					var v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );

				}

				correctUVs();

				correctSeam();

			}

			function correctSeam() {

				// handle case when face straddles the seam, see #3269

				for ( var i = 0; i < uvBuffer.length; i += 6 ) {

					// uv data of a single face

					var x0 = uvBuffer[ i + 0 ];
					var x1 = uvBuffer[ i + 2 ];
					var x2 = uvBuffer[ i + 4 ];

					var max = Math.max( x0, x1, x2 );
					var min = Math.min( x0, x1, x2 );

					// 0.9 is somewhat arbitrary

					if ( max > 0.9 && min < 0.1 ) {

						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

					}

				}

			}

			function pushVertex( vertex ) {

				vertexBuffer.push( vertex.x, vertex.y, vertex.z );

			}

			function getVertexByIndex( index, vertex ) {

				var stride = index * 3;

				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];

			}

			function correctUVs() {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				var centroid = new Vector3();

				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

					var azi = azimuth( centroid );

					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );

				}

			}

			function correctUV( uv, stride, vector, azimuth  ) {

				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

					uvBuffer[ stride ] =  uv.x - 1;

				}

				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

				}

			}

			// Angle around the Y axis, counter-clockwise when looking from above.

			function azimuth( vector ) {

				return Math.atan2( vector.z, - vector.x );

			}


			// Angle above the XZ plane.

			function inclination( vector ) {

				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

			}

		}

		PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function TetrahedronBufferGeometry( radius, detail ) {

			var vertices = [
				1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
			];

			var indices = [
				2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'TetrahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */

		function TetrahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'TetrahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
		TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function OctahedronBufferGeometry( radius,detail ) {

			var vertices = [
				1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
			];

			var indices = [
				0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'OctahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */

		function OctahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'OctahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		OctahedronGeometry.prototype = Object.create( Geometry.prototype );
		OctahedronGeometry.prototype.constructor = OctahedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function IcosahedronBufferGeometry( radius, detail ) {

			var t = ( 1 + Math.sqrt( 5 ) ) / 2;

			var vertices = [
				- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
				 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
				 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
			];

			var indices = [
				 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
				 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
				 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
				 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'IcosahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */

		function IcosahedronGeometry( radius, detail ) {

		 	Geometry.call( this );

			this.type = 'IcosahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
		IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function DodecahedronBufferGeometry( radius, detail ) {

			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
			var r = 1 / t;

			var vertices = [

				// (±1, ±1, ±1)
				- 1, - 1, - 1,    - 1, - 1,  1,
				- 1,  1, - 1,    - 1,  1,  1,
				 1, - 1, - 1,     1, - 1,  1,
				 1,  1, - 1,     1,  1,  1,

				// (0, ±1/φ, ±φ)
				 0, - r, - t,     0, - r,  t,
				 0,  r, - t,     0,  r,  t,

				// (±1/φ, ±φ, 0)
				- r, - t,  0,    - r,  t,  0,
				 r, - t,  0,     r,  t,  0,

				// (±φ, 0, ±1/φ)
				- t,  0, - r,     t,  0, - r,
				- t,  0,  r,     t,  0,  r
			];

			var indices = [
				 3, 11,  7,      3,  7, 15,      3, 15, 13,
				 7, 19, 17,      7, 17,  6,      7,  6, 15,
				17,  4,  8,     17,  8, 10,     17, 10,  6,
				 8,  0, 16,      8, 16,  2,      8,  2, 10,
				 0, 12,  1,      0,  1, 18,      0, 18, 16,
				 6, 10,  2,      6,  2, 13,      6, 13, 15,
				 2, 16, 18,      2, 18,  3,      2,  3, 13,
				18,  1,  9,     18,  9, 11,     18, 11,  3,
				 4, 14, 12,      4, 12,  0,      4,  0,  8,
				11,  9,  5,     11,  5, 19,     11, 19,  7,
				19,  5, 14,     19, 14,  4,     19,  4, 17,
				 1, 12, 14,      1, 14,  5,      1,  5,  9
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'DodecahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

		/**
		 * @author Abe Pazos / https://hamoid.com
		 */

		function DodecahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'DodecahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
		DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

		/**
		 * @author clockworkgeek / https://github.com/clockworkgeek
		 * @author timothypratley / https://github.com/timothypratley
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function PolyhedronGeometry( vertices, indices, radius, detail ) {

			Geometry.call( this );

			this.type = 'PolyhedronGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
			this.mergeVertices();

		}

		PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
		PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 *
		 */

		function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

			BufferGeometry.call( this );

			this.type = 'TubeBufferGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			tubularSegments = tubularSegments || 64;
			radius = radius || 1;
			radialSegments = radialSegments || 8;
			closed = closed || false;

			var frames = path.computeFrenetFrames( tubularSegments, closed );

			// expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;

			// helper variables

			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();

			var i, j;

			// buffer

			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];

			// create buffer data

			generateBufferData();

			// build geometry

			this.setIndex( new ( indices.length > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 ) );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// functions

			function generateBufferData() {

				for ( i = 0; i < tubularSegments; i ++ ) {

					generateSegment( i );

				}

				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

				generateSegment( ( closed === false ) ? tubularSegments : 0 );

				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs();

				// finally create faces

				generateIndices();

			}

			function generateSegment( i ) {

				// we use getPointAt to sample evenly distributed points from the given path

				var P = path.getPointAt( i / tubularSegments );

				// retrieve corresponding normal and binormal

				var N = frames.normals[ i ];
				var B = frames.binormals[ i ];

				// generate normals and vertices for the current segment

				for ( j = 0; j <= radialSegments; j ++ ) {

					var v = j / radialSegments * Math.PI * 2;

					var sin =   Math.sin( v );
					var cos = - Math.cos( v );

					// normal

					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();

					normals.push( normal.x, normal.y, normal.z );

					// vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;

					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

			function generateIndices() {

				for ( j = 1; j <= tubularSegments; j ++ ) {

					for ( i = 1; i <= radialSegments; i ++ ) {

						var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						var b = ( radialSegments + 1 ) * j + ( i - 1 );
						var c = ( radialSegments + 1 ) * j + i;
						var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

					}

				}

			}

			function generateUVs() {

				for ( i = 0; i <= tubularSegments; i ++ ) {

					for ( j = 0; j <= radialSegments; j ++ ) {

						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;

						uvs.push( uv.x, uv.y );

					}

				}

			}

		}

		TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

		/**
		 * @author oosmoxiecode / https://github.com/oosmoxiecode
		 * @author WestLangley / https://github.com/WestLangley
		 * @author zz85 / https://github.com/zz85
		 * @author miningold / https://github.com/miningold
		 * @author jonobr1 / https://github.com/jonobr1
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 */

		function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

			Geometry.call( this );

			this.type = 'TubeGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

			var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

			// expose internals

			this.tangents = bufferGeometry.tangents;
			this.normals = bufferGeometry.normals;
			this.binormals = bufferGeometry.binormals;

			// create geometry

			this.fromBufferGeometry( bufferGeometry );
			this.mergeVertices();

		}

		TubeGeometry.prototype = Object.create( Geometry.prototype );
		TubeGeometry.prototype.constructor = TubeGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * see: http://www.blackpawn.com/texts/pqtorus/
		 */
		function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

			BufferGeometry.call( this );

			this.type = 'TorusKnotBufferGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			radius = radius || 100;
			tube = tube || 40;
			tubularSegments = Math.floor( tubularSegments ) || 64;
			radialSegments = Math.floor( radialSegments ) || 8;
			p = p || 2;
			q = q || 3;

			// used to calculate buffer length
			var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
			var indexCount = radialSegments * tubularSegments * 2 * 3;

			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// helper variables
			var i, j, index = 0, indexOffset = 0;

			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();

			var P1 = new Vector3();
			var P2 = new Vector3();

			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3();

			// generate vertices, normals and uvs

			for ( i = 0; i <= tubularSegments; ++ i ) {

				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

				var u = i / tubularSegments * p * Math.PI * 2;

				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

				// calculate orthonormal basis

				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );

				// normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for ( j = 0; j <= radialSegments; ++ j ) {

					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

					var v = j / radialSegments * Math.PI * 2;
					var cx = - tube * Math.cos( v );
					var cy = tube * Math.sin( v );

					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );

					// vertex
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
					normal.subVectors( vertex, P1 ).normalize();
					normals.setXYZ( index, normal.x, normal.y, normal.z );

					// uv
					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

			}

			// generate indices

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					// indices
					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

					// face two
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

			// this function calculates the current position on the torus curve

			function calculatePositionOnCurve( u, p, q, radius, position ) {

				var cu = Math.cos( u );
				var su = Math.sin( u );
				var quOverP = q / p * u;
				var cs = Math.cos( quOverP );

				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;

			}

		}

		TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

		/**
		 * @author oosmoxiecode
		 */

		function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

			Geometry.call( this );

			this.type = 'TorusKnotGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

			this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
			this.mergeVertices();

		}

		TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
		TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

			BufferGeometry.call( this );

			this.type = 'TorusBufferGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			radius = radius || 100;
			tube = tube || 40;
			radialSegments = Math.floor( radialSegments ) || 8;
			tubularSegments = Math.floor( tubularSegments ) || 6;
			arc = arc || Math.PI * 2;

			// used to calculate buffer length
			var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
			var indexCount = radialSegments * tubularSegments * 2 * 3;

			// buffers
			var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
			var vertices = new Float32Array( vertexCount * 3 );
			var normals = new Float32Array( vertexCount * 3 );
			var uvs = new Float32Array( vertexCount * 2 );

			// offset variables
			var vertexBufferOffset = 0;
			var uvBufferOffset = 0;
			var indexBufferOffset = 0;

			// helper variables
			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3();

			var j, i;

			// generate vertices, normals and uvs

			for ( j = 0; j <= radialSegments; j ++ ) {

				for ( i = 0; i <= tubularSegments; i ++ ) {

					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2;

					// vertex
					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );

					vertices[ vertexBufferOffset ] = vertex.x;
					vertices[ vertexBufferOffset + 1 ] = vertex.y;
					vertices[ vertexBufferOffset + 2 ] = vertex.z;

					// this vector is used to calculate the normal
					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );

					// normal
					normal.subVectors( vertex, center ).normalize();

					normals[ vertexBufferOffset ] = normal.x;
					normals[ vertexBufferOffset + 1 ] = normal.y;
					normals[ vertexBufferOffset + 2 ] = normal.z;

					// uv
					uvs[ uvBufferOffset ] = i / tubularSegments;
					uvs[ uvBufferOffset + 1 ] = j / radialSegments;

					// update offsets
					vertexBufferOffset += 3;
					uvBufferOffset += 2;

				}

			}

			// generate indices

			for ( j = 1; j <= radialSegments; j ++ ) {

				for ( i = 1; i <= tubularSegments; i ++ ) {

					// indices
					var a = ( tubularSegments + 1 ) * j + i - 1;
					var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					var d = ( tubularSegments + 1 ) * j + i;

					// face one
					indices[ indexBufferOffset ] = a;
					indices[ indexBufferOffset + 1 ] = b;
					indices[ indexBufferOffset + 2 ] = d;

					// face two
					indices[ indexBufferOffset + 3 ] = b;
					indices[ indexBufferOffset + 4 ] = c;
					indices[ indexBufferOffset + 5 ] = d;

					// update offset
					indexBufferOffset += 6;

				}

			}

			// build geometry
			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

		}

		TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

		/**
		 * @author oosmoxiecode
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
		 */

		function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

			Geometry.call( this );

			this.type = 'TorusGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

		}

		TorusGeometry.prototype = Object.create( Geometry.prototype );
		TorusGeometry.prototype.constructor = TorusGeometry;

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		var ShapeUtils = {

			// calculate area of the contour polygon

			area: function ( contour ) {

				var n = contour.length;
				var a = 0.0;

				for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

					a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

				}

				return a * 0.5;

			},

			triangulate: ( function () {

				/**
				 * This code is a quick port of code written in C++ which was submitted to
				 * flipcode.com by John W. Ratcliff  // July 22, 2000
				 * See original code and more information here:
				 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
				 *
				 * ported to actionscript by Zevan Rosser
				 * www.actionsnippet.com
				 *
				 * ported to javascript by Joshua Koo
				 * http://www.lab4games.net/zz85/blog
				 *
				 */

				function snip( contour, u, v, w, n, verts ) {

					var p;
					var ax, ay, bx, by;
					var cx, cy, px, py;

					ax = contour[ verts[ u ] ].x;
					ay = contour[ verts[ u ] ].y;

					bx = contour[ verts[ v ] ].x;
					by = contour[ verts[ v ] ].y;

					cx = contour[ verts[ w ] ].x;
					cy = contour[ verts[ w ] ].y;

					if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;

					var aX, aY, bX, bY, cX, cY;
					var apx, apy, bpx, bpy, cpx, cpy;
					var cCROSSap, bCROSScp, aCROSSbp;

					aX = cx - bx;  aY = cy - by;
					bX = ax - cx;  bY = ay - cy;
					cX = bx - ax;  cY = by - ay;

					for ( p = 0; p < n; p ++ ) {

						px = contour[ verts[ p ] ].x;
						py = contour[ verts[ p ] ].y;

						if ( ( ( px === ax ) && ( py === ay ) ) ||
							 ( ( px === bx ) && ( py === by ) ) ||
							 ( ( px === cx ) && ( py === cy ) ) )	continue;

						apx = px - ax;  apy = py - ay;
						bpx = px - bx;  bpy = py - by;
						cpx = px - cx;  cpy = py - cy;

						// see if p is inside triangle abc

						aCROSSbp = aX * bpy - aY * bpx;
						cCROSSap = cX * apy - cY * apx;
						bCROSScp = bX * cpy - bY * cpx;

						if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

					}

					return true;

				}

				// takes in an contour array and returns

				return function triangulate( contour, indices ) {

					var n = contour.length;

					if ( n < 3 ) return null;

					var result = [],
						verts = [],
						vertIndices = [];

					/* we want a counter-clockwise polygon in verts */

					var u, v, w;

					if ( ShapeUtils.area( contour ) > 0.0 ) {

						for ( v = 0; v < n; v ++ ) verts[ v ] = v;

					} else {

						for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

					}

					var nv = n;

					/*  remove nv - 2 vertices, creating 1 triangle every time */

					var count = 2 * nv;   /* error detection */

					for ( v = nv - 1; nv > 2; ) {

						/* if we loop, it is probably a non-simple polygon */

						if ( ( count -- ) <= 0 ) {

							//** Triangulate: ERROR - probable bad polygon!

							//throw ( "Warning, unable to triangulate polygon!" );
							//return null;
							// Sometimes warning is fine, especially polygons are triangulated in reverse.
							console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

							if ( indices ) return vertIndices;
							return result;

						}

						/* three consecutive vertices in current polygon, <u,v,w> */

						u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
						v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
						w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

						if ( snip( contour, u, v, w, nv, verts ) ) {

							var a, b, c, s, t;

							/* true names of the vertices */

							a = verts[ u ];
							b = verts[ v ];
							c = verts[ w ];

							/* output Triangle */

							result.push( [ contour[ a ],
								contour[ b ],
								contour[ c ] ] );


							vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

							/* remove v from the remaining polygon */

							for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

								verts[ s ] = verts[ t ];

							}

							nv --;

							/* reset error detection counter */

							count = 2 * nv;

						}

					}

					if ( indices ) return vertIndices;
					return result;

				}

			} )(),

			triangulateShape: function ( contour, holes ) {

				function removeDupEndPts(points) {

					var l = points.length;

					if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

						points.pop();

					}

				}

				removeDupEndPts( contour );
				holes.forEach( removeDupEndPts );

				function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

					// inOtherPt needs to be collinear to the inSegment
					if ( inSegPt1.x !== inSegPt2.x ) {

						if ( inSegPt1.x < inSegPt2.x ) {

							return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

						} else {

							return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

						}

					} else {

						if ( inSegPt1.y < inSegPt2.y ) {

							return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

						} else {

							return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

						}

					}

				}

				function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

					var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
					var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

					var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
					var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

					var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
					var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

					if ( Math.abs( limit ) > Number.EPSILON ) {

						// not parallel

						var perpSeg2;
						if ( limit > 0 ) {

							if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

						} else {

							if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

						}

						// i.e. to reduce rounding errors
						// intersection at endpoint of segment#1?
						if ( perpSeg2 === 0 ) {

							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt1 ];

						}
						if ( perpSeg2 === limit ) {

							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt2 ];

						}
						// intersection at endpoint of segment#2?
						if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
						if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

						// return real intersection point
						var factorSeg1 = perpSeg2 / limit;
						return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
									y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

					} else {

						// parallel or collinear
						if ( ( perpSeg1 !== 0 ) ||
							 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

						// they are collinear or degenerate
						var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
						var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
						// both segments are points
						if ( seg1Pt && seg2Pt ) {

							if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
								 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
							return [ inSeg1Pt1 ];                 						// they are the same point

						}
						// segment#1  is a single point
						if ( seg1Pt ) {

							if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
							return [ inSeg1Pt1 ];

						}
						// segment#2  is a single point
						if ( seg2Pt ) {

							if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
							return [ inSeg2Pt1 ];

						}

						// they are collinear segments, which might overlap
						var seg1min, seg1max, seg1minVal, seg1maxVal;
						var seg2min, seg2max, seg2minVal, seg2maxVal;
						if ( seg1dx !== 0 ) {

							// the segments are NOT on a vertical line
							if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

							} else {

								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

							}
							if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

							} else {

								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

							}

						} else {

							// the segments are on a vertical line
							if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

							} else {

								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

							}
							if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

							} else {

								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

							}

						}
						if ( seg1minVal <= seg2minVal ) {

							if ( seg1maxVal <  seg2minVal )	return [];
							if ( seg1maxVal === seg2minVal )	{

								if ( inExcludeAdjacentSegs )		return [];
								return [ seg2min ];

							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
							return	[ seg2min, seg2max ];

						} else {

							if ( seg1minVal >  seg2maxVal )	return [];
							if ( seg1minVal === seg2maxVal )	{

								if ( inExcludeAdjacentSegs )		return [];
								return [ seg1min ];

							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
							return	[ seg1min, seg2max ];

						}

					}

				}

				function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

					// The order of legs is important

					// translation of all points, so that Vertex is at (0,0)
					var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
					var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
					var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

					// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
					var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
					var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

					if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

						// angle != 180 deg.

						var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
						// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

						if ( from2toAngle > 0 ) {

							// main angle < 180 deg.
							return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

						} else {

							// main angle > 180 deg.
							return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

						}

					} else {

						// angle == 180 deg.
						// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
						return	( from2otherAngle > 0 );

					}

				}


				function removeHoles( contour, holes ) {

					var shape = contour.concat(); // work on this shape
					var hole;

					function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

						// Check if hole point lies within angle around shape point
						var lastShapeIdx = shape.length - 1;

						var prevShapeIdx = inShapeIdx - 1;
						if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

						var nextShapeIdx = inShapeIdx + 1;
						if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

						var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
						if ( ! insideAngle ) {

							// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
							return	false;

						}

						// Check if shape point lies within angle around hole point
						var lastHoleIdx = hole.length - 1;

						var prevHoleIdx = inHoleIdx - 1;
						if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

						var nextHoleIdx = inHoleIdx + 1;
						if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

						insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
						if ( ! insideAngle ) {

							// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
							return	false;

						}

						return	true;

					}

					function intersectsShapeEdge( inShapePt, inHolePt ) {

						// checks for intersections with shape edges
						var sIdx, nextIdx, intersection;
						for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

							nextIdx = sIdx + 1; nextIdx %= shape.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;

						}

						return	false;

					}

					var indepHoles = [];

					function intersectsHoleEdge( inShapePt, inHolePt ) {

						// checks for intersections with hole edges
						var ihIdx, chkHole,
							hIdx, nextIdx, intersection;
						for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

							chkHole = holes[ indepHoles[ ihIdx ]];
							for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

								nextIdx = hIdx + 1; nextIdx %= chkHole.length;
								intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
								if ( intersection.length > 0 )		return	true;

							}

						}
						return	false;

					}

					var holeIndex, shapeIndex,
						shapePt, holePt,
						holeIdx, cutKey, failedCuts = [],
						tmpShape1, tmpShape2,
						tmpHole1, tmpHole2;

					for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

						indepHoles.push( h );

					}

					var minShapeIndex = 0;
					var counter = indepHoles.length * 2;
					while ( indepHoles.length > 0 ) {

						counter --;
						if ( counter < 0 ) {

							console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
							break;

						}

						// search for shape-vertex and hole-vertex,
						// which can be connected without intersections
						for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

							shapePt = shape[ shapeIndex ];
							holeIndex	= - 1;

							// search for hole which can be reached without intersections
							for ( var h = 0; h < indepHoles.length; h ++ ) {

								holeIdx = indepHoles[ h ];

								// prevent multiple checks
								cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
								if ( failedCuts[ cutKey ] !== undefined )			continue;

								hole = holes[ holeIdx ];
								for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

									holePt = hole[ h2 ];
									if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
									if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
									if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

									holeIndex = h2;
									indepHoles.splice( h, 1 );

									tmpShape1 = shape.slice( 0, shapeIndex + 1 );
									tmpShape2 = shape.slice( shapeIndex );
									tmpHole1 = hole.slice( holeIndex );
									tmpHole2 = hole.slice( 0, holeIndex + 1 );

									shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

									minShapeIndex = shapeIndex;

									// Debug only, to show the selected cuts
									// glob_CutLines.push( [ shapePt, holePt ] );

									break;

								}
								if ( holeIndex >= 0 )	break;		// hole-vertex found

								failedCuts[ cutKey ] = true;			// remember failure

							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found

						}

					}

					return shape; 			/* shape with no holes */

				}


				var i, il, f, face,
					key, index,
					allPointsMap = {};

				// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

				var allpoints = contour.concat();

				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

					Array.prototype.push.apply( allpoints, holes[ h ] );

				}

				//console.log( "allpoints",allpoints, allpoints.length );

				// prepare all points map

				for ( i = 0, il = allpoints.length; i < il; i ++ ) {

					key = allpoints[ i ].x + ":" + allpoints[ i ].y;

					if ( allPointsMap[ key ] !== undefined ) {

						console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

					}

					allPointsMap[ key ] = i;

				}

				// remove holes by cutting paths to holes and adding them to the shape
				var shapeWithoutHoles = removeHoles( contour, holes );

				var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
				//console.log( "triangles",triangles, triangles.length );

				// check all face vertices against all points map

				for ( i = 0, il = triangles.length; i < il; i ++ ) {

					face = triangles[ i ];

					for ( f = 0; f < 3; f ++ ) {

						key = face[ f ].x + ":" + face[ f ].y;

						index = allPointsMap[ key ];

						if ( index !== undefined ) {

							face[ f ] = index;

						}

					}

				}

				return triangles.concat();

			},

			isClockWise: function ( pts ) {

				return ShapeUtils.area( pts ) < 0;

			}

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Creates extruded geometry from a path shape.
		 *
		 * parameters = {
		 *
		 *  curveSegments: <int>, // number of points on the curves
		 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
		 *  amount: <int>, // Depth to extrude the shape
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into the original shape bevel goes
		 *  bevelSize: <float>, // how far from shape outline is bevel
		 *  bevelSegments: <int>, // number of bevel layers
		 *
		 *  extrudePath: <THREE.Curve> // curve to extrude shape along
		 *  frames: <Object> // containing arrays of tangents, normals, binormals
		 *
		 *  uvGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 **/

		function ExtrudeGeometry( shapes, options ) {

			if ( typeof( shapes ) === "undefined" ) {

				shapes = [];
				return;

			}

			Geometry.call( this );

			this.type = 'ExtrudeGeometry';

			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

			this.addShapeList( shapes, options );

			this.computeFaceNormals();

			// can't really use automatic vertex normals
			// as then front and back sides get smoothed too
			// should do separate smoothing just for sides

			//this.computeVertexNormals();

			//console.log( "took", ( Date.now() - startTime ) );

		}

		ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
		ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

		ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

			var sl = shapes.length;

			for ( var s = 0; s < sl; s ++ ) {

				var shape = shapes[ s ];
				this.addShape( shape, options );

			}

		};

		ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

			var amount = options.amount !== undefined ? options.amount : 100;

			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

			var steps = options.steps !== undefined ? options.steps : 1;

			var extrudePath = options.extrudePath;
			var extrudePts, extrudeByPath = false;

			// Use default WorldUVGenerator if no UV generators are specified.
			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

			var splineTube, binormal, normal, position2;
			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;

			}

			// Variables initialization

			var ahole, h, hl; // looping of holes
			var scope = this;

			var shapesOffset = this.vertices.length;

			var shapePoints = shape.extractPoints( curveSegments );

			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;

			var reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

				reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

			}


			var faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			var contour = vertices; // vertices has all points but contour has only points of circumference

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
							  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return	new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					var direction_eq = false;		// assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y =  v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			var contourMovements = [];

			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				oneHoleMovements = [];

				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y,  - z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y,  - z );

					}

				}

			}

			bs = bevelSize;

			// Back facing vertices

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			var s;

			for ( s = 1; s <= steps; s ++ ) {

				for ( i = 0; i < vlen; i ++ ) {

					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, amount / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos ( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y,  amount + z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y,  amount + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				if ( bevelEnabled ) {

					var layer = 0; // steps + 1
					var offset = vlen * layer;

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}

			}

			function sidewalls( contour, layeroffset ) {

				var j, k;
				i = contour.length;

				while ( -- i >= 0 ) {

					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					var s = 0, sl = steps  + bevelSegments * 2;

					for ( s = 0; s < sl; s ++ ) {

						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );

						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d, contour, s, sl, j, k );

					}

				}

			}


			function v( x, y, z ) {

				scope.vertices.push( new Vector3( x, y, z ) );

			}

			function f3( a, b, c ) {

				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;

				scope.faces.push( new Face3( a, b, c, null, null, 0 ) );

				var uvs = uvgen.generateTopUV( scope, a, b, c );

				scope.faceVertexUvs[ 0 ].push( uvs );

			}

			function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;
				d += shapesOffset;

				scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
				scope.faces.push( new Face3( b, c, d, null, null, 1 ) );

				var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

				scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
				scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

			}

		};

		ExtrudeGeometry.WorldUVGenerator = {

			generateTopUV: function ( geometry, indexA, indexB, indexC ) {

				var vertices = geometry.vertices;

				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];

				return [
					new Vector2( a.x, a.y ),
					new Vector2( b.x, b.y ),
					new Vector2( c.x, c.y )
				];

			},

			generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

				var vertices = geometry.vertices;

				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];
				var d = vertices[ indexD ];

				if ( Math.abs( a.y - b.y ) < 0.01 ) {

					return [
						new Vector2( a.x, 1 - a.z ),
						new Vector2( b.x, 1 - b.z ),
						new Vector2( c.x, 1 - c.z ),
						new Vector2( d.x, 1 - d.z )
					];

				} else {

					return [
						new Vector2( a.y, 1 - a.z ),
						new Vector2( b.y, 1 - b.z ),
						new Vector2( c.y, 1 - c.z ),
						new Vector2( d.y, 1 - d.z )
					];

				}

			}
		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * Text = 3D Text
		 *
		 * parameters = {
		 *  font: <THREE.Font>, // font
		 *
		 *  size: <float>, // size of the text
		 *  height: <float>, // thickness to extrude text
		 *  curveSegments: <int>, // number of points on the curves
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into text bevel goes
		 *  bevelSize: <float> // how far from text outline is bevel
		 * }
		 */

		function TextGeometry( text, parameters ) {

			parameters = parameters || {};

			var font = parameters.font;

			if ( (font && font.isFont) === false ) {

				console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
				return new Geometry();

			}

			var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

			// translate parameters to ExtrudeGeometry API

			parameters.amount = parameters.height !== undefined ? parameters.height : 50;

			// defaults

			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

			ExtrudeGeometry.call( this, shapes, parameters );

			this.type = 'TextGeometry';

		}

		TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
		TextGeometry.prototype.constructor = TextGeometry;

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * based on THREE.SphereGeometry
		 */

		function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'SphereBufferGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			radius = radius || 50;

			widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

			phiStart = phiStart !== undefined ? phiStart : 0;
			phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

			var thetaEnd = thetaStart + thetaLength;

			var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

			var positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			var index = 0, vertices = [], normal = new Vector3();

			for ( var y = 0; y <= heightSegments; y ++ ) {

				var verticesRow = [];

				var v = y / heightSegments;

				for ( var x = 0; x <= widthSegments; x ++ ) {

					var u = x / widthSegments;

					var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					var py = radius * Math.cos( thetaStart + v * thetaLength );
					var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					normal.set( px, py, pz ).normalize();

					positions.setXYZ( index, px, py, pz );
					normals.setXYZ( index, normal.x, normal.y, normal.z );
					uvs.setXY( index, u, 1 - v );

					verticesRow.push( index );

					index ++;

				}

				vertices.push( verticesRow );

			}

			var indices = [];

			for ( var y = 0; y < heightSegments; y ++ ) {

				for ( var x = 0; x < widthSegments; x ++ ) {

					var v1 = vertices[ y ][ x + 1 ];
					var v2 = vertices[ y ][ x ];
					var v3 = vertices[ y + 1 ][ x ];
					var v4 = vertices[ y + 1 ][ x + 1 ];

					if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
					if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

				}

			}

			this.setIndex( new ( positions.count > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 ) );
			this.addAttribute( 'position', positions );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

			this.boundingSphere = new Sphere( new Vector3(), radius );

		}

		SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'SphereGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

		}

		SphereGeometry.prototype = Object.create( Geometry.prototype );
		SphereGeometry.prototype.constructor = SphereGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'RingBufferGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			innerRadius = innerRadius || 20;
			outerRadius = outerRadius || 50;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

			thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
			phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

			// these are used to calculate buffer length
			var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
			var indexCount = thetaSegments * phiSegments * 2 * 3;

			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// some helper variables
			var index = 0, indexOffset = 0, segment;
			var radius = innerRadius;
			var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			var vertex = new Vector3();
			var uv = new Vector2();
			var j, i;

			// generate vertices, normals and uvs

			// values are generate from the inside of the ring to the outside

			for ( j = 0; j <= phiSegments; j ++ ) {

				for ( i = 0; i <= thetaSegments; i ++ ) {

					segment = thetaStart + i / thetaSegments * thetaLength;

					// vertex
					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// normal
					normals.setXYZ( index, 0, 0, 1 );

					// uv
					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index++;

				}

				// increase the radius for next row of vertices
				radius += radiusStep;

			}

			// generate indices

			for ( j = 0; j < phiSegments; j ++ ) {

				var thetaSegmentLevel = j * ( thetaSegments + 1 );

				for ( i = 0; i < thetaSegments; i ++ ) {

					segment = i + thetaSegmentLevel;

					// indices
					var a = segment;
					var b = segment + thetaSegments + 1;
					var c = segment + thetaSegments + 2;
					var d = segment + 1;

					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;

					// face two
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

		}

		RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		RingBufferGeometry.prototype.constructor = RingBufferGeometry;

		/**
		 * @author Kaleb Murphy
		 */

		function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'RingGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

		}

		RingGeometry.prototype = Object.create( Geometry.prototype );
		RingGeometry.prototype.constructor = RingGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */

		function PlaneGeometry( width, height, widthSegments, heightSegments ) {

			Geometry.call( this );

			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

		}

		PlaneGeometry.prototype = Object.create( Geometry.prototype );
		PlaneGeometry.prototype.constructor = PlaneGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		 // points - to create a closed torus, one must use a set of points
		 //    like so: [ a, b, c, d, a ], see first is the same as last.
		 // segments - the number of circumference segments to create
		 // phiStart - the starting radian
		 // phiLength - the radian (0 to 2PI) range of the lathed section
		 //    2PI is a closed lathe, less than 2PI is a portion.

		function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

			BufferGeometry.call( this );

			this.type = 'LatheBufferGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			segments = Math.floor( segments ) || 12;
			phiStart = phiStart || 0;
			phiLength = phiLength || Math.PI * 2;

			// clamp phiLength so it's in range of [ 0, 2PI ]
			phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );

			// these are used to calculate buffer length
			var vertexCount = ( segments + 1 ) * points.length;
			var indexCount = segments * points.length * 2 * 3;

			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// helper variables
			var index = 0, indexOffset = 0, base;
			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2();
			var i, j;

			// generate vertices and uvs

			for ( i = 0; i <= segments; i ++ ) {

				var phi = phiStart + i * inverseSegments * phiLength;

				var sin = Math.sin( phi );
				var cos = Math.cos( phi );

				for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

					// vertex
					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// uv
					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

			}

			// generate indices

			for ( i = 0; i < segments; i ++ ) {

				for ( j = 0; j < ( points.length - 1 ); j ++ ) {

					base = j + i * points.length;

					// indices
					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1;

					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

					// face two
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'uv', uvs );

			// generate normals

			this.computeVertexNormals();

			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if( phiLength === Math.PI * 2 ) {

				var normals = this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3();

				// this is the buffer offset for the last line of vertices
				base = segments * points.length * 3;

				for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

					// select the normal of the vertex in the first line
					n1.x = normals[ j + 0 ];
					n1.y = normals[ j + 1 ];
					n1.z = normals[ j + 2 ];

					// select the normal of the vertex in the last line
					n2.x = normals[ base + j + 0 ];
					n2.y = normals[ base + j + 1 ];
					n2.z = normals[ base + j + 2 ];

					// average normals
					n.addVectors( n1, n2 ).normalize();

					// assign the new values to both normals
					normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
					normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
					normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

				} // next row

			}

		}

		LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

		/**
		 * @author astrodud / http://astrodud.isgreat.org/
		 * @author zz85 / https://github.com/zz85
		 * @author bhouston / http://clara.io
		 */

		// points - to create a closed torus, one must use a set of points
		//    like so: [ a, b, c, d, a ], see first is the same as last.
		// segments - the number of circumference segments to create
		// phiStart - the starting radian
		// phiLength - the radian (0 to 2PI) range of the lathed section
		//    2PI is a closed lathe, less than 2PI is a portion.

		function LatheGeometry( points, segments, phiStart, phiLength ) {

			Geometry.call( this );

			this.type = 'LatheGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
			this.mergeVertices();

		}

		LatheGeometry.prototype = Object.create( Geometry.prototype );
		LatheGeometry.prototype.constructor = LatheGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Creates a one-sided polygonal geometry from one or more shapes.
		 *
		 **/

		function ShapeBufferGeometry( shapes, curveSegments ) {

			BufferGeometry.call( this );

			this.type = 'ShapeBufferGeometry';

			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};

			curveSegments = curveSegments || 12;

			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];

			var groupStart = 0;
			var groupCount = 0;

			// allow single and array values for "shapes" parameter

			if ( Array.isArray( shapes ) === false ) {

				addShape( shapes );

			} else {

				for ( var i = 0; i < shapes.length; i++ ) {

					addShape( shapes[ i ] );

					this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

					groupStart += groupCount;
					groupCount = 0;

				}

			}

			// build geometry

			this.setIndex( new ( indices.length > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 ) );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


			// helper functions

			function addShape( shape ) {

				var i, l, shapeHole;

				var indexOffset = vertices.length / 3;
				var points = shape.extractPoints( curveSegments );

				var shapeVertices = points.shape;
				var shapeHoles = points.holes;

				// check direction of vertices

				if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

					shapeVertices = shapeVertices.reverse();

					// also check if holes are in the opposite direction

					for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

						shapeHole = shapeHoles[ i ];

						if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

							shapeHoles[ i ] = shapeHole.reverse();

						}

					}

				}

				var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

				// join vertices of inner and outer paths to a single array

				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

					shapeHole = shapeHoles[ i ];
					shapeVertices = shapeVertices.concat( shapeHole );

				}

				// vertices, normals, uvs

				for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

					var vertex = shapeVertices[ i ];

					vertices.push( vertex.x, vertex.y, 0 );
					normals.push( 0, 0, 1 );
					uvs.push( vertex.x, vertex.y ); // world uvs

				}

				// incides

				for ( i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					var a = face[ 0 ] + indexOffset;
					var b = face[ 1 ] + indexOffset;
					var c = face[ 2 ] + indexOffset;

					indices.push( a, b, c );
					groupCount += 3;

				}

			}

		}

		ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

		/**
		 * @author jonobr1 / http://jonobr1.com
		 *
		 * Creates a one-sided polygonal geometry from a path shape.
		 *
		 **/

		function ShapeGeometry( shapes, curveSegments ) {

			Geometry.call( this );

			this.type = 'ShapeGeometry';

			if ( typeof curveSegments === 'object' ) {

				console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

				curveSegments = curveSegments.curveSegments;

			}

			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};

			this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
			this.mergeVertices();

		}

		ShapeGeometry.prototype = Object.create( Geometry.prototype );
		ShapeGeometry.prototype.constructor = ShapeGeometry;

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function EdgesGeometry( geometry, thresholdAngle ) {

			BufferGeometry.call( this );

			thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

			var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );

			var edge = [ 0, 0 ], hash = {};

			function sortFunction( a, b ) {

				return a - b;

			}

			var keys = [ 'a', 'b', 'c' ];

			var geometry2;

			if ( geometry.isBufferGeometry ) {

				geometry2 = new Geometry();
				geometry2.fromBufferGeometry( geometry );

			} else {

				geometry2 = geometry.clone();

			}

			geometry2.mergeVertices();
			geometry2.computeFaceNormals();

			var vertices = geometry2.vertices;
			var faces = geometry2.faces;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

					} else {

						hash[ key ].face2 = i;

					}

				}

			}

			var coords = [];

			for ( var key in hash ) {

				var h = hash[ key ];

				// An edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

				if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

					var vertex = vertices[ h.vert1 ];
					coords.push( vertex.x );
					coords.push( vertex.y );
					coords.push( vertex.z );

					vertex = vertices[ h.vert2 ];
					coords.push( vertex.x );
					coords.push( vertex.y );
					coords.push( vertex.z );

				}

			}

			this.addAttribute( 'position', new Float32BufferAttribute( coords, 3 ) );

		}

		EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
		EdgesGeometry.prototype.constructor = EdgesGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'CylinderBufferGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			var scope = this;

			radiusTop = radiusTop !== undefined ? radiusTop : 20;
			radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
			height = height !== undefined ? height : 100;

			radialSegments = Math.floor( radialSegments ) || 8;
			heightSegments = Math.floor( heightSegments ) || 1;

			openEnded = openEnded !== undefined ? openEnded : false;
			thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
			thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

			// used to calculate buffer length

			var nbCap = 0;

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) nbCap ++;
				if ( radiusBottom > 0 ) nbCap ++;

			}

			var vertexCount = calculateVertexCount();
			var indexCount = calculateIndexCount();

			// buffers

			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// helper variables

			var index = 0,
			    indexOffset = 0,
			    indexArray = [],
			    halfHeight = height / 2;

			// group variables
			var groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

			// helper functions

			function calculateVertexCount() {

				var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

				if ( openEnded === false ) {

					count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );

				}

				return count;

			}

			function calculateIndexCount() {

				var count = radialSegments * heightSegments * 2 * 3;

				if ( openEnded === false ) {

					count += radialSegments * nbCap * 3;

				}

				return count;

			}

			function generateTorso() {

				var x, y;
				var normal = new Vector3();
				var vertex = new Vector3();

				var groupCount = 0;

				// this will be used to calculate the normal
				var slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( y = 0; y <= heightSegments; y ++ ) {

					var indexRow = [];

					var v = y / heightSegments;

					// calculate the radius of the current row
					var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( x = 0; x <= radialSegments; x ++ ) {

						var u = x / radialSegments;

						var theta = u * thetaLength + thetaStart;

						var sinTheta = Math.sin( theta );
						var cosTheta = Math.cos( theta );

						// vertex
						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

						// normal
						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.setXYZ( index, normal.x, normal.y, normal.z );

						// uv
						uvs.setXY( index, u, 1 - v );

						// save index of vertex in respective row
						indexRow.push( index );

						// increase index
						index ++;

					}

					// now save vertices of the row in our index array
					indexArray.push( indexRow );

				}

				// generate indices

				for ( x = 0; x < radialSegments; x ++ ) {

					for ( y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices
						var i1 = indexArray[ y ][ x ];
						var i2 = indexArray[ y + 1 ][ x ];
						var i3 = indexArray[ y + 1 ][ x + 1 ];
						var i4 = indexArray[ y ][ x + 1 ];

						// face one
						indices.setX( indexOffset, i1 ); indexOffset ++;
						indices.setX( indexOffset, i2 ); indexOffset ++;
						indices.setX( indexOffset, i4 ); indexOffset ++;

						// face two
						indices.setX( indexOffset, i2 ); indexOffset ++;
						indices.setX( indexOffset, i3 ); indexOffset ++;
						indices.setX( indexOffset, i4 ); indexOffset ++;

						// update counters
						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups
				groupStart += groupCount;

			}

			function generateCap( top ) {

				var x, centerIndexStart, centerIndexEnd;

				var uv = new Vector2();
				var vertex = new Vector3();

				var groupCount = 0;

				var radius = ( top === true ) ? radiusTop : radiusBottom;
				var sign = ( top === true ) ? 1 : - 1;

				// save the index of the first center vertex
				centerIndexStart = index;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( x = 1; x <= radialSegments; x ++ ) {

					// vertex
					vertices.setXYZ( index, 0, halfHeight * sign, 0 );

					// normal
					normals.setXYZ( index, 0, sign, 0 );

					// uv
					uv.x = 0.5;
					uv.y = 0.5;

					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

				// save the index of the last center vertex
				centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;
					var theta = u * thetaLength + thetaStart;

					var cosTheta = Math.cos( theta );
					var sinTheta = Math.sin( theta );

					// vertex
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// normal
					normals.setXYZ( index, 0, sign, 0 );

					// uv
					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

				// generate indices

				for ( x = 0; x < radialSegments; x ++ ) {

					var c = centerIndexStart + x;
					var i = centerIndexEnd + x;

					if ( top === true ) {

						// face top
						indices.setX( indexOffset, i ); indexOffset ++;
						indices.setX( indexOffset, i + 1 ); indexOffset ++;
						indices.setX( indexOffset, c ); indexOffset ++;

					} else {

						// face bottom
						indices.setX( indexOffset, i + 1 ); indexOffset ++;
						indices.setX( indexOffset, i ); indexOffset ++;
						indices.setX( indexOffset, c ); indexOffset ++;

					}

					// update counters
					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups
				groupStart += groupCount;

			}

		}

		CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'CylinderGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
			this.mergeVertices();

		}

		CylinderGeometry.prototype = Object.create( Geometry.prototype );
		CylinderGeometry.prototype.constructor = CylinderGeometry;

		/**
		 * @author abelnation / http://github.com/abelnation
		 */

		function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
		ConeGeometry.prototype.constructor = ConeGeometry;

		/**
		 * @author: abelnation / http://github.com/abelnation
		 */

		function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeBufferGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
		ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'CircleBufferGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			radius = radius || 50;
			segments = segments !== undefined ? Math.max( 3, segments ) : 8;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

			var vertices = segments + 2;

			var positions = new Float32Array( vertices * 3 );
			var normals = new Float32Array( vertices * 3 );
			var uvs = new Float32Array( vertices * 2 );

			// center data is already zero, but need to set a few extras
			normals[ 2 ] = 1.0;
			uvs[ 0 ] = 0.5;
			uvs[ 1 ] = 0.5;

			for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

				var segment = thetaStart + s / segments * thetaLength;

				positions[ i ] = radius * Math.cos( segment );
				positions[ i + 1 ] = radius * Math.sin( segment );

				normals[ i + 2 ] = 1; // normal z

				uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
				uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

			}

			var indices = [];

			for ( var i = 1; i <= segments; i ++ ) {

				indices.push( i, i + 1, 0 );

			}

			this.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

			this.boundingSphere = new Sphere( new Vector3(), radius );

		}

		CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

		/**
		 * @author hughes
		 */

		function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'CircleGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

		}

		CircleGeometry.prototype = Object.create( Geometry.prototype );
		CircleGeometry.prototype.constructor = CircleGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
		 */

		function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

			Geometry.call( this );

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
			this.mergeVertices();

		}

		BoxGeometry.prototype = Object.create( Geometry.prototype );
		BoxGeometry.prototype.constructor = BoxGeometry;



		var Geometries = Object.freeze({
			WireframeGeometry: WireframeGeometry,
			ParametricGeometry: ParametricGeometry,
			ParametricBufferGeometry: ParametricBufferGeometry,
			TetrahedronGeometry: TetrahedronGeometry,
			TetrahedronBufferGeometry: TetrahedronBufferGeometry,
			OctahedronGeometry: OctahedronGeometry,
			OctahedronBufferGeometry: OctahedronBufferGeometry,
			IcosahedronGeometry: IcosahedronGeometry,
			IcosahedronBufferGeometry: IcosahedronBufferGeometry,
			DodecahedronGeometry: DodecahedronGeometry,
			DodecahedronBufferGeometry: DodecahedronBufferGeometry,
			PolyhedronGeometry: PolyhedronGeometry,
			PolyhedronBufferGeometry: PolyhedronBufferGeometry,
			TubeGeometry: TubeGeometry,
			TubeBufferGeometry: TubeBufferGeometry,
			TorusKnotGeometry: TorusKnotGeometry,
			TorusKnotBufferGeometry: TorusKnotBufferGeometry,
			TorusGeometry: TorusGeometry,
			TorusBufferGeometry: TorusBufferGeometry,
			TextGeometry: TextGeometry,
			SphereBufferGeometry: SphereBufferGeometry,
			SphereGeometry: SphereGeometry,
			RingGeometry: RingGeometry,
			RingBufferGeometry: RingBufferGeometry,
			PlaneBufferGeometry: PlaneBufferGeometry,
			PlaneGeometry: PlaneGeometry,
			LatheGeometry: LatheGeometry,
			LatheBufferGeometry: LatheBufferGeometry,
			ShapeGeometry: ShapeGeometry,
			ShapeBufferGeometry: ShapeBufferGeometry,
			ExtrudeGeometry: ExtrudeGeometry,
			EdgesGeometry: EdgesGeometry,
			ConeGeometry: ConeGeometry,
			ConeBufferGeometry: ConeBufferGeometry,
			CylinderGeometry: CylinderGeometry,
			CylinderBufferGeometry: CylinderBufferGeometry,
			CircleBufferGeometry: CircleBufferGeometry,
			CircleGeometry: CircleGeometry,
			BoxBufferGeometry: BoxBufferGeometry,
			BoxGeometry: BoxGeometry
		});

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ShadowMaterial() {

			ShaderMaterial.call( this, {
				uniforms: UniformsUtils.merge( [
					UniformsLib.lights,
					{
						opacity: { value: 1.0 }
					}
				] ),
				vertexShader: ShaderChunk[ 'shadow_vert' ],
				fragmentShader: ShaderChunk[ 'shadow_frag' ]
			} );

			this.lights = true;
			this.transparent = true;

			Object.defineProperties( this, {
				opacity: {
					enumerable: true,
					get: function () {
						return this.uniforms.opacity.value;
					},
					set: function ( value ) {
						this.uniforms.opacity.value = value;
					}
				}
			} );

		}

		ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
		ShadowMaterial.prototype.constructor = ShadowMaterial;

		ShadowMaterial.prototype.isShadowMaterial = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function RawShaderMaterial( parameters ) {

			ShaderMaterial.call( this, parameters );

			this.type = 'RawShaderMaterial';

		}

		RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
		RawShaderMaterial.prototype.constructor = RawShaderMaterial;

		RawShaderMaterial.prototype.isRawShaderMaterial = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function MultiMaterial( materials ) {

			this.uuid = _Math.generateUUID();

			this.type = 'MultiMaterial';

			this.materials = Array.isArray( materials ) ? materials : [];

			this.visible = true;

		}

		MultiMaterial.prototype = {

			constructor: MultiMaterial,

			isMultiMaterial: true,

			toJSON: function ( meta ) {

				var output = {
					metadata: {
						version: 4.2,
						type: 'material',
						generator: 'MaterialExporter'
					},
					uuid: this.uuid,
					type: this.type,
					materials: []
				};

				var materials = this.materials;

				for ( var i = 0, l = materials.length; i < l; i ++ ) {

					var material = materials[ i ].toJSON( meta );
					delete material.metadata;

					output.materials.push( material );

				}

				output.visible = this.visible;

				return output;

			},

			clone: function () {

				var material = new this.constructor();

				for ( var i = 0; i < this.materials.length; i ++ ) {

					material.materials.push( this.materials[ i ].clone() );

				}

				material.visible = this.visible;

				return material;

			}

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author Ben Houston / bhouston / http://clara.io
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  roughness: <float>,
		 *  metalness: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  roughnessMap: new THREE.Texture( <Image> ),
		 *
		 *  metalnessMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  envMapIntensity: <float>
		 *
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshStandardMaterial( parameters ) {

			Material.call( this );

			this.defines = { 'STANDARD': '' };

			this.type = 'MeshStandardMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			//this.map = null;
			this.mapSlot = new MaterialMap( "map", 0, false, false );

			this.reflectivity = 0.5;

			this.roughness = 0.5;
			//this.roughnessMap = null;
			this.roughnessMapSlot = new MaterialMap( "roughnessMap", 0, false, false );

			this.metalness = 0.5;
			//this.metalnessMap = null;
			this.metalnessMapSlot = new MaterialMap( "metalnessMap", 0, false, false );

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			//this.emissiveMap = null;
			this.emissiveMapSlot = new MaterialMap( "emissiveMap", 0, false, false );

			//this.bumpMap = null;
			//this.bumpScale = 1;
			this.bumpMapSlot = new MaterialMap( "bumpMap", 0, false, true );

			//this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
			this.normalMapSlot = new MaterialMap( "normalMap", 0, false, false );

			//this.displacementMap = null;
			//this.displacementScale = 1;
			//this.displacementBias = 0;
			this.displacementMapSlot = new MaterialMap( "displacementMap", 0, false, true );

			//this.lightMap = null;
			//this.lightMapIntensity = 1.0;
			this.lightMapSlot = new MaterialMap( "lightMap", 1, false, true );

			//this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.aoMapSlot = new MaterialMap( "aoMap", 1, false, true );

			//this.alphaMap = null;
			this.alphaMapSlot = new MaterialMap( "alphaMap", 0, false, false );

			this.envMap = null;
			this.envMapIntensity = 1.0;

			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshStandardMaterial.prototype = Object.create( Material.prototype );
		MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

		MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

		var closure$1 = function () {
			var propertyMappings = {
				"map": {
				  get: function() {
						return this.mapSlot.texture;
				  },
					set: function( value ) {
						this.mapSlot.texture = value;
					}
				},
				"lightMap": {
				  get: function() {
						return this.lightMapSlot.texture;
				  },
					set: function( value ) {
						this.lightMapSlot.texture = value;
					}
				},
				"lightMapIntensity": {
				  get: function() {
						return this.lightMapSlot.texelScale;
				  },
					set: function( value ) {
						this.lightMapSlot.texelTransform = true;
						this.lightMapSlot.texelScale = value;
					}
				},
				"aoMap": {
				  get: function() {
						return this.aoMapSlot.texture;
				  },
					set: function( value ) {
						this.aoMapSlot.texture = value;
					}
				},
				"emissiveMap": {
				  get: function() {
						return this.emissiveMapSlot.texture;
				  },
					set: function( value ) {
						this.emissiveMapSlot.texture = value;
					}
				},
				"bumpMap": {
				  get: function() {
						return this.bumpMapSlot.texture;
				  },
					set: function( value ) {
						this.bumpMapSlot.texture = value;
					}
				},
				"bumpScale": {
				  get: function() {
						return this.bumpMapSlot.texelScale;
				  },
					set: function( value ) {
						this.bumpMapSlot.texelTransform = true;
						this.bumpMapSlot.texelScale = value;
					}
				},
				"normalMap": {
				  get: function() {
						return this.normalMapSlot.texture;
				  },
					set: function( value ) {
						this.normalMapSlot.texture = value;
					}
				},
				"displacementMap": {
				  get: function() {
						return this.displacementMapSlot.texture;
				  },
					set: function( value ) {
						this.displacementMapSlot.texture = value;
					}
				},
				"displacementScale": {
				  get: function() {
						return this.displacementMapSlot.texelScale;
				  },
					set: function( value ) {
						this.displacementMapSlot.texelTransform = true;
						this.displacementMapSlot.texelScale = value;
					}
				},
				"displacementBias": {
				  get: function() {
						return this.displacementMapSlot.texelOffset;
				  },
					set: function( value ) {
						this.displacementMapSlot.texelTransform = true;
						this.displacementMapSlot.texelOffset = value;
					}
				},
				"roughnessMap": {
				  get: function() {
						return this.roughnessMapSlot.texture;
				  },
					set: function( value ) {
						this.roughnessMapSlot.texture = value;
					}
				},
				"metalnessMap": {
				  get: function() {
						return this.metalnessMapSlot.texture;
				  },
					set: function( value ) {
						this.metalnessMapSlot.texture = value;
					}
				},
				"alphaMap": {
				  get: function() {
						return this.alphaMapSlot.texture;
				  },
					set: function( value ) {
						this.alphaMapSlot.texture = value;
					}
				}
			};
			for( var propertyName in propertyMappings ) {
				Object.defineProperty( MeshStandardMaterial.prototype, propertyName, propertyMappings[ propertyName ] );
			}
		}();

		MeshStandardMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.defines = { 'STANDARD': '' };

			this.color.copy( source.color );
			this.mapSlot.copy( source.mapSlot );

			this.reflectivity = source.reflectivity;

			this.roughness = source.roughness;
			this.roughnessMapSlot.copy( source.roughnessMapSlot );

			this.metalness = source.metalness;
			this.metalnessMapSlot.copy( source.metalnessMapSlot );

			this.lightMapSlot.copy( source.lightMapSlot );

			this.aoMapIntensity = source.aoMapIntensity;
			this.aoMapSlot.copy( source.aoMapSlot );

			this.emissive.copy( source.emissive );
			this.emissiveIntensity = source.emissiveIntensity;
			this.emissiveMapSlot.copy( source.emissiveMapSlot );

			this.bumpMapSlot.copy( source.bumpMapSlot );

			this.normalScale.copy( source.normalScale );
			this.normalMapSlot.copy( source.normalMapSlot );

			this.displacementMapSlot.copy( source.displacementMapSlot );

			this.alphaMapSlot.copy( source.alphaMapSlot );

			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;

			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  reflectivity: <float>
		 * }
		 */

		function MeshPhysicalMaterial( parameters ) {

			MeshStandardMaterial.call( this );

			this.defines = { 'PHYSICAL': '' };

			this.type = 'MeshPhysicalMaterial';

			this.reflectivity = 0.5; // maps to F0 = 0.04

			this.falloff = false;
			this.falloffColor = new Color( 0xffffff );
			this.falloffMapSlot = new MaterialMap( "falloffMap", 0, false, false );
			this.falloffOpacity = 1.0;
			this.falloffAlphaMapSlot = new MaterialMap( "falloffAlphaMap", 0, false, false );

			this.clearCoat = 0.0;
			this.clearCoatRoughness = 0.0;

			this.setValues( parameters );

		}

		MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
		MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

		MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;


		var closure = function () {
			var propertyMappings = {
				"falloffMap": {
				  get: function() {
						return this.falloffMapSlot.texture;
				  },
					set: function( value ) {
						this.falloffMapSlot.texture = value;
					}
				},
				"falloffAlphaMap": {
				  get: function() {
						return this.falloffAlphaMapSlot.texture;
				  },
					set: function( value ) {
						this.falloffAlphaMapSlot.texture = value;
					}
				}
			};
			for( var propertyName in propertyMappings ) {
				Object.defineProperty( MeshPhysicalMaterial.prototype, propertyName, propertyMappings[ propertyName ] );
			}
		}();

		MeshPhysicalMaterial.prototype.copy = function ( source ) {

			MeshStandardMaterial.prototype.copy.call( this, source );

			this.defines = { 'PHYSICAL': '' };

			this.reflectivity = source.reflectivity;

			this.falloff = source.falloff;
			this.falloffColor.copy( source.falloffColor );
			this.falloffMapSlot.copy( source.falloffMapSlot );
			this.falloffOpacity = source.falloffOpacity;
			this.falloffAlphaMapSlot.copy( source.falloffAlphaMapSlot );

			this.clearCoat = source.clearCoat;
			this.clearCoatRoughness = source.clearCoatRoughness;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshPhongMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshPhongMaterial.prototype = Object.create( Material.prototype );
		MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

		MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

		MeshPhongMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author takahirox / http://github.com/takahirox
		 *
		 * parameters = {
		 *  gradientMap: new THREE.Texture( <Image> )
		 * }
		 */

		function MeshToonMaterial( parameters ) {

			MeshPhongMaterial.call( this );

			this.defines = { 'TOON': '' };

			this.type = 'MeshToonMaterial';

			this.gradientMap = null;

			this.setValues( parameters );

		}

		MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
		MeshToonMaterial.prototype.constructor = MeshToonMaterial;

		MeshToonMaterial.prototype.isMeshToonMaterial = true;

		MeshToonMaterial.prototype.copy = function ( source ) {

			MeshPhongMaterial.prototype.copy.call( this, source );

			this.gradientMap = source.gradientMap;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  opacity: <float>,
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshNormalMaterial( parameters ) {

			Material.call( this, parameters );

			this.type = 'MeshNormalMaterial';

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;
			this.lights = false;

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			// default normal is facing the camera.
			this.clearColor = new Color( 0.5, 0.5, 1.0 );
			this.clearAlpha = 1.0;

			this.setValues( parameters );

		}

		MeshNormalMaterial.prototype = Object.create( Material.prototype );
		MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

		MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

		MeshNormalMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.clearColor = source.clearColor;
			this.clearAlpha = source.clearAlpha;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshLambertMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshLambertMaterial.prototype = Object.create( Material.prototype );
		MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

		MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

		MeshLambertMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author bhouston / https://clara.io
		 *
		 * parameters = {
		 *
		 * }
		 */

		function MeshCubeMaterial ( parameters ) {

			Material.call( this );

			this.type = 'MeshCubeMaterial';

			this.envMap = null;
			this.envMapIntensity = 1.0;

			this.roughness = 0.0;

			this.depthTest = false;
			this.depthWrite = false;
			this.side = BackSide;

			this.lights = false;

			this.setValues( parameters );

		}

		MeshCubeMaterial.prototype = Object.create( Material.prototype );
		MeshCubeMaterial.prototype.constructor = MeshCubeMaterial;

		MeshCubeMaterial.prototype.isMeshCubeMaterial = true;

		MeshCubeMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;

			this.roughness = source.roughness;

			return this;

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *
		 *  scale: <float>,
		 *  dashSize: <float>,
		 *  gapSize: <float>
		 * }
		 */

		function LineDashedMaterial( parameters ) {

			Material.call( this );

			this.type = 'LineDashedMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;

			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;

			this.lights = false;

			this.setValues( parameters );

		}

		LineDashedMaterial.prototype = Object.create( Material.prototype );
		LineDashedMaterial.prototype.constructor = LineDashedMaterial;

		LineDashedMaterial.prototype.isLineDashedMaterial = true;

		LineDashedMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;

			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;

			return this;

		};



		var Materials = Object.freeze({
			ShadowMaterial: ShadowMaterial,
			SpriteMaterial: SpriteMaterial,
			RawShaderMaterial: RawShaderMaterial,
			ShaderMaterial: ShaderMaterial,
			PointsMaterial: PointsMaterial,
			MultiMaterial: MultiMaterial,
			MeshPhysicalMaterial: MeshPhysicalMaterial,
			MeshStandardMaterial: MeshStandardMaterial,
			MeshPhongMaterial: MeshPhongMaterial,
			MeshToonMaterial: MeshToonMaterial,
			MeshNormalMaterial: MeshNormalMaterial,
			MeshLambertMaterial: MeshLambertMaterial,
			MeshDepthMaterial: MeshDepthMaterial,
			MeshBasicMaterial: MeshBasicMaterial,
			MeshCubeMaterial: MeshCubeMaterial,
			LineDashedMaterial: LineDashedMaterial,
			LineBasicMaterial: LineBasicMaterial,
			MaterialMap: MaterialMap,
			Material: Material
		});

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var Cache = {

			enabled: false,

			files: {},

			add: function ( key, file ) {

				if ( this.enabled === false ) return;

				// console.log( 'THREE.Cache', 'Adding key:', key );

				this.files[ key ] = file;

			},

			get: function ( key ) {

				if ( this.enabled === false ) return;

				// console.log( 'THREE.Cache', 'Checking key:', key );

				return this.files[ key ];

			},

			remove: function ( key ) {

				delete this.files[ key ];

			},

			clear: function () {

				this.files = {};

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LoadingManager( onLoad, onProgress, onError ) {

			var scope = this;

			var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function ( url ) {

				itemsTotal ++;

				if ( isLoading === false ) {

					if ( scope.onStart !== undefined ) {

						scope.onStart( url, itemsLoaded, itemsTotal );

					}

				}

				isLoading = true;

			};

			this.itemEnd = function ( url ) {

				itemsLoaded ++;

				if ( scope.onProgress !== undefined ) {

					scope.onProgress( url, itemsLoaded, itemsTotal );

				}

				if ( itemsLoaded === itemsTotal ) {

					isLoading = false;

					if ( scope.onLoad !== undefined ) {

						scope.onLoad();

					}

				}

			};

			this.itemError = function ( url ) {

				if ( scope.onError !== undefined ) {

					scope.onError( url );

				}

			};

		}

		var DefaultLoadingManager = new LoadingManager();

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function FileLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( FileLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				if ( url === undefined ) url = '';

				if ( this.path !== undefined ) url = this.path + url;

				var scope = this;

				var cached = Cache.get( url );

				if ( cached !== undefined ) {

					scope.manager.itemStart( url );

					setTimeout( function () {

						if ( onLoad ) onLoad( cached );

						scope.manager.itemEnd( url );

					}, 0 );

					return cached;

				}

				// Check for data: URI
				var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
				var dataUriRegexResult = url.match( dataUriRegex );

				// Safari can not handle Data URIs through XMLHttpRequest so process manually
				if ( dataUriRegexResult ) {

					var mimeType = dataUriRegexResult[ 1 ];
					var isBase64 = !! dataUriRegexResult[ 2 ];
					var data = dataUriRegexResult[ 3 ];

					data = window.decodeURIComponent( data );

					if ( isBase64 ) data = window.atob( data );

					try {

						var response;
						var responseType = ( this.responseType || '' ).toLowerCase();

						switch ( responseType ) {

							case 'arraybuffer':
							case 'blob':

							 	response = new ArrayBuffer( data.length );

								var view = new Uint8Array( response );

								for ( var i = 0; i < data.length; i ++ ) {

									view[ i ] = data.charCodeAt( i );

								}

								if ( responseType === 'blob' ) {

									response = new Blob( [ response ], { type: mimeType } );

								}

								break;

							case 'document':

								var parser = new DOMParser();
								response = parser.parseFromString( data, mimeType );

								break;

							case 'json':

								response = JSON.parse( data );

								break;

							default: // 'text' or other

								response = data;

								break;

						}

						// Wait for next browser tick
						window.setTimeout( function () {

							if ( onLoad ) onLoad( response );

							scope.manager.itemEnd( url );

						}, 0 );

					} catch ( error ) {

						// Wait for next browser tick
						window.setTimeout( function () {

							if ( onError ) onError( error );

							scope.manager.itemError( url );

						}, 0 );

					}

				} else {

					var request = new XMLHttpRequest();
					request.open( 'GET', url, true );

					request.addEventListener( 'load', function ( event ) {

						var response = event.target.response;

						Cache.add( url, response );

						if ( this.status === 200 ) {

							if ( onLoad ) onLoad( response );

							scope.manager.itemEnd( url );

						} else if ( this.status === 0 ) {

							// Some browsers return HTTP Status 0 when using non-http protocol
							// e.g. 'file://' or 'data://'. Handle as success.

							console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

							if ( onLoad ) onLoad( response );

							scope.manager.itemEnd( url );

						} else {

							if ( onError ) onError( event );

							scope.manager.itemError( url );

						}

					}, false );

					if ( onProgress !== undefined ) {

						request.addEventListener( 'progress', function ( event ) {

							onProgress( event );

						}, false );

					}

					request.addEventListener( 'error', function ( event ) {

						if ( onError ) onError( event );

						scope.manager.itemError( url );

					}, false );

					if ( this.responseType !== undefined ) request.responseType = this.responseType;
					if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

					if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

					request.send( null );

				}

				scope.manager.itemStart( url );

				return request;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			},

			setResponseType: function ( value ) {

				this.responseType = value;
				return this;

			},

			setWithCredentials: function ( value ) {

				this.withCredentials = value;
				return this;

			},

			setMimeType: function ( value ) {

				this.mimeType = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * Abstract Base class to block based textures loader (dds, pvr, ...)
		 */

		function CompressedTextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			// override in sub classes
			this._parser = null;

		}

		Object.assign( CompressedTextureLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var images = [];

				var texture = new CompressedTexture();
				texture.image = images;

				var loader = new FileLoader( this.manager );
				loader.setPath( this.path );
				loader.setResponseType( 'arraybuffer' );

				function loadTexture( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

							if ( texDatas.mipmapCount === 1 )
								texture.minFilter = LinearFilter;

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					}, onProgress, onError );

				}

				if ( Array.isArray( url ) ) {

					var loaded = 0;

					for ( var i = 0, il = url.length; i < il; ++ i ) {

						loadTexture( i );

					}

				} else {

					// compressed cubemap texture stored in a single DDS file

					loader.load( url, function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						if ( texDatas.isCubemap ) {

							var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

							for ( var f = 0; f < faces; f ++ ) {

								images[ f ] = { mipmaps : [] };

								for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

									images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
									images[ f ].format = texDatas.format;
									images[ f ].width = texDatas.width;
									images[ f ].height = texDatas.height;

								}

							}

						} else {

							texture.image.width = texDatas.width;
							texture.image.height = texDatas.height;
							texture.mipmaps = texDatas.mipmaps;

						}

						if ( texDatas.mipmapCount === 1 ) {

							texture.minFilter = LinearFilter;

						}

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}, onProgress, onError );

				}

				return texture;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author Nikos M. / https://github.com/foo123/
		 *
		 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
		 */

		function DataTextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			// override in sub classes
			this._parser = null;

		}

		Object.assign( DataTextureLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var texture = new DataTexture();

				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );

				loader.load( url, function ( buffer ) {

					var texData = scope._parser( buffer );

					if ( ! texData ) return;

					if ( undefined !== texData.image ) {

						texture.image = texData.image;

					} else if ( undefined !== texData.data ) {

						texture.image.width = texData.width;
						texture.image.height = texData.height;
						texture.image.data = texData.data;

					}

					texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
					texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

					texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
					texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

					texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

					if ( undefined !== texData.format ) {

						texture.format = texData.format;

					}
					if ( undefined !== texData.type ) {

						texture.type = texData.type;

					}

					if ( undefined !== texData.mipmaps ) {

						texture.mipmaps = texData.mipmaps;

					}

					if ( 1 === texData.mipmapCount ) {

						texture.minFilter = LinearFilter;

					}

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture, texData );

				}, onProgress, onError );


				return texture;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ImageLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( ImageLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				if ( url === undefined ) url = '';

				if ( this.path !== undefined ) url = this.path + url;

				var scope = this;

				var cached = Cache.get( url );

				if ( cached !== undefined ) {

					scope.manager.itemStart( url );

					setTimeout( function () {

						if ( onLoad ) onLoad( cached );

						scope.manager.itemEnd( url );

					}, 0 );

					return cached;

				}

				var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

				image.addEventListener( 'load', function () {

					Cache.add( url, this );

					if ( onLoad ) onLoad( this );

					scope.manager.itemEnd( url );

				}, false );

				/*
				image.addEventListener( 'progress', function ( event ) {

					if ( onProgress ) onProgress( event );

				}, false );
				*/

				image.addEventListener( 'error', function ( event ) {

					if ( onError ) onError( event );

					scope.manager.itemError( url );

				}, false );

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

				scope.manager.itemStart( url );

				image.src = url;

				return image;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;
				return this;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CubeTextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( CubeTextureLoader.prototype, {

			load: function ( urls, onLoad, onProgress, onError ) {

				var texture = new CubeTexture();

				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );

				var loaded = 0;

				function loadTexture( i ) {

					loader.load( urls[ i ], function ( image ) {

						texture.images[ i ] = image;

						loaded ++;

						if ( loaded === 6 ) {

							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					}, undefined, onError );

				}

				for ( var i = 0; i < urls.length; ++ i ) {

					loadTexture( i );

				}

				return texture;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;
				return this;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function TextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( TextureLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var texture = new Texture();

				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );
				loader.load( url, function ( image ) {

					// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
					var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

					texture.format = isJPEG ? RGBFormat : RGBAFormat;
					texture.image = image;
					texture.needsUpdate = true;

					if ( onLoad !== undefined ) {

						onLoad( texture );

					}

				}, onProgress, onError );

				return texture;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;
				return this;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Light( color, intensity ) {

			Object3D.call( this );

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity !== undefined ? intensity : 1;

			this.receiveShadow = undefined;

		}

		Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Light,

			isLight: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.color.copy( source.color );
				this.intensity = source.intensity;

				return this;

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.color = this.color.getHex();
				data.object.intensity = this.intensity;

				if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

				if ( this.distance !== undefined ) data.object.distance = this.distance;
				if ( this.angle !== undefined ) data.object.angle = this.angle;
				if ( this.decay !== undefined ) data.object.decay = this.decay;
				if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

				if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

				return data;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function HemisphereLight( skyColor, groundColor, intensity ) {

			Light.call( this, skyColor, intensity );

			this.type = 'HemisphereLight';

			this.castShadow = undefined;

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.groundColor = new Color( groundColor );

		}

		HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: HemisphereLight,

			isHemisphereLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.groundColor.copy( source.groundColor );

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 */

		function LightShadow( camera ) {

			this.camera = camera;

			this.bias = 0;
			this.radius = 1;

			this.mapSize = new Vector2( 512, 512 );

			this.map = null;
			this.matrix = new Matrix4();

			this.cameraFovNearFar = new Vector3( 2 * _Math.DEG2RAD, 0.5, 500 );

		}

		Object.assign( LightShadow.prototype, {

			copy: function ( source ) {

				this.camera = source.camera.clone();

				this.bias = source.bias;
				this.radius = source.radius;

				this.mapSize.copy( source.mapSize );

				this.cameraFovNearFar.copy( source.cameraFovNearFar );

				return this;

			},



			clone: function () {

				return new this.constructor().copy( this );

			},

			toJSON: function () {

				var object = {};

				if ( this.bias !== 0 ) object.bias = this.bias;
				if ( this.radius !== 1 ) object.radius = this.radius;
				if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

				object.camera = this.camera.toJSON( false ).object;
				delete object.camera.matrix;

				return object;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function SpotLightShadow() {

			var fov = 50;
			this.cameraParams = new Vector3( fov, 10.5, 1000 );
			LightShadow.call( this, new PerspectiveCamera( this.cameraParams.x, 1, this.cameraParams.y, this.cameraParams.z ) );

		}

		SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

			constructor: SpotLightShadow,

			isSpotLightShadow: true,

			update: function ( light ) {

				var fov = _Math.RAD2DEG * 2 * light.angle;
				var aspect = this.mapSize.width / this.mapSize.height;
				var far = light.distance || 500;

				var camera = this.camera;

				this.cameraParams.x = fov * _Math.DEG2RAD;
				this.cameraParams.y = light.shadow.camera.near;
				this.cameraParams.z = far;

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

			Light.call( this, color, intensity );

			this.type = 'SpotLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * Math.PI;
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / Math.PI;
				}
			} );

			this.distance = ( distance !== undefined ) ? distance : 0;
			this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
			this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();

		}

		SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: SpotLight,

			isSpotLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.distance = source.distance;
				this.angle = source.angle;
				this.penumbra = source.penumbra;
				this.decay = source.decay;

				this.target = source.target.clone();

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */


		function PointLight( color, intensity, distance, decay ) {

			Light.call( this, color, intensity );

			this.type = 'PointLight';

			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * 4 * Math.PI;

				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / ( 4 * Math.PI );
				}
			} );

			this.distance = ( distance !== undefined ) ? distance : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

			this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		}

		PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: PointLight,

			isPointLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.distance = source.distance;
				this.decay = source.decay;

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io
		 */

		function DirectionalLightShadow( ) {

			var frustrumWidth = 300;
			this.spreadAngle = 0.0;
			this.cameraParams = new Vector3( 2*frustrumWidth, 0.5, 1000 );
			LightShadow.call( this, new OrthographicCamera( - frustrumWidth, frustrumWidth, frustrumWidth, - frustrumWidth, this.cameraParams.y, this.cameraParams.z ) );

		}

		DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

			constructor: DirectionalLightShadow

		} );

		DirectionalLightShadow.prototype.update = function ( light ) {

			var camera = this.camera;
			var frustrumWidth = Math.abs(camera.left - camera.right);
			if ( this.cameraParams.x !== frustrumWidth || this.cameraParams.y !== camera.near || this.cameraParams.z !== camera.far ) {

				this.cameraParams.x = frustrumWidth;
				this.cameraParams.y = camera.near;
				this.cameraParams.z = camera.far;
			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function DirectionalLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: DirectionalLight,

			isDirectionalLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.target = source.target.clone();

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AmbientLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'AmbientLight';

			this.castShadow = undefined;

		}

		AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: AmbientLight,

			isAmbientLight: true

		} );

		/**
		 * @author tschw
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */

		var AnimationUtils = {

			// same as Array.prototype.slice, but also works on typed arrays
			arraySlice: function( array, from, to ) {

				if ( AnimationUtils.isTypedArray( array ) ) {

					return new array.constructor( array.subarray( from, to ) );

				}

				return array.slice( from, to );

			},

			// converts an array to a specific type
			convertArray: function( array, type, forceClone ) {

				if ( ! array || // let 'undefined' and 'null' pass
						! forceClone && array.constructor === type ) return array;

				if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

					return new type( array ); // create typed array

				}

				return Array.prototype.slice.call( array ); // create Array

			},

			isTypedArray: function( object ) {

				return ArrayBuffer.isView( object ) &&
						! ( object instanceof DataView );

			},

			// returns an array by which times and values can be sorted
			getKeyframeOrder: function( times ) {

				function compareTime( i, j ) {

					return times[ i ] - times[ j ];

				}

				var n = times.length;
				var result = new Array( n );
				for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

				result.sort( compareTime );

				return result;

			},

			// uses the array previously returned by 'getKeyframeOrder' to sort data
			sortedArray: function( values, stride, order ) {

				var nValues = values.length;
				var result = new values.constructor( nValues );

				for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

					var srcOffset = order[ i ] * stride;

					for ( var j = 0; j !== stride; ++ j ) {

						result[ dstOffset ++ ] = values[ srcOffset + j ];

					}

				}

				return result;

			},

			// function for parsing AOS keyframe formats
			flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

				var i = 1, key = jsonKeys[ 0 ];

				while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

					key = jsonKeys[ i ++ ];

				}

				if ( key === undefined ) return; // no data

				var value = key[ valuePropertyName ];
				if ( value === undefined ) return; // no data

				if ( Array.isArray( value ) ) {

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							values.push.apply( values, value ); // push all elements

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				} else if ( value.toArray !== undefined ) {
					// ...assume THREE.Math-ish

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							value.toArray( values, values.length );

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				} else {
					// otherwise push as-is

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							values.push( value );

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				}

			}

		};

		/**
		 * Abstract base class of interpolants over parametric samples.
		 *
		 * The parameter domain is one dimensional, typically the time or a path
		 * along a curve defined by the data.
		 *
		 * The sample values can have any dimensionality and derived classes may
		 * apply special interpretations to the data.
		 *
		 * This class provides the interval seek in a Template Method, deferring
		 * the actual interpolation to derived classes.
		 *
		 * Time complexity is O(1) for linear access crossing at most two points
		 * and O(log N) for random access, where N is the number of positions.
		 *
		 * References:
		 *
		 * 		http://www.oodesign.com/template-method-pattern.html
		 *
		 * @author tschw
		 */

		function Interpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;

			this.resultBuffer = resultBuffer !== undefined ?
					resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;

		}

		Interpolant.prototype = {

			constructor: Interpolant,

			evaluate: function( t ) {

				var pp = this.parameterPositions,
					i1 = this._cachedIndex,

					t1 = pp[   i1   ],
					t0 = pp[ i1 - 1 ];

				validate_interval: {

					seek: {

						var right;

						linear_scan: {
		//- See http://jsperf.com/comparison-to-undefined/3
		//- slower code:
		//-
		//- 				if ( t >= t1 || t1 === undefined ) {
							forward_scan: if ( ! ( t < t1 ) ) {

								for ( var giveUpAt = i1 + 2; ;) {

									if ( t1 === undefined ) {

										if ( t < t0 ) break forward_scan;

										// after end

										i1 = pp.length;
										this._cachedIndex = i1;
										return this.afterEnd_( i1 - 1, t, t0 );

									}

									if ( i1 === giveUpAt ) break; // this loop

									t0 = t1;
									t1 = pp[ ++ i1 ];

									if ( t < t1 ) {

										// we have arrived at the sought interval
										break seek;

									}

								}

								// prepare binary search on the right side of the index
								right = pp.length;
								break linear_scan;

							}

		//- slower code:
		//-					if ( t < t0 || t0 === undefined ) {
							if ( ! ( t >= t0 ) ) {

								// looping?

								var t1global = pp[ 1 ];

								if ( t < t1global ) {

									i1 = 2; // + 1, using the scan for the details
									t0 = t1global;

								}

								// linear reverse scan

								for ( var giveUpAt = i1 - 2; ;) {

									if ( t0 === undefined ) {

										// before start

										this._cachedIndex = 0;
										return this.beforeStart_( 0, t, t1 );

									}

									if ( i1 === giveUpAt ) break; // this loop

									t1 = t0;
									t0 = pp[ -- i1 - 1 ];

									if ( t >= t0 ) {

										// we have arrived at the sought interval
										break seek;

									}

								}

								// prepare binary search on the left side of the index
								right = i1;
								i1 = 0;
								break linear_scan;

							}

							// the interval is valid

							break validate_interval;

						} // linear scan

						// binary search

						while ( i1 < right ) {

							var mid = ( i1 + right ) >>> 1;

							if ( t < pp[ mid ] ) {

								right = mid;

							} else {

								i1 = mid + 1;

							}

						}

						t1 = pp[   i1   ];
						t0 = pp[ i1 - 1 ];

						// check boundary cases, again

						if ( t0 === undefined ) {

							this._cachedIndex = 0;
							return this.beforeStart_( 0, t, t1 );

						}

						if ( t1 === undefined ) {

							i1 = pp.length;
							this._cachedIndex = i1;
							return this.afterEnd_( i1 - 1, t0, t );

						}

					} // seek

					this._cachedIndex = i1;

					this.intervalChanged_( i1, t0, t1 );

				} // validate_interval

				return this.interpolate_( i1, t0, t, t1 );

			},

			settings: null, // optional, subclass-specific settings structure
			// Note: The indirection allows central control of many interpolants.

			// --- Protected interface

			DefaultSettings_: {},

			getSettings_: function() {

				return this.settings || this.DefaultSettings_;

			},

			copySampleValue_: function( index ) {

				// copies a sample value to the result buffer

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] = values[ offset + i ];

				}

				return result;

			},

			// Template methods for derived classes:

			interpolate_: function( i1, t0, t, t1 ) {

				throw new Error( "call to abstract method" );
				// implementations shall return this.resultBuffer

			},

			intervalChanged_: function( i1, t0, t1 ) {

				// empty

			}

		};

		Object.assign( Interpolant.prototype, {

			beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_,

			afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_

		} );

		/**
		 * Fast and simple cubic spline interpolant.
		 *
		 * It was derived from a Hermitian construction setting the first derivative
		 * at each sample position to the linear slope between neighboring positions
		 * over their parameter interval.
		 *
		 * @author tschw
		 */

		function CubicInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;

		}

		CubicInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: CubicInterpolant,

			DefaultSettings_: {

				endingStart: 	ZeroCurvatureEnding,
				endingEnd:		ZeroCurvatureEnding

			},

			intervalChanged_: function( i1, t0, t1 ) {

				var pp = this.parameterPositions,
					iPrev = i1 - 2,
					iNext = i1 + 1,

					tPrev = pp[ iPrev ],
					tNext = pp[ iNext ];

				if ( tPrev === undefined ) {

					switch ( this.getSettings_().endingStart ) {

						case ZeroSlopeEnding:

							// f'(t0) = 0
							iPrev = i1;
							tPrev = 2 * t0 - t1;

							break;

						case WrapAroundEnding:

							// use the other end of the curve
							iPrev = pp.length - 2;
							tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

							break;

						default: // ZeroCurvatureEnding

							// f''(t0) = 0 a.k.a. Natural Spline
							iPrev = i1;
							tPrev = t1;

					}

				}

				if ( tNext === undefined ) {

					switch ( this.getSettings_().endingEnd ) {

						case ZeroSlopeEnding:

							// f'(tN) = 0
							iNext = i1;
							tNext = 2 * t1 - t0;

							break;

						case WrapAroundEnding:

							// use the other end of the curve
							iNext = 1;
							tNext = t1 + pp[ 1 ] - pp[ 0 ];

							break;

						default: // ZeroCurvatureEnding

							// f''(tN) = 0, a.k.a. Natural Spline
							iNext = i1 - 1;
							tNext = t0;

					}

				}

				var halfDt = ( t1 - t0 ) * 0.5,
					stride = this.valueSize;

				this._weightPrev = halfDt / ( t0 - tPrev );
				this._weightNext = halfDt / ( tNext - t1 );
				this._offsetPrev = iPrev * stride;
				this._offsetNext = iNext * stride;

			},

			interpolate_: function( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					o1 = i1 * stride,		o0 = o1 - stride,
					oP = this._offsetPrev, 	oN = this._offsetNext,
					wP = this._weightPrev,	wN = this._weightNext,

					p = ( t - t0 ) / ( t1 - t0 ),
					pp = p * p,
					ppp = pp * p;

				// evaluate polynomials

				var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
				var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
				var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
				var sN =       wN   * ppp   -           wN      * pp;

				// combine data linearly

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] =
							sP * values[ oP + i ] +
							s0 * values[ o0 + i ] +
							s1 * values[ o1 + i ] +
							sN * values[ oN + i ];

				}

				return result;

			}

		} );

		/**
		 * @author tschw
		 */

		function LinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		LinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: LinearInterpolant,

			interpolate_: function( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset1 = i1 * stride,
					offset0 = offset1 - stride,

					weight1 = ( t - t0 ) / ( t1 - t0 ),
					weight0 = 1 - weight1;

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] =
							values[ offset0 + i ] * weight0 +
							values[ offset1 + i ] * weight1;

				}

				return result;

			}

		} );

		/**
		 *
		 * Interpolant that evaluates to the sample value at the position preceeding
		 * the parameter.
		 *
		 * @author tschw
		 */

		function DiscreteInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		DiscreteInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: DiscreteInterpolant,

			interpolate_: function( i1, t0, t, t1 ) {

				return this.copySampleValue_( i1 - 1 );

			}

		} );

		var KeyframeTrackPrototype;

		KeyframeTrackPrototype = {

			TimeBufferType: Float32Array,
			ValueBufferType: Float32Array,

			DefaultInterpolation: InterpolateLinear,

			InterpolantFactoryMethodDiscrete: function ( result ) {

				return new DiscreteInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodLinear: function ( result ) {

				return new LinearInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodSmooth: function ( result ) {

				return new CubicInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			setInterpolation: function ( interpolation ) {

				var factoryMethod;

				switch ( interpolation ) {

					case InterpolateDiscrete:

						factoryMethod = this.InterpolantFactoryMethodDiscrete;

						break;

					case InterpolateLinear:

						factoryMethod = this.InterpolantFactoryMethodLinear;

						break;

					case InterpolateSmooth:

						factoryMethod = this.InterpolantFactoryMethodSmooth;

						break;

				}

				if ( factoryMethod === undefined ) {

					var message = "unsupported interpolation for " +
							this.ValueTypeName + " keyframe track named " + this.name;

					if ( this.createInterpolant === undefined ) {

						// fall back to default, unless the default itself is messed up
						if ( interpolation !== this.DefaultInterpolation ) {

							this.setInterpolation( this.DefaultInterpolation );

						} else {

							throw new Error( message ); // fatal, in this case

						}

					}

					console.warn( message );
					return;

				}

				this.createInterpolant = factoryMethod;

			},

			getInterpolation: function () {

				switch ( this.createInterpolant ) {

					case this.InterpolantFactoryMethodDiscrete:

						return InterpolateDiscrete;

					case this.InterpolantFactoryMethodLinear:

						return InterpolateLinear;

					case this.InterpolantFactoryMethodSmooth:

						return InterpolateSmooth;

				}

			},

			getValueSize: function () {

				return this.values.length / this.times.length;

			},

			// move all keyframes either forwards or backwards in time
			shift: function ( timeOffset ) {

				if ( timeOffset !== 0.0 ) {

					var times = this.times;

					for ( var i = 0, n = times.length; i !== n; ++ i ) {

						times[ i ] += timeOffset;

					}

				}

				return this;

			},

			// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
			scale: function ( timeScale ) {

				if ( timeScale !== 1.0 ) {

					var times = this.times;

					for ( var i = 0, n = times.length; i !== n; ++ i ) {

						times[ i ] *= timeScale;

					}

				}

				return this;

			},

			// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
			// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
			trim: function ( startTime, endTime ) {

				var times = this.times,
					nKeys = times.length,
					from = 0,
					to = nKeys - 1;

				while ( from !== nKeys && times[ from ] < startTime ) ++ from;
				while ( to !== - 1 && times[ to ] > endTime ) -- to;

				++ to; // inclusive -> exclusive bound

				if ( from !== 0 || to !== nKeys ) {

					// empty tracks are forbidden, so keep at least one keyframe
					if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

					var stride = this.getValueSize();
					this.times = AnimationUtils.arraySlice( times, from, to );
					this.values = AnimationUtils.
							arraySlice( this.values, from * stride, to * stride );

				}

				return this;

			},

			// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
			validate: function () {

				var valid = true;

				var valueSize = this.getValueSize();
				if ( valueSize - Math.floor( valueSize ) !== 0 ) {

					console.error( "invalid value size in track", this );
					valid = false;

				}

				var times = this.times,
					values = this.values,

					nKeys = times.length;

				if ( nKeys === 0 ) {

					console.error( "track is empty", this );
					valid = false;

				}

				var prevTime = null;

				for ( var i = 0; i !== nKeys; i ++ ) {

					var currTime = times[ i ];

					if ( typeof currTime === 'number' && isNaN( currTime ) ) {

						console.error( "time is not a valid number", this, i, currTime );
						valid = false;
						break;

					}

					if ( prevTime !== null && prevTime > currTime ) {

						console.error( "out of order keys", this, i, currTime, prevTime );
						valid = false;
						break;

					}

					prevTime = currTime;

				}

				if ( values !== undefined ) {

					if ( AnimationUtils.isTypedArray( values ) ) {

						for ( var i = 0, n = values.length; i !== n; ++ i ) {

							var value = values[ i ];

							if ( isNaN( value ) ) {

								console.error( "value is not a valid number", this, i, value );
								valid = false;
								break;

							}

						}

					}

				}

				return valid;

			},

			// removes equivalent sequential keys as common in morph target sequences
			// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
			optimize: function () {

				var times = this.times,
					values = this.values,
					stride = this.getValueSize(),

					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

					writeIndex = 1,
					lastIndex = times.length - 1;

				for ( var i = 1; i < lastIndex; ++ i ) {

					var keep = false;

					var time = times[ i ];
					var timeNext = times[ i + 1 ];

					// remove adjacent keyframes scheduled at the same time

					if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

						if ( ! smoothInterpolation ) {

							// remove unnecessary keyframes same as their neighbors

							var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;

							for ( var j = 0; j !== stride; ++ j ) {

								var value = values[ offset + j ];

								if ( value !== values[ offsetP + j ] ||
										value !== values[ offsetN + j ] ) {

									keep = true;
									break;

								}

							}

						} else keep = true;

					}

					// in-place compaction

					if ( keep ) {

						if ( i !== writeIndex ) {

							times[ writeIndex ] = times[ i ];

							var readOffset = i * stride,
								writeOffset = writeIndex * stride;

							for ( var j = 0; j !== stride; ++ j )

								values[ writeOffset + j ] = values[ readOffset + j ];

						}

						++ writeIndex;

					}

				}

				// flush last keyframe (compaction looks ahead)

				if ( lastIndex > 0 ) {

					times[ writeIndex ] = times[ lastIndex ];

					for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

						values[ writeOffset + j ] = values[ readOffset + j ];

					++ writeIndex;

				}

				if ( writeIndex !== times.length ) {

					this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
					this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

				}

				return this;

			}

		};

		function KeyframeTrackConstructor( name, times, values, interpolation ) {

			if( name === undefined ) throw new Error( "track name is undefined" );

			if( times === undefined || times.length === 0 ) {

				throw new Error( "no keyframes in track named " + name );

			}

			this.name = name;

			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

			this.setInterpolation( interpolation || this.DefaultInterpolation );

			this.validate();
			this.optimize();

		}

		/**
		 *
		 * A Track of vectored keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function VectorKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		VectorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: VectorKeyframeTrack,

			ValueTypeName: 'vector'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		} );

		/**
		 * Spherical linear unit quaternion interpolant.
		 *
		 * @author tschw
		 */

		function QuaternionLinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		QuaternionLinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: QuaternionLinearInterpolant,

			interpolate_: function( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset = i1 * stride,

					alpha = ( t - t0 ) / ( t1 - t0 );

				for ( var end = offset + stride; offset !== end; offset += 4 ) {

					Quaternion.slerpFlat( result, 0,
							values, offset - stride, values, offset, alpha );

				}

				return result;

			}

		} );

		/**
		 *
		 * A Track of quaternion keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function QuaternionKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		QuaternionKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: QuaternionKeyframeTrack,

			ValueTypeName: 'quaternion',

			// ValueBufferType is inherited

			DefaultInterpolation: InterpolateLinear,

			InterpolantFactoryMethodLinear: function( result ) {

				return new QuaternionLinearInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodSmooth: undefined // not yet implemented

		} );

		/**
		 *
		 * A Track of numeric keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function NumberKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		NumberKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: NumberKeyframeTrack,

			ValueTypeName: 'number'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		} );

		/**
		 *
		 * A Track that interpolates Strings
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function StringKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		StringKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: StringKeyframeTrack,

			ValueTypeName: 'string',
			ValueBufferType: Array,

			DefaultInterpolation: InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,

			InterpolantFactoryMethodSmooth: undefined

		} );

		/**
		 *
		 * A Track of Boolean keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function BooleanKeyframeTrack( name, times, values ) {

			KeyframeTrackConstructor.call( this, name, times, values );

		}

		BooleanKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: BooleanKeyframeTrack,

			ValueTypeName: 'bool',
			ValueBufferType: Array,

			DefaultInterpolation: InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,
			InterpolantFactoryMethodSmooth: undefined

			// Note: Actually this track could have a optimized / compressed
			// representation of a single value and a custom interpolant that
			// computes "firstValue ^ isOdd( index )".

		} );

		/**
		 *
		 * A Track of keyframe values that represent color.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function ColorKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		ColorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: ColorKeyframeTrack,

			ValueTypeName: 'color'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited


			// Note: Very basic implementation and nothing special yet.
			// However, this is the place for color space parameterization.

		} );

		/**
		 *
		 * A timed sequence of keyframes for a specific property.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function KeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.apply( this, arguments );

		}

		KeyframeTrack.prototype = KeyframeTrackPrototype;
		KeyframeTrackPrototype.constructor = KeyframeTrack;

		// Static methods:

		Object.assign( KeyframeTrack, {

			// Serialization (in static context, because of constructor invocation
			// and automatic invocation of .toJSON):

			parse: function( json ) {

				if( json.type === undefined ) {

					throw new Error( "track type undefined, can not parse" );

				}

				var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

				if ( json.times === undefined ) {

					var times = [], values = [];

					AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

					json.times = times;
					json.values = values;

				}

				// derived classes can define a static parse method
				if ( trackType.parse !== undefined ) {

					return trackType.parse( json );

				} else {

					// by default, we asssume a constructor compatible with the base
					return new trackType(
							json.name, json.times, json.values, json.interpolation );

				}

			},

			toJSON: function( track ) {

				var trackType = track.constructor;

				var json;

				// derived classes can define a static toJSON method
				if ( trackType.toJSON !== undefined ) {

					json = trackType.toJSON( track );

				} else {

					// by default, we assume the data can be serialized as-is
					json = {

						'name': track.name,
						'times': AnimationUtils.convertArray( track.times, Array ),
						'values': AnimationUtils.convertArray( track.values, Array )

					};

					var interpolation = track.getInterpolation();

					if ( interpolation !== track.DefaultInterpolation ) {

						json.interpolation = interpolation;

					}

				}

				json.type = track.ValueTypeName; // mandatory

				return json;

			},

			_getTrackTypeForValueTypeName: function( typeName ) {

				switch( typeName.toLowerCase() ) {

					case "scalar":
					case "double":
					case "float":
					case "number":
					case "integer":

						return NumberKeyframeTrack;

					case "vector":
					case "vector2":
					case "vector3":
					case "vector4":

						return VectorKeyframeTrack;

					case "color":

						return ColorKeyframeTrack;

					case "quaternion":

						return QuaternionKeyframeTrack;

					case "bool":
					case "boolean":

						return BooleanKeyframeTrack;

					case "string":

						return StringKeyframeTrack;

				}

				throw new Error( "Unsupported typeName: " + typeName );

			}

		} );

		/**
		 *
		 * Reusable set of Tracks that represent an animation.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */

		function AnimationClip( name, duration, tracks ) {

			this.name = name;
			this.tracks = tracks;
			this.duration = ( duration !== undefined ) ? duration : -1;

			this.uuid = _Math.generateUUID();

			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {

				this.resetDuration();

			}

			this.optimize();

		}

		AnimationClip.prototype = {

			constructor: AnimationClip,

			resetDuration: function() {

				var tracks = this.tracks,
					duration = 0;

				for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

					var track = this.tracks[ i ];

					duration = Math.max( duration, track.times[ track.times.length - 1 ] );

				}

				this.duration = duration;

			},

			trim: function() {

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					this.tracks[ i ].trim( 0, this.duration );

				}

				return this;

			},

			optimize: function() {

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					this.tracks[ i ].optimize();

				}

				return this;

			}

		};

		// Static methods:

		Object.assign( AnimationClip, {

			parse: function( json ) {

				var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / ( json.fps || 1.0 );

				for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

					tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

				}

				return new AnimationClip( json.name, json.duration, tracks );

			},


			toJSON: function( clip ) {

				var tracks = [],
					clipTracks = clip.tracks;

				var json = {

					'name': clip.name,
					'duration': clip.duration,
					'tracks': tracks

				};

				for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

					tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

				}

				return json;

			},


			CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

				var numMorphTargets = morphTargetSequence.length;
				var tracks = [];

				for ( var i = 0; i < numMorphTargets; i ++ ) {

					var times = [];
					var values = [];

					times.push(
							( i + numMorphTargets - 1 ) % numMorphTargets,
							i,
							( i + 1 ) % numMorphTargets );

					values.push( 0, 1, 0 );

					var order = AnimationUtils.getKeyframeOrder( times );
					times = AnimationUtils.sortedArray( times, 1, order );
					values = AnimationUtils.sortedArray( values, 1, order );

					// if there is a key at the first frame, duplicate it as the
					// last frame as well for perfect loop.
					if ( ! noLoop && times[ 0 ] === 0 ) {

						times.push( numMorphTargets );
						values.push( values[ 0 ] );

					}

					tracks.push(
							new NumberKeyframeTrack(
								'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
								times, values
							).scale( 1.0 / fps ) );
				}

				return new AnimationClip( name, -1, tracks );

			},

			findByName: function( objectOrClipArray, name ) {

				var clipArray = objectOrClipArray;

				if ( ! Array.isArray( objectOrClipArray ) ) {

					var o = objectOrClipArray;
					clipArray = o.geometry && o.geometry.animations || o.animations;

				}

				for ( var i = 0; i < clipArray.length; i ++ ) {

					if ( clipArray[ i ].name === name ) {

						return clipArray[ i ];

					}
				}

				return null;

			},

			CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

				var animationToMorphTargets = {};

				// tested with https://regex101.com/ on trick sequences
				// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
				var pattern = /^([\w-]*?)([\d]+)$/;

				// sort morph target names into animation groups based
				// patterns like Walk_001, Walk_002, Run_001, Run_002
				for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

					var morphTarget = morphTargets[ i ];
					var parts = morphTarget.name.match( pattern );

					if ( parts && parts.length > 1 ) {

						var name = parts[ 1 ];

						var animationMorphTargets = animationToMorphTargets[ name ];
						if ( ! animationMorphTargets ) {

							animationToMorphTargets[ name ] = animationMorphTargets = [];

						}

						animationMorphTargets.push( morphTarget );

					}

				}

				var clips = [];

				for ( var name in animationToMorphTargets ) {

					clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

				}

				return clips;

			},

			// parse the animation.hierarchy format
			parseAnimation: function( animation, bones ) {

				if ( ! animation ) {

					console.error( "  no animation in JSONLoader data" );
					return null;

				}

				var addNonemptyTrack = function(
						trackType, trackName, animationKeys, propertyName, destTracks ) {

					// only return track if there are actually keys.
					if ( animationKeys.length !== 0 ) {

						var times = [];
						var values = [];

						AnimationUtils.flattenJSON(
								animationKeys, times, values, propertyName );

						// empty keys are filtered out, so check again
						if ( times.length !== 0 ) {

							destTracks.push( new trackType( trackName, times, values ) );

						}

					}

				};

				var tracks = [];

				var clipName = animation.name || 'default';
				// automatic length determination in AnimationClip.
				var duration = animation.length || -1;
				var fps = animation.fps || 30;

				var hierarchyTracks = animation.hierarchy || [];

				for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

					var animationKeys = hierarchyTracks[ h ].keys;

					// skip empty tracks
					if ( ! animationKeys || animationKeys.length === 0 ) continue;

					// process morph targets in a way exactly compatible
					// with AnimationHandler.init( animation )
					if ( animationKeys[0].morphTargets ) {

						// figure out all morph targets used in this track
						var morphTargetNames = {};
						for ( var k = 0; k < animationKeys.length; k ++ ) {

							if ( animationKeys[k].morphTargets ) {

								for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

									morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
								}

							}

						}

						// create a track for each morph target with all zero
						// morphTargetInfluences except for the keys in which
						// the morphTarget is named.
						for ( var morphTargetName in morphTargetNames ) {

							var times = [];
							var values = [];

							for ( var m = 0; m !== animationKeys[k].morphTargets.length; ++ m ) {

								var animationKey = animationKeys[k];

								times.push( animationKey.time );
								values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

							}

							tracks.push( new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

						}

						duration = morphTargetNames.length * ( fps || 1.0 );

					} else {
						// ...assume skeletal animation

						var boneName = '.bones[' + bones[ h ].name + ']';

						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.position',
								animationKeys, 'pos', tracks );

						addNonemptyTrack(
								QuaternionKeyframeTrack, boneName + '.quaternion',
								animationKeys, 'rot', tracks );

						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.scale',
								animationKeys, 'scl', tracks );

					}

				}

				if ( tracks.length === 0 ) {

					return null;

				}

				var clip = new AnimationClip( clipName, duration, tracks );

				return clip;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function MaterialLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.textures = {};

		}

		Object.assign( MaterialLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( JSON.parse( text ) ) );

				}, onProgress, onError );

			},

			setTextures: function ( value ) {

				this.textures = value;

			},

			parse: function ( json ) {

				var textures = this.textures;

				function getTexture( name ) {

					if ( textures[ name ] === undefined ) {

						console.warn( 'THREE.MaterialLoader: Undefined texture', name );

					}

					return textures[ name ];

				}

				var material = new Materials[ json.type ]();

				if ( json.uuid !== undefined ) material.uuid = json.uuid;
				if ( json.name !== undefined ) material.name = json.name;
				if ( json.color !== undefined ) material.color.setHex( json.color );
				if ( json.roughness !== undefined ) material.roughness = json.roughness;
				if ( json.metalness !== undefined ) material.metalness = json.metalness;
				if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
				if ( json.specular !== undefined ) material.specular.setHex( json.specular );
				if ( json.shininess !== undefined ) material.shininess = json.shininess;
				if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
				if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
				if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
				if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
				if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
				if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
				if ( json.fog !== undefined ) material.fog = json.fog;
				if ( json.shading !== undefined ) material.shading = json.shading;
				if ( json.blending !== undefined ) material.blending = json.blending;
				if ( json.side !== undefined ) material.side = json.side;
				if ( json.opacity !== undefined ) material.opacity = json.opacity;
				if ( json.transparent !== undefined ) material.transparent = json.transparent;
				if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
				if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
				if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
				if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
				if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
				if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
				if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
				if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
				if ( json.skinning !== undefined ) material.skinning = json.skinning;
				if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

				// for PointsMaterial

				if ( json.size !== undefined ) material.size = json.size;
				if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

				// maps

				if ( json.map !== undefined ) material.map = getTexture( json.map );

				if ( json.alphaMap !== undefined ) {

					material.alphaMap = getTexture( json.alphaMap );
					material.transparent = true;

				}

				if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
				if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

				if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
				if ( json.normalScale !== undefined ) {

					var normalScale = json.normalScale;

					if ( Array.isArray( normalScale ) === false ) {

						// Blender exporter used to export a scalar. See #7459

						normalScale = [ normalScale, normalScale ];

					}

					material.normalScale = new Vector2().fromArray( normalScale );

				}

				if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
				if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
				if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

				if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
				if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

				if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
				if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

				if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

				if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

				if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

				if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
				if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

				if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
				if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

				if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

				// MultiMaterial

				if ( json.materials !== undefined ) {

					for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

						material.materials.push( this.parse( json.materials[ i ] ) );

					}

				}

				return material;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferGeometryLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( BufferGeometryLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( JSON.parse( text ) ) );

				}, onProgress, onError );

			},

			parse: function ( json ) {

				var geometry = new BufferGeometry();

				var index = json.data.index;

				var TYPED_ARRAYS = {
					'Int8Array': Int8Array,
					'Uint8Array': Uint8Array,
					'Uint8ClampedArray': Uint8ClampedArray,
					'Int16Array': Int16Array,
					'Uint16Array': Uint16Array,
					'Int32Array': Int32Array,
					'Uint32Array': Uint32Array,
					'Float32Array': Float32Array,
					'Float64Array': Float64Array
				};

				if ( index !== undefined ) {

					var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
					geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

				}

				var attributes = json.data.attributes;

				for ( var key in attributes ) {

					var attribute = attributes[ key ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

					geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

				}

				var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

				if ( groups !== undefined ) {

					for ( var i = 0, n = groups.length; i !== n; ++ i ) {

						var group = groups[ i ];

						geometry.addGroup( group.start, group.count, group.materialIndex );

					}

				}

				var boundingSphere = json.data.boundingSphere;

				if ( boundingSphere !== undefined ) {

					var center = new Vector3();

					if ( boundingSphere.center !== undefined ) {

						center.fromArray( boundingSphere.center );

					}

					geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

				}

				return geometry;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Loader() {

			this.onLoadStart = function () {};
			this.onLoadProgress = function () {};
			this.onLoadComplete = function () {};

		}

		Loader.prototype = {

			constructor: Loader,

			crossOrigin: undefined,

			extractUrlBase: function ( url ) {

				var parts = url.split( '/' );

				if ( parts.length === 1 ) return './';

				parts.pop();

				return parts.join( '/' ) + '/';

			},

			initMaterials: function ( materials, texturePath, crossOrigin ) {

				var array = [];

				for ( var i = 0; i < materials.length; ++ i ) {

					array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

				}

				return array;

			},

			createMaterial: ( function () {

				var BlendingMode = {
					NoBlending: NoBlending,
					NormalBlending: NormalBlending,
					AdditiveBlending: AdditiveBlending,
					SubtractiveBlending: SubtractiveBlending,
					MultiplyBlending: MultiplyBlending,
					CustomBlending: CustomBlending
				};

				var color, textureLoader, materialLoader;

				return function createMaterial( m, texturePath, crossOrigin ) {

					if ( color === undefined ) color = new Color();
					if ( textureLoader === undefined ) textureLoader = new TextureLoader();
					if ( materialLoader === undefined ) materialLoader = new MaterialLoader();

					// convert from old material format

					var textures = {};

					function loadTexture( path, repeat, offset, wrap, anisotropy ) {

						var fullPath = texturePath + path;
						var loader = Loader.Handlers.get( fullPath );

						var texture;

						if ( loader !== null ) {

							texture = loader.load( fullPath );

						} else {

							textureLoader.setCrossOrigin( crossOrigin );
							texture = textureLoader.load( fullPath );

						}

						if ( repeat !== undefined ) {

							texture.repeat.fromArray( repeat );

							if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
							if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

						}

						if ( offset !== undefined ) {

							texture.offset.fromArray( offset );

						}

						if ( wrap !== undefined ) {

							if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
							if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

							if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
							if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

						}

						if ( anisotropy !== undefined ) {

							texture.anisotropy = anisotropy;

						}

						var uuid = _Math.generateUUID();

						textures[ uuid ] = texture;

						return uuid;

					}

					//

					var json = {
						uuid: _Math.generateUUID(),
						type: 'MeshLambertMaterial'
					};

					for ( var name in m ) {

						var value = m[ name ];

						switch ( name ) {

							case 'DbgColor':
							case 'DbgIndex':
							case 'opticalDensity':
							case 'illumination':
								break;
							case 'DbgName':
								json.name = value;
								break;
							case 'blending':
								json.blending = BlendingMode[ value ];
								break;
							case 'colorAmbient':
							case 'mapAmbient':
								console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
								break;
							case 'colorDiffuse':
								json.color = color.fromArray( value ).getHex();
								break;
							case 'colorSpecular':
								json.specular = color.fromArray( value ).getHex();
								break;
							case 'colorEmissive':
								json.emissive = color.fromArray( value ).getHex();
								break;
							case 'specularCoef':
								json.shininess = value;
								break;
							case 'shading':
								if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
								if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
								if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
								break;
							case 'mapDiffuse':
								json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
								break;
							case 'mapDiffuseRepeat':
							case 'mapDiffuseOffset':
							case 'mapDiffuseWrap':
							case 'mapDiffuseAnisotropy':
								break;
							case 'mapEmissive':
								json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
								break;
							case 'mapEmissiveRepeat':
							case 'mapEmissiveOffset':
							case 'mapEmissiveWrap':
							case 'mapEmissiveAnisotropy':
								break;
							case 'mapLight':
								json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
								break;
							case 'mapLightRepeat':
							case 'mapLightOffset':
							case 'mapLightWrap':
							case 'mapLightAnisotropy':
								break;
							case 'mapAO':
								json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
								break;
							case 'mapAORepeat':
							case 'mapAOOffset':
							case 'mapAOWrap':
							case 'mapAOAnisotropy':
								break;
							case 'mapBump':
								json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
								break;
							case 'mapBumpScale':
								json.bumpScale = value;
								break;
							case 'mapBumpRepeat':
							case 'mapBumpOffset':
							case 'mapBumpWrap':
							case 'mapBumpAnisotropy':
								break;
							case 'mapNormal':
								json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
								break;
							case 'mapNormalFactor':
								json.normalScale = [ value, value ];
								break;
							case 'mapNormalRepeat':
							case 'mapNormalOffset':
							case 'mapNormalWrap':
							case 'mapNormalAnisotropy':
								break;
							case 'mapSpecular':
								json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
								break;
							case 'mapSpecularRepeat':
							case 'mapSpecularOffset':
							case 'mapSpecularWrap':
							case 'mapSpecularAnisotropy':
								break;
							case 'mapMetalness':
								json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
								break;
							case 'mapMetalnessRepeat':
							case 'mapMetalnessOffset':
							case 'mapMetalnessWrap':
							case 'mapMetalnessAnisotropy':
								break;
							case 'mapRoughness':
								json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
								break;
							case 'mapRoughnessRepeat':
							case 'mapRoughnessOffset':
							case 'mapRoughnessWrap':
							case 'mapRoughnessAnisotropy':
								break;
							case 'mapAlpha':
								json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
								break;
							case 'mapAlphaRepeat':
							case 'mapAlphaOffset':
							case 'mapAlphaWrap':
							case 'mapAlphaAnisotropy':
								break;
							case 'flipSided':
								json.side = BackSide;
								break;
							case 'doubleSided':
								json.side = DoubleSide;
								break;
							case 'transparency':
								console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
								json.opacity = value;
								break;
							case 'depthTest':
							case 'depthWrite':
							case 'colorWrite':
							case 'opacity':
							case 'reflectivity':
							case 'transparent':
							case 'visible':
							case 'wireframe':
								json[ name ] = value;
								break;
							case 'vertexColors':
								if ( value === true ) json.vertexColors = VertexColors;
								if ( value === 'face' ) json.vertexColors = FaceColors;
								break;
							default:
								console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
								break;

						}

					}

					if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
					if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

					if ( json.opacity < 1 ) json.transparent = true;

					materialLoader.setTextures( textures );

					return materialLoader.parse( json );

				};

			} )()

		};

		Loader.Handlers = {

			handlers: [],

			add: function ( regex, loader ) {

				this.handlers.push( regex, loader );

			},

			get: function ( file ) {

				var handlers = this.handlers;

				for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

					var regex = handlers[ i ];
					var loader = handlers[ i + 1 ];

					if ( regex.test( file ) ) {

						return loader;

					}

				}

				return null;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function JSONLoader( manager ) {

			if ( typeof manager === 'boolean' ) {

				console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
				manager = undefined;

			}

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			this.withCredentials = false;

		}

		Object.assign( JSONLoader.prototype, {

			load: function( url, onLoad, onProgress, onError ) {

				var scope = this;

				var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

				var loader = new FileLoader( this.manager );
				loader.setWithCredentials( this.withCredentials );
				loader.load( url, function ( text ) {

					var json = JSON.parse( text );
					var metadata = json.metadata;

					if ( metadata !== undefined ) {

						var type = metadata.type;

						if ( type !== undefined ) {

							if ( type.toLowerCase() === 'object' ) {

								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;

							}

							if ( type.toLowerCase() === 'scene' ) {

								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
								return;

							}

						}

					}

					var object = scope.parse( json, texturePath );
					onLoad( object.geometry, object.materials );

				}, onProgress, onError );

			},

			setTexturePath: function ( value ) {

				this.texturePath = value;

			},

			parse: function ( json, texturePath ) {

				var geometry = new Geometry(),
				scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

				parseModel( scale );

				parseSkin();
				parseMorphing( scale );
				parseAnimations();

				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();

				function parseModel( scale ) {

					function isBitSet( value, position ) {

						return value & ( 1 << position );

					}

					var i, j, fi,

					offset, zLength,

				colorIndex, normalIndex, uvIndex, materialIndex,

					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,

				vertex, face, faceA, faceB, hex, normal,

					uvLayer, uv, u, v,

					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,

					nUvLayers = 0;

					if ( json.uvs !== undefined ) {

						// disregard empty arrays

						for ( i = 0; i < json.uvs.length; i ++ ) {

							if ( json.uvs[ i ].length ) nUvLayers ++;

						}

						for ( i = 0; i < nUvLayers; i ++ ) {

							geometry.faceVertexUvs[ i ] = [];

						}

					}

					offset = 0;
					zLength = vertices.length;

					while ( offset < zLength ) {

						vertex = new Vector3();

						vertex.x = vertices[ offset ++ ] * scale;
						vertex.y = vertices[ offset ++ ] * scale;
						vertex.z = vertices[ offset ++ ] * scale;

						geometry.vertices.push( vertex );

					}

					offset = 0;
					zLength = faces.length;

					while ( offset < zLength ) {

						type = faces[ offset ++ ];


						isQuad              = isBitSet( type, 0 );
						hasMaterial         = isBitSet( type, 1 );
						hasFaceVertexUv     = isBitSet( type, 3 );
						hasFaceNormal       = isBitSet( type, 4 );
						hasFaceVertexNormal = isBitSet( type, 5 );
						hasFaceColor	     = isBitSet( type, 6 );
						hasFaceVertexColor  = isBitSet( type, 7 );

						// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

						if ( isQuad ) {

							faceA = new Face3();
							faceA.a = faces[ offset ];
							faceA.b = faces[ offset + 1 ];
							faceA.c = faces[ offset + 3 ];

							faceB = new Face3();
							faceB.a = faces[ offset + 1 ];
							faceB.b = faces[ offset + 2 ];
							faceB.c = faces[ offset + 3 ];

							offset += 4;

							if ( hasMaterial ) {

								materialIndex = faces[ offset ++ ];
								faceA.materialIndex = materialIndex;
								faceB.materialIndex = materialIndex;

							}

							// to get face <=> uv index correspondence

							fi = geometry.faces.length;

							if ( hasFaceVertexUv ) {

								for ( i = 0; i < nUvLayers; i ++ ) {

									uvLayer = json.uvs[ i ];

									geometry.faceVertexUvs[ i ][ fi ] = [];
									geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

									for ( j = 0; j < 4; j ++ ) {

										uvIndex = faces[ offset ++ ];

										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];

										uv = new Vector2( u, v );

										if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
										if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

									}

								}

							}

							if ( hasFaceNormal ) {

								normalIndex = faces[ offset ++ ] * 3;

								faceA.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								faceB.normal.copy( faceA.normal );

							}

							if ( hasFaceVertexNormal ) {

								for ( i = 0; i < 4; i ++ ) {

									normalIndex = faces[ offset ++ ] * 3;

									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);


									if ( i !== 2 ) faceA.vertexNormals.push( normal );
									if ( i !== 0 ) faceB.vertexNormals.push( normal );

								}

							}


							if ( hasFaceColor ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								faceA.color.setHex( hex );
								faceB.color.setHex( hex );

							}


							if ( hasFaceVertexColor ) {

								for ( i = 0; i < 4; i ++ ) {

									colorIndex = faces[ offset ++ ];
									hex = colors[ colorIndex ];

									if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
									if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

								}

							}

							geometry.faces.push( faceA );
							geometry.faces.push( faceB );

						} else {

							face = new Face3();
							face.a = faces[ offset ++ ];
							face.b = faces[ offset ++ ];
							face.c = faces[ offset ++ ];

							if ( hasMaterial ) {

								materialIndex = faces[ offset ++ ];
								face.materialIndex = materialIndex;

							}

							// to get face <=> uv index correspondence

							fi = geometry.faces.length;

							if ( hasFaceVertexUv ) {

								for ( i = 0; i < nUvLayers; i ++ ) {

									uvLayer = json.uvs[ i ];

									geometry.faceVertexUvs[ i ][ fi ] = [];

									for ( j = 0; j < 3; j ++ ) {

										uvIndex = faces[ offset ++ ];

										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];

										uv = new Vector2( u, v );

										geometry.faceVertexUvs[ i ][ fi ].push( uv );

									}

								}

							}

							if ( hasFaceNormal ) {

								normalIndex = faces[ offset ++ ] * 3;

								face.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

							}

							if ( hasFaceVertexNormal ) {

								for ( i = 0; i < 3; i ++ ) {

									normalIndex = faces[ offset ++ ] * 3;

									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);

									face.vertexNormals.push( normal );

								}

							}


							if ( hasFaceColor ) {

								colorIndex = faces[ offset ++ ];
								face.color.setHex( colors[ colorIndex ] );

							}


							if ( hasFaceVertexColor ) {

								for ( i = 0; i < 3; i ++ ) {

									colorIndex = faces[ offset ++ ];
									face.vertexColors.push( new Color( colors[ colorIndex ] ) );

								}

							}

							geometry.faces.push( face );

						}

					}

				}

				function parseSkin() {

					var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

					if ( json.skinWeights ) {

						for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

							var x =                               json.skinWeights[ i ];
							var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
							var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
							var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

							geometry.skinWeights.push( new Vector4( x, y, z, w ) );

						}

					}

					if ( json.skinIndices ) {

						for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

							var a =                               json.skinIndices[ i ];
							var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
							var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
							var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

							geometry.skinIndices.push( new Vector4( a, b, c, d ) );

						}

					}

					geometry.bones = json.bones;

					if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

						console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
							geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

					}

				}

				function parseMorphing( scale ) {

					if ( json.morphTargets !== undefined ) {

						for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

							geometry.morphTargets[ i ] = {};
							geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
							geometry.morphTargets[ i ].vertices = [];

							var dstVertices = geometry.morphTargets[ i ].vertices;
							var srcVertices = json.morphTargets[ i ].vertices;

							for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

								var vertex = new Vector3();
								vertex.x = srcVertices[ v ] * scale;
								vertex.y = srcVertices[ v + 1 ] * scale;
								vertex.z = srcVertices[ v + 2 ] * scale;

								dstVertices.push( vertex );

							}

						}

					}

					if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

						console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

						var faces = geometry.faces;
						var morphColors = json.morphColors[ 0 ].colors;

						for ( var i = 0, l = faces.length; i < l; i ++ ) {

							faces[ i ].color.fromArray( morphColors, i * 3 );

						}

					}

				}

				function parseAnimations() {

					var outputAnimations = [];

					// parse old style Bone/Hierarchy animations
					var animations = [];

					if ( json.animation !== undefined ) {

						animations.push( json.animation );

					}

					if ( json.animations !== undefined ) {

						if ( json.animations.length ) {

							animations = animations.concat( json.animations );

						} else {

							animations.push( json.animations );

						}

					}

					for ( var i = 0; i < animations.length; i ++ ) {

						var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
						if ( clip ) outputAnimations.push( clip );

					}

					// parse implicit morph animations
					if ( geometry.morphTargets ) {

						// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
						var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
						outputAnimations = outputAnimations.concat( morphAnimationClips );

					}

					if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

				}

				if ( json.materials === undefined || json.materials.length === 0 ) {

					return { geometry: geometry };

				} else {

					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

					return { geometry: geometry, materials: materials };

				}

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ObjectLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.texturePath = '';

		}

		Object.assign( ObjectLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				if ( this.texturePath === '' ) {

					this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

				}

				var scope = this;

				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {

					var json = null;

					try {

						json = JSON.parse( text );

					} catch ( error ) {

						console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );
						return;

					}

					var metadata = json.metadata;

					if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

						console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
						return;

					}

					scope.parse( json, onLoad );

				}, onProgress, onError );

			},

			setTexturePath: function ( value ) {

				this.texturePath = value;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;

			},

			parse: function ( json, onLoad ) {

				var geometries = this.parseGeometries( json.geometries );

				var images = this.parseImages( json.images, function () {

					if ( onLoad !== undefined ) onLoad( object );

				} );

				var textures = this.parseTextures( json.textures, images );
				var materials = this.parseMaterials( json.materials, textures );

				var object = this.parseObject( json.object, geometries, materials );

				if ( json.animations ) {

					object.animations = this.parseAnimations( json.animations );

				}

				if ( json.images === undefined || json.images.length === 0 ) {

					if ( onLoad !== undefined ) onLoad( object );

				}

				return object;

			},

			parseGeometries: function ( json ) {

				var geometries = {};

				if ( json !== undefined ) {

					var geometryLoader = new JSONLoader();
					var bufferGeometryLoader = new BufferGeometryLoader();

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var geometry;
						var data = json[ i ];

						switch ( data.type ) {

							case 'PlaneGeometry':
							case 'PlaneBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.widthSegments,
									data.heightSegments
								);

								break;

							case 'BoxGeometry':
							case 'BoxBufferGeometry':
							case 'CubeGeometry': // backwards compatible

								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.depth,
									data.widthSegments,
									data.heightSegments,
									data.depthSegments
								);

								break;

							case 'CircleGeometry':
							case 'CircleBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.segments,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'CylinderGeometry':
							case 'CylinderBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radiusTop,
									data.radiusBottom,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'ConeGeometry':
							case 'ConeBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'SphereGeometry':
							case 'SphereBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.widthSegments,
									data.heightSegments,
									data.phiStart,
									data.phiLength,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'DodecahedronGeometry':
							case 'IcosahedronGeometry':
							case 'OctahedronGeometry':
							case 'TetrahedronGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.detail
								);

								break;

							case 'RingGeometry':
							case 'RingBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.innerRadius,
									data.outerRadius,
									data.thetaSegments,
									data.phiSegments,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'TorusGeometry':
							case 'TorusBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.radialSegments,
									data.tubularSegments,
									data.arc
								);

								break;

							case 'TorusKnotGeometry':
							case 'TorusKnotBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.tubularSegments,
									data.radialSegments,
									data.p,
									data.q
								);

								break;

							case 'LatheGeometry':
							case 'LatheBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.points,
									data.segments,
									data.phiStart,
									data.phiLength
								);

								break;

							case 'BufferGeometry':

								geometry = bufferGeometryLoader.parse( data );

								break;

							case 'Geometry':

								geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

								break;

							default:

								console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

								continue;

						}

						geometry.uuid = data.uuid;

						if ( data.name !== undefined ) geometry.name = data.name;

						geometries[ data.uuid ] = geometry;

					}

				}

				return geometries;

			},

			parseMaterials: function ( json, textures ) {

				var materials = {};

				if ( json !== undefined ) {

					var loader = new MaterialLoader();
					loader.setTextures( textures );

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var material = loader.parse( json[ i ] );
						materials[ material.uuid ] = material;

					}

				}

				return materials;

			},

			parseAnimations: function ( json ) {

				var animations = [];

				for ( var i = 0; i < json.length; i ++ ) {

					var clip = AnimationClip.parse( json[ i ] );

					animations.push( clip );

				}

				return animations;

			},

			parseImages: function ( json, onLoad ) {

				var scope = this;
				var images = {};

				function loadImage( url ) {

					scope.manager.itemStart( url );

					return loader.load( url, function () {

						scope.manager.itemEnd( url );

					}, undefined, function () {

						scope.manager.itemError( url );

					} );

				}

				if ( json !== undefined && json.length > 0 ) {

					var manager = new LoadingManager( onLoad );

					var loader = new ImageLoader( manager );
					loader.setCrossOrigin( this.crossOrigin );

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var image = json[ i ];
						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

						images[ image.uuid ] = loadImage( path );

					}

				}

				return images;

			},

			parseTextures: function ( json, images ) {

				var TextureMapping = {
					UVMapping: UVMapping,
					CubeReflectionMapping: CubeReflectionMapping,
					CubeRefractionMapping: CubeRefractionMapping,
					EquirectangularReflectionMapping: EquirectangularReflectionMapping,
					EquirectangularRefractionMapping: EquirectangularRefractionMapping,
					SphericalReflectionMapping: SphericalReflectionMapping,
					CubeUVReflectionMapping: CubeUVReflectionMapping,
					CubeUVRefractionMapping: CubeUVRefractionMapping
				};

				var TextureWrapping = {
					RepeatWrapping: RepeatWrapping,
					ClampToEdgeWrapping: ClampToEdgeWrapping,
					MirroredRepeatWrapping: MirroredRepeatWrapping
				};

				var TextureFilter = {
					NearestFilter: NearestFilter,
					NearestMipMapNearestFilter: NearestMipMapNearestFilter,
					NearestMipMapLinearFilter: NearestMipMapLinearFilter,
					LinearFilter: LinearFilter,
					LinearMipMapNearestFilter: LinearMipMapNearestFilter,
					LinearMipMapLinearFilter: LinearMipMapLinearFilter
				};

				function parseConstant( value, type ) {

					if ( typeof( value ) === 'number' ) return value;

					console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

					return type[ value ];

				}

				var textures = {};

				if ( json !== undefined ) {

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var data = json[ i ];

						if ( data.image === undefined ) {

							console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

						}

						if ( images[ data.image ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

						}

						var texture = new Texture( images[ data.image ] );
						texture.needsUpdate = true;

						texture.uuid = data.uuid;

						if ( data.name !== undefined ) texture.name = data.name;

						if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );

						if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
						if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
						if ( data.wrap !== undefined ) {

							texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
							texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );

						}

						if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
						if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
						if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

						if ( data.flipY !== undefined ) texture.flipY = data.flipY;

						textures[ data.uuid ] = texture;

					}

				}

				return textures;

			},

			parseObject: function () {

				var matrix = new Matrix4();

				return function parseObject( data, geometries, materials ) {

					var object;

					function getGeometry( name ) {

						if ( geometries[ name ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

						}

						return geometries[ name ];

					}

					function getMaterial( name ) {

						if ( name === undefined ) return undefined;

						if ( materials[ name ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', name );

						}

						return materials[ name ];

					}

					switch ( data.type ) {

						case 'Scene':

							object = new Scene();

							if ( data.background !== undefined ) {

								if ( Number.isInteger( data.background ) ) {

									object.background = new Color( data.background );

								}

							}

							if ( data.fog !== undefined ) {

								if ( data.fog.type === 'Fog' ) {

									object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

								} else if ( data.fog.type === 'FogExp2' ) {

									object.fog = new FogExp2( data.fog.color, data.fog.density );

								}

							}

							break;

						case 'PerspectiveCamera':

							object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

							if ( data.focus !== undefined ) object.focus = data.focus;
							if ( data.zoom !== undefined ) object.zoom = data.zoom;
							if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
							if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
							if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

							break;

						case 'OrthographicCamera':

							object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

							break;

						case 'AmbientLight':

							object = new AmbientLight( data.color, data.intensity );

							break;

						case 'DirectionalLight':

							object = new DirectionalLight( data.color, data.intensity );

							break;

						case 'PointLight':

							object = new PointLight( data.color, data.intensity, data.distance, data.decay );

							break;

						case 'SpotLight':

							object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

							break;

						case 'HemisphereLight':

							object = new HemisphereLight( data.color, data.groundColor, data.intensity );

							break;

						case 'Mesh':

							var geometry = getGeometry( data.geometry );
							var material = getMaterial( data.material );

							if ( geometry.bones && geometry.bones.length > 0 ) {

								object = new SkinnedMesh( geometry, material );

							} else {

								object = new Mesh( geometry, material );

							}

							break;

						case 'LOD':

							object = new LOD();

							break;

						case 'Line':

							object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

							break;

						case 'LineSegments':

							object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

							break;

						case 'PointCloud':
						case 'Points':

							object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

							break;

						case 'Sprite':

							object = new Sprite( getMaterial( data.material ) );

							break;

						case 'Group':

							object = new Group();

							break;

						case 'SkinnedMesh':

							console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.' );

						default:

							object = new Object3D();

					}

					object.uuid = data.uuid;

					if ( data.name !== undefined ) object.name = data.name;
					if ( data.matrix !== undefined ) {

						matrix.fromArray( data.matrix );
						matrix.decompose( object.position, object.quaternion, object.scale );

					} else {

						if ( data.position !== undefined ) object.position.fromArray( data.position );
						if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
						if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
						if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

					}

					if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
					if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

					if ( data.shadow ) {

						if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
						if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
						if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
						if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

					}

					if ( data.visible !== undefined ) object.visible = data.visible;
					if ( data.userData !== undefined ) object.userData = data.userData;

					if ( data.children !== undefined ) {

						for ( var child in data.children ) {

							object.add( this.parseObject( data.children[ child ], geometries, materials ) );

						}

					}

					if ( data.type === 'LOD' ) {

						var levels = data.levels;

						for ( var l = 0; l < levels.length; l ++ ) {

							var level = levels[ l ];
							var child = object.getObjectByProperty( 'uuid', level.object );

							if ( child !== undefined ) {

								object.addLevel( child, level.distance );

							}

						}

					}

					return object;

				};

			}()

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Bezier Curves formulas obtained from
		 * http://en.wikipedia.org/wiki/Bézier_curve
		 */

		function CatmullRom( t, p0, p1, p2, p3 ) {

			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

		//

		function QuadraticBezierP0( t, p ) {

			var k = 1 - t;
			return k * k * p;

		}

		function QuadraticBezierP1( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		}

		function QuadraticBezierP2( t, p ) {

			return t * t * p;

		}

		function QuadraticBezier( t, p0, p1, p2 ) {

			return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
				QuadraticBezierP2( t, p2 );

		}

		//

		function CubicBezierP0( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		}

		function CubicBezierP1( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		}

		function CubicBezierP2( t, p ) {

			return 3 * ( 1 - t ) * t * t * p;

		}

		function CubicBezierP3( t, p ) {

			return t * t * t * p;

		}

		function CubicBezier( t, p0, p1, p2, p3 ) {

			return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
				CubicBezierP3( t, p3 );

		}

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Extensible curve object
		 *
		 * Some common of Curve methods
		 * .getPoint(t), getTangent(t)
		 * .getPointAt(u), getTangentAt(u)
		 * .getPoints(), .getSpacedPoints()
		 * .getLength()
		 * .updateArcLengths()
		 *
		 * This following classes subclasses THREE.Curve:
		 *
		 * -- 2d classes --
		 * THREE.LineCurve
		 * THREE.QuadraticBezierCurve
		 * THREE.CubicBezierCurve
		 * THREE.SplineCurve
		 * THREE.ArcCurve
		 * THREE.EllipseCurve
		 *
		 * -- 3d classes --
		 * THREE.LineCurve3
		 * THREE.QuadraticBezierCurve3
		 * THREE.CubicBezierCurve3
		 * THREE.CatmullRomCurve3
		 *
		 * A series of curves can be represented as a THREE.CurvePath
		 *
		 **/

		/**************************************************************
		 *	Abstract Curve base class
		 **************************************************************/

		function Curve() {}

		Curve.prototype = {

			constructor: Curve,

			// Virtual base class method to overwrite and implement in subclasses
			//	- t [0 .. 1]

			getPoint: function ( t ) {

				console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
				return null;

			},

			// Get point at relative position in curve according to arc length
			// - u [0 .. 1]

			getPointAt: function ( u ) {

				var t = this.getUtoTmapping( u );
				return this.getPoint( t );

			},

			// Get sequence of points using getPoint( t )

			getPoints: function ( divisions ) {

				if ( ! divisions ) divisions = 5;

				var points = [];

				for ( var d = 0; d <= divisions; d ++ ) {

					points.push( this.getPoint( d / divisions ) );

				}

				return points;

			},

			// Get sequence of points using getPointAt( u )

			getSpacedPoints: function ( divisions ) {

				if ( ! divisions ) divisions = 5;

				var points = [];

				for ( var d = 0; d <= divisions; d ++ ) {

					points.push( this.getPointAt( d / divisions ) );

				}

				return points;

			},

			// Get total curve arc length

			getLength: function () {

				var lengths = this.getLengths();
				return lengths[ lengths.length - 1 ];

			},

			// Get list of cumulative segment lengths

			getLengths: function ( divisions ) {

				if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

				if ( this.cacheArcLengths
					&& ( this.cacheArcLengths.length === divisions + 1 )
					&& ! this.needsUpdate ) {

					//console.log( "cached", this.cacheArcLengths );
					return this.cacheArcLengths;

				}

				this.needsUpdate = false;

				var cache = [];
				var current, last = this.getPoint( 0 );
				var p, sum = 0;

				cache.push( 0 );

				for ( p = 1; p <= divisions; p ++ ) {

					current = this.getPoint ( p / divisions );
					sum += current.distanceTo( last );
					cache.push( sum );
					last = current;

				}

				this.cacheArcLengths = cache;

				return cache; // { sums: cache, sum:sum }; Sum is in the last element.

			},

			updateArcLengths: function() {

				this.needsUpdate = true;
				this.getLengths();

			},

			// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

			getUtoTmapping: function ( u, distance ) {

				var arcLengths = this.getLengths();

				var i = 0, il = arcLengths.length;

				var targetArcLength; // The targeted u distance value to get

				if ( distance ) {

					targetArcLength = distance;

				} else {

					targetArcLength = u * arcLengths[ il - 1 ];

				}

				//var time = Date.now();

				// binary search for the index with largest value smaller than target u distance

				var low = 0, high = il - 1, comparison;

				while ( low <= high ) {

					i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

					comparison = arcLengths[ i ] - targetArcLength;

					if ( comparison < 0 ) {

						low = i + 1;

					} else if ( comparison > 0 ) {

						high = i - 1;

					} else {

						high = i;
						break;

						// DONE

					}

				}

				i = high;

				//console.log('b' , i, low, high, Date.now()- time);

				if ( arcLengths[ i ] === targetArcLength ) {

					var t = i / ( il - 1 );
					return t;

				}

				// we could get finer grain at lengths, or use simple interpolation between two points

				var lengthBefore = arcLengths[ i ];
				var lengthAfter = arcLengths[ i + 1 ];

				var segmentLength = lengthAfter - lengthBefore;

				// determine where we are between the 'before' and 'after' points

				var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

				// add that fractional amount to t

				var t = ( i + segmentFraction ) / ( il - 1 );

				return t;

			},

			// Returns a unit vector tangent at t
			// In case any sub curve does not implement its tangent derivation,
			// 2 points a small delta apart will be used to find its gradient
			// which seems to give a reasonable approximation

			getTangent: function( t ) {

				var delta = 0.0001;
				var t1 = t - delta;
				var t2 = t + delta;

				// Capping in case of danger

				if ( t1 < 0 ) t1 = 0;
				if ( t2 > 1 ) t2 = 1;

				var pt1 = this.getPoint( t1 );
				var pt2 = this.getPoint( t2 );

				var vec = pt2.clone().sub( pt1 );
				return vec.normalize();

			},

			getTangentAt: function ( u ) {

				var t = this.getUtoTmapping( u );
				return this.getTangent( t );

			},

			computeFrenetFrames: function ( segments, closed ) {

				// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

				var normal = new Vector3();

				var tangents = [];
				var normals = [];
				var binormals = [];

				var vec = new Vector3();
				var mat = new Matrix4();

				var i, u, theta;

				// compute the tangent vectors for each segment on the curve

				for ( i = 0; i <= segments; i ++ ) {

					u = i / segments;

					tangents[ i ] = this.getTangentAt( u );
					tangents[ i ].normalize();

				}

				// select an initial normal vector perpendicular to the first tangent vector,
				// and in the direction of the minimum tangent xyz component

				normals[ 0 ] = new Vector3();
				binormals[ 0 ] = new Vector3();
				var min = Number.MAX_VALUE;
				var tx = Math.abs( tangents[ 0 ].x );
				var ty = Math.abs( tangents[ 0 ].y );
				var tz = Math.abs( tangents[ 0 ].z );

				if ( tx <= min ) {

					min = tx;
					normal.set( 1, 0, 0 );

				}

				if ( ty <= min ) {

					min = ty;
					normal.set( 0, 1, 0 );

				}

				if ( tz <= min ) {

					normal.set( 0, 0, 1 );

				}

				vec.crossVectors( tangents[ 0 ], normal ).normalize();

				normals[ 0 ].crossVectors( tangents[ 0 ], vec );
				binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


				// compute the slowly-varying normal and binormal vectors for each segment on the curve

				for ( i = 1; i <= segments; i ++ ) {

					normals[ i ] = normals[ i - 1 ].clone();

					binormals[ i ] = binormals[ i - 1 ].clone();

					vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

					if ( vec.length() > Number.EPSILON ) {

						vec.normalize();

						theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

						normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

					}

					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

				// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

				if ( closed === true ) {

					theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
					theta /= segments;

					if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

						theta = - theta;

					}

					for ( i = 1; i <= segments; i ++ ) {

						// twist a little...
						normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
						binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

					}

				}

				return {
					tangents: tangents,
					normals: normals,
					binormals: binormals
				};

			}

		};

		function LineCurve( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		}

		LineCurve.prototype = Object.create( Curve.prototype );
		LineCurve.prototype.constructor = LineCurve;

		LineCurve.prototype.isLineCurve = true;

		LineCurve.prototype.getPoint = function ( t ) {

			if ( t === 1 ) {

				return this.v2.clone();

			}

			var point = this.v2.clone().sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

			return point;

		};

		// Line curve is linear, so we can overwrite default getPointAt

		LineCurve.prototype.getPointAt = function ( u ) {

			return this.getPoint( u );

		};

		LineCurve.prototype.getTangent = function ( t ) {

			var tangent = this.v2.clone().sub( this.v1 );

			return tangent.normalize();

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 **/

		/**************************************************************
		 *	Curved Path - a curve path is simply a array of connected
		 *  curves, but retains the api of a curve
		 **************************************************************/

		function CurvePath() {

			this.curves = [];

			this.autoClose = false; // Automatically closes the path

		}

		CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

			constructor: CurvePath,

			add: function ( curve ) {

				this.curves.push( curve );

			},

			closePath: function () {

				// Add a line curve if start and end of lines are not connected
				var startPoint = this.curves[ 0 ].getPoint( 0 );
				var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

				if ( ! startPoint.equals( endPoint ) ) {

					this.curves.push( new LineCurve( endPoint, startPoint ) );

				}

			},

			// To get accurate point with reference to
			// entire path distance at time t,
			// following has to be done:

			// 1. Length of each sub path have to be known
			// 2. Locate and identify type of curve
			// 3. Get t for the curve
			// 4. Return curve.getPointAt(t')

			getPoint: function ( t ) {

				var d = t * this.getLength();
				var curveLengths = this.getCurveLengths();
				var i = 0;

				// To think about boundaries points.

				while ( i < curveLengths.length ) {

					if ( curveLengths[ i ] >= d ) {

						var diff = curveLengths[ i ] - d;
						var curve = this.curves[ i ];

						var segmentLength = curve.getLength();
						var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

						return curve.getPointAt( u );

					}

					i ++;

				}

				return null;

				// loop where sum != 0, sum > d , sum+1 <d

			},

			// We cannot use the default THREE.Curve getPoint() with getLength() because in
			// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
			// getPoint() depends on getLength

			getLength: function () {

				var lens = this.getCurveLengths();
				return lens[ lens.length - 1 ];

			},

			// cacheLengths must be recalculated.
			updateArcLengths: function () {

				this.needsUpdate = true;
				this.cacheLengths = null;
				this.getLengths();

			},

			// Compute lengths and cache them
			// We cannot overwrite getLengths() because UtoT mapping uses it.

			getCurveLengths: function () {

				// We use cache values if curves and cache array are same length

				if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

					return this.cacheLengths;

				}

				// Get length of sub-curve
				// Push sums into cached array

				var lengths = [], sums = 0;

				for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

					sums += this.curves[ i ].getLength();
					lengths.push( sums );

				}

				this.cacheLengths = lengths;

				return lengths;

			},

			getSpacedPoints: function ( divisions ) {

				if ( ! divisions ) divisions = 40;

				var points = [];

				for ( var i = 0; i <= divisions; i ++ ) {

					points.push( this.getPoint( i / divisions ) );

				}

				if ( this.autoClose ) {

					points.push( points[ 0 ] );

				}

				return points;

			},

			getPoints: function ( divisions ) {

				divisions = divisions || 12;

				var points = [], last;

				for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

					var curve = curves[ i ];
					var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
						: (curve && curve.isLineCurve) ? 1
						: (curve && curve.isSplineCurve) ? divisions * curve.points.length
						: divisions;

					var pts = curve.getPoints( resolution );

					for ( var j = 0; j < pts.length; j++ ) {

						var point = pts[ j ];

						if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

						points.push( point );
						last = point;

					}

				}

				if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

					points.push( points[ 0 ] );

				}

				return points;

			},

			/**************************************************************
			 *	Create Geometries Helpers
			 **************************************************************/

			/// Generate geometry from path points (for Line or Points objects)

			createPointsGeometry: function ( divisions ) {

				var pts = this.getPoints( divisions );
				return this.createGeometry( pts );

			},

			// Generate geometry from equidistant sampling along the path

			createSpacedPointsGeometry: function ( divisions ) {

				var pts = this.getSpacedPoints( divisions );
				return this.createGeometry( pts );

			},

			createGeometry: function ( points ) {

				var geometry = new Geometry();

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					var point = points[ i ];
					geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

				}

				return geometry;

			}

		} );

		function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			this.aX = aX;
			this.aY = aY;

			this.xRadius = xRadius;
			this.yRadius = yRadius;

			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;

			this.aClockwise = aClockwise;

			this.aRotation = aRotation || 0;

		}

		EllipseCurve.prototype = Object.create( Curve.prototype );
		EllipseCurve.prototype.constructor = EllipseCurve;

		EllipseCurve.prototype.isEllipseCurve = true;

		EllipseCurve.prototype.getPoint = function ( t ) {

			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

			if ( deltaAngle < Number.EPSILON ) {

				if ( samePoints ) {

					deltaAngle = 0;

				} else {

					deltaAngle = twoPi;

				}

			}

			if ( this.aClockwise === true && ! samePoints ) {

				if ( deltaAngle === twoPi ) {

					deltaAngle = - twoPi;

				} else {

					deltaAngle = deltaAngle - twoPi;

				}

			}

			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos( angle );
			var y = this.aY + this.yRadius * Math.sin( angle );

			if ( this.aRotation !== 0 ) {

				var cos = Math.cos( this.aRotation );
				var sin = Math.sin( this.aRotation );

				var tx = x - this.aX;
				var ty = y - this.aY;

				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;

			}

			return new Vector2( x, y );

		};

		function SplineCurve( points /* array of Vector2 */ ) {

			this.points = ( points === undefined ) ? [] : points;

		}

		SplineCurve.prototype = Object.create( Curve.prototype );
		SplineCurve.prototype.constructor = SplineCurve;

		SplineCurve.prototype.isSplineCurve = true;

		SplineCurve.prototype.getPoint = function ( t ) {

			var points = this.points;
			var point = ( points.length - 1 ) * t;

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			return new Vector2(
				CatmullRom( weight, point0.x, point1.x, point2.x, point3.x ),
				CatmullRom( weight, point0.y, point1.y, point2.y, point3.y )
			);

		};

		function CubicBezierCurve( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		CubicBezierCurve.prototype = Object.create( Curve.prototype );
		CubicBezierCurve.prototype.constructor = CubicBezierCurve;

		CubicBezierCurve.prototype.getPoint = function ( t ) {

			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			return new Vector2(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
			);

		};

		function QuadraticBezierCurve( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

		QuadraticBezierCurve.prototype.getPoint = function ( t ) {

			var v0 = this.v0, v1 = this.v1, v2 = this.v2;

			return new Vector2(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y )
			);

		};

		var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

			fromPoints: function ( vectors ) {

				this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

				for ( var i = 1, l = vectors.length; i < l; i ++ ) {

					this.lineTo( vectors[ i ].x, vectors[ i ].y );

				}

			},

			moveTo: function ( x, y ) {

				this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

			},

			lineTo: function ( x, y ) {

				var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
				this.curves.push( curve );

				this.currentPoint.set( x, y );

			},

			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

				var curve = new QuadraticBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCPx, aCPy ),
					new Vector2( aX, aY )
				);

				this.curves.push( curve );

				this.currentPoint.set( aX, aY );

			},

			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

				var curve = new CubicBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCP1x, aCP1y ),
					new Vector2( aCP2x, aCP2y ),
					new Vector2( aX, aY )
				);

				this.curves.push( curve );

				this.currentPoint.set( aX, aY );

			},

			splineThru: function ( pts /*Array of Vector*/ ) {

				var npts = [ this.currentPoint.clone() ].concat( pts );

				var curve = new SplineCurve( npts );
				this.curves.push( curve );

				this.currentPoint.copy( pts[ pts.length - 1 ] );

			},

			arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;

				this.absarc( aX + x0, aY + y0, aRadius,
					aStartAngle, aEndAngle, aClockwise );

			},

			absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

				this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			},

			ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;

				this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			},

			absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

				var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

				if ( this.curves.length > 0 ) {

					// if a previous curve is present, attempt to join
					var firstPoint = curve.getPoint( 0 );

					if ( ! firstPoint.equals( this.currentPoint ) ) {

						this.lineTo( firstPoint.x, firstPoint.y );

					}

				}

				this.curves.push( curve );

				var lastPoint = curve.getPoint( 1 );
				this.currentPoint.copy( lastPoint );

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Creates free form 2d path using series of points, lines or curves.
		 **/

		function Path( points ) {

			CurvePath.call( this );
			this.currentPoint = new Vector2();

			if ( points ) {

				this.fromPoints( points );

			}

		}

		Path.prototype = PathPrototype;
		PathPrototype.constructor = Path;

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Defines a 2d shape plane using paths.
		 **/

		// STEP 1 Create a path.
		// STEP 2 Turn path into shape.
		// STEP 3 ExtrudeGeometry takes in Shape/Shapes
		// STEP 3a - Extract points from each shape, turn to vertices
		// STEP 3b - Triangulate each shape, add faces.

		function Shape() {

			Path.apply( this, arguments );

			this.holes = [];

		}

		Shape.prototype = Object.assign( Object.create( PathPrototype ), {

			constructor: Shape,

			getPointsHoles: function ( divisions ) {

				var holesPts = [];

				for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

					holesPts[ i ] = this.holes[ i ].getPoints( divisions );

				}

				return holesPts;

			},

			// Get points of shape and holes (keypoints based on segments parameter)

			extractAllPoints: function ( divisions ) {

				return {

					shape: this.getPoints( divisions ),
					holes: this.getPointsHoles( divisions )

				};

			},

			extractPoints: function ( divisions ) {

				return this.extractAllPoints( divisions );

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
		 **/

		function ShapePath() {

			this.subPaths = [];
			this.currentPath = null;

		}

		ShapePath.prototype = {

			moveTo: function ( x, y ) {

				this.currentPath = new Path();
				this.subPaths.push( this.currentPath );
				this.currentPath.moveTo( x, y );

			},

			lineTo: function ( x, y ) {

				this.currentPath.lineTo( x, y );

			},

			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

				this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

			},

			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

				this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

			},

			splineThru: function ( pts ) {

				this.currentPath.splineThru( pts );

			},

			toShapes: function ( isCCW, noHoles ) {

				function toShapesNoHoles( inSubpaths ) {

					var shapes = [];

					for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

						var tmpPath = inSubpaths[ i ];

						var tmpShape = new Shape();
						tmpShape.curves = tmpPath.curves;

						shapes.push( tmpShape );

					}

					return shapes;

				}

				function isPointInsidePolygon( inPt, inPolygon ) {

					var polyLen = inPolygon.length;

					// inPt on polygon contour => immediate success    or
					// toggling of inside/outside at every single! intersection point of an edge
					//  with the horizontal line through inPt, left of inPt
					//  not counting lowerY endpoints of edges and whole edges on that line
					var inside = false;
					for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

						var edgeLowPt  = inPolygon[ p ];
						var edgeHighPt = inPolygon[ q ];

						var edgeDx = edgeHighPt.x - edgeLowPt.x;
						var edgeDy = edgeHighPt.y - edgeLowPt.y;

						if ( Math.abs( edgeDy ) > Number.EPSILON ) {

							// not parallel
							if ( edgeDy < 0 ) {

								edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
								edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

							}
							if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

							if ( inPt.y === edgeLowPt.y ) {

								if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
								// continue;				// no intersection or edgeLowPt => doesn't count !!!

							} else {

								var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
								if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
								if ( perpEdge < 0 ) 				continue;
								inside = ! inside;		// true intersection left of inPt

							}

						} else {

							// parallel or collinear
							if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
							// edge lies on the same horizontal line as inPt
							if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
								 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
							// continue;

						}

					}

					return	inside;

				}

				var isClockWise = ShapeUtils.isClockWise;

				var subPaths = this.subPaths;
				if ( subPaths.length === 0 ) return [];

				if ( noHoles === true )	return	toShapesNoHoles( subPaths );


				var solid, tmpPath, tmpShape, shapes = [];

				if ( subPaths.length === 1 ) {

					tmpPath = subPaths[ 0 ];
					tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push( tmpShape );
					return shapes;

				}

				var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
				holesFirst = isCCW ? ! holesFirst : holesFirst;

				// console.log("Holes first", holesFirst);

				var betterShapeHoles = [];
				var newShapes = [];
				var newShapeHoles = [];
				var mainIdx = 0;
				var tmpPoints;

				newShapes[ mainIdx ] = undefined;
				newShapeHoles[ mainIdx ] = [];

				for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

					tmpPath = subPaths[ i ];
					tmpPoints = tmpPath.getPoints();
					solid = isClockWise( tmpPoints );
					solid = isCCW ? ! solid : solid;

					if ( solid ) {

						if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

						newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
						newShapes[ mainIdx ].s.curves = tmpPath.curves;

						if ( holesFirst )	mainIdx ++;
						newShapeHoles[ mainIdx ] = [];

						//console.log('cw', i);

					} else {

						newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

						//console.log('ccw', i);

					}

				}

				// only Holes? -> probably all Shapes with wrong orientation
				if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


				if ( newShapes.length > 1 ) {

					var ambiguous = false;
					var toChange = [];

					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

						betterShapeHoles[ sIdx ] = [];

					}

					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

						var sho = newShapeHoles[ sIdx ];

						for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

							var ho = sho[ hIdx ];
							var hole_unassigned = true;

							for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

								if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

									if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
									if ( hole_unassigned ) {

										hole_unassigned = false;
										betterShapeHoles[ s2Idx ].push( ho );

									} else {

										ambiguous = true;

									}

								}

							}
							if ( hole_unassigned ) {

								betterShapeHoles[ sIdx ].push( ho );

							}

						}

					}
					// console.log("ambiguous: ", ambiguous);
					if ( toChange.length > 0 ) {

						// console.log("to change: ", toChange);
						if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

					}

				}

				var tmpHoles;

				for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

					tmpShape = newShapes[ i ].s;
					shapes.push( tmpShape );
					tmpHoles = newShapeHoles[ i ];

					for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

						tmpShape.holes.push( tmpHoles[ j ].h );

					}

				}

				//console.log("shape", shapes);

				return shapes;

			}

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Font( data ) {

			this.data = data;

		}

		Object.assign( Font.prototype, {

			isFont: true,

			generateShapes: function ( text, size, divisions ) {

				function createPaths( text ) {

					var chars = String( text ).split( '' );
					var scale = size / data.resolution;
					var offset = 0;

					var paths = [];

					for ( var i = 0; i < chars.length; i ++ ) {

						var ret = createPath( chars[ i ], scale, offset );
						offset += ret.offset;

						paths.push( ret.path );

					}

					return paths;

				}

				function createPath( c, scale, offset ) {

					var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

					if ( ! glyph ) return;

					var path = new ShapePath();

					var pts = [];
					var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

					if ( glyph.o ) {

						var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

						for ( var i = 0, l = outline.length; i < l; ) {

							var action = outline[ i ++ ];

							switch ( action ) {

								case 'm': // moveTo

									x = outline[ i ++ ] * scale + offset;
									y = outline[ i ++ ] * scale;

									path.moveTo( x, y );

									break;

								case 'l': // lineTo

									x = outline[ i ++ ] * scale + offset;
									y = outline[ i ++ ] * scale;

									path.lineTo( x, y );

									break;

								case 'q': // quadraticCurveTo

									cpx  = outline[ i ++ ] * scale + offset;
									cpy  = outline[ i ++ ] * scale;
									cpx1 = outline[ i ++ ] * scale + offset;
									cpy1 = outline[ i ++ ] * scale;

									path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

									laste = pts[ pts.length - 1 ];

									if ( laste ) {

										cpx0 = laste.x;
										cpy0 = laste.y;

										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

											var t = i2 / divisions;
											QuadraticBezier( t, cpx0, cpx1, cpx );
											QuadraticBezier( t, cpy0, cpy1, cpy );

										}

									}

									break;

								case 'b': // bezierCurveTo

									cpx  = outline[ i ++ ] * scale + offset;
									cpy  = outline[ i ++ ] * scale;
									cpx1 = outline[ i ++ ] * scale + offset;
									cpy1 = outline[ i ++ ] * scale;
									cpx2 = outline[ i ++ ] * scale + offset;
									cpy2 = outline[ i ++ ] * scale;

									path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

									laste = pts[ pts.length - 1 ];

									if ( laste ) {

										cpx0 = laste.x;
										cpy0 = laste.y;

										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

											var t = i2 / divisions;
											CubicBezier( t, cpx0, cpx1, cpx2, cpx );
											CubicBezier( t, cpy0, cpy1, cpy2, cpy );

										}

									}

									break;

							}

						}

					}

					return { offset: glyph.ha * scale, path: path };

				}

				//

				if ( size === undefined ) size = 100;
				if ( divisions === undefined ) divisions = 4;

				var data = this.data;

				var paths = createPaths( text );
				var shapes = [];

				for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

					Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

				}

				return shapes;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function FontLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( FontLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new FileLoader( this.manager );
				loader.load( url, function ( text ) {

					var json;

					try {

						json = JSON.parse( text );

					} catch ( e ) {

						console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
						json = JSON.parse( text.substring( 65, text.length - 2 ) );

					}

					var font = scope.parse( json );

					if ( onLoad ) onLoad( font );

				}, onProgress, onError );

			},

			parse: function ( json ) {

				return new Font( json );

			}

		} );

		var context;

		var AudioContext = {

			getContext: function () {

				if ( context === undefined ) {

					context = new ( window.AudioContext || window.webkitAudioContext )();

				}

				return context;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

		/**
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */

		function AudioLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( AudioLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
				loader.load( url, function ( buffer ) {

					var context = AudioContext.getContext();

					context.decodeAudioData( buffer, function ( audioBuffer ) {

						onLoad( audioBuffer );

					} );

				}, onProgress, onError );

			}

		} );

		/**
		 * @author abelnation / http://github.com/abelnation
		 */

		function RectAreaLight ( color, intensity, width, height ) {

			Light.call( this, color, intensity );

			this.type = 'RectAreaLight';

			this.position.set( 0, 1, 0 );
			this.updateMatrix();

			this.width = ( width !== undefined ) ? width : 10;
			this.height = ( height !== undefined ) ? height : 10;

			// TODO (abelnation): distance/decay

			// TODO (abelnation): update method for RectAreaLight to update transform to lookat target

			// TODO (abelnation): shadows
			// this.shadow = new THREE.RectAreaLightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );

		}

		// TODO (abelnation): RectAreaLight update when light shape is changed
		RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: RectAreaLight,

			isRectAreaLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.width = source.width;
				this.height = source.height;

				// this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function StereoCamera() {

			this.type = 'StereoCamera';

			this.aspect = 1;

			this.eyeSep = 0.064;

			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;

			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;

		}

		Object.assign( StereoCamera.prototype, {

			update: ( function () {

				var instance, focus, fov, aspect, near, far, zoom;

				var eyeRight = new Matrix4();
				var eyeLeft = new Matrix4();

				return function update( camera ) {

					var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
														aspect !== camera.aspect * this.aspect || near !== camera.near ||
														far !== camera.far || zoom !== camera.zoom;

					if ( needsUpdate ) {

						instance = this;
						focus = camera.focus;
						fov = camera.fov;
						aspect = camera.aspect * this.aspect;
						near = camera.near;
						far = camera.far;
						zoom = camera.zoom;

						// Off-axis stereoscopic effect based on
						// http://paulbourke.net/stereographics/stereorender/

						var projectionMatrix = camera.projectionMatrix.clone();
						var eyeSep = this.eyeSep / 2;
						var eyeSepOnProjection = eyeSep * near / focus;
						var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
						var xmin, xmax;

						// translate xOffset

						eyeLeft.elements[ 12 ] = - eyeSep;
						eyeRight.elements[ 12 ] = eyeSep;

						// for left eye

						xmin = - ymax * aspect + eyeSepOnProjection;
						xmax = ymax * aspect + eyeSepOnProjection;

						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

						this.cameraL.projectionMatrix.copy( projectionMatrix );

						// for right eye

						xmin = - ymax * aspect - eyeSepOnProjection;
						xmax = ymax * aspect - eyeSepOnProjection;

						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

						this.cameraR.projectionMatrix.copy( projectionMatrix );

					}

					this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
					this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

				};

			} )()

		} );

		/**
		 * Camera for rendering cube maps
		 *	- renders scene into axis-aligned cube
		 *
		 * @author alteredq / http://alteredqualia.com/
		 */

		function CubeCamera( near, far, cubeResolution ) {

			Object3D.call( this );

			this.type = 'CubeCamera';

			var fov = 90, aspect = 1;

			var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );

			var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );

			var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );

			var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );

			var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );

			var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );

			var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter, name: "cubeCamera" };

			this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

			this.updateCubeMap = function ( renderer, scene ) {

				if ( this.parent === null ) this.updateMatrixWorld();

				var renderTarget = this.renderTarget;
				var generateMipmaps = renderTarget.texture.generateMipmaps;

				renderTarget.texture.generateMipmaps = false;

				renderTarget.activeCubeFace = 0;
				renderer.render( scene, cameraPX, renderTarget );

				renderTarget.activeCubeFace = 1;
				renderer.render( scene, cameraNX, renderTarget );

				renderTarget.activeCubeFace = 2;
				renderer.render( scene, cameraPY, renderTarget );

				renderTarget.activeCubeFace = 3;
				renderer.render( scene, cameraNY, renderTarget );

				renderTarget.activeCubeFace = 4;
				renderer.render( scene, cameraPZ, renderTarget );

				renderTarget.texture.generateMipmaps = generateMipmaps;

				renderTarget.activeCubeFace = 5;
				renderer.render( scene, cameraNZ, renderTarget );

				renderer.setRenderTarget( null );

			};

		}

		CubeCamera.prototype = Object.create( Object3D.prototype );
		CubeCamera.prototype.constructor = CubeCamera;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AudioListener() {

			Object3D.call( this );

			this.type = 'AudioListener';

			this.context = AudioContext.getContext();

			this.gain = this.context.createGain();
			this.gain.connect( this.context.destination );

			this.filter = null;

		}

		AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: AudioListener,

			getInput: function () {

				return this.gain;

			},

			removeFilter: function ( ) {

				if ( this.filter !== null ) {

					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
					this.gain.connect( this.context.destination );
					this.filter = null;

				}

			},

			getFilter: function () {

				return this.filter;

			},

			setFilter: function ( value ) {

				if ( this.filter !== null ) {

					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );

				} else {

					this.gain.disconnect( this.context.destination );

				}

				this.filter = value;
				this.gain.connect( this.filter );
				this.filter.connect( this.context.destination );

			},

			getMasterVolume: function () {

				return this.gain.gain.value;

			},

			setMasterVolume: function ( value ) {

				this.gain.gain.value = value;

			},

			updateMatrixWorld: ( function () {

				var position = new Vector3();
				var quaternion = new Quaternion();
				var scale = new Vector3();

				var orientation = new Vector3();

				return function updateMatrixWorld( force ) {

					Object3D.prototype.updateMatrixWorld.call( this, force );

					var listener = this.context.listener;
					var up = this.up;

					this.matrixWorld.decompose( position, quaternion, scale );

					orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

					if ( listener.positionX ) {

						listener.positionX.setValueAtTime( position.x, this.context.currentTime );
						listener.positionY.setValueAtTime( position.y, this.context.currentTime );
						listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
						listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
						listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
						listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
						listener.upX.setValueAtTime( up.x, this.context.currentTime );
						listener.upY.setValueAtTime( up.y, this.context.currentTime );
						listener.upZ.setValueAtTime( up.z, this.context.currentTime );

					} else {

						listener.setPosition( position.x, position.y, position.z );
						listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

					}

				};

			} )()

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */

		function Audio( listener ) {

			Object3D.call( this );

			this.type = 'Audio';

			this.context = listener.context;

			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );

			this.autoplay = false;

			this.buffer = null;
			this.loop = false;
			this.startTime = 0;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.sourceType = 'empty';

			this.filters = [];

		}

		Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Audio,

			getOutput: function () {

				return this.gain;

			},

			setNodeSource: function ( audioNode ) {

				this.hasPlaybackControl = false;
				this.sourceType = 'audioNode';
				this.source = audioNode;
				this.connect();

				return this;

			},

			setBuffer: function ( audioBuffer ) {

				this.buffer = audioBuffer;
				this.sourceType = 'buffer';

				if ( this.autoplay ) this.play();

				return this;

			},

			play: function () {

				if ( this.isPlaying === true ) {

					console.warn( 'THREE.Audio: Audio is already playing.' );
					return;

				}

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				var source = this.context.createBufferSource();

				source.buffer = this.buffer;
				source.loop = this.loop;
				source.onended = this.onEnded.bind( this );
				source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
				source.start( 0, this.startTime );

				this.isPlaying = true;

				this.source = source;

				return this.connect();

			},

			pause: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.source.stop();
				this.startTime = this.context.currentTime;
				this.isPlaying = false;

				return this;

			},

			stop: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.source.stop();
				this.startTime = 0;
				this.isPlaying = false;

				return this;

			},

			connect: function () {

				if ( this.filters.length > 0 ) {

					this.source.connect( this.filters[ 0 ] );

					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

						this.filters[ i - 1 ].connect( this.filters[ i ] );

					}

					this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

				} else {

					this.source.connect( this.getOutput() );

				}

				return this;

			},

			disconnect: function () {

				if ( this.filters.length > 0 ) {

					this.source.disconnect( this.filters[ 0 ] );

					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

						this.filters[ i - 1 ].disconnect( this.filters[ i ] );

					}

					this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

				} else {

					this.source.disconnect( this.getOutput() );

				}

				return this;

			},

			getFilters: function () {

				return this.filters;

			},

			setFilters: function ( value ) {

				if ( ! value ) value = [];

				if ( this.isPlaying === true ) {

					this.disconnect();
					this.filters = value;
					this.connect();

				} else {

					this.filters = value;

				}

				return this;

			},

			getFilter: function () {

				return this.getFilters()[ 0 ];

			},

			setFilter: function ( filter ) {

				return this.setFilters( filter ? [ filter ] : [] );

			},

			setPlaybackRate: function ( value ) {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.playbackRate = value;

				if ( this.isPlaying === true ) {

					this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

				}

				return this;

			},

			getPlaybackRate: function () {

				return this.playbackRate;

			},

			onEnded: function () {

				this.isPlaying = false;

			},

			getLoop: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return false;

				}

				return this.loop;

			},

			setLoop: function ( value ) {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.loop = value;

				if ( this.isPlaying === true ) {

					this.source.loop = this.loop;

				}

				return this;

			},

			getVolume: function () {

				return this.gain.gain.value;

			},


			setVolume: function ( value ) {

				this.gain.gain.value = value;

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function PositionalAudio( listener ) {

			Audio.call( this, listener );

			this.panner = this.context.createPanner();
			this.panner.connect( this.gain );

		}

		PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

			constructor: PositionalAudio,

			getOutput: function () {

				return this.panner;

			},

			getRefDistance: function () {

				return this.panner.refDistance;

			},

			setRefDistance: function ( value ) {

				this.panner.refDistance = value;

			},

			getRolloffFactor: function () {

				return this.panner.rolloffFactor;

			},

			setRolloffFactor: function ( value ) {

				this.panner.rolloffFactor = value;

			},

			getDistanceModel: function () {

				return this.panner.distanceModel;

			},

			setDistanceModel: function ( value ) {

				this.panner.distanceModel = value;

			},

			getMaxDistance: function () {

				return this.panner.maxDistance;

			},

			setMaxDistance: function ( value ) {

				this.panner.maxDistance = value;

			},

			updateMatrixWorld: ( function () {

				var position = new Vector3();

				return function updateMatrixWorld( force ) {

					Object3D.prototype.updateMatrixWorld.call( this, force );

					position.setFromMatrixPosition( this.matrixWorld );

					this.panner.setPosition( position.x, position.y, position.z );

				};

			} )()


		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AudioAnalyser( audio, fftSize ) {

			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

			this.data = new Uint8Array( this.analyser.frequencyBinCount );

			audio.getOutput().connect( this.analyser );

		}

		Object.assign( AudioAnalyser.prototype, {

			getFrequencyData: function () {

				this.analyser.getByteFrequencyData( this.data );

				return this.data;

			},

			getAverageFrequency: function () {

				var value = 0, data = this.getFrequencyData();

				for ( var i = 0; i < data.length; i ++ ) {

					value += data[ i ];

				}

				return value / data.length;

			}

		} );

		/**
		 *
		 * Buffered scene graph property that allows weighted accumulation.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function PropertyMixer( binding, typeName, valueSize ) {

			this.binding = binding;
			this.valueSize = valueSize;

			var bufferType = Float64Array,
				mixFunction;

			switch ( typeName ) {

				case 'quaternion':
					mixFunction = this._slerp;
					break;

				case 'string':
				case 'bool':
					bufferType = Array;
					mixFunction = this._select;
					break;

				default:
					mixFunction = this._lerp;

			}

			this.buffer = new bufferType( valueSize * 4 );
			// layout: [ incoming | accu0 | accu1 | orig ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property

			this._mixBufferRegion = mixFunction;

			this.cumulativeWeight = 0;

			this.useCount = 0;
			this.referenceCount = 0;

		}

		PropertyMixer.prototype = {

			constructor: PropertyMixer,

			// accumulate data in the 'incoming' region into 'accu<i>'
			accumulate: function( accuIndex, weight ) {

				// note: happily accumulating nothing when weight = 0, the caller knows
				// the weight and shouldn't have made the call in the first place

				var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride,

					currentWeight = this.cumulativeWeight;

				if ( currentWeight === 0 ) {

					// accuN := incoming * weight

					for ( var i = 0; i !== stride; ++ i ) {

						buffer[ offset + i ] = buffer[ i ];

					}

					currentWeight = weight;

				} else {

					// accuN := accuN + incoming * weight

					currentWeight += weight;
					var mix = weight / currentWeight;
					this._mixBufferRegion( buffer, offset, 0, mix, stride );

				}

				this.cumulativeWeight = currentWeight;

			},

			// apply the state of 'accu<i>' to the binding when accus differ
			apply: function( accuIndex ) {

				var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,

					weight = this.cumulativeWeight,

					binding = this.binding;

				this.cumulativeWeight = 0;

				if ( weight < 1 ) {

					// accuN := accuN + original * ( 1 - cumulativeWeight )

					var originalValueOffset = stride * 3;

					this._mixBufferRegion(
							buffer, offset, originalValueOffset, 1 - weight, stride );

				}

				for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

					if ( buffer[ i ] !== buffer[ i + stride ] ) {

						// value has changed -> update scene graph

						binding.setValue( buffer, offset );
						break;

					}

				}

			},

			// remember the state of the bound property and copy it to both accus
			saveOriginalState: function() {

				var binding = this.binding;

				var buffer = this.buffer,
					stride = this.valueSize,

					originalValueOffset = stride * 3;

				binding.getValue( buffer, originalValueOffset );

				// accu[0..1] := orig -- initially detect changes against the original
				for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

					buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

				}

				this.cumulativeWeight = 0;

			},

			// apply the state previously taken via 'saveOriginalState' to the binding
			restoreOriginalState: function() {

				var originalValueOffset = this.valueSize * 3;
				this.binding.setValue( this.buffer, originalValueOffset );

			},


			// mix functions

			_select: function( buffer, dstOffset, srcOffset, t, stride ) {

				if ( t >= 0.5 ) {

					for ( var i = 0; i !== stride; ++ i ) {

						buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

					}

				}

			},

			_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

				Quaternion.slerpFlat( buffer, dstOffset,
						buffer, dstOffset, buffer, srcOffset, t );

			},

			_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

				var s = 1 - t;

				for ( var i = 0; i !== stride; ++ i ) {

					var j = dstOffset + i;

					buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

				}

			}

		};

		/**
		 *
		 * A reference to a real property in the scene graph.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function PropertyBinding( rootNode, path, parsedPath ) {

			this.path = path;
			this.parsedPath = parsedPath ||
					PropertyBinding.parseTrackName( path );

			this.node = PropertyBinding.findNode(
					rootNode, this.parsedPath.nodeName ) || rootNode;

			this.rootNode = rootNode;

		}

		PropertyBinding.prototype = {

			constructor: PropertyBinding,

			getValue: function getValue_unbound( targetArray, offset ) {

				this.bind();
				this.getValue( targetArray, offset );

				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.

			},

			setValue: function getValue_unbound( sourceArray, offset ) {

				this.bind();
				this.setValue( sourceArray, offset );

			},

			// create getter / setter pair for a property in the scene graph
			bind: function() {

				var targetObject = this.node,
					parsedPath = this.parsedPath,

					objectName = parsedPath.objectName,
					propertyName = parsedPath.propertyName,
					propertyIndex = parsedPath.propertyIndex;

				if ( ! targetObject ) {

					targetObject = PropertyBinding.findNode(
							this.rootNode, parsedPath.nodeName ) || this.rootNode;

					this.node = targetObject;

				}

				// set fail state so we can just 'return' on error
				this.getValue = this._getValue_unavailable;
				this.setValue = this._setValue_unavailable;

		 		// ensure there is a value node
				if ( ! targetObject ) {

					console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
					return;

				}

				if ( objectName ) {

					var objectIndex = parsedPath.objectIndex;

					// special cases were we need to reach deeper into the hierarchy to get the face materials....
					switch ( objectName ) {

						case 'materials':

							if ( ! targetObject.material ) {

								console.error( '  can not bind to material as node does not have a material', this );
								return;

							}

							if ( ! targetObject.material.materials ) {

								console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
								return;

							}

							targetObject = targetObject.material.materials;

							break;

						case 'bones':

							if ( ! targetObject.skeleton ) {

								console.error( '  can not bind to bones as node does not have a skeleton', this );
								return;

							}

							// potential future optimization: skip this if propertyIndex is already an integer
							// and convert the integer string to a true integer.

							targetObject = targetObject.skeleton.bones;

							// support resolving morphTarget names into indices.
							for ( var i = 0; i < targetObject.length; i ++ ) {

								if ( targetObject[ i ].name === objectIndex ) {

									objectIndex = i;
									break;

								}

							}

							break;

						default:

							if ( targetObject[ objectName ] === undefined ) {

								console.error( '  can not bind to objectName of node, undefined', this );
								return;

							}

							targetObject = targetObject[ objectName ];

					}


					if ( objectIndex !== undefined ) {

						if ( targetObject[ objectIndex ] === undefined ) {

							console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
							return;

						}

						targetObject = targetObject[ objectIndex ];

					}

				}

				// resolve property
				var nodeProperty = targetObject[ propertyName ];

				if ( nodeProperty === undefined ) {

					var nodeName = parsedPath.nodeName;

					console.error( "  trying to update property for track: " + nodeName +
							'.' + propertyName + " but it wasn't found.", targetObject );
					return;

				}

				// determine versioning scheme
				var versioning = this.Versioning.None;

				if ( targetObject.needsUpdate !== undefined ) { // material

					versioning = this.Versioning.NeedsUpdate;
					this.targetObject = targetObject;

				} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

					versioning = this.Versioning.MatrixWorldNeedsUpdate;
					this.targetObject = targetObject;

				}

				// determine how the property gets bound
				var bindingType = this.BindingType.Direct;

				if ( propertyIndex !== undefined ) {
					// access a sub element of the property array (only primitives are supported right now)

					if ( propertyName === "morphTargetInfluences" ) {
						// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

						// support resolving morphTarget names into indices.
						if ( ! targetObject.geometry ) {

							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
							return;

						}

						if ( ! targetObject.geometry.morphTargets ) {

							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}

					}

					bindingType = this.BindingType.ArrayElement;

					this.resolvedProperty = nodeProperty;
					this.propertyIndex = propertyIndex;

				} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
					// must use copy for Object3D.Euler/Quaternion

					bindingType = this.BindingType.HasFromToArray;

					this.resolvedProperty = nodeProperty;

				} else if ( nodeProperty.length !== undefined ) {

					bindingType = this.BindingType.EntireArray;

					this.resolvedProperty = nodeProperty;

				} else {

					this.propertyName = propertyName;

				}

				// select getter / setter
				this.getValue = this.GetterByBindingType[ bindingType ];
				this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

			},

			unbind: function() {

				this.node = null;

				// back to the prototype version of getValue / setValue
				// note: avoiding to mutate the shape of 'this' via 'delete'
				this.getValue = this._getValue_unbound;
				this.setValue = this._setValue_unbound;

			}

		};

		Object.assign( PropertyBinding.prototype, { // prototype, continued

			// these are used to "bind" a nonexistent property
			_getValue_unavailable: function() {},
			_setValue_unavailable: function() {},

			// initial state of these methods that calls 'bind'
			_getValue_unbound: PropertyBinding.prototype.getValue,
			_setValue_unbound: PropertyBinding.prototype.setValue,

			BindingType: {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			},

			Versioning: {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			},

			GetterByBindingType: [

				function getValue_direct( buffer, offset ) {

					buffer[ offset ] = this.node[ this.propertyName ];

				},

				function getValue_array( buffer, offset ) {

					var source = this.resolvedProperty;

					for ( var i = 0, n = source.length; i !== n; ++ i ) {

						buffer[ offset ++ ] = source[ i ];

					}

				},

				function getValue_arrayElement( buffer, offset ) {

					buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

				},

				function getValue_toArray( buffer, offset ) {

					this.resolvedProperty.toArray( buffer, offset );

				}

			],

			SetterByBindingTypeAndVersioning: [

				[
					// Direct

					function setValue_direct( buffer, offset ) {

						this.node[ this.propertyName ] = buffer[ offset ];

					},

					function setValue_direct_setNeedsUpdate( buffer, offset ) {

						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;

					},

					function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// EntireArray

					function setValue_array( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

					},

					function setValue_array_setNeedsUpdate( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

						this.targetObject.needsUpdate = true;

					},

					function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// ArrayElement

					function setValue_arrayElement( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

					},

					function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;

					},

					function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// HasToFromArray

					function setValue_fromArray( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );

					},

					function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.needsUpdate = true;

					},

					function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				]

			]

		} );

		PropertyBinding.Composite =
				function( targetGroup, path, optionalParsedPath ) {

			var parsedPath = optionalParsedPath ||
					PropertyBinding.parseTrackName( path );

			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );

		};

		PropertyBinding.Composite.prototype = {

			constructor: PropertyBinding.Composite,

			getValue: function( array, offset ) {

				this.bind(); // bind all binding

				var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[ firstValidIndex ];

				// and only call .getValue on the first
				if ( binding !== undefined ) binding.getValue( array, offset );

			},

			setValue: function( array, offset ) {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].setValue( array, offset );

				}

			},

			bind: function() {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].bind();

				}

			},

			unbind: function() {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].unbind();

				}

			}

		};

		PropertyBinding.create = function( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		};

		PropertyBinding.parseTrackName = function( trackName ) {

			// matches strings in the form of:
			//    nodeName.property
			//    nodeName.property[accessor]
			//    nodeName.material.property[accessor]
			//    uuid.property[accessor]
			//    uuid.objectName[objectIndex].propertyName[propertyIndex]
			//    parentName/nodeName.property
			//    parentName/parentName/nodeName.property[index]
			//    .bone[Armature.DEF_cog].position
			//    scene:helium_balloon_model:helium_balloon_model.position
			// created and tested via https://regex101.com/#javascript

			var re = /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/;
			var matches = re.exec( trackName );

			if ( ! matches ) {

				throw new Error( "cannot parse trackName at all: " + trackName );

			}

			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ],
				propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
			};

			if ( results.propertyName === null || results.propertyName.length === 0 ) {

				throw new Error( "can not parse propertyName from trackName: " + trackName );

			}

			return results;

		};

		PropertyBinding.findNode = function( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var searchSkeleton = function( skeleton ) {

					for( var i = 0; i < skeleton.bones.length; i ++ ) {

						var bone = skeleton.bones[ i ];

						if ( bone.name === nodeName ) {

							return bone;

						}
					}

					return null;

				};

				var bone = searchSkeleton( root.skeleton );

				if ( bone ) {

					return bone;

				}
			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function( children ) {

					for( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		};

		/**
		 *
		 * A group of objects that receives a shared animation state.
		 *
		 * Usage:
		 *
		 * 	-	Add objects you would otherwise pass as 'root' to the
		 * 		constructor or the .clipAction method of AnimationMixer.
		 *
		 * 	-	Instead pass this object as 'root'.
		 *
		 * 	-	You can also add and remove objects later when the mixer
		 * 		is running.
		 *
		 * Note:
		 *
		 *  	Objects of this class appear as one object to the mixer,
		 *  	so cache control of the individual objects must be done
		 *  	on the group.
		 *
		 * Limitation:
		 *
		 * 	- 	The animated properties must be compatible among the
		 * 		all objects in the group.
		 *
		 *  -	A single property can either be controlled through a
		 *  	target group or directly, but not both.
		 *
		 * @author tschw
		 */

		function AnimationObjectGroup( var_args ) {

			this.uuid = _Math.generateUUID();

			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );

			this.nCachedObjects_ = 0;			// threshold
			// note: read by PropertyBinding.Composite

			var indices = {};
			this._indicesByUUID = indices;		// for bookkeeping

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				indices[ arguments[ i ].uuid ] = i;

			}

			this._paths = [];					// inside: string
			this._parsedPaths = [];				// inside: { we don't care, here }
			this._bindings = []; 				// inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

			var scope = this;

			this.stats = {

				objects: {
					get total() { return scope._objects.length; },
					get inUse() { return this.total - scope.nCachedObjects_;  }
				},

				get bindingsPerObject() { return scope._bindings.length; }

			};

		}

		AnimationObjectGroup.prototype = {

			constructor: AnimationObjectGroup,

			isAnimationObjectGroup: true,

			add: function( var_args ) {

				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ],
						knownObject = undefined;

					if ( index === undefined ) {

						// unknown object -> add it to the ACTIVE region

						index = nObjects ++;
						indicesByUUID[ uuid ] = index;
						objects.push( object );

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							bindings[ j ].push(
									new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] ) );

						}

					} else if ( index < nCachedObjects ) {

						knownObject = objects[ index ];

						// move existing object to the ACTIVE region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ];

						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						indicesByUUID[ uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = object;

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								binding = bindingsForPath[ index ];

							bindingsForPath[ index ] = lastCached;

							if ( binding === undefined ) {

								// since we do not bother to create new bindings
								// for objects that are cached, the binding may
								// or may not exist

								binding = new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] );

							}

							bindingsForPath[ firstActiveIndex ] = binding;

						}

					} else if ( objects[ index ] !== knownObject) {

						console.error( "Different objects with the same UUID " +
								"detected. Clean the caches or recreate your " +
								"infrastructure when reloading scenes..." );

					} // else the object is already where we want it to be

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			remove: function( var_args ) {

				var objects = this._objects,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index !== undefined && index >= nCachedObjects ) {

						// move existing object into the CACHED region

						var lastCachedIndex = nCachedObjects ++,
							firstActiveObject = objects[ lastCachedIndex ];

						indicesByUUID[ firstActiveObject.uuid ] = index;
						objects[ index ] = firstActiveObject;

						indicesByUUID[ uuid ] = lastCachedIndex;
						objects[ lastCachedIndex ] = object;

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								firstActive = bindingsForPath[ lastCachedIndex ],
								binding = bindingsForPath[ index ];

							bindingsForPath[ index ] = firstActive;
							bindingsForPath[ lastCachedIndex ] = binding;

						}

					}

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			// remove & forget
			uncache: function( var_args ) {

				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index !== undefined ) {

						delete indicesByUUID[ uuid ];

						if ( index < nCachedObjects ) {

							// object is cached, shrink the CACHED region

							var firstActiveIndex = -- nCachedObjects,
								lastCachedObject = objects[ firstActiveIndex ],
								lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];

							// last cached object takes this object's place
							indicesByUUID[ lastCachedObject.uuid ] = index;
							objects[ index ] = lastCachedObject;

							// last object goes to the activated slot and pop
							indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
							objects[ firstActiveIndex ] = lastObject;
							objects.pop();

							// accounting is done, now do the same for all bindings

							for ( var j = 0, m = nBindings; j !== m; ++ j ) {

								var bindingsForPath = bindings[ j ],
									lastCached = bindingsForPath[ firstActiveIndex ],
									last = bindingsForPath[ lastIndex ];

								bindingsForPath[ index ] = lastCached;
								bindingsForPath[ firstActiveIndex ] = last;
								bindingsForPath.pop();

							}

						} else {

							// object is active, just swap with the last and pop

							var lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];

							indicesByUUID[ lastObject.uuid ] = index;
							objects[ index ] = lastObject;
							objects.pop();

							// accounting is done, now do the same for all bindings

							for ( var j = 0, m = nBindings; j !== m; ++ j ) {

								var bindingsForPath = bindings[ j ];

								bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
								bindingsForPath.pop();

							}

						} // cached or active

					} // if object is known

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			// Internal interface used by befriended PropertyBinding.Composite:

			subscribe_: function( path, parsedPath ) {
				// returns an array of bindings for the given path that is changed
				// according to the contained objects in the group

				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ],
					bindings = this._bindings;

				if ( index !== undefined ) return bindings[ index ];

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array( nObjects );

				index = bindings.length;

				indicesByPath[ path ] = index;

				paths.push( path );
				parsedPaths.push( parsedPath );
				bindings.push( bindingsForPath );

				for ( var i = nCachedObjects,
						n = objects.length; i !== n; ++ i ) {

					var object = objects[ i ];

					bindingsForPath[ i ] =
							new PropertyBinding( object, path, parsedPath );

				}

				return bindingsForPath;

			},

			unsubscribe_: function( path ) {
				// tells the group to forget about a property path and no longer
				// update the array previously obtained with 'subscribe_'

				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ];

				if ( index !== undefined ) {

					var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[ lastBindingsIndex ],
						lastBindingsPath = path[ lastBindingsIndex ];

					indicesByPath[ lastBindingsPath ] = index;

					bindings[ index ] = lastBindings;
					bindings.pop();

					parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
					parsedPaths.pop();

					paths[ index ] = paths[ lastBindingsIndex ];
					paths.pop();

				}

			}

		};

		/**
		 *
		 * Action provided by AnimationMixer for scheduling clip playback on specific
		 * objects.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 *
		 */

		function AnimationAction( mixer, clip, localRoot ) {

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot || null;

			var tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );

			var interpolantSettings = {
					endingStart: 	ZeroCurvatureEnding,
					endingEnd:		ZeroCurvatureEnding
			};

			for ( var i = 0; i !== nTracks; ++ i ) {

				var interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;

			}

			this._interpolantSettings = interpolantSettings;

			this._interpolants = interpolants;	// bound by the mixer

			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );

			this._cacheIndex = null;			// for the memory manager
			this._byClipCacheIndex = null;		// for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;

			this.loop = LoopRepeat;
			this._loopCount = -1;

			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;

			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;

			this.timeScale = 1;
			this._effectiveTimeScale = 1;

			this.weight = 1;
			this._effectiveWeight = 1;

			this.repetitions = Infinity; 		// no. of repetitions when looping

			this.paused = false;				// false -> zero effective time scale
			this.enabled = true;				// true -> zero effective weight

			this.clampWhenFinished 	= false;	// keep feeding the last frame?

			this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

		}

		AnimationAction.prototype = {

			constructor: AnimationAction,

			// State & Scheduling

			play: function() {

				this._mixer._activateAction( this );

				return this;

			},

			stop: function() {

				this._mixer._deactivateAction( this );

				return this.reset();

			},

			reset: function() {

				this.paused = false;
				this.enabled = true;

				this.time = 0;			// restart clip
				this._loopCount = -1;	// forget previous loops
				this._startTime = null;	// forget scheduling

				return this.stopFading().stopWarping();

			},

			isRunning: function() {

				return this.enabled && ! this.paused && this.timeScale !== 0 &&
						this._startTime === null && this._mixer._isActiveAction( this );

			},

			// return true when play has been called
			isScheduled: function() {

				return this._mixer._isActiveAction( this );

			},

			startAt: function( time ) {

				this._startTime = time;

				return this;

			},

			setLoop: function( mode, repetitions ) {

				this.loop = mode;
				this.repetitions = repetitions;

				return this;

			},

			// Weight

			// set the weight stopping any scheduled fading
			// although .enabled = false yields an effective weight of zero, this
			// method does *not* change .enabled, because it would be confusing
			setEffectiveWeight: function( weight ) {

				this.weight = weight;

				// note: same logic as when updated at runtime
				this._effectiveWeight = this.enabled ? weight : 0;

				return this.stopFading();

			},

			// return the weight considering fading and .enabled
			getEffectiveWeight: function() {

				return this._effectiveWeight;

			},

			fadeIn: function( duration ) {

				return this._scheduleFading( duration, 0, 1 );

			},

			fadeOut: function( duration ) {

				return this._scheduleFading( duration, 1, 0 );

			},

			crossFadeFrom: function( fadeOutAction, duration, warp ) {

				fadeOutAction.fadeOut( duration );
				this.fadeIn( duration );

				if( warp ) {

					var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,

						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;

					fadeOutAction.warp( 1.0, startEndRatio, duration );
					this.warp( endStartRatio, 1.0, duration );

				}

				return this;

			},

			crossFadeTo: function( fadeInAction, duration, warp ) {

				return fadeInAction.crossFadeFrom( this, duration, warp );

			},

			stopFading: function() {

				var weightInterpolant = this._weightInterpolant;

				if ( weightInterpolant !== null ) {

					this._weightInterpolant = null;
					this._mixer._takeBackControlInterpolant( weightInterpolant );

				}

				return this;

			},

			// Time Scale Control

			// set the weight stopping any scheduled warping
			// although .paused = true yields an effective time scale of zero, this
			// method does *not* change .paused, because it would be confusing
			setEffectiveTimeScale: function( timeScale ) {

				this.timeScale = timeScale;
				this._effectiveTimeScale = this.paused ? 0 :timeScale;

				return this.stopWarping();

			},

			// return the time scale considering warping and .paused
			getEffectiveTimeScale: function() {

				return this._effectiveTimeScale;

			},

			setDuration: function( duration ) {

				this.timeScale = this._clip.duration / duration;

				return this.stopWarping();

			},

			syncWith: function( action ) {

				this.time = action.time;
				this.timeScale = action.timeScale;

				return this.stopWarping();

			},

			halt: function( duration ) {

				return this.warp( this._effectiveTimeScale, 0, duration );

			},

			warp: function( startTimeScale, endTimeScale, duration ) {

				var mixer = this._mixer, now = mixer.time,
					interpolant = this._timeScaleInterpolant,

					timeScale = this.timeScale;

				if ( interpolant === null ) {

					interpolant = mixer._lendControlInterpolant();
					this._timeScaleInterpolant = interpolant;

				}

				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;

				times[ 0 ] = now;
				times[ 1 ] = now + duration;

				values[ 0 ] = startTimeScale / timeScale;
				values[ 1 ] = endTimeScale / timeScale;

				return this;

			},

			stopWarping: function() {

				var timeScaleInterpolant = this._timeScaleInterpolant;

				if ( timeScaleInterpolant !== null ) {

					this._timeScaleInterpolant = null;
					this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

				}

				return this;

			},

			// Object Accessors

			getMixer: function() {

				return this._mixer;

			},

			getClip: function() {

				return this._clip;

			},

			getRoot: function() {

				return this._localRoot || this._mixer._root;

			},

			// Interna

			_update: function( time, deltaTime, timeDirection, accuIndex ) {
				// called by the mixer

				var startTime = this._startTime;

				if ( startTime !== null ) {

					// check for scheduled start of action

					var timeRunning = ( time - startTime ) * timeDirection;
					if ( timeRunning < 0 || timeDirection === 0 ) {

						return; // yet to come / don't decide when delta = 0

					}

					// start

					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;

				}

				// apply time scale and advance time

				deltaTime *= this._updateTimeScale( time );
				var clipTime = this._updateTime( deltaTime );

				// note: _updateTime may disable the action resulting in
				// an effective weight of 0

				var weight = this._updateWeight( time );

				if ( weight > 0 ) {

					var interpolants = this._interpolants;
					var propertyMixers = this._propertyBindings;

					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

				}

			},

			_updateWeight: function( time ) {

				var weight = 0;

				if ( this.enabled ) {

					weight = this.weight;
					var interpolant = this._weightInterpolant;

					if ( interpolant !== null ) {

						var interpolantValue = interpolant.evaluate( time )[ 0 ];

						weight *= interpolantValue;

						if ( time > interpolant.parameterPositions[ 1 ] ) {

							this.stopFading();

							if ( interpolantValue === 0 ) {

								// faded out, disable
								this.enabled = false;

							}

						}

					}

				}

				this._effectiveWeight = weight;
				return weight;

			},

			_updateTimeScale: function( time ) {

				var timeScale = 0;

				if ( ! this.paused ) {

					timeScale = this.timeScale;

					var interpolant = this._timeScaleInterpolant;

					if ( interpolant !== null ) {

						var interpolantValue = interpolant.evaluate( time )[ 0 ];

						timeScale *= interpolantValue;

						if ( time > interpolant.parameterPositions[ 1 ] ) {

							this.stopWarping();

							if ( timeScale === 0 ) {

								// motion has halted, pause
								this.paused = true;

							} else {

								// warp done - apply final time scale
								this.timeScale = timeScale;

							}

						}

					}

				}

				this._effectiveTimeScale = timeScale;
				return timeScale;

			},

			_updateTime: function( deltaTime ) {

				var time = this.time + deltaTime;

				if ( deltaTime === 0 ) return time;

				var duration = this._clip.duration,

					loop = this.loop,
					loopCount = this._loopCount;

				if ( loop === LoopOnce ) {

					if ( loopCount === -1 ) {
						// just started

						this._loopCount = 0;
						this._setEndings( true, true, false );

					}

					handle_stop: {

						if ( time >= duration ) {

							time = duration;

						} else if ( time < 0 ) {

							time = 0;

						} else break handle_stop;

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime < 0 ? -1 : 1
						} );

					}

				} else { // repetitive Repeat or PingPong

					var pingPong = ( loop === LoopPingPong );

					if ( loopCount === -1 ) {
						// just started

						if ( deltaTime >= 0 ) {

							loopCount = 0;

							this._setEndings(
									true, this.repetitions === 0, pingPong );

						} else {

							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1

							this._setEndings(
									this.repetitions === 0, true, pingPong );

						}

					}

					if ( time >= duration || time < 0 ) {
						// wrap around

						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;

						loopCount += Math.abs( loopDelta );

						var pending = this.repetitions - loopCount;

						if ( pending < 0 ) {
							// have to stop (switch state, clamp time, fire event)

							if ( this.clampWhenFinished ) this.paused = true;
							else this.enabled = false;

							time = deltaTime > 0 ? duration : 0;

							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : -1
							} );

						} else {
							// keep running

							if ( pending === 0 ) {
								// entering the last round

								var atStart = deltaTime < 0;
								this._setEndings( atStart, ! atStart, pingPong );

							} else {

								this._setEndings( false, false, pingPong );

							}

							this._loopCount = loopCount;

							this._mixer.dispatchEvent( {
								type: 'loop', action: this, loopDelta: loopDelta
							} );

						}

					}

					if ( pingPong && ( loopCount & 1 ) === 1 ) {
						// invert time for the "pong round"

						this.time = time;
						return duration - time;

					}

				}

				this.time = time;
				return time;

			},

			_setEndings: function( atStart, atEnd, pingPong ) {

				var settings = this._interpolantSettings;

				if ( pingPong ) {

					settings.endingStart 	= ZeroSlopeEnding;
					settings.endingEnd		= ZeroSlopeEnding;

				} else {

					// assuming for LoopOnce atStart == atEnd == true

					if ( atStart ) {

						settings.endingStart = this.zeroSlopeAtStart ?
								ZeroSlopeEnding : ZeroCurvatureEnding;

					} else {

						settings.endingStart = WrapAroundEnding;

					}

					if ( atEnd ) {

						settings.endingEnd = this.zeroSlopeAtEnd ?
								ZeroSlopeEnding : ZeroCurvatureEnding;

					} else {

						settings.endingEnd 	 = WrapAroundEnding;

					}

				}

			},

			_scheduleFading: function( duration, weightNow, weightThen ) {

				var mixer = this._mixer, now = mixer.time,
					interpolant = this._weightInterpolant;

				if ( interpolant === null ) {

					interpolant = mixer._lendControlInterpolant();
					this._weightInterpolant = interpolant;

				}

				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;

				times[ 0 ] = now; 				values[ 0 ] = weightNow;
				times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

				return this;

			}

		};

		/**
		 *
		 * Player for AnimationClips.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function AnimationMixer( root ) {

			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;

			this.time = 0;

			this.timeScale = 1.0;

		}

		AnimationMixer.prototype = {

			constructor: AnimationMixer,

			// return an action for a clip optionally using a custom root target
			// object (this method allocates a lot of dynamic memory in case a
			// previously unknown clip/root combination is specified)
			clipAction: function ( clip, optionalRoot ) {

				var root = optionalRoot || this._root,
					rootUuid = root.uuid,

					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,

					clipUuid = clipObject !== null ? clipObject.uuid : clip,

					actionsForClip = this._actionsByClip[ clipUuid ],
					prototypeAction = null;

				if ( actionsForClip !== undefined ) {

					var existingAction =
							actionsForClip.actionByRoot[ rootUuid ];

					if ( existingAction !== undefined ) {

						return existingAction;

					}

					// we know the clip, so we don't have to parse all
					// the bindings again but can just copy
					prototypeAction = actionsForClip.knownActions[ 0 ];

					// also, take the clip from the prototype action
					if ( clipObject === null )
						clipObject = prototypeAction._clip;

				}

				// clip must be known when specified via string
				if ( clipObject === null ) return null;

				// allocate all resources required to run it
				var newAction = new AnimationAction( this, clipObject, optionalRoot );

				this._bindAction( newAction, prototypeAction );

				// and make the action known to the memory manager
				this._addInactiveAction( newAction, clipUuid, rootUuid );

				return newAction;

			},

			// get an existing action
			existingAction: function ( clip, optionalRoot ) {

				var root = optionalRoot || this._root,
					rootUuid = root.uuid,

					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,

					clipUuid = clipObject ? clipObject.uuid : clip,

					actionsForClip = this._actionsByClip[ clipUuid ];

				if ( actionsForClip !== undefined ) {

					return actionsForClip.actionByRoot[ rootUuid ] || null;

				}

				return null;

			},

			// deactivates all previously scheduled actions
			stopAllAction: function () {

				var actions = this._actions,
					nActions = this._nActiveActions,
					bindings = this._bindings,
					nBindings = this._nActiveBindings;

				this._nActiveActions = 0;
				this._nActiveBindings = 0;

				for ( var i = 0; i !== nActions; ++ i ) {

					actions[ i ].reset();

				}

				for ( var i = 0; i !== nBindings; ++ i ) {

					bindings[ i ].useCount = 0;

				}

				return this;

			},

			// advance the time and update apply the animation
			update: function ( deltaTime ) {

				deltaTime *= this.timeScale;

				var actions = this._actions,
					nActions = this._nActiveActions,

					time = this.time += deltaTime,
					timeDirection = Math.sign( deltaTime ),

					accuIndex = this._accuIndex ^= 1;

				// run active actions

				for ( var i = 0; i !== nActions; ++ i ) {

					var action = actions[ i ];

					if ( action.enabled ) {

						action._update( time, deltaTime, timeDirection, accuIndex );

					}

				}

				// update scene graph

				var bindings = this._bindings,
					nBindings = this._nActiveBindings;

				for ( var i = 0; i !== nBindings; ++ i ) {

					bindings[ i ].apply( accuIndex );

				}

				return this;

			},

			// return this mixer's root target object
			getRoot: function () {

				return this._root;

			},

			// free all resources specific to a particular clip
			uncacheClip: function ( clip ) {

				var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];

				if ( actionsForClip !== undefined ) {

					// note: just calling _removeInactiveAction would mess up the
					// iteration state and also require updating the state we can
					// just throw away

					var actionsToRemove = actionsForClip.knownActions;

					for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

						var action = actionsToRemove[ i ];

						this._deactivateAction( action );

						var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[ actions.length - 1 ];

						action._cacheIndex = null;
						action._byClipCacheIndex = null;

						lastInactiveAction._cacheIndex = cacheIndex;
						actions[ cacheIndex ] = lastInactiveAction;
						actions.pop();

						this._removeInactiveBindingsForAction( action );

					}

					delete actionsByClip[ clipUuid ];

				}

			},

			// free all resources specific to a particular root target object
			uncacheRoot: function ( root ) {

				var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;

				for ( var clipUuid in actionsByClip ) {

					var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
						action = actionByRoot[ rootUuid ];

					if ( action !== undefined ) {

						this._deactivateAction( action );
						this._removeInactiveAction( action );

					}

				}

				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ];

				if ( bindingByName !== undefined ) {

					for ( var trackName in bindingByName ) {

						var binding = bindingByName[ trackName ];
						binding.restoreOriginalState();
						this._removeInactiveBinding( binding );

					}

				}

			},

			// remove a targeted clip from the cache
			uncacheAction: function ( clip, optionalRoot ) {

				var action = this.existingAction( clip, optionalRoot );

				if ( action !== null ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

		};

		// Implementation details:

		Object.assign( AnimationMixer.prototype, {

			_bindAction: function ( action, prototypeAction ) {

				var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingsByName = bindingsByRoot[ rootUuid ];

				if ( bindingsByName === undefined ) {

					bindingsByName = {};
					bindingsByRoot[ rootUuid ] = bindingsByName;

				}

				for ( var i = 0; i !== nTracks; ++ i ) {

					var track = tracks[ i ],
						trackName = track.name,
						binding = bindingsByName[ trackName ];

					if ( binding !== undefined ) {

						bindings[ i ] = binding;

					} else {

						binding = bindings[ i ];

						if ( binding !== undefined ) {

							// existing binding, make sure the cache knows

							if ( binding._cacheIndex === null ) {

								++ binding.referenceCount;
								this._addInactiveBinding( binding, rootUuid, trackName );

							}

							continue;

						}

						var path = prototypeAction && prototypeAction.
								_propertyBindings[ i ].binding.parsedPath;

						binding = new PropertyMixer(
								PropertyBinding.create( root, trackName, path ),
								track.ValueTypeName, track.getValueSize() );

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

						bindings[ i ] = binding;

					}

					interpolants[ i ].resultBuffer = binding.buffer;

				}

			},

			_activateAction: function ( action ) {

				if ( ! this._isActiveAction( action ) ) {

					if ( action._cacheIndex === null ) {

						// this action has been forgotten by the cache, but the user
						// appears to be still using it -> rebind

						var rootUuid = ( action._localRoot || this._root ).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[ clipUuid ];

						this._bindAction( action,
								actionsForClip && actionsForClip.knownActions[ 0 ] );

						this._addInactiveAction( action, clipUuid, rootUuid );

					}

					var bindings = action._propertyBindings;

					// increment reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

						var binding = bindings[ i ];

						if ( binding.useCount ++ === 0 ) {

							this._lendBinding( binding );
							binding.saveOriginalState();

						}

					}

					this._lendAction( action );

				}

			},

			_deactivateAction: function ( action ) {

				if ( this._isActiveAction( action ) ) {

					var bindings = action._propertyBindings;

					// decrement reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

						var binding = bindings[ i ];

						if ( -- binding.useCount === 0 ) {

							binding.restoreOriginalState();
							this._takeBackBinding( binding );

						}

					}

					this._takeBackAction( action );

				}

			},

			// Memory manager

			_initMemoryManager: function () {

				this._actions = []; // 'nActiveActions' followed by inactive ones
				this._nActiveActions = 0;

				this._actionsByClip = {};
				// inside:
				// {
				// 		knownActions: Array< AnimationAction >	- used as prototypes
				// 		actionByRoot: AnimationAction			- lookup
				// }


				this._bindings = []; // 'nActiveBindings' followed by inactive ones
				this._nActiveBindings = 0;

				this._bindingsByRootAndName = {}; // inside: MaterialMap< name, PropertyMixer >


				this._controlInterpolants = []; // same game as above
				this._nActiveControlInterpolants = 0;

				var scope = this;

				this.stats = {

					actions: {
						get total() { return scope._actions.length; },
						get inUse() { return scope._nActiveActions; }
					},
					bindings: {
						get total() { return scope._bindings.length; },
						get inUse() { return scope._nActiveBindings; }
					},
					controlInterpolants: {
						get total() { return scope._controlInterpolants.length; },
						get inUse() { return scope._nActiveControlInterpolants; }
					}

				};

			},

			// Memory management for AnimationAction objects

			_isActiveAction: function ( action ) {

				var index = action._cacheIndex;
				return index !== null && index < this._nActiveActions;

			},

			_addInactiveAction: function ( action, clipUuid, rootUuid ) {

				var actions = this._actions,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];

				if ( actionsForClip === undefined ) {

					actionsForClip = {

						knownActions: [ action ],
						actionByRoot: {}

					};

					action._byClipCacheIndex = 0;

					actionsByClip[ clipUuid ] = actionsForClip;

				} else {

					var knownActions = actionsForClip.knownActions;

					action._byClipCacheIndex = knownActions.length;
					knownActions.push( action );

				}

				action._cacheIndex = actions.length;
				actions.push( action );

				actionsForClip.actionByRoot[ rootUuid ] = action;

			},

			_removeInactiveAction: function ( action ) {

				var actions = this._actions,
					lastInactiveAction = actions[ actions.length - 1 ],
					cacheIndex = action._cacheIndex;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				action._cacheIndex = null;


				var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ],
					knownActionsForClip = actionsForClip.knownActions,

					lastKnownAction =
						knownActionsForClip[ knownActionsForClip.length - 1 ],

					byClipCacheIndex = action._byClipCacheIndex;

				lastKnownAction._byClipCacheIndex = byClipCacheIndex;
				knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
				knownActionsForClip.pop();

				action._byClipCacheIndex = null;


				var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = ( actions._localRoot || this._root ).uuid;

				delete actionByRoot[ rootUuid ];

				if ( knownActionsForClip.length === 0 ) {

					delete actionsByClip[ clipUuid ];

				}

				this._removeInactiveBindingsForAction( action );

			},

			_removeInactiveBindingsForAction: function ( action ) {

				var bindings = action._propertyBindings;
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.referenceCount === 0 ) {

						this._removeInactiveBinding( binding );

					}

				}

			},

			_lendAction: function ( action ) {

				// [ active actions |  inactive actions  ]
				// [  active actions >| inactive actions ]
				//                 s        a
				//                  <-swap->
				//                 a        s

				var actions = this._actions,
					prevIndex = action._cacheIndex,

					lastActiveIndex = this._nActiveActions ++,

					firstInactiveAction = actions[ lastActiveIndex ];

				action._cacheIndex = lastActiveIndex;
				actions[ lastActiveIndex ] = action;

				firstInactiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = firstInactiveAction;

			},

			_takeBackAction: function ( action ) {

				// [  active actions  | inactive actions ]
				// [ active actions |< inactive actions  ]
				//        a        s
				//         <-swap->
				//        s        a

				var actions = this._actions,
					prevIndex = action._cacheIndex,

					firstInactiveIndex = -- this._nActiveActions,

					lastActiveAction = actions[ firstInactiveIndex ];

				action._cacheIndex = firstInactiveIndex;
				actions[ firstInactiveIndex ] = action;

				lastActiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = lastActiveAction;

			},

			// Memory management for PropertyMixer objects

			_addInactiveBinding: function ( binding, rootUuid, trackName ) {

				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],

					bindings = this._bindings;

				if ( bindingByName === undefined ) {

					bindingByName = {};
					bindingsByRoot[ rootUuid ] = bindingByName;

				}

				bindingByName[ trackName ] = binding;

				binding._cacheIndex = bindings.length;
				bindings.push( binding );

			},

			_removeInactiveBinding: function ( binding ) {

				var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],

					lastInactiveBinding = bindings[ bindings.length - 1 ],
					cacheIndex = binding._cacheIndex;

				lastInactiveBinding._cacheIndex = cacheIndex;
				bindings[ cacheIndex ] = lastInactiveBinding;
				bindings.pop();

				delete bindingByName[ trackName ];

				remove_empty_map: {

					for ( var _ in bindingByName ) break remove_empty_map;

					delete bindingsByRoot[ rootUuid ];

				}

			},

			_lendBinding: function ( binding ) {

				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,

					lastActiveIndex = this._nActiveBindings ++,

					firstInactiveBinding = bindings[ lastActiveIndex ];

				binding._cacheIndex = lastActiveIndex;
				bindings[ lastActiveIndex ] = binding;

				firstInactiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = firstInactiveBinding;

			},

			_takeBackBinding: function ( binding ) {

				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,

					firstInactiveIndex = -- this._nActiveBindings,

					lastActiveBinding = bindings[ firstInactiveIndex ];

				binding._cacheIndex = firstInactiveIndex;
				bindings[ firstInactiveIndex ] = binding;

				lastActiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = lastActiveBinding;

			},


			// Memory management of Interpolants for weight and time scale

			_lendControlInterpolant: function () {

				var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants ++,
					interpolant = interpolants[ lastActiveIndex ];

				if ( interpolant === undefined ) {

					interpolant = new LinearInterpolant(
							new Float32Array( 2 ), new Float32Array( 2 ),
								1, this._controlInterpolantsResultBuffer );

					interpolant.__cacheIndex = lastActiveIndex;
					interpolants[ lastActiveIndex ] = interpolant;

				}

				return interpolant;

			},

			_takeBackControlInterpolant: function ( interpolant ) {

				var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,

					firstInactiveIndex = -- this._nActiveControlInterpolants,

					lastActiveInterpolant = interpolants[ firstInactiveIndex ];

				interpolant.__cacheIndex = firstInactiveIndex;
				interpolants[ firstInactiveIndex ] = interpolant;

				lastActiveInterpolant.__cacheIndex = prevIndex;
				interpolants[ prevIndex ] = lastActiveInterpolant;

			},

			_controlInterpolantsResultBuffer: new Float32Array( 1 )

		} );

		Object.assign( AnimationMixer.prototype, EventDispatcher.prototype );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Uniform( value ) {

			if ( typeof value === 'string' ) {

				console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
				value = arguments[ 1 ];

			}

			this.value = value;

		}

		Uniform.prototype.clone = function () {

			return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedBufferGeometry() {

			BufferGeometry.call( this );

			this.type = 'InstancedBufferGeometry';
			this.maxInstancedCount = undefined;

		}

		InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;

		InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

		InstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		};

		InstancedBufferGeometry.prototype.copy = function ( source ) {

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			var attributes = source.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			var groups = source.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			return this;

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

			this.uuid = _Math.generateUUID();

			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;

			this.normalized = normalized === true;

		}


		InterleavedBufferAttribute.prototype = {

			constructor: InterleavedBufferAttribute,

			isInterleavedBufferAttribute: true,

			get count() {

				return this.data.count;

			},

			get array() {

				return this.data.array;

			},

			setX: function ( index, x ) {

				this.data.array[ index * this.data.stride + this.offset ] = x;

				return this;

			},

			setY: function ( index, y ) {

				this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

				return this;

			},

			setZ: function ( index, z ) {

				this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

				return this;

			},

			setW: function ( index, w ) {

				this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

				return this;

			},

			getX: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset ];

			},

			getY: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 1 ];

			},

			getZ: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 2 ];

			},

			getW: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 3 ];

			},

			setXY: function ( index, x, y ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;

				return this;

			},

			setXYZ: function ( index, x, y, z ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;

				return this;

			},

			setXYZW: function ( index, x, y, z, w ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
				this.data.array[ index + 3 ] = w;

				return this;

			}

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InterleavedBuffer( array, stride ) {

			this.uuid = _Math.generateUUID();

			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;

			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };

			this.onUploadCallback = function () {};

			this.version = 0;

		}

		InterleavedBuffer.prototype = {

			constructor: InterleavedBuffer,

			isInterleavedBuffer: true,

			set needsUpdate( value ) {

				if ( value === true ) this.version ++;

			},

			setArray: function ( array ) {

				if ( Array.isArray( array ) ) {

					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

				}

				this.count = array !== undefined ? array.length / this.stride : 0;
				this.array = array;

			},

			setDynamic: function ( value ) {

				this.dynamic = value;

				return this;

			},

			copy: function ( source ) {

				this.array = new source.array.constructor( source.array );
				this.count = source.count;
				this.stride = source.stride;
				this.dynamic = source.dynamic;

				return this;

			},

			copyAt: function ( index1, attribute, index2 ) {

				index1 *= this.stride;
				index2 *= attribute.stride;

				for ( var i = 0, l = this.stride; i < l; i ++ ) {

					this.array[ index1 + i ] = attribute.array[ index2 + i ];

				}

				return this;

			},

			set: function ( value, offset ) {

				if ( offset === undefined ) offset = 0;

				this.array.set( value, offset );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			onUpload: function ( callback ) {

				this.onUploadCallback = callback;

				return this;

			}

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

			InterleavedBuffer.call( this, array, stride );

			this.meshPerAttribute = meshPerAttribute || 1;

		}

		InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
		InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;

		InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

		InstancedInterleavedBuffer.prototype.copy = function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

			BufferAttribute.call( this, array, itemSize );

			this.meshPerAttribute = meshPerAttribute || 1;

		}

		InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;

		InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

		InstancedBufferAttribute.prototype.copy = function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 * @author stephomi / http://stephaneginier.com/
		 */

		function Raycaster( origin, direction, near, far ) {

			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );

		}

		function ascSort( a, b ) {

			return a.distance - b.distance;

		}

		function intersectObject( object, raycaster, intersects, recursive ) {

			if ( object.visible === false ) return;

			object.raycast( raycaster, intersects );

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		}

		//

		Raycaster.prototype = {

			constructor: Raycaster,

			linePrecision: 1,

			set: function ( origin, direction ) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set( origin, direction );

			},

			setFromCamera: function ( coords, camera ) {

				if ( (camera && camera.isPerspectiveCamera) ) {

					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

				} else if ( (camera && camera.isOrthographicCamera) ) {

					this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

				} else {

					console.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function ( object, recursive ) {

				var intersects = [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( ascSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive ) {

				var intersects = [];

				if ( Array.isArray( objects ) === false ) {

					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( ascSort );

				return intersects;

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Clock( autoStart ) {

			this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;

			this.running = false;

		}

		Clock.prototype = {

			constructor: Clock,

			start: function () {

				this.startTime = ( performance || Date ).now();

				this.oldTime = this.startTime;
				this.elapsedTime = 0;
				this.running = true;

			},

			stop: function () {

				this.getElapsedTime();
				this.running = false;

			},

			getElapsedTime: function () {

				this.getDelta();
				return this.elapsedTime;

			},

			getDelta: function () {

				var diff = 0;

				if ( this.autoStart && ! this.running ) {

					this.start();

				}

				if ( this.running ) {

					var newTime = ( performance || Date ).now();

					diff = ( newTime - this.oldTime ) / 1000;
					this.oldTime = newTime;

					this.elapsedTime += diff;

				}

				return diff;

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
		 *
		 * The poles (phi) are at the positive and negative y axis.
		 * The equator starts at positive z.
		 */

		function Spherical( radius, phi, theta ) {

			this.radius = ( radius !== undefined ) ? radius : 1.0;
			this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
			this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

			return this;

		}

		Spherical.prototype = {

			constructor: Spherical,

			set: function ( radius, phi, theta ) {

				this.radius = radius;
				this.phi = phi;
				this.theta = theta;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( other ) {

				this.radius = other.radius;
				this.phi = other.phi;
				this.theta = other.theta;

				return this;

			},

			// restrict phi to be betwee EPS and PI-EPS
			makeSafe: function() {

				var EPS = 0.000001;
				this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

				return this;

			},

			setFromVector3: function( vec3 ) {

				this.radius = vec3.length();

				if ( this.radius === 0 ) {

					this.theta = 0;
					this.phi = 0;

				} else {

					this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
					this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

				}

				return this;

			}

		};

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
		 *
		 */

		function Cylindrical( radius, theta, y ) {

			this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
			this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
			this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

			return this;

		}

		Cylindrical.prototype = {

			constructor: Cylindrical,

			set: function ( radius, theta, y ) {

				this.radius = radius;
				this.theta = theta;
				this.y = y;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( other ) {

				this.radius = other.radius;
				this.theta = other.theta;
				this.y = other.y;

				return this;

			},

			setFromVector3: function( vec3 ) {

				this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
				this.theta = Math.atan2( vec3.x, vec3.z );
				this.y = vec3.y;

				return this;

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function MorphBlendMesh( geometry, material ) {

			Mesh.call( this, geometry, material );

			this.animationsMap = {};
			this.animationsList = [];

			// prepare default animation
			// (all frames played together in 1 second)

			var numFrames = this.geometry.morphTargets.length;

			var name = "__default";

			var startFrame = 0;
			var endFrame = numFrames - 1;

			var fps = numFrames / 1;

			this.createAnimation( name, startFrame, endFrame, fps );
			this.setAnimationWeight( name, 1 );

		}

		MorphBlendMesh.prototype = Object.create( Mesh.prototype );
		MorphBlendMesh.prototype.constructor = MorphBlendMesh;

		MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

			var animation = {

				start: start,
				end: end,

				length: end - start + 1,

				fps: fps,
				duration: ( end - start ) / fps,

				lastFrame: 0,
				currentFrame: 0,

				active: false,

				time: 0,
				direction: 1,
				weight: 1,

				directionBackwards: false,
				mirroredLoop: false

			};

			this.animationsMap[ name ] = animation;
			this.animationsList.push( animation );

		};

		MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

			var pattern = /([a-z]+)_?(\d+)/i;

			var firstAnimation, frameRanges = {};

			var geometry = this.geometry;

			for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

				var morph = geometry.morphTargets[ i ];
				var chunks = morph.name.match( pattern );

				if ( chunks && chunks.length > 1 ) {

					var name = chunks[ 1 ];

					if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

					var range = frameRanges[ name ];

					if ( i < range.start ) range.start = i;
					if ( i > range.end ) range.end = i;

					if ( ! firstAnimation ) firstAnimation = name;

				}

			}

			for ( var name in frameRanges ) {

				var range = frameRanges[ name ];
				this.createAnimation( name, range.start, range.end, fps );

			}

			this.firstAnimation = firstAnimation;

		};

		MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.direction = 1;
				animation.directionBackwards = false;

			}

		};

		MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.direction = - 1;
				animation.directionBackwards = true;

			}

		};

		MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.fps = fps;
				animation.duration = ( animation.end - animation.start ) / animation.fps;

			}

		};

		MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.duration = duration;
				animation.fps = ( animation.end - animation.start ) / animation.duration;

			}

		};

		MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.weight = weight;

			}

		};

		MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.time = time;

			}

		};

		MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

			var time = 0;

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				time = animation.time;

			}

			return time;

		};

		MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

			var duration = - 1;

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				duration = animation.duration;

			}

			return duration;

		};

		MorphBlendMesh.prototype.playAnimation = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.time = 0;
				animation.active = true;

			} else {

				console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

			}

		};

		MorphBlendMesh.prototype.stopAnimation = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.active = false;

			}

		};

		MorphBlendMesh.prototype.update = function ( delta ) {

			for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

				var animation = this.animationsList[ i ];

				if ( ! animation.active ) continue;

				var frameTime = animation.duration / animation.length;

				animation.time += animation.direction * delta;

				if ( animation.mirroredLoop ) {

					if ( animation.time > animation.duration || animation.time < 0 ) {

						animation.direction *= - 1;

						if ( animation.time > animation.duration ) {

							animation.time = animation.duration;
							animation.directionBackwards = true;

						}

						if ( animation.time < 0 ) {

							animation.time = 0;
							animation.directionBackwards = false;

						}

					}

				} else {

					animation.time = animation.time % animation.duration;

					if ( animation.time < 0 ) animation.time += animation.duration;

				}

				var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
				var weight = animation.weight;

				if ( keyframe !== animation.currentFrame ) {

					this.morphTargetInfluences[ animation.lastFrame ] = 0;
					this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

					this.morphTargetInfluences[ keyframe ] = 0;

					animation.lastFrame = animation.currentFrame;
					animation.currentFrame = keyframe;

				}

				var mix = ( animation.time % frameTime ) / frameTime;

				if ( animation.directionBackwards ) mix = 1 - mix;

				if ( animation.currentFrame !== animation.lastFrame ) {

					this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
					this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

				} else {

					this.morphTargetInfluences[ animation.currentFrame ] = weight;

				}

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function ImmediateRenderObject( material ) {

			Object3D.call( this );

			this.material = material;
			this.render = function ( renderCallback ) {};

		}

		ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
		ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

		ImmediateRenderObject.prototype.isImmediateRenderObject = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function VertexNormalsHelper( object, size, hex, linewidth ) {

			this.object = object;

			this.size = ( size !== undefined ) ? size : 1;

			var color = ( hex !== undefined ) ? hex : 0xff0000;

			var width = ( linewidth !== undefined ) ? linewidth : 1;

			//

			var nNormals = 0;

			var objGeometry = this.object.geometry;

			if ( objGeometry && objGeometry.isGeometry ) {

				nNormals = objGeometry.faces.length * 3;

			} else if ( objGeometry && objGeometry.isBufferGeometry ) {

				nNormals = objGeometry.attributes.normal.count;

			}

			//

			var geometry = new BufferGeometry();

			var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

			geometry.addAttribute( 'position', positions );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

			//

			this.matrixAutoUpdate = false;

			this.update();

		}

		VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
		VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

		VertexNormalsHelper.prototype.update = ( function () {

			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();

			return function update() {

				var keys = [ 'a', 'b', 'c' ];

				this.object.updateMatrixWorld( true );

				normalMatrix.getNormalMatrix( this.object.matrixWorld );

				var matrixWorld = this.object.matrixWorld;

				var position = this.geometry.attributes.position;

				//

				var objGeometry = this.object.geometry;

				if ( objGeometry && objGeometry.isGeometry ) {

					var vertices = objGeometry.vertices;

					var faces = objGeometry.faces;

					var idx = 0;

					for ( var i = 0, l = faces.length; i < l; i ++ ) {

						var face = faces[ i ];

						for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

							var vertex = vertices[ face[ keys[ j ] ] ];

							var normal = face.vertexNormals[ j ];

							v1.copy( vertex ).applyMatrix4( matrixWorld );

							v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

							position.setXYZ( idx, v1.x, v1.y, v1.z );

							idx = idx + 1;

							position.setXYZ( idx, v2.x, v2.y, v2.z );

							idx = idx + 1;

						}

					}

				} else if ( objGeometry && objGeometry.isBufferGeometry ) {

					var objPos = objGeometry.attributes.position;

					var objNorm = objGeometry.attributes.normal;

					var idx = 0;

					// for simplicity, ignore index and drawcalls, and render every normal

					for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

						v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

						v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

						v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

				position.needsUpdate = true;

				return this;

			};

		}() );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function SpotLightHelper( light ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			var geometry = new BufferGeometry();

			var positions = [
				0, 0, 0,   0,   0,   1,
				0, 0, 0,   1,   0,   1,
				0, 0, 0, - 1,   0,   1,
				0, 0, 0,   0,   1,   1,
				0, 0, 0,   0, - 1,   1
			];

			for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

				var p1 = ( i / l ) * Math.PI * 2;
				var p2 = ( j / l ) * Math.PI * 2;

				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);

			}

			geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

			var material = new LineBasicMaterial( { fog: false } );

			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );

			this.update();

		}

		SpotLightHelper.prototype = Object.create( Object3D.prototype );
		SpotLightHelper.prototype.constructor = SpotLightHelper;

		SpotLightHelper.prototype.dispose = function () {

			this.cone.geometry.dispose();
			this.cone.material.dispose();

		};

		SpotLightHelper.prototype.update = function () {

			var vector = new Vector3();
			var vector2 = new Vector3();

			return function update() {

				var coneLength = this.light.distance ? this.light.distance : 1000;
				var coneWidth = coneLength * Math.tan( this.light.angle );

				this.cone.scale.set( coneWidth, coneWidth, coneLength );

				vector.setFromMatrixPosition( this.light.matrixWorld );
				vector2.setFromMatrixPosition( this.light.target.matrixWorld );

				this.cone.lookAt( vector2.sub( vector ) );

				this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			};

		}();

		/**
		 * @author Sean Griffin / http://twitter.com/sgrif
		 * @author Michael Guerrero / http://realitymeltdown.com
		 * @author mrdoob / http://mrdoob.com/
		 * @author ikerr / http://verold.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function SkeletonHelper( object ) {

			this.bones = this.getBoneList( object );

			var geometry = new BufferGeometry();

			var vertices = [];
			var colors = [];

			var color1 = new Color( 0, 0, 1 );
			var color2 = new Color( 0, 1, 0 );

			for ( var i = 0; i < this.bones.length; i ++ ) {

				var bone = this.bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					vertices.push( 0, 0, 0 );
					vertices.push( 0, 0, 0 );
					colors.push( color1.r, color1.g, color1.b );
					colors.push( color2.r, color2.g, color2.b );

				}

			}

			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

			LineSegments.call( this, geometry, material );

			this.root = object;

			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;

			this.update();

		}


		SkeletonHelper.prototype = Object.create( LineSegments.prototype );
		SkeletonHelper.prototype.constructor = SkeletonHelper;

		SkeletonHelper.prototype.getBoneList = function( object ) {

			var boneList = [];

			if ( object && object.isBone ) {

				boneList.push( object );

			}

			for ( var i = 0; i < object.children.length; i ++ ) {

				boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

			}

			return boneList;

		};

		SkeletonHelper.prototype.update = function () {

			var vector = new Vector3();

			var boneMatrix = new Matrix4();
			var matrixWorldInv = new Matrix4();

			return function update() {

				var geometry = this.geometry;
				var position = geometry.getAttribute( 'position' );

				matrixWorldInv.getInverse( this.root.matrixWorld );

				for ( var i = 0, j = 0; i < this.bones.length; i ++ ) {

					var bone = this.bones[ i ];

					if ( bone.parent && bone.parent.isBone ) {

						boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
						vector.setFromMatrixPosition( boneMatrix );
						position.setXYZ( j, vector.x, vector.y, vector.z );

						boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
						vector.setFromMatrixPosition( boneMatrix );
						position.setXYZ( j + 1, vector.x, vector.y, vector.z );

						j += 2;

					}

				}

				geometry.getAttribute( 'position' ).needsUpdate = true;

			};

		}();

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function PointLightHelper( light, sphereSize ) {

			this.light = light;
			this.light.updateMatrixWorld();

			var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
			var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
			material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			Mesh.call( this, geometry, material );

			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;

			/*
			var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
			var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

			var d = light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.scale.set( d, d, d );

			}

			this.add( this.lightDistance );
			*/

		}

		PointLightHelper.prototype = Object.create( Mesh.prototype );
		PointLightHelper.prototype.constructor = PointLightHelper;

		PointLightHelper.prototype.dispose = function () {

			this.geometry.dispose();
			this.material.dispose();

		};

		PointLightHelper.prototype.update = function () {

			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			/*
			var d = this.light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );

			}
			*/

		};

		/**
		 * @author abelnation / http://github.com/abelnation
		 * @author Mugen87 / http://github.com/Mugen87
		 */

		function RectAreaLightHelper( light ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			var materialFront = new MeshBasicMaterial( {
				color: light.color,
				fog: false
			} );

			var materialBack = new MeshBasicMaterial( {
				color: light.color,
				fog: false,
				wireframe: true
			} );

			var geometry = new BufferGeometry();

			geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 6 * 3 ), 3 ) );

			// shows the "front" of the light, e.g. where light comes from

			this.add( new Mesh( geometry, materialFront ) );

			// shows the "back" of the light, which does not emit light

			this.add( new Mesh( geometry, materialBack ) );

			this.update();

		}

		RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
		RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

		RectAreaLightHelper.prototype.dispose = function () {

			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();
			this.children[ 1 ].geometry.dispose();
			this.children[ 1 ].material.dispose();

		};

		RectAreaLightHelper.prototype.update = function () {

			var vector1 = new Vector3();
			var vector2 = new Vector3();

			return function update() {

				var mesh1 = this.children[ 0 ];
				var mesh2 = this.children[ 1 ];

				if ( this.light.target ) {

					vector1.setFromMatrixPosition( this.light.matrixWorld );
					vector2.setFromMatrixPosition( this.light.target.matrixWorld );

					var lookVec = vector2.clone().sub( vector1 );
					mesh1.lookAt( lookVec );
					mesh2.lookAt( lookVec );

				}

				// update materials

				mesh1.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
				mesh2.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

				// calculate new dimensions of the helper

				var hx = this.light.width * 0.5;
				var hy = this.light.height * 0.5;

				// because the buffer attribute is shared over both geometries, we only have to update once

				var position = mesh1.geometry.getAttribute( 'position' );
				var array = position.array;

				// first face

				array[  0 ] =   hx; array[  1 ] = - hy; array[  2 ] = 0;
				array[  3 ] =   hx; array[  4 ] =   hy; array[  5 ] = 0;
				array[  6 ] = - hx; array[  7 ] =   hy; array[  8 ] = 0;

				// second face

				array[  9 ] = - hx; array[ 10 ] =   hy; array[ 11 ] = 0;
				array[ 12 ] = - hx; array[ 13 ] = - hy; array[ 14 ] = 0;
				array[ 15 ] =   hx; array[ 16 ] = - hy; array[ 17 ] = 0;

				position.needsUpdate = true;

			};

		}();

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function HemisphereLightHelper( light, size ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			var geometry = new OctahedronBufferGeometry( size );
			geometry.rotateY( Math.PI * 0.5 );

			var material = new MeshBasicMaterial( { vertexColors: VertexColors, wireframe: true } );

			var position = geometry.getAttribute( 'position' );
			var colors = new Float32Array( position.count * 3 );

			geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

			this.add( new Mesh( geometry, material ) );

			this.update();

		}

		HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
		HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

		HemisphereLightHelper.prototype.dispose = function () {

			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();

		};

		HemisphereLightHelper.prototype.update = function () {

			var vector = new Vector3();

			var color1 = new Color();
			var color2 = new Color();

			return function update() {

				var mesh = this.children[ 0 ];

				var colors = mesh.geometry.getAttribute( 'color' );

				color1.copy( this.light.color ).multiplyScalar( this.light.intensity );
				color2.copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

				for ( var i = 0, l = colors.count; i < l; i ++ ) {

					var color = ( i < ( l / 2 ) ) ? color1 : color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

				colors.needsUpdate = true;

			};

		}();

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function GridHelper( size, divisions, color1, color2 ) {

			size = size || 10;
			divisions = divisions || 10;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

			var center = divisions / 2;
			var step = ( size * 2 ) / divisions;
			var vertices = [], colors = [];

			for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {

				vertices.push( - size, 0, k, size, 0, k );
				vertices.push( k, 0, - size, k, 0, size );

				var color = i === center ? color1 : color2;

				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;

			}

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: VertexColors } );

			LineSegments.call( this, geometry, material );

		}

		GridHelper.prototype = Object.create( LineSegments.prototype );
		GridHelper.prototype.constructor = GridHelper;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / http://github.com/Mugen87
		 * @author Hectate / http://www.github.com/Hectate
		 */

		function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

			radius = radius || 10;
			radials = radials || 16;
			circles = circles || 8;
			divisions = divisions || 64;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

			var vertices = [];
			var colors = [];

			var x, z;
			var v, i, j, r, color;

			// create the radials

			for ( i = 0; i <= radials; i ++ ) {

				v = ( i / radials ) * ( Math.PI * 2 );

				x = Math.sin( v ) * radius;
				z = Math.cos( v ) * radius;

				vertices.push( 0, 0, 0 );
				vertices.push( x, 0, z );

				color = ( i & 1 ) ? color1 : color2;

				colors.push( color.r, color.g, color.b );
				colors.push( color.r, color.g, color.b );

			}

			// create the circles

			for ( i = 0; i <= circles; i ++ ) {

				color = ( i & 1 ) ? color1 : color2;

				r = radius - ( radius / circles * i );

				for ( j = 0; j < divisions; j ++ ) {

					// first vertex

					v = ( j / divisions ) * ( Math.PI * 2 );

					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;

					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );

					// second vertex

					v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;

					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );

				}

			}

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: VertexColors } );

			LineSegments.call( this, geometry, material );

		}

		PolarGridHelper.prototype = Object.create( LineSegments.prototype );
		PolarGridHelper.prototype.constructor = PolarGridHelper;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function FaceNormalsHelper( object, size, hex, linewidth ) {

			// FaceNormalsHelper only supports THREE.Geometry

			this.object = object;

			this.size = ( size !== undefined ) ? size : 1;

			var color = ( hex !== undefined ) ? hex : 0xffff00;

			var width = ( linewidth !== undefined ) ? linewidth : 1;

			//

			var nNormals = 0;

			var objGeometry = this.object.geometry;

			if ( objGeometry && objGeometry.isGeometry ) {

				nNormals = objGeometry.faces.length;

			} else {

				console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

			}

			//

			var geometry = new BufferGeometry();

			var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

			geometry.addAttribute( 'position', positions );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

			//

			this.matrixAutoUpdate = false;
			this.update();

		}

		FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
		FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

		FaceNormalsHelper.prototype.update = ( function () {

			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();

			return function update() {

				this.object.updateMatrixWorld( true );

				normalMatrix.getNormalMatrix( this.object.matrixWorld );

				var matrixWorld = this.object.matrixWorld;

				var position = this.geometry.attributes.position;

				//

				var objGeometry = this.object.geometry;

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					var normal = face.normal;

					v1.copy( vertices[ face.a ] )
						.add( vertices[ face.b ] )
						.add( vertices[ face.c ] )
						.divideScalar( 3 )
						.applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

				position.needsUpdate = true;

				return this;

			};

		}() );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function DirectionalLightHelper( light, size ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			if ( size === undefined ) size = 1;

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( [
				- size,   size, 0,
				  size,   size, 0,
				  size, - size, 0,
				- size, - size, 0,
				- size,   size, 0
			], 3 ) );

			var material = new LineBasicMaterial( { fog: false } );

			this.add( new Line( geometry, material ) );

			geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

			this.add( new Line( geometry, material ));

			this.update();

		}

		DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
		DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

		DirectionalLightHelper.prototype.dispose = function () {

			var lightPlane = this.children[ 0 ];
			var targetLine = this.children[ 1 ];

			lightPlane.geometry.dispose();
			lightPlane.material.dispose();
			targetLine.geometry.dispose();
			targetLine.material.dispose();

		};

		DirectionalLightHelper.prototype.update = function () {

			var v1 = new Vector3();
			var v2 = new Vector3();
			var v3 = new Vector3();

			return function update() {

				v1.setFromMatrixPosition( this.light.matrixWorld );
				v2.setFromMatrixPosition( this.light.target.matrixWorld );
				v3.subVectors( v2, v1 );

				var lightPlane = this.children[ 0 ];
				var targetLine = this.children[ 1 ];

				lightPlane.lookAt( v3 );
				lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

				targetLine.lookAt( v3 );
				targetLine.scale.z = v3.length();

			};

		}();

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 *	- shows frustum, line of sight and up of the camera
		 *	- suitable for fast updates
		 * 	- based on frustum visualization in lightgl.js shadowmap example
		 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
		 */

		function CameraHelper( camera ) {

			var geometry = new BufferGeometry();
			var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

			var vertices = [];
			var colors = [];

			var pointMap = {};

			// colors

			var colorFrustum = new Color( 0xffaa00 );
			var colorCone = new Color( 0xff0000 );
			var colorUp = new Color( 0x00aaff );
			var colorTarget = new Color( 0xffffff );
			var colorCross = new Color( 0x333333 );

			// near

			addLine( "n1", "n2", colorFrustum );
			addLine( "n2", "n4", colorFrustum );
			addLine( "n4", "n3", colorFrustum );
			addLine( "n3", "n1", colorFrustum );

			// far

			addLine( "f1", "f2", colorFrustum );
			addLine( "f2", "f4", colorFrustum );
			addLine( "f4", "f3", colorFrustum );
			addLine( "f3", "f1", colorFrustum );

			// sides

			addLine( "n1", "f1", colorFrustum );
			addLine( "n2", "f2", colorFrustum );
			addLine( "n3", "f3", colorFrustum );
			addLine( "n4", "f4", colorFrustum );

			// cone

			addLine( "p", "n1", colorCone );
			addLine( "p", "n2", colorCone );
			addLine( "p", "n3", colorCone );
			addLine( "p", "n4", colorCone );

			// up

			addLine( "u1", "u2", colorUp );
			addLine( "u2", "u3", colorUp );
			addLine( "u3", "u1", colorUp );

			// target

			addLine( "c", "t", colorTarget );
			addLine( "p", "c", colorCross );

			// cross

			addLine( "cn1", "cn2", colorCross );
			addLine( "cn3", "cn4", colorCross );

			addLine( "cf1", "cf2", colorCross );
			addLine( "cf3", "cf4", colorCross );

			function addLine( a, b, color ) {

				addPoint( a, color );
				addPoint( b, color );

			}

			function addPoint( id, color ) {

				vertices.push( 0, 0, 0 );
				colors.push( color.r, color.g, color.b );

				if ( pointMap[ id ] === undefined ) {

					pointMap[ id ] = [];

				}

				pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

			}

			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			LineSegments.call( this, geometry, material );

			this.camera = camera;
			if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;

			this.pointMap = pointMap;

			this.update();

		}

		CameraHelper.prototype = Object.create( LineSegments.prototype );
		CameraHelper.prototype.constructor = CameraHelper;

		CameraHelper.prototype.update = function () {

			var geometry, pointMap;

			var vector = new Vector3();
			var camera = new Camera();

			function setPoint( point, x, y, z ) {

				vector.set( x, y, z ).unproject( camera );

				var points = pointMap[ point ];

				if ( points !== undefined ) {

					var position = geometry.getAttribute( 'position' );

					for ( var i = 0, l = points.length; i < l; i ++ ) {

						position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

					}

				}

			}

			return function update() {

				geometry = this.geometry;
				pointMap = this.pointMap;

				var w = 1, h = 1;

				// we need just camera projection matrix
				// world matrix must be identity

				camera.projectionMatrix.copy( this.camera.projectionMatrix );

				// center / target

				setPoint( "c", 0, 0, - 1 );
				setPoint( "t", 0, 0,  1 );

				// near

				setPoint( "n1", - w, - h, - 1 );
				setPoint( "n2",   w, - h, - 1 );
				setPoint( "n3", - w,   h, - 1 );
				setPoint( "n4",   w,   h, - 1 );

				// far

				setPoint( "f1", - w, - h, 1 );
				setPoint( "f2",   w, - h, 1 );
				setPoint( "f3", - w,   h, 1 );
				setPoint( "f4",   w,   h, 1 );

				// up

				setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
				setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
				setPoint( "u3",         0, h * 2,   - 1 );

				// cross

				setPoint( "cf1", - w,   0, 1 );
				setPoint( "cf2",   w,   0, 1 );
				setPoint( "cf3",   0, - h, 1 );
				setPoint( "cf4",   0,   h, 1 );

				setPoint( "cn1", - w,   0, - 1 );
				setPoint( "cn2",   w,   0, - 1 );
				setPoint( "cn3",   0, - h, - 1 );
				setPoint( "cn4",   0,   h, - 1 );

				geometry.getAttribute( 'position' ).needsUpdate = true;

			};

		}();

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BoxHelper( object, color ) {

			if ( color === undefined ) color = 0xffff00;

			var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			var positions = new Float32Array( 8 * 3 );

			var geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

			if ( object !== undefined ) {

				this.update( object );

			}

		}

		BoxHelper.prototype = Object.create( LineSegments.prototype );
		BoxHelper.prototype.constructor = BoxHelper;

		BoxHelper.prototype.update = ( function () {

			var box = new Box3();

			return function update( object ) {

				if ( object && object.isBox3 ) {

					box.copy( object );

				} else {

					box.setFromObject( object );

				}

				if ( box.isEmpty() ) return;

				var min = box.min;
				var max = box.max;

				/*
				  5____4
				1/___0/|
				| 6__|_7
				2/___3/

				0: max.x, max.y, max.z
				1: min.x, max.y, max.z
				2: min.x, min.y, max.z
				3: max.x, min.y, max.z
				4: max.x, max.y, min.z
				5: min.x, max.y, min.z
				6: min.x, min.y, min.z
				7: max.x, min.y, min.z
				*/

				var position = this.geometry.attributes.position;
				var array = position.array;

				array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
				array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
				array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
				array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
				array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
				array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
				array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
				array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

				position.needsUpdate = true;

				this.geometry.computeBoundingSphere();

			};

		} )();

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author zz85 / http://github.com/zz85
		 * @author bhouston / http://clara.io
		 *
		 * Creates an arrow for visualizing directions
		 *
		 * Parameters:
		 *  dir - Vector3
		 *  origin - Vector3
		 *  length - Number
		 *  color - color in hex value
		 *  headLength - Number
		 *  headWidth - Number
		 */

		var lineGeometry = new BufferGeometry();
		lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

		var coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );

		function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			Object3D.call( this );

			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.position.copy( origin );

			this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );

			this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

		ArrowHelper.prototype = Object.create( Object3D.prototype );
		ArrowHelper.prototype.constructor = ArrowHelper;

		ArrowHelper.prototype.setDirection = ( function () {

			var axis = new Vector3();
			var radians;

			return function setDirection( dir ) {

				// dir is assumed to be normalized

				if ( dir.y > 0.99999 ) {

					this.quaternion.set( 0, 0, 0, 1 );

				} else if ( dir.y < - 0.99999 ) {

					this.quaternion.set( 1, 0, 0, 0 );

				} else {

					axis.set( dir.z, 0, - dir.x ).normalize();

					radians = Math.acos( dir.y );

					this.quaternion.setFromAxisAngle( axis, radians );

				}

			};

		}() );

		ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
			this.line.updateMatrix();

			this.cone.scale.set( headWidth, headLength, headWidth );
			this.cone.position.y = length;
			this.cone.updateMatrix();

		};

		ArrowHelper.prototype.setColor = function ( color ) {

			this.line.material.color.copy( color );
			this.cone.material.color.copy( color );

		};

		/**
		 * @author sroucheray / http://sroucheray.org/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AxisHelper( size ) {

			size = size || 1;

			var vertices = [
				0, 0, 0,  size, 0, 0,
				0, 0, 0,  0, size, 0,
				0, 0, 0,  0, 0, size
			];

			var colors = [
				1, 0, 0,  1, 0.6, 0,
				0, 1, 0,  0.6, 1, 0,
				0, 0, 1,  0, 0.6, 1
			];

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: VertexColors } );

			LineSegments.call( this, geometry, material );

		}

		AxisHelper.prototype = Object.create( LineSegments.prototype );
		AxisHelper.prototype.constructor = AxisHelper;

		/**
		 * @author zz85 https://github.com/zz85
		 *
		 * Centripetal CatmullRom Curve - which is useful for avoiding
		 * cusps and self-intersections in non-uniform catmull rom curves.
		 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
		 *
		 * curve.type accepts centripetal(default), chordal and catmullrom
		 * curve.tension is used for catmullrom which defaults to 0.5
		 */


		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM

		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/

		function CubicPoly() {

			var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

			/*
			 * Compute coefficients for a cubic polynomial
			 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
			 * such that
			 *   p(0) = x0, p(1) = x1
			 *  and
			 *   p'(0) = t0, p'(1) = t1.
			 */
			function init( x0, x1, t0, t1 ) {

				c0 = x0;
				c1 = t0;
				c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
				c3 = 2 * x0 - 2 * x1 + t0 + t1;

			}

			return {

				initCatmullRom: function ( x0, x1, x2, x3, tension ) {

					init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

				},

				initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

					// compute tangents when parameterized in [t1,t2]
					var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
					var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

					// rescale tangents for parametrization in [0,1]
					t1 *= dt1;
					t2 *= dt1;

					init( x1, x2, t1, t2 );

				},

				calc: function ( t ) {

					var t2 = t * t;
					var t3 = t2 * t;
					return c0 + c1 * t + c2 * t2 + c3 * t3;

				}

			};

		}

		//

		var tmp = new Vector3();
		var px = new CubicPoly();
		var py = new CubicPoly();
		var pz = new CubicPoly();

		function CatmullRomCurve3( p /* array of Vector3 */ ) {

			this.points = p || [];
			this.closed = false;

		}

		CatmullRomCurve3.prototype = Object.create( Curve.prototype );
		CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

		CatmullRomCurve3.prototype.getPoint = function ( t ) {

			var points = this.points;
			var l = points.length;

			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

			var point = ( l - ( this.closed ? 0 : 1 ) ) * t;
			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			if ( this.closed ) {

				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			} else if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			var p0, p1, p2, p3; // 4 points

			if ( this.closed || intPoint > 0 ) {

				p0 = points[ ( intPoint - 1 ) % l ];

			} else {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			}

			p1 = points[ intPoint % l ];
			p2 = points[ ( intPoint + 1 ) % l ];

			if ( this.closed || intPoint + 2 < l ) {

				p3 = points[ ( intPoint + 2 ) % l ];

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;

			}

			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.type === 'catmullrom' ) {

				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

			}

			return new Vector3( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );

		};

		function CubicBezierCurve3( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		CubicBezierCurve3.prototype = Object.create( Curve.prototype );
		CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

		CubicBezierCurve3.prototype.getPoint = function ( t ) {

			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			return new Vector3(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
				CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
			);

		};

		function QuadraticBezierCurve3( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

		QuadraticBezierCurve3.prototype.getPoint = function ( t ) {

			var v0 = this.v0, v1 = this.v1, v2 = this.v2;

			return new Vector3(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y ),
				QuadraticBezier( t, v0.z, v1.z, v2.z )
			);

		};

		function LineCurve3( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		}

		LineCurve3.prototype = Object.create( Curve.prototype );
		LineCurve3.prototype.constructor = LineCurve3;

		LineCurve3.prototype.getPoint = function ( t ) {

			if ( t === 1 ) {

				return this.v2.clone();

			}

			var vector = new Vector3();

			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );

			return vector;

		};

		function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		}

		ArcCurve.prototype = Object.create( EllipseCurve.prototype );
		ArcCurve.prototype.constructor = ArcCurve;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		var SceneUtils = {

			createMultiMaterialObject: function ( geometry, materials ) {

				var group = new Group();

				for ( var i = 0, l = materials.length; i < l; i ++ ) {

					group.add( new Mesh( geometry, materials[ i ] ) );

				}

				return group;

			},

			detach: function ( child, parent, scene ) {

				child.applyMatrix( parent.matrixWorld );
				parent.remove( child );
				scene.add( child );

			},

			attach: function ( child, scene, parent ) {

				var matrixWorldInverse = new Matrix4();
				matrixWorldInverse.getInverse( parent.matrixWorld );
				child.applyMatrix( matrixWorldInverse );

				scene.remove( child );
				parent.add( child );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Face4( a, b, c, d, normal, color, materialIndex ) {

			console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new Face3( a, b, c, normal, color, materialIndex );

		}

		var LineStrip = 0;

		var LinePieces = 1;

		function MeshFaceMaterial( materials ) {

			console.warn( 'THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.' );
			return new MultiMaterial( materials );

		}

		function PointCloud( geometry, material ) {

			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new Points( geometry, material );

		}

		function Particle( material ) {

			console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
			return new Sprite( material );

		}

		function ParticleSystem( geometry, material ) {

			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new Points( geometry, material );

		}

		function PointCloudMaterial( parameters ) {

			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );

		}

		function ParticleBasicMaterial( parameters ) {

			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );

		}

		function ParticleSystemMaterial( parameters ) {

			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );

		}

		function Vertex( x, y, z ) {

			console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new Vector3( x, y, z );

		}

		//

		function DynamicBufferAttribute( array, itemSize ) {

			console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
			return new BufferAttribute( array, itemSize ).setDynamic( true );

		}

		function Int8Attribute( array, itemSize ) {

			console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
			return new Int8BufferAttribute( array, itemSize );

		}

		function Uint8Attribute( array, itemSize ) {

			console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
			return new Uint8BufferAttribute( array, itemSize );

		}

		function Uint8ClampedAttribute( array, itemSize ) {

			console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
			return new Uint8ClampedBufferAttribute( array, itemSize );

		}

		function Int16Attribute( array, itemSize ) {

			console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
			return new Int16BufferAttribute( array, itemSize );

		}

		function Uint16Attribute( array, itemSize ) {

			console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
			return new Uint16BufferAttribute( array, itemSize );

		}

		function Int32Attribute( array, itemSize ) {

			console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
			return new Int32BufferAttribute( array, itemSize );

		}

		function Uint32Attribute( array, itemSize ) {

			console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
			return new Uint32BufferAttribute( array, itemSize );

		}

		function Float32Attribute( array, itemSize ) {

			console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
			return new Float32BufferAttribute( array, itemSize );

		}

		function Float64Attribute( array, itemSize ) {

			console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
			return new Float64BufferAttribute( array, itemSize );

		}

		//

		Curve.create = function ( construct, getPoint ) {

			console.log( 'THREE.Curve.create() has been deprecated' );

			construct.prototype = Object.create( Curve.prototype );
			construct.prototype.constructor = construct;
			construct.prototype.getPoint = getPoint;

			return construct;

		};

		//

		function ClosedSplineCurve3( points ) {

			console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
			this.closed = true;

		}

		ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

		//

		function SplineCurve3( points ) {

			console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';

		}

		SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

		//

		function Spline( points ) {

			console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';

		}

		Spline.prototype = Object.create( CatmullRomCurve3.prototype );

		Object.assign( Spline.prototype, {

			initFromArray: function ( a ) {

				console.error( 'THREE.Spline: .initFromArray() has been removed.' );

			},
			getControlPointsArray: function ( optionalTarget ) {

				console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

			},
			reparametrizeByArcLength: function ( samplingCoef ) {

				console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

			}

		} );

		//
		function BoundingBoxHelper( object, color ) {

			console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
			return new BoxHelper( object, color );

		}

		function EdgesHelper( object, hex ) {

			console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
			return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

		}

		GridHelper.prototype.setColors = function () {

			console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

		};

		function WireframeHelper( object, hex ) {

			console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
			return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

		}

		//

		function XHRLoader( manager ) {

			console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
			return new FileLoader( manager );

		}

		function BinaryTextureLoader( manager ) {

			console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
			return new DataTextureLoader( manager );

		}

		//

		Object.assign( Box2.prototype, {

			center: function ( optionalTarget ) {

				console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );

			},
			empty: function () {

				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();

			},
			isIntersectionBox: function ( box ) {

				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );

			},
			size: function ( optionalTarget ) {

				console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );

			}
		} );

		Object.assign( Box3.prototype, {

			center: function ( optionalTarget ) {

				console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );

			},
			empty: function () {

				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();

			},
			isIntersectionBox: function ( box ) {

				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );

			},
			isIntersectionSphere: function ( sphere ) {

				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );

			},
			size: function ( optionalTarget ) {

				console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );

			}
		} );

		Line3.prototype.center = function ( optionalTarget ) {

			console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		};

		_Math.random16 = function () {

			console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();

		};

		Object.assign( Matrix3.prototype, {

			flattenToArrayOffset: function ( array, offset ) {

				console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );

			},
			multiplyVector3: function ( vector ) {

				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );

			},
			multiplyVector3Array: function ( a ) {

				console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );

			},
			applyToBuffer: function( buffer, offset, length ) {

				console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
				return this.applyToBufferAttribute( buffer );

			},
			applyToVector3Array: function( array, offset, length ) {

				console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

			}

		} );

		Object.assign( Matrix4.prototype, {

			extractPosition: function ( m ) {

				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );

			},
			flattenToArrayOffset: function ( array, offset ) {

				console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );

			},
			getPosition: function () {

				var v1;

				return function getPosition() {

					if ( v1 === undefined ) v1 = new Vector3();
					console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
					return v1.setFromMatrixColumn( this, 3 );

				};

			}(),
			setRotationFromQuaternion: function ( q ) {

				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );

			},
			multiplyVector3: function ( vector ) {

				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );

			},
			multiplyVector4: function ( vector ) {

				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );

			},
			multiplyVector3Array: function ( a ) {

				console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );

			},
			rotateAxis: function ( v ) {

				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );

			},
			crossVector: function ( vector ) {

				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );

			},
			translate: function () {

				console.error( 'THREE.Matrix4: .translate() has been removed.' );

			},
			rotateX: function () {

				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

			},
			rotateY: function () {

				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

			},
			rotateZ: function () {

				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

			},
			rotateByAxis: function () {

				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

			},
			applyToBuffer: function( buffer, offset, length ) {

				console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
				return this.applyToBufferAttribute( buffer );

			},
			applyToVector3Array: function( array, offset, length ) {

				console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

			},
			makeFrustum: function( left, right, bottom, top, near, far ) {

				console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
				return this.makePerspective( left, right, top, bottom, near, far );

			}

		} );

		Plane.prototype.isIntersectionLine = function ( line ) {

			console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
			return this.intersectsLine( line );

		};

		Quaternion.prototype.multiplyVector3 = function ( vector ) {

			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );

		};

		Object.assign( Ray.prototype, {

			isIntersectionBox: function ( box ) {

				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );

			},
			isIntersectionPlane: function ( plane ) {

				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );

			},
			isIntersectionSphere: function ( sphere ) {

				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );

			}

		} );

		Object.assign( Shape.prototype, {

			extrude: function ( options ) {

				console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
				return new ExtrudeGeometry( this, options );

			},
			makeGeometry: function ( options ) {

				console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
				return new ShapeGeometry( this, options );

			}

		} );

		Object.assign( Vector2.prototype, {

			fromAttribute: function ( attribute, index, offset ) {

				console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );

			}

		} );

		Object.assign( Vector3.prototype, {

			setEulerFromRotationMatrix: function () {

				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

			},
			setEulerFromQuaternion: function () {

				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

			},
			getPositionFromMatrix: function ( m ) {

				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );

			},
			getScaleFromMatrix: function ( m ) {

				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );

			},
			getColumnFromMatrix: function ( index, matrix ) {

				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( matrix, index );

			},
			applyProjection: function ( m ) {

				console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
				return this.applyMatrix4( m );

			},
			fromAttribute: function ( attribute, index, offset ) {

				console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );

			}

		} );

		Object.assign( Vector4.prototype, {

			fromAttribute: function ( attribute, index, offset ) {

				console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );

			}

		} );

		//

		Geometry.prototype.computeTangents = function () {

			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

		};

		Object.assign( Object3D.prototype, {

			getChildByName: function ( name ) {

				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );

			},
			renderDepth: function () {

				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

			},
			translate: function ( distance, axis ) {

				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );

			}

		} );

		Object.defineProperties( Object3D.prototype, {

			eulerOrder: {
				get: function () {

					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					return this.rotation.order;

				},
				set: function ( value ) {

					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					this.rotation.order = value;

				}
			},
			useQuaternion: {
				get: function () {

					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

				},
				set: function () {

					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

				}
			}

		} );

		Object.defineProperties( LOD.prototype, {

			objects: {
				get: function () {

					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;

				}
			}

		} );

		//

		PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

			console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
					"Use .setFocalLength and .filmGauge for a photographic setup." );

			if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
			this.setFocalLength( focalLength );

		};

		//

		Object.defineProperties( Light.prototype, {
			onlyShadow: {
				set: function () {

					console.warn( 'THREE.Light: .onlyShadow has been removed.' );

				}
			},
			shadowCameraFov: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
					this.shadow.camera.fov = value;

				}
			},
			shadowCameraLeft: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
					this.shadow.camera.left = value;

				}
			},
			shadowCameraRight: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
					this.shadow.camera.right = value;

				}
			},
			shadowCameraTop: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
					this.shadow.camera.top = value;

				}
			},
			shadowCameraBottom: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
					this.shadow.camera.bottom = value;

				}
			},
			shadowCameraNear: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
					this.shadow.camera.near = value;

				}
			},
			shadowCameraFar: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
					this.shadow.camera.far = value;

				}
			},
			shadowCameraVisible: {
				set: function () {

					console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

				}
			},
			shadowBias: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
					this.shadow.bias = value;

				}
			},
			shadowDarkness: {
				set: function () {

					console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

				}
			},
			shadowMapWidth: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
					this.shadow.mapSize.width = value;

				}
			},
			shadowMapHeight: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
					this.shadow.mapSize.height = value;

				}
			}
		} );

		//

		Object.defineProperties( BufferAttribute.prototype, {

			length: {
				get: function () {

					console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
					return this.array.length;

				}
			}

		} );

		Object.assign( BufferGeometry.prototype, {

			addIndex: function ( index ) {

				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );

			},
			addDrawCall: function ( start, count, indexOffset ) {

				if ( indexOffset !== undefined ) {

					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );

			},
			clearDrawCalls: function () {

				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();

			},
			computeTangents: function () {

				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

			},
			computeOffsets: function () {

				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

			}

		} );

		Object.defineProperties( BufferGeometry.prototype, {

			drawcalls: {
				get: function () {

					console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
					return this.groups;

				}
			},
			offsets: {
				get: function () {

					console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
					return this.groups;

				}
			}

		} );

		//

		Object.defineProperties( Uniform.prototype, {

			dynamic: {
				set: function () {

					console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

				}
			},
			onUpdate: {
				value: function () {

					console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
					return this;

				}
			}

		} );

		//

		Object.defineProperties( Material.prototype, {

			wrapAround: {
				get: function () {

					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

				},
				set: function () {

					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

				}
			},
			wrapRGB: {
				get: function () {

					console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
					return new Color();

				}
			}

		} );

		Object.defineProperties( MeshPhongMaterial.prototype, {

			metal: {
				get: function () {

					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
					return false;

				},
				set: function () {

					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

				}
			}

		} );

		Object.defineProperties( ShaderMaterial.prototype, {

			derivatives: {
				get: function () {

					console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					return this.extensions.derivatives;

				},
				set: function ( value ) {

					console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					this.extensions.derivatives = value;

				}
			}

		} );

		//

		Object.assign( WebGLRenderer.prototype, {

			supportsFloatTextures: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );

			},
			supportsHalfFloatTextures: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );

			},
			supportsStandardDerivatives: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );

			},
			supportsCompressedTextureS3TC: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

			},
			supportsCompressedTexturePVRTC: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			},
			supportsBlendMinMax: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );

			},
			supportsVertexTextures: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
				return this.capabilities.vertexTextures;

			},
			supportsInstancedArrays: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );

			},
			enableScissorTest: function ( boolean ) {

				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );

			},
			initMaterial: function () {

				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

			},
			addPrePlugin: function () {

				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

			},
			addPostPlugin: function () {

				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

			},
			updateShadowMap: function () {

				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

			}

		} );

		Object.defineProperties( WebGLRenderer.prototype, {

			shadowMapEnabled: {
				get: function () {

					return this.shadowMap.enabled;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					this.shadowMap.enabled = value;

				}
			},
			shadowMapType: {
				get: function () {

					return this.shadowMap.type;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					this.shadowMap.type = value;

				}
			},
			shadowMapCullFace: {
				get: function () {

					return this.shadowMap.cullFace;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					this.shadowMap.cullFace = value;

				}
			}
		} );

		Object.defineProperties( WebGLShadowMap.prototype, {

			cullFace: {
				get: function () {

					return this.renderReverseSided ? CullFaceFront : CullFaceBack;

				},
				set: function ( cullFace ) {

					var value = ( cullFace !== CullFaceBack );
					console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
					this.renderReverseSided = value;

				}
			}

		} );

		//

		Object.defineProperties( WebGLRenderTarget.prototype, {

			wrapS: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					return this.texture.wrapS;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					this.texture.wrapS = value;

				}
			},
			wrapT: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					return this.texture.wrapT;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					this.texture.wrapT = value;

				}
			},
			magFilter: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					return this.texture.magFilter;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					this.texture.magFilter = value;

				}
			},
			minFilter: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					return this.texture.minFilter;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					this.texture.minFilter = value;

				}
			},
			anisotropy: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					return this.texture.anisotropy;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					this.texture.anisotropy = value;

				}
			},
			offset: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					return this.texture.offset;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					this.texture.offset = value;

				}
			},
			repeat: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					return this.texture.repeat;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					this.texture.repeat = value;

				}
			},
			format: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					return this.texture.format;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					this.texture.format = value;

				}
			},
			type: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					return this.texture.type;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					this.texture.type = value;

				}
			},
			generateMipmaps: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					return this.texture.generateMipmaps;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					this.texture.generateMipmaps = value;

				}
			}

		} );

		//

		Audio.prototype.load = function ( file ) {

			console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
			var scope = this;
			var audioLoader = new AudioLoader();
			audioLoader.load( file, function ( buffer ) {

				scope.setBuffer( buffer );

			} );
			return this;

		};

		AudioAnalyser.prototype.getData = function () {

			console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
			return this.getFrequencyData();

		};

		//

		var GeometryUtils = {

			merge: function ( geometry1, geometry2, materialIndexOffset ) {

				console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
				var matrix;

				if ( geometry2.isMesh ) {

					geometry2.matrixAutoUpdate && geometry2.updateMatrix();

					matrix = geometry2.matrix;
					geometry2 = geometry2.geometry;

				}

				geometry1.merge( geometry2, matrix, materialIndexOffset );

			},

			center: function ( geometry ) {

				console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
				return geometry.center();

			}

		};

		var ImageUtils = {

			crossOrigin: undefined,

			loadTexture: function ( url, mapping, onLoad, onError ) {

				console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

				var loader = new TextureLoader();
				loader.setCrossOrigin( this.crossOrigin );

				var texture = loader.load( url, onLoad, undefined, onError );

				if ( mapping ) texture.mapping = mapping;

				return texture;

			},

			loadTextureCube: function ( urls, mapping, onLoad, onError ) {

				console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

				var loader = new CubeTextureLoader();
				loader.setCrossOrigin( this.crossOrigin );

				var texture = loader.load( urls, onLoad, undefined, onError );

				if ( mapping ) texture.mapping = mapping;

				return texture;

			},

			loadCompressedTexture: function () {

				console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

			},

			loadCompressedTextureCube: function () {

				console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

			}

		};

		function Projector() {

			console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

			this.projectVector = function ( vector, camera ) {

				console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
				vector.project( camera );

			};

			this.unprojectVector = function ( vector, camera ) {

				console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
				vector.unproject( camera );

			};

			this.pickingRay = function () {

				console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

			};

		}

		//

		function CanvasRenderer() {

			console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

			this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			this.clear = function () {};
			this.render = function () {};
			this.setClearColor = function () {};
			this.setSize = function () {};

		}

		exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
		exports.WebGLRenderTarget = WebGLRenderTarget;
		exports.WebGLRenderer = WebGLRenderer;
		exports.ShaderLib = ShaderLib;
		exports.UniformsLib = UniformsLib;
		exports.UniformsUtils = UniformsUtils;
		exports.ShaderChunk = ShaderChunk;
		exports.FogExp2 = FogExp2;
		exports.Fog = Fog;
		exports.Scene = Scene;
		exports.LensFlare = LensFlare;
		exports.Sprite = Sprite;
		exports.LOD = LOD;
		exports.SkinnedMesh = SkinnedMesh;
		exports.Skeleton = Skeleton;
		exports.Bone = Bone;
		exports.Mesh = Mesh;
		exports.LineSegments = LineSegments;
		exports.Line = Line;
		exports.Points = Points;
		exports.Group = Group;
		exports.VideoTexture = VideoTexture;
		exports.DataTexture = DataTexture;
		exports.CompressedTexture = CompressedTexture;
		exports.CubeTexture = CubeTexture;
		exports.CanvasTexture = CanvasTexture;
		exports.DepthTexture = DepthTexture;
		exports.Texture = Texture;
		exports.CompressedTextureLoader = CompressedTextureLoader;
		exports.DataTextureLoader = DataTextureLoader;
		exports.CubeTextureLoader = CubeTextureLoader;
		exports.TextureLoader = TextureLoader;
		exports.ObjectLoader = ObjectLoader;
		exports.MaterialLoader = MaterialLoader;
		exports.BufferGeometryLoader = BufferGeometryLoader;
		exports.DefaultLoadingManager = DefaultLoadingManager;
		exports.LoadingManager = LoadingManager;
		exports.JSONLoader = JSONLoader;
		exports.ImageLoader = ImageLoader;
		exports.FontLoader = FontLoader;
		exports.FileLoader = FileLoader;
		exports.Loader = Loader;
		exports.Cache = Cache;
		exports.AudioLoader = AudioLoader;
		exports.SpotLightShadow = SpotLightShadow;
		exports.SpotLight = SpotLight;
		exports.PointLight = PointLight;
		exports.RectAreaLight = RectAreaLight;
		exports.HemisphereLight = HemisphereLight;
		exports.DirectionalLightShadow = DirectionalLightShadow;
		exports.DirectionalLight = DirectionalLight;
		exports.AmbientLight = AmbientLight;
		exports.LightShadow = LightShadow;
		exports.Light = Light;
		exports.StereoCamera = StereoCamera;
		exports.PerspectiveCamera = PerspectiveCamera;
		exports.OrthographicCamera = OrthographicCamera;
		exports.CubeCamera = CubeCamera;
		exports.Camera = Camera;
		exports.AudioListener = AudioListener;
		exports.PositionalAudio = PositionalAudio;
		exports.AudioContext = AudioContext;
		exports.AudioAnalyser = AudioAnalyser;
		exports.Audio = Audio;
		exports.VectorKeyframeTrack = VectorKeyframeTrack;
		exports.StringKeyframeTrack = StringKeyframeTrack;
		exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
		exports.NumberKeyframeTrack = NumberKeyframeTrack;
		exports.ColorKeyframeTrack = ColorKeyframeTrack;
		exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
		exports.PropertyMixer = PropertyMixer;
		exports.PropertyBinding = PropertyBinding;
		exports.KeyframeTrack = KeyframeTrack;
		exports.AnimationUtils = AnimationUtils;
		exports.AnimationObjectGroup = AnimationObjectGroup;
		exports.AnimationMixer = AnimationMixer;
		exports.AnimationClip = AnimationClip;
		exports.Uniform = Uniform;
		exports.InstancedBufferGeometry = InstancedBufferGeometry;
		exports.BufferGeometry = BufferGeometry;
		exports.GeometryIdCount = GeometryIdCount;
		exports.Geometry = Geometry;
		exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
		exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
		exports.InterleavedBuffer = InterleavedBuffer;
		exports.InstancedBufferAttribute = InstancedBufferAttribute;
		exports.Face3 = Face3;
		exports.Object3D = Object3D;
		exports.Raycaster = Raycaster;
		exports.Layers = Layers;
		exports.EventDispatcher = EventDispatcher;
		exports.Clock = Clock;
		exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
		exports.LinearInterpolant = LinearInterpolant;
		exports.DiscreteInterpolant = DiscreteInterpolant;
		exports.CubicInterpolant = CubicInterpolant;
		exports.Interpolant = Interpolant;
		exports.Triangle = Triangle;
		exports.Math = _Math;
		exports.Spherical = Spherical;
		exports.Cylindrical = Cylindrical;
		exports.Plane = Plane;
		exports.Frustum = Frustum;
		exports.Sphere = Sphere;
		exports.Ray = Ray;
		exports.Matrix4 = Matrix4;
		exports.Matrix3 = Matrix3;
		exports.Box3 = Box3;
		exports.Box2 = Box2;
		exports.Line3 = Line3;
		exports.Euler = Euler;
		exports.Vector4 = Vector4;
		exports.Vector3 = Vector3;
		exports.Vector2 = Vector2;
		exports.Quaternion = Quaternion;
		exports.Color = Color;
		exports.MorphBlendMesh = MorphBlendMesh;
		exports.ImmediateRenderObject = ImmediateRenderObject;
		exports.VertexNormalsHelper = VertexNormalsHelper;
		exports.SpotLightHelper = SpotLightHelper;
		exports.SkeletonHelper = SkeletonHelper;
		exports.PointLightHelper = PointLightHelper;
		exports.RectAreaLightHelper = RectAreaLightHelper;
		exports.HemisphereLightHelper = HemisphereLightHelper;
		exports.GridHelper = GridHelper;
		exports.PolarGridHelper = PolarGridHelper;
		exports.FaceNormalsHelper = FaceNormalsHelper;
		exports.DirectionalLightHelper = DirectionalLightHelper;
		exports.CameraHelper = CameraHelper;
		exports.BoxHelper = BoxHelper;
		exports.ArrowHelper = ArrowHelper;
		exports.AxisHelper = AxisHelper;
		exports.CatmullRomCurve3 = CatmullRomCurve3;
		exports.CubicBezierCurve3 = CubicBezierCurve3;
		exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
		exports.LineCurve3 = LineCurve3;
		exports.ArcCurve = ArcCurve;
		exports.EllipseCurve = EllipseCurve;
		exports.SplineCurve = SplineCurve;
		exports.CubicBezierCurve = CubicBezierCurve;
		exports.QuadraticBezierCurve = QuadraticBezierCurve;
		exports.LineCurve = LineCurve;
		exports.Shape = Shape;
		exports.Path = Path;
		exports.ShapePath = ShapePath;
		exports.Font = Font;
		exports.CurvePath = CurvePath;
		exports.Curve = Curve;
		exports.ShapeUtils = ShapeUtils;
		exports.SceneUtils = SceneUtils;
		exports.WireframeGeometry = WireframeGeometry;
		exports.ParametricGeometry = ParametricGeometry;
		exports.ParametricBufferGeometry = ParametricBufferGeometry;
		exports.TetrahedronGeometry = TetrahedronGeometry;
		exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
		exports.OctahedronGeometry = OctahedronGeometry;
		exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
		exports.IcosahedronGeometry = IcosahedronGeometry;
		exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
		exports.DodecahedronGeometry = DodecahedronGeometry;
		exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
		exports.PolyhedronGeometry = PolyhedronGeometry;
		exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
		exports.TubeGeometry = TubeGeometry;
		exports.TubeBufferGeometry = TubeBufferGeometry;
		exports.TorusKnotGeometry = TorusKnotGeometry;
		exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
		exports.TorusGeometry = TorusGeometry;
		exports.TorusBufferGeometry = TorusBufferGeometry;
		exports.TextGeometry = TextGeometry;
		exports.SphereBufferGeometry = SphereBufferGeometry;
		exports.SphereGeometry = SphereGeometry;
		exports.RingGeometry = RingGeometry;
		exports.RingBufferGeometry = RingBufferGeometry;
		exports.PlaneBufferGeometry = PlaneBufferGeometry;
		exports.PlaneGeometry = PlaneGeometry;
		exports.LatheGeometry = LatheGeometry;
		exports.LatheBufferGeometry = LatheBufferGeometry;
		exports.ShapeGeometry = ShapeGeometry;
		exports.ShapeBufferGeometry = ShapeBufferGeometry;
		exports.ExtrudeGeometry = ExtrudeGeometry;
		exports.EdgesGeometry = EdgesGeometry;
		exports.ConeGeometry = ConeGeometry;
		exports.ConeBufferGeometry = ConeBufferGeometry;
		exports.CylinderGeometry = CylinderGeometry;
		exports.CylinderBufferGeometry = CylinderBufferGeometry;
		exports.CircleBufferGeometry = CircleBufferGeometry;
		exports.CircleGeometry = CircleGeometry;
		exports.BoxBufferGeometry = BoxBufferGeometry;
		exports.BoxGeometry = BoxGeometry;
		exports.ShadowMaterial = ShadowMaterial;
		exports.SpriteMaterial = SpriteMaterial;
		exports.RawShaderMaterial = RawShaderMaterial;
		exports.ShaderMaterial = ShaderMaterial;
		exports.PointsMaterial = PointsMaterial;
		exports.MultiMaterial = MultiMaterial;
		exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
		exports.MeshStandardMaterial = MeshStandardMaterial;
		exports.MeshPhongMaterial = MeshPhongMaterial;
		exports.MeshToonMaterial = MeshToonMaterial;
		exports.MeshNormalMaterial = MeshNormalMaterial;
		exports.MeshLambertMaterial = MeshLambertMaterial;
		exports.MeshDepthMaterial = MeshDepthMaterial;
		exports.MeshBasicMaterial = MeshBasicMaterial;
		exports.MeshCubeMaterial = MeshCubeMaterial;
		exports.LineDashedMaterial = LineDashedMaterial;
		exports.LineBasicMaterial = LineBasicMaterial;
		exports.MaterialMap = MaterialMap;
		exports.Material = Material;
		exports.Float64BufferAttribute = Float64BufferAttribute;
		exports.Float32BufferAttribute = Float32BufferAttribute;
		exports.Uint32BufferAttribute = Uint32BufferAttribute;
		exports.Int32BufferAttribute = Int32BufferAttribute;
		exports.Uint16BufferAttribute = Uint16BufferAttribute;
		exports.Int16BufferAttribute = Int16BufferAttribute;
		exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
		exports.Uint8BufferAttribute = Uint8BufferAttribute;
		exports.Int8BufferAttribute = Int8BufferAttribute;
		exports.BufferAttribute = BufferAttribute;
		exports.REVISION = REVISION;
		exports.MOUSE = MOUSE;
		exports.CullFaceNone = CullFaceNone;
		exports.CullFaceBack = CullFaceBack;
		exports.CullFaceFront = CullFaceFront;
		exports.CullFaceFrontBack = CullFaceFrontBack;
		exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
		exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
		exports.BasicShadowMap = BasicShadowMap;
		exports.PCFShadowMap = PCFShadowMap;
		exports.PCFSoftShadowMap = PCFSoftShadowMap;
		exports.PCSSSoftShadowMap = PCSSSoftShadowMap;
		exports.FrontSide = FrontSide;
		exports.BackSide = BackSide;
		exports.DoubleSide = DoubleSide;
		exports.FlatShading = FlatShading;
		exports.SmoothShading = SmoothShading;
		exports.NoColors = NoColors;
		exports.FaceColors = FaceColors;
		exports.VertexColors = VertexColors;
		exports.NoBlending = NoBlending;
		exports.NormalBlending = NormalBlending;
		exports.AdditiveBlending = AdditiveBlending;
		exports.SubtractiveBlending = SubtractiveBlending;
		exports.MultiplyBlending = MultiplyBlending;
		exports.CustomBlending = CustomBlending;
		exports.AddEquation = AddEquation;
		exports.SubtractEquation = SubtractEquation;
		exports.ReverseSubtractEquation = ReverseSubtractEquation;
		exports.MinEquation = MinEquation;
		exports.MaxEquation = MaxEquation;
		exports.ZeroFactor = ZeroFactor;
		exports.OneFactor = OneFactor;
		exports.SrcColorFactor = SrcColorFactor;
		exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
		exports.SrcAlphaFactor = SrcAlphaFactor;
		exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
		exports.DstAlphaFactor = DstAlphaFactor;
		exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
		exports.DstColorFactor = DstColorFactor;
		exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
		exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
		exports.NeverDepth = NeverDepth;
		exports.AlwaysDepth = AlwaysDepth;
		exports.LessDepth = LessDepth;
		exports.LessEqualDepth = LessEqualDepth;
		exports.EqualDepth = EqualDepth;
		exports.GreaterEqualDepth = GreaterEqualDepth;
		exports.GreaterDepth = GreaterDepth;
		exports.NotEqualDepth = NotEqualDepth;
		exports.MultiplyOperation = MultiplyOperation;
		exports.MixOperation = MixOperation;
		exports.AddOperation = AddOperation;
		exports.NoToneMapping = NoToneMapping;
		exports.LinearToneMapping = LinearToneMapping;
		exports.ReinhardToneMapping = ReinhardToneMapping;
		exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
		exports.CineonToneMapping = CineonToneMapping;
		exports.UVMapping = UVMapping;
		exports.CubeReflectionMapping = CubeReflectionMapping;
		exports.CubeRefractionMapping = CubeRefractionMapping;
		exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
		exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
		exports.SphericalReflectionMapping = SphericalReflectionMapping;
		exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
		exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
		exports.RepeatWrapping = RepeatWrapping;
		exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
		exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
		exports.NearestFilter = NearestFilter;
		exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
		exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
		exports.LinearFilter = LinearFilter;
		exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
		exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
		exports.UnsignedByteType = UnsignedByteType;
		exports.ByteType = ByteType;
		exports.ShortType = ShortType;
		exports.UnsignedShortType = UnsignedShortType;
		exports.IntType = IntType;
		exports.UnsignedIntType = UnsignedIntType;
		exports.FloatType = FloatType;
		exports.HalfFloatType = HalfFloatType;
		exports.UnsignedShort4444Type = UnsignedShort4444Type;
		exports.UnsignedShort5551Type = UnsignedShort5551Type;
		exports.UnsignedShort565Type = UnsignedShort565Type;
		exports.UnsignedInt248Type = UnsignedInt248Type;
		exports.AlphaFormat = AlphaFormat;
		exports.RGBFormat = RGBFormat;
		exports.RGBAFormat = RGBAFormat;
		exports.LuminanceFormat = LuminanceFormat;
		exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
		exports.RGBEFormat = RGBEFormat;
		exports.DepthFormat = DepthFormat;
		exports.DepthStencilFormat = DepthStencilFormat;
		exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
		exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
		exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
		exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
		exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
		exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
		exports.RGB_ETC1_Format = RGB_ETC1_Format;
		exports.LoopOnce = LoopOnce;
		exports.LoopRepeat = LoopRepeat;
		exports.LoopPingPong = LoopPingPong;
		exports.InterpolateDiscrete = InterpolateDiscrete;
		exports.InterpolateLinear = InterpolateLinear;
		exports.InterpolateSmooth = InterpolateSmooth;
		exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
		exports.ZeroSlopeEnding = ZeroSlopeEnding;
		exports.WrapAroundEnding = WrapAroundEnding;
		exports.TrianglesDrawMode = TrianglesDrawMode;
		exports.TriangleStripDrawMode = TriangleStripDrawMode;
		exports.TriangleFanDrawMode = TriangleFanDrawMode;
		exports.LinearEncoding = LinearEncoding;
		exports.sRGBEncoding = sRGBEncoding;
		exports.GammaEncoding = GammaEncoding;
		exports.RGBEEncoding = RGBEEncoding;
		exports.LogLuvEncoding = LogLuvEncoding;
		exports.RGBM7Encoding = RGBM7Encoding;
		exports.RGBM16Encoding = RGBM16Encoding;
		exports.RGBDEncoding = RGBDEncoding;
		exports.BasicDepthPacking = BasicDepthPacking;
		exports.RGBADepthPacking = RGBADepthPacking;
		exports.CubeGeometry = BoxGeometry;
		exports.Face4 = Face4;
		exports.LineStrip = LineStrip;
		exports.LinePieces = LinePieces;
		exports.MeshFaceMaterial = MeshFaceMaterial;
		exports.PointCloud = PointCloud;
		exports.Particle = Particle;
		exports.ParticleSystem = ParticleSystem;
		exports.PointCloudMaterial = PointCloudMaterial;
		exports.ParticleBasicMaterial = ParticleBasicMaterial;
		exports.ParticleSystemMaterial = ParticleSystemMaterial;
		exports.Vertex = Vertex;
		exports.DynamicBufferAttribute = DynamicBufferAttribute;
		exports.Int8Attribute = Int8Attribute;
		exports.Uint8Attribute = Uint8Attribute;
		exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
		exports.Int16Attribute = Int16Attribute;
		exports.Uint16Attribute = Uint16Attribute;
		exports.Int32Attribute = Int32Attribute;
		exports.Uint32Attribute = Uint32Attribute;
		exports.Float32Attribute = Float32Attribute;
		exports.Float64Attribute = Float64Attribute;
		exports.ClosedSplineCurve3 = ClosedSplineCurve3;
		exports.SplineCurve3 = SplineCurve3;
		exports.Spline = Spline;
		exports.BoundingBoxHelper = BoundingBoxHelper;
		exports.EdgesHelper = EdgesHelper;
		exports.WireframeHelper = WireframeHelper;
		exports.XHRLoader = XHRLoader;
		exports.BinaryTextureLoader = BinaryTextureLoader;
		exports.GeometryUtils = GeometryUtils;
		exports.ImageUtils = ImageUtils;
		exports.Projector = Projector;
		exports.CanvasRenderer = CanvasRenderer;

		Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ },
/* 66 */
/*!**********************************************************!*\
  !*** ./~/rollbar-browser/dist/rollbar.umd.nojson.min.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	!function(e,r){if(true)module.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{var t=r();for(var n in t)("object"==typeof exports?exports:e)[n]=t[n]}}(this,function(){return function(e){function r(n){if(t[n])return t[n].exports;var o=t[n]={exports:{},id:n,loaded:!1};return e[n].call(o.exports,o,o.exports,r),o.loaded=!0,o.exports}var t={};return r.m=e,r.c=t,r.p="",r(0)}([function(e,r,t){e.exports=t(1)},function(e,r,t){"use strict";function n(){var e="undefined"==typeof JSON?{}:JSON;o.setupJSON(e)}var o=t(2),i=t(3);n();var a=window._rollbarConfig,s=a&&a.globalAlias||"Rollbar",u=window[s]&&"undefined"!=typeof window[s].shimId;!u&&a?o.wrapper.init(a):(window.Rollbar=o.wrapper,window.RollbarNotifier=i.Notifier),e.exports=o.wrapper},function(e,r,t){"use strict";function n(e,r,t){!t[4]&&window._rollbarWrappedError&&(t[4]=window._rollbarWrappedError,window._rollbarWrappedError=null),e.uncaughtError.apply(e,t),r&&r.apply(window,t)}function o(e,r){if(r.hasOwnProperty&&r.hasOwnProperty("addEventListener")){var t=r.addEventListener;r.addEventListener=function(r,n,o){t.call(this,r,e.wrap(n),o)};var n=r.removeEventListener;r.removeEventListener=function(e,r,t){n.call(this,e,r&&r._wrapped||r,t)}}}var i=t(3),a=t(8),s=i.Notifier;window._rollbarWrappedError=null;var u={};u.init=function(e,r){var t=new s(r);if(t.configure(e),e.captureUncaught){var i;r&&a.isType(r._rollbarOldOnError,"function")?i=r._rollbarOldOnError:window.onerror&&!window.onerror.belongsToShim&&(i=window.onerror),window.onerror=function(){var e=Array.prototype.slice.call(arguments,0);n(t,i,e)};var u,c,l=["EventTarget","Window","Node","ApplicationCache","AudioTrackList","ChannelMergerNode","CryptoOperation","EventSource","FileReader","HTMLUnknownElement","IDBDatabase","IDBRequest","IDBTransaction","KeyOperation","MediaController","MessagePort","ModalWindow","Notification","SVGElementInstance","Screen","TextTrack","TextTrackCue","TextTrackList","WebSocket","WebSocketWorker","Worker","XMLHttpRequest","XMLHttpRequestEventTarget","XMLHttpRequestUpload"];for(u=0;u<l.length;++u)c=l[u],window[c]&&window[c].prototype&&o(t,window[c].prototype)}return e.captureUnhandledRejections&&(r&&a.isType(r._unhandledRejectionHandler,"function")&&window.removeEventListener("unhandledrejection",r._unhandledRejectionHandler),t._unhandledRejectionHandler=function(e){var r=e.reason,n=e.promise,o=e.detail;!r&&o&&(r=o.reason,n=o.promise),t.unhandledRejection(r,n)},window.addEventListener("unhandledrejection",t._unhandledRejectionHandler)),window.Rollbar=t,s.processPayloads(),t},e.exports={wrapper:u,setupJSON:i.setupJSON}},function(e,r,t){"use strict";function n(e){E=e,w.setupJSON(e)}function o(e,r){return function(){var t=r||this;try{return e.apply(t,arguments)}catch(n){console.error("[Rollbar]:",n)}}}function i(){h||(h=setTimeout(f,1e3))}function a(){return _}function s(e){_=_||this;var r="https://"+s.DEFAULT_ENDPOINT;this.options={enabled:!0,endpoint:r,environment:"production",scrubFields:g([],s.DEFAULT_SCRUB_FIELDS),checkIgnore:null,logLevel:s.DEFAULT_LOG_LEVEL,reportLevel:s.DEFAULT_REPORT_LEVEL,uncaughtErrorLevel:s.DEFAULT_UNCAUGHT_ERROR_LEVEL,payload:{}},this.lastError=null,this.plugins={},this.parentNotifier=e,e&&(e.hasOwnProperty("shimId")?e.notifier=this:this.configure(e.options))}function u(e){window._rollbarPayloadQueue.push(e),i()}function c(e){return o(function(){var r=this._getLogArgs(arguments);return this._log(e||r.level||this.options.logLevel||s.DEFAULT_LOG_LEVEL,r.message,r.err,r.custom,r.callback)})}function l(e,r){e||(e=r?E.stringify(r):"");var t={body:e};return r&&(t.extra=g(!0,{},r)),{message:t}}function p(e,r,t){var n=m.guessErrorClass(r.message),o=r.name||n[0],i=n[1],a={exception:{"class":o,message:i}};if(e&&(a.exception.description=e||"uncaught exception"),r.stack){var s,u,c,p,f,d,h,w;for(a.frames=[],h=0;h<r.stack.length;++h)s=r.stack[h],u={filename:s.url?v.sanitizeUrl(s.url):"(unknown)",lineno:s.line||null,method:s.func&&"?"!==s.func?s.func:"[anonymous]",colno:s.column},c=p=f=null,d=s.context?s.context.length:0,d&&(w=Math.floor(d/2),p=s.context.slice(0,w),c=s.context[w],f=s.context.slice(w)),c&&(u.code=c),(p||f)&&(u.context={},p&&p.length&&(u.context.pre=p),f&&f.length&&(u.context.post=f)),s.args&&(u.args=s.args),a.frames.push(u);return a.frames.reverse(),t&&(a.extra=g(!0,{},t)),{trace:a}}return l(o+": "+i,t)}function f(){var e;try{for(;e=window._rollbarPayloadQueue.shift();)d(e)}finally{h=void 0}}function d(e){var r=e.endpointUrl,t=e.accessToken,n=e.payload,o=e.callback||function(){},i=(new Date).getTime();i-L>=6e4&&(L=i,R=0);var a=window._globalRollbarOptions.maxItems,c=window._globalRollbarOptions.itemsPerMinute,l=function(){return!n.ignoreRateLimit&&a>=1&&T>=a},p=function(){return!n.ignoreRateLimit&&c>=1&&R>=c};return l()?void o(new Error(a+" max items reached")):p()?void o(new Error(c+" items per minute reached")):(T++,R++,l()&&_._log(_.options.uncaughtErrorLevel,"maxItems has been hit. Ignoring errors for the remainder of the current page load.",null,{maxItems:a},null,!1,!0),n.ignoreRateLimit&&delete n.ignoreRateLimit,void y.post(r,t,n,function(r,t){return r?(r instanceof b&&(e.callback=function(){},setTimeout(function(){u(e)},s.RETRY_DELAY)),o(r)):o(null,t)}))}var h,g=t(4),m=t(5),v=t(8),w=t(10),y=w.XHR,b=w.ConnectionError,E=null;s.NOTIFIER_VERSION="1.9.2",s.DEFAULT_ENDPOINT="api.rollbar.com/api/1/",s.DEFAULT_SCRUB_FIELDS=["pw","pass","passwd","password","secret","confirm_password","confirmPassword","password_confirmation","passwordConfirmation","access_token","accessToken","secret_key","secretKey","secretToken"],s.DEFAULT_LOG_LEVEL="debug",s.DEFAULT_REPORT_LEVEL="debug",s.DEFAULT_UNCAUGHT_ERROR_LEVEL="error",s.DEFAULT_ITEMS_PER_MIN=60,s.DEFAULT_MAX_ITEMS=0,s.LEVELS={debug:0,info:1,warning:2,error:3,critical:4},s.RETRY_DELAY=1e4,window._rollbarPayloadQueue=window._rollbarPayloadQueue||[],window._globalRollbarOptions={startTime:(new Date).getTime(),maxItems:s.DEFAULT_MAX_ITEMS,itemsPerMinute:s.DEFAULT_ITEMS_PER_MIN};var _,x=s.prototype;x._getLogArgs=function(e){for(var r,t,n,i,a,u,c=this.options.logLevel||s.DEFAULT_LOG_LEVEL,l=[],p=0;p<e.length;++p)u=e[p],a=v.typeName(u),"string"===a?r?l.push(u):r=u:"function"===a?i=o(u,this):"date"===a?l.push(u):"error"===a||u instanceof Error||"undefined"!=typeof DOMException&&u instanceof DOMException?t?l.push(u):t=u:"object"!==a&&"array"!==a||(n?l.push(u):n=u);return l.length&&(n=n||{},n.extraArgs=l),{level:c,message:r,err:t,custom:n,callback:i}},x._route=function(e){var r=this.options.endpoint,t=/\/$/.test(r),n=/^\//.test(e);return t&&n?e=e.substring(1):t||n||(e="/"+e),r+e},x._processShimQueue=function(e){for(var r,t,n,o,i,a,u,c={};t=e.shift();)r=t.shim,n=t.method,o=t.args,i=r.parentShim,u=c[r.shimId],u||(i?(a=c[i.shimId],u=new s(a)):u=this,c[r.shimId]=u),u[n]&&v.isType(u[n],"function")&&u[n].apply(u,o)},x._buildPayload=function(e,r,t,n,o){var i=this.options.accessToken,a=this.options.environment,u=g(!0,{},this.options.payload),c=v.uuid4();if(void 0===s.LEVELS[r])throw new Error("Invalid level");if(!t&&!n&&!o)throw new Error("No message, stack info or custom data");var l={environment:a,endpoint:this.options.endpoint,uuid:c,level:r,platform:"browser",framework:"browser-js",language:"javascript",body:this._buildBody(t,n,o),request:{url:window.location.href,query_string:window.location.search,user_ip:"$remote_ip"},client:{runtime_ms:e.getTime()-window._globalRollbarOptions.startTime,timestamp:Math.round(e.getTime()/1e3),javascript:{browser:window.navigator.userAgent,language:window.navigator.language,cookie_enabled:window.navigator.cookieEnabled,screen:{width:window.screen.width,height:window.screen.height},plugins:this._getBrowserPlugins()}},server:{},notifier:{name:"rollbar-browser-js",version:s.NOTIFIER_VERSION}};u.body&&delete u.body;var p={access_token:i,data:g(!0,l,u)};return this._scrub(p.data),p},x._buildBody=function(e,r,t){var n;return n=r?p(e,r,t):l(e,t)},x._getBrowserPlugins=function(){if(!this._browserPlugins){var e,r,t=window.navigator.plugins||[],n=t.length,o=[];for(r=0;r<n;++r)e=t[r],o.push({name:e.name,description:e.description});this._browserPlugins=o}return this._browserPlugins},x._scrub=function(e){function r(e,r,t,n,o,i){return r+v.redact(i)}function t(e){var t;if(v.isType(e,"string"))for(t=0;t<s.length;++t)e=e.replace(s[t],r);return e}function n(e,r){var t;for(t=0;t<a.length;++t)if(a[t].test(e)){r=v.redact(r);break}return r}function o(e,r){var o=n(e,r);return o===r?t(o):o}var i=this.options.scrubFields,a=this._getScrubFieldRegexs(i),s=this._getScrubQueryParamRegexs(i);return v.traverse(e,o),e},x._getScrubFieldRegexs=function(e){for(var r,t=[],n=0;n<e.length;++n)r="\\[?(%5[bB])?"+e[n]+"\\[?(%5[bB])?\\]?(%5[dD])?",t.push(new RegExp(r,"i"));return t},x._getScrubQueryParamRegexs=function(e){for(var r,t=[],n=0;n<e.length;++n)r="\\[?(%5[bB])?"+e[n]+"\\[?(%5[bB])?\\]?(%5[dD])?",t.push(new RegExp("("+r+"=)([^&\\n]+)","igm"));return t},x._urlIsWhitelisted=function(e){var r,t,n,o,i,a,s,u,c,l;try{if(r=this.options.hostWhiteList,t=e&&e.data&&e.data.body&&e.data.body.trace,!r||0===r.length)return!0;if(!t)return!0;for(s=r.length,i=t.frames.length,c=0;c<i;c++){if(n=t.frames[c],o=n.filename,!v.isType(o,"string"))return!0;for(l=0;l<s;l++)if(a=r[l],u=new RegExp(a),u.test(o))return!0}}catch(p){return this.configure({hostWhiteList:null}),console.error("[Rollbar]: Error while reading your configuration's hostWhiteList option. Removing custom hostWhiteList.",p),!0}return!1},x._messageIsIgnored=function(e){var r,t,n,o,i,a,s,u,c;try{if(i=!1,n=this.options.ignoredMessages,!n||0===n.length)return!1;if(s=e&&e.data&&e.data.body,u=s&&s.trace&&s.trace.exception&&s.trace.exception.message,c=s&&s.message&&s.message.body,r=u||c,!r)return!1;for(o=n.length,t=0;t<o&&(a=new RegExp(n[t],"gi"),!(i=a.test(r)));t++);}catch(l){this.configure({ignoredMessages:null}),console.error("[Rollbar]: Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.")}return i},x._enqueuePayload=function(e,r,t,n){var o={callback:n,accessToken:this.options.accessToken,endpointUrl:this._route("item/"),payload:e},i=function(){if(n){var e="This item was not sent to Rollbar because it was ignored. This can happen if a custom checkIgnore() function was used or if the item's level was less than the notifier' reportLevel. See https://rollbar.com/docs/notifier/rollbar.js/configuration for more details.";n(null,{err:0,result:{id:null,uuid:null,message:e}})}};if(this._internalCheckIgnore(r,t,e))return void i();try{if(v.isType(this.options.checkIgnore,"function")&&this.options.checkIgnore(r,t,e))return void i()}catch(a){this.configure({checkIgnore:null}),console.error("[Rollbar]: Error while calling custom checkIgnore() function. Removing custom checkIgnore().",a)}if(this._urlIsWhitelisted(e)&&!this._messageIsIgnored(e)){if(this.options.verbose){if(e.data&&e.data.body&&e.data.body.trace){var s=e.data.body.trace,c=s.exception.message;console.error("[Rollbar]: ",c)}console.info("[Rollbar]: ",o)}v.isType(this.options.logFunction,"function")&&this.options.logFunction(o);try{v.isType(this.options.transform,"function")&&this.options.transform(e)}catch(a){this.configure({transform:null}),console.error("[Rollbar]: Error while calling custom transform() function. Removing custom transform().",a)}this.options.enabled&&u(o)}},x._internalCheckIgnore=function(e,r,t){var n=r[0],o=s.LEVELS[n]||0,i=s.LEVELS[this.options.reportLevel]||0;if(o<i)return!0;var a=this.options?this.options.plugins:{};if(a&&a.jquery&&a.jquery.ignoreAjaxErrors)try{return!!t.data.body.message.extra.isAjax}catch(u){return!1}return!1},x._log=function(e,r,t,n,o,i,a){var s=null;if(t)try{if(s=t._savedStackTrace?t._savedStackTrace:m.parse(t),t===this.lastError)return;this.lastError=t}catch(u){console.error("[Rollbar]: Error while parsing the error object.",u),r=t.message||t.description||r||String(t),t=null}var c=this._buildPayload(new Date,e,r,s,n);a&&(c.ignoreRateLimit=!0),this._enqueuePayload(c,!!i,[e,r,t,n],o)},x.log=c(),x.debug=c("debug"),x.info=c("info"),x.warn=c("warning"),x.warning=c("warning"),x.error=c("error"),x.critical=c("critical"),x.uncaughtError=o(function(e,r,t,n,o,i){if(i=i||null,o&&v.isType(o,"error"))return void this._log(this.options.uncaughtErrorLevel,e,o,i,null,!0);if(r&&v.isType(r,"error"))return void this._log(this.options.uncaughtErrorLevel,e,r,i,null,!0);var a={url:r||"",line:t};a.func=m.guessFunctionName(a.url,a.line),a.context=m.gatherContext(a.url,a.line);var s={mode:"onerror",message:o?String(o):e||"uncaught exception",url:document.location.href,stack:[a],useragent:navigator.userAgent},u=this._buildPayload(new Date,this.options.uncaughtErrorLevel,e,s,i);this._enqueuePayload(u,!0,[this.options.uncaughtErrorLevel,e,r,t,n,o])}),x.unhandledRejection=o(function(e,r){if(null==e)return void _._log(_.options.uncaughtErrorLevel,"unhandled rejection was null or undefined!",null,{},null,!1,!1);var t=e.message||(e?String(e):"unhandled rejection"),n=e._rollbarContext||r._rollbarContext||null;if(e&&v.isType(e,"error"))return void this._log(this.options.uncaughtErrorLevel,t,e,n,null,!0);var o={url:"",line:0};o.func=m.guessFunctionName(o.url,o.line),o.context=m.gatherContext(o.url,o.line);var i={mode:"unhandledrejection",message:t,url:document.location.href,stack:[o],useragent:navigator.userAgent},a=this._buildPayload(new Date,this.options.uncaughtErrorLevel,t,i,n);this._enqueuePayload(a,!0,[this.options.uncaughtErrorLevel,t,o.url,o.line,0,e,r])}),x.global=o(function(e){e=e||{};var r={startTime:e.startTime,maxItems:e.maxItems,itemsPerMinute:e.itemsPerMinute};g(!0,window._globalRollbarOptions,r),void 0!==e.maxItems&&(T=0),void 0!==e.itemsPerMinute&&(R=0)}),x.configure=o(function(e,r){var t=g(!0,{},e);g(!r,this.options,t),this.global(t)}),x.scope=o(function(e){var r=new s(this);return g(!0,r.options.payload,e),r}),x.wrap=function(e,r){try{var t;if(t=v.isType(r,"function")?r:function(){return r||{}},!v.isType(e,"function"))return e;if(e._isWrap)return e;if(!e._wrapped){e._wrapped=function(){try{return e.apply(this,arguments)}catch(r){throw"string"==typeof r&&(r=new String(r)),r.stack||(r._savedStackTrace=m.parse(r)),r._rollbarContext=t()||{},r._rollbarContext._wrappedSource=e.toString(),window._rollbarWrappedError=r,r}},e._wrapped._isWrap=!0;for(var n in e)e.hasOwnProperty(n)&&(e._wrapped[n]=e[n])}return e._wrapped}catch(o){return e}},x.loadFull=function(){console.error("[Rollbar]: Unexpected Rollbar.loadFull() called on a Notifier instance")},s.processPayloads=function(e){return e?void f():void i()};var L=(new Date).getTime(),T=0,R=0;e.exports={Notifier:s,setupJSON:n,topLevelNotifier:a}},function(e,r){"use strict";var t=Object.prototype.hasOwnProperty,n=Object.prototype.toString,o=function(e){return"function"==typeof Array.isArray?Array.isArray(e):"[object Array]"===n.call(e)},i=function(e){if(!e||"[object Object]"!==n.call(e))return!1;var r=t.call(e,"constructor"),o=e.constructor&&e.constructor.prototype&&t.call(e.constructor.prototype,"isPrototypeOf");if(e.constructor&&!r&&!o)return!1;var i;for(i in e);return"undefined"==typeof i||t.call(e,i)};e.exports=function a(){var e,r,t,n,s,u,c=arguments[0],l=1,p=arguments.length,f=!1;for("boolean"==typeof c?(f=c,c=arguments[1]||{},l=2):("object"!=typeof c&&"function"!=typeof c||null==c)&&(c={});l<p;++l)if(e=arguments[l],null!=e)for(r in e)t=c[r],n=e[r],c!==n&&(f&&n&&(i(n)||(s=o(n)))?(s?(s=!1,u=t&&o(t)?t:[]):u=t&&i(t)?t:{},c[r]=a(f,u,n)):"undefined"!=typeof n&&(c[r]=n));return c}},function(e,r,t){"use strict";function n(){return l}function o(){return null}function i(e){var r={};return r._stackFrame=e,r.url=e.fileName,r.line=e.lineNumber,r.func=e.functionName,r.column=e.columnNumber,r.args=e.args,r.context=o(r.url,r.line),r}function a(e){function r(){var r=[];try{r=c.parse(e)}catch(t){r=[]}for(var n=[],o=0;o<r.length;o++)n.push(new i(r[o]));return n}return{stack:r(),message:e.message,name:e.name}}function s(e){return new a(e)}function u(e){if(!e)return["Unknown error. There was no error message to display.",""];var r=e.match(p),t="(unknown)";return r&&(t=r[r.length-1],e=e.replace((r[r.length-2]||"")+t+":",""),e=e.replace(/(^[\s]+|[\s]+$)/g,"")),[t,e]}var c=t(6),l="?",p=new RegExp("^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): ");e.exports={guessFunctionName:n,guessErrorClass:u,gatherContext:o,parse:s,Stack:a,Frame:i}},function(e,r,t){var n,o,i;!function(a,s){"use strict";o=[t(7)],n=s,i="function"==typeof n?n.apply(r,o):n,!(void 0!==i&&(e.exports=i))}(this,function(e){"use strict";function r(e,r,t){if("function"==typeof Array.prototype.map)return e.map(r,t);for(var n=new Array(e.length),o=0;o<e.length;o++)n[o]=r.call(t,e[o]);return n}function t(e,r,t){if("function"==typeof Array.prototype.filter)return e.filter(r,t);for(var n=[],o=0;o<e.length;o++)r.call(t,e[o])&&n.push(e[o]);return n}var n=/(^|@)\S+\:\d+/,o=/^\s*at .*(\S+\:\d+|\(native\))/m,i=/^(eval@)?(\[native code\])?$/;return{parse:function(e){if("undefined"!=typeof e.stacktrace||"undefined"!=typeof e["opera#sourceloc"])return this.parseOpera(e);if(e.stack&&e.stack.match(o))return this.parseV8OrIE(e);if(e.stack)return this.parseFFOrSafari(e);throw new Error("Cannot parse given Error object")},extractLocation:function(e){if(e.indexOf(":")===-1)return[e];var r=e.replace(/[\(\)\s]/g,"").split(":"),t=r.pop(),n=r[r.length-1];if(!isNaN(parseFloat(n))&&isFinite(n)){var o=r.pop();return[r.join(":"),o,t]}return[r.join(":"),t,void 0]},parseV8OrIE:function(n){var i=t(n.stack.split("\n"),function(e){return!!e.match(o)},this);return r(i,function(r){r.indexOf("(eval ")>-1&&(r=r.replace(/eval code/g,"eval").replace(/(\(eval at [^\()]*)|(\)\,.*$)/g,""));var t=r.replace(/^\s+/,"").replace(/\(eval code/g,"(").split(/\s+/).slice(1),n=this.extractLocation(t.pop()),o=t.join(" ")||void 0,i="eval"===n[0]?void 0:n[0];return new e(o,(void 0),i,n[1],n[2],r)},this)},parseFFOrSafari:function(n){var o=t(n.stack.split("\n"),function(e){return!e.match(i)},this);return r(o,function(r){if(r.indexOf(" > eval")>-1&&(r=r.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g,":$1")),r.indexOf("@")===-1&&r.indexOf(":")===-1)return new e(r);var t=r.split("@"),n=this.extractLocation(t.pop()),o=t.shift()||void 0;return new e(o,(void 0),n[0],n[1],n[2],r)},this)},parseOpera:function(e){return!e.stacktrace||e.message.indexOf("\n")>-1&&e.message.split("\n").length>e.stacktrace.split("\n").length?this.parseOpera9(e):e.stack?this.parseOpera11(e):this.parseOpera10(e)},parseOpera9:function(r){for(var t=/Line (\d+).*script (?:in )?(\S+)/i,n=r.message.split("\n"),o=[],i=2,a=n.length;i<a;i+=2){var s=t.exec(n[i]);s&&o.push(new e((void 0),(void 0),s[2],s[1],(void 0),n[i]))}return o},parseOpera10:function(r){for(var t=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,n=r.stacktrace.split("\n"),o=[],i=0,a=n.length;i<a;i+=2){var s=t.exec(n[i]);s&&o.push(new e(s[3]||void 0,(void 0),s[2],s[1],(void 0),n[i]))}return o},parseOpera11:function(o){var i=t(o.stack.split("\n"),function(e){return!!e.match(n)&&!e.match(/^Error created at/)},this);return r(i,function(r){var t,n=r.split("@"),o=this.extractLocation(n.pop()),i=n.shift()||"",a=i.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^\)]*\)/g,"")||void 0;i.match(/\(([^\)]*)\)/)&&(t=i.replace(/^[^\(]+\(([^\)]*)\)$/,"$1"));var s=void 0===t||"[arguments not available]"===t?void 0:t.split(",");return new e(a,s,o[0],o[1],o[2],r)},this)}}})},function(e,r,t){var n,o,i;!function(t,a){"use strict";o=[],n=a,i="function"==typeof n?n.apply(r,o):n,!(void 0!==i&&(e.exports=i))}(this,function(){"use strict";function e(e){return!isNaN(parseFloat(e))&&isFinite(e)}function r(e,r,t,n,o,i){void 0!==e&&this.setFunctionName(e),void 0!==r&&this.setArgs(r),void 0!==t&&this.setFileName(t),void 0!==n&&this.setLineNumber(n),void 0!==o&&this.setColumnNumber(o),void 0!==i&&this.setSource(i)}return r.prototype={getFunctionName:function(){return this.functionName},setFunctionName:function(e){this.functionName=String(e)},getArgs:function(){return this.args},setArgs:function(e){if("[object Array]"!==Object.prototype.toString.call(e))throw new TypeError("Args must be an Array");this.args=e},getFileName:function(){return this.fileName},setFileName:function(e){this.fileName=String(e)},getLineNumber:function(){return this.lineNumber},setLineNumber:function(r){if(!e(r))throw new TypeError("Line Number must be a Number");this.lineNumber=Number(r)},getColumnNumber:function(){return this.columnNumber},setColumnNumber:function(r){if(!e(r))throw new TypeError("Column Number must be a Number");this.columnNumber=Number(r)},getSource:function(){return this.source},setSource:function(e){this.source=String(e)},toString:function(){var r=this.getFunctionName()||"{anonymous}",t="("+(this.getArgs()||[]).join(",")+")",n=this.getFileName()?"@"+this.getFileName():"",o=e(this.getLineNumber())?":"+this.getLineNumber():"",i=e(this.getColumnNumber())?":"+this.getColumnNumber():"";return r+t+n+o+i}},r})},function(e,r,t){"use strict";function n(e){return{}.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}function o(e,r){return n(e)===r}function i(e){if(!o(e,"string"))throw new Error("received invalid input");for(var r=l,t=r.parser[r.strictMode?"strict":"loose"].exec(e),n={},i=14;i--;)n[r.key[i]]=t[i]||"";return n[r.q.name]={},n[r.key[12]].replace(r.q.parser,function(e,t,o){t&&(n[r.q.name][t]=o)}),n}function a(e){var r=i(e);return""===r.anchor&&(r.source=r.source.replace("#","")),e=r.source.replace("?"+r.query,"")}function s(e,r){var t,n,i,a=o(e,"object"),u=o(e,"array"),c=[];if(a)for(t in e)e.hasOwnProperty(t)&&c.push(t);else if(u)for(i=0;i<e.length;++i)c.push(i);for(i=0;i<c.length;++i)t=c[i],n=e[t],a=o(n,"object"),u=o(n,"array"),a||u?e[t]=s(n,r):e[t]=r(t,n);return e}function u(e){return e=String(e),new Array(e.length+1).join("*")}function c(){var e=(new Date).getTime(),r="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(r){var t=(e+16*Math.random())%16|0;return e=Math.floor(e/16),("x"===r?t:7&t|8).toString(16)});return r}t(9);var l={strictMode:!1,key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}},p={isType:o,parseUri:i,parseUriOptions:l,redact:u,sanitizeUrl:a,traverse:s,typeName:n,uuid4:c};e.exports=p},function(e,r){!function(e){"use strict";e.console=e.console||{};for(var r,t,n=e.console,o={},i=function(){},a="memory".split(","),s="assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn".split(",");r=a.pop();)n[r]||(n[r]=o);for(;t=s.pop();)n[t]||(n[t]=i)}("undefined"==typeof window?this:window)},function(e,r,t){"use strict";function n(e){a=e}function o(e){this.name="Connection Error",this.message=e,this.stack=(new Error).stack}var i=t(8),a=null;o.prototype=Object.create(Error.prototype),o.prototype.constructor=o;var s={XMLHttpFactories:[function(){return new XMLHttpRequest},function(){return new ActiveXObject("Msxml2.XMLHTTP")},function(){return new ActiveXObject("Msxml3.XMLHTTP")},function(){return new ActiveXObject("Microsoft.XMLHTTP")}],createXMLHTTPObject:function(){var e,r=!1,t=s.XMLHttpFactories,n=t.length;for(e=0;e<n;e++)try{r=t[e]();break}catch(o){}return r},post:function(e,r,t,n){if(!i.isType(t,"object"))throw new Error("Expected an object to POST");t=a.stringify(t),n=n||function(){};var u=s.createXMLHTTPObject();if(u)try{try{var c=function(){try{if(c&&4===u.readyState){c=void 0;var e=a.parse(u.responseText);200===u.status?n(null,e):i.isType(u.status,"number")&&u.status>=400&&u.status<600?(403==u.status&&console.error("[Rollbar]:"+e.message),n(new Error(String(u.status)))):n(new o("XHR response had no status code (likely connection failure)"))}}catch(r){var t;t=r&&r.stack?r:new Error(r),n(t)}};u.open("POST",e,!0),u.setRequestHeader&&(u.setRequestHeader("Content-Type","application/json"),u.setRequestHeader("X-Rollbar-Access-Token",r)),u.onreadystatechange=c,u.send(t)}catch(l){if("undefined"!=typeof XDomainRequest){"http:"===window.location.href.substring(0,5)&&"https"===e.substring(0,5)&&(e="http"+e.substring(5));var p=function(){n(new o("Request timed out"))},f=function(){n(new Error("Error during request"))},d=function(){n(null,a.parse(u.responseText))};u=new XDomainRequest,u.onprogress=function(){},u.ontimeout=p,u.onerror=f,u.onload=d,u.open("POST",e,!0),u.send(t)}}}catch(h){n(h)}}};e.exports={XHR:s,setupJSON:n,ConnectionError:o}}])});

/***/ },
/* 67 */
/*!***************************************!*\
  !*** ./~/immutable/dist/immutable.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function()
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function()
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue)
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ },
/* 68 */
/*!********************************!*\
  !*** ./~/snabbdom/snabbdom.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	// jshint newcap: false
	/* global require, module, document, Element */
	'use strict';

	var VNode = __webpack_require__(/*! ./vnode */ 69);
	var is = __webpack_require__(/*! ./is */ 70);

	function isUndef(s) { return s === undefined; }
	function isDef(s) { return s !== undefined; }

	function emptyNodeAt(elm) {
	  return VNode(elm.tagName, {}, [], undefined, elm);
	}

	var emptyNode = VNode('', {}, [], undefined, undefined);

	function sameVnode(vnode1, vnode2) {
	  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
	}

	function createKeyToOldIdx(children, beginIdx, endIdx) {
	  var i, map = {}, key;
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) map[key] = i;
	  }
	  return map;
	}

	function createRmCb(childElm, listeners) {
	  return function() {
	    if (--listeners === 0) childElm.parentElement.removeChild(childElm);
	  };
	}

	var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];

	function init(modules) {
	  var i, j, cbs = {};
	  for (i = 0; i < hooks.length; ++i) {
	    cbs[hooks[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
	    }
	  }

	  function createElm(vnode, insertedVnodeQueue) {
	    var i, data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) i(vnode);
	      if (isDef(i = data.vnode)) vnode = i;
	    }
	    var elm, children = vnode.children, sel = vnode.sel;
	    if (isDef(sel)) {
	      // Parse selector
	      var hashIdx = sel.indexOf('#');
	      var dotIdx = sel.indexOf('.', hashIdx);
	      var hash = hashIdx > 0 ? hashIdx : sel.length;
	      var dot = dotIdx > 0 ? dotIdx : sel.length;
	      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
	      elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? document.createElementNS(i, tag)
	                                                          : document.createElement(tag);
	      if (hash < dot) elm.id = sel.slice(hash + 1, dot);
	      if (dotIdx > 0) elm.className = sel.slice(dot+1).replace(/\./g, ' ');
	      if (is.array(children)) {
	        for (i = 0; i < children.length; ++i) {
	          elm.appendChild(createElm(children[i], insertedVnodeQueue));
	        }
	      } else if (is.primitive(vnode.text)) {
	        elm.appendChild(document.createTextNode(vnode.text));
	      }
	      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
	      i = vnode.data.hook; // Reuse variable
	      if (isDef(i)) {
	        if (i.create) i.create(emptyNode, vnode);
	        if (i.insert) insertedVnodeQueue.push(vnode);
	      }
	    } else {
	      elm = vnode.elm = document.createTextNode(vnode.text);
	    }
	    return vnode.elm;
	  }

	  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      parentElm.insertBefore(createElm(vnodes[startIdx], insertedVnodeQueue), before);
	    }
	  }

	  function invokeDestroyHook(vnode) {
	    var i = vnode.data, j;
	    if (isDef(i)) {
	      if (isDef(i = i.hook) && isDef(i = i.destroy)) i(vnode);
	      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
	      if (isDef(i = vnode.children)) {
	        for (j = 0; j < vnode.children.length; ++j) {
	          invokeDestroyHook(vnode.children[j]);
	        }
	      }
	    }
	  }

	  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var i, listeners, rm, ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.sel)) {
	          invokeDestroyHook(ch);
	          listeners = cbs.remove.length + 1;
	          rm = createRmCb(ch.elm, listeners);
	          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
	          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
	            i(ch, rm);
	          } else {
	            rm();
	          }
	        } else { // Text node
	          parentElm.removeChild(ch.elm);
	        }
	      }
	    }
	  }

	  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
	    var oldStartIdx = 0, newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, before;

	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	        idxInOld = oldKeyToIdx[newStartVnode.key];
	        if (isUndef(idxInOld)) { // New element
	          parentElm.insertBefore(createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	          oldCh[idxInOld] = undefined;
	          parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;
	      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }

	  function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
	    var i, hook;
	    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
	      i(oldVnode, vnode);
	    }
	    if (isDef(i = oldVnode.data) && isDef(i = i.vnode)) oldVnode = i;
	    if (isDef(i = vnode.data) && isDef(i = i.vnode)) vnode = i;
	    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;
	    if (oldVnode === vnode) return;
	    if (isDef(vnode.data)) {
	      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
	      i = vnode.data.hook;
	      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
	      } else if (isDef(ch)) {
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      elm.textContent = vnode.text;
	    }
	    if (isDef(hook) && isDef(i = hook.postpatch)) {
	      i(oldVnode, vnode);
	    }
	  }

	  return function(oldVnode, vnode) {
	    var i;
	    var insertedVnodeQueue = [];
	    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();
	    if (oldVnode instanceof Element) {
	      if (oldVnode.parentElement !== null) {
	        createElm(vnode, insertedVnodeQueue);
	        oldVnode.parentElement.replaceChild(vnode.elm, oldVnode);
	      } else {
	        oldVnode = emptyNodeAt(oldVnode);
	        patchVnode(oldVnode, vnode, insertedVnodeQueue);
	      }
	    } else {
	      patchVnode(oldVnode, vnode, insertedVnodeQueue);
	    }
	    for (i = 0; i < insertedVnodeQueue.length; ++i) {
	      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
	    }
	    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
	    return vnode;
	  };
	}

	module.exports = {init: init};


/***/ },
/* 69 */
/*!*****************************!*\
  !*** ./~/snabbdom/vnode.js ***!
  \*****************************/
/***/ function(module, exports) {

	module.exports = function(sel, data, children, text, elm) {
	  var key = data === undefined ? undefined : data.key;
	  return {sel: sel, data: data, children: children,
	          text: text, elm: elm, key: key};
	};


/***/ },
/* 70 */
/*!**************************!*\
  !*** ./~/snabbdom/is.js ***!
  \**************************/
/***/ function(module, exports) {

	module.exports = {
	  array: Array.isArray,
	  primitive: function(s) { return typeof s === 'string' || typeof s === 'number'; },
	};


/***/ },
/* 71 */
/*!*************************!*\
  !*** ./~/snabbdom/h.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	var VNode = __webpack_require__(/*! ./vnode */ 69);
	var is = __webpack_require__(/*! ./is */ 70);

	function addNS(data, children) {
	  data.ns = 'http://www.w3.org/2000/svg';
	  if (children !== undefined) {
	    for (var i = 0; i < children.length; ++i) {
	      addNS(children[i].data, children[i].children);
	    }
	  }
	}

	module.exports = function h(sel, b, c) {
	  var data = {}, children, text, i;
	  if (arguments.length === 3) {
	    data = b;
	    if (is.array(c)) { children = c; }
	    else if (is.primitive(c)) { text = c; }
	  } else if (arguments.length === 2) {
	    if (is.array(b)) { children = b; }
	    else if (is.primitive(b)) { text = b; }
	    else { data = b; }
	  }
	  if (is.array(children)) {
	    for (i = 0; i < children.length; ++i) {
	      if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);
	    }
	  }
	  if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
	    addNS(data, children);
	  }
	  return VNode(sel, data, children, text, undefined);
	};


/***/ },
/* 72 */
/*!*************************************!*\
  !*** ./~/snabbdom/modules/class.js ***!
  \*************************************/
/***/ function(module, exports) {

	function updateClass(oldVnode, vnode) {
	  var cur, name, elm = vnode.elm,
	      oldClass = oldVnode.data.class || {},
	      klass = vnode.data.class || {};
	  for (name in klass) {
	    cur = klass[name];
	    if (cur !== oldClass[name]) {
	      elm.classList[cur ? 'add' : 'remove'](name);
	    }
	  }
	}

	module.exports = {create: updateClass, update: updateClass};


/***/ },
/* 73 */
/*!*************************************!*\
  !*** ./~/snabbdom/modules/props.js ***!
  \*************************************/
/***/ function(module, exports) {

	function updateProps(oldVnode, vnode) {
	  var key, cur, old, elm = vnode.elm,
	      oldProps = oldVnode.data.props || {}, props = vnode.data.props || {};
	  for (key in props) {
	    cur = props[key];
	    old = oldProps[key];
	    if (old !== cur) {
	      elm[key] = cur;
	    }
	  }
	}

	module.exports = {create: updateProps, update: updateProps};


/***/ },
/* 74 */
/*!******************************************!*\
  !*** ./~/snabbdom/modules/attributes.js ***!
  \******************************************/
/***/ function(module, exports) {

	var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare",
	                "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable",
	                "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple",
	                "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly",
	                "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate",
	                "truespeed", "typemustmatch", "visible"];

	var booleanAttrsDict = {};
	for(var i=0, len = booleanAttrs.length; i < len; i++) {
	  booleanAttrsDict[booleanAttrs[i]] = true;
	}

	function updateAttrs(oldVnode, vnode) {
	  var key, cur, old, elm = vnode.elm,
	      oldAttrs = oldVnode.data.attrs || {}, attrs = vnode.data.attrs || {};

	  // update modified attributes, add new attributes
	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      // TODO: add support to namespaced attributes (setAttributeNS)
	      if(!cur && booleanAttrsDict[key])
	        elm.removeAttribute(key);
	      else
	        elm.setAttribute(key, cur);
	    }
	  }
	  //remove removed attributes
	  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
	  // the other option is to remove all attributes with value == undefined
	  for (key in oldAttrs) {
	    if (!(key in attrs)) {
	      elm.removeAttribute(key);
	    }
	  }
	}

	module.exports = {create: updateAttrs, update: updateAttrs};


/***/ },
/* 75 */
/*!*************************************!*\
  !*** ./~/snabbdom/modules/style.js ***!
  \*************************************/
/***/ function(module, exports) {

	var raf = requestAnimationFrame || setTimeout;
	var nextFrame = function(fn) { raf(function() { raf(fn); }); };

	function setNextFrame(obj, prop, val) {
	  nextFrame(function() { obj[prop] = val; });
	}

	function updateStyle(oldVnode, vnode) {
	  var cur, name, elm = vnode.elm,
	      oldStyle = oldVnode.data.style || {},
	      style = vnode.data.style || {},
	      oldHasDel = 'delayed' in oldStyle;
	  for (name in style) {
	    cur = style[name];
	    if (name === 'delayed') {
	      for (name in style.delayed) {
	        cur = style.delayed[name];
	        if (!oldHasDel || cur !== oldStyle.delayed[name]) {
	          setNextFrame(elm.style, name, cur);
	        }
	      }
	    } else if (name !== 'remove' && cur !== oldStyle[name]) {
	      elm.style[name] = cur;
	    }
	  }
	}

	function applyDestroyStyle(vnode) {
	  var style, name, elm = vnode.elm, s = vnode.data.style;
	  if (!s || !(style = s.destroy)) return;
	  for (name in style) {
	    elm.style[name] = style[name];
	  }
	}

	function applyRemoveStyle(vnode, rm) {
	  var s = vnode.data.style;
	  if (!s || !s.remove) {
	    rm();
	    return;
	  }
	  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,
	      compStyle, style = s.remove, amount = 0, applied = [];
	  for (name in style) {
	    applied.push(name);
	    elm.style[name] = style[name];
	  }
	  compStyle = getComputedStyle(elm);
	  var props = compStyle['transition-property'].split(', ');
	  for (; i < props.length; ++i) {
	    if(applied.indexOf(props[i]) !== -1) amount++;
	  }
	  elm.addEventListener('transitionend', function(ev) {
	    if (ev.target === elm) --amount;
	    if (amount === 0) rm();
	  });
	}

	module.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};


/***/ },
/* 76 */
/*!**********************************************!*\
  !*** ./~/snabbdom/modules/eventlisteners.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	var is = __webpack_require__(/*! ../is */ 70);

	function arrInvoker(arr) {
	  return function() {
	    // Special case when length is two, for performance
	    arr.length === 2 ? arr[0](arr[1]) : arr[0].apply(undefined, arr.slice(1));
	  };
	}

	function fnInvoker(o) {
	  return function(ev) { o.fn(ev); };
	}

	function updateEventListeners(oldVnode, vnode) {
	  var name, cur, old, elm = vnode.elm,
	      oldOn = oldVnode.data.on || {}, on = vnode.data.on;
	  if (!on) return;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    if (old === undefined) {
	      if (is.array(cur)) {
	        elm.addEventListener(name, arrInvoker(cur));
	      } else {
	        cur = {fn: cur};
	        on[name] = cur;
	        elm.addEventListener(name, fnInvoker(cur));
	      }
	    } else if (is.array(old)) {
	      // Deliberately modify old array since it's captured in closure created with `arrInvoker`
	      old.length = cur.length;
	      for (var i = 0; i < old.length; ++i) old[i] = cur[i];
	      on[name]  = old;
	    } else {
	      old.fn = cur;
	      on[name] = old;
	    }
	  }
	}

	module.exports = {create: updateEventListeners, update: updateEventListeners};


/***/ },
/* 77 */
/*!***********************************!*\
  !*** ./src/utils/eventEmitter.js ***!
  \***********************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = eventEmitter;
	// Fork of: https://github.com/scottcorgan/tiny-emitter

	/**
	 * Event Emitter
	 * @mixin
	 * @public
	 */
	function eventEmitter() {
	  var e = {};

	  /**
	   *
	   * Subscribe to an event.
	   *
	   * @param {string} name
	   * @param {function} callback
	   * @param {any} [context]
	   * @public
	   * @instance
	   * @memberof eventEmitter
	   */
	  function on(name, callback, context) {
	    (e[name] || (e[name] = [])).push({
	      fn: callback,
	      ctx: context
	    });
	    return this;
	  }

	  /**
	   *
	   * Subscribe to an event only once.
	   *
	   * @param {string} name
	   * @param {function} callback
	   * @param {any} [context]
	   * @memberof eventEmitter
	   * @instance
	   * @public
	   */
	  function once(name, callback, context) {
	    function listener() {
	      off(name, listener);
	      callback.apply(context, arguments);
	    }

	    listener._ = callback;

	    return on(name, listener, context);
	  }

	  /**
	   *
	   * Emit an event
	   *
	   * @param {string} name
	   * @param {any} ...rest arguments for the event
	   * @memberof eventEmitter
	   * @instance
	   * @public
	   */
	  function emit(name) {
	    var data = [].slice.call(arguments, 1);
	    var evtArr = (e[name] || []).slice();
	    var i = 0;
	    var len = evtArr.length;

	    for (i; i < len; i++) {
	      evtArr[i].fn.apply(evtArr[i].ctx, data);
	    }

	    return this;
	  }

	  /**
	   * Unsubscribe from an event or all events.
	   * If no callback is provided, it unsubscribes all callback from this event.
	   *
	   * @param {string} name
	   * @param {function} callback
	   * @memberof eventEmitter
	   * @instance
	   * @public
	   */
	  function off(name, callback) {
	    var evts = e[name];
	    var liveEvents = [];

	    if (evts && callback) {
	      for (var i = 0, len = evts.length; i < len; i++) {
	        if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
	      }
	    }

	    liveEvents.length ? e[name] = liveEvents : delete e[name];

	    return this;
	  }

	  return { on: on, once: once, emit: emit, off: off };
	}

/***/ },
/* 78 */
/*!*************************!*\
  !*** ./vendor/ramda.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	;(function() {

	  'use strict';

	  // jshint unused:vars
	    var _arity = function _arity(n, fn) {
	        // jshint unused:vars
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.apply(this, arguments);
	            };
	        case 1:
	            return function (a0) {
	                return fn.apply(this, arguments);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.apply(this, arguments);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.apply(this, arguments);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.apply(this, arguments);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.apply(this, arguments);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.apply(this, arguments);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.apply(this, arguments);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.apply(this, arguments);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.apply(this, arguments);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.apply(this, arguments);
	            };
	        default:
	            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
	        }
	    };

	    var _arrayFromIterator = function _arrayFromIterator(iter) {
	        var list = [];
	        var next;
	        while (!(next = iter.next()).done) {
	            list.push(next.value);
	        }
	        return list;
	    };

	    /**
	     * Private `concat` function to merge two array-like objects.
	     *
	     * @private
	     * @param {Array|Arguments} [set1=[]] An array-like object.
	     * @param {Array|Arguments} [set2=[]] An array-like object.
	     * @return {Array} A new, merged array.
	     * @example
	     *
	     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     */
	    var _concat = function _concat(set1, set2) {
	        set1 = set1 || [];
	        set2 = set2 || [];
	        var idx;
	        var len1 = set1.length;
	        var len2 = set2.length;
	        var result = [];
	        idx = 0;
	        while (idx < len1) {
	            result[result.length] = set1[idx];
	            idx += 1;
	        }
	        idx = 0;
	        while (idx < len2) {
	            result[result.length] = set2[idx];
	            idx += 1;
	        }
	        return result;
	    };

	    var _filter = function _filter(fn, list) {
	        var idx = 0, len = list.length, result = [];
	        while (idx < len) {
	            if (fn(list[idx])) {
	                result[result.length] = list[idx];
	            }
	            idx += 1;
	        }
	        return result;
	    };

	    var _forceReduced = function _forceReduced(x) {
	        return {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    var _has = function _has(prop, obj) {
	        return Object.prototype.hasOwnProperty.call(obj, prop);
	    };

	    /**
	     * Tests whether or not an object is an array.
	     *
	     * @private
	     * @param {*} val The object to test.
	     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
	     * @example
	     *
	     *      _isArray([]); //=> true
	     *      _isArray(null); //=> false
	     *      _isArray({}); //=> false
	     */
	    var _isArray = Array.isArray || function _isArray(val) {
	        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
	    };

	    var _isPlaceholder = function _isPlaceholder(a) {
	        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
	    };

	    var _isString = function _isString(x) {
	        return Object.prototype.toString.call(x) === '[object String]';
	    };

	    var _isTransformer = function _isTransformer(obj) {
	        return typeof obj['@@transducer/step'] === 'function';
	    };

	    var _map = function _map(fn, functor) {
	        var idx = 0;
	        var len = functor.length;
	        var result = Array(len);
	        while (idx < len) {
	            result[idx] = fn(functor[idx]);
	            idx += 1;
	        }
	        return result;
	    };

	    var _pipe = function _pipe(f, g) {
	        return function () {
	            return g.call(this, f.apply(this, arguments));
	        };
	    };

	    var _reduced = function _reduced(x) {
	        return x && x['@@transducer/reduced'] ? x : {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    /**
	     * An optimized, private array `slice` implementation.
	     *
	     * @private
	     * @param {Arguments|Array} args The array or arguments object to consider.
	     * @param {Number} [from=0] The array index to slice from, inclusive.
	     * @param {Number} [to=args.length] The array index to slice to, exclusive.
	     * @return {Array} A new, sliced array.
	     * @example
	     *
	     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
	     *
	     *      var firstThreeArgs = function(a, b, c, d) {
	     *        return _slice(arguments, 0, 3);
	     *      };
	     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
	     */
	    var _slice = function _slice(args, from, to) {
	        switch (arguments.length) {
	        case 1:
	            return _slice(args, 0, args.length);
	        case 2:
	            return _slice(args, from, args.length);
	        default:
	            var list = [];
	            var idx = 0;
	            var len = Math.max(0, Math.min(args.length, to) - from);
	            while (idx < len) {
	                list[idx] = args[from + idx];
	                idx += 1;
	            }
	            return list;
	        }
	    };

	    var _xfBase = {
	        init: function () {
	            return this.xf['@@transducer/init']();
	        },
	        result: function (result) {
	            return this.xf['@@transducer/result'](result);
	        }
	    };

	    var _xwrap = function () {
	        function XWrap(fn) {
	            this.f = fn;
	        }
	        XWrap.prototype['@@transducer/init'] = function () {
	            throw new Error('init not implemented on XWrap');
	        };
	        XWrap.prototype['@@transducer/result'] = function (acc) {
	            return acc;
	        };
	        XWrap.prototype['@@transducer/step'] = function (acc, x) {
	            return this.f(acc, x);
	        };
	        return function _xwrap(fn) {
	            return new XWrap(fn);
	        };
	    }();

	    /**
	     * Similar to hasMethod, this checks whether a function has a [methodname]
	     * function. If it isn't an array it will execute that function otherwise it
	     * will default to the ramda implementation.
	     *
	     * @private
	     * @param {Function} fn ramda implemtation
	     * @param {String} methodname property to check for a custom implementation
	     * @return {Object} Whatever the return value of the method is.
	     */
	    var _checkForMethod = function _checkForMethod(methodname, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
	        };
	    };

	    /**
	     * Optimized internal one-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry1 = function _curry1(fn) {
	        return function f1(a) {
	            if (arguments.length === 0 || _isPlaceholder(a)) {
	                return f1;
	            } else {
	                return fn.apply(this, arguments);
	            }
	        };
	    };

	    /**
	     * Optimized internal two-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry2 = function _curry2(fn) {
	        return function f2(a, b) {
	            switch (arguments.length) {
	            case 0:
	                return f2;
	            case 1:
	                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
	                    return fn(a, _b);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b);
	                }) : fn(a, b);
	            }
	        };
	    };

	    /**
	     * Optimized internal three-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry3 = function _curry3(fn) {
	        return function f3(a, b, c) {
	            switch (arguments.length) {
	            case 0:
	                return f3;
	            case 1:
	                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                });
	            case 2:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _curry1(function (_c) {
	                    return fn(a, b, _c);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
	                    return fn(_a, _b, c);
	                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b, c);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b, c);
	                }) : _isPlaceholder(c) ? _curry1(function (_c) {
	                    return fn(a, b, _c);
	                }) : fn(a, b, c);
	            }
	        };
	    };

	    /**
	     * Internal curryN function.
	     *
	     * @private
	     * @category Function
	     * @param {Number} length The arity of the curried function.
	     * @param {Array} received An array of arguments received thus far.
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curryN = function _curryN(length, received, fn) {
	        return function () {
	            var combined = [];
	            var argsIdx = 0;
	            var left = length;
	            var combinedIdx = 0;
	            while (combinedIdx < received.length || argsIdx < arguments.length) {
	                var result;
	                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
	                    result = received[combinedIdx];
	                } else {
	                    result = arguments[argsIdx];
	                    argsIdx += 1;
	                }
	                combined[combinedIdx] = result;
	                if (!_isPlaceholder(result)) {
	                    left -= 1;
	                }
	                combinedIdx += 1;
	            }
	            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
	        };
	    };

	    /**
	     * Returns a function that dispatches with different strategies based on the
	     * object in list position (last argument). If it is an array, executes [fn].
	     * Otherwise, if it has a function with [methodname], it will execute that
	     * function (functor case). Otherwise, if it is a transformer, uses transducer
	     * [xf] to return a new transformer (transducer case). Otherwise, it will
	     * default to executing [fn].
	     *
	     * @private
	     * @param {String} methodname property to check for a custom implementation
	     * @param {Function} xf transducer to initialize if object is transformer
	     * @param {Function} fn default ramda implementation
	     * @return {Function} A function that dispatches on object in list position
	     */
	    var _dispatchable = function _dispatchable(methodname, xf, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            if (!_isArray(obj)) {
	                var args = _slice(arguments, 0, length - 1);
	                if (typeof obj[methodname] === 'function') {
	                    return obj[methodname].apply(obj, args);
	                }
	                if (_isTransformer(obj)) {
	                    var transducer = xf.apply(null, args);
	                    return transducer(obj);
	                }
	            }
	            return fn.apply(this, arguments);
	        };
	    };

	    var _xall = function () {
	        function XAll(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.all = true;
	        }
	        XAll.prototype['@@transducer/init'] = _xfBase.init;
	        XAll.prototype['@@transducer/result'] = function (result) {
	            if (this.all) {
	                result = this.xf['@@transducer/step'](result, true);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAll.prototype['@@transducer/step'] = function (result, input) {
	            if (!this.f(input)) {
	                this.all = false;
	                result = _reduced(this.xf['@@transducer/step'](result, false));
	            }
	            return result;
	        };
	        return _curry2(function _xall(f, xf) {
	            return new XAll(f, xf);
	        });
	    }();

	    var _xfilter = function () {
	        function XFilter(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFilter.prototype['@@transducer/init'] = _xfBase.init;
	        XFilter.prototype['@@transducer/result'] = _xfBase.result;
	        XFilter.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
	        };
	        return _curry2(function _xfilter(f, xf) {
	            return new XFilter(f, xf);
	        });
	    }();

	    var _xfind = function () {
	        function XFind(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.found = false;
	        }
	        XFind.prototype['@@transducer/init'] = _xfBase.init;
	        XFind.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, void 0);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFind.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, input));
	            }
	            return result;
	        };
	        return _curry2(function _xfind(f, xf) {
	            return new XFind(f, xf);
	        });
	    }();

	    var _xfindIndex = function () {
	        function XFindIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.found = false;
	        }
	        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindIndex.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, -1);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
	            }
	            return result;
	        };
	        return _curry2(function _xfindIndex(f, xf) {
	            return new XFindIndex(f, xf);
	        });
	    }();

	    var _xmap = function () {
	        function XMap(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XMap.prototype['@@transducer/init'] = _xfBase.init;
	        XMap.prototype['@@transducer/result'] = _xfBase.result;
	        XMap.prototype['@@transducer/step'] = function (result, input) {
	            return this.xf['@@transducer/step'](result, this.f(input));
	        };
	        return _curry2(function _xmap(f, xf) {
	            return new XMap(f, xf);
	        });
	    }();

	    /**
	     * Returns `true` if all elements of the list match the predicate, `false` if
	     * there are any that don't.
	     *
	     * Dispatches to the `all` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
	     *         otherwise.
	     * @see R.any, R.none, R.transduce
	     * @example
	     *
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      var lessThan3 = R.flip(R.lt)(3);
	     *      R.all(lessThan2)([1, 2]); //=> false
	     *      R.all(lessThan3)([1, 2]); //=> true
	     */
	    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (!fn(list[idx])) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    }));

	    /**
	     * Creates a function that is bound to a context.
	     * Note: `R.bind` does not provide the additional argument-binding capabilities of
	     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Function
	     * @category Object
	     * @sig (* -> *) -> {*} -> (* -> *)
	     * @param {Function} fn The function to bind to context
	     * @param {Object} thisObj The context to bind `fn` to
	     * @return {Function} A function that will execute in the context of `thisObj`.
	     * @see R.partial
	     */
	    var bind = _curry2(function bind(fn, thisObj) {
	        return _arity(fn.length, function () {
	            return fn.apply(thisObj, arguments);
	        });
	    });

	    /**
	     * Returns a curried equivalent of the provided function, with the specified
	     * arity. The curried function has two unusual capabilities. First, its
	     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curry
	     * @example
	     *
	     *      var sumArgs = (...args) => R.sum(args);
	     *
	     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curryN = _curry2(function curryN(length, fn) {
	        if (length === 1) {
	            return _curry1(fn);
	        }
	        return _arity(length, _curryN(length, [], fn));
	    });

	    /**
	     * Returns a new list containing only those items that match a given predicate
	     * function. The predicate function is passed one argument: *(value)*.
	     *
	     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the
	     * native `Array.prototype.filter` method. For more details on this behavior,
	     * see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
	     *
	     * Dispatches to the `filter` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} The new filtered array.
	     * @see R.reject, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *
	     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
	     */
	    var filter = _curry2(_dispatchable('filter', _xfilter, _filter));

	    /**
	     * Returns the first element of the list which matches the predicate, or
	     * `undefined` if no element matches.
	     *
	     * Dispatches to the `find` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     *        desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
	     *      R.find(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx += 1;
	        }
	    }));

	    /**
	     * Returns the index of the first element of the list which matches the
	     * predicate, or `-1` if no element matches.
	     *
	     * Dispatches to the `findIndex` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
	     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    }));

	    /**
	     * Iterate over an input `list`, calling a provided function `fn` for each
	     * element in the list.
	     *
	     * `fn` receives one argument: *(value)*.
	     *
	     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.forEach` method. For more
	     * details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
	     *
	     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
	     * the original array. In some libraries this function is named `each`.
	     *
	     * Dispatches to the `forEach` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> *) -> [a] -> [a]
	     * @param {Function} fn The function to invoke. Receives one argument, `value`.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} The original list.
	     * @see R.addIndex
	     * @example
	     *
	     *      var printXPlusFive = x => console.log(x + 5);
	     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
	     *      //-> 6
	     *      //-> 7
	     *      //-> 8
	     */
	    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            fn(list[idx]);
	            idx += 1;
	        }
	        return list;
	    }));

	    /**
	     * Returns true if its arguments are identical, false otherwise. Values are
	     * identical if they reference the same memory. `NaN` is identical to `NaN`;
	     * `0` and `-0` are not identical.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      var o = {};
	     *      R.identical(o, o); //=> true
	     *      R.identical(1, 1); //=> true
	     *      R.identical(1, '1'); //=> false
	     *      R.identical([], []); //=> false
	     *      R.identical(0, -0); //=> false
	     *      R.identical(NaN, NaN); //=> true
	     */
	    // SameValue algorithm
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Step 6.a: NaN == NaN
	    var identical = _curry2(function identical(a, b) {
	        // SameValue algorithm
	        if (a === b) {
	            // Steps 1-5, 7-10
	            // Steps 6.b-6.e: +0 != -0
	            return a !== 0 || 1 / a === 1 / b;
	        } else {
	            // Step 6.a: NaN == NaN
	            return a !== a && b !== b;
	        }
	    });

	    /**
	     * See if an object (`val`) is an instance of the supplied constructor. This
	     * function will check up the inheritance chain, if any.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Type
	     * @sig (* -> {*}) -> a -> Boolean
	     * @param {Object} ctor A constructor
	     * @param {*} val The value to test
	     * @return {Boolean}
	     * @example
	     *
	     *      R.is(Object, {}); //=> true
	     *      R.is(Number, 1); //=> true
	     *      R.is(Object, 1); //=> false
	     *      R.is(String, 's'); //=> true
	     *      R.is(String, new String('')); //=> true
	     *      R.is(Object, new String('')); //=> true
	     *      R.is(Object, 's'); //=> false
	     *      R.is(Number, {}); //=> false
	     */
	    var is = _curry2(function is(Ctor, val) {
	        return val != null && val.constructor === Ctor || val instanceof Ctor;
	    });

	    /**
	     * Tests whether or not an object is similar to an array.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Type
	     * @category List
	     * @sig * -> Boolean
	     * @param {*} x The object to test.
	     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
	     * @example
	     *
	     *      R.isArrayLike([]); //=> true
	     *      R.isArrayLike(true); //=> false
	     *      R.isArrayLike({}); //=> false
	     *      R.isArrayLike({length: 10}); //=> false
	     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
	     */
	    var isArrayLike = _curry1(function isArrayLike(x) {
	        if (_isArray(x)) {
	            return true;
	        }
	        if (!x) {
	            return false;
	        }
	        if (typeof x !== 'object') {
	            return false;
	        }
	        if (x instanceof String) {
	            return false;
	        }
	        if (x.nodeType === 1) {
	            return !!x.length;
	        }
	        if (x.length === 0) {
	            return true;
	        }
	        if (x.length > 0) {
	            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
	        }
	        return false;
	    });

	    /**
	     * Returns a list containing the names of all the enumerable own properties of
	     * the supplied object.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own properties.
	     * @example
	     *
	     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
	     */
	    // cover IE < 9 keys issues
	    var keys = function () {
	        // cover IE < 9 keys issues
	        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
	        var nonEnumerableProps = [
	            'constructor',
	            'valueOf',
	            'isPrototypeOf',
	            'toString',
	            'propertyIsEnumerable',
	            'hasOwnProperty',
	            'toLocaleString'
	        ];
	        var contains = function contains(list, item) {
	            var idx = 0;
	            while (idx < list.length) {
	                if (list[idx] === item) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        };
	        return typeof Object.keys === 'function' ? _curry1(function keys(obj) {
	            return Object(obj) !== obj ? [] : Object.keys(obj);
	        }) : _curry1(function keys(obj) {
	            if (Object(obj) !== obj) {
	                return [];
	            }
	            var prop, ks = [], nIdx;
	            for (prop in obj) {
	                if (_has(prop, obj)) {
	                    ks[ks.length] = prop;
	                }
	            }
	            if (hasEnumBug) {
	                nIdx = nonEnumerableProps.length - 1;
	                while (nIdx >= 0) {
	                    prop = nonEnumerableProps[nIdx];
	                    if (_has(prop, obj) && !contains(ks, prop)) {
	                        ks[ks.length] = prop;
	                    }
	                    nIdx -= 1;
	                }
	            }
	            return ks;
	        });
	    }();

	    /**
	     * Returns a partial copy of an object containing only the keys specified. If
	     * the key does not exist, the property is ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.omit, R.props
	     * @example
	     *
	     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
	     */
	    var pick = _curry2(function pick(names, obj) {
	        var result = {};
	        var idx = 0;
	        while (idx < names.length) {
	            if (names[idx] in obj) {
	                result[names[idx]] = obj[names[idx]];
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys that satisfy
	     * the supplied predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
	     * @param {Function} pred A predicate to determine whether or not a key
	     *        should be included on the output object.
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties that satisfy `pred`
	     *         on it.
	     * @see R.pick
	     * @example
	     *
	     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
	     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
	     */
	    var pickBy = _curry2(function pickBy(test, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (test(obj[prop], prop, obj)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns a function that when supplied an object returns the indicated
	     * property of that object, if it exists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig s -> {s: a} -> a | Undefined
	     * @param {String} p The property name
	     * @param {Object} obj The object to query
	     * @return {*} The value at `obj.p`.
	     * @example
	     *
	     *      R.prop('x', {x: 100}); //=> 100
	     *      R.prop('x', {}); //=> undefined
	     */
	    var prop = _curry2(function prop(p, obj) {
	        return obj[p];
	    });

	    /**
	     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> [v]
	     * @param {Array} ps The property names to fetch
	     * @param {Object} obj The object to query
	     * @return {Array} The corresponding values or partially applied function.
	     * @example
	     *
	     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
	     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
	     *
	     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
	     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
	     */
	    var props = _curry2(function props(ps, obj) {
	        var len = ps.length;
	        var out = [];
	        var idx = 0;
	        while (idx < len) {
	            out[idx] = obj[ps[idx]];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new list or string with the elements or characters in reverse
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {Array|String} list
	     * @return {Array|String}
	     * @example
	     *
	     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
	     *      R.reverse([1, 2]);     //=> [2, 1]
	     *      R.reverse([1]);        //=> [1]
	     *      R.reverse([]);         //=> []
	     *
	     *      R.reverse('abc');      //=> 'cba'
	     *      R.reverse('ab');       //=> 'ba'
	     *      R.reverse('a');        //=> 'a'
	     *      R.reverse('');         //=> ''
	     */
	    var reverse = _curry1(function reverse(list) {
	        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
	    });

	    /**
	     * Returns the elements of the given list or string (or object with a `slice`
	     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
	     *
	     * Dispatches to the `slice` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @sig Number -> Number -> String -> String
	     * @param {Number} fromIndex The start index (inclusive).
	     * @param {Number} toIndex The end index (exclusive).
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
	     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
	     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
	     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
	     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
	     */
	    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
	        return Array.prototype.slice.call(list, fromIndex, toIndex);
	    }));

	    /**
	     * Returns all but the first element of the given list or string (or object
	     * with a `tail` method).
	     *
	     * Dispatches to the `slice` method of the first argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.head, R.init, R.last
	     * @example
	     *
	     *      R.tail([1, 2, 3]);  //=> [2, 3]
	     *      R.tail([1, 2]);     //=> [2]
	     *      R.tail([1]);        //=> []
	     *      R.tail([]);         //=> []
	     *
	     *      R.tail('abc');  //=> 'bc'
	     *      R.tail('ab');   //=> 'b'
	     *      R.tail('a');    //=> ''
	     *      R.tail('');     //=> ''
	     */
	    var tail = _checkForMethod('tail', slice(1, Infinity));

	    /**
	     * Gives a single-word string description of the (native) type of a value,
	     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
	     * attempt to distinguish user Object types any further, reporting them all as
	     * 'Object'.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Type
	     * @sig (* -> {*}) -> String
	     * @param {*} val The value to test
	     * @return {String}
	     * @example
	     *
	     *      R.type({}); //=> "Object"
	     *      R.type(1); //=> "Number"
	     *      R.type(false); //=> "Boolean"
	     *      R.type('s'); //=> "String"
	     *      R.type(null); //=> "Null"
	     *      R.type([]); //=> "Array"
	     *      R.type(/[A-z]/); //=> "RegExp"
	     */
	    var type = _curry1(function type(val) {
	        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
	    });

	    /**
	     * Returns a list of all the enumerable own properties of the supplied object.
	     * Note that the order of the output array is not guaranteed across different
	     * JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own properties.
	     * @example
	     *
	     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
	     */
	    var values = _curry1(function values(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var vals = [];
	        var idx = 0;
	        while (idx < len) {
	            vals[idx] = obj[props[idx]];
	            idx += 1;
	        }
	        return vals;
	    });

	    // Values of other types are only equal if identical.
	    var _equals = function _equals(a, b, stackA, stackB) {
	        if (identical(a, b)) {
	            return true;
	        }
	        if (type(a) !== type(b)) {
	            return false;
	        }
	        if (a == null || b == null) {
	            return false;
	        }
	        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
	            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
	        }
	        switch (type(a)) {
	        case 'Arguments':
	        case 'Array':
	        case 'Object':
	            break;
	        case 'Boolean':
	        case 'Number':
	        case 'String':
	            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
	                return false;
	            }
	            break;
	        case 'Date':
	            if (!identical(a.valueOf(), b.valueOf())) {
	                return false;
	            }
	            break;
	        case 'Error':
	            if (!(a.name === b.name && a.message === b.message)) {
	                return false;
	            }
	            break;
	        case 'RegExp':
	            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
	                return false;
	            }
	            break;
	        case 'Map':
	        case 'Set':
	            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
	                return false;
	            }
	            break;
	        case 'Int8Array':
	        case 'Uint8Array':
	        case 'Uint8ClampedArray':
	        case 'Int16Array':
	        case 'Uint16Array':
	        case 'Int32Array':
	        case 'Uint32Array':
	        case 'Float32Array':
	        case 'Float64Array':
	            break;
	        case 'ArrayBuffer':
	            break;
	        default:
	            // Values of other types are only equal if identical.
	            return false;
	        }
	        var keysA = keys(a);
	        if (keysA.length !== keys(b).length) {
	            return false;
	        }
	        var idx = stackA.length - 1;
	        while (idx >= 0) {
	            if (stackA[idx] === a) {
	                return stackB[idx] === b;
	            }
	            idx -= 1;
	        }
	        stackA.push(a);
	        stackB.push(b);
	        idx = keysA.length - 1;
	        while (idx >= 0) {
	            var key = keysA[idx];
	            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
	                return false;
	            }
	            idx -= 1;
	        }
	        stackA.pop();
	        stackB.pop();
	        return true;
	    };

	    /**
	     * `_makeFlat` is a helper function that returns a one-level or fully recursive
	     * function based on the flag passed in.
	     *
	     * @private
	     */
	    var _makeFlat = function _makeFlat(recursive) {
	        return function flatt(list) {
	            var value, result = [], idx = 0, j, ilen = list.length, jlen;
	            while (idx < ilen) {
	                if (isArrayLike(list[idx])) {
	                    value = recursive ? flatt(list[idx]) : list[idx];
	                    j = 0;
	                    jlen = value.length;
	                    while (j < jlen) {
	                        result[result.length] = value[j];
	                        j += 1;
	                    }
	                } else {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	            return result;
	        };
	    };

	    var _reduce = function () {
	        function _arrayReduce(xf, acc, list) {
	            var idx = 0, len = list.length;
	            while (idx < len) {
	                acc = xf['@@transducer/step'](acc, list[idx]);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                idx += 1;
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _iterableReduce(xf, acc, iter) {
	            var step = iter.next();
	            while (!step.done) {
	                acc = xf['@@transducer/step'](acc, step.value);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                step = iter.next();
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _methodReduce(xf, acc, obj) {
	            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
	        }
	        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	        return function _reduce(fn, acc, list) {
	            if (typeof fn === 'function') {
	                fn = _xwrap(fn);
	            }
	            if (isArrayLike(list)) {
	                return _arrayReduce(fn, acc, list);
	            }
	            if (typeof list.reduce === 'function') {
	                return _methodReduce(fn, acc, list);
	            }
	            if (list[symIterator] != null) {
	                return _iterableReduce(fn, acc, list[symIterator]());
	            }
	            if (typeof list.next === 'function') {
	                return _iterableReduce(fn, acc, list);
	            }
	            throw new TypeError('reduce: list must be array or iterable');
	        };
	    }();

	    /**
	     * Creates a new list iteration function from an existing one by adding two new
	     * parameters to its callback function: the current index, and the entire list.
	     *
	     * This would turn, for instance, Ramda's simple `map` function into one that
	     * more closely resembles `Array.prototype.map`. Note that this will only work
	     * for functions in which the iteration callback function is the first
	     * parameter, and where the list is the last parameter. (This latter might be
	     * unimportant if the list parameter is not used.)
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Function
	     * @category List
	     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
	     * @param {Function} fn A list iteration function that does not pass index or list to its callback
	     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
	     * @example
	     *
	     *      var mapIndexed = R.addIndex(R.map);
	     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
	     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
	     */
	    var addIndex = _curry1(function addIndex(fn) {
	        return curryN(fn.length, function () {
	            var idx = 0;
	            var origFn = arguments[0];
	            var list = arguments[arguments.length - 1];
	            var args = _slice(arguments);
	            args[0] = function () {
	                var result = origFn.apply(this, _concat(arguments, [
	                    idx,
	                    list
	                ]));
	                idx += 1;
	                return result;
	            };
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Returns a curried equivalent of the provided function. The curried function
	     * has two unusual capabilities. First, its arguments needn't be provided one
	     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (* -> a) -> (* -> a)
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curryN
	     * @example
	     *
	     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
	     *
	     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curry = _curry1(function curry(fn) {
	        return curryN(fn.length, fn);
	    });

	    /**
	     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
	     * cyclical data structures.
	     *
	     * Dispatches symmetrically to the `equals` methods of both arguments, if
	     * present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> b -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      R.equals(1, 1); //=> true
	     *      R.equals(1, '1'); //=> false
	     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
	     *
	     *      var a = {}; a.v = a;
	     *      var b = {}; b.v = b;
	     *      R.equals(a, b); //=> true
	     */
	    var equals = _curry2(function equals(a, b) {
	        return _equals(a, b, [], []);
	    });

	    /**
	     * Returns a new list by pulling every item out of it (and all its sub-arrays)
	     * and putting them in a new array, depth-first.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b]
	     * @param {Array} list The array to consider.
	     * @return {Array} The flattened list.
	     * @see R.unnest
	     * @example
	     *
	     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
	     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
	     */
	    var flatten = _curry1(_makeFlat(true));

	    /**
	     * Returns a new list, constructed by applying the supplied function to every
	     * element of the supplied list.
	     *
	     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays),
	     * unlike the native `Array.prototype.map` method. For more details on this
	     * behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
	     *
	     * Dispatches to the `map` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * Also treats functions as functors and will compose them together.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Functor f => (a -> b) -> f a -> f b
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {Array} list The list to be iterated over.
	     * @return {Array} The new list.
	     * @see R.transduce, R.addIndex
	     * @example
	     *
	     *      var double = x => x * 2;
	     *
	     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
	     *
	     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
	     */
	    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
	        switch (Object.prototype.toString.call(functor)) {
	        case '[object Function]':
	            return curryN(functor.length, function () {
	                return fn.call(this, functor.apply(this, arguments));
	            });
	        case '[object Object]':
	            return _reduce(function (acc, key) {
	                acc[key] = fn(functor[key]);
	                return acc;
	            }, {}, keys(functor));
	        default:
	            return _map(fn, functor);
	        }
	    }));

	    /**
	     * Like `mapObj`, but passes additional arguments to the predicate function.
	     * The predicate function is passed three arguments: *(value, key, obj)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}
	     * @param {Function} fn A function called for each property in `obj`. Its return value will
	     *        become a new property on the return object.
	     * @param {Object} obj The object to iterate over.
	     * @return {Object} A new object with the same keys as `obj` and values that are the result
	     *         of running each property through `fn`.
	     * @example
	     *
	     *      var values = { x: 1, y: 2, z: 3 };
	     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
	     *
	     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
	     */
	    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
	        return _reduce(function (acc, key) {
	            acc[key] = fn(obj[key], key, obj);
	            return acc;
	        }, {}, keys(obj));
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling
	     * the iterator function and passing it an accumulator value and the current
	     * value from the array, and then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It may use
	     * `R.reduced` to shortcut the iteration.
	     *
	     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.reduce` method. For more details
	     * on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
	     *
	     * Dispatches to the `reduce` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig ((a, b) -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.reduced, R.addIndex
	     * @example
	     *
	     *      var numbers = [1, 2, 3];
	     *      var add = (a, b) => a + b;
	     *
	     *      R.reduce(add, 10, numbers); //=> 16
	     */
	    var reduce = _curry3(_reduce);

	    var _flatCat = function () {
	        var preservingReduced = function (xf) {
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return xf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    var ret = xf['@@transducer/step'](result, input);
	                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
	                }
	            };
	        };
	        return function _xcat(xf) {
	            var rxf = preservingReduced(xf);
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return rxf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
	                }
	            };
	        };
	    }();

	    var _indexOf = function _indexOf(list, item, from) {
	        var idx = from;
	        while (idx < list.length) {
	            if (equals(list[idx], item)) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    };

	    var _xchain = _curry2(function _xchain(f, xf) {
	        return map(f, _flatCat(xf));
	    });

	    /**
	     * `chain` maps a function over a list and concatenates the results. `chain`
	     * is also known as `flatMap` in some libraries
	     *
	     * Dispatches to the `chain` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig (a -> [b]) -> [a] -> [b]
	     * @param {Function} fn
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      var duplicate = n => [n, n];
	     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
	     */
	    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
	        if (typeof monad === 'function') {
	            return function () {
	                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
	            };
	        }
	        return _makeFlat(false)(map(fn, monad));
	    }));

	    /**
	     * Performs left-to-right function composition. The leftmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * In some libraries this function is named `sequence`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.compose
	     * @example
	     *
	     *      var f = R.pipe(Math.pow, R.negate, R.inc);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var pipe = function pipe() {
	        if (arguments.length === 0) {
	            throw new Error('pipe requires at least one argument');
	        }
	        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
	    };

	    /* globals Set */
	    // manually crawl the list to distinguish between +0 and -0
	    // non-zero numbers can utilise Set
	    // all these types can utilise Set
	    // null can utilise Set
	    // other objects need R.equals for equality
	    // anything else not covered above, defer to R.equals
	    var _contains = typeof Set === 'undefined' ? function _contains(a, list) {
	        return _indexOf(list, a, 0) >= 0;
	    } : function _containsSet(a, list) {
	        var idx, inf, item;
	        switch (typeof a) {
	        case 'number':
	            if (a === 0) {
	                // manually crawl the list to distinguish between +0 and -0
	                idx = 0;
	                inf = 1 / a;
	                while (idx < list.length) {
	                    item = list[idx];
	                    if (item === 0 && 1 / item === inf) {
	                        return true;
	                    }
	                    idx += 1;
	                }
	                return false;
	            }
	            // non-zero numbers can utilise Set
	            return new Set(list).has(a);
	        // all these types can utilise Set
	        case 'string':
	        case 'boolean':
	        case 'function':
	        case 'undefined':
	            return new Set(list).has(a);
	        case 'object':
	            if (a === null) {
	                // null can utilise Set
	                return new Set(list).has(a);
	            }
	            // other objects need R.equals for equality
	            return _indexOf(list, a, 0) >= 0;
	        default:
	            // anything else not covered above, defer to R.equals
	            return _indexOf(list, a, 0) >= 0;
	        }
	    };

	    /**
	     * Performs right-to-left function composition. The rightmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipe
	     * @example
	     *
	     *      var f = R.compose(R.inc, R.negate, Math.pow);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var compose = function compose() {
	        if (arguments.length === 0) {
	            throw new Error('compose requires at least one argument');
	        }
	        return pipe.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
	     * least one element of the given list; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Boolean
	     * @param {Object} a The item to compare against.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
	     * @see R.any
	     * @example
	     *
	     *      R.contains(3, [1, 2, 3]); //=> true
	     *      R.contains(4, [1, 2, 3]); //=> false
	     *      R.contains([42], [[42]]); //=> true
	     */
	    var contains = _curry2(_contains);

	    /**
	     * Returns a partial copy of an object omitting the keys specified.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [String] -> {String: *} -> {String: *}
	     * @param {Array} names an array of String property names to omit from the new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with properties from `names` not on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
	     */
	    var omit = _curry2(function omit(names, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (!_contains(prop, names)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    var R = {
	        addIndex: addIndex,
	        all: all,
	        chain: chain,
	        compose: compose,
	        contains: contains,
	        curry: curry,
	        curryN: curryN,
	        filter: filter,
	        find: find,
	        findIndex: findIndex,
	        flatten: flatten,
	        forEach: forEach,
	        is: is,
	        map: map,
	        mapObjIndexed: mapObjIndexed,
	        omit: omit,
	        pick: pick,
	        pickBy: pickBy,
	        prop: prop,
	        props: props,
	        reduce: reduce,
	        values: values
	    };

	  /* TEST_ENTRY_POINT */

	  if (true) {
	    module.exports = R;
	  } else if (typeof define === 'function' && define.amd) {
	    define(function() { return R; });
	  } else {
	    this.R = R;
	  }

	}.call(this));


/***/ },
/* 79 */
/*!**************************!*\
  !*** ./src/store/api.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _apiBase = __webpack_require__(/*! ./apiBase */ 80);

	var _apiBase2 = _interopRequireDefault(_apiBase);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function fetchNext(url, urls, success, failure, _ref) {
	  var contentType = _ref.contentType,
	      method = _ref.method,
	      body = _ref.body;

	  function tryNext(err) {
	    if (urls.length) {
	      return fetchNext(urls[0], urls.slice(1), success, failure, { contentType: contentType, method: method, body: body });
	    } else {
	      failure(err);
	    }
	  }

	  if (contentType === 'img') {
	    (function () {
	      var img = new Image();
	      img.crossOrigin = 'anonymous'; // don't send cookies, but do send Origin: header
	      img.addEventListener('load', function (e) {
	        success(img);
	      });
	      img.addEventListener('error', tryNext);
	      img.src = url; //s.shift();
	    })();
	  } else if (contentType === 'external') {
	    // This will need to use JSONP in some fashion (either dynamic function,
	    // or some sort of global plugin namespace in order to work, since
	    // CORS prevents us from just loading the file via xhr
	    throw new Error('External Script support not allowed in the browser');
	  } else {
	    (function () {
	      var request = new XMLHttpRequest();
	      var requestMethod = method || 'GET';
	      if (requestMethod !== 'GET') request.withCredentials = true;
	      request.open(requestMethod, url, true);
	      if (body) request.setRequestHeader('Content-Type', 'application/json');

	      if (contentType === 'binary') request.responseType = 'arraybuffer';
	      request.onload = function (xhr) {
	        var response = request.response;

	        if (request.status >= 200 && request.status < 400) {
	          if (contentType === 'json') response = JSON.parse(response);
	          success(response);
	        } else {
	          tryNext(request);
	        }
	      };

	      request.onerror = tryNext;
	      request.send(body);
	    })();
	  }
	}

	var callApi = (0, _apiBase2.default)(fetchNext);

	exports.default = callApi;

/***/ },
/* 80 */
/*!******************************!*\
  !*** ./src/store/apiBase.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 97);

	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

	exports.default = apiBase;

	var _lzmaDecompressor = __webpack_require__(/*! ./utils/lzmaDecompressor */ 104);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _rsvp = __webpack_require__(/*! rsvp */ 106);

	var _rsvp2 = _interopRequireDefault(_rsvp);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Simple, persistent api cache for now.
	var apiCache = {};
	var fetchingCache = {};

	function apiBase(fetchNext) {
	  return function (store, _ref) {
	    var types = _ref.types,
	        url = _ref.url,
	        fireAndForget = _ref.fireAndForget,
	        payload = _ref.payload,
	        queryKey = _ref.queryKey,
	        requestPayload = _ref.requestPayload,
	        cache = _ref.cache,
	        method = _ref.method,
	        contentType = _ref.contentType,
	        body = _ref.body,
	        files = _ref.files,
	        success = _ref.success,
	        failure = _ref.failure,
	        decompress = _ref.decompress;

	    var urls = Array.isArray(url) ? url : [url];
	    if (!contentType) contentType = 'json';

	    var _ref2 = types || ['IGN', 'IGN', 'IGN'],
	        _ref3 = (0, _slicedToArray3.default)(_ref2, 3),
	        requestType = _ref3[0],
	        successType = _ref3[1],
	        failureType = _ref3[2];

	    // If we provide a 'queryKey', there can be only one query at once


	    if (queryKey) {
	      if (apiCache[queryKey]) {
	        return fireAndForget ? apiCache[queryKey] : _promise2.default.resolve(apiCache[queryKey]);
	      }

	      if (fetchingCache[queryKey]) {
	        if (fireAndForget) {
	          fetchingCache[queryKey].push({ payload: payload, store: store });
	          store.dispatch({ type: requestType, payload: payload });
	          return;
	        } else {
	          return new _rsvp2.default.Promise(function (resolve, reject) {
	            fetchingCache[queryKey].push({ payload: payload, store: store, resolve: resolve, reject: reject });
	            store.dispatch({ type: requestType, payload: payload });
	          });
	        }
	      }

	      fetchingCache[queryKey] = [{ payload: payload, store: store }];
	    }

	    store.dispatch({ type: requestType, payload: payload });

	    var promise = new _rsvp2.default.Promise(function (resolve, reject) {
	      var meta = {
	        queryKey: queryKey,
	        payload: payload,
	        successType: successType,
	        success: success,
	        failureType: failureType,
	        failure: failure
	      };

	      function onFailure(error, workerMeta) {
	        var _ref4 = workerMeta || meta,
	            failureType = _ref4.failureType,
	            failure = _ref4.failure,
	            queryKey = _ref4.queryKey,
	            payload = _ref4.payload;

	        if (queryKey) {
	          (0, _ramda.forEach)(function (_ref5) {
	            var payload = _ref5.payload,
	                store = _ref5.store,
	                reject = _ref5.reject;

	            store.dispatch({ type: failureType, payload: payload, error: error });
	            if (reject) reject(error);
	          }, fetchingCache[queryKey]);
	          delete fetchingCache[queryKey];
	        } else {
	          store.dispatch({ type: failureType, payload: payload, error: error });
	        }

	        if (failure) failure(error);
	        reject(error);
	      };

	      function onSuccessEnd(buffer, workerMeta) {
	        var _ref6 = workerMeta || meta,
	            successType = _ref6.successType,
	            sucess = _ref6.sucess,
	            queryKey = _ref6.queryKey,
	            payload = _ref6.payload;

	        if (queryKey) {
	          apiCache[queryKey] = buffer;
	          (0, _ramda.forEach)(function (_ref7) {
	            var payload = _ref7.payload,
	                store = _ref7.store,
	                resolve = _ref7.resolve;

	            store.dispatch({ type: successType, payload: payload, response: buffer });
	            if (resolve) resolve(buffer);
	          }, fetchingCache[queryKey]);
	          delete fetchingCache[queryKey];
	        } else {
	          store.dispatch({ type: successType, payload: payload, response: buffer });
	        }

	        if (success) success(buffer);
	        resolve(buffer);
	      }

	      function onSuccess(response) {
	        if (decompress) {
	          (0, _lzmaDecompressor.lzmaDecompressor)(response, meta, onSuccessEnd, onFailure);
	        } else {
	          onSuccessEnd(response);
	        }
	      };

	      fetchNext(urls[0], urls.slice(1), onSuccess, onFailure, { contentType: contentType, method: method, body: body, files: files });
	    });

	    return fireAndForget ? null : promise;
	  };
	}

/***/ },
/* 81 */
/*!********************************************!*\
  !*** ./~/babel-runtime/core-js/promise.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/promise */ 82), __esModule: true };

/***/ },
/* 82 */
/*!*********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/promise.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/es6.object.to-string */ 83);
	__webpack_require__(/*! ../modules/es6.string.iterator */ 5);
	__webpack_require__(/*! ../modules/web.dom.iterable */ 84);
	__webpack_require__(/*! ../modules/es6.promise */ 88);
	module.exports = __webpack_require__(/*! ../modules/_core */ 13).Promise;

/***/ },
/* 83 */
/*!***************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.to-string.js ***!
  \***************************************************************************/
/***/ function(module, exports) {



/***/ },
/* 84 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/web.dom.iterable.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./es6.array.iterator */ 85);
	var global        = __webpack_require__(/*! ./_global */ 12)
	  , hide          = __webpack_require__(/*! ./_hide */ 16)
	  , Iterators     = __webpack_require__(/*! ./_iterators */ 28)
	  , TO_STRING_TAG = __webpack_require__(/*! ./_wks */ 46)('toStringTag');

	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 85 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.array.iterator.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ 86)
	  , step             = __webpack_require__(/*! ./_iter-step */ 87)
	  , Iterators        = __webpack_require__(/*! ./_iterators */ 28)
	  , toIObject        = __webpack_require__(/*! ./_to-iobject */ 34);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(/*! ./_iter-define */ 9)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 86 */
/*!**************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_add-to-unscopables.js ***!
  \**************************************************************************/
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 87 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-step.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 88 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.promise.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(/*! ./_library */ 10)
	  , global             = __webpack_require__(/*! ./_global */ 12)
	  , ctx                = __webpack_require__(/*! ./_ctx */ 14)
	  , classof            = __webpack_require__(/*! ./_classof */ 54)
	  , $export            = __webpack_require__(/*! ./_export */ 11)
	  , isObject           = __webpack_require__(/*! ./_is-object */ 19)
	  , aFunction          = __webpack_require__(/*! ./_a-function */ 15)
	  , anInstance         = __webpack_require__(/*! ./_an-instance */ 89)
	  , forOf              = __webpack_require__(/*! ./_for-of */ 90)
	  , speciesConstructor = __webpack_require__(/*! ./_species-constructor */ 91)
	  , task               = __webpack_require__(/*! ./_task */ 92).set
	  , microtask          = __webpack_require__(/*! ./_microtask */ 94)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;

	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ 46)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();

	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};

	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ 95)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(/*! ./_set-to-string-tag */ 45)($Promise, PROMISE);
	__webpack_require__(/*! ./_set-species */ 96)(PROMISE);
	Wrapper = __webpack_require__(/*! ./_core */ 13)[PROMISE];

	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ 55)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 89 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_an-instance.js ***!
  \*******************************************************************/
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 90 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_for-of.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(/*! ./_ctx */ 14)
	  , call        = __webpack_require__(/*! ./_iter-call */ 50)
	  , isArrayIter = __webpack_require__(/*! ./_is-array-iter */ 51)
	  , anObject    = __webpack_require__(/*! ./_an-object */ 18)
	  , toLength    = __webpack_require__(/*! ./_to-length */ 38)
	  , getIterFn   = __webpack_require__(/*! ./core.get-iterator-method */ 53)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 91 */
/*!***************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_species-constructor.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(/*! ./_an-object */ 18)
	  , aFunction = __webpack_require__(/*! ./_a-function */ 15)
	  , SPECIES   = __webpack_require__(/*! ./_wks */ 46)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 92 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_task.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(/*! ./_ctx */ 14)
	  , invoke             = __webpack_require__(/*! ./_invoke */ 93)
	  , html               = __webpack_require__(/*! ./_html */ 44)
	  , cel                = __webpack_require__(/*! ./_dom-create */ 23)
	  , global             = __webpack_require__(/*! ./_global */ 12)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(/*! ./_cof */ 36)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 93 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_invoke.js ***!
  \**************************************************************/
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 94 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_microtask.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(/*! ./_global */ 12)
	  , macrotask = __webpack_require__(/*! ./_task */ 92).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(/*! ./_cof */ 36)(process) == 'process';

	module.exports = function(){
	  var head, last, notify;

	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };

	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }

	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 95 */
/*!********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_redefine-all.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(/*! ./_hide */ 16);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 96 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_set-species.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(/*! ./_global */ 12)
	  , core        = __webpack_require__(/*! ./_core */ 13)
	  , dP          = __webpack_require__(/*! ./_object-dp */ 17)
	  , DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ 21)
	  , SPECIES     = __webpack_require__(/*! ./_wks */ 46)('species');

	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 97 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/helpers/slicedToArray.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _isIterable2 = __webpack_require__(/*! ../core-js/is-iterable */ 98);

	var _isIterable3 = _interopRequireDefault(_isIterable2);

	var _getIterator2 = __webpack_require__(/*! ../core-js/get-iterator */ 101);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 98 */
/*!************************************************!*\
  !*** ./~/babel-runtime/core-js/is-iterable.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/is-iterable */ 99), __esModule: true };

/***/ },
/* 99 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/is-iterable.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/web.dom.iterable */ 84);
	__webpack_require__(/*! ../modules/es6.string.iterator */ 5);
	module.exports = __webpack_require__(/*! ../modules/core.is-iterable */ 100);

/***/ },
/* 100 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/core.is-iterable.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(/*! ./_classof */ 54)
	  , ITERATOR  = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , Iterators = __webpack_require__(/*! ./_iterators */ 28);
	module.exports = __webpack_require__(/*! ./_core */ 13).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 101 */
/*!*************************************************!*\
  !*** ./~/babel-runtime/core-js/get-iterator.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/get-iterator */ 102), __esModule: true };

/***/ },
/* 102 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/get-iterator.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/web.dom.iterable */ 84);
	__webpack_require__(/*! ../modules/es6.string.iterator */ 5);
	module.exports = __webpack_require__(/*! ../modules/core.get-iterator */ 103);

/***/ },
/* 103 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/core.get-iterator.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(/*! ./_an-object */ 18)
	  , get      = __webpack_require__(/*! ./core.get-iterator-method */ 53);
	module.exports = __webpack_require__(/*! ./_core */ 13).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 104 */
/*!*********************************************!*\
  !*** ./src/store/utils/lzmaDecompressor.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.lzmaDecompressor = lzmaDecompressor;

	var _lzma = __webpack_require__(/*! ../../../vendor/lzma */ 105);

	var _lzma2 = _interopRequireDefault(_lzma);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var LZMARaw = '\n//From Repository: https://github.com/jcmellado/js-lzma\n/*\nCopyright (c) 2011 Juan Mellado\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/*\nReferences:\n- "LZMA SDK" by Igor Pavlov\n  http://www.7-zip.org/sdk.html\n*/\n\nvar LZMA = LZMA || {};\n\nLZMA.OutWindow = function(){\n  this._windowSize = 0;\n};\n\nLZMA.OutWindow.prototype.create = function(windowSize){\n  if ( (!this._buffer) || (this._windowSize !== windowSize) ){\n    this._buffer = [];\n  }\n  this._windowSize = windowSize;\n  this._pos = 0;\n  this._streamPos = 0;\n};\n\nLZMA.OutWindow.prototype.flush = function(){\n  var size = this._pos - this._streamPos;\n  if (size !== 0){\n    while(size --){\n      this._stream.writeByte(this._buffer[this._streamPos ++]);\n    }\n    if (this._pos >= this._windowSize){\n      this._pos = 0;\n    }\n    this._streamPos = this._pos;\n  }\n};\n\nLZMA.OutWindow.prototype.releaseStream = function(){\n  this.flush();\n  this._stream = null;\n};\n\nLZMA.OutWindow.prototype.setStream = function(stream){\n  this.releaseStream();\n  this._stream = stream;\n};\n\nLZMA.OutWindow.prototype.init = function(solid){\n  if (!solid){\n    this._streamPos = 0;\n    this._pos = 0;\n  }\n};\n\nLZMA.OutWindow.prototype.copyBlock = function(distance, len){\n  var pos = this._pos - distance - 1;\n  if (pos < 0){\n    pos += this._windowSize;\n  }\n  while(len --){\n    if (pos >= this._windowSize){\n      pos = 0;\n    }\n    this._buffer[this._pos ++] = this._buffer[pos ++];\n    if (this._pos >= this._windowSize){\n      this.flush();\n    }\n  }\n};\n\nLZMA.OutWindow.prototype.putByte = function(b){\n  this._buffer[this._pos ++] = b;\n  if (this._pos >= this._windowSize){\n    this.flush();\n  }\n};\n\nLZMA.OutWindow.prototype.getByte = function(distance){\n  var pos = this._pos - distance - 1;\n  if (pos < 0){\n    pos += this._windowSize;\n  }\n  return this._buffer[pos];\n};\n\nLZMA.RangeDecoder = function(){\n};\n\nLZMA.RangeDecoder.prototype.setStream = function(stream){\n  this._stream = stream;\n};\n\nLZMA.RangeDecoder.prototype.releaseStream = function(){\n  this._stream = null;\n};\n\nLZMA.RangeDecoder.prototype.init = function(){\n  var i = 5;\n\n  this._code = 0;\n  this._range = -1;\n\n  while(i --){\n    this._code = (this._code << 8) | this._stream.readByte();\n  }\n};\n\nLZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){\n  var result = 0, i = numTotalBits, t;\n\n  while(i --){\n    this._range >>>= 1;\n    t = (this._code - this._range) >>> 31;\n    this._code -= this._range & (t - 1);\n    result = (result << 1) | (1 - t);\n\n    if ( (this._range & 0xff000000) === 0){\n      this._code = (this._code << 8) | this._stream.readByte();\n      this._range <<= 8;\n    }\n  }\n\n  return result;\n};\n\nLZMA.RangeDecoder.prototype.decodeBit = function(probs, index){\n  var prob = probs[index],\n      newBound = (this._range >>> 11) * prob;\n\n  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){\n    this._range = newBound;\n    probs[index] += (2048 - prob) >>> 5;\n    if ( (this._range & 0xff000000) === 0){\n      this._code = (this._code << 8) | this._stream.readByte();\n      this._range <<= 8;\n    }\n    return 0;\n  }\n\n  this._range -= newBound;\n  this._code -= newBound;\n  probs[index] -= prob >>> 5;\n  if ( (this._range & 0xff000000) === 0){\n    this._code = (this._code << 8) | this._stream.readByte();\n    this._range <<= 8;\n  }\n  return 1;\n};\n\nLZMA.initBitModels = function(probs, len){\n  while(len --){\n    probs[len] = 1024;\n  }\n};\n\nLZMA.BitTreeDecoder = function(numBitLevels){\n  this._models = [];\n  this._numBitLevels = numBitLevels;\n};\n\nLZMA.BitTreeDecoder.prototype.init = function(){\n  LZMA.initBitModels(this._models, 1 << this._numBitLevels);\n};\n\nLZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){\n  var m = 1, i = this._numBitLevels;\n\n  while(i --){\n    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);\n  }\n  return m - (1 << this._numBitLevels);\n};\n\nLZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){\n  var m = 1, symbol = 0, i = 0, bit;\n\n  for (; i < this._numBitLevels; ++ i){\n    bit = rangeDecoder.decodeBit(this._models, m);\n    m = (m << 1) | bit;\n    symbol |= bit << i;\n  }\n  return symbol;\n};\n\nLZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){\n  var m = 1, symbol = 0, i = 0, bit;\n\n  for (; i < numBitLevels; ++ i){\n    bit = rangeDecoder.decodeBit(models, startIndex + m);\n    m = (m << 1) | bit;\n    symbol |= bit << i;\n  }\n  return symbol;\n};\n\nLZMA.LenDecoder = function(){\n  this._choice = [];\n  this._lowCoder = [];\n  this._midCoder = [];\n  this._highCoder = new LZMA.BitTreeDecoder(8);\n  this._numPosStates = 0;\n};\n\nLZMA.LenDecoder.prototype.create = function(numPosStates){\n  for (; this._numPosStates < numPosStates; ++ this._numPosStates){\n    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n  }\n};\n\nLZMA.LenDecoder.prototype.init = function(){\n  var i = this._numPosStates;\n  LZMA.initBitModels(this._choice, 2);\n  while(i --){\n    this._lowCoder[i].init();\n    this._midCoder[i].init();\n  }\n  this._highCoder.init();\n};\n\nLZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){\n  if (rangeDecoder.decodeBit(this._choice, 0) === 0){\n    return this._lowCoder[posState].decode(rangeDecoder);\n  }\n  if (rangeDecoder.decodeBit(this._choice, 1) === 0){\n    return 8 + this._midCoder[posState].decode(rangeDecoder);\n  }\n  return 16 + this._highCoder.decode(rangeDecoder);\n};\n\nLZMA.Decoder2 = function(){\n  this._decoders = [];\n};\n\nLZMA.Decoder2.prototype.init = function(){\n  LZMA.initBitModels(this._decoders, 0x300);\n};\n\nLZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){\n  var symbol = 1;\n\n  do{\n    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n  }while(symbol < 0x100);\n\n  return symbol & 0xff;\n};\n\nLZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){\n  var symbol = 1, matchBit, bit;\n\n  do{\n    matchBit = (matchByte >> 7) & 1;\n    matchByte <<= 1;\n    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);\n    symbol = (symbol << 1) | bit;\n    if (matchBit !== bit){\n      while(symbol < 0x100){\n        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n      }\n      break;\n    }\n  }while(symbol < 0x100);\n\n  return symbol & 0xff;\n};\n\nLZMA.LiteralDecoder = function(){\n};\n\nLZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){\n  var i;\n\n  if (this._coders\n    && (this._numPrevBits === numPrevBits)\n    && (this._numPosBits === numPosBits) ){\n    return;\n  }\n  this._numPosBits = numPosBits;\n  this._posMask = (1 << numPosBits) - 1;\n  this._numPrevBits = numPrevBits;\n\n  this._coders = [];\n\n  i = 1 << (this._numPrevBits + this._numPosBits);\n  while(i --){\n    this._coders[i] = new LZMA.Decoder2();\n  }\n};\n\nLZMA.LiteralDecoder.prototype.init = function(){\n  var i = 1 << (this._numPrevBits + this._numPosBits);\n  while(i --){\n    this._coders[i].init();\n  }\n};\n\nLZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){\n  return this._coders[( (pos & this._posMask) << this._numPrevBits)\n    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];\n};\n\nLZMA.Decoder = function(){\n  this._outWindow = new LZMA.OutWindow();\n  this._rangeDecoder = new LZMA.RangeDecoder();\n  this._isMatchDecoders = [];\n  this._isRepDecoders = [];\n  this._isRepG0Decoders = [];\n  this._isRepG1Decoders = [];\n  this._isRepG2Decoders = [];\n  this._isRep0LongDecoders = [];\n  this._posSlotDecoder = [];\n  this._posDecoders = [];\n  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);\n  this._lenDecoder = new LZMA.LenDecoder();\n  this._repLenDecoder = new LZMA.LenDecoder();\n  this._literalDecoder = new LZMA.LiteralDecoder();\n  this._dictionarySize = -1;\n  this._dictionarySizeCheck = -1;\n\n  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);\n};\n\nLZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){\n  if (dictionarySize < 0){\n    return false;\n  }\n  if (this._dictionarySize !== dictionarySize){\n    this._dictionarySize = dictionarySize;\n    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);\n    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );\n  }\n  return true;\n};\n\nLZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){\n  var numPosStates = 1 << pb;\n\n  if (lc > 8 || lp > 4 || pb > 4){\n    return false;\n  }\n\n  this._literalDecoder.create(lp, lc);\n\n  this._lenDecoder.create(numPosStates);\n  this._repLenDecoder.create(numPosStates);\n  this._posStateMask = numPosStates - 1;\n\n  return true;\n};\n\nLZMA.Decoder.prototype.init = function(){\n  var i = 4;\n\n  this._outWindow.init(false);\n\n  LZMA.initBitModels(this._isMatchDecoders, 192);\n  LZMA.initBitModels(this._isRep0LongDecoders, 192);\n  LZMA.initBitModels(this._isRepDecoders, 12);\n  LZMA.initBitModels(this._isRepG0Decoders, 12);\n  LZMA.initBitModels(this._isRepG1Decoders, 12);\n  LZMA.initBitModels(this._isRepG2Decoders, 12);\n  LZMA.initBitModels(this._posDecoders, 114);\n\n  this._literalDecoder.init();\n\n  while(i --){\n    this._posSlotDecoder[i].init();\n  }\n\n  this._lenDecoder.init();\n  this._repLenDecoder.init();\n  this._posAlignDecoder.init();\n  this._rangeDecoder.init();\n};\n\nLZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){\n  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,\n      posState, decoder2, len, distance, posSlot, numDirectBits;\n\n  this._rangeDecoder.setStream(inStream);\n  this._outWindow.setStream(outStream);\n\n  this.init();\n\n  while(outSize < 0 || nowPos64 < outSize){\n    posState = nowPos64 & this._posStateMask;\n\n    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){\n      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);\n\n      if (state >= 7){\n        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );\n      }else{\n        prevByte = decoder2.decodeNormal(this._rangeDecoder);\n      }\n      this._outWindow.putByte(prevByte);\n\n      state = state < 4? 0: state - (state < 10? 3: 6);\n\n    }else{\n\n      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){\n        len = 0;\n        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){\n          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){\n            state = state < 7? 9: 11;\n            len = 1;\n          }\n        }else{\n          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){\n            distance = rep1;\n          }else{\n            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){\n              distance = rep2;\n            }else{\n              distance = rep3;\n              rep3 = rep2;\n            }\n            rep2 = rep1;\n          }\n          rep1 = rep0;\n          rep0 = distance;\n        }\n        if (len === 0){\n          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);\n          state = state < 7? 8: 11;\n        }\n      }else{\n        rep3 = rep2;\n        rep2 = rep1;\n        rep1 = rep0;\n\n        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);\n        state = state < 7? 7: 10;\n\n        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);\n        if (posSlot >= 4){\n\n          numDirectBits = (posSlot >> 1) - 1;\n          rep0 = (2 | (posSlot & 1) ) << numDirectBits;\n\n          if (posSlot < 14){\n            rep0 += LZMA.reverseDecode2(this._posDecoders,\n                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);\n          }else{\n            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;\n            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);\n            if (rep0 < 0){\n              if (rep0 === -1){\n                break;\n              }\n              return false;\n            }\n          }\n        }else{\n          rep0 = posSlot;\n        }\n      }\n\n      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){\n        return false;\n      }\n\n      this._outWindow.copyBlock(rep0, len);\n      nowPos64 += len;\n      prevByte = this._outWindow.getByte(0);\n    }\n  }\n\n  this._outWindow.flush();\n  this._outWindow.releaseStream();\n  this._rangeDecoder.releaseStream();\n\n  return true;\n};\n\nLZMA.Decoder.prototype.setDecoderProperties = function(properties){\n  var value, lc, lp, pb, dictionarySize;\n\n  if (properties.size < 5){\n    return false;\n  }\n\n  value = properties.readByte();\n  lc = value % 9;\n  value = ~~(value / 9);\n  lp = value % 5;\n  pb = ~~(value / 5);\n\n  if ( !this.setLcLpPb(lc, lp, pb) ){\n    return false;\n  }\n\n  dictionarySize = properties.readByte();\n  dictionarySize |= properties.readByte() << 8;\n  dictionarySize |= properties.readByte() << 16;\n  dictionarySize += properties.readByte() * 16777216;\n\n  return this.setDictionarySize(dictionarySize);\n};\n\nLZMA.decompress = function(properties, inStream, outStream, outSize){\n  var decoder = new LZMA.Decoder();\n\n  if ( !decoder.setDecoderProperties(properties) ){\n    throw "Incorrect stream properties";\n  }\n\n  if ( !decoder.decode(inStream, outStream, outSize) ){\n    throw "Error in data stream";\n  }\n\n  return true;\n};\n\nLZMA.decompressFile = function(inStream, outStream){\n  var decoder = new LZMA.Decoder(), outSize;\n\n  if ( !decoder.setDecoderProperties(inStream) ){\n    throw "Incorrect stream properties";\n  }\n\n  outSize = inStream.readByte();\n  outSize |= inStream.readByte() << 8;\n  outSize |= inStream.readByte() << 16;\n  outSize += inStream.readByte() * 16777216;\n\n  inStream.readByte();\n  inStream.readByte();\n  inStream.readByte();\n  inStream.readByte();\n\n  if ( !decoder.decode(inStream, outStream, outSize) ){\n    throw "Error in data stream";\n  }\n\n  return true;\n};\n\n//export default LZMA;\n\n\n';

	var LZMAWorker = '\nfunction decompressBuffer(buffer){\n  var inStream = {\n    data: new Uint8Array(buffer),\n    offset: 0,\n    readByte: function() {\n      return this.data[this.offset++]\n    },\n  }\n  var outStream = {\n    data:[],\n    offset: 0,\n    writeByte: function(val) {\n      this.data[this.offset++] = val\n    },\n  }\n  LZMA.decompressFile(inStream, outStream);\n  var uintGeomArray = new Uint8Array(outStream.data);\n  return uintGeomArray.buffer;\n}\n\nself.onmessage = function( event ) {\n  if(event.data===\'CLOSE\') {\n    self.close();\n    return;\n  }\n\n  try {\n    var decompBuffer = decompressBuffer(event.data.buffer);\n    self.postMessage({type:\'SUCCESS\', buffer:decompBuffer, meta:event.data.meta});\n  } catch(e) {\n    self.postMessage({type:\'FAILURE\', error:e, meta:event.data.meta});\n  }\n\n};\n';


	var workerQueue = [];
	var workerPool = [];

	var workerBlob = void 0;
	try {
	  workerBlob = new Blob([LZMARaw, LZMAWorker], { type: 'application/javascript' });
	} catch (e) {
	  // Backwards-compatibility
	  if (true) {
	    window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
	    workerBlob = new BlobBuilder();
	    workerBlob.append(LZMARaw);
	    workerBlob.append(LZMAWorker);
	    workerBlob = blob.getBlob();
	  }
	}

	var workerLimit =  true ? Math.max(window.navigator.hardwareConcurrency - 1, 1) : 0;

	function requeueWorker(idx) {
	  if (workerQueue.length > 0) {
	    var toBeDecompressed = workerQueue.shift();
	    toBeDecompressed.meta.idx = idx;
	    workerPool[idx].postMessage(toBeDecompressed);
	  } else {
	    workerPool[idx].postMessage('CLOSE');
	    delete workerPool[idx];
	  }
	}

	function lzmaDecompressor(response, meta, onSuccessEnd, onFailure) {
	  var freeWorkerIndex = -1;
	  var idx = 0;
	  var lzmaWorkerObj = (0, _ramda.find)(function (worker) {
	    if (!worker) freeWorkerIndex = idx;else idx++;
	    return !worker;
	  }, workerPool);
	  var numWorkers = workerPool.length;

	  if (workerQueue.length > 0 || typeof Worker !== 'undefined' && Worker && numWorkers >= workerLimit && freeWorkerIndex === -1) {
	    workerQueue.push({
	      buffer: response,
	      meta: meta
	    });
	  } else {
	    if (typeof Worker !== 'undefined' && Worker) {
	      var lzmaWorker = new Worker(URL.createObjectURL(workerBlob));
	      var index = freeWorkerIndex === -1 ? workerPool.length : freeWorkerIndex;
	      lzmaWorker.onmessage = function (event) {
	        if (event.data.type === 'SUCCESS') {
	          onSuccessEnd(event.data.buffer, event.data.meta);
	          requeueWorker(event.data.meta.idx);
	        } else {
	          onFailure(event.data.error, event.data.meta);
	        }
	      };

	      lzmaWorker.postMessage({
	        buffer: response,
	        meta: (0, _assign2.default)({}, meta, { idx: index })
	      });
	      workerPool[index] = lzmaWorker;
	    } else {
	      var inStream = {
	        data: new Uint8Array(response),
	        offset: 0,
	        readByte: function readByte() {
	          return this.data[this.offset++];
	        }
	      };
	      var outStream = {
	        data: [],
	        offset: 0,
	        writeByte: function writeByte(val) {
	          this.data[this.offset++] = val;
	        }
	      };
	      try {
	        _lzma2.default.decompressFile(inStream, outStream);
	        var uintGeomArray = new Uint8Array(outStream.data);
	        onSuccessEnd(uintGeomArray.buffer, meta);
	      } catch (e) {
	        onFailure(e);
	      }
	    }
	  }
	}

/***/ },
/* 105 */
/*!************************!*\
  !*** ./vendor/lzma.js ***!
  \************************/
/***/ function(module, exports) {


	//From Repository: https://github.com/jcmellado/js-lzma
	/*
	Copyright (c) 2011 Juan Mellado
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/

	/*
	References:
	- "LZMA SDK" by Igor Pavlov
	  http://www.7-zip.org/sdk.html
	*/

	var LZMA = LZMA || {};

	LZMA.OutWindow = function(){
	  this._windowSize = 0;
	};

	LZMA.OutWindow.prototype.create = function(windowSize){
	  if ( (!this._buffer) || (this._windowSize !== windowSize) ){
	    this._buffer = [];
	  }
	  this._windowSize = windowSize;
	  this._pos = 0;
	  this._streamPos = 0;
	};

	LZMA.OutWindow.prototype.flush = function(){
	  var size = this._pos - this._streamPos;
	  if (size !== 0){
	    while(size --){
	      this._stream.writeByte(this._buffer[this._streamPos ++]);
	    }
	    if (this._pos >= this._windowSize){
	      this._pos = 0;
	    }
	    this._streamPos = this._pos;
	  }
	};

	LZMA.OutWindow.prototype.releaseStream = function(){
	  this.flush();
	  this._stream = null;
	};

	LZMA.OutWindow.prototype.setStream = function(stream){
	  this.releaseStream();
	  this._stream = stream;
	};

	LZMA.OutWindow.prototype.init = function(solid){
	  if (!solid){
	    this._streamPos = 0;
	    this._pos = 0;
	  }
	};

	LZMA.OutWindow.prototype.copyBlock = function(distance, len){
	  var pos = this._pos - distance - 1;
	  if (pos < 0){
	    pos += this._windowSize;
	  }
	  while(len --){
	    if (pos >= this._windowSize){
	      pos = 0;
	    }
	    this._buffer[this._pos ++] = this._buffer[pos ++];
	    if (this._pos >= this._windowSize){
	      this.flush();
	    }
	  }
	};

	LZMA.OutWindow.prototype.putByte = function(b){
	  this._buffer[this._pos ++] = b;
	  if (this._pos >= this._windowSize){
	    this.flush();
	  }
	};

	LZMA.OutWindow.prototype.getByte = function(distance){
	  var pos = this._pos - distance - 1;
	  if (pos < 0){
	    pos += this._windowSize;
	  }
	  return this._buffer[pos];
	};

	LZMA.RangeDecoder = function(){
	};

	LZMA.RangeDecoder.prototype.setStream = function(stream){
	  this._stream = stream;
	};

	LZMA.RangeDecoder.prototype.releaseStream = function(){
	  this._stream = null;
	};

	LZMA.RangeDecoder.prototype.init = function(){
	  var i = 5;

	  this._code = 0;
	  this._range = -1;

	  while(i --){
	    this._code = (this._code << 8) | this._stream.readByte();
	  }
	};

	LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){
	  var result = 0, i = numTotalBits, t;

	  while(i --){
	    this._range >>>= 1;
	    t = (this._code - this._range) >>> 31;
	    this._code -= this._range & (t - 1);
	    result = (result << 1) | (1 - t);

	    if ( (this._range & 0xff000000) === 0){
	      this._code = (this._code << 8) | this._stream.readByte();
	      this._range <<= 8;
	    }
	  }

	  return result;
	};

	LZMA.RangeDecoder.prototype.decodeBit = function(probs, index){
	  var prob = probs[index],
	      newBound = (this._range >>> 11) * prob;

	  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){
	    this._range = newBound;
	    probs[index] += (2048 - prob) >>> 5;
	    if ( (this._range & 0xff000000) === 0){
	      this._code = (this._code << 8) | this._stream.readByte();
	      this._range <<= 8;
	    }
	    return 0;
	  }

	  this._range -= newBound;
	  this._code -= newBound;
	  probs[index] -= prob >>> 5;
	  if ( (this._range & 0xff000000) === 0){
	    this._code = (this._code << 8) | this._stream.readByte();
	    this._range <<= 8;
	  }
	  return 1;
	};

	LZMA.initBitModels = function(probs, len){
	  while(len --){
	    probs[len] = 1024;
	  }
	};

	LZMA.BitTreeDecoder = function(numBitLevels){
	  this._models = [];
	  this._numBitLevels = numBitLevels;
	};

	LZMA.BitTreeDecoder.prototype.init = function(){
	  LZMA.initBitModels(this._models, 1 << this._numBitLevels);
	};

	LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){
	  var m = 1, i = this._numBitLevels;

	  while(i --){
	    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);
	  }
	  return m - (1 << this._numBitLevels);
	};

	LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){
	  var m = 1, symbol = 0, i = 0, bit;

	  for (; i < this._numBitLevels; ++ i){
	    bit = rangeDecoder.decodeBit(this._models, m);
	    m = (m << 1) | bit;
	    symbol |= bit << i;
	  }
	  return symbol;
	};

	LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){
	  var m = 1, symbol = 0, i = 0, bit;

	  for (; i < numBitLevels; ++ i){
	    bit = rangeDecoder.decodeBit(models, startIndex + m);
	    m = (m << 1) | bit;
	    symbol |= bit << i;
	  }
	  return symbol;
	};

	LZMA.LenDecoder = function(){
	  this._choice = [];
	  this._lowCoder = [];
	  this._midCoder = [];
	  this._highCoder = new LZMA.BitTreeDecoder(8);
	  this._numPosStates = 0;
	};

	LZMA.LenDecoder.prototype.create = function(numPosStates){
	  for (; this._numPosStates < numPosStates; ++ this._numPosStates){
	    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
	    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
	  }
	};

	LZMA.LenDecoder.prototype.init = function(){
	  var i = this._numPosStates;
	  LZMA.initBitModels(this._choice, 2);
	  while(i --){
	    this._lowCoder[i].init();
	    this._midCoder[i].init();
	  }
	  this._highCoder.init();
	};

	LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){
	  if (rangeDecoder.decodeBit(this._choice, 0) === 0){
	    return this._lowCoder[posState].decode(rangeDecoder);
	  }
	  if (rangeDecoder.decodeBit(this._choice, 1) === 0){
	    return 8 + this._midCoder[posState].decode(rangeDecoder);
	  }
	  return 16 + this._highCoder.decode(rangeDecoder);
	};

	LZMA.Decoder2 = function(){
	  this._decoders = [];
	};

	LZMA.Decoder2.prototype.init = function(){
	  LZMA.initBitModels(this._decoders, 0x300);
	};

	LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){
	  var symbol = 1;

	  do{
	    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
	  }while(symbol < 0x100);

	  return symbol & 0xff;
	};

	LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){
	  var symbol = 1, matchBit, bit;

	  do{
	    matchBit = (matchByte >> 7) & 1;
	    matchByte <<= 1;
	    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);
	    symbol = (symbol << 1) | bit;
	    if (matchBit !== bit){
	      while(symbol < 0x100){
	        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
	      }
	      break;
	    }
	  }while(symbol < 0x100);

	  return symbol & 0xff;
	};

	LZMA.LiteralDecoder = function(){
	};

	LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){
	  var i;

	  if (this._coders
	    && (this._numPrevBits === numPrevBits)
	    && (this._numPosBits === numPosBits) ){
	    return;
	  }
	  this._numPosBits = numPosBits;
	  this._posMask = (1 << numPosBits) - 1;
	  this._numPrevBits = numPrevBits;

	  this._coders = [];

	  i = 1 << (this._numPrevBits + this._numPosBits);
	  while(i --){
	    this._coders[i] = new LZMA.Decoder2();
	  }
	};

	LZMA.LiteralDecoder.prototype.init = function(){
	  var i = 1 << (this._numPrevBits + this._numPosBits);
	  while(i --){
	    this._coders[i].init();
	  }
	};

	LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){
	  return this._coders[( (pos & this._posMask) << this._numPrevBits)
	    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];
	};

	LZMA.Decoder = function(){
	  this._outWindow = new LZMA.OutWindow();
	  this._rangeDecoder = new LZMA.RangeDecoder();
	  this._isMatchDecoders = [];
	  this._isRepDecoders = [];
	  this._isRepG0Decoders = [];
	  this._isRepG1Decoders = [];
	  this._isRepG2Decoders = [];
	  this._isRep0LongDecoders = [];
	  this._posSlotDecoder = [];
	  this._posDecoders = [];
	  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);
	  this._lenDecoder = new LZMA.LenDecoder();
	  this._repLenDecoder = new LZMA.LenDecoder();
	  this._literalDecoder = new LZMA.LiteralDecoder();
	  this._dictionarySize = -1;
	  this._dictionarySizeCheck = -1;

	  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);
	  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);
	  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);
	  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);
	};

	LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){
	  if (dictionarySize < 0){
	    return false;
	  }
	  if (this._dictionarySize !== dictionarySize){
	    this._dictionarySize = dictionarySize;
	    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);
	    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );
	  }
	  return true;
	};

	LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){
	  var numPosStates = 1 << pb;

	  if (lc > 8 || lp > 4 || pb > 4){
	    return false;
	  }

	  this._literalDecoder.create(lp, lc);

	  this._lenDecoder.create(numPosStates);
	  this._repLenDecoder.create(numPosStates);
	  this._posStateMask = numPosStates - 1;

	  return true;
	};

	LZMA.Decoder.prototype.init = function(){
	  var i = 4;

	  this._outWindow.init(false);

	  LZMA.initBitModels(this._isMatchDecoders, 192);
	  LZMA.initBitModels(this._isRep0LongDecoders, 192);
	  LZMA.initBitModels(this._isRepDecoders, 12);
	  LZMA.initBitModels(this._isRepG0Decoders, 12);
	  LZMA.initBitModels(this._isRepG1Decoders, 12);
	  LZMA.initBitModels(this._isRepG2Decoders, 12);
	  LZMA.initBitModels(this._posDecoders, 114);

	  this._literalDecoder.init();

	  while(i --){
	    this._posSlotDecoder[i].init();
	  }

	  this._lenDecoder.init();
	  this._repLenDecoder.init();
	  this._posAlignDecoder.init();
	  this._rangeDecoder.init();
	};

	LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){
	  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,
	      posState, decoder2, len, distance, posSlot, numDirectBits;

	  this._rangeDecoder.setStream(inStream);
	  this._outWindow.setStream(outStream);

	  this.init();

	  while(outSize < 0 || nowPos64 < outSize){
	    posState = nowPos64 & this._posStateMask;

	    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){
	      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);

	      if (state >= 7){
	        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );
	      }else{
	        prevByte = decoder2.decodeNormal(this._rangeDecoder);
	      }
	      this._outWindow.putByte(prevByte);

	      state = state < 4? 0: state - (state < 10? 3: 6);

	    }else{

	      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){
	        len = 0;
	        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){
	          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){
	            state = state < 7? 9: 11;
	            len = 1;
	          }
	        }else{
	          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){
	            distance = rep1;
	          }else{
	            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){
	              distance = rep2;
	            }else{
	              distance = rep3;
	              rep3 = rep2;
	            }
	            rep2 = rep1;
	          }
	          rep1 = rep0;
	          rep0 = distance;
	        }
	        if (len === 0){
	          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);
	          state = state < 7? 8: 11;
	        }
	      }else{
	        rep3 = rep2;
	        rep2 = rep1;
	        rep1 = rep0;

	        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);
	        state = state < 7? 7: 10;

	        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);
	        if (posSlot >= 4){

	          numDirectBits = (posSlot >> 1) - 1;
	          rep0 = (2 | (posSlot & 1) ) << numDirectBits;

	          if (posSlot < 14){
	            rep0 += LZMA.reverseDecode2(this._posDecoders,
	                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
	          }else{
	            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;
	            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
	            if (rep0 < 0){
	              if (rep0 === -1){
	                break;
	              }
	              return false;
	            }
	          }
	        }else{
	          rep0 = posSlot;
	        }
	      }

	      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){
	        return false;
	      }

	      this._outWindow.copyBlock(rep0, len);
	      nowPos64 += len;
	      prevByte = this._outWindow.getByte(0);
	    }
	  }

	  this._outWindow.flush();
	  this._outWindow.releaseStream();
	  this._rangeDecoder.releaseStream();

	  return true;
	};

	LZMA.Decoder.prototype.setDecoderProperties = function(properties){
	  var value, lc, lp, pb, dictionarySize;

	  if (properties.size < 5){
	    return false;
	  }

	  value = properties.readByte();
	  lc = value % 9;
	  value = ~~(value / 9);
	  lp = value % 5;
	  pb = ~~(value / 5);

	  if ( !this.setLcLpPb(lc, lp, pb) ){
	    return false;
	  }

	  dictionarySize = properties.readByte();
	  dictionarySize |= properties.readByte() << 8;
	  dictionarySize |= properties.readByte() << 16;
	  dictionarySize += properties.readByte() * 16777216;

	  return this.setDictionarySize(dictionarySize);
	};

	LZMA.decompress = function(properties, inStream, outStream, outSize){
	  var decoder = new LZMA.Decoder();

	  if ( !decoder.setDecoderProperties(properties) ){
	    throw "Incorrect stream properties";
	  }

	  if ( !decoder.decode(inStream, outStream, outSize) ){
	    throw "Error in data stream";
	  }

	  return true;
	};

	LZMA.decompressFile = function(inStream, outStream){
	  var decoder = new LZMA.Decoder(), outSize;

	  if ( !decoder.setDecoderProperties(inStream) ){
	    throw "Incorrect stream properties";
	  }

	  outSize = inStream.readByte();
	  outSize |= inStream.readByte() << 8;
	  outSize |= inStream.readByte() << 16;
	  outSize += inStream.readByte() * 16777216;

	  inStream.readByte();
	  inStream.readByte();
	  inStream.readByte();
	  inStream.readByte();

	  if ( !decoder.decode(inStream, outStream, outSize) ){
	    throw "Error in data stream";
	  }

	  return true;
	};

	module.exports = LZMA;


/***/ },
/* 106 */
/*!*****************************!*\
  !*** ./~/rsvp/dist/rsvp.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {/*!
	 * @overview RSVP - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2016 Yehuda Katz, Tom Dale, Stefan Penner and contributors
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
	 * @version   3.3.3
	 */

	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.RSVP = global.RSVP || {})));
	}(this, (function (exports) { 'use strict';

	function indexOf(callbacks, callback) {
	  for (var i = 0, l = callbacks.length; i < l; i++) {
	    if (callbacks[i] === callback) {
	      return i;
	    }
	  }

	  return -1;
	}

	function callbacksFor(object) {
	  var callbacks = object._promiseCallbacks;

	  if (!callbacks) {
	    callbacks = object._promiseCallbacks = {};
	  }

	  return callbacks;
	}

	/**
	  @class RSVP.EventTarget
	*/
	var EventTarget = {

	  /**
	    `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For
	    Example:
	     ```javascript
	    let object = {};
	     RSVP.EventTarget.mixin(object);
	     object.on('finished', function(event) {
	      // handle event
	    });
	     object.trigger('finished', { detail: value });
	    ```
	     `EventTarget.mixin` also works with prototypes:
	     ```javascript
	    let Person = function() {};
	    RSVP.EventTarget.mixin(Person.prototype);
	     let yehuda = new Person();
	    let tom = new Person();
	     yehuda.on('poke', function(event) {
	      console.log('Yehuda says OW');
	    });
	     tom.on('poke', function(event) {
	      console.log('Tom says OW');
	    });
	     yehuda.trigger('poke');
	    tom.trigger('poke');
	    ```
	     @method mixin
	    @for RSVP.EventTarget
	    @private
	    @param {Object} object object to extend with EventTarget methods
	  */
	  mixin: function mixin(object) {
	    object['on'] = this['on'];
	    object['off'] = this['off'];
	    object['trigger'] = this['trigger'];
	    object._promiseCallbacks = undefined;
	    return object;
	  },

	  /**
	    Registers a callback to be executed when `eventName` is triggered
	     ```javascript
	    object.on('event', function(eventInfo){
	      // handle the event
	    });
	     object.trigger('event');
	    ```
	     @method on
	    @for RSVP.EventTarget
	    @private
	    @param {String} eventName name of the event to listen for
	    @param {Function} callback function to be called when the event is triggered.
	  */
	  on: function on(eventName, callback) {
	    if (typeof callback !== 'function') {
	      throw new TypeError('Callback must be a function');
	    }

	    var allCallbacks = callbacksFor(this),
	        callbacks = undefined;

	    callbacks = allCallbacks[eventName];

	    if (!callbacks) {
	      callbacks = allCallbacks[eventName] = [];
	    }

	    if (indexOf(callbacks, callback) === -1) {
	      callbacks.push(callback);
	    }
	  },

	  /**
	    You can use `off` to stop firing a particular callback for an event:
	     ```javascript
	    function doStuff() { // do stuff! }
	    object.on('stuff', doStuff);
	     object.trigger('stuff'); // doStuff will be called
	     // Unregister ONLY the doStuff callback
	    object.off('stuff', doStuff);
	    object.trigger('stuff'); // doStuff will NOT be called
	    ```
	     If you don't pass a `callback` argument to `off`, ALL callbacks for the
	    event will not be executed when the event fires. For example:
	     ```javascript
	    let callback1 = function(){};
	    let callback2 = function(){};
	     object.on('stuff', callback1);
	    object.on('stuff', callback2);
	     object.trigger('stuff'); // callback1 and callback2 will be executed.
	     object.off('stuff');
	    object.trigger('stuff'); // callback1 and callback2 will not be executed!
	    ```
	     @method off
	    @for RSVP.EventTarget
	    @private
	    @param {String} eventName event to stop listening to
	    @param {Function} callback optional argument. If given, only the function
	    given will be removed from the event's callback queue. If no `callback`
	    argument is given, all callbacks will be removed from the event's callback
	    queue.
	  */
	  off: function off(eventName, callback) {
	    var allCallbacks = callbacksFor(this),
	        callbacks = undefined,
	        index = undefined;

	    if (!callback) {
	      allCallbacks[eventName] = [];
	      return;
	    }

	    callbacks = allCallbacks[eventName];

	    index = indexOf(callbacks, callback);

	    if (index !== -1) {
	      callbacks.splice(index, 1);
	    }
	  },

	  /**
	    Use `trigger` to fire custom events. For example:
	     ```javascript
	    object.on('foo', function(){
	      console.log('foo event happened!');
	    });
	    object.trigger('foo');
	    // 'foo event happened!' logged to the console
	    ```
	     You can also pass a value as a second argument to `trigger` that will be
	    passed as an argument to all event listeners for the event:
	     ```javascript
	    object.on('foo', function(value){
	      console.log(value.name);
	    });
	     object.trigger('foo', { name: 'bar' });
	    // 'bar' logged to the console
	    ```
	     @method trigger
	    @for RSVP.EventTarget
	    @private
	    @param {String} eventName name of the event to be triggered
	    @param {*} options optional value to be passed to any event handlers for
	    the given `eventName`
	  */
	  trigger: function trigger(eventName, options, label) {
	    var allCallbacks = callbacksFor(this),
	        callbacks = undefined,
	        callback = undefined;

	    if (callbacks = allCallbacks[eventName]) {
	      // Don't cache the callbacks.length since it may grow
	      for (var i = 0; i < callbacks.length; i++) {
	        callback = callbacks[i];

	        callback(options, label);
	      }
	    }
	  }
	};

	var config = {
	  instrument: false
	};

	EventTarget['mixin'](config);

	function configure(name, value) {
	  if (name === 'onerror') {
	    // handle for legacy users that expect the actual
	    // error to be passed to their function added via
	    // `RSVP.configure('onerror', someFunctionHere);`
	    config['on']('error', value);
	    return;
	  }

	  if (arguments.length === 2) {
	    config[name] = value;
	  } else {
	    return config[name];
	  }
	}

	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}

	function isFunction(x) {
	  return typeof x === 'function';
	}

	function isMaybeThenable(x) {
	  return typeof x === 'object' && x !== null;
	}

	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}

	var isArray = _isArray;

	// Date.now is not available in browsers < IE9
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
	var now = Date.now || function () {
	  return new Date().getTime();
	};

	function F() {}

	var o_create = Object.create || function (o) {
	  if (arguments.length > 1) {
	    throw new Error('Second argument not supported');
	  }
	  if (typeof o !== 'object') {
	    throw new TypeError('Argument must be an object');
	  }
	  F.prototype = o;
	  return new F();
	};

	var queue = [];

	function scheduleFlush() {
	  setTimeout(function () {
	    for (var i = 0; i < queue.length; i++) {
	      var entry = queue[i];

	      var payload = entry.payload;

	      payload.guid = payload.key + payload.id;
	      payload.childGuid = payload.key + payload.childId;
	      if (payload.error) {
	        payload.stack = payload.error.stack;
	      }

	      config['trigger'](entry.name, entry.payload);
	    }
	    queue.length = 0;
	  }, 50);
	}
	function instrument(eventName, promise, child) {
	  if (1 === queue.push({
	    name: eventName,
	    payload: {
	      key: promise._guidKey,
	      id: promise._id,
	      eventName: eventName,
	      detail: promise._result,
	      childId: child && child._id,
	      label: promise._label,
	      timeStamp: now(),
	      error: config["instrument-with-stack"] ? new Error(promise._label) : null
	    } })) {
	    scheduleFlush();
	  }
	}

	/**
	  `RSVP.Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:

	  ```javascript
	  let promise = new RSVP.Promise(function(resolve, reject){
	    resolve(1);
	  });

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = RSVP.Promise.resolve(1);

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  @method resolve
	  @static
	  @param {*} object value that the returned promise will be resolved with
	  @param {String} label optional string for identifying the returned promise.
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve$1(object, label) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }

	  var promise = new Constructor(noop, label);
	  resolve(promise, object);
	  return promise;
	}

	function withOwnPromise() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}

	function noop() {}

	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;

	var GET_THEN_ERROR = new ErrorObject();

	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}

	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}

	function handleForeignThenable(promise, thenable, then) {
	  config.async(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        resolve(promise, value, undefined);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;

	      reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));

	    if (!sealed && error) {
	      sealed = true;
	      reject(promise, error);
	    }
	  }, promise);
	}

	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    thenable._onError = null;
	    reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      if (thenable !== value) {
	        resolve(promise, value, undefined);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      return reject(promise, reason);
	    });
	  }
	}

	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && promise.constructor.resolve === resolve$1) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}

	function resolve(promise, value) {
	  if (promise === value) {
	    fulfill(promise, value);
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}

	function publishRejection(promise) {
	  if (promise._onError) {
	    promise._onError(promise._result);
	  }

	  publish(promise);
	}

	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }

	  promise._result = value;
	  promise._state = FULFILLED;

	  if (promise._subscribers.length === 0) {
	    if (config.instrument) {
	      instrument('fulfilled', promise);
	    }
	  } else {
	    config.async(publish, promise);
	  }
	}

	function reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;
	  config.async(publishRejection, promise);
	}

	function subscribe(parent, child, onFulfillment, onRejection) {
	  var subscribers = parent._subscribers;
	  var length = subscribers.length;

	  parent._onError = null;

	  subscribers[length] = child;
	  subscribers[length + FULFILLED] = onFulfillment;
	  subscribers[length + REJECTED] = onRejection;

	  if (length === 0 && parent._state) {
	    config.async(publish, parent);
	  }
	}

	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;

	  if (config.instrument) {
	    instrument(settled === FULFILLED ? 'fulfilled' : 'rejected', promise);
	  }

	  if (subscribers.length === 0) {
	    return;
	  }

	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;

	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];

	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }

	  promise._subscribers.length = 0;
	}

	function ErrorObject() {
	  this.error = null;
	}

	var TRY_CATCH_ERROR = new ErrorObject();

	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}

	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;

	  if (hasCallback) {
	    value = tryCatch(callback, detail);

	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }

	    if (promise === value) {
	      reject(promise, withOwnPromise());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }

	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      resolve(promise, value);
	    } else if (failed) {
	      reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      reject(promise, value);
	    }
	}

	function initializePromise(promise, resolver) {
	  var resolved = false;
	  try {
	    resolver(function (value) {
	      if (resolved) {
	        return;
	      }
	      resolved = true;
	      resolve(promise, value);
	    }, function (reason) {
	      if (resolved) {
	        return;
	      }
	      resolved = true;
	      reject(promise, reason);
	    });
	  } catch (e) {
	    reject(promise, e);
	  }
	}

	function then(onFulfillment, onRejection, label) {
	  var _arguments = arguments;

	  var parent = this;
	  var state = parent._state;

	  if (state === FULFILLED && !onFulfillment || state === REJECTED && !onRejection) {
	    config.instrument && instrument('chained', parent, parent);
	    return parent;
	  }

	  parent._onError = null;

	  var child = new parent.constructor(noop, label);
	  var result = parent._result;

	  config.instrument && instrument('chained', parent, child);

	  if (state) {
	    (function () {
	      var callback = _arguments[state - 1];
	      config.async(function () {
	        return invokeCallback(state, child, callback, result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }

	  return child;
	}

	function makeSettledResult(state, position, value) {
	  if (state === FULFILLED) {
	    return {
	      state: 'fulfilled',
	      value: value
	    };
	  } else {
	    return {
	      state: 'rejected',
	      reason: value
	    };
	  }
	}

	function Enumerator(Constructor, input, abortOnReject, label) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop, label);
	  this._abortOnReject = abortOnReject;

	  if (this._validateInput(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;

	    this._init();

	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    reject(this.promise, this._validationError());
	  }
	}

	Enumerator.prototype._validateInput = function (input) {
	  return isArray(input);
	};

	Enumerator.prototype._validationError = function () {
	  return new Error('Array Methods must be provided an Array');
	};

	Enumerator.prototype._init = function () {
	  this._result = new Array(this.length);
	};

	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var promise = this.promise;
	  var input = this._input;

	  for (var i = 0; promise._state === PENDING && i < length; i++) {
	    this._eachEntry(input[i], i);
	  }
	};

	Enumerator.prototype._settleMaybeThenable = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve = c.resolve;

	  if (resolve === resolve$1) {
	    var then$$ = getThen(entry);

	    if (then$$ === then && entry._state !== PENDING) {
	      entry._onError = null;
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof then$$ !== 'function') {
	      this._remaining--;
	      this._result[i] = this._makeResult(FULFILLED, i, entry);
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, then$$);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve) {
	        return resolve(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve(entry), i);
	  }
	};

	Enumerator.prototype._eachEntry = function (entry, i) {
	  if (isMaybeThenable(entry)) {
	    this._settleMaybeThenable(entry, i);
	  } else {
	    this._remaining--;
	    this._result[i] = this._makeResult(FULFILLED, i, entry);
	  }
	};

	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;

	  if (promise._state === PENDING) {
	    this._remaining--;

	    if (this._abortOnReject && state === REJECTED) {
	      reject(promise, value);
	    } else {
	      this._result[i] = this._makeResult(state, i, value);
	    }
	  }

	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};

	Enumerator.prototype._makeResult = function (state, i, value) {
	  return value;
	};

	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;

	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};

	/**
	  `RSVP.Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.

	  Example:

	  ```javascript
	  let promise1 = RSVP.resolve(1);
	  let promise2 = RSVP.resolve(2);
	  let promise3 = RSVP.resolve(3);
	  let promises = [ promise1, promise2, promise3 ];

	  RSVP.Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```

	  If any of the `promises` given to `RSVP.all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:

	  Example:

	  ```javascript
	  let promise1 = RSVP.resolve(1);
	  let promise2 = RSVP.reject(new Error("2"));
	  let promise3 = RSVP.reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];

	  RSVP.Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```

	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries, label) {
	  return new Enumerator(this, entries, true, /* abort on reject */label).promise;
	}

	/**
	  `RSVP.Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.

	  Example:

	  ```javascript
	  let promise1 = new RSVP.Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new RSVP.Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });

	  RSVP.Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```

	  `RSVP.Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:

	  ```javascript
	  let promise1 = new RSVP.Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new RSVP.Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });

	  RSVP.Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```

	  An example real-world use case is implementing timeouts:

	  ```javascript
	  RSVP.Promise.race([ajax('foo.json'), timeout(5000)])
	  ```

	  @method race
	  @static
	  @param {Array} entries array of promises to observe
	  @param {String} label optional string for describing the promise returned.
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries, label) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  var promise = new Constructor(noop, label);

	  if (!isArray(entries)) {
	    reject(promise, new TypeError('You must pass an array to race.'));
	    return promise;
	  }

	  for (var i = 0; promise._state === PENDING && i < entries.length; i++) {
	    subscribe(Constructor.resolve(entries[i]), undefined, function (value) {
	      return resolve(promise, value);
	    }, function (reason) {
	      return reject(promise, reason);
	    });
	  }

	  return promise;
	}

	/**
	  `RSVP.Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:

	  ```javascript
	  let promise = new RSVP.Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = RSVP.Promise.reject(new Error('WHOOPS'));

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  @method reject
	  @static
	  @param {*} reason value that the returned promise will be rejected with.
	  @param {String} label optional string for identifying the returned promise.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject$1(reason, label) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop, label);
	  reject(promise, reason);
	  return promise;
	}

	var guidKey = 'rsvp_' + now() + '-';
	var counter = 0;

	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}

	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}

	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise’s eventual value or the reason
	  why the promise cannot be fulfilled.

	  Terminology
	  -----------

	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.

	  A promise can be in one of three states: pending, fulfilled, or rejected.

	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.

	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.


	  Basic Usage:
	  ------------

	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);

	    // on failure
	    reject(reason);
	  });

	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Advanced Usage:
	  ---------------

	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.

	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();

	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();

	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }

	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Unlike callbacks, promises are great composable primitives.

	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON

	    return values;
	  });
	  ```

	  @class RSVP.Promise
	  @param {function} resolver
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver, label) {
	  this._id = counter++;
	  this._label = label;
	  this._state = undefined;
	  this._result = undefined;
	  this._subscribers = [];

	  config.instrument && instrument('created', this);

	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}

	Promise.cast = resolve$1; // deprecated
	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve$1;
	Promise.reject = reject$1;

	Promise.prototype = {
	  constructor: Promise,

	  _guidKey: guidKey,

	  _onError: function _onError(reason) {
	    var promise = this;
	    config.after(function () {
	      if (promise._onError) {
	        config['trigger']('error', reason, promise._label);
	      }
	    });
	  },

	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.

	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```

	    Chaining
	    --------

	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.

	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });

	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we\'re unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we\'re unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```

	    Assimilation
	    ------------

	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.

	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```

	    If the assimliated promise rejects, then the downstream promise will also reject.

	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```

	    Simple Example
	    --------------

	    Synchronous Example

	    ```javascript
	    let result;

	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```

	    Errback Example

	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```

	    Promise Example;

	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```

	    Advanced Example
	    --------------

	    Synchronous Example

	    ```javascript
	    let author, books;

	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```

	    Errback Example

	    ```js

	    function foundBooks(books) {

	    }

	    function failure(reason) {

	    }

	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```

	    Promise Example;

	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```

	    @method then
	    @param {Function} onFulfillment
	    @param {Function} onRejection
	    @param {String} label optional string for labeling the promise.
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,

	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.

	    ```js
	    function findAuthor(){
	      throw new Error('couldn\'t find that author');
	    }

	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }

	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```

	    @method catch
	    @param {Function} onRejection
	    @param {String} label optional string for labeling the promise.
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection, label) {
	    return this.then(undefined, onRejection, label);
	  },

	  /**
	    `finally` will be invoked regardless of the promise's fate just as native
	    try/catch/finally behaves

	    Synchronous example:

	    ```js
	    findAuthor() {
	      if (Math.random() > 0.5) {
	        throw new Error();
	      }
	      return new Author();
	    }

	    try {
	      return findAuthor(); // succeed or fail
	    } catch(error) {
	      return findOtherAuther();
	    } finally {
	      // always runs
	      // doesn't affect the return value
	    }
	    ```

	    Asynchronous example:

	    ```js
	    findAuthor().catch(function(reason){
	      return findOtherAuther();
	    }).finally(function(){
	      // author was either found, or not
	    });
	    ```

	    @method finally
	    @param {Function} callback
	    @param {String} label optional string for labeling the promise.
	    Useful for tooling.
	    @return {Promise}
	  */
	  'finally': function _finally(callback, label) {
	    var promise = this;
	    var constructor = promise.constructor;

	    return promise.then(function (value) {
	      return constructor.resolve(callback()).then(function () {
	        return value;
	      });
	    }, function (reason) {
	      return constructor.resolve(callback()).then(function () {
	        throw reason;
	      });
	    }, label);
	  }
	};

	function Result() {
	  this.value = undefined;
	}

	var ERROR = new Result();
	var GET_THEN_ERROR$1 = new Result();

	function getThen$1(obj) {
	  try {
	    return obj.then;
	  } catch (error) {
	    ERROR.value = error;
	    return ERROR;
	  }
	}

	function tryApply(f, s, a) {
	  try {
	    f.apply(s, a);
	  } catch (error) {
	    ERROR.value = error;
	    return ERROR;
	  }
	}

	function makeObject(_, argumentNames) {
	  var obj = {};
	  var length = _.length;
	  var args = new Array(length);

	  for (var x = 0; x < length; x++) {
	    args[x] = _[x];
	  }

	  for (var i = 0; i < argumentNames.length; i++) {
	    var _name = argumentNames[i];
	    obj[_name] = args[i + 1];
	  }

	  return obj;
	}

	function arrayResult(_) {
	  var length = _.length;
	  var args = new Array(length - 1);

	  for (var i = 1; i < length; i++) {
	    args[i - 1] = _[i];
	  }

	  return args;
	}

	function wrapThenable(_then, promise) {
	  return {
	    then: function then(onFulFillment, onRejection) {
	      return _then.call(promise, onFulFillment, onRejection);
	    }
	  };
	}

	/**
	  `RSVP.denodeify` takes a 'node-style' function and returns a function that
	  will return an `RSVP.Promise`. You can use `denodeify` in Node.js or the
	  browser when you'd prefer to use promises over using callbacks. For example,
	  `denodeify` transforms the following:

	  ```javascript
	  let fs = require('fs');

	  fs.readFile('myfile.txt', function(err, data){
	    if (err) return handleError(err);
	    handleData(data);
	  });
	  ```

	  into:

	  ```javascript
	  let fs = require('fs');
	  let readFile = RSVP.denodeify(fs.readFile);

	  readFile('myfile.txt').then(handleData, handleError);
	  ```

	  If the node function has multiple success parameters, then `denodeify`
	  just returns the first one:

	  ```javascript
	  let request = RSVP.denodeify(require('request'));

	  request('http://example.com').then(function(res) {
	    // ...
	  });
	  ```

	  However, if you need all success parameters, setting `denodeify`'s
	  second parameter to `true` causes it to return all success parameters
	  as an array:

	  ```javascript
	  let request = RSVP.denodeify(require('request'), true);

	  request('http://example.com').then(function(result) {
	    // result[0] -> res
	    // result[1] -> body
	  });
	  ```

	  Or if you pass it an array with names it returns the parameters as a hash:

	  ```javascript
	  let request = RSVP.denodeify(require('request'), ['res', 'body']);

	  request('http://example.com').then(function(result) {
	    // result.res
	    // result.body
	  });
	  ```

	  Sometimes you need to retain the `this`:

	  ```javascript
	  let app = require('express')();
	  let render = RSVP.denodeify(app.render.bind(app));
	  ```

	  The denodified function inherits from the original function. It works in all
	  environments, except IE 10 and below. Consequently all properties of the original
	  function are available to you. However, any properties you change on the
	  denodeified function won't be changed on the original function. Example:

	  ```javascript
	  let request = RSVP.denodeify(require('request')),
	      cookieJar = request.jar(); // <- Inheritance is used here

	  request('http://example.com', {jar: cookieJar}).then(function(res) {
	    // cookieJar.cookies holds now the cookies returned by example.com
	  });
	  ```

	  Using `denodeify` makes it easier to compose asynchronous operations instead
	  of using callbacks. For example, instead of:

	  ```javascript
	  let fs = require('fs');

	  fs.readFile('myfile.txt', function(err, data){
	    if (err) { ... } // Handle error
	    fs.writeFile('myfile2.txt', data, function(err){
	      if (err) { ... } // Handle error
	      console.log('done')
	    });
	  });
	  ```

	  you can chain the operations together using `then` from the returned promise:

	  ```javascript
	  let fs = require('fs');
	  let readFile = RSVP.denodeify(fs.readFile);
	  let writeFile = RSVP.denodeify(fs.writeFile);

	  readFile('myfile.txt').then(function(data){
	    return writeFile('myfile2.txt', data);
	  }).then(function(){
	    console.log('done')
	  }).catch(function(error){
	    // Handle error
	  });
	  ```

	  @method denodeify
	  @static
	  @for RSVP
	  @param {Function} nodeFunc a 'node-style' function that takes a callback as
	  its last argument. The callback expects an error to be passed as its first
	  argument (if an error occurred, otherwise null), and the value from the
	  operation as its second argument ('function(err, value){ }').
	  @param {Boolean|Array} [options] An optional paramter that if set
	  to `true` causes the promise to fulfill with the callback's success arguments
	  as an array. This is useful if the node function has multiple success
	  paramters. If you set this paramter to an array with names, the promise will
	  fulfill with a hash with these names as keys and the success parameters as
	  values.
	  @return {Function} a function that wraps `nodeFunc` to return an
	  `RSVP.Promise`
	  @static
	*/
	function denodeify(nodeFunc, options) {
	  var fn = function fn() {
	    var self = this;
	    var l = arguments.length;
	    var args = new Array(l + 1);
	    var promiseInput = false;

	    for (var i = 0; i < l; ++i) {
	      var arg = arguments[i];

	      if (!promiseInput) {
	        // TODO: clean this up
	        promiseInput = needsPromiseInput(arg);
	        if (promiseInput === GET_THEN_ERROR$1) {
	          var p = new Promise(noop);
	          reject(p, GET_THEN_ERROR$1.value);
	          return p;
	        } else if (promiseInput && promiseInput !== true) {
	          arg = wrapThenable(promiseInput, arg);
	        }
	      }
	      args[i] = arg;
	    }

	    var promise = new Promise(noop);

	    args[l] = function (err, val) {
	      if (err) reject(promise, err);else if (options === undefined) resolve(promise, val);else if (options === true) resolve(promise, arrayResult(arguments));else if (isArray(options)) resolve(promise, makeObject(arguments, options));else resolve(promise, val);
	    };

	    if (promiseInput) {
	      return handlePromiseInput(promise, args, nodeFunc, self);
	    } else {
	      return handleValueInput(promise, args, nodeFunc, self);
	    }
	  };

	  fn.__proto__ = nodeFunc;

	  return fn;
	}

	function handleValueInput(promise, args, nodeFunc, self) {
	  var result = tryApply(nodeFunc, self, args);
	  if (result === ERROR) {
	    reject(promise, result.value);
	  }
	  return promise;
	}

	function handlePromiseInput(promise, args, nodeFunc, self) {
	  return Promise.all(args).then(function (args) {
	    var result = tryApply(nodeFunc, self, args);
	    if (result === ERROR) {
	      reject(promise, result.value);
	    }
	    return promise;
	  });
	}

	function needsPromiseInput(arg) {
	  if (arg && typeof arg === 'object') {
	    if (arg.constructor === Promise) {
	      return true;
	    } else {
	      return getThen$1(arg);
	    }
	  } else {
	    return false;
	  }
	}

	/**
	  This is a convenient alias for `RSVP.Promise.all`.

	  @method all
	  @static
	  @for RSVP
	  @param {Array} array Array of promises.
	  @param {String} label An optional label. This is useful
	  for tooling.
	*/
	function all$1(array, label) {
	  return Promise.all(array, label);
	}

	function AllSettled(Constructor, entries, label) {
	  this._superConstructor(Constructor, entries, false, /* don't abort on reject */label);
	}

	AllSettled.prototype = o_create(Enumerator.prototype);
	AllSettled.prototype._superConstructor = Enumerator;
	AllSettled.prototype._makeResult = makeSettledResult;
	AllSettled.prototype._validationError = function () {
	  return new Error('allSettled must be called with an array');
	};

	/**
	  `RSVP.allSettled` is similar to `RSVP.all`, but instead of implementing
	  a fail-fast method, it waits until all the promises have returned and
	  shows you all the results. This is useful if you want to handle multiple
	  promises' failure states together as a set.

	  Returns a promise that is fulfilled when all the given promises have been
	  settled. The return promise is fulfilled with an array of the states of
	  the promises passed into the `promises` array argument.

	  Each state object will either indicate fulfillment or rejection, and
	  provide the corresponding value or reason. The states will take one of
	  the following formats:

	  ```javascript
	  { state: 'fulfilled', value: value }
	    or
	  { state: 'rejected', reason: reason }
	  ```

	  Example:

	  ```javascript
	  let promise1 = RSVP.Promise.resolve(1);
	  let promise2 = RSVP.Promise.reject(new Error('2'));
	  let promise3 = RSVP.Promise.reject(new Error('3'));
	  let promises = [ promise1, promise2, promise3 ];

	  RSVP.allSettled(promises).then(function(array){
	    // array == [
	    //   { state: 'fulfilled', value: 1 },
	    //   { state: 'rejected', reason: Error },
	    //   { state: 'rejected', reason: Error }
	    // ]
	    // Note that for the second item, reason.message will be '2', and for the
	    // third item, reason.message will be '3'.
	  }, function(error) {
	    // Not run. (This block would only be called if allSettled had failed,
	    // for instance if passed an incorrect argument type.)
	  });
	  ```

	  @method allSettled
	  @static
	  @for RSVP
	  @param {Array} entries
	  @param {String} label - optional string that describes the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled with an array of the settled
	  states of the constituent promises.
	*/
	function allSettled(entries, label) {
	  return new AllSettled(Promise, entries, label).promise;
	}

	/**
	  This is a convenient alias for `RSVP.Promise.race`.

	  @method race
	  @static
	  @for RSVP
	  @param {Array} array Array of promises.
	  @param {String} label An optional label. This is useful
	  for tooling.
	 */
	function race$1(array, label) {
	  return Promise.race(array, label);
	}

	function PromiseHash(Constructor, object, label) {
	  this._superConstructor(Constructor, object, true, label);
	}

	PromiseHash.prototype = o_create(Enumerator.prototype);
	PromiseHash.prototype._superConstructor = Enumerator;
	PromiseHash.prototype._init = function () {
	  this._result = {};
	};

	PromiseHash.prototype._validateInput = function (input) {
	  return input && typeof input === 'object';
	};

	PromiseHash.prototype._validationError = function () {
	  return new Error('Promise.hash must be called with an object');
	};

	PromiseHash.prototype._enumerate = function () {
	  var enumerator = this;
	  var promise = enumerator.promise;
	  var input = enumerator._input;
	  var results = [];

	  for (var key in input) {
	    if (promise._state === PENDING && Object.prototype.hasOwnProperty.call(input, key)) {
	      results.push({
	        position: key,
	        entry: input[key]
	      });
	    }
	  }

	  var length = results.length;
	  enumerator._remaining = length;
	  var result = undefined;

	  for (var i = 0; promise._state === PENDING && i < length; i++) {
	    result = results[i];
	    enumerator._eachEntry(result.entry, result.position);
	  }
	};

	/**
	  `RSVP.hash` is similar to `RSVP.all`, but takes an object instead of an array
	  for its `promises` argument.

	  Returns a promise that is fulfilled when all the given promises have been
	  fulfilled, or rejected if any of them become rejected. The returned promise
	  is fulfilled with a hash that has the same key names as the `promises` object
	  argument. If any of the values in the object are not promises, they will
	  simply be copied over to the fulfilled object.

	  Example:

	  ```javascript
	  let promises = {
	    myPromise: RSVP.resolve(1),
	    yourPromise: RSVP.resolve(2),
	    theirPromise: RSVP.resolve(3),
	    notAPromise: 4
	  };

	  RSVP.hash(promises).then(function(hash){
	    // hash here is an object that looks like:
	    // {
	    //   myPromise: 1,
	    //   yourPromise: 2,
	    //   theirPromise: 3,
	    //   notAPromise: 4
	    // }
	  });
	  ````

	  If any of the `promises` given to `RSVP.hash` are rejected, the first promise
	  that is rejected will be given as the reason to the rejection handler.

	  Example:

	  ```javascript
	  let promises = {
	    myPromise: RSVP.resolve(1),
	    rejectedPromise: RSVP.reject(new Error('rejectedPromise')),
	    anotherRejectedPromise: RSVP.reject(new Error('anotherRejectedPromise')),
	  };

	  RSVP.hash(promises).then(function(hash){
	    // Code here never runs because there are rejected promises!
	  }, function(reason) {
	    // reason.message === 'rejectedPromise'
	  });
	  ```

	  An important note: `RSVP.hash` is intended for plain JavaScript objects that
	  are just a set of keys and values. `RSVP.hash` will NOT preserve prototype
	  chains.

	  Example:

	  ```javascript
	  function MyConstructor(){
	    this.example = RSVP.resolve('Example');
	  }

	  MyConstructor.prototype = {
	    protoProperty: RSVP.resolve('Proto Property')
	  };

	  let myObject = new MyConstructor();

	  RSVP.hash(myObject).then(function(hash){
	    // protoProperty will not be present, instead you will just have an
	    // object that looks like:
	    // {
	    //   example: 'Example'
	    // }
	    //
	    // hash.hasOwnProperty('protoProperty'); // false
	    // 'undefined' === typeof hash.protoProperty
	  });
	  ```

	  @method hash
	  @static
	  @for RSVP
	  @param {Object} object
	  @param {String} label optional string that describes the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all properties of `promises`
	  have been fulfilled, or rejected if any of them become rejected.
	*/
	function hash(object, label) {
	  return new PromiseHash(Promise, object, label).promise;
	}

	function HashSettled(Constructor, object, label) {
	  this._superConstructor(Constructor, object, false, label);
	}

	HashSettled.prototype = o_create(PromiseHash.prototype);
	HashSettled.prototype._superConstructor = Enumerator;
	HashSettled.prototype._makeResult = makeSettledResult;

	HashSettled.prototype._validationError = function () {
	  return new Error('hashSettled must be called with an object');
	};

	/**
	  `RSVP.hashSettled` is similar to `RSVP.allSettled`, but takes an object
	  instead of an array for its `promises` argument.

	  Unlike `RSVP.all` or `RSVP.hash`, which implement a fail-fast method,
	  but like `RSVP.allSettled`, `hashSettled` waits until all the
	  constituent promises have returned and then shows you all the results
	  with their states and values/reasons. This is useful if you want to
	  handle multiple promises' failure states together as a set.

	  Returns a promise that is fulfilled when all the given promises have been
	  settled, or rejected if the passed parameters are invalid.

	  The returned promise is fulfilled with a hash that has the same key names as
	  the `promises` object argument. If any of the values in the object are not
	  promises, they will be copied over to the fulfilled object and marked with state
	  'fulfilled'.

	  Example:

	  ```javascript
	  let promises = {
	    myPromise: RSVP.Promise.resolve(1),
	    yourPromise: RSVP.Promise.resolve(2),
	    theirPromise: RSVP.Promise.resolve(3),
	    notAPromise: 4
	  };

	  RSVP.hashSettled(promises).then(function(hash){
	    // hash here is an object that looks like:
	    // {
	    //   myPromise: { state: 'fulfilled', value: 1 },
	    //   yourPromise: { state: 'fulfilled', value: 2 },
	    //   theirPromise: { state: 'fulfilled', value: 3 },
	    //   notAPromise: { state: 'fulfilled', value: 4 }
	    // }
	  });
	  ```

	  If any of the `promises` given to `RSVP.hash` are rejected, the state will
	  be set to 'rejected' and the reason for rejection provided.

	  Example:

	  ```javascript
	  let promises = {
	    myPromise: RSVP.Promise.resolve(1),
	    rejectedPromise: RSVP.Promise.reject(new Error('rejection')),
	    anotherRejectedPromise: RSVP.Promise.reject(new Error('more rejection')),
	  };

	  RSVP.hashSettled(promises).then(function(hash){
	    // hash here is an object that looks like:
	    // {
	    //   myPromise:              { state: 'fulfilled', value: 1 },
	    //   rejectedPromise:        { state: 'rejected', reason: Error },
	    //   anotherRejectedPromise: { state: 'rejected', reason: Error },
	    // }
	    // Note that for rejectedPromise, reason.message == 'rejection',
	    // and for anotherRejectedPromise, reason.message == 'more rejection'.
	  });
	  ```

	  An important note: `RSVP.hashSettled` is intended for plain JavaScript objects that
	  are just a set of keys and values. `RSVP.hashSettled` will NOT preserve prototype
	  chains.

	  Example:

	  ```javascript
	  function MyConstructor(){
	    this.example = RSVP.Promise.resolve('Example');
	  }

	  MyConstructor.prototype = {
	    protoProperty: RSVP.Promise.resolve('Proto Property')
	  };

	  let myObject = new MyConstructor();

	  RSVP.hashSettled(myObject).then(function(hash){
	    // protoProperty will not be present, instead you will just have an
	    // object that looks like:
	    // {
	    //   example: { state: 'fulfilled', value: 'Example' }
	    // }
	    //
	    // hash.hasOwnProperty('protoProperty'); // false
	    // 'undefined' === typeof hash.protoProperty
	  });
	  ```

	  @method hashSettled
	  @for RSVP
	  @param {Object} object
	  @param {String} label optional string that describes the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when when all properties of `promises`
	  have been settled.
	  @static
	*/
	function hashSettled(object, label) {
	  return new HashSettled(Promise, object, label).promise;
	}

	function rethrow(reason) {
	  setTimeout(function () {
	    throw reason;
	  });
	  throw reason;
	}

	/**
	  `RSVP.defer` returns an object similar to jQuery's `$.Deferred`.
	  `RSVP.defer` should be used when porting over code reliant on `$.Deferred`'s
	  interface. New code should use the `RSVP.Promise` constructor instead.

	  The object returned from `RSVP.defer` is a plain object with three properties:

	  * promise - an `RSVP.Promise`.
	  * reject - a function that causes the `promise` property on this object to
	    become rejected
	  * resolve - a function that causes the `promise` property on this object to
	    become fulfilled.

	  Example:

	   ```javascript
	   let deferred = RSVP.defer();

	   deferred.resolve("Success!");

	   deferred.promise.then(function(value){
	     // value here is "Success!"
	   });
	   ```

	  @method defer
	  @static
	  @for RSVP
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Object}
	 */
	function defer(label) {
	  var deferred = { resolve: undefined, reject: undefined };

	  deferred.promise = new Promise(function (resolve, reject) {
	    deferred.resolve = resolve;
	    deferred.reject = reject;
	  }, label);

	  return deferred;
	}

	/**
	 `RSVP.map` is similar to JavaScript's native `map` method, except that it
	  waits for all promises to become fulfilled before running the `mapFn` on
	  each item in given to `promises`. `RSVP.map` returns a promise that will
	  become fulfilled with the result of running `mapFn` on the values the promises
	  become fulfilled with.

	  For example:

	  ```javascript

	  let promise1 = RSVP.resolve(1);
	  let promise2 = RSVP.resolve(2);
	  let promise3 = RSVP.resolve(3);
	  let promises = [ promise1, promise2, promise3 ];

	  let mapFn = function(item){
	    return item + 1;
	  };

	  RSVP.map(promises, mapFn).then(function(result){
	    // result is [ 2, 3, 4 ]
	  });
	  ```

	  If any of the `promises` given to `RSVP.map` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promise's
	  rejection handler. For example:

	  ```javascript
	  let promise1 = RSVP.resolve(1);
	  let promise2 = RSVP.reject(new Error('2'));
	  let promise3 = RSVP.reject(new Error('3'));
	  let promises = [ promise1, promise2, promise3 ];

	  let mapFn = function(item){
	    return item + 1;
	  };

	  RSVP.map(promises, mapFn).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(reason) {
	    // reason.message === '2'
	  });
	  ```

	  `RSVP.map` will also wait if a promise is returned from `mapFn`. For example,
	  say you want to get all comments from a set of blog posts, but you need
	  the blog posts first because they contain a url to those comments.

	  ```javscript

	  let mapFn = function(blogPost){
	    // getComments does some ajax and returns an RSVP.Promise that is fulfilled
	    // with some comments data
	    return getComments(blogPost.comments_url);
	  };

	  // getBlogPosts does some ajax and returns an RSVP.Promise that is fulfilled
	  // with some blog post data
	  RSVP.map(getBlogPosts(), mapFn).then(function(comments){
	    // comments is the result of asking the server for the comments
	    // of all blog posts returned from getBlogPosts()
	  });
	  ```

	  @method map
	  @static
	  @for RSVP
	  @param {Array} promises
	  @param {Function} mapFn function to be called on each fulfilled promise.
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled with the result of calling
	  `mapFn` on each fulfilled promise or value when they become fulfilled.
	   The promise will be rejected if any of the given `promises` become rejected.
	  @static
	*/
	function map(promises, mapFn, label) {
	  return Promise.all(promises, label).then(function (values) {
	    if (!isFunction(mapFn)) {
	      throw new TypeError("You must pass a function as map's second argument.");
	    }

	    var length = values.length;
	    var results = new Array(length);

	    for (var i = 0; i < length; i++) {
	      results[i] = mapFn(values[i]);
	    }

	    return Promise.all(results, label);
	  });
	}

	/**
	  This is a convenient alias for `RSVP.Promise.resolve`.

	  @method resolve
	  @static
	  @for RSVP
	  @param {*} value value that the returned promise will be resolved with
	  @param {String} label optional string for identifying the returned promise.
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve$2(value, label) {
	  return Promise.resolve(value, label);
	}

	/**
	  This is a convenient alias for `RSVP.Promise.reject`.

	  @method reject
	  @static
	  @for RSVP
	  @param {*} reason value that the returned promise will be rejected with.
	  @param {String} label optional string for identifying the returned promise.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject$2(reason, label) {
	  return Promise.reject(reason, label);
	}

	/**
	 `RSVP.filter` is similar to JavaScript's native `filter` method, except that it
	  waits for all promises to become fulfilled before running the `filterFn` on
	  each item in given to `promises`. `RSVP.filter` returns a promise that will
	  become fulfilled with the result of running `filterFn` on the values the
	  promises become fulfilled with.

	  For example:

	  ```javascript

	  let promise1 = RSVP.resolve(1);
	  let promise2 = RSVP.resolve(2);
	  let promise3 = RSVP.resolve(3);

	  let promises = [promise1, promise2, promise3];

	  let filterFn = function(item){
	    return item > 1;
	  };

	  RSVP.filter(promises, filterFn).then(function(result){
	    // result is [ 2, 3 ]
	  });
	  ```

	  If any of the `promises` given to `RSVP.filter` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promise's
	  rejection handler. For example:

	  ```javascript
	  let promise1 = RSVP.resolve(1);
	  let promise2 = RSVP.reject(new Error('2'));
	  let promise3 = RSVP.reject(new Error('3'));
	  let promises = [ promise1, promise2, promise3 ];

	  let filterFn = function(item){
	    return item > 1;
	  };

	  RSVP.filter(promises, filterFn).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(reason) {
	    // reason.message === '2'
	  });
	  ```

	  `RSVP.filter` will also wait for any promises returned from `filterFn`.
	  For instance, you may want to fetch a list of users then return a subset
	  of those users based on some asynchronous operation:

	  ```javascript

	  let alice = { name: 'alice' };
	  let bob   = { name: 'bob' };
	  let users = [ alice, bob ];

	  let promises = users.map(function(user){
	    return RSVP.resolve(user);
	  });

	  let filterFn = function(user){
	    // Here, Alice has permissions to create a blog post, but Bob does not.
	    return getPrivilegesForUser(user).then(function(privs){
	      return privs.can_create_blog_post === true;
	    });
	  };
	  RSVP.filter(promises, filterFn).then(function(users){
	    // true, because the server told us only Alice can create a blog post.
	    users.length === 1;
	    // false, because Alice is the only user present in `users`
	    users[0] === bob;
	  });
	  ```

	  @method filter
	  @static
	  @for RSVP
	  @param {Array} promises
	  @param {Function} filterFn - function to be called on each resolved value to
	  filter the final results.
	  @param {String} label optional string describing the promise. Useful for
	  tooling.
	  @return {Promise}
	*/

	function resolveAll(promises, label) {
	  return Promise.all(promises, label);
	}

	function resolveSingle(promise, label) {
	  return Promise.resolve(promise, label).then(function (promises) {
	    return resolveAll(promises, label);
	  });
	}
	function filter(promises, filterFn, label) {
	  var promise = isArray(promises) ? resolveAll(promises, label) : resolveSingle(promises, label);
	  return promise.then(function (values) {
	    if (!isFunction(filterFn)) {
	      throw new TypeError("You must pass a function as filter's second argument.");
	    }

	    var length = values.length;
	    var filtered = new Array(length);

	    for (var i = 0; i < length; i++) {
	      filtered[i] = filterFn(values[i]);
	    }

	    return resolveAll(filtered, label).then(function (filtered) {
	      var results = new Array(length);
	      var newLength = 0;

	      for (var i = 0; i < length; i++) {
	        if (filtered[i]) {
	          results[newLength] = values[i];
	          newLength++;
	        }
	      }

	      results.length = newLength;

	      return results;
	    });
	  });
	}

	var len = 0;
	var vertxNext = undefined;
	function asap(callback, arg) {
	  queue$1[len] = callback;
	  queue$1[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 1, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    scheduleFlush$1();
	  }
	}

	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

	// node
	function useNextTick() {
	  var nextTick = process.nextTick;
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // setImmediate should be used instead instead
	  var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
	  if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
	    nextTick = setImmediate;
	  }
	  return function () {
	    return nextTick(flush);
	  };
	}

	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }
	  return useSetTimeout();
	}

	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });

	  return function () {
	    return node.data = iterations = ++iterations % 2;
	  };
	}

	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}

	function useSetTimeout() {
	  return function () {
	    return setTimeout(flush, 1);
	  };
	}

	var queue$1 = new Array(1000);

	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue$1[i];
	    var arg = queue$1[i + 1];

	    callback(arg);

	    queue$1[i] = undefined;
	    queue$1[i + 1] = undefined;
	  }

	  len = 0;
	}

	function attemptVertex() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(/*! vertx */ 109);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}

	var scheduleFlush$1 = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush$1 = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush$1 = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush$1 = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush$1 = attemptVertex();
	} else {
	  scheduleFlush$1 = useSetTimeout();
	}

	var platform = undefined;

	/* global self */
	if (typeof self === 'object') {
	  platform = self;

	  /* global global */
	} else if (typeof global === 'object') {
	    platform = global;
	  } else {
	    throw new Error('no global: `self` or `global` found');
	  }

	var _async$filter;

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	// defaults

	// the default export here is for backwards compat:
	//   https://github.com/tildeio/rsvp.js/issues/434
	config.async = asap;
	config.after = function (cb) {
	  return setTimeout(cb, 0);
	};
	var cast = resolve$2;

	var async = function async(callback, arg) {
	  return config.async(callback, arg);
	};

	function on() {
	  config['on'].apply(config, arguments);
	}

	function off() {
	  config['off'].apply(config, arguments);
	}

	// Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
	if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
	  var callbacks = window['__PROMISE_INSTRUMENTATION__'];
	  configure('instrument', true);
	  for (var eventName in callbacks) {
	    if (callbacks.hasOwnProperty(eventName)) {
	      on(eventName, callbacks[eventName]);
	    }
	  }
	}var rsvp = (_async$filter = {
	  cast: cast,
	  Promise: Promise,
	  EventTarget: EventTarget,
	  all: all$1,
	  allSettled: allSettled,
	  race: race$1,
	  hash: hash,
	  hashSettled: hashSettled,
	  rethrow: rethrow,
	  defer: defer,
	  denodeify: denodeify,
	  configure: configure,
	  on: on,
	  off: off,
	  resolve: resolve$2,
	  reject: reject$2,
	  map: map
	}, _defineProperty(_async$filter, 'async', async), _defineProperty(_async$filter, 'filter', // babel seems to error if async isn't a computed prop here...
	filter), _async$filter);

	exports['default'] = rsvp;
	exports.cast = cast;
	exports.Promise = Promise;
	exports.EventTarget = EventTarget;
	exports.all = all$1;
	exports.allSettled = allSettled;
	exports.race = race$1;
	exports.hash = hash;
	exports.hashSettled = hashSettled;
	exports.rethrow = rethrow;
	exports.defer = defer;
	exports.denodeify = denodeify;
	exports.configure = configure;
	exports.on = on;
	exports.off = off;
	exports.resolve = resolve$2;
	exports.reject = reject$2;
	exports.map = map;
	exports.async = async;
	exports.filter = filter;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));
	//# sourceMappingURL=rsvp.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/process/browser.js */ 107), __webpack_require__(/*! ./~/timers-browserify/main.js */ 108).setImmediate, (function() { return this; }())))

/***/ },
/* 107 */
/*!******************************!*\
  !*** ./~/process/browser.js ***!
  \******************************/
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 108 */
/*!*************************************!*\
  !*** ./~/timers-browserify/main.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(/*! process/browser.js */ 107).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/timers-browserify/main.js */ 108).setImmediate, __webpack_require__(/*! ./~/timers-browserify/main.js */ 108).clearImmediate))

/***/ },
/* 109 */
/*!***********************!*\
  !*** vertx (ignored) ***!
  \***********************/
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 110 */
/*!***************************************!*\
  !*** ./src/store/clientMiddleware.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = promiseMiddleware;

	var _isPromise = __webpack_require__(/*! ./isPromise */ 111);

	var _isPromise2 = _interopRequireDefault(_isPromise);

	var _isPlainObject = __webpack_require__(/*! ./isPlainObject */ 129);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var PENDING = 'PENDING';
	var FULFILLED = 'FULFILLED';
	var REJECTED = 'REJECTED';

	function isAction(action) {
	  return (0, _isPlainObject2.default)(action) && typeof action.type !== 'undefined';
	}

	function promiseMiddleware(store) {
	  var dispatch = store.dispatch;


	  return function (next) {
	    return function (action) {
	      if (typeof action === 'function') return action(store);

	      if (!isAction(action) || !(0, _isPromise2.default)(action.payload) || action.error) {
	        return next(action);
	      }

	      var type = action.type,
	          payload = action.payload,
	          meta = action.meta;


	      dispatch({ type: type + '_' + PENDING, meta: meta });

	      return payload.then(function (result) {
	        return dispatch({ type: type + '_' + FULFILLED, payload: result, meta: meta });
	      }, function (error) {
	        return dispatch({ type: type + '_' + REJECTED, payload: payload, error: error, meta: meta });
	      });
	    };
	  };
	};

/***/ },
/* 111 */
/*!********************************!*\
  !*** ./src/store/isPromise.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	exports.default = isPromise;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isPromise(value) {
	  if (value !== null && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object') {
	    return typeof value.then === 'function';
	  }
	}

/***/ },
/* 112 */
/*!*******************************************!*\
  !*** ./~/babel-runtime/helpers/typeof.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _iterator = __webpack_require__(/*! ../core-js/symbol/iterator */ 113);

	var _iterator2 = _interopRequireDefault(_iterator);

	var _symbol = __webpack_require__(/*! ../core-js/symbol */ 116);

	var _symbol2 = _interopRequireDefault(_symbol);

	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 113 */
/*!****************************************************!*\
  !*** ./~/babel-runtime/core-js/symbol/iterator.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/iterator */ 114), __esModule: true };

/***/ },
/* 114 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/symbol/iterator.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.string.iterator */ 5);
	__webpack_require__(/*! ../../modules/web.dom.iterable */ 84);
	module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ 115).f('iterator');

/***/ },
/* 115 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_wks-ext.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(/*! ./_wks */ 46);

/***/ },
/* 116 */
/*!*******************************************!*\
  !*** ./~/babel-runtime/core-js/symbol.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol */ 117), __esModule: true };

/***/ },
/* 117 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/symbol/index.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.symbol */ 118);
	__webpack_require__(/*! ../../modules/es6.object.to-string */ 83);
	__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ 127);
	__webpack_require__(/*! ../../modules/es7.symbol.observable */ 128);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Symbol;

/***/ },
/* 118 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.symbol.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(/*! ./_global */ 12)
	  , has            = __webpack_require__(/*! ./_has */ 27)
	  , DESCRIPTORS    = __webpack_require__(/*! ./_descriptors */ 21)
	  , $export        = __webpack_require__(/*! ./_export */ 11)
	  , redefine       = __webpack_require__(/*! ./_redefine */ 26)
	  , META           = __webpack_require__(/*! ./_meta */ 119).KEY
	  , $fails         = __webpack_require__(/*! ./_fails */ 22)
	  , shared         = __webpack_require__(/*! ./_shared */ 41)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 45)
	  , uid            = __webpack_require__(/*! ./_uid */ 42)
	  , wks            = __webpack_require__(/*! ./_wks */ 46)
	  , wksExt         = __webpack_require__(/*! ./_wks-ext */ 115)
	  , wksDefine      = __webpack_require__(/*! ./_wks-define */ 120)
	  , keyOf          = __webpack_require__(/*! ./_keyof */ 121)
	  , enumKeys       = __webpack_require__(/*! ./_enum-keys */ 122)
	  , isArray        = __webpack_require__(/*! ./_is-array */ 123)
	  , anObject       = __webpack_require__(/*! ./_an-object */ 18)
	  , toIObject      = __webpack_require__(/*! ./_to-iobject */ 34)
	  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ 24)
	  , createDesc     = __webpack_require__(/*! ./_property-desc */ 25)
	  , _create        = __webpack_require__(/*! ./_object-create */ 30)
	  , gOPNExt        = __webpack_require__(/*! ./_object-gopn-ext */ 124)
	  , $GOPD          = __webpack_require__(/*! ./_object-gopd */ 126)
	  , $DP            = __webpack_require__(/*! ./_object-dp */ 17)
	  , $keys          = __webpack_require__(/*! ./_object-keys */ 32)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(/*! ./_object-gopn */ 125).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(/*! ./_object-pie */ 61).f  = $propertyIsEnumerable;
	  __webpack_require__(/*! ./_object-gops */ 60).f = $getOwnPropertySymbols;

	  if(DESCRIPTORS && !__webpack_require__(/*! ./_library */ 10)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ 16)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 119 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_meta.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(/*! ./_uid */ 42)('meta')
	  , isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , has      = __webpack_require__(/*! ./_has */ 27)
	  , setDesc  = __webpack_require__(/*! ./_object-dp */ 17).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(/*! ./_fails */ 22)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 120 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_wks-define.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(/*! ./_global */ 12)
	  , core           = __webpack_require__(/*! ./_core */ 13)
	  , LIBRARY        = __webpack_require__(/*! ./_library */ 10)
	  , wksExt         = __webpack_require__(/*! ./_wks-ext */ 115)
	  , defineProperty = __webpack_require__(/*! ./_object-dp */ 17).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 121 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_keyof.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(/*! ./_object-keys */ 32)
	  , toIObject = __webpack_require__(/*! ./_to-iobject */ 34);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 122 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_enum-keys.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(/*! ./_object-keys */ 32)
	  , gOPS    = __webpack_require__(/*! ./_object-gops */ 60)
	  , pIE     = __webpack_require__(/*! ./_object-pie */ 61);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 123 */
/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_is-array.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(/*! ./_cof */ 36);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 124 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gopn-ext.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(/*! ./_to-iobject */ 34)
	  , gOPN      = __webpack_require__(/*! ./_object-gopn */ 125).f
	  , toString  = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 125 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gopn.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(/*! ./_object-keys-internal */ 33)
	  , hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ 43).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 126 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gopd.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(/*! ./_object-pie */ 61)
	  , createDesc     = __webpack_require__(/*! ./_property-desc */ 25)
	  , toIObject      = __webpack_require__(/*! ./_to-iobject */ 34)
	  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ 24)
	  , has            = __webpack_require__(/*! ./_has */ 27)
	  , IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ 20)
	  , gOPD           = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(/*! ./_descriptors */ 21) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 127 */
/*!********************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es7.symbol.async-iterator.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_wks-define */ 120)('asyncIterator');

/***/ },
/* 128 */
/*!****************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es7.symbol.observable.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_wks-define */ 120)('observable');

/***/ },
/* 129 */
/*!************************************!*\
  !*** ./src/store/isPlainObject.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ 130);

	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	exports.default = isPlainObject;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var fnToString = function fnToString(fn) {
	  return Function.prototype.toString.call(fn);
	};
	var objStringValue = fnToString(Object);

	/**
	 * @param {any} obj The object to inspect.
	 * @returns {boolean} True if the argument appears to be a plain object.
	 */
	function isPlainObject(obj) {
	  if (!obj || (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) !== 'object') {
	    return false;
	  }

	  var proto = typeof obj.constructor === 'function' ? (0, _getPrototypeOf2.default)(obj) : Object.prototype;

	  if (proto === null) {
	    return true;
	  }

	  var constructor = proto.constructor;

	  return typeof constructor === 'function' && constructor instanceof constructor && fnToString(constructor) === objStringValue;
	}

/***/ },
/* 130 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/core-js/object/get-prototype-of.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-prototype-of */ 131), __esModule: true };

/***/ },
/* 131 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/get-prototype-of.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.get-prototype-of */ 132);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.getPrototypeOf;

/***/ },
/* 132 */
/*!**********************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.get-prototype-of.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(/*! ./_to-object */ 48)
	  , $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ 47);

	__webpack_require__(/*! ./_object-sap */ 133)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 133 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-sap.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(/*! ./_export */ 11)
	  , core    = __webpack_require__(/*! ./_core */ 13)
	  , fails   = __webpack_require__(/*! ./_fails */ 22);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 134 */
/*!**********************************!*\
  !*** ./src/modules/animation.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _createReducer;

	exports.setFrameTime = setFrameTime;
	exports.getTime = getTime;
	exports.setTime = setTime;
	exports.isPlaying = isPlaying;
	exports.startPlaying = startPlaying;
	exports.incrementTime = incrementTime;
	exports.stopPlaying = stopPlaying;
	exports.queueClip = queueClip;
	exports.queueAnimation = queueAnimation;
	exports.findAnimationIndex = findAnimationIndex;
	exports.removeAnimation = removeAnimation;
	exports.addClip = addClip;
	exports.getClips = getClips;
	exports.getTimelineAnimation = getTimelineAnimation;

	var _cuid = __webpack_require__(/*! cuid */ 142);

	var _cuid2 = _interopRequireDefault(_cuid);

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 143);

	var _createReducer3 = _interopRequireDefault(_createReducer2);

	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 144);

	var _tweenFunctions = __webpack_require__(/*! ./utils/tweenFunctions */ 290);

	var _tweenFunctions2 = _interopRequireDefault(_tweenFunctions);

	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 281);

	var _createStore = __webpack_require__(/*! ../store/createStore */ 284);

	var _scene = __webpack_require__(/*! ./scene */ 171);

	var _physics = __webpack_require__(/*! ./utils/physics */ 291);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SET_TIME = 'SET_TIME';
	var SET_FRAME_TIME = 'SET_FRAME_TIME';
	var START_PLAYING = 'START_PLAYING';
	var STOP_PLAYING = 'STOP_PLAYING';
	var UPDATE_TRACK = 'UPDATE_TRACK';
	var UPDATE_ANIMATION = 'UPDATE_ANIMATION';
	var REMOVE_ANIMATION = 'REMOVE_ANIMATION';
	var QUEUE_ANIMATION = 'QUEUE_ANIMATION';
	var QUEUE_TIMELINE_ANIMATION = 'QUEUE_TIMELINE_ANIMATION';
	var ADD_CLIP = 'ADD_CLIP';
	var INIT_PHYSICS = 'INIT_PHYSICS';

	/**
	 * Animation module.
	 *
	 * This module controls the animation happening. The properties of an
	 * animation are [defined here in the Animation type](global.html#Animation).
	 *
	 * Animations can be queued dynamically with [`queueAnimation`](module-animation.html#.queueAnimation)
	 * Or, to play existing clips, queue a clip for playing with [`queueClip`](module-animation.html#.queueClip).
	 *
	 * @module animation
	 * @public
	 *
	 */

	function newInitialState() {
	  return (0, _immutable.Map)({
	    time: 0,
	    startTime: null,
	    playing: false,
	    autoplay: false,
	    frameTime: 0,
	    animations: (0, _immutable.List)(),
	    clips: (0, _immutable.Map)(),
	    timelineAnimationIndex: -1,
	    dynamicsWorld: null,
	    dynamicBodies: {},
	    kinematicBodies: {}
	  });
	}

	var reducer = (0, _createReducer3.default)(newInitialState(), (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, _createStore.ActionTypes.INIT, function (state) {
	  return newInitialState();
	}), (0, _defineProperty3.default)(_createReducer, SET_TIME, function (state, _ref) {
	  var time = _ref.time,
	      startTime = _ref.startTime;

	  return state.set('time', time).set('startTime', startTime);
	}), (0, _defineProperty3.default)(_createReducer, SET_FRAME_TIME, function (state, frameTime) {
	  var currentFrameTime = state.get('frameTime');
	  // Apply a smoothing moving average to frameTime
	  return state.set('frameTime', currentFrameTime + (frameTime - currentFrameTime) * 0.1);
	}), (0, _defineProperty3.default)(_createReducer, START_PLAYING, function (state, autoplay) {
	  return state.merge({ playing: true, autoplay: !!autoplay });
	}), (0, _defineProperty3.default)(_createReducer, STOP_PLAYING, function (state) {
	  return state.set('playing', false);
	}), (0, _defineProperty3.default)(_createReducer, UPDATE_TRACK, function (state, _ref2) {
	  var path = _ref2.path,
	      attrs = _ref2.attrs;

	  var anim = state.getIn(['animations', path[0]]);
	  var track = anim && anim.tracks[path[1]];
	  if (track) (0, _assign2.default)(track, attrs);
	  return state;
	}), (0, _defineProperty3.default)(_createReducer, UPDATE_ANIMATION, function (state, _ref3) {
	  var index = _ref3.index,
	      attrs = _ref3.attrs;

	  var anim = state.getIn(['animations', index]);
	  if (anim) (0, _assign2.default)(anim, attrs);
	  return state;
	}), (0, _defineProperty3.default)(_createReducer, REMOVE_ANIMATION, function (state, idx) {
	  var newState = state;
	  if (idx === state.get('timelineAnimationIndex')) newState = newState.set('timelineAnimationIndex', -1);
	  return newState.deleteIn(['animations', idx]);
	}), (0, _defineProperty3.default)(_createReducer, QUEUE_ANIMATION, function (state, animation) {
	  return state.updateIn(['animations'], (0, _immutable.List)(), function (list) {
	    return list.push(animation);
	  });
	}), (0, _defineProperty3.default)(_createReducer, QUEUE_TIMELINE_ANIMATION, function (state, animation) {
	  return state.set('timelineAnimationIndex', state.get('animations').size - 1);
	}), (0, _defineProperty3.default)(_createReducer, ADD_CLIP, function (state, _ref4) {
	  var clip = _ref4.clip,
	      id = _ref4.id;

	  return state.setIn(['clips', id], (0, _immutable.Map)(clip).set('id', id));
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref5) {
	  var clips = _ref5.clips;

	  return clips ? state.mergeIn(['clips'], clips) : state;
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state) {
	  return initialState;
	}), (0, _defineProperty3.default)(_createReducer, INIT_PHYSICS, function (state, _ref6) {
	  var dynamicsWorld = _ref6.dynamicsWorld,
	      dynamicBodies = _ref6.dynamicBodies,
	      kinematicBodies = _ref6.kinematicBodies;

	  return state.set('dynamicsWorld', dynamicsWorld).set('dynamicBodies', dynamicBodies).set('kinematicBodies', kinematicBodies);
	}), _createReducer));

	function setFrameTime(frameTime) {
	  return { type: SET_FRAME_TIME, payload: frameTime };
	};

	/**
	 * Return the current animation time.
	 * @returns {Number}
	 * @public
	 *
	 */
	function getTime(store) {
	  return store.getIn(['animation', 'time']);
	};

	/**
	 * Set the current animation time.
	 * @public
	 * @param {Number} time in seconds
	 */
	function setTime(time) {
	  return function (store) {
	    var startTime = new Date();
	    var delta = time - store.getIn(['animation', 'time']);
	    var dynamicsWorld = store.getIn(['animation', 'dynamicsWorld']);

	    if (delta !== 0) {
	      if (store.getIn(['animation', 'animations']).size) {
	        (function () {
	          var offsetIdx = 0;
	          store.getIn(['animation', 'animations']).forEach(function (anim, animIdx) {
	            var animationKept = updateAnimation(store, delta, time, anim, animIdx - offsetIdx);
	            if (!animationKept) offsetIdx++;
	          });
	        })();
	      } else {
	        if (store.getIn(['animation', 'autoplay'])) {
	          store.dispatch(stopPlaying());
	        }
	      }

	      if (dynamicsWorld) {
	        (0, _physics.updatePhysics)(store, delta, time, dynamicsWorld, store.getIn(['animation', 'dynamicBodies']), store.getIn(['animation', 'kinematicBodies']));
	      }
	    }

	    store.dispatch({ type: SET_TIME, payload: { time: time, startTime: startTime } });
	  };
	};

	function getKeyframeValueFor(t, keyframes, tween, currentValue) {
	  var vs = keyframes.vs,
	      ts = keyframes.ts;


	  if (!ts.length) return currentValue;

	  var idx = (0, _ramda.findIndex)(function (kt) {
	    return t <= kt;
	  }, ts);
	  if (idx === -1) return vs[vs.length - 1];

	  // FIXME: Handle keyframe that hasn't started yet
	  if (idx === 0) return vs[0];

	  //console.log('tween?', frame1.v, frame2.v, frame2.t - frame1.t);
	  var v = tween(t - ts[idx - 1], vs[idx - 1], vs[idx], ts[idx] - ts[idx - 1]);
	  //console.log('getkeyframe value?', t, idx, v);
	  return v;
	}

	function getKeyframeValue(t, keyframes, tween, currentValue) {
	  //console.log('get keyframe value: ', t, keyframes, tween);
	  if (keyframes.ts) return getKeyframeValueFor(t, keyframes, tween, currentValue);
	  var result = {};
	  var keys = (0, _keys2.default)(keyframes);
	  for (var i = 0; i < keys.length; i++) {
	    result[keys[i]] = getKeyframeValueFor(t, keyframes[keys[i]], tween, currentValue[keys[i]]);
	  }

	  return result;
	};

	function updateAnimation(store, delta, time, animation, animationIdx) {
	  //console.log('updateAnimation', delta, time, animation.name, animationIdx);

	  var tracks = animation.tracks,
	      first = animation.first,
	      iterations = animation.iterations,
	      duration = animation.duration,
	      easingFn = animation.easingFn,
	      easingDuration = animation.easingDuration,
	      playSpeed = animation.playSpeed;
	  var easingTime = animation.easingTime;

	  var animationStart = animation.start;
	  var trackSet = animation.set;

	  var animationTime = time;

	  var isEasing = first && time < animationStart + easingDuration && time > animationStart;
	  if (isEasing) {
	    easingTime += delta * easingFn(time - animationStart, 0, 1, easingDuration);
	    animationTime = animationStart + easingTime;
	  } else if (easingTime) {
	    animationTime = time - easingDuration + easingTime;
	  }

	  var reverse = playSpeed < 0;

	  if (playSpeed !== 1) {
	    animationTime = (animationTime - animationStart) * playSpeed + animationStart;
	    if (reverse) animationTime = animationTime + duration;
	  }

	  var inProgress = false;
	  var ops = [];

	  var s = new Date();
	  var track = void 0;
	  for (var trackIdx = 0; trackIdx < tracks.length; trackIdx++) {
	    track = tracks[trackIdx];
	    var start = track.start + animationStart;
	    var end = track.end + animationStart;
	    if (reverse ? animationTime > end : animationTime < start) {
	      inProgress = true;
	      continue;
	    }

	    var endValue = track.value;
	    var _track = track,
	        tween = _track.tween,
	        path = _track.path,
	        keyframes = _track.keyframes,
	        _duration = _track.duration,
	        currentValue = _track.currentValue,
	        _trackSet = _track.trackSet;

	    var startValue = track.startValue;

	    // TODO: this should be more efficient
	    //let currentValue = endValue; //get(store, path);

	    if (startValue == null && !keyframes) {
	      startValue = (0, _sceneGraph.get)(store, path);
	      store.dispatch({ type: UPDATE_TRACK, payload: { path: [animationIdx, trackIdx], attrs: { startValue: startValue } } });
	    }

	    var v = keyframes ? getKeyframeValue(animationTime - start, keyframes, tween, currentValue) : animationTime > end ? endValue : tween(animationTime - start, startValue, endValue, _duration);

	    var op = _trackSet(path, v);
	    if (op) ops.push(op);

	    if (reverse ? animationTime >= start : animationTime <= end) inProgress = true;
	  }

	  //console.log('dispatch animations',ops.length, 'in',  new Date() - s);
	  if (ops.length) store.dispatch((0, _sceneGraph.multi)(ops));

	  if (inProgress) {
	    if (isEasing) {
	      store.dispatch({ type: UPDATE_ANIMATION, payload: { index: animationIdx, attrs: {
	            easingTime: easingTime
	          } } });
	    }
	  } else {
	    if (iterations > 1) {
	      store.dispatch({ type: UPDATE_ANIMATION, payload: { index: animationIdx, attrs: {
	            first: false, easingTime: 0, start: time, iterations: iterations - 1
	          } } });
	    } else {
	      if (animation.onEnd) animation.onEnd();

	      if (animationIdx !== store.getIn(['animation', 'timelineAnimationIndex'])) {
	        store.dispatch({ type: REMOVE_ANIMATION, payload: animationIdx });
	        return false;
	      } else {
	        store.dispatch({ type: UPDATE_ANIMATION, payload: {
	            index: animationIdx, attrs: { start: time }
	          } });
	        store.dispatch(stopPlaying());
	      }
	    }
	  }
	  return true;
	};

	/**
	 * Are we currently playing
	 * @returns {Boolean}
	 */
	function isPlaying(store) {
	  return store.getIn(['animation', 'playing']);
	};

	/**
	 * Start time
	 * @public
	 */
	function startPlaying() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  return function (store) {
	    store.dispatch({ type: START_PLAYING, payload: options.autoplay });
	    if (typeof Ammo !== 'undefined' && !store.getIn(['animation', 'dynamicsWorld'])) {
	      store.dispatch({ type: INIT_PHYSICS, payload: (0, _physics.initPhysics)(store) });
	    }
	    store.dispatch(setTime(store.getIn(['animation', 'time'])));
	  };
	};

	/*
	 * If we are currently playing, increment time
	 */
	function incrementTime() {
	  return function (store) {
	    if (store.getIn(['animation', 'playing'])) {
	      var startTime = store.getIn(['animation', 'startTime']);
	      var time = store.getIn(['animation', 'time']);
	      var delta = startTime ? new Date() - startTime : 0;
	      store.dispatch(setTime(time + delta));
	    }
	  };
	};

	function getLastKeyframeTime(keyframes) {
	  if (keyframes.ts) return keyframes.ts.length ? keyframes.ts[keyframes.ts.length - 1] : 0;
	  var lastTime = 0;
	  var times = void 0;
	  var keys = (0, _keys2.default)(keyframes);
	  for (var i = 0; i < keys.length; i++) {
	    times = keyframes[keys[i]].ts;
	    lastTime = times.length ? Math.max(times[times.length - 1], lastTime) : lastTime;
	  }

	  return lastTime;
	};

	/**
	 * Stop time
	 * @public
	 */
	function stopPlaying() {
	  return { type: STOP_PLAYING };
	};

	function formatTrack(store, sceneTime, attrs) {
	  var id = (0, _cuid2.default)();
	  var path = Array.isArray(attrs.path) ? attrs.path : attrs.path && (0, _scene.find)(store, attrs.path);
	  if (!path && attrs.path && attrs.path.id) {
	    delete attrs.path.id;
	    path = (0, _scene.find)(store, attrs.path);
	  }
	  if (!path && !attrs.set) {
	    console.log('path is not defined for track', attrs);
	    return null;
	  }

	  var start = attrs.start || 0;
	  var value = attrs.value;
	  var tween = attrs.tween || getTweenFunction(value, attrs.easing || 'linear');
	  var trackSet = attrs.set || _sceneGraph.set;
	  var keyframes = attrs.keyframes;
	  var duration = keyframes ? getLastKeyframeTime(keyframes) : attrs.duration || 0;
	  var end = duration + start;
	  var startValue = duration === 0 ? value : attrs.startValue;
	  var currentValue = path && (0, _sceneGraph.get)(store, path);
	  return { path: path, start: start, end: end, value: value, duration: duration, tween: tween, startValue: startValue, keyframes: keyframes, currentValue: currentValue, trackSet: trackSet };
	};

	/**
	 * Queue a clip to be played
	 *
	 * @public
	 * @param {String} clipId the id of the clip to be queued.
	 * @param {Object} attrs Attrs to override the clip settings.
	 * @param {Object} options
	 * @param {Boolean} options.useTimeline Display the clip in the timeline
	 * @returns {Promise}
	 *
	 * @example
	 * var clips = animation.getClips();
	 * animation.queueClip(clips[0].id, {autoplay: true});
	 *
	 */
	function queueClip(clipId, attrs) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  return function (store) {
	    var clip = store.getIn(['animation', 'clips', clipId]);
	    if (clip) {
	      store.dispatch(queueAnimation((0, _assign2.default)({}, clip.toJS(), attrs)));
	      if (options.useTimeline) store.dispatch({ type: QUEUE_TIMELINE_ANIMATION });
	    }
	  };
	};

	/**
	 * Queue an animation
	 *
	 * @public
	 * @param {Animation} attrs the animation object
	 * @returns {Promise}
	 */
	function queueAnimation(attrs) {
	  return function (store) {
	    var sceneTime = store.getIn(['animation', 'time']);

	    var name = attrs.name || 'Animation';
	    var iterations = attrs.iterations || 1;
	    var start = attrs.start || sceneTime;
	    var easing = attrs.easing || 'linear';
	    var easingFn = getTweenFunction(1, easing);
	    var easingDuration = attrs.easingDuration || 0;
	    var playSpeed = typeof attrs.playSpeed !== 'undefined' ? attrs.playSpeed : 1;
	    var trackList = (0, _ramda.filter)(function (t) {
	      return !!t;
	    }, (0, _ramda.map)(function (attrs) {
	      return formatTrack(store, sceneTime, attrs);
	    }, attrs.tracks));
	    var duration = (0, _ramda.reduce)(function (lastEnd, track) {
	      return Math.max(lastEnd, track.end);
	    }, 0, trackList);
	    var onEnd = attrs.onEnd || null;

	    //let end = 0;
	    //forEach((t) => { if (t.get('end') > end) end = t.get('end'); }, trackList);

	    store.dispatch({
	      type: QUEUE_ANIMATION,
	      payload: {
	        name: name,
	        start: start,
	        easingTime: 0,
	        first: true,
	        easing: easing,
	        easingFn: easingFn,
	        easingDuration: easingDuration,
	        iterations: iterations,
	        tracks: trackList,
	        onEnd: onEnd,
	        playSpeed: playSpeed,
	        duration: duration
	      }
	    });

	    if (attrs.autoplay && !isPlaying(store)) {
	      store.dispatch(startPlaying({ autoplay: true }));
	    }

	    return _promise2.default.resolve(true);
	  };
	};

	function findAnimationIndex(name, store) {
	  return store.getIn(['animation', 'animations']).findIndex(function (anim) {
	    return anim.name === name;
	  });
	};

	/**
	 * Remove an animation
	 *
	 * @public
	 * @param {String} name the name of the animation
	 * @returns {Promise}
	 */
	function removeAnimation(name) {
	  return function (store) {
	    var animationIdx = findAnimationIndex(name, store);
	    if (animationIdx !== -1) {
	      return store.dispatch({ type: REMOVE_ANIMATION, payload: animationIdx });
	    }
	  };
	};

	/**
	 * Add a clip to the store.
	 * @param {Object} clip
	 * @param {String} id
	 * @returns {Promise}
	 */
	function addClip(clip, id) {
	  return { type: ADD_CLIP, payload: { clip: clip, id: id } };
	};

	/**
	 * Return a list of clips available.
	 *
	 * @public
	 * @returns {Clip[]}
	 */
	function getClips(store) {
	  return (0, _ramda.values)(store.getIn(['animation', 'clips']).toJS());
	};

	function getTweenFunction(value, easing) {
	  var tweenFn = _tweenFunctions2.default[easing];
	  if (!tweenFn) throw new Error('Unknown easing function: ' + easing);

	  if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== 'object') return tweenFn;

	  var keys = (0, _keys2.default)(value);

	  return function (t, b, c, d) {
	    var result = {};
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      result[key] = tweenFn(t, b[key], c[key], d);
	    }

	    return result;
	  };
	};

	function getTimelineAnimation(store) {
	  var index = store.getIn(['animation', 'timelineAnimationIndex']);
	  if (index < 0) return null;
	  return store.getIn(['animation', 'animations', index]);
	}

	var publicApi = {
	  reducer: reducer,
	  actions: { setTime: setTime, startPlaying: startPlaying, stopPlaying: stopPlaying, removeAnimation: removeAnimation, queueAnimation: queueAnimation,
	    addClip: addClip, queueClip: queueClip
	  },
	  selectors: { getTime: getTime, getClips: getClips, getTimelineAnimation: getTimelineAnimation, isPlaying: isPlaying }
	};

	exports.default = publicApi;

/***/ },
/* 135 */
/*!************************************************!*\
  !*** ./~/babel-runtime/core-js/object/keys.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/keys */ 136), __esModule: true };

/***/ },
/* 136 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/keys.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.keys */ 137);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.keys;

/***/ },
/* 137 */
/*!**********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.keys.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(/*! ./_to-object */ 48)
	  , $keys    = __webpack_require__(/*! ./_object-keys */ 32);

	__webpack_require__(/*! ./_object-sap */ 133)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 138 */
/*!***************************************************!*\
  !*** ./~/babel-runtime/helpers/defineProperty.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ 139);

	var _defineProperty2 = _interopRequireDefault(_defineProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

/***/ },
/* 139 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/core-js/object/define-property.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ 140), __esModule: true };

/***/ },
/* 140 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/define-property.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.define-property */ 141);
	var $Object = __webpack_require__(/*! ../../modules/_core */ 13).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 141 */
/*!*********************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.define-property.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 11);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ 21), 'Object', {defineProperty: __webpack_require__(/*! ./_object-dp */ 17).f});

/***/ },
/* 142 */
/*!*************************************!*\
  !*** ./~/cuid/dist/browser-cuid.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * cuid.js
	 * Collision-resistant UID generator for browsers and node.
	 * Sequential for fast db lookups and recency sorting.
	 * Safe for element IDs and server-side lookups.
	 *
	 * Extracted from CLCTR
	 *
	 * Copyright (c) Eric Elliott 2012
	 * MIT License
	 */

	/*global window, navigator, document, require, process, module */
	(function (app) {
	  'use strict';
	  var namespace = 'cuid',
	    c = 0,
	    blockSize = 4,
	    base = 36,
	    discreteValues = Math.pow(base, blockSize),

	    pad = function pad(num, size) {
	      var s = "000000000" + num;
	      return s.substr(s.length-size);
	    },

	    randomBlock = function randomBlock() {
	      return pad((Math.random() *
	            discreteValues << 0)
	            .toString(base), blockSize);
	    },

	    safeCounter = function () {
	      c = (c < discreteValues) ? c : 0;
	      c++; // this is not subliminal
	      return c - 1;
	    },

	    api = function cuid() {
	      // Starting with a lowercase letter makes
	      // it HTML element ID friendly.
	      var letter = 'c', // hard-coded allows for sequential access

	        // timestamp
	        // warning: this exposes the exact date and time
	        // that the uid was created.
	        timestamp = (new Date().getTime()).toString(base),

	        // Prevent same-machine collisions.
	        counter,

	        // A few chars to generate distinct ids for different
	        // clients (so different computers are far less
	        // likely to generate the same id)
	        fingerprint = api.fingerprint(),

	        // Grab some more chars from Math.random()
	        random = randomBlock() + randomBlock();

	        counter = pad(safeCounter().toString(base), blockSize);

	      return  (letter + timestamp + counter + fingerprint + random);
	    };

	  api.slug = function slug() {
	    var date = new Date().getTime().toString(36),
	      counter,
	      print = api.fingerprint().slice(0,1) +
	        api.fingerprint().slice(-1),
	      random = randomBlock().slice(-2);

	      counter = safeCounter().toString(36).slice(-4);

	    return date.slice(-2) +
	      counter + print + random;
	  };

	  api.globalCount = function globalCount() {
	    // We want to cache the results of this
	    var cache = (function calc() {
	        var i,
	          count = 0;

	        for (i in window) {
	          count++;
	        }

	        return count;
	      }());

	    api.globalCount = function () { return cache; };
	    return cache;
	  };

	  api.fingerprint = function browserPrint() {
	    return pad((navigator.mimeTypes.length +
	      navigator.userAgent.length).toString(36) +
	      api.globalCount().toString(36), 4);
	  };

	  // don't change anything from here down.
	  if (app.register) {
	    app.register(namespace, api);
	  } else if (true) {
	    module.exports = api;
	  } else {
	    app[namespace] = api;
	  }

	}(this.applitude || this));


/***/ },
/* 143 */
/*!********************************************!*\
  !*** ./src/modules/utils/createReducer.js ***!
  \********************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createReducer;
	function createReducer(initialState, handlers) {
	  return function reducer(state, action, allState, createEvent) {
	    if (action && handlers.hasOwnProperty(action.type)) {
	      return handlers[action.type](state, action.payload, { action: action, createEvent: createEvent, state: allState });
	    } else {
	      return state || initialState;
	    }
	  };
	}

/***/ },
/* 144 */
/*!***********************************!*\
  !*** ./src/modules/sceneGraph.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.virtualTargetId = exports.vrCameraId = exports.virtualCameraId = undefined;

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 101);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 97);

	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	exports.initNode = initNode;
	exports.addNode = addNode;
	exports.setVRCamera = setVRCamera;
	exports.deleteNode = deleteNode;
	exports.addOperator = addOperator;
	exports.get = get;
	exports.getVRCamera = getVRCamera;
	exports.set = set;
	exports.merge = merge;
	exports.replace = replace;
	exports.multi = multi;
	exports.touch = touch;
	exports.reparent = reparent;
	exports.findParent = findParent;
	exports.findRoot = findRoot;
	exports.clone = clone;
	exports.oldNodeJSON = oldNodeJSON;
	exports.exportJSON = exportJSON;
	exports.updateNodeTransform = updateNodeTransform;
	exports.getEvalSceneGraph = getEvalSceneGraph;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _cuid = __webpack_require__(/*! cuid */ 142);

	var _cuid2 = _interopRequireDefault(_cuid);

	var _nodeUuid = __webpack_require__(/*! node-uuid */ 145);

	var _nodeUuid2 = _interopRequireDefault(_nodeUuid);

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 143);

	var _createReducer3 = _interopRequireDefault(_createReducer2);

	var _assets = __webpack_require__(/*! ./assets */ 168);

	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 281);

	var _nonImmutable = __webpack_require__(/*! ../operators/nonImmutable */ 173);

	var _nonImmutable2 = _interopRequireDefault(_nonImmutable);

	var _evalSceneGraph = __webpack_require__(/*! ./utils/evalSceneGraph */ 282);

	var _createStore = __webpack_require__(/*! ../store/createStore */ 284);

	var _scene = __webpack_require__(/*! ./scene */ 171);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SET = 'SET';
	//import { fetchmaterial } from './files';

	var MERGE = 'MERGE';
	var REPLACE = 'REPLACE';
	var MULTI = 'MULTI';
	var REPARENT = 'REPARENT';
	var ADD_OPERATOR = 'ADD_OPERATOR';
	var TOUCH = 'TOUCH';
	var virtualCameraId = 'cccccccc-cccc-1ccc-accc-cccccccccccc';
	var vrCameraId = 'bbbbbbbb-bbbb-0bbb-zbbb-bbbbbbbbbbbb';
	var virtualTargetId = 'dddddddd-dddd-0ddd-addd-dddddddddddd';

	/*
	 * Convert from immutable.js scenegraph to our new object format
	 */
	function convertFromImmutable(scene) {
	  return scene.map(function (node) {
	    var warnings = node.get('warnings').toArray();
	    var plugs = node.get('plugs').map(function (ops, plug) {
	      return ops.map(function (op) {
	        var type = op.get('type');
	        var operator = (0, _nonImmutable.lookupOperator)(plug, type, warnings);
	        var opjs = operator.init(type, op.toJS(), op.get('name'));
	        //console.log('init operator: ', plug, opjs);
	        return opjs;
	      }).toArray();
	    }).toObject();
	    var nodeJS = node.toJS();
	    nodeJS.plugs = plugs;
	    nodeJS.warnings = warnings;
	    nodeJS._v = 0;
	    return nodeJS;
	  }).toObject();
	}

	/**
	 * Initialize node from object literal format
	 */
	function initNode(node) {
	  var plugs = {};
	  var warnings = node.warnings || [];
	  (0, _keys2.default)(node.plugs).forEach(function (plugName) {
	    plugs[plugName] = node.plugs[plugName].map(function (op) {
	      var type = op.type;
	      var operator = (0, _nonImmutable.lookupOperator)(plugName, type, warnings);
	      return operator.init(type, op, op.name);
	    });
	  });
	  return (0, _assign2.default)({}, node, { warnings: warnings, plugs: plugs, _v: 0 });
	}

	/*
	 * Read and initialize nodes from object literal format
	 */
	function initNodes(nodes) {
	  var result = {};
	  (0, _keys2.default)(nodes).forEach(function (id) {
	    result[id] = initNode(nodes[id]);
	  });
	  return result;
	}

	/**
	 * This module contains actions to manipulate the scene graph.
	 *
	 * @module sceneGraph
	 * @public
	 *
	 */

	/*
	 * Reducer
	 */
	function reducer(records) {
	  var _createReducer;

	  function createOperator(OperatorRecord, type, props, name) {
	    if (!name) name = type;

	    var Op = new OperatorRecord({ type: type, name: name });
	    // Calling merge directly so that the immutable shim has its `set` method called
	    // Filtering the operator to only known keys.
	    return Op.merge((0, _ramda.pick)(OperatorRecord.keys(), props));
	  };

	  function checkNode(node) {
	    if (!node.hasOwnProperty('_v')) node._v = 0;
	    return node;
	  }

	  function buildNode(_ref) {
	    var id = _ref.id,
	        name = _ref.name,
	        type = _ref.type,
	        children = _ref.children,
	        parent = _ref.parent,
	        plugs = _ref.plugs;

	    var warnings = [];

	    var initPlugs = (0, _ramda.mapObjIndexed)(function (ops, plug) {
	      if (!records[plug]) {
	        warnings = warnings.push('No Plug: ' + plug);
	        return [];
	      }

	      return ops.map(function (op) {
	        if (!Array.isArray(op)) throw new Error('Expect op to be an array of 2 or 3');

	        var _op = (0, _slicedToArray3.default)(op, 3),
	            type = _op[0],
	            props = _op[1],
	            name = _op[2];

	        var operator = (0, _nonImmutable.lookupOperator)(plug, type, warnings);
	        var opdata = operator.init(type, props, name); // Object.assign({}, props, { type, name });
	        //console.log('init operator: ', type, props, opdata);
	        return opdata;
	        //let OperatorRecord = records[plug][type];

	        //if (!OperatorRecord) {
	        //  warnings = warnings.push(`No Operator: ${plug} - ${type}`);
	        //  //console.log('WARNING:', warnings.toJS());
	        //  OperatorRecord = records.None.NoOp;
	        //}
	        //return createOperator(OperatorRecord, type, props, name);
	      });
	    }, plugs);

	    var newChildren = children || [];

	    return {
	      id: id,
	      name: name,
	      type: type,
	      children: newChildren,
	      parent: parent,
	      plugs: initPlugs,
	      warnings: warnings,
	      _v: 0
	    };
	  };

	  function errorNode(_ref2) {
	    var id = _ref2.id,
	        name = _ref2.name,
	        children = _ref2.children,
	        parent = _ref2.parent;

	    children = children ? (0, _immutable.List)(children) : (0, _immutable.List)();
	    return (0, _immutable.Map)({ id: id, name: name, type: 'ErrorNode', children: children, parent: parent, plugs: (0, _immutable.Map)() });
	  };

	  function initializeVirtualNodes(state) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    if (!state.nodes[virtualCameraId] || options.force) {
	      state.nodes[virtualCameraId] = buildNode({
	        id: virtualCameraId,
	        name: 'CAMERA',
	        type: 'Camera',
	        plugs: {
	          Camera: [['Camera', {}]],
	          Transform: [['Transform', {}]],
	          Properties: [['Default', {}]]
	        }
	      });
	    }

	    if (!state.nodes[vrCameraId] || options.force) {
	      state.nodes[vrCameraId] = buildNode({
	        id: vrCameraId,
	        name: 'VR CAMERA',
	        type: 'Camera',
	        plugs: {
	          Camera: [['Camera', { fieldOfView: 45 }]],
	          Transform: [['Transform', { translation: { x: 0, y: 1.6, z: 1 } }]],
	          Properties: [['Default', {}]]
	        }
	      });
	    }

	    if (!state.nodes[virtualTargetId] || options.force) {
	      state.nodes[virtualTargetId] = buildNode({
	        id: virtualTargetId,
	        name: 'VIRTUAL TARGET NULL',
	        type: 'Null',
	        plugs: {
	          Transform: [['Transform', {}]]
	        }
	      });
	    }
	  }

	  function newInitialState() {
	    return {
	      _v: 0,
	      nodes: {},
	      fileReferences: { to: {}, from: {} },
	      nodeReferences: { to: {}, from: {} },
	      evaluatedNodes: {},
	      loaded: false,
	      _ev: 0
	    };
	  }

	  function setReducer(state, _ref3) {
	    var path = _ref3.path,
	        value = _ref3.value;

	    if (!path.length || path.length < 2) {
	      throw new Error('SET requires a path with length 2 or 4');
	    }

	    var _path = (0, _slicedToArray3.default)(path, 4),
	        nodeId = _path[0],
	        plugName = _path[1],
	        idx = _path[2],
	        key = _path[3];

	    var node = state.nodes[nodeId];

	    if (path.length === 2 && path[1] === 'name') {
	      node.name = value;
	      node._v += 1;
	      state._v += 1;
	    } else {
	      var plug = node && node.plugs[plugName];
	      var op = plug && plug[idx];
	      if (!op) throw new Error('Setting data on unknown operator: ' + path.join(','));

	      var operator = _nonImmutable2.default[plugName][op.type];
	      if (operator.set(op, key, value)) {
	        node._v += 1;
	        state._v += 1;
	      };
	    }

	    return state;
	  }

	  var sceneReducer = (0, _createReducer3.default)({}, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, _createStore.ActionTypes.INIT, function (state) {
	    return newInitialState();
	  }), (0, _defineProperty3.default)(_createReducer, TOUCH, function (state, id) {
	    var node = state.nodes[id];
	    if (node) {
	      node._v += 1;
	      state._v += 1;
	    }

	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, SET, setReducer), (0, _defineProperty3.default)(_createReducer, MERGE, function (state, _ref4) {
	    var path = _ref4.path,
	        attrs = _ref4.attrs;

	    if (!path.length || path.length !== 3) {
	      throw new Error('MERGE requires a path with length 3');
	    }

	    if ((typeof attrs === 'undefined' ? 'undefined' : (0, _typeof3.default)(attrs)) !== 'object') {
	      throw new Error('MERGE requires an object to merge in');
	    }

	    var _path2 = (0, _slicedToArray3.default)(path, 3),
	        nodeId = _path2[0],
	        plugName = _path2[1],
	        idx = _path2[2];

	    var node = state.nodes[nodeId];
	    var plug = node && node.plugs[plugName];
	    var op = plug && plug[idx];
	    var operator = op && _nonImmutable2.default[plugName][op.type];
	    if (!operator) throw new Error('Setting data on unknown operator: ' + path.join(','));
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(attrs)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var k = _step.value;

	        operator.set(op, k, attrs[k]);
	      }
	      //op._v += 1;
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    node._v += 1;
	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, REPLACE, function (state, _ref5) {
	    var id = _ref5.id,
	        node = _ref5.node;

	    var originalNode = state.nodes[id];
	    if (!originalNode) return;

	    var v = originalNode._v;
	    state.nodes[id] = node;
	    node._v = v + 1;
	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.ADD_NODE, function (state, attrs) {
	    var id = attrs.id,
	        parent = attrs.parent;

	    var parentNode = parent && state.nodes[parent];
	    if (parent && !parentNode) throw new Error('Unknown parent: \'' + parent + '\'');

	    if (state.nodes[id]) throw new Error('Adding a node that already exists: ' + id);

	    state.nodes[id] = attrs.node ? checkNode(attrs.node) : buildNode(attrs);

	    if (parent && !parentNode.children) {
	      parentNode.children = [];
	    }

	    if (parent && parentNode.children.indexOf(id) === -1) {
	      parentNode.children.push(id);
	    }

	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.DELETE_NODE, function (state, nodeId) {
	    function deleteNodesFromState(id) {
	      var node = state.nodes[id];
	      if (node) {
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = (0, _getIterator3.default)(node.children || []), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var childId = _step2.value;

	            deleteNodesFromState(childId);
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }

	        var references = state.nodeReferences.from[id];
	        (0, _keys2.default)(references || {}).forEach(function (refKey) {
	          var path = JSON.parse(refKey);
	          setReducer(state, { path: path, value: null });
	        });
	        delete state.nodes[id];
	      }

	      return node;
	    }

	    var node = deleteNodesFromState(nodeId);
	    if (!node) return state;
	    var parent = node.parent && state.nodes[node.parent];
	    if (parent) {
	      var idx = parent.children.indexOf(nodeId);
	      if (idx !== -1) parent.children.splice(idx, 1);
	      parent._v += 1;
	    }

	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, ADD_OPERATOR, function (state, attrs) {
	    var id = attrs.id,
	        plug = attrs.plug,
	        op = attrs.op;

	    var node = state.nodes[id];
	    if (!node) throw new Error('Unknown node: ' + id);

	    var ops = node.plugs[plug];
	    if (!ops) throw new Error('Unknown plug: ' + plug);

	    if (!Array.isArray(op)) throw new Error('Expect op to be an array of 2 or 3');

	    var _op2 = (0, _slicedToArray3.default)(op, 3),
	        type = _op2[0],
	        props = _op2[1],
	        name = _op2[2];

	    var operator = (0, _nonImmutable.lookupOperator)(plug, type, node.warnings);
	    ops.push(operator.init(type, op, name));
	    node._v += 1;
	    state._v += 1;

	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, MULTI, function (state, ops) {
	    var v = state._v;
	    for (var opId in ops) {
	      var op = ops[opId];
	      if (op.type === SET) setReducer(state, op.payload);
	    }

	    state._v = v + 1;
	    //console.log('create new multi state in: ', new Date() - s);
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, REPARENT, function (state, _ref6) {
	    var parentId = _ref6.parentId,
	        childIds = _ref6.childIds;

	    var newParentNode = state.nodes[parentId];
	    if (!newParentNode) {
	      console.warn('Unknown parent for reparent: ' + parentId);
	      return state;
	    }

	    (0, _ramda.forEach)(function (childId) {
	      var childNode = state.nodes[childId];
	      if (!childNode) return;

	      var childParentId = childNode && childNode.parent;
	      var prevParentNode = childParentId && state.nodes[childParentId];
	      var idx = prevParentNode && prevParentNode.children ? prevParentNode.children.indexOf(childId) : -1;
	      if (idx !== -1) {
	        prevParentNode.children.splice(idx, 1);
	        prevParentNode._v += 1;
	      }

	      newParentNode.children.push(childId);
	      childNode.parent = parentId;
	      childNode._v += 1;
	    }, childIds.slice()); // iterate copy of array to protect from corruption from child removals

	    newParentNode._v += 1;
	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref7) {
	    var scene = _ref7.scene,
	        nodes = _ref7.nodes;

	    var sceneJS = scene ? convertFromImmutable(scene) : initNodes(JSON.parse(nodes));

	    (0, _assign2.default)(state.nodes, sceneJS);

	    initializeVirtualNodes(state);
	    state._v += 1;

	    return state;
	    //const newState = state.merge(scene);
	    //return newState.get(virtualCameraId) ? newState : newState.set(virtualCameraId, buildNode({
	    //  id: virtualCameraId,
	    //  name: 'CAMERA',
	    //  type: 'Camera',
	    //  plugs: {
	    //    Camera: [['Camera', {}]],
	    //    Transform: [['Transform', {}]],
	    //    Properties: [['Default', {}]],
	    //  },
	    //}));
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state, id) {
	    initializeVirtualNodes(state, { force: true });
	    state._v += 1;
	    if (state.nodes[id]) state.nodes[id]._v = 0;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADED_FILE, function (state, id) {
	    if (state.fileReferences.from[id]) {
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(state.fileReferences.from[id])), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var refKey = _step3.value;

	          var _JSON$parse = JSON.parse(refKey),
	              _JSON$parse2 = (0, _slicedToArray3.default)(_JSON$parse, 3),
	              nodeId = _JSON$parse2[0],
	              plugName = _JSON$parse2[1],
	              opIdx = _JSON$parse2[2];

	          state.nodes[nodeId]._v += 1;
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }

	      state._v += 1;
	    }

	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.SET_VR_CAMERA, function (state, cameraId) {
	    // FIXME: remove this
	    var camNode = state.get(cameraId);
	    if (camNode.type === 'Camera') return state.set(vrCameraId, camNode);else return state;
	  }), _createReducer));

	  return sceneReducer;
	}

	// Return a new node object from existing node
	function copyNode(node) {
	  var newPlugs = {};
	  var _iteratorNormalCompletion4 = true;
	  var _didIteratorError4 = false;
	  var _iteratorError4 = undefined;

	  try {
	    for (var _iterator4 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	      var plug = _step4.value;

	      newPlugs[plug] = (0, _ramda.map)(function (op) {
	        return (0, _assign2.default)({}, op);
	      }, node.plugs[plug]);
	    }
	  } catch (err) {
	    _didIteratorError4 = true;
	    _iteratorError4 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion4 && _iterator4.return) {
	        _iterator4.return();
	      }
	    } finally {
	      if (_didIteratorError4) {
	        throw _iteratorError4;
	      }
	    }
	  }

	  return {
	    id: _nodeUuid2.default.v4(),
	    name: node.name,
	    type: node.type,
	    parent: node.parent,
	    children: [].concat(node.children),
	    plugs: newPlugs,
	    _v: 1
	  };
	}

	/**
	 * Add a node to the scene.
	 *
	 * @public
	 * @param {Node} node
	 * @returns {Promise}
	 */
	function addNode(node) {
	  var id = node.id,
	      name = node.name,
	      type = node.type,
	      plugs = node.plugs,
	      parent = node.parent;

	  if (!id) id = _nodeUuid2.default.v4(); //cuid();
	  name = name || id;

	  return {
	    type: _actionTypes.ADD_NODE,
	    payload: { id: id, name: name, type: type, plugs: plugs, parent: parent },
	    resolve: id
	  };
	};

	function setVRCamera(camId) {
	  return { type: _actionTypes.SET_VR_CAMERA, payload: camId };
	}

	/**
	 * Deletes a node
	 *
	 * @public
	 * @param {String} id The node id
	 * @returns {Promise}
	 */
	function deleteNode(id) {
	  return {
	    type: _actionTypes.DELETE_NODE,
	    payload: id
	  };
	};

	/**
	 *
	 * Add an operator to a plug of a node.
	 */
	function addOperator(id, plug, op) {
	  return {
	    type: ADD_OPERATOR,
	    payload: { id: id, plug: plug, op: op }
	  };
	};

	/**
	 * get a property
	 *
	 * @param {Path} path to the operator property.
	 * @returns {any} value
	 *
	 * @example
	 * // scene.get([uuid
	 */
	function get(store, path) {
	  if (!Array.isArray(path)) throw new Error('Expect path to be an array');

	  var sceneGraph = store.get('sceneGraph');
	  var result = sceneGraph.nodes[path[0]];

	  if (path.length >= 2) {
	    if (path[1] === 'name' || path[1] === 'type') {
	      return result && result[path[1]];
	    }

	    result = result && result.plugs[path[1]];
	  }

	  if (path.length >= 3) {
	    result = result && result[path[2]];
	  }

	  if (path.length >= 4 && result) {
	    var operator = (0, _nonImmutable.lookupOperator)(path[1], result.type, []);
	    result = operator.get(result, path[3]);
	  }

	  return result;
	};

	function getVRCamera(store) {
	  return store.getIn(['sceneGraph', vrCameraId]);
	}

	/**
	 * set a property on an operator. This takes a Path array,
	 * and a value
	 *
	 * @param {Path} path includes the operator property.
	 * @param {any} value
	 * @returns {Promise}
	 *
	 */
	function set(path, value) {
	  return { type: SET, payload: { path: path, value: value }, meta: { remote: true } };
	};

	/**
	 * Merges an object into an operator.
	 *
	 * @param {Path} path to the operator.
	 * @param {Object} attrs
	 * @returns {Promise}
	 *
	 */
	function merge(path, attrs) {
	  return { type: MERGE, payload: { path: path, attrs: attrs } };
	};

	/**
	 * Replace a node with the given node contents
	 * @private
	 *
	 */
	function replace(id, node) {
	  return { type: REPLACE, payload: { id: id, node: node } };
	};

	/**
	 * An array of scene actions.
	 *
	 * @param {Action[]} ops
	 * @returns {Promise}
	 */
	function multi(ops) {
	  return { type: MULTI, payload: ops };
	};

	/**
	 * Touch sceneGraph node, so it is re-evaluated and translated
	 */
	function touch(id) {
	  return { type: TOUCH, payload: id };
	};

	/**
	 * Reparent nodes to the new parent.
	 *
	 * @public
	 * @param {String} parent id of the new parent node
	 * @param {Array} childIds list of ids to reparent
	 *
	 * @example
	 * // reparent children of 'MyModel' to 'NewParentNull'
	 * const parentId = scene.find({ name: 'NewParentNull' });
	 * const nodesToReparent = scene.filter({ from: { name: 'MyModel' } });
	 * sceneGraph.reparent(parentId, nodesToReparent);
	 */
	function reparent(parentId, childIds) {
	  return { type: REPARENT, payload: { parentId: parentId, childIds: childIds } };
	};

	/**
	 * Return the parent id of the node.
	 */
	function findParent(store, id) {
	  var node = store.get('sceneGraph').nodes[id];
	  return node && node.parent;
	};

	/**
	 * Return the root parent id of the node.
	 */
	function findRoot(store, id) {
	  var node = store.get('sceneGraph').nodes[id];
	  var parent = node && node.parent;
	  return parent ? findRoot(store, parent) : id;
	};

	/**
	 * Clone nodes. Given a list of ids, this will copy the node with a new id,
	 * and update the parent and child of each node. By passing in a map of *old
	 * parent id* to *new parent id*, the nodes can be cloned to a different location
	 * in the sceneGraph (or from one to another).
	 *
	 * @public
	 * @param {Array} ids list of ids to clone
	 * @param {Object} nodeMap of {oldNodeId: newNodeId} Can be used for passing
	 *                         new parents, or new depencies.
	 * @param {Object} [options]
	 * @param {Boolean} [options.cloneDependencies] Clone dependencies as well.
	 *
	 * @example
	 * // clone children of 'MyModel' to 'NewParentNull'
	 * const parentId = scene.find({ name: 'NewParentNull' });
	 * const myModelId = scene.find({ name: 'MyModel' });
	 * const nodesToClone = scene.filter({ from: { id: myModelId } });
	 * sceneGraph.clone(nodesToClone, { [myModelId]: parentId });
	 * // clone dependencies
	 * sceneGraph.clone(nodesToClone, { [myModelId]: parentId }, {cloneDependencies: true});
	 */
	function clone(ids) {
	  var nodeMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var cloneDependencies = options.cloneDependencies;

	  var nodes = (0, _ramda.reduce)(function (acc, id) {
	    acc[id] = true;return acc;
	  }, {}, ids);
	  var assets = {};

	  return function (store) {
	    var sceneGraph = store.get('sceneGraph');

	    // Find dependencies
	    function checkDependency(id) {
	      var node = sceneGraph.nodes[id];
	      var name = node && node.name;
	      if (!node || !node.plugs) return;

	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;

	      try {
	        for (var _iterator5 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var plug = _step5.value;

	          var ops = node.plugs[plug];

	          var _iteratorNormalCompletion6 = true;
	          var _didIteratorError6 = false;
	          var _iteratorError6 = undefined;

	          try {
	            for (var _iterator6 = (0, _getIterator3.default)(ops), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	              var op = _step6.value;

	              var operator = _nonImmutable2.default[plug][op.type];
	              if (operator) {
	                var _iteratorNormalCompletion7 = true;
	                var _didIteratorError7 = false;
	                var _iteratorError7 = undefined;

	                try {
	                  for (var _iterator7 = (0, _getIterator3.default)(operator.referenceKeys), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	                    var key = _step7.value;

	                    var refId = op[key];
	                    if (refId && !nodes[refId] && !nodeMap[refId]) {
	                      nodes[refId] = true;
	                      checkDependency(refId);
	                    }
	                  }
	                } catch (err) {
	                  _didIteratorError7 = true;
	                  _iteratorError7 = err;
	                } finally {
	                  try {
	                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
	                      _iterator7.return();
	                    }
	                  } finally {
	                    if (_didIteratorError7) {
	                      throw _iteratorError7;
	                    }
	                  }
	                }

	                var _iteratorNormalCompletion8 = true;
	                var _didIteratorError8 = false;
	                var _iteratorError8 = undefined;

	                try {
	                  for (var _iterator8 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	                    var _key = _step8.value;

	                    var _refId = op[_key];
	                    if (_refId && store.getIn(['assets', _refId])) {
	                      assets[_refId] = true;
	                    }
	                  }
	                } catch (err) {
	                  _didIteratorError8 = true;
	                  _iteratorError8 = err;
	                } finally {
	                  try {
	                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
	                      _iterator8.return();
	                    }
	                  } finally {
	                    if (_didIteratorError8) {
	                      throw _iteratorError8;
	                    }
	                  }
	                }
	              }
	            }
	          } catch (err) {
	            _didIteratorError6 = true;
	            _iteratorError6 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                _iterator6.return();
	              }
	            } finally {
	              if (_didIteratorError6) {
	                throw _iteratorError6;
	              }
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }
	    }

	    if (cloneDependencies) (0, _ramda.forEach)(checkDependency, ids);

	    // Generate new ids
	    (0, _ramda.forEach)(function (id) {
	      return nodes[id] = _nodeUuid2.default.v4();
	    }, (0, _keys2.default)(nodes));
	    (0, _ramda.forEach)(function (assetId) {
	      return assets[assetId] = _nodeUuid2.default.v4();
	    }, (0, _keys2.default)(assets));

	    function updateDependencies(node) {
	      var resultNode = node;
	      var _iteratorNormalCompletion9 = true;
	      var _didIteratorError9 = false;
	      var _iteratorError9 = undefined;

	      try {
	        var _loop = function _loop() {
	          var plug = _step9.value;

	          var ops = node.plugs[plug];
	          ops.forEach(function (op, opIdx) {
	            var operator = _nonImmutable2.default[plug][op.type];
	            if (operator) {
	              var _iteratorNormalCompletion10 = true;
	              var _didIteratorError10 = false;
	              var _iteratorError10 = undefined;

	              try {
	                for (var _iterator10 = (0, _getIterator3.default)(operator.referenceKeys), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	                  var key = _step10.value;

	                  var refId = op[key];
	                  var newRef = refId && (nodes[refId] || nodeMap[refId]);
	                  if (newRef) resultNode.plugs[plug][opIdx][key] = newRef;
	                }
	              } catch (err) {
	                _didIteratorError10 = true;
	                _iteratorError10 = err;
	              } finally {
	                try {
	                  if (!_iteratorNormalCompletion10 && _iterator10.return) {
	                    _iterator10.return();
	                  }
	                } finally {
	                  if (_didIteratorError10) {
	                    throw _iteratorError10;
	                  }
	                }
	              }

	              var _iteratorNormalCompletion11 = true;
	              var _didIteratorError11 = false;
	              var _iteratorError11 = undefined;

	              try {
	                for (var _iterator11 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
	                  var _key2 = _step11.value;

	                  var _refId2 = op[_key2];
	                  if (_refId2 && assets[_refId2]) {
	                    resultNode.plugs[plug][opIdx][_key2] = assets[_refId2];
	                  }
	                }
	              } catch (err) {
	                _didIteratorError11 = true;
	                _iteratorError11 = err;
	              } finally {
	                try {
	                  if (!_iteratorNormalCompletion11 && _iterator11.return) {
	                    _iterator11.return();
	                  }
	                } finally {
	                  if (_didIteratorError11) {
	                    throw _iteratorError11;
	                  }
	                }
	              }

	              ;
	            }
	          });
	        };

	        for (var _iterator9 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	          _loop();
	        }
	      } catch (err) {
	        _didIteratorError9 = true;
	        _iteratorError9 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion9 && _iterator9.return) {
	            _iterator9.return();
	          }
	        } finally {
	          if (_didIteratorError9) {
	            throw _iteratorError9;
	          }
	        }
	      }

	      return resultNode;
	    }

	    // Remap parents, children and dependencies
	    (0, _ramda.forEach)(function (id) {
	      var oldNode = sceneGraph.nodes[id];
	      var newNode = copyNode(oldNode);
	      newNode.id = nodes[id];

	      var nodeParent = oldNode.parent;
	      var parent = nodeParent && (nodes[nodeParent] || nodeMap[nodeParent] || nodeParent);
	      newNode.parent = parent;

	      newNode.children = [];
	      var _iteratorNormalCompletion12 = true;
	      var _didIteratorError12 = false;
	      var _iteratorError12 = undefined;

	      try {
	        for (var _iterator12 = (0, _getIterator3.default)(oldNode.children), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
	          var childId = _step12.value;

	          if (nodes[childId]) newNode.children.push(nodes[childId]);else if (nodeMap[childId]) newNode.children.push(nodeMap[childId]);
	        }
	      } catch (err) {
	        _didIteratorError12 = true;
	        _iteratorError12 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion12 && _iterator12.return) {
	            _iterator12.return();
	          }
	        } finally {
	          if (_didIteratorError12) {
	            throw _iteratorError12;
	          }
	        }
	      }

	      store.dispatch({
	        type: _actionTypes.ADD_NODE,
	        payload: {
	          id: nodes[id],
	          parent: parent,
	          node: updateDependencies(newNode)
	        }
	      });
	    }, (0, _keys2.default)(nodes));

	    var firstNodeRootId = findRoot(store, nodes[(0, _keys2.default)(nodes)[0]]);

	    (0, _ramda.forEach)(function (assetId) {
	      var asset = store.getIn(['assets', assetId]);
	      if (asset) {
	        store.dispatch((0, _assets.addFile)(asset.set('id', assets[assetId]).set('sceneId', firstNodeRootId).toJS()));
	      }
	    }, (0, _keys2.default)(assets));

	    return _promise2.default.resolve(nodes);
	  };
	};

	function oldNodeJSON(node) {
	  var plugs = (0, _keys2.default)(node.plugs).map(function (plugName) {
	    return {
	      type: plugName,
	      operators: node.plugs[plugName].map(function (op) {
	        var operator = (0, _nonImmutable.lookupOperator)(plugName, op.type, []);
	        return operator.export(op);
	      })
	    };
	  });

	  return {
	    _id: node.id,
	    name: node.name,
	    type: node.type,
	    plugs: plugs,
	    nodes: []
	  };
	};

	/**
	 * Given a list of nodes, build and return the old scene graph format.
	 */
	function exportJSON(store, nodes) {
	  var rootNode = void 0;
	  var nodeMap = {};
	  var sceneGraph = store.get('sceneGraph');

	  (0, _ramda.forEach)(function (nodeId) {
	    var node = sceneGraph.nodes[nodeId];
	    if (!node) return;

	    var newNode = oldNodeJSON(node);
	    nodeMap[newNode._id] = newNode;
	    if (!rootNode) rootNode = newNode;

	    if (node.parent && nodeMap[node.parent]) {
	      nodeMap[node.parent].nodes.push(newNode);
	    }
	  }, nodes);

	  return rootNode;
	};

	//export function importMaterial(id) {
	//  return ({dispatch, getState}) => {
	//    // let sceneId = getState().getIn(['scene','id']);
	//    return dispatch(fetchMaterial(id)).then((mat) => {
	//      return dispatch(addNode({...mat, plugs: {
	//        Material: [['Material', {color: {r: 1, g: 0, b: 0}}]]
	//      }, parent: 'materiallibrary'}));
	//    }).catch((err) => {
	//      // console.log('handle rejected promise?', err);
	//      return false;
	//      // throw err;
	//    });
	//  }
	//}

	function updateNodeTransform(store, nodeId, newTransform) {
	  var parentNodeId = findParent(store, nodeId);

	  //const parent = store.getIn(['sceneGraph',parentNode.get('id'),'parent']);
	  var parentWorldTransform = (0, _scene.getWorldTransform)(store, parentNodeId);
	  //console.log( 'parentWorldTransform', parentWorldTransform );

	  var position = new THREE.Vector3(),
	      quaternion = new THREE.Quaternion(),
	      scale = new THREE.Vector3();

	  var tempTransform = new THREE.Matrix4();
	  tempTransform.copy(newTransform);

	  if (parentWorldTransform) {
	    var invParentWorldTransform = new THREE.Matrix4();
	    invParentWorldTransform.getInverse(parentWorldTransform, true);
	    tempTransform.multiplyMatrices(invParentWorldTransform, tempTransform);
	  }

	  tempTransform.decompose(position, quaternion, scale);
	  //console.log( 'position', JSON.stringify( position ) );
	  //console.log( 'scale', JSON.stringify( scale ) );
	  var euler = new THREE.Euler().setFromQuaternion(quaternion, 'ZYX');
	  //console.log( 'euler', JSON.stringify( euler ) );


	  //let translation = node.getIn(['plugs','Transform',0,'translation']);
	  //let rotation = node.getIn(['plugs','Transform',0,'rotation']);
	  store.dispatch(set([nodeId, 'Transform', 0, 'translation'], { x: position.x, y: position.y, z: position.z }));
	  store.dispatch(set([nodeId, 'Transform', 0, 'rotation'], { x: THREE.Math.radToDeg(euler.x), y: THREE.Math.radToDeg(euler.y), z: THREE.Math.radToDeg(euler.z) }));
	}

	function getEvalSceneGraph(store) {
	  var sceneGraph = store.get('sceneGraph');

	  if (sceneGraph._v === sceneGraph._ev) {
	    return sceneGraph;
	  }

	  var sceneId = store.getIn(['sceneIO', 'id']); // getSceneId
	  //console.log('updateSceneGraph', sceneGraph._ev, 'from', sceneGraph._v);
	  (0, _evalSceneGraph.evaluateSceneGraph)(store, sceneId, sceneGraph);
	  return sceneGraph;
	};

	var publicApi = {
	  reducer: reducer,
	  actions: { set: set, merge: merge, multi: multi, addNode: addNode, deleteNode: deleteNode, reparent: reparent, clone: clone, setVRCamera: setVRCamera, addOperator: addOperator },
	  selectors: { get: get, exportJSON: exportJSON, getVRCamera: getVRCamera }
	};
	exports.default = publicApi;
	exports.virtualCameraId = virtualCameraId;
	exports.vrCameraId = vrCameraId;
	exports.virtualTargetId = virtualTargetId;

/***/ },
/* 145 */
/*!*****************************!*\
  !*** ./~/node-uuid/uuid.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(Buffer) {//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php

	/*global window, require, define */
	(function(_window) {
	  'use strict';

	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;

	  function setupBrowser() {
	    // Allow for MSIE11 msCrypto
	    var _crypto = _window.crypto || _window.msCrypto;

	    if (!_rng && _crypto && _crypto.getRandomValues) {
	      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	      //
	      // Moderately fast, high quality
	      try {
	        var _rnds8 = new Uint8Array(16);
	        _whatwgRNG = _rng = function whatwgRNG() {
	          _crypto.getRandomValues(_rnds8);
	          return _rnds8;
	        };
	        _rng();
	      } catch(e) {}
	    }

	    if (!_rng) {
	      // Math.random()-based (RNG)
	      //
	      // If all else fails, use Math.random().  It's fast, but is of unspecified
	      // quality.
	      var  _rnds = new Array(16);
	      _mathRNG = _rng = function() {
	        for (var i = 0, r; i < 16; i++) {
	          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
	          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	        }

	        return _rnds;
	      };
	      if ('undefined' !== typeof console && console.warn) {
	        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
	      }
	    }
	  }

	  function setupNode() {
	    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	    //
	    // Moderately fast, high quality
	    if (true) {
	      try {
	        var _rb = __webpack_require__(/*! crypto */ 150).randomBytes;
	        _nodeRNG = _rng = _rb && function() {return _rb(16);};
	        _rng();
	      } catch(e) {}
	    }
	  }

	  if (_window) {
	    setupBrowser();
	  } else {
	    setupNode();
	  }

	  // Buffer class to use
	  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;

	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }

	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = (buf && offset) || 0, ii = 0;

	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	      if (ii < 16) { // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });

	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }

	    return buf;
	  }

	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0, bth = _byteToHex;
	    return  bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]];
	  }

	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html

	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();

	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [
	    _seedBytes[0] | 0x01,
	    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	  ];

	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

	  // Previous uuid creation time
	  var _lastMSecs = 0, _lastNSecs = 0;

	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];

	    options = options || {};

	    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;

	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();

	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;

	    // Time since last uuid creation (in msecs)
	    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }

	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }

	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }

	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;

	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;

	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;

	    // `time_mid`
	    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;

	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;

	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;

	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;

	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }

	    return buf ? buf : unparse(b);
	  }

	  // **`v4()` - Generate random UUID**

	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;

	    if (typeof(options) === 'string') {
	      buf = (options === 'binary') ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};

	    var rnds = options.random || (options.rng || _rng)();

	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = (rnds[6] & 0x0f) | 0x40;
	    rnds[8] = (rnds[8] & 0x3f) | 0x80;

	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }

	    return buf || unparse(rnds);
	  }

	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	  uuid._rng = _rng;
	  uuid._mathRNG = _mathRNG;
	  uuid._nodeRNG = _nodeRNG;
	  uuid._whatwgRNG = _whatwgRNG;

	  if (('undefined' !== typeof module) && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return uuid;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


	  } else {
	    // Publish as global (in browsers)
	    _previousRoot = _window.uuid;

	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function() {
	      _window.uuid = _previousRoot;
	      return uuid;
	    };

	    _window.uuid = uuid;
	  }
	})('undefined' !== typeof window ? window : null);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 146 */
/*!***************************!*\
  !*** ./~/buffer/index.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(/*! base64-js */ 147)
	var ieee754 = __webpack_require__(/*! ieee754 */ 148)
	var isArray = __webpack_require__(/*! isarray */ 149)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer, (function() { return this; }())))

/***/ },
/* 147 */
/*!******************************!*\
  !*** ./~/base64-js/index.js ***!
  \******************************/
/***/ function(module, exports) {

	'use strict'

	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}

	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63

	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}

	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}

	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)

	  arr = new Arr(len * 3 / 4 - placeHolders)

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len

	  var L = 0

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }

	  parts.push(output)

	  return parts.join('')
	}


/***/ },
/* 148 */
/*!****************************!*\
  !*** ./~/ieee754/index.js ***!
  \****************************/
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 149 */
/*!*************************************!*\
  !*** ./~/buffer/~/isarray/index.js ***!
  \*************************************/
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 150 */
/*!**************************************!*\
  !*** ./~/crypto-browserify/index.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(/*! ./rng */ 151)

	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}

	exports.createHash = __webpack_require__(/*! ./create-hash */ 153)

	exports.createHmac = __webpack_require__(/*! ./create-hmac */ 165)

	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}

	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}

	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}

	var p = __webpack_require__(/*! ./pbkdf2 */ 166)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync


	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 151 */
/*!************************************!*\
  !*** ./~/crypto-browserify/rng.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(/*! crypto */ 152)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */

	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 152 */
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
109,
/* 153 */
/*!********************************************!*\
  !*** ./~/crypto-browserify/create-hash.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! sha.js */ 154)

	var md5 = toConstructor(__webpack_require__(/*! ./md5 */ 162))
	var rmd160 = toConstructor(__webpack_require__(/*! ripemd160 */ 164))

	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}

	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 154 */
/*!***************************!*\
  !*** ./~/sha.js/index.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}

	var Buffer = __webpack_require__(/*! buffer */ 146).Buffer
	var Hash   = __webpack_require__(/*! ./hash */ 155)(Buffer)

	exports.sha1 = __webpack_require__(/*! ./sha1 */ 156)(Buffer, Hash)
	exports.sha256 = __webpack_require__(/*! ./sha256 */ 160)(Buffer, Hash)
	exports.sha512 = __webpack_require__(/*! ./sha512 */ 161)(Buffer, Hash)


/***/ },
/* 155 */
/*!**************************!*\
  !*** ./~/sha.js/hash.js ***!
  \**************************/
/***/ function(module, exports) {

	module.exports = function (Buffer) {

	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }

	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }

	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }

	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block

	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)

	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }

	      s += ch
	      f += ch

	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s

	    return this
	  }

	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8

	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80

	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)

	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }

	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)

	    var hash = this._update(this._block) || this._hash()

	    return enc ? hash.toString(enc) : hash
	  }

	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }

	  return Hash
	}


/***/ },
/* 156 */
/*!**************************!*\
  !*** ./~/sha.js/sha1.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = __webpack_require__(/*! util */ 157).inherits

	module.exports = function (Buffer, Hash) {

	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0

	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)

	  var POOL = []

	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()

	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)

	    this._h = null
	    this.init()
	  }

	  inherits(Sha1, Hash)

	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0

	    Hash.prototype.init.call(this)
	    return this
	  }

	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {

	    var a, b, c, d, e, _a, _b, _c, _d, _e

	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e

	    var w = this._w

	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)

	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )

	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }

	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }

	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }

	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }

	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }

	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }

	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }

	  return Sha1
	}


/***/ },
/* 157 */
/*!************************!*\
  !*** ./~/util/util.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ 158);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(/*! inherits */ 159);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./~/process/browser.js */ 107)))

/***/ },
/* 158 */
/*!*******************************************!*\
  !*** ./~/util/support/isBufferBrowser.js ***!
  \*******************************************/
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 159 */
/*!****************************************!*\
  !*** ./~/inherits/inherits_browser.js ***!
  \****************************************/
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 160 */
/*!****************************!*\
  !*** ./~/sha.js/sha256.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {


	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(/*! util */ 157).inherits

	module.exports = function (Buffer, Hash) {

	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]

	  var W = new Array(64)

	  function Sha256() {
	    this.init()

	    this._w = W //new Array(64)

	    Hash.call(this, 16*4, 14*4)
	  }

	  inherits(Sha256, Hash)

	  Sha256.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }

	  function R (X, n) {
	    return (X >>> n);
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }

	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }

	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }

	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }

	  Sha256.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]

	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w

	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }

	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0

	  };

	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)

	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)

	    return H
	  }

	  return Sha256

	}


/***/ },
/* 161 */
/*!****************************!*\
  !*** ./~/sha.js/sha512.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(/*! util */ 157).inherits

	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]

	  var W = new Array(160)

	  function Sha512() {
	    this.init()
	    this._w = W

	    Hash.call(this, 128, 112)
	  }

	  inherits(Sha512, Hash)

	  Sha512.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  Sha512.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0

	    for (var i = 0; i < 80; i++) {
	      var j = i * 2

	      var Wi, Wil

	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)

	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]

	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]

	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)

	        W[j] = Wi
	        W[j + 1] = Wil
	      }

	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)

	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]

	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)

	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }

	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0

	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }

	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)

	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }

	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)

	    return H
	  }

	  return Sha512

	}


/***/ },
/* 162 */
/*!************************************!*\
  !*** ./~/crypto-browserify/md5.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(/*! ./helpers */ 163);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;

	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;

	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);

	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 163 */
/*!****************************************!*\
  !*** ./~/crypto-browserify/helpers.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}

	module.exports = { hash: hash };

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 164 */
/*!**************************************!*\
  !*** ./~/ripemd160/lib/ripemd160.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160



	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];

	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};

	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};

	var processBlock = function (H, M, offset) {

	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];

	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }

	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;

	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;

	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};

	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}

	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}

	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}

	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}

	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}

	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}

	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');

	  var m = bytesToWords(message);

	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;

	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );

	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }

	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];

	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }

	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}



	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 165 */
/*!********************************************!*\
  !*** ./~/crypto-browserify/create-hmac.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! ./create-hash */ 153)

	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)

	module.exports = Hmac

	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg

	  var blocksize = (alg === 'sha512') ? 128 : 64

	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key

	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }

	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)

	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }

	  this._hash = createHash(alg).update(ipad)
	}

	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}

	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 166 */
/*!***************************************!*\
  !*** ./~/crypto-browserify/pbkdf2.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(/*! pbkdf2-compat/pbkdf2 */ 167)

	module.exports = function (crypto, exports) {
	  exports = exports || {}

	  var exported = pbkdf2Export(crypto)

	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync

	  return exports
	}


/***/ },
/* 167 */
/*!***********************************!*\
  !*** ./~/pbkdf2-compat/pbkdf2.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }

	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')

	    setTimeout(function() {
	      var result

	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }

	      callback(undefined, result)
	    })
	  }

	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')

	    if (iterations < 0)
	      throw new TypeError('Bad iterations')

	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')

	    if (keylen < 0)
	      throw new TypeError('Bad key length')

	    digest = digest || 'sha1'

	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)

	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)

	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)

	      var U = crypto.createHmac(digest, password).update(block1).digest()

	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen

	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }

	      U.copy(T, 0, 0, hLen)

	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()

	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }

	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }

	    return DK
	  }

	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 168 */
/*!*******************************!*\
  !*** ./src/modules/assets.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NULL_SCENE_ID = undefined;

	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 169);

	var _stringify2 = _interopRequireDefault(_stringify);

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _createReducer;

	exports.addFile = addFile;
	exports.removeFile = removeFile;
	exports.isLoading = isLoading;
	exports.getImage = getImage;
	exports.getOrFetchImage = getOrFetchImage;
	exports.getOrFetchBinary = getOrFetchBinary;
	exports.getHash = getHash;
	exports.getUrl = getUrl;
	exports.fetchText = fetchText;
	exports.fetchTransit = fetchTransit;
	exports.find = find;
	exports.filter = filter;
	exports.exportJSON = exportJSON;
	exports.getActiveAssets = getActiveAssets;
	exports.importImage = importImage;
	exports.importFile = importFile;

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 143);

	var _createReducer3 = _interopRequireDefault(_createReducer2);

	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 144);

	var _scene = __webpack_require__(/*! ./scene */ 171);

	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 281);

	var _selectors = __webpack_require__(/*! ./utils/selectors */ 172);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Managing assets
	 *
	 * @module assets
	 * @public
	 */

	var ADD_FILE = 'ADD_FILE';
	var REMOVE_FILE = 'REMOVE_FILE';

	var IMPORTING_FILE = 'IMPORTING_FILE';
	var IMPORTED_FILE = 'IMPORTED_FILE';
	var IMPORT_FILE_ERROR = 'IMPORT_FILE_ERROR';

	var initialState = (0, _immutable.Map)({});

	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, ADD_FILE, function (state, attrs, _ref) {
	  var action = _ref.action,
	      createEvent = _ref.createEvent;
	  var id = attrs.id;

	  if (action.meta && action.meta.saveFile) createEvent('saveFile', attrs);
	  return state.set(id, (0, _immutable.Map)(attrs));
	}), (0, _defineProperty3.default)(_createReducer, REMOVE_FILE, function (state, id) {
	  return state.delete(id);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref2) {
	  var assets = _ref2.assets;

	  return state.merge(assets);
	}), _createReducer));

	function addFile(attrs, saveFile) {
	  return { type: ADD_FILE, payload: attrs, meta: { saveFile: saveFile } };
	};

	function removeFile(id) {
	  return { type: REMOVE_FILE, payload: id };
	};

	function urlsFor(file) {
	  return (0, _ramda.map)(function (host) {
	    return host + '/' + file.get('hash') + file.get('suffix') + '?filename=' + file.get('name');
	  }, (["https://di2xnf34q86h1.cloudfront.net","https://editor.vimarket.io/resources"]));
	}

	function isLoading(id) {
	  return function (_ref3) {
	    var getIn = _ref3.getIn;
	    return getIn(['sceneIO', 'loadingFiles', id]);
	  };
	};

	function getImage(id) {
	  return images[id];
	};

	function getOrFetchImage(id) {
	  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  return function (store) {
	    var file = store.getIn(['assets', id]);
	    if (!file) return;

	    return store.callApi((0, _assign2.default)({
	      types: [_actionTypes.LOADING_FILE, _actionTypes.LOADED_FILE, _actionTypes.LOADING_FILE_ERROR],
	      url: urlsFor(file),
	      contentType: 'img',
	      payload: id,
	      queryKey: 'IMAGE' + file.get('hash'),
	      fireAndForget: true
	    }, attrs));
	  };
	}

	function getOrFetchBinary(id) {
	  return function (store) {
	    var file = store.getIn(['assets', id]);
	    if (file.get('content')) {
	      return file.get('content');
	    } else {
	      var lzmaFile = file.get('lzma') ? file.set('suffix', 'lzma1') : file;

	      return store.callApi({
	        types: [_actionTypes.LOADING_FILE, _actionTypes.LOADED_FILE, _actionTypes.LOADING_FILE_ERROR],
	        url: urlsFor(lzmaFile),
	        contentType: 'binary',
	        payload: id,
	        queryKey: 'FILE' + lzmaFile.get('hash'),
	        decompress: lzmaFile.get('lzma'),
	        fireAndForget: true
	      });
	    }
	  };
	}

	function getHash(store, id) {
	  return store.getIn(['assets', id, 'hash']);
	};

	/**
	 * get the url for the asset.
	 *
	 * @public
	 * @param {String} id
	 * @returns {String} the url pointing to the asset.
	 *
	 */
	function getUrl(store, id) {
	  var asset = store.getIn(['assets', id]);
	  if (asset) {
	    var urls = urlsFor(asset);
	    return urls[urls.length - 1];
	  } else {
	    return asset;
	  }
	};

	function fetchText(hash) {
	  return function (store) {
	    return store.callApi({
	      contentType: 'text',
	      url: (0, _ramda.map)(function (host) {
	        return host + '/' + hash;
	      }, (["https://di2xnf34q86h1.cloudfront.net","https://editor.vimarket.io/resources"]))
	    });
	  };
	};

	function fetchTransit(uuid) {
	  return function (store) {
	    return store.callApi({
	      contentType: 'text',
	      url: '/api/scenes/' + uuid
	    });
	  };
	};

	function find(store, fn) {
	  return store.get('assets').find(fn);
	};

	function filter(store, fn) {
	  return store.getIn(['assets']).filter(fn || function () {
	    return true;
	  });
	};

	function exportJSON(store) {
	  return store.getIn(['assets']).map(function (asset) {
	    var json = asset.toJS();
	    json._id = json.id;
	    delete json.id;
	    return json;
	  }).toArray();
	};

	function getActiveAssets(store) {
	  var sceneGraph = (0, _sceneGraph.getEvalSceneGraph)(store);
	  return filter(store, function (v, k) {
	    return !!sceneGraph.fileReferences.from[k];
	  });
	};

	function logBase(value, base) {
	  return Math.log(value) / Math.log(base);
	}

	function ceilPower2(value) {
	  return Math.pow(2, Math.ceil(logBase(value, 2)));
	}

	function clamp(value, min, max) {
	  return Math.max(min, Math.min(value, max));
	}

	function computeNewSize(imgInfo, maxSize) {
	  var newSize = {};
	  newSize.width = clamp(ceilPower2(imgInfo.width), 1, maxSize.width);
	  newSize.height = clamp(ceilPower2(imgInfo.height), 1, maxSize.height);
	  return newSize;
	};

	function resizeImage(file, maxWidth, maxHeight) {
	  return new _promise2.default(function (resolve, reject) {
	    var img = document.createElement('img');
	    var reader = new FileReader();
	    reader.onload = function (e) {
	      img.src = e.target.result;

	      img.onload = function () {
	        var canvas = document.createElement('canvas');
	        var ctx = canvas.getContext('2d');
	        ctx.drawImage(img, 0, 0);

	        var width = img.width;
	        var height = img.height;
	        var newSize = computeNewSize({ width: width, height: height }, { width: maxWidth, height: maxHeight });
	        canvas.width = newSize.width;
	        canvas.height = newSize.height;

	        var ctx2 = canvas.getContext('2d');
	        ctx2.drawImage(img, 0, 0, newSize.width, newSize.height);

	        resolve(canvas.toDataURL(file.type));
	      };
	    };

	    reader.readAsDataURL(file);
	  });
	}

	var MAX_IMG_SIZE = 4096;
	var NULL_SCENE_ID = exports.NULL_SCENE_ID = '00000000-0000-0000-0000-000000000000';

	/**
	 *
	 * This will upload an image, add an image node to the scene graph, and return
	 * an object with the id of the new node, and the id of the uploaded asset.
	 *
	 * If you save the assetId, that assetId can be passed into this function
	 * to get a new image node for the scene. That means you can restore the state of
	 * a scene without having to reimport the previous image.
	 *
	 * See [The demo example](tutorial-demo-ImportImage.html) for an example of usage.
	 *
	 * @public
	 * @param {(File|String)} image A [File](https://developer.mozilla.org/en/docs/Web/API/File) to import, an assetId from a previous import, or url src of image.
	 * @param {Object} options
	 * @param {Number} options.resizeTo A max width/height to resize the
	 *   image to (preserves aspect ratio of image)
	 * @returns Promise resolve to an object with `assetId` and `imageNodeId` keys
	 *
	 */
	function importImage(file) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  return function (store) {
	    function fetchAsset(uuid) {
	      return store.callApi({
	        types: [IMPORTING_FILE, IMPORTED_FILE, IMPORT_FILE_ERROR],
	        url: ("https://editor.vimarket.io/api") + '/files/' + uuid + '/asset'
	      });
	    }

	    function importImageURL(url) {
	      var body = (0, _stringify2.default)({
	        url: url,
	        maxSize: options.resizeTo || MAX_IMG_SIZE,
	        sceneId: NULL_SCENE_ID
	      });

	      return store.callApi({
	        types: [IMPORTING_FILE, IMPORTED_FILE, IMPORT_FILE_ERROR],
	        method: 'POST',
	        url: ("https://editor.vimarket.io/api") + '/files/image',
	        body: body
	      });
	    };

	    // Post to the server to create the image asset
	    function importImage(image) {
	      var body = (0, _stringify2.default)({
	        content: image,
	        name: file.name,
	        sceneId: NULL_SCENE_ID,
	        type: file.type
	      });

	      return importFile(store, { body: body });
	    }

	    // Add the asset to the store.
	    function addImageAsset(image) {
	      return store.dispatch(addFile((0, _assign2.default)({ id: image._id }, image)));
	    }

	    // Create the image node from given asset
	    function createImageNode(imageAsset) {
	      return store.dispatch((0, _sceneGraph.addNode)({
	        name: imageAsset.name || file.name,
	        type: 'Image',
	        parent: (0, _scene.find)(store, { name: 'Material Library' }),
	        plugs: {
	          Image: [['Image', { glBitmapFile: imageAsset.id, glOption: 1 }]],
	          Properties: [['ImageProperties', {}]]
	        }
	      })).then(function (imageNodeId) {
	        return {
	          imageNodeId: imageNodeId,
	          assetId: imageAsset.id,
	          imageSize: {
	            width: imageAsset.height,
	            height: imageAsset.width,
	            originalWidth: imageAsset.originalWidth,
	            originalHeight: imageAsset.originalHeight
	          }
	        };
	      });
	    }

	    if (typeof file === 'string') {
	      if ((0, _selectors.isUuid)(file)) {
	        return fetchAsset(file).then(addImageAsset).then(createImageNode);
	      } else {
	        return importImageURL(file).then(addImageAsset).then(createImageNode).catch(function (err) {
	          var errMessage = void 0;

	          if (err.status && err.status < 500) errMessage = 'Image not imported, bad url';else if (err.status && err.status >= 500) errMessage = 'Image not imported, internal error';else errMessage = err;

	          return _promise2.default.reject(errMessage);
	        });
	      }
	    }

	    if (!file.type) return _promise2.default.reject('Expect a File');
	    if (file.type !== 'image/jpeg' && file.type !== 'image/png') return _promise2.default.reject('File must be a jpg or png');

	    var max = options.resizeTo || MAX_IMG_SIZE;

	    return resizeImage(file, max, max).then(importImage).then(addImageAsset).then(createImageNode);
	  };
	}

	function importFile(store) {
	  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  return store.callApi((0, _assign2.default)({
	    types: [IMPORTING_FILE, IMPORTED_FILE, IMPORT_FILE_ERROR],
	    method: 'POST',
	    url: ("https://editor.vimarket.io/api") + '/files'
	  }, attrs));
	}

	var publicApi = {
	  reducer: reducer,
	  actions: { addFile: addFile, removeFile: removeFile, importImage: importImage },
	  selectors: { _getHash: getHash, getUrl: getUrl, filter: filter, find: find, getActiveAssets: getActiveAssets, exportJSON: exportJSON }
	};
	exports.default = publicApi;

/***/ },
/* 169 */
/*!***************************************************!*\
  !*** ./~/babel-runtime/core-js/json/stringify.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/json/stringify */ 170), __esModule: true };

/***/ },
/* 170 */
/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/json/stringify.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(/*! ../../modules/_core */ 13)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 171 */
/*!******************************!*\
  !*** ./src/modules/scene.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 101);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	exports.find = find;
	exports.filter = filter;
	exports.get = get;
	exports.getAll = getAll;
	exports.getEval = getEval;
	exports.getWorldTransform = getWorldTransform;
	exports.getRelativeTransform = getRelativeTransform;
	exports.getLocalTransform = getLocalTransform;
	exports.set = set;
	exports.setAll = setAll;
	exports.getWarnings = getWarnings;
	exports.setVRCamera = setVRCamera;
	exports.clone = clone;
	exports.pruneAssets = pruneAssets;
	exports.getNodeBoundingBox = getNodeBoundingBox;
	exports.getCurrentPass = getCurrentPass;
	exports.exportJSON = exportJSON;
	exports.addNode = addNode;
	exports.addOperator = addOperator;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 144);

	var _assets = __webpack_require__(/*! ./assets */ 168);

	var _selectors = __webpack_require__(/*! ./utils/selectors */ 172);

	var _nonImmutable = __webpack_require__(/*! ../operators/nonImmutable */ 173);

	var _nonImmutable2 = _interopRequireDefault(_nonImmutable);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * This module is a high level scene graph manipulation and query library.
	 *
	 * * Either id, name, or regex's can be used for node names.
	 * * All `get` functions return the value, or undefined if no match is found
	 * * All `find` functions return an `id` or a Path
	 * * All `filter` functions return an array of `id` or Path
	 * *
	 * @module scene
	 * @public
	 *
	 */

	/**
	 * Finds first matching node.
	 * If propertyName is specified, will look for the first matching operator,
	 * and if found, return a path to the operator property.
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @public
	 * @param {(String|QueryObject)} query The query object to filter on (or a string that gets converted to a query object).
	 *
	 * @example
	 *
	 * // Return the node uuid
	 * scene.find('Box'); -> 'uuid'
	 * // Return the path to the transform operator
	 * scene.find('Box','Transform','translation'); -> ['uuid','Transform',0]
	 * // Match the first node that starts with Box
	 * scene.find('Box*');
	 *
	 */
	function find(store, query, onlyNode) {
	  var queryObj = (0, _selectors.buildQueryObject)(query);
	  var sceneGraph = store.get('sceneGraph');

	  // Don't need to do a search if we have an id
	  if (queryObj.id) {
	    var foundNode = sceneGraph.nodes[queryObj.id];
	    if (foundNode && queryObj.parent) {
	      return foundNode.parent || null;
	    }

	    if (foundNode && queryObj.child) {
	      return (0, _selectors.findChild)(store, foundNode, { type: queryObj.child, shallow: true }, false, true) || null;
	    }

	    return foundNode ? (0, _selectors.getMatch)(foundNode, queryObj, onlyNode) : null;
	  }

	  // If we ask to search `all`, then we do a linear search. This lets us
	  // find nodes from scenes not in the active scene graph.
	  if (queryObj.from && queryObj.from.all) {
	    var result = void 0;
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(sceneGraph.nodes)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var id = _step.value;

	        result = (0, _selectors.getMatch)(sceneGraph.nodes[id], queryObj);
	        if (result) return result;
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    return null;
	  }

	  var rootId = queryObj.from ? find(store, queryObj.from, true) : store.getIn(['sceneIO', 'id']);
	  var rootNode = rootId && sceneGraph.nodes[rootId];

	  return rootNode ? (0, _selectors.findChild)(store, rootNode, queryObj, queryObj.includeParent && rootNode, onlyNode) : null;
	};

	function matchSceneNode(store, queryObj, onlyNode) {
	  var node = store.getIn('sceneGraph').nodes[store.getIn(['sceneIO', 'id'])];
	  return node && (0, _selectors.getMatch)(node, queryObj, onlyNode) || null;
	};

	/**
	 * This function will iterate through the scene graph, returning an array
	 * of all elements that match the parameters provided.
	 *
	 * The return value of this function will either be an array of ids (if nodequery and
	 * plug are provied), or an array of paths (if property is provided).
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @public
	 * @param {(String|QueryObject)} query The query object to filter on (or a string that gets converted to a query object).
	 * @returns {Array}
	 */
	function filter(store, query) {
	  var queryObj = (0, _selectors.buildQueryObject)(query);
	  var fromId = queryObj.from ? find(store, queryObj.from) : store.getIn(['sceneIO', 'id']);

	  // No matching from query, return empty search
	  if (queryObj.from && !fromId) return [];

	  var fromNode = store.get('sceneGraph').nodes[fromId];

	  if (!fromNode) {
	    throw new Error('Unknown node to filter from');
	  }

	  return (0, _selectors.matchChildren)(store, fromNode, queryObj, queryObj.includeParent && fromNode);
	};

	/**
	 * Returns the value at the matching property.
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @param {(String|QueryObject|Path)} query The query object to filter on (or a string that gets converted to a query object).
	 * @returns {any}
	 * @public
	 */
	function get(store, query) {
	  var path = Array.isArray(query) ? query : find(store, query);
	  if (!path || !Array.isArray(path)) return undefined;
	  if (path.length >= 2 && path[1] === 'eval') {
	    var evalNode = (0, _sceneGraph.getEvalSceneGraph)(store).evaluatedNodes[path[0]];
	    var evalPlug = evalNode && evalNode[path[2]];
	    return evalPlug && path[3] ? evalPlug[path[3]] : evalPlug;
	  }

	  return (0, _sceneGraph.get)(store, path);
	};

	/**
	 * Returns an array of values for the matching properties
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @param {(String|QueryObject|Path)} query The query object to filter on (or a found path)
	 * @returns {any[]}
	 * @public
	 */
	function getAll(store, query) {
	  var paths = Array.isArray(query) ? query : filter(store, query);
	  return paths ? (0, _ramda.reduce)(function (obj, path) {
	    obj[path[0]] = (0, _sceneGraph.get)(store, path);
	    return obj;
	  }, {}, paths) : undefined;
	};

	/**
	 * Returns the evaluated plug (and/or property).
	 * @param {String} nodeId id of the node
	 * @param {String} plug
	 * @param {?String} key
	 *
	 * @example
	 *
	 * // Return the calculated transform
	 * ctx.getEval('Box','Transfrom','translation');
	 * // Return the orbitTarget for the scene camera
	 * ctx.getEval(true, 'Player', 'orbitTarget');
	 */
	function getEval(store, nodeId, plug, key) {
	  return get(store, key ? [nodeId, plug, key] : [nodeId, plug]);
	};

	/**
	 * Get the world transform for a node.
	 *
	 * @param {String} id
	 * @public
	 * @returns {?THREE.Matrix4}
	 */
	function getWorldTransform(store, id) {
	  var transform = get(store, { id: id, evalPlug: 'Transform' });
	  if (!transform) return null;

	  var localTransform = transform.transform;
	  var node = store.get('sceneGraph').nodes[id];
	  var parent = node && node.parent;

	  var parentTransform = parent && getWorldTransform(store, parent);
	  return parentTransform ? new THREE.Matrix4().copy(parentTransform).multiply(localTransform) : new THREE.Matrix4().copy(localTransform);
	}

	/**
	 * Get the transform for a node relative to a specified ancestor node. If rootId is not in id's
	 *  ancestry, the result is simply the world transform.
	 *
	 * @param {String} id
	 * @param {String} rootId - the node for which we want to calculated id's relative transform from
	 * @public
	 * @returns {?THREE.Matrix4}
	 */
	function getRelativeTransform(store, id, rootId) {
	  var transform = get(store, { id: id, evalPlug: 'Transform' });
	  if (!transform || id === rootId) return null;

	  var localTransform = transform.transform;
	  var node = store.get('sceneGraph').nodes[id];
	  var parent = node && node.parent;
	  var parentTransform = parent && getRelativeTransform(store, parent, rootId);
	  return parentTransform ? new THREE.Matrix4().copy(parentTransform).multiply(localTransform) : new THREE.Matrix4().copy(localTransform);
	}

	/**
	 * Get the local transform for a node.
	 *
	 * @returns {?THREE.Matrix4}
	 */
	function getLocalTransform(transform) {
	  var translation = transform.translation,
	      rotation = transform.rotation,
	      scale = transform.scale,
	      rotateOrder = transform.rotateOrder,
	      preRotation = transform.preRotation,
	      rotatePivotOffset = transform.rotatePivotOffset,
	      localRotatePivot = transform.localRotatePivot,
	      scalePivotOffset = transform.scalePivotOffset,
	      localScalePivot = transform.localScalePivot,
	      shear = transform.shear;

	  if (scale.x === 0) scale.x = 0.0000001;
	  if (scale.y === 0) scale.y = 0.0000001;
	  if (scale.z === 0) scale.z = 0.0000001;
	  var zero = new THREE.Vector3(0, 0, 0);

	  var matrixStack = [];

	  var translationM = new THREE.Matrix4().makeTranslation(translation.x, translation.y, translation.z);
	  matrixStack.push(translationM);

	  var rotatePivotOffestM = new THREE.Matrix4();
	  if (!rotatePivotOffset.equals(zero)) {
	    rotatePivotOffestM.makeTranslation(rotatePivotOffset.x, rotatePivotOffset.y, rotatePivotOffset.z);
	    matrixStack.push(rotatePivotOffestM);
	  }

	  var localRotatePivotM = new THREE.Matrix4();
	  var invLocalRotatePivotM = new THREE.Matrix4();
	  var localRotatePivotFlag = false;
	  if (!localRotatePivot.equals(zero)) {
	    localRotatePivotM.makeTranslation(localRotatePivot.x, localRotatePivot.y, localRotatePivot.z);
	    matrixStack.push(localRotatePivotM);
	    invLocalRotatePivotM.getInverse(localRotatePivotM, true);
	    localRotatePivotFlag = true;
	  }

	  var preRotationM = new THREE.Matrix4();
	  if (!preRotation.equals(zero)) {
	    var localRotationRadians = new THREE.Vector3().copy(preRotation).multiplyScalar(Math.PI / 180);
	    preRotationM.makeRotationFromEuler(new THREE.Euler(localRotationRadians.x, localRotationRadians.y, localRotationRadians.z, rotateOrder));
	    matrixStack.push(preRotationM);
	  }

	  var rotationRadians = new THREE.Vector3().copy(rotation).multiplyScalar(Math.PI / 180);
	  var rotationM = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(rotationRadians.x, rotationRadians.y, rotationRadians.z, rotateOrder));
	  matrixStack.push(rotationM);

	  if (localRotatePivotFlag) matrixStack.push(invLocalRotatePivotM);

	  var scalePivotOffsetM = new THREE.Matrix4();
	  if (!scalePivotOffset.equals(zero)) {
	    scalePivotOffsetM.makeTranslation(scalePivotOffset.x, scalePivotOffset.y, scalePivotOffset.z);
	    matrixStack.push(scalePivotOffsetM);
	  }

	  var localScalePivotM = new THREE.Matrix4();
	  var invLocalScalePivotM = new THREE.Matrix4();
	  var localScalePivotFlag = false;
	  if (!localScalePivot.equals(zero)) {
	    localScalePivotM.makeTranslation(localScalePivot.x, localScalePivot.y, localScalePivot.z);
	    matrixStack.push(localScalePivotM);
	    invLocalScalePivotM.getInverse(localScalePivotM, true);
	    localScalePivotFlag = true;
	  }

	  var sX = shear.x,
	      sY = shear.y,
	      sZ = shear.z;
	  var shearM = new THREE.Matrix4().set(1, sX, sY, 0, 0, 1, sZ, 0, 0, 0, 1, 0, 0, 0, 0, 1); //.makeShear(new THREE.Vector3(0, 0, 0));
	  matrixStack.push(shearM);

	  var scaleM = new THREE.Matrix4().makeScale(scale.x, scale.y, scale.z);
	  matrixStack.push(scaleM);

	  if (localScalePivotFlag) matrixStack.push(invLocalScalePivotM);

	  var matrixAccumulation = new THREE.Matrix4();
	  for (var i = 0; i < matrixStack.length; i++) {
	    matrixAccumulation.multiply(matrixStack[i]);
	  }

	  return matrixAccumulation;
	}

	/**
	 * Sets the property at path to value.
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @param {(Path|QueryObject|String)} query The query object to filter on (or a string that gets converted to a query object).
	 * @param {any} value The value to set, the type must match the property being set.
	 * @public
	 */
	function set(query, value) {
	  return function (store) {
	    var path = Array.isArray(query) ? query : find(store, query);
	    if (!path) {
	      console.warn('No matching query', query);
	      return _promise2.default.resolve();
	    }

	    if (path.length === 3) {
	      if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== 'object') throw new Error('If no property is set, expect an object to merge into the operator');
	      return store.dispatch((0, _sceneGraph.merge)(path, value));
	    } else if (path.length === 4) {
	      return store.dispatch((0, _sceneGraph.set)(path, value));
	    } else if (path.length === 2) {
	      if (path[1] !== 'name') throw new Error('Can only set node name');
	      return store.dispatch((0, _sceneGraph.set)(path, value));
	    }
	  };
	};

	/**
	 * Given an array of paths, will set the `value` on each path.
	 * This can be combined with `find` to set a number of properties at once.
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @public
	 * @param {(Path[]|QueryObject|String)} query An array of path arrays, or a QueryObject
	 * @param {any} value The value to set the properties to.
	 *
	 * @example
	 *
	 * // Move all boxes to the origin
	 * const paths = ctx.find('Box*', 'Transform', 'translation');
	 * setAll(paths, {x: 0, y: 0, z: 0});
	 *
	 */
	function setAll(query, value) {
	  //if (!Array.isArray(paths)) return Promise.reject('paths must be an array');
	  return function (store) {
	    var paths = Array.isArray(query) ? query : filter(store, query);
	    //console.log('ctx.setAll', paths, value);
	    return _promise2.default.all((0, _ramda.map)(function (path) {
	      return store.dispatch(set(path, value));
	    }, paths));
	  };
	};

	/*
	 * Returns an array of nodes with warnings in the scene graph.
	 * @private
	 */
	function getWarnings(store) {
	  var sceneGraph = store.get('sceneGraph');
	  var nodeIds = (0, _keys2.default)(sceneGraph.nodes);
	  var node = void 0;
	  var warningNodes = [];
	  for (var i = 0; i < nodeIds.length; i++) {
	    node = sceneGraph.nodes[nodeIds[i]];
	    if (node && node.warnings && node.warnings.length) warningNodes.push(node);
	  }

	  return warningNodes;
	}

	function setVRCamera(query) {
	  return function (store) {
	    query.type = 'Camera';
	    var newVRCamera = find(store, query);
	    store.dispatch((0, _sceneGraph.setVRCamera)(newVRCamera));
	  };
	}

	/**
	 * Given a query, clone these nodes. Without options, these nodes will be cloned
	 * in place
	 *
	 * @public
	 * @param {(QueryObject|String|Path[])} query A list of nodes (from filter), or query that will find a list of nodes to clone
	 * @param {Object} [options]
	 * @param {String} [options.to] The scene being cloned to (default is the active scene)
	 * @param {String} [options.withNull] Add a null to clone the nodes to
	 * @param {Object} [options.includeDependencies] Clone dependencies (default true)
	 *
	 * @example
	 *
	 * // Clone all nodes from Objects on import scene into active scene
	 * scene.clone({from: {id: importId, child: 'Objects'}});
	 *
	 * // Clone children of a null to a new null
	 * scene.clone({from: {id: importId, child: 'Objects'}}, {withNull: 'New Parent Null'});
	 *
	 * // Clone children, without also cloning dependencies.
	 *
	 *
	 * // Return the path to the transform operator
	 * scene.find('Box','Transform','translation'); -> ['uuid','Transform',0]
	 * // Match the first node that starts with Box
	 * scene.find('Box*');
	 *
	 */
	function clone(query) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  if (options.cloneDependencies === undefined) options.cloneDependencies = true;

	  return function (store) {
	    var _nodeMap;

	    var paths = Array.isArray(query) ? query : filter(store, query);
	    if (!paths.length) {
	      console.warn('No match for clone: ', query);
	      return _promise2.default.resolve(true);
	    }

	    var fromSceneId = (0, _sceneGraph.findRoot)(store, paths[0]);
	    var toSceneId = options.to || store.getIn(['sceneIO', 'id']);
	    var fromObjectsId = find(store, { id: fromSceneId, child: 'Objects' });
	    var toObjectsId = find(store, { id: toSceneId, child: 'Objects' });

	    var nodeMap = (_nodeMap = {}, (0, _defineProperty3.default)(_nodeMap, fromObjectsId, toObjectsId), (0, _defineProperty3.default)(_nodeMap, find(store, { id: fromSceneId, child: 'MaterialLibrary' }), find(store, { id: toSceneId, child: 'MaterialLibrary' })), _nodeMap);

	    var nullNode = options.withNull ? store.dispatch((0, _sceneGraph.addNode)({
	      name: options.withNull,
	      parent: toObjectsId,
	      type: 'Null',
	      plugs: {
	        Null: [['Null', {}]],
	        Transform: [['Transform', {}]],
	        Properties: [['Default', {}]]
	      }
	    })) : _promise2.default.resolve(null);

	    return nullNode.then(function (nullNodeId) {
	      if (nullNodeId) nodeMap[fromObjectsId] = nullNodeId;
	      return store.dispatch((0, _sceneGraph.clone)(paths, nodeMap, { cloneDependencies: options.cloneDependencies })).then(function (cloneMap) {
	        if (nullNodeId) cloneMap[options.withNull] = nullNodeId;
	        return cloneMap;
	      });
	    });
	  };
	}

	function pruneAssets() {
	  return function (store) {
	    var sceneGraph = store.get('sceneGraph');
	    var usedAssets = {};
	    var nodes = filter(store, { includeParent: true });

	    function storeFileRefs(id) {
	      var plugs = sceneGraph.nodes[id] && sceneGraph.nodes[id].plugs;
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        var _loop = function _loop() {
	          var plugName = _step2.value;

	          plugs[plugName].forEach(function (op, opIdx) {
	            var operator = (0, _nonImmutable.lookupOperator)(plugName, op.type, []);
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;

	            try {
	              for (var _iterator3 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                var refKey = _step3.value;

	                if (op[refKey]) usedAssets[op[refKey]] = true;
	              }
	            } catch (err) {
	              _didIteratorError3 = true;
	              _iteratorError3 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                  _iterator3.return();
	                }
	              } finally {
	                if (_didIteratorError3) {
	                  throw _iteratorError3;
	                }
	              }
	            }
	          });
	        };

	        for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(plugs || {})), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          _loop();
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    };

	    nodes.forEach(storeFileRefs);

	    return _promise2.default.all((0, _assets.filter)(store).map(function (asset) {
	      return !usedAssets[asset.get('id')] && store.dispatch((0, _assets.removeFile)(asset.get('id')));
	    }));
	  };
	}

	function getNodeBoundingBox(store, id) {
	  var translator = store.getTranslator();
	  if (translator) return translator.getNodeBoundingBox(id);
	  return new THREE.Box3();
	};

	function getCurrentPass(store, optionalPassName) {
	  if (optionalPassName) {
	    return get(store, { name: optionalPassName, evalPlug: 'Pass' });
	  }
	  var currPassID = get(store, { name: 'Passes', plug: 'GeneralRenderer', property: 'curPass' });
	  var currPass = get(store, { id: currPassID, evalPlug: 'Pass' });
	  return currPass || get(store, { type: 'Pass', evalPlug: 'Pass' });
	};

	function exportJSON(store, sceneId) {
	  var _sceneId = sceneId || store.getIn(['sceneIO', 'id']);

	  var nodes = filter(store, { from: { id: _sceneId }, includeParent: true });
	  return {
	    sceneGraph: (0, _sceneGraph.exportJSON)(store, nodes),
	    assets: (0, _assets.exportJSON)(store)
	  };
	};

	var nodeTypes = {
	  //Scene: {
	  //  'Environment': 'Environment',
	  //  'Timeline': 'Timeline',
	  //  'Player': 'Player',
	  //},
	  BinMesh: {
	    'BinMesh': 'ProxyMesh',
	    'Transform': 'Transform',
	    'Material': 'Reference',
	    'Properties': 'BinMeshProperties'
	  },
	  PolyMesh: {
	    'PolyMesh': 'Box',
	    'Transform': 'Transform',
	    'Material': 'Reference',
	    'Properties': 'PolyMeshProperties'
	  },
	  Light: {
	    'Light': 'PointLight',
	    'Transform': 'Transform',
	    'Properties': 'Default'
	  },
	  Camera: {
	    'Camera': 'Camera',
	    'Transform': 'Transform',
	    'Properties': 'Default'
	  },
	  Null: {
	    'Null': 'Null',
	    'Transform': 'Transform',
	    'Properties': 'Default'
	  },
	  Model: {
	    'Null': 'Null',
	    'Transform': 'Transform',
	    'Mixer': 'Mixer',
	    'Properties': 'ModelProperties'
	  },
	  Material: {
	    'Material': 'Physical',
	    'Properties': 'MaterialProperties'
	  },
	  Image: {
	    'Image': 'Image',
	    'Properties': 'ImageProperties'
	  },
	  Pass: {
	    'Pass': 'Pass'
	  },
	  Renderer: {
	    'Renderer': 'WebGLRenderer'
	  },
	  Bone: {
	    'Bone': 'Bone',
	    'Transform': 'BoneTransform',
	    'Properties': 'Default'
	  },
	  Annotation: {
	    'Annotation': 'Annotation',
	    'Transform': 'Transform',
	    'Properties': 'Default'
	  }
	};

	/**
	 * Add a node to the scene.
	 *
	 * @public
	 * @param {Node} node The new node being added
	 * @param {String} node.name The name of the new node
	 * @param {String} node.type The type of the new node
	 * @param {String} node.parent the id of the parent node for the new node
	 * @param {Object} [node.plugs] The plugs for the new node
	 * @returns {Promise}
	 *
	 */
	function addNode(node) {
	  var name = node.name,
	      type = node.type,
	      parent = node.parent,
	      plugs = node.plugs;

	  if (!parent) throw new Error('addNode requires parent to be set');
	  if (!type) throw new Error('addNode requires type to be set');
	  if (!name) throw new Error('addNode requires name to be set');
	  if (!nodeTypes[type]) throw new Error('invalid type: ' + type + ' for addNode');
	  var toPlugs = plugs || {};
	  var _iteratorNormalCompletion4 = true;
	  var _didIteratorError4 = false;
	  var _iteratorError4 = undefined;

	  try {
	    for (var _iterator4 = (0, _getIterator3.default)((0, _keys2.default)(nodeTypes[type])), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	      var _plugName = _step4.value;

	      if (!toPlugs[_plugName]) toPlugs[_plugName] = [[nodeTypes[type][_plugName], {}]];
	      if (!toPlugs[_plugName][0][0]) throw new Error('Required operator for ' + _plugName);
	    }
	  } catch (err) {
	    _didIteratorError4 = true;
	    _iteratorError4 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion4 && _iterator4.return) {
	        _iterator4.return();
	      }
	    } finally {
	      if (_didIteratorError4) {
	        throw _iteratorError4;
	      }
	    }
	  }

	  return (0, _sceneGraph.addNode)({ name: name, type: type, plugs: toPlugs, parent: parent });
	};

	/**
	 * Add an operator to an existing node in the scene.
	 *
	 * @public
	 * @param {String} id The id of the node receiving the operator
	 * @param {String} plugType The plug that is receiving the operator
	 * @param {string} operatorType The type of operator being added
	 * @param {Object} [operator] The details of the operator
	 * @param {String} [name] the name of the operator
	 * @returns {Promise}
	 *
	 */
	function addOperator(id, plugType, operatorType) {
	  var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	  var name = arguments[4];

	  if (!id) throw new Error('addOperator requires the id for the element receiving the operator');
	  if (!plugType) throw new Error('addOperator requires the plug to be set');
	  if (!operatorType) throw new Error('addOperator requires the operator type to be set');

	  var plug = _nonImmutable2.default[plugType];
	  if (!plug) throw new Error('Unknown plug: ' + plugType);
	  var op = plug[operatorType];
	  if (!op) throw new Error('Unknown operator: ' + operatorType);

	  return (0, _sceneGraph.addOperator)(id, plugType, [operatorType, operator, name]);
	}

	var publicApi = {
	  actions: { set: set, setAll: setAll, clone: clone, pruneAssets: pruneAssets, setVRCamera: setVRCamera, addOperator: addOperator, addNode: addNode },
	  selectors: { get: get, getAll: getAll, getWorldTransform: getWorldTransform, find: find, filter: filter, getWarnings: getWarnings,
	    exportJSON: exportJSON, getNodeBoundingBox: getNodeBoundingBox, getCurrentPass: getCurrentPass }
	};

	exports.default = publicApi;

/***/ },
/* 172 */
/*!****************************************!*\
  !*** ./src/modules/utils/selectors.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.isUuid = isUuid;
	exports.buildQueryObject = buildQueryObject;
	exports.getMatch = getMatch;
	exports.matchChildren = matchChildren;
	exports.findChild = findChild;

	var _ramda = __webpack_require__(/*! ramda */ 78);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

	/**
	 * Test whether a string is a uuid or not.
	 * @param {String} id
	 */
	function isUuid(id) {
	  return uuidRegex.test(id);
	};

	function pathToRegExp(query) {
	  if (query instanceof RegExp) return query;
	  query = query.replace(/\*/g, '(.*)').replace(/^\"|\"$/g, '');
	  return new RegExp('^' + query + '$', 'i');
	};

	var re = {
	  bareName: '^([^!%\[#:]*)*', // Match the name, up to % or #
	  type: '(?:\%([^#!:]*))*', // Match the type
	  filter: '(?::([^#:]*))*', // Any filter?
	  evalPlug: '(?:\!([^#\[]*))*', // Evaluated plug name
	  plugName: '(?:\#([^\[]*))*', // Plug name
	  attrs: '(.*)' };

	var queryRegex = new RegExp(re.bareName + re.type + re.filter + re.evalPlug + re.plugName + re.attrs);

	var queryRegexNoName = new RegExp('()' + re.type + re.filter + re.evalPlug + re.plugName + re.attrs);

	var attrsRegex = /(?:\[([^\]]*)\])/g;

	/*
	 * Parse "[translation][name='Transform']" and turn it into
	 * operator/property/properties fields for matching.
	 */
	function parseOperatorAttributes(attrsString) {
	  // Take "[translation][name='Transform']" and convert it into
	  // a filter function that will match the specific operator
	  var items, match;

	  var property = void 0;
	  var properties = void 0;

	  while ((match = attrsRegex.exec(attrsString)) !== null) {
	    items = match[1].split('=');
	    if (items.length === 2) {
	      if (!properties) properties = {};
	      properties[items[0]] = items[1];
	    } else {
	      property = items[0];
	    }
	  }

	  return { property: property, properties: properties };
	};

	function buildQueryObjectFromString(query) {
	  // Support looking for the active scene node with '~'.
	  var scene = query[0] === '~';
	  var quotedIdx = !scene && query[0] === '"' && query.slice(1).indexOf('"');
	  var quotedName = quotedIdx && quotedIdx !== -1;

	  var matches = quotedName || scene ? queryRegexNoName.exec(query.slice(scene ? 1 : quotedIdx + 2)) : queryRegex.exec(query);
	  var name = quotedName ? query.slice(1, quotedIdx + 1) : scene ? false : matches[1];
	  var type = matches[2];
	  var filter = matches[3];
	  var evalPlug = matches[4];
	  var plug = matches[5];
	  var attrs = matches[6];
	  var id = isUuid(name) ? name : undefined;
	  return (0, _assign2.default)({ scene: scene, id: id, name: id || !name ? undefined : pathToRegExp(name),
	    type: type, filter: filter, evalPlug: evalPlug, plug: plug }, parseOperatorAttributes(attrs), { includeParent: true });
	};

	/**
	 * Takes a query string, and returns an object with the attributes we are looking
	 * for.
	 */
	function buildQueryObject(query) {
	  if (typeof query === 'string') return buildQueryObjectFromString(query);
	  if ((typeof query === 'undefined' ? 'undefined' : (0, _typeof3.default)(query)) === 'object') {
	    //if (typeof query.name === 'string' && query.name.indexOf('*') !== -1)
	    return (0, _assign2.default)({}, query, {
	      name: query.name ? pathToRegExp(query.name) : undefined,
	      names: query.names && Array.isArray(query.names) ? query.names.map(pathToRegExp) : undefined,
	      // include parent by default if no from query is specified
	      includeParent: query.includeParent === undefined ? !query.from : query.includeParent
	    });
	  }

	  return {};
	}

	/*
	 * Given a QueryObject, will return a matching path for this node, or
	 * null if the node does not match.
	 */
	function getMatch(node, queryObj, onlyNode) {
	  var nodeMatch = getNodeMatch(node, queryObj);
	  return !nodeMatch ? null : onlyNode ? nodeMatch.id : matchInside(node, queryObj);
	}

	/*
	 * Given a QueryObject, will return the node if the node matches the
	 * node query parameters (id, name, type).
	 */
	function getNodeMatch(node, queryObj) {
	  if (queryObj.id !== undefined && queryObj.id !== node.id) return null;
	  if (queryObj.name !== undefined && !queryObj.name.test(node.name)) return null;
	  if (queryObj.type !== undefined) {
	    if (typeof queryObj.type === 'string') {
	      if (queryObj.type !== node.type) return null;
	    } else if (Array.isArray(queryObj.type)) {
	      var found = false;
	      if ((0, _ramda.contains)(node.type, queryObj.type)) found = true;else if (queryObj.type.indexOf && queryObj.type.indexOf(node.type) >= 0) found = true;

	      if (!found) return null;
	    }
	  }
	  if (queryObj.hasPlug !== undefined && !node.plugs[queryObj.hasPlug]) return null;

	  return node;
	};

	function matchInside(node, queryObj) {
	  var properties = queryObj.properties,
	      property = queryObj.property,
	      operator = queryObj.operator,
	      operatorIndex = queryObj.operatorIndex;


	  if (queryObj.evalPlug) {
	    return property ? [node.id, 'eval', queryObj.evalPlug, property] : [node.id, 'eval', queryObj.evalPlug];
	  }

	  if (!queryObj.plug) {
	    if (property === 'name' || property === 'type') {
	      return [node.id, property];
	    }

	    return node.id;
	  }

	  var plug = node.plugs[queryObj.plug];
	  if (!plug) return null;

	  var propKeys = properties && (0, _keys2.default)(properties);

	  if (!properties && !property && !operator && operatorIndex === undefined) {
	    return node.id; // No operator query provided.
	  }

	  var idx = queryObj.operatorIndex !== undefined ? queryObj.operatorIndex : (0, _ramda.findIndex)(function (op) {
	    return (property ? op.hasOwnProperty(property) : true) && (properties ? (0, _ramda.all)(function (k) {
	      return op[k] === properties[k];
	    }, propKeys) : true);
	  }, plug);

	  if (idx === -1) return null;
	  return property ? [node.id, queryObj.plug, idx, property] : [node.id, queryObj.plug, idx];
	};

	function matchChildren(store, node, queryObj, parentNodeToMatch) {
	  var results = [];
	  var sceneGraph = store.get('sceneGraph');

	  var parentMatch = parentNodeToMatch && getMatch(parentNodeToMatch, queryObj);
	  if (parentMatch) results.push(parentMatch);

	  (0, _ramda.forEach)(function (childId) {
	    var childNode = sceneGraph.nodes[childId];
	    if (!childNode) throw new Error('Invalid child for \'' + node.get('name') + '\' - ' + childId);

	    var match = getMatch(childNode, queryObj);
	    if (match) results.push(match);
	    if (!queryObj.shallow) {
	      results = results.concat(matchChildren(store, childNode, queryObj));
	    }
	  }, node.children || []);

	  return results;
	};

	function findChild(store, node, queryObj, parentNodeToMatch, onlyNode) {
	  var result = void 0;
	  if (parentNodeToMatch) {
	    result = getMatch(parentNodeToMatch, queryObj, onlyNode);
	    if (result) return result;
	  }

	  var sceneGraph = store.get('sceneGraph');
	  var query = (0, _assign2.default)({}, queryObj);
	  if (query.names) {
	    query.name = query.names[0];
	    query.names = query.names.slice(1);
	  }

	  var match = (0, _ramda.find)(function (childId) {
	    var childNode = sceneGraph.nodes[childId];
	    result = getMatch(childNode, query, onlyNode || query.names && query.names.length);
	    if (query.names) {
	      // heirarchical search by name
	      if (!result || !query.names.length) return !!result;
	      result = findChild(store, childNode, query, null, onlyNode);
	      if (result) return true;
	    } else {
	      if (result) return true;
	      result = !query.shallow && findChild(store, childNode, query, null, onlyNode);
	      if (result) return true;
	    }
	  }, node.children || []);
	  return match ? result : null;
	};

/***/ },
/* 173 */
/*!***************************************!*\
  !*** ./src/operators/nonImmutable.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.lookupOperator = lookupOperator;

	var _makeAllOperatorsNonImmutable = __webpack_require__(/*! ./makeAllOperatorsNonImmutable */ 174);

	var _makeAllOperatorsNonImmutable2 = _interopRequireDefault(_makeAllOperatorsNonImmutable);

	var _Annotation = __webpack_require__(/*! ./Annotation */ 180);

	var _Annotation2 = _interopRequireDefault(_Annotation);

	var _BinMesh = __webpack_require__(/*! ./BinMesh */ 181);

	var _BinMesh2 = _interopRequireDefault(_BinMesh);

	var _Camera = __webpack_require__(/*! ./Camera */ 224);

	var _Camera2 = _interopRequireDefault(_Camera);

	var _Environment = __webpack_require__(/*! ./Environment */ 225);

	var _Environment2 = _interopRequireDefault(_Environment);

	var _GeneralRenderer = __webpack_require__(/*! ./GeneralRenderer */ 226);

	var _GeneralRenderer2 = _interopRequireDefault(_GeneralRenderer);

	var _Image = __webpack_require__(/*! ./Image */ 227);

	var _Image2 = _interopRequireDefault(_Image);

	var _Light = __webpack_require__(/*! ./Light */ 230);

	var _Light2 = _interopRequireDefault(_Light);

	var _Material = __webpack_require__(/*! ./Material */ 231);

	var _Material2 = _interopRequireDefault(_Material);

	var _Pass = __webpack_require__(/*! ./Pass */ 232);

	var _Pass2 = _interopRequireDefault(_Pass);

	var _Player = __webpack_require__(/*! ./Player */ 233);

	var _Player2 = _interopRequireDefault(_Player);

	var _PolyMesh = __webpack_require__(/*! ./PolyMesh */ 234);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _Properties = __webpack_require__(/*! ./Properties */ 278);

	var _Properties2 = _interopRequireDefault(_Properties);

	var _Renderer = __webpack_require__(/*! ./Renderer */ 279);

	var _Renderer2 = _interopRequireDefault(_Renderer);

	var _Transform = __webpack_require__(/*! ./Transform */ 280);

	var _Transform2 = _interopRequireDefault(_Transform);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var NoOp = { schema: {} };

	var Bone = { Bone: NoOp };
	var Null = { Null: NoOp };
	var Mixer = { Action: NoOp, Mixer: NoOp };
	_Renderer2.default['vray/create'] = NoOp;
	var Timeline = { Timeline: NoOp };
	var Viewport = { Viewport: NoOp };

	var records = (0, _makeAllOperatorsNonImmutable2.default)({
	  Annotation: _Annotation2.default, BinMesh: _BinMesh2.default, Bone: Bone, Camera: _Camera2.default, Environment: _Environment2.default, GeneralRenderer: _GeneralRenderer2.default, Light: _Light2.default, Material: _Material2.default,
	  Mixer: Mixer, Null: Null, Pass: _Pass2.default, Player: _Player2.default, PolyMesh: _PolyMesh2.default, Properties: _Properties2.default,
	  Renderer: _Renderer2.default, Timeline: Timeline, Transform: _Transform2.default, Image: _Image2.default, Viewport: Viewport
	}, { withNone: true });

	function lookupOperator(plugName, type, warnings) {
	  var plug = records[plugName];
	  if (!plug) {
	    warnings.push('Unknown plug: ' + plugName);
	    return records.None.NoOp;
	  }

	  var operator = plug[type];
	  if (!operator) {
	    warnings.push('Unknown Operator: ' + plugName + ', ' + type);
	    return records.None.NoOp;
	  }

	  return operator;
	}

	exports.default = records;

/***/ },
/* 174 */
/*!*******************************************************!*\
  !*** ./src/operators/makeAllOperatorsNonImmutable.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 101);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.default = makeAllOperators;

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _schemaTypes = __webpack_require__(/*! ./schemaTypes */ 175);

	var _schemaTypes2 = _interopRequireDefault(_schemaTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function makeAllOperators(hierarchy, _ref) {
	  var withNone = _ref.withNone;

	  var records = (0, _ramda.mapObjIndexed)(function (ops, plug) {
	    return (0, _ramda.mapObjIndexed)(function (op, name) {
	      return makeOperator(plug, op, name);
	    }, ops);
	  }, hierarchy);
	  if (withNone) records.None = { NoOp: makeOperator('None', { schema: {} }, 'NoOp') };
	  return records;
	};

	function makeOperator(plug, op, name) {
	  var fileReferenceKeys = [];
	  var referenceKeys = [];
	  var nodeReferenceKeys = [];
	  var nodeReferenceListKeys = [];
	  var plugReferences = {};

	  var props = (0, _ramda.mapObjIndexed)(function (info, key) {
	    var prop = _schemaTypes2.default[info.type] ? (0, _assign2.default)({ type: info.type, schema: info }, _schemaTypes2.default[info.type](info)) : { set: function set(v) {
	        return v;
	      } };

	    if (prop.isFileReference) fileReferenceKeys.push(key);
	    if (prop.isNodeReference) {
	      nodeReferenceKeys.push(key);
	      referenceKeys.push(key);
	    }

	    if (prop.isPlugReference) {
	      plugReferences[key] = prop.isPlugReference;
	      referenceKeys.push(key);
	    }

	    if (prop.isReferenceList) nodeReferenceListKeys.push(key);

	    return prop;
	  }, op.schema);

	  var keys = (0, _keys2.default)(props);

	  return {
	    keys: keys,
	    referenceKeys: referenceKeys,
	    fileReferenceKeys: fileReferenceKeys,
	    nodeReferenceKeys: nodeReferenceKeys,
	    nodeReferenceListKeys: nodeReferenceListKeys,
	    plugReferences: plugReferences,
	    environment: op.environment,

	    getProperties: function getProperties() {
	      return props;
	    },
	    typeOf: function typeOf(key) {
	      return op.schema[key] && op.schema[key].type;
	    },
	    set: function set(data, key, val) {
	      var newVal = props[key] ? props[key].set(val) : val;
	      var isChanged = props[key] && props[key].equals ? !props[key].equals(newVal, data[key]) : newVal !== data[key];
	      if (isChanged) data[key] = props[key] && props[key].get ? props[key].get(newVal) : newVal;
	      return isChanged;
	    },


	    /*
	    equals(data1, data2) {
	      //return (JSON.stringify(data1) === JSON.stringify(data2));
	      let isEqual = true;
	       for(let key in keys){
	        if(data1.hasOwnProperty(key) &&
	          ((data1[key].equals && !data1[key].equals(data2)) ||
	          (data1[key] !== data2[key]))){
	            isEqual = false;
	            break;
	        }
	      }
	      return isEqual;
	    },
	    */

	    export: function _export(data) {
	      // This could be written to remove default keys
	      return (0, _assign2.default)({}, data, {
	        name: name, primitive: plug
	      });
	    },
	    get: function get(data, key) {
	      return props[key] && props[key].get ? props[key].get(data[key]) : data[key];
	    },
	    init: function init(type) {
	      var initAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var name = arguments[2];

	      var result = { type: type, name: name || type };
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = (0, _getIterator3.default)(keys), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value;

	          result[key] = props[key].set(initAttrs[key]); //props.set(result, key, props[key]);
	        }
	        //result._v = 1;
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return result;
	    },
	    update: function update(data, primitive, options) {
	      var newPrimitive = op.update ? op.update.call(op, data, primitive, options) : (0, _assign2.default)(primitive, data);
	      var result = newPrimitive || primitive;

	      if (!result.nodeId) result.nodeId = options.node.id;
	      if (!result.id) result.id = options.node.id;
	      result._v = options.node._v;
	      return result;
	    }
	  };
	}

/***/ },
/* 175 */
/*!**************************************!*\
  !*** ./src/operators/schemaTypes.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 169);

	var _stringify2 = _interopRequireDefault(_stringify);

	var _isInteger = __webpack_require__(/*! babel-runtime/core-js/number/is-integer */ 176);

	var _isInteger2 = _interopRequireDefault(_isInteger);

	var _three = __webpack_require__(/*! three */ 64);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import { FileReference, NodeReference, PlugReference, Vec2, Vec3, Color} from './primitives';

	function initVector3(from) {
	  if (!from) return new _three.Vector3();
	  if (from.isVector3) return from;
	  if (from.hasOwnProperty('x')) return new _three.Vector3(from.x, from.y, from.z);
	  if (Array.isArray(from)) return new _three.Vector3(from[0], from[1], from[2]);
	  return new _three.Vector3();
	};

	function initVector2(from) {
	  if (!from) return new _three.Vector2();
	  if (from.isVector2) return from;
	  if (from.hasOwnProperty('x')) return new _three.Vector2(from.x, from.y);
	  if (Array.isArray(from)) return new _three.Vector2(from[0], from[1]);
	  return new _three.Vector2();
	};

	function initColor(from) {
	  if (!from) return new _three.Color();
	  if (Array.isArray(from)) return new _three.Color(from[0], from[1], from[2]);
	  if (from.hasOwnProperty('r')) return new _three.Color(from.r, from.g, from.b);
	  if ((0, _isInteger2.default)(from)) return new _three.Color(from); //hex value
	  return new _three.Color();
	}

	var schemaTypes = {
	  Boolean: function Boolean(schema) {
	    var defaultValue = schema.defaultValue || false;

	    return {
	      defaultValue: defaultValue,

	      set: function set(val) {
	        return val == null ? defaultValue : !!val;
	      }
	    };
	  },

	  Label: function Label(schema) {
	    return {
	      set: function set(val) {
	        return typeof val === 'string' ? val : '';
	      }
	    };
	  },

	  Number: function (_Number) {
	    function Number(_x) {
	      return _Number.apply(this, arguments);
	    }

	    Number.toString = function () {
	      return _Number.toString();
	    };

	    return Number;
	  }(function (schema) {
	    var min = schema.minValue;
	    var max = schema.maxValue;
	    var defaultValue = schema.defaultValue || 0;

	    var clamp = void 0;

	    if (min !== undefined && max !== undefined) clamp = function clamp(v) {
	      return Math.min(Math.max(min, v), max);
	    };else if (min !== undefined) clamp = function clamp(v) {
	      return Math.max(v, min);
	    };else if (max !== undefined) clamp = function clamp(v) {
	      return Math.min(v, max);
	    };else clamp = function clamp(v) {
	      return v;
	    };

	    return {
	      defaultValue: defaultValue,

	      set: function set(val) {
	        var num = Number(val);
	        if (isNaN(num)) return defaultValue;
	        return Math.round(clamp(num) * 10000) / 10000;
	      }
	    };
	  }),

	  Integer: function Integer(schema) {
	    var min = schema.minValue;
	    var max = schema.maxValue;
	    var defaultValue = schema.defaultValue || 0;

	    var clamp = void 0;

	    if (min !== undefined && max !== undefined) clamp = function clamp(v) {
	      return Math.min(Math.max(min, v), max);
	    };else if (min !== undefined) clamp = function clamp(v) {
	      return Math.max(v, min);
	    };else if (max !== undefined) clamp = function clamp(v) {
	      return Math.min(v, max);
	    };else clamp = function clamp(v) {
	      return v;
	    };

	    return {
	      defaultValue: defaultValue,

	      set: function set(val) {
	        var num = Number(val);
	        if (isNaN(num)) return defaultValue;
	        return Math.round(clamp(num));
	      }
	    };
	  },

	  Plug: function Plug(schema) {
	    if (!schema.plug) throw new Error('plug property expects a `plug` property');

	    return {
	      isPlugReference: schema.plug,

	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id;
	      }
	    };
	  },

	  Options: function Options(schema) {
	    var defaultValue = schema.defaultValue;
	    return {
	      defaultValue: defaultValue,

	      set: function set(val) {
	        return val == null ? defaultValue : val;
	      }
	    };
	  },

	  Image: function Image(schema) {
	    return {
	      isFileReference: true,

	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id; // ? FileReference({id}) : null;
	      }
	    };
	  },

	  Binary: function Binary(schema) {
	    return {
	      isFileReference: true,

	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id; // ? FileReference({id}) : null;
	      }
	    };
	  },

	  File: function File(schema) {
	    return {
	      isFileReference: true,

	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id; // ? FileReference({id}) : null;
	      }
	    };
	  },

	  Object: function Object(schema) {
	    var defaultValue = schema.defaultValue || {};
	    return {
	      set: function set(obj) {
	        return obj || defaultValue;
	      },

	      equals: function equals(val1, val2) {
	        return (0, _stringify2.default)(val1) === (0, _stringify2.default)(val2);
	      }
	    };
	  },

	  String: function String(schema) {
	    var defaultValue = schema.defaultValue || '';

	    return {
	      defaultValue: defaultValue,

	      set: function set(str) {
	        return typeof str === 'string' ? str : defaultValue;
	      }
	    };
	  },

	  Node: function Node(schema) {
	    return {
	      isNodeReference: true,

	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id; // ? NodeReference({id}) : null;
	      }
	    };
	  },

	  NodeList: function NodeList(schema) {
	    return {
	      isReferenceList: true,

	      set: function set(ids) {
	        if (Array.isArray(ids)) {
	          return ids.map(function (id) {
	            return id && id.id ? id.id : id;
	          });
	        }

	        return [];
	      },

	      equals: function equals(val1, val2) {
	        return (0, _stringify2.default)(val1) === (0, _stringify2.default)(val2);
	      }
	    };
	  },

	  Vec2: function Vec2(schema) {
	    var defaultValue = initVector2(schema.defaultValue);

	    return {
	      defaultValue: defaultValue,

	      set: function set(val) {
	        return initVector2(val || defaultValue);
	      },

	      get: function get(val) {
	        return val.clone();
	      },

	      equals: function equals(val1, val2) {
	        return val1.equals(val2);
	      }
	    };
	  },

	  Color: function Color(schema) {
	    var defaultValue = initColor(schema.defaultValue);

	    return {
	      defaultValue: defaultValue,

	      set: function set(val) {
	        return initColor(val || defaultValue);
	      },

	      get: function get(val) {
	        return val.clone();
	      },

	      equals: function equals(val1, val2) {
	        return val1.equals(val2);
	      }
	    };
	  },

	  Vec3: function Vec3(schema) {
	    var defaultValue = initVector3(schema.defaultValue);

	    return {
	      defaultValue: defaultValue,

	      set: function set(val) {
	        return initVector3(val || defaultValue);
	      },

	      get: function get(val) {
	        return val.clone();
	      },

	      equals: function equals(val1, val2) {
	        return val1.equals(val2);
	      }
	    };
	  }
	};

	exports.default = schemaTypes;

/***/ },
/* 176 */
/*!******************************************************!*\
  !*** ./~/babel-runtime/core-js/number/is-integer.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/number/is-integer */ 177), __esModule: true };

/***/ },
/* 177 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/number/is-integer.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.number.is-integer */ 178);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Number.isInteger;

/***/ },
/* 178 */
/*!****************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.number.is-integer.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(/*! ./_export */ 11);

	$export($export.S, 'Number', {isInteger: __webpack_require__(/*! ./_is-integer */ 179)});

/***/ },
/* 179 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_is-integer.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 180 */
/*!*************************************!*\
  !*** ./src/operators/Annotation.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Annotation = {
	  schema: {
	    useText: { type: 'Boolean', label: 'Use Custom Text', defaultValue: false, animatable: false },
	    text: { type: 'String', label: 'Custom Text', defaultValue: 'Annotation Text', animatable: false },
	    open: { type: 'Boolean', label: 'Open by default', defaultValue: false, animatable: false },
	    // Mis-spelled `limitVisibility`
	    limitVisilibility: { type: 'Boolean', label: 'Limit Visibility', defaultValue: false, animatable: false },
	    visibilityAngle: { type: 'Number', label: 'Visibility Angle', defaultValue: 180, step: 5, minValue: 10, maxValue: 360, animatable: false },
	    directionMode: { label: 'Direction Mode', type: 'Options',
	      labels: ['Manual', 'Away From Origin'],
	      values: ['manual', 'awayFromOrigin'],
	      defaultValue: 'manual' },
	    directionAxis: { label: 'Direction', type: 'Options',
	      labels: ['XAxis', 'YAxis', 'ZAxis'],
	      values: ['x', 'y', 'z'],
	      defaultValue: 'z' },
	    directionTarget: { type: 'Node', label: 'Direction Target' }
	  },

	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;

	    (0, _assign2.default)(primitive, operator);
	    if (!operator.useText) primitive.text = node.name;
	  }
	};

	exports.default = { Annotation: Annotation };

/***/ },
/* 181 */
/*!**********************************!*\
  !*** ./src/operators/BinMesh.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _bingeom = __webpack_require__(/*! ../translators/bingeom */ 182);

	var _assets = __webpack_require__(/*! ../modules/assets */ 168);

	var _MeshSmooth = __webpack_require__(/*! ./PolyMesh/MeshSmooth */ 220);

	var _MeshSmooth2 = _interopRequireDefault(_MeshSmooth);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ProxyMesh = {
	  schema: {
	    binary: { type: 'Binary', label: 'Binary Geometry File' },
	    reducedBinary: { type: 'Binary', label: 'Reduced Binary Geometry File' },
	    operatorDisplay: { type: 'Number', defaultValue: 1, label: 'Operator Display Type' },
	    nbLevel: { type: 'Number', defaultValue: 1 }, // 1 -> only binary, 2 -> level0 and binary, 3 -> level0, level1, binary, ....
	    level0: { type: 'Binary', label: 'Binary Geometry File' },
	    level1: { type: 'Binary', label: 'Binary Geometry File' },
	    level2: { type: 'Binary', label: 'Binary Geometry File' },
	    level3: { type: 'Binary', label: 'Binary Geometry File' },
	    level4: { type: 'Binary', label: 'Binary Geometry File' }
	  },

	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node,
	        store = _ref.store,
	        properties = _ref.properties,
	        previousResult = _ref.previousResult,
	        loaded = _ref.loaded;

	    var visible = properties.visible;
	    var binary = operator.binary;
	    var fetch = visible || properties.prefetch && loaded;
	    var bingeom = fetch && binary && store.hasApi() && (0, _assets.getOrFetchBinary)(binary)(store);
	    var mesh = bingeom && (0, _bingeom.convertToCNSPolyMesh)(bingeom, binary);
	    //console.log('Mesh update', 'visible:', visible, 'prefetch:', properties.prefetch, 'fetch:', fetch, 'bingeom:', !!bingeom, node.name, mesh);
	    primitive.mesh = mesh;
	    primitive.previousMesh = previousResult && previousResult.mesh;
	  }
	};

	var Instance = {
	  schema: {
	    geometry: { label: 'Mesh', plug: 'BinMesh', type: 'Plug' }
	  },

	  update: function update(operator, primitive) {
	    primitive.mesh = operator.geometry && operator.geometry.mesh;
	  }
	};

	exports.default = { ProxyMesh: ProxyMesh, MeshSmooth: _MeshSmooth2.default, Instance: Instance };

/***/ },
/* 182 */
/*!************************************!*\
  !*** ./src/translators/bingeom.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 169);

	var _stringify2 = _interopRequireDefault(_stringify);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	exports.validatePolymeshData = validatePolymeshData;
	exports.checkGeometryCache = checkGeometryCache;
	exports.cacheGeometry = cacheGeometry;
	exports.convertToPolyMesh = convertToPolyMesh;
	exports.convertToBingeom = convertToBingeom;
	exports.convertToCNSPolyMesh = convertToCNSPolyMesh;

	var _polyMesh = __webpack_require__(/*! ../polyMesh */ 183);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function validateAndRetype(data) {
	  if (data instanceof Uint32Array) return data;else if (data instanceof ArrayBuffer) return new Uint32Array(data);else if (typeof Buffer !== 'undefined' && data instanceof Buffer) {
	    return new Uint32Array(new Uint8Array(data).buffer);
	  }

	  throw new Error('Invalid bingeom type: ' + (typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)));
	};

	function extractFooter(data) {
	  var jsonLength = data[data.length - 2];
	  if (!jsonLength) throw new Error('No footer in bingeom');
	  var charData = new Uint8Array(data.buffer);
	  var len = charData.byteLength - 8;
	  charData = charData.subarray(len - jsonLength, len);
	  return JSON.parse(String.fromCharCode.apply(null, charData));
	}

	function validateDataInfo(dataInfo) {
	  return dataInfo !== undefined && typeof dataInfo.o === 'number' && typeof dataInfo.l === 'number';
	}

	function validatePolymeshData(jsonData) {
	  return jsonData && validateDataInfo(jsonData.faceCount) && validateDataInfo(jsonData.faces) && validateDataInfo(jsonData.positions);
	}

	function assert(truthy, message) {
	  if (!truthy) throw new Error(message);
	}

	var RawUintByteSize = { 1: 'RawUint8', 2: 'RawUint16', 4: 'RawUint32' };

	var types = {
	  RawUint8: { shift: 0, arr: Uint8Array },
	  RawUint16: { shift: 1, arr: Uint16Array },
	  RawUint32: { shift: 2, arr: Uint32Array },
	  RawFloat32: { shift: 2, arr: Float32Array }
	};

	function readArray(buffer, jsonData) {
	  var dataType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  if (!jsonData) return dataType ? new types[dataType].arr(0) : [];
	  var typeinfo = types[dataType || RawUintByteSize[jsonData.b || 4]];
	  return new typeinfo.arr(buffer, jsonData.o, jsonData.l >> typeinfo.shift);
	}

	function noTriangulation(faces, faceSize) {
	  return faces;
	}

	function staticTriangulation(faces, faceSize) {
	  if (faces.length % faceSize !== 0) throw new Error('Invalid face index array');
	  var trianglePerFace = faceSize - 2;
	  var nbFaces = 3 * (faces.length * trianglePerFace) / faceSize; // number of triangulated faces

	  var newFaces = new faces.constructor(nbFaces);
	  for (var inn = 0, out = 0, il = faces.length; out < il;) {
	    var first = faces[out++];
	    var second = faces[out++];
	    for (var j = trianglePerFace; j > 0; --j) {
	      newFaces[inn++] = first;
	      newFaces[inn++] = second;
	      second = faces[out++];
	      newFaces[inn++] = second;
	    }
	  }

	  return newFaces;
	};

	function dynamicTriangulation(faces, faceCount) {
	  var fl = faceCount.length;
	  var nbFaces = -(fl << 1); // starts at -2*fl because the number of triangle in on face 'x' is faceCount[x]-2
	  for (var i = fl - 1; i >= 0; --i) {
	    nbFaces += faceCount[i];
	  }var newFaces = new faces.constructor(nbFaces * 3); // can reuse the same constructor as faces because the max index is the same
	  for (var inn = 0, out = 0, f = 0, _fl = faceCount.length; f < _fl; ++f) {
	    var first = faces[out++];
	    var second = faces[out++];
	    for (var j = faceCount[f] - 2; j > 0; --j) {
	      newFaces[inn++] = first;
	      newFaces[inn++] = second;
	      second = faces[out++];
	      newFaces[inn++] = second;
	    }
	  }

	  return newFaces;
	};

	var geometryCache = {};

	function checkGeometryCache(hash) {
	  return geometryCache[hash];
	}

	/*
	 * cache geometry by file hash. This might break when we start adding
	 * on operators, so verify that.
	 */
	function cacheGeometry(hash, geometry) {
	  geometryCache[hash] = geometry;
	  return geometry;
	}

	function convertToPolyMesh(data) {
	  var binaryData = validateAndRetype(data);
	  var jsonData = extractFooter(binaryData);
	  //console.log('extracted footer: ', jsonData);
	  var buffer = binaryData.buffer;
	  assert(validatePolymeshData(jsonData), 'Invalid Polymesh Data?');

	  var positions = readArray(buffer, jsonData.positions, 'RawFloat32');
	  var fc = readArray(buffer, jsonData.faceCount);
	  var faceCount = fc;
	  if (fc.length === 1) faceCount = fc[0];
	  var triangulationFunction = fc.length === 1 ? fc[0] !== 3 ? staticTriangulation : noTriangulation : dynamicTriangulation;
	  var faces = triangulationFunction(readArray(buffer, jsonData.faces), faceCount);

	  // normalMap
	  var normalMap = jsonData.normalMap && {
	    faces: triangulationFunction(readArray(buffer, jsonData.normalMap.faces), faceCount),
	    values: readArray(buffer, jsonData.normalMap.values, 'RawFloat32')
	  };

	  var uvs = null;

	  // uvMaps
	  if (jsonData.uvMaps && (0, _keys2.default)(jsonData.uvMaps).length) {
	    uvs = {};
	    for (var attr in jsonData.uvMaps) {
	      if (jsonData.uvMaps.hasOwnProperty(attr)) {
	        var map = jsonData.uvMaps[attr];
	        // TODO for vray?: if (options.uvsToVec3Array) throw new Error('vec3ForUvs');

	        uvs[attr] = {
	          faces: triangulationFunction(readArray(buffer, map.faces), faceCount),
	          values: readArray(buffer, map.values, 'RawFloat32')
	        };
	      }
	    }
	  }

	  // // extra data
	  // if (tmp = jsonData.materialIds) {//this.materialIds = reader.readArray(tmp, "RawUint32");
	  //   let rawMtl = reader.readArray(tmp, "RawUint32");
	  //   if (triangulationFunction !== noTriangulation) {  // noTriangulation, material id already correct!
	  //     let nbTriangulatedFaces = this.faces.length / 3;    // already know the right size of the material ids array
	  //
	  //     let materialTriangulationFunction = (triangulationFunction === staticTriangulation) ? staticMaterialTriangulation : dynamicMaterialTriangulation;
	  //     rawMtl = materialTriangulationFunction(rawMtl, faceCount, nbTriangulatedFaces);
	  //   }
	  //   this.materialIds = rawMtl;
	  // }
	  // return this;
	  return { positions: positions, faces: faces, normalMap: normalMap, uvs: uvs };
	}

	var BIN_VERSION = 1000;
	//Things to change when we eventually upgrade the format
	// - remove all references to poseBoneToWorldTransform
	// - materialIds should be a Uint8Array or at least a Uint16Array
	// - materialIds could also be deprecated in favor of material ranges


	/*
	 * Convert PolyMesh to bingeom
	 */
	function convertToBingeom(polyMesh) {
	  //{ positions, faces, normalMap, uvs }) {
	  var jsonFooter = { blendShapes: {}, colorMaps: {} }; //, uvMaps: { 'default': {}} };
	  var byteLength = 0;
	  var buffers = [];
	  var bufferFooters = [];

	  function extract(key, typedArray, footer, readInto) {
	    var sourceBuf = readInto ? new readInto(typedArray).buffer : typedArray.buffer;
	    var buf = new Uint8Array(sourceBuf, 0, typedArray.byteLength);

	    // pad buffer if necessary to maintain 4-byte alignment
	    var overBytes = buf.byteLength % 4;
	    var padBytes = 0;
	    if (overBytes) {
	      padBytes = 4 - overBytes;
	      var paddedBuf = new Uint8Array(buf.byteLength + padBytes);
	      paddedBuf.set(buf);
	      buf = paddedBuf;
	    }

	    var reuseFooter = null;
	    for (var i = 0; i < buffers.length; i++) {
	      if (equalsArrayBuffers(buf, buffers[i])) {
	        reuseFooter = bufferFooters[i];
	        break;
	      }
	    }

	    if (reuseFooter !== null) {
	      footer[key] = reuseFooter;
	    } else {
	      var bytesPerElement = readInto ? readInto.BYTES_PER_ELEMENT : typedArray.BYTES_PER_ELEMENT;
	      footer[key] = { b: bytesPerElement, l: buf.byteLength - padBytes, o: byteLength };
	      byteLength += buf.byteLength;
	      buffers.push(buf);
	      bufferFooters.push(footer[key]);
	    }
	    //console.log( "extract: key", key, "result", footer[key], (reuseFooter !== null ) ? 'deduped' : '');
	  }

	  function equalsArrayBuffers(a, b) {
	    // a and b must be Uint8Arrays.

	    if (a.length !== b.length) {
	      return false;
	    }

	    for (var i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) {
	        return false;
	      }
	    }

	    return true;
	  };

	  function offsetsSum(offsets) {
	    var arr = new Uint32Array(offsets.length - 1);
	    for (var i = 0; i < offsets.length - 1; i++) {
	      arr[i] = offsets[i + 1] - offsets[i];
	    }

	    return arr;
	  }

	  extract('faces', polyMesh.positions.faceValueIndices, jsonFooter);
	  extract('faceCount', offsetsSum(polyMesh.faceRangeOffsets), jsonFooter);
	  extract('positions', polyMesh.positions.values.data, jsonFooter, Float32Array);

	  if (polyMesh.normalMap) {
	    jsonFooter.normalMap = {};
	    extract('faces', polyMesh.normalMap.faceValueIndices, jsonFooter.normalMap);
	    extract('values', polyMesh.normalMap.values.data, jsonFooter.normalMap, Float32Array);
	  }

	  if (polyMesh.uvMaps && polyMesh.uvMaps.length) {
	    jsonFooter.uvMaps = {};
	    polyMesh.uvMaps.namesByIndex.forEach(function (uvName) {
	      var uvMap = polyMesh.uvMaps.byName[uvName];
	      jsonFooter.uvMaps[uvName] = {};
	      extract('faces', uvMap.faceValueIndices, jsonFooter.uvMaps[uvName]);
	      extract('values', uvMap.values.data, jsonFooter.uvMaps[uvName], Float32Array);
	    });
	  }

	  if (polyMesh.edgeCreaseWeights && polyMesh.edgeCreaseWeights.length) {
	    extract('edgeCreaseWeights', polyMesh.edgeCreaseWeights, jsonFooter, Float32Array); // don't need to convert, already Float32Array...?
	  }

	  if (polyMesh.skinning) {
	    jsonFooter.skinning = {};
	    extract('positionSkinRange', polyMesh.skinning.positionSkinRange, jsonFooter.skinning);
	    extract('skinWeights', polyMesh.skinning.skinWeights, jsonFooter.skinning);
	    extract('poseSkinToPoseBoneTransform', polyMesh.skinning.poseSkinToPoseBoneTransform.data, jsonFooter.skinning, Float32Array);
	    extract('skinBoneIndices', polyMesh.skinning.skinBoneIndices, jsonFooter.skinning);
	  }

	  var jsonFooterString = (0, _stringify2.default)(jsonFooter);
	  jsonFooterString += { 0: '', 1: '   ', 2: '  ', 3: ' ' }[jsonFooterString.length % 4];

	  var currentByte = 0;
	  var result = new Uint8Array(byteLength + jsonFooterString.length + 8);
	  for (var i = 0; i < buffers.length; i++) {
	    result.set(buffers[i], currentByte);
	    currentByte += buffers[i].byteLength;
	  }

	  for (var _i = 0; _i < jsonFooterString.length; _i++) {
	    result[currentByte++] = jsonFooterString.charCodeAt(_i);
	  }

	  var currentDWord = currentByte >> 2;
	  var newBytes32 = new Uint32Array(result.buffer);
	  newBytes32[currentDWord] = jsonFooterString.length;
	  newBytes32[currentDWord + 1] = BIN_VERSION;
	  return new Uint32Array(result.buffer);
	}

	var polyMeshCaches = {};

	function convertToCNSPolyMesh(data, refId) {
	  if (refId && polyMeshCaches[refId]) return polyMeshCaches[refId];

	  var binaryData = validateAndRetype(data);
	  var jsonData = extractFooter(binaryData);
	  var buffer = binaryData.buffer;

	  if (jsonData && !jsonData.faceCount && !jsonData.faces && !jsonData.positions) {
	    console.warn('Warning: PolyMesh is empty.');
	    return new _polyMesh.PolyMesh();
	  }

	  assert(validatePolymeshData(jsonData), 'Invalid Polymesh Data?');

	  var fc = readArray(buffer, jsonData.faceCount);
	  //console.log( 'CNS', CNS );
	  var importer = new _polyMesh.Importer();
	  //console.log( 'importer', importer );
	  if (fc.length === 1) {
	    importer.defaultFaceArity = fc[0];
	  } else {
	    importer.setFaceArities(fc);
	  }

	  importer.collapsePositions = false;
	  importer.collapseMapValues = false;

	  var positionFaceIndices = readArray(buffer, jsonData.faces);
	  var positionValues = readArray(buffer, jsonData.positions, 'RawFloat32');

	  var positionsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypePosition);

	  importer.setMapIndices(positionsId, positionFaceIndices);
	  importer.setMapValues(positionsId, positionValues);

	  // normalMap
	  if (jsonData.normalMap) {

	    var normalFaceIndices = readArray(buffer, jsonData.normalMap.faces);
	    var normalValues = readArray(buffer, jsonData.normalMap.values, 'RawFloat32');

	    var normalsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypeNormal);

	    importer.setMapIndices(normalsId, normalFaceIndices);
	    importer.setMapValues(normalsId, normalValues);
	  }

	  // uvMaps
	  if (jsonData.uvMaps && (0, _keys2.default)(jsonData.uvMaps).length) {
	    for (var attr in jsonData.uvMaps) {
	      if (jsonData.uvMaps.hasOwnProperty(attr)) {
	        var map = jsonData.uvMaps[attr];

	        var uvFaceIndices = readArray(buffer, map.faces);
	        var uvValues = readArray(buffer, map.values, 'RawFloat32');

	        var uvsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypeUV, attr);

	        importer.setMapIndices(uvsId, uvFaceIndices);
	        importer.setMapValues(uvsId, uvValues);
	      }
	    }
	  }

	  // skinning
	  if (jsonData.skinning) {

	    importer.setSkinning(readArray(buffer, jsonData.skinning.positionSkinRange, 'RawUint32'), readArray(buffer, jsonData.skinning.skinWeights, 'RawFloat32'), readArray(buffer, jsonData.skinning.skinBoneIndices, 'RawUint16'), readArray(buffer, jsonData.skinning.poseSkinToPoseBoneTransform, 'RawFloat32'));
	  }

	  // edge creases
	  // Can come in 2 forms:
	  //  1) 'creases': Imported from fbx. Contains an edge crease weights array and an array of
	  //                vertex index pairs for the corresponding creased edges
	  //  2) 'edgeCreaseWeights': A single array of weights, where the edge is implied by the index, which
	  //                corresponds to the V2 polyMesh edge index. This form is preferred.
	  if (jsonData.edgeCreaseWeights) importer.setCreases(readArray(buffer, jsonData.edgeCreaseWeights, 'RawFloat32'));else if (jsonData.creases) {
	    var weights = readArray(buffer, jsonData.creases.weights, 'RawFloat32');
	    var edges = readArray(buffer, jsonData.creases.edgeVertexIndices, 'RawUint32');
	    importer.setCreases(weights, edges);
	  }

	  if (jsonData.materialIds) {
	    importer.setMaterialIds(readArray(buffer, jsonData.materialIds, 'RawUint32'));
	  }

	  // TODO: add support for UVs.
	  // TODO: add support for Colors.
	  // TODO: add support for MaterialIDs.

	  var polyMesh = importer.toMeshAndClear();
	  //console.log('bingeom jsonDate ', jsonData);
	  //console.log('bingeom.js convertToCNSPolyMesh ', polyMesh );

	  if (refId) polyMeshCaches[refId] = polyMesh;
	  return polyMesh;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 183 */
/*!*******************************!*\
  !*** ./src/polyMesh/index.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ThreeExport = exports.Selection = exports.PolyMesh = exports.PolyMaps = exports.PolyMap = exports.Importer = undefined;

	__webpack_require__(/*! ./three/ThreeInstanceScalarSize */ 184);

	__webpack_require__(/*! ./generic/utility/polyfill */ 185);

	var _Importer = __webpack_require__(/*! ./geometric/tool/Importer */ 186);

	var _Importer2 = _interopRequireDefault(_Importer);

	var _PolyMesh = __webpack_require__(/*! ./geometric/model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ./geometric/model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _PolyMaps = __webpack_require__(/*! ./geometric/model/PolyMaps */ 201);

	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

	var _Selection = __webpack_require__(/*! ./geometric/transient/Selection */ 215);

	var _Selection2 = _interopRequireDefault(_Selection);

	var _ThreeExport = __webpack_require__(/*! ./three/ThreeExport */ 216);

	var _ThreeExport2 = _interopRequireDefault(_ThreeExport);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Importer = _Importer2.default;
	exports.PolyMap = _PolyMap2.default;
	exports.PolyMaps = _PolyMaps2.default;
	exports.PolyMesh = _PolyMesh2.default;
	exports.Selection = _Selection2.default;
	exports.ThreeExport = _ThreeExport2.default;

/***/ },
/* 184 */
/*!*******************************************************!*\
  !*** ./src/polyMesh/three/ThreeInstanceScalarSize.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	THREE.Vector2.InstanceScalarSize = 2;
	THREE.Vector3.InstanceScalarSize = 3;
	THREE.Vector4.InstanceScalarSize = 4;

	THREE.Color.InstanceScalarSize = 3;
	THREE.Quaternion.InstanceScalarSize = 4;

	THREE.Matrix3.InstanceScalarSize = 9;
	THREE.Matrix4.InstanceScalarSize = 16;

/***/ },
/* 185 */
/*!**************************************************!*\
  !*** ./src/polyMesh/generic/utility/polyfill.js ***!
  \**************************************************/
/***/ function(module, exports) {

	'use strict';

	[Uint32Array, Int32Array, Uint8Array, Int8Array].forEach(function (cls) {
	  if (!cls.prototype.fill) {
	    Object.defineProperty(cls.prototype, 'fill', { value: function value(_value, start, end) {
	        start = start || 0;
	        end = end || this.length;
	        for (var i = start; i < end; i++) {
	          this[i] = _value;
	        }

	        return this;
	      } });
	  }

	  if (!cls.prototype.slice) {
	    Object.defineProperty(cls.prototype, 'slice', { value: function value(start, end) {
	        var i = start === undefined ? 0 : start;
	        var finalIdx = end === undefined ? this.length : end;
	        var count = finalIdx - i;
	        var a = new this.constructor(count);
	        var n = 0;
	        while (i < finalIdx) {
	          a[n] = this[i];
	          ++n;
	          ++i;
	        }

	        return a;
	      } });
	  }

	  if (!cls.prototype.sort) {
	    // https://github.com/inexorabletash/polyfill/blob/master/es6.js
	    Object.defineProperty(cls.prototype, 'sort', { value: function sort(comparefn) {
	        function sortCompare(x, y) {
	          // console.assert(Type(x) === 'number' && Type(y) === 'number');
	          if (x !== x && y !== y) return +0;
	          if (x !== x) return 1;
	          if (y !== y) return -1;
	          if (comparefn !== undefined) {
	            return comparefn(x, y);
	          }
	          if (x < y) return -1;
	          if (x > y) return 1;
	          return +0;
	        }
	        return Array.prototype.sort.call(this, sortCompare);
	      } });
	  }
	});

/***/ },
/* 186 */
/*!*************************************************!*\
  !*** ./src/polyMesh/geometric/tool/Importer.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Importer;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ScalarArrayView = __webpack_require__(/*! ../../generic/container/ScalarArrayView */ 199);

	var _ScalarArrayView2 = _interopRequireDefault(_ScalarArrayView);

	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	var _PolyMaps = __webpack_require__(/*! ../model/PolyMaps */ 201);

	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _Skinning = __webpack_require__(/*! ../model/Skinning */ 211);

	var _Skinning2 = _interopRequireDefault(_Skinning);

	var _ImportConversions = __webpack_require__(/*! ../algorithm/ImportConversions */ 212);

	var _ImportConversions2 = _interopRequireDefault(_ImportConversions);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Importer() {

	  this.defaultFaceArity = 3; // triangles
	  this.collapsePositions = true; // re-index positions
	  this.collapseMapValues = true; // join equal map values at the same vertex

	  this.faceArities = null;
	  this.materialIds = null;

	  this.mapIds = [];
	  this.mapValues = {};
	  this.mapIndices = {};

	  this.skinning = null;
	  this.creases = null;
	};

	Importer.prototype = {

	  constructor: Importer,

	  setFaceArities: function setFaceArities(array, optionalNumberOfElements, optionalOffset, optionalStride) {

	    this.faceArities = new _ScalarArrayView2.default(optionalNumberOfElements || null, array, optionalOffset, optionalStride);

	    return this;
	  },

	  setMaterialIds: function setMaterialIds(materialIds) {
	    for (var i = 0; i < materialIds.length; i++) {
	      //only add to the polymesh if array contains a non zero value
	      if (materialIds[i] > 0) {
	        this.materialIds = materialIds;
	        break;
	      }
	    }

	    return this;
	  },

	  setMapValues: function setMapValues(mapId, array, optionalNumberOfElements, optionalOffset, optionalStride) {

	    var id = _PolyMaps2.default.checkId(mapId);
	    var ids = this.mapIds;

	    if (ids.indexOf(id) === -1) ids.push(id);

	    this.mapValues[id] = new _ObjectArrayView2.default(_PolyMaps2.default.getTypeInfo(_PolyMaps2.default.getAnchorName(mapId)).ElementType, optionalNumberOfElements || null, !optionalOffset ? array : array.subarray(optionalOffset), optionalStride);

	    return this;
	  },

	  setMapIndices: function setMapIndices(mapId, array, optionalNumberOfElements, optionalOffset, optionalStride) {

	    this.mapIndices[_PolyMaps2.default.checkId(mapId)] = new _ScalarArrayView2.default(optionalNumberOfElements || null, array, optionalOffset, optionalStride);

	    return this;
	  },

	  setSkinning: function setSkinning(positionSkinRange, skinWeights, skinBoneIndices, poseSkinToPoseBoneTransform) {
	    this.skinning = {};

	    this.skinning.positionSkinRange = positionSkinRange;
	    this.skinning.skinWeights = skinWeights;
	    this.skinning.skinBoneIndices = skinBoneIndices;

	    this.skinning.poseSkinToPoseBoneTransform = new _ObjectArrayView2.default(THREE.Matrix4, null, poseSkinToPoseBoneTransform);

	    return this;
	  },

	  setCreases: function setCreases(weights, edges) {
	    this.creases = { weights: weights, edges: edges };
	  },

	  toMeshAndClear: function toMeshAndClear() {

	    var mapIds = this.mapIds;
	    var mapValueData = this.mapValues;
	    var mapIndexData = this.mapIndices;

	    var positionMapId = _PolyMaps2.default.IdPositions;
	    var positions = mapValueData[positionMapId];

	    var faceArities = this.faceArities;
	    var materialIds = this.materialIds;

	    if (!positions) throw Error('No positions!');

	    var positionIndices = mapIndexData[positionMapId] || null;

	    var nFaceVertices = positionIndices ? positionIndices.length : positions.length;

	    var faceOffsets = null;
	    //  -----------

	    if (faceArities === null) {
	      var fixedArity = this.defaultFaceArity;
	      var nFaces = nFaceVertices / fixedArity | 0;

	      faceArities = new Uint32Array(nFaces + 1).fill(fixedArity, 1);
	    } else {
	      faceArities = faceArities.toArray(Uint32Array, 1);
	    }

	    // Here faceOffsets contains the face arities after a zero at index 0,
	    // their accumulation yields the offsets (including length sentinel):
	    faceOffsets = _Arrays2.default.accumulate(faceArities); // (in-place)

	    for (var i = 0; i !== mapIds.length; ++i) {
	      // avoid aliasing with the map indices in case it's the same array

	      var mapId = mapIds[i];
	      if (mapId === positionMapId) continue;

	      var mapIndexView = mapIndexData[mapId];

	      if (mapIndexView !== undefined) mapIndexView.forceRepack(Uint32Array);
	    }

	    var indices = null;
	    if (this.collapsePositions) {
	      // re-index values
	      if (positionIndices !== null) indices = positionIndices.repack(Uint32Array).data;

	      positions = _ImportConversions2.default.collapsePositions(positions, indices);
	    } else if (positionIndices !== null) {
	      // use given indices as-is
	      indices = positionIndices.repack(Uint32Array).data;
	    }

	    var mesh = _PolyMesh2.default.fromData(faceOffsets, positions, indices, materialIds);

	    for (var _i = 0; _i !== mapIds.length; ++_i) {

	      var _mapId = mapIds[_i];
	      if (_mapId === positionMapId) continue;

	      var _mapIndexView = mapIndexData[_mapId];
	      var mapValueView = mapValueData[_mapId];

	      var polyMap = _PolyMap2.default.fromData(faceOffsets, _mapIndexView.data, mapValueView);

	      if (this.collapseMapValues) {

	        _ImportConversions2.default.collapseMapVertexValues(mesh, polyMap);

	        polyMap.compactValues();
	      }

	      _PolyMaps2.default.assignMap(mesh, _mapId, polyMap);
	    }

	    if (this.skinning) mesh.skinning = new _Skinning2.default(this.skinning);

	    if (this.creases) {
	      var _creases = this.creases,
	          weights = _creases.weights,
	          edges = _creases.edges;
	      // if edges array exists, need to calculate edge indices from the vertex pairs

	      if (edges) {
	        // generate edge indices from vertex pairs
	        var edgeVertexAdjacency = mesh.positions.edgeVertexAdjacency;
	        var edgeWeights = new Float32Array(edgeVertexAdjacency.getNumEdges());
	        for (var _i2 = 0, e = 0; _i2 < edges.length; _i2 += 2, e++) {
	          edgeWeights[edgeVertexAdjacency.findEdgeId(edges[_i2], edges[_i2 + 1])] = weights[e];
	        }

	        mesh.edgeCreaseWeights = edgeWeights;
	      } else mesh.edgeCreaseWeights = weights; // no edges array, assume weight index = edge index
	    }

	    Importer.call(this); // re-run constructor to clear state

	    return mesh;
	  }

	};

/***/ },
/* 187 */
/*!***********************************************************!*\
  !*** ./src/polyMesh/generic/container/ObjectArrayView.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 188);

	var _create2 = _interopRequireDefault(_create);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.default = ObjectArrayView;

	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	var _FlatArrayView = __webpack_require__(/*! ./FlatArrayView */ 196);

	var _FlatArrayView2 = _interopRequireDefault(_FlatArrayView);

	var _ObjectBuffer = __webpack_require__(/*! ./ObjectBuffer */ 197);

	var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Object view mapping fixed size objects to flat arrays.
	 *
	 * @constructor
	 *
	 * @param {!function(new:*)} type
	 *
	 *    object constructor
	 *
	 * @param {number} length
	 *
	 *    number of objects to map,
	 *    can be null when an existing array is given,
	 *
	 * @param {ArrayOrType=} optionalArrayOrType
	 *
	 *    existing array or array constructor, default is Float32Array
	 *
	 * @param {number=} optionalStride
	 *
	 *    an explicit stride for cases where it differs from the element size
	 *    deduced from {@code type.InstanceScalarSize}
	 */
	function ObjectArrayView(type, length, optionalArrayOrType, optionalStride) {

	  var elementSize = type.InstanceScalarSize || optionalStride;
	  var stride = optionalStride || elementSize;
	  var arrayLength = length !== null ? length * stride : null;

	  if (elementSize === undefined || stride === undefined) throw Error("Can't determine element size / stride!");

	  var existingArrayOrType = optionalArrayOrType || Float32Array;

	  var array = _Arrays2.default.maybeCreate(existingArrayOrType, arrayLength);

	  _FlatArrayView2.default.call(this, array, length ||
	  // Note: Integer division by 'stride', rounding towards infinity
	  // at a minimum remainder of 'elementSize':
	  (array.length + stride - elementSize) / stride | 0);

	  this.type = type;
	  this.stride = stride;
	  this.elementSize = elementSize;
	  this.tempBuffer = new Float32Array(elementSize);
	};

	ObjectArrayView.prototype = (0, _assign2.default)((0, _create2.default)(_FlatArrayView2.default.prototype), {

	  constructor: ObjectArrayView,

	  getAt: function getAt(index, optionalValue) {

	    var result = optionalValue || new this.type();
	    return result.fromArray(this.data, index * this.stride);
	  },

	  setAt: function setAt(index, value) {

	    value.toArray(this.data, index * this.stride);
	  },

	  addAt: function addAt(index, value) {

	    value.toArray(this.tempBuffer, 0);
	    for (var i = 0, offset = index * this.stride; i < this.elementSize; i++) {
	      this.data[offset + i] += this.tempBuffer[i];
	    }
	  },

	  multiplyScalarAt: function multiplyScalarAt(index, scalar) {

	    for (var i = 0, offset = index * this.stride; i < this.elementSize; i++) {
	      this.data[offset + i] *= scalar;
	    }
	  },

	  newCompatibleView: function newCompatibleView(arrayOrType, optionalLength) {

	    return new ObjectArrayView(this.type, optionalLength || null, arrayOrType, this.stride);
	  },

	  newCompatibleBuffer: function newCompatibleBuffer() {

	    return new _ObjectBuffer2.default(this.type, this.data.constructor, this.stride);
	  }

	});

	ObjectArrayView.fromObjects = function (type, objects, optionalArrayType) {

	  var result = new ObjectArrayView(type, objects.length, optionalArrayType);

	  _Arrays2.default.copyObjects(objects, result.data);
	  return result;
	};

/***/ },
/* 188 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/object/create.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/create */ 189), __esModule: true };

/***/ },
/* 189 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/create.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.create */ 190);
	var $Object = __webpack_require__(/*! ../../modules/_core */ 13).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 190 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.create.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 11)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(/*! ./_object-create */ 30)});

/***/ },
/* 191 */
/*!************************************************!*\
  !*** ./src/polyMesh/generic/utility/Arrays.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _freeze = __webpack_require__(/*! babel-runtime/core-js/object/freeze */ 192);

	var _freeze2 = _interopRequireDefault(_freeze);

	var _Orders = __webpack_require__(/*! ./Orders */ 195);

	var _Orders2 = _interopRequireDefault(_Orders);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @typedef {(function(new:Array)|Array)} ArrayOrType
	 */

	/**
	 * Various utilities for working with arrays.
	 *
	 * @namespace
	 */
	var Arrays = {

	  /**
	   * Empty arrays.
	   *
	   * @namespace
	   */
	  Empty: (0, _freeze2.default)({

	    /** @const @type {!Array} */
	    Array: (0, _freeze2.default)(new Array(0)),

	    // Note: Typed arrays can't - and don't have to frozen, since
	    // they have an immutable length.

	    /** @const @type {!Array<!number>} */
	    Float64Array: new Float64Array(0),
	    /** @const @type {!Array<!number>} */
	    Float32Array: new Float32Array(0),
	    /** @const @type {!Array<!number>} */
	    Uint32Array: new Uint32Array(0),
	    /** @const @type {!Array<!number>} */
	    Int32Array: new Int32Array(0)

	  }),

	  //

	  rangeCopy: function rangeCopy(src, srcOffset, dst, dstOffset, length) {

	    for (var i = 0; i !== length; ++i) {
	      dst[dstOffset + i] = src[srcOffset + i];
	    }return dst;
	  },

	  rangeEquals: function rangeEquals(a, aStart, b, bStart, length) {

	    for (var i = 0; i !== length; ++i) {
	      if (a[aStart + i] !== b[bStart + i]) return false;
	    }return true;
	  },

	  stridedCopy: function stridedCopy(src, srcOffset, srcStride, dst, dstOffset, dstStride, elementLength, numElements) {

	    for (var i = 0; i !== numElements; ++i) {
	      for (var j = 0; j !== elementLength; ++j) {

	        dst[dstOffset + i * dstStride + j] = src[srcOffset + i * srcStride + j];
	      }
	    }return dst;
	  },

	  /**
	   * For each element add the previous element.
	   *
	   * @param {!Array<!number>} array
	   */
	  accumulate: function accumulate(array) {

	    for (var i = 1, n = array.length; i < n; ++i) {
	      array[i] += array[i - 1];
	    }return array;
	  },

	  slice: function slice(array, from, optionalTo) {

	    // Not all browsers have .slice for typed arrays...

	    return array.slice !== undefined ? array.slice(from, optionalTo) : new array.constructor(array.subarray(from, optionalTo));
	  },

	  clone: function clone(array) {

	    // Not all browsers have .slice for typed arrays...

	    return array !== null ? array.slice !== undefined ? array.slice(0) : new array.constructor(array) : null;
	  },

	  binarySearch: function binarySearch(array, elem, optionalBegin, optionalUntil) {

	    var left = optionalBegin === undefined ? 0 : optionalBegin,
	        right = optionalUntil === undefined ? array.length - left : optionalUntil,
	        rightBound = right;

	    while (left < right) {

	      var mid = left + right >>> 1,
	          midVal = array[mid];

	      if (midVal < elem) left = mid + 1;else right = mid;
	    }

	    return left < rightBound && array[left] === elem ? left : ~left;
	  },

	  sort: function sort(array, optionalOrder) {

	    // TODO: Optimized sorting - a likely and improvable bottleneck:
	    //
	    // - A customized sort beats Chrome by a factor of 18 at block
	    //   sizes of 10.000 elements, where the performance is roughly
	    //   equal for a few elements. At this scale Chrome is already
	    //   3-4 times slower than Firefox - the more elements there are
	    //   the worse it gets.
	    //
	    // - The same routine beats Firefox by a factor of 5 with small
	    //   block sizes, where the performance becomes roughly equal at
	    //   10.000 elements.
	    //
	    // My test code did not contain duplicate elements (and does not
	    // handle them well, in the moment) and used a Quicksort with a
	    // median index pivot (which is rather lousy). It did implement
	    // a decent partitioner based on Hoare's algorithm, though.

	    if (array.sort !== undefined) {

	      return array.sort(optionalOrder || _Orders2.default.Numeric);
	    } else {
	      // some browsers may not yet support the above

	      return Array.prototype.sort.call(array, optionalOrder || _Orders2.default.Numeric);
	    }

	    return array;
	  },

	  unique: function unique(sortedArray, optionalOrder) {

	    var n = sortedArray.length;

	    if (n <= 1) return sortedArray.length;

	    var writeIndex = 0,
	        prevValue = sortedArray[0];

	    if (optionalOrder === undefined) {

	      for (var i = 1; i !== n; ++i) {

	        var value = sortedArray[i];
	        if (value !== prevValue) {

	          prevValue = value;

	          if (++writeIndex !== i) sortedArray[writeIndex] = value;
	        }
	      }
	    } else {

	      var compare = optionalOrder;

	      if (!optionallyBuiltMap) {

	        for (var _i = 1; _i !== n; ++_i) {

	          var _value = sortedArray[_i];
	          if (compare(_value, prevValue) !== 0) {

	            prevValue = _value;

	            if (++writeIndex !== _i) sortedArray[writeIndex] = _value;
	          }
	        }
	      }
	    }

	    return writeIndex + 1; // new length
	  },

	  //

	  /**
	   * Utiltiy function for taking an argument that is either an existing
	   * array or an array type / constructor.
	   *
	   * Example:
	   * <pre>
	   * const array = Arrays.maybeCreate( arg || Uint32Array, n );
	   * </pre>
	   *
	   * @param {!ArrayOrType} existingArrayOrType
	   * @param {number=} requiredLength
	   * @throws Error when argument missing or an array and too short
	   */
	  maybeCreate: function maybeCreate(existingArrayOrType, requiredLength) {
	    if (!existingArrayOrType) throw Error('Missing array!');

	    var validLength = requiredLength !== null && !isNaN(requiredLength);

	    // Safari returns "object" for typeof Uint32Array, Float32Array, etc, so use instanceof
	    if (typeof existingArrayOrType === 'function' || existingArrayOrType instanceof Function) {

	      if (!validLength) throw Error('Missing or invalid length!');

	      // Note: Browsers show wEirD behavior when it comes to
	      // argument checks of typed array constructors...

	      return new existingArrayOrType(requiredLength);
	    }

	    // otherwise assume we got an existing array

	    if (validLength && existingArrayOrType.length < requiredLength) throw Error('Array too short: ' + existingArrayOrType.length + ' < ' + requiredLength);

	    return existingArrayOrType;
	  },

	  copyObjects: function copyObjects(objects, array, optionalStride) {

	    if (!objects) return null;

	    var nObjects = objects.length;
	    if (nObjects === 0) return array;

	    var stride = objects[0].constructor.InstanceScalarSize || optionalStride;

	    if (stride === undefined) throw Error('Arrays.fromObjects: Cannot determine stride!');

	    var result = Arrays.maybeCreate(arrayOrType, nObjects * stride);

	    for (var i = 0, offset = 0; i !== nObjects; ++i, offset += stride) {

	      var object = objects[i];

	      if (object === undefined) {
	        console.warn('Arrays.fromObjects: Undefined object.');
	        array.fill(0, offset, offset + stride);
	        continue;
	      }

	      object.toArray(array, offset);
	    }

	    return array;
	  }

	};

	exports.default = Arrays;

/***/ },
/* 192 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/object/freeze.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/freeze */ 193), __esModule: true };

/***/ },
/* 193 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/freeze.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.freeze */ 194);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.freeze;

/***/ },
/* 194 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.freeze.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , meta     = __webpack_require__(/*! ./_meta */ 119).onFreeze;

	__webpack_require__(/*! ./_object-sap */ 133)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 195 */
/*!************************************************!*\
  !*** ./src/polyMesh/generic/utility/Orders.js ***!
  \************************************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Orders = {

	  Numeric: function Numeric(a, b) {
	    return a - b;
	  },

	  Natural: function Natural(a, b) {
	    return a < b ? -1 : b < a ? 1 : 0;
	  },

	  // Note: Unstable compare functions are not an optimization.
	  // Some operations require to detect equality!

	  derefedNumbersIn: function derefedNumbersIn(array) {

	    return function compare(a, b) {
	      return array[a] - array[b];
	    };
	  },

	  derefedTuplesIn: function derefedTuplesIn(array, elementSize, optionalStride) {

	    if (!elementSize) throw Error('Invalid element size!');

	    var stride = optionalStride || elementSize;

	    if (stride === 1 && elementSize === 1) return Orders.derefNumbersIn(array);

	    return function compare(a, b) {

	      var offsetA = a * stride;
	      var offsetB = b * stride;

	      var result = array[offsetA] - array[offsetB];

	      for (var i = 1; i !== elementSize && result === 0; ++i) {

	        result = array[offsetA + i] - array[offsetB + i];
	      }return result;
	    };
	  },

	  derefedNumbersStableIn: function derefedNumbersStableIn(array) {

	    return function compare(a, b) {

	      var result = array[a] - array[b];
	      return result !== 0 ? result : a - b;
	    };
	  },

	  derefedTuplesStableIn: function derefedTuplesStableIn(array, elementSize, optionalStride) {

	    if (!elementSize) throw Error('Invalid element size!');

	    var stride = optionalStride || elementSize;

	    if (stride === 1 && elementSize === 1) return Orders.derefNumbersStableIn(array);

	    return function compare(a, b) {

	      var offsetA = a * stride;
	      var offsetB = b * stride;

	      var result = array[offsetA] - array[offsetB];

	      for (var i = 1; i !== elementSize && result === 0; ++i) {

	        result = array[offsetA + i] - array[offsetB + i];
	      }return result !== 0 ? result : a - b;
	    };
	  }

	};

	exports.default = Orders;

/***/ },
/* 196 */
/*!*********************************************************!*\
  !*** ./src/polyMesh/generic/container/FlatArrayView.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = FlatArrayView;

	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	var _Orders = __webpack_require__(/*! ../utility/Orders */ 195);

	var _Orders2 = _interopRequireDefault(_Orders);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function FlatArrayView(data, length) {

	  this.data = data;
	  this.length = length;
	};

	FlatArrayView.prototype = {

	  constructor: FlatArrayView,

	  offset: 0, // in scalars, constant default
	  stride: 1, // in scalars, constant default
	  elementSize: 1, // in scalars, constant default

	  // Access to element ranges

	  newRangeArray: function newRangeArray(optionalNumberOfElements) {

	    var n = optionalNumberOfElements || 1;
	    return new this.data.constructor(n * this.elementSize);
	  },

	  rangeToArray: function rangeToArray(index, n, optionalArray, optionalWriteOffset) {

	    var data = this.data;
	    var stride = this.stride;
	    var elemSize = this.elementSize;

	    var array = optionalArray || new this.data.constructor(n * this.elementSize);
	    var writeOffset = optionalWriteOffset || 0;

	    for (var offset = this.offset + index * stride, end = offset + n * stride; offset < end; offset += stride) {

	      for (var i = offset, e = offset + elemSize; i !== e; ++i) {

	        array[writeOffset++] = data[i];
	      }
	    }return array;
	  },

	  arrayToRange: function arrayToRange(array, index, n, optionalReadOffset) {

	    var data = this.data;
	    var stride = this.stride;
	    var elemSize = this.elementSize;
	    var readOffset = optionalReadOffset || 0;

	    for (var offset = this.offset + index * stride, end = offset + n * stride; offset < end; offset += stride) {

	      for (var i = offset, e = offset + elemSize; i !== e; ++i) {

	        data[i] = array[readOffset++];
	      }
	    }return this;
	  },

	  // Bulk copy operations

	  toArray: function toArray(optionalArrayOrType, optionalOffset) {

	    var stride = this.stride;
	    var length = this.length;
	    var elemSize = this.elementSize;
	    var writeOffset = optionalOffset === undefined ? 0 : optionalOffset;
	    var minimumLength = writeOffset + length * elemSize;

	    if (stride === elemSize) {
	      // data is packed, can use typed array API

	      var data = this.data;
	      var offset = this.offset;
	      var dataEnd = offset + length * elemSize;

	      if (writeOffset === 0 && (optionalArrayOrType === undefined || optionalArrayOrType === this.data.constructor)) return _Arrays2.default.slice(data, offset, dataEnd);

	      var array = _Arrays2.default.maybeCreate(optionalArrayOrType, minimumLength);

	      array.set(data.subarray(offset, dataEnd), writeOffset);

	      return array;
	    } else {
	      // data is strided, twiddle it apart

	      var _array = _Arrays2.default.maybeCreate(optionalArrayOrType, minimumLength);

	      return this.rangeToArray(0, length, _array, optionalOffset);
	    }
	  },

	  fromArray: function fromArray(array, optionalOffset) {

	    var stride = this.stride;
	    var length = this.length;
	    var elemSize = this.elementSize;
	    var readOffset = optionalOffset === undefined ? 0 : optionalOffset;
	    var minimumLength = readOffset + length * elemSize;

	    if (stride === elemSize) {
	      // data is packed, can use typed array API

	      var readView = readOffset === 0 && array.length === minimumLength ? array : array.subarray(readOffset, minimumLength);

	      this.data.set(readView, this.offset);
	    } else {
	      // data is strided, scatter it

	      return this.arrayToRange(array, 0, length, readOffset);
	    }

	    return this;
	  },

	  // Array data management

	  repack: function repack(optionalArrayType) {

	    var currentArrayType = this.data.constructor;
	    var requestedArrayType = optionalArrayType || currentArrayType;

	    if (this.stride !== this.elementSize || requestedArrayType !== currentArrayType) this.forceRepack(optionalArrayType);

	    return this;
	  },

	  forceRepack: function forceRepack(optionalArrayType) {

	    this.data = this.toArray(optionalArrayType);
	    this.offset = 0;
	    this.stride = this.elementSize;

	    return this;
	  },

	  // Factory methods for views / buffers

	  clone: function clone() {

	    return this.newCompatibleView(this.toArray(), this.length);
	  },

	  newCompatibleView: function newCompatibleView(arrayOrType, optionalLength) {

	    throw Error('not implemented'); // abstract
	  },

	  newCompatibleBuffer: function newCompatibleBuffer() {

	    throw Error('not implemented'); // abstract
	  },

	  // Factory methods for compare functions

	  newCompareAtIndices: function newCompareAtIndices() {

	    return _Orders2.default.derefedTuplesIn(this.data, this.elementSize, this.stride);
	  },

	  newCompareAtIndicesStable: function newCompareAtIndicesStable() {

	    return _Orders2.default.derefedTuplesStableIn(this.data, this.elementSize, this.stride);
	  }

	};

/***/ },
/* 197 */
/*!********************************************************!*\
  !*** ./src/polyMesh/generic/container/ObjectBuffer.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 188);

	var _create2 = _interopRequireDefault(_create);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.default = ObjectBuffer;

	var _BlockBuffer = __webpack_require__(/*! ./BlockBuffer */ 198);

	var _BlockBuffer2 = _interopRequireDefault(_BlockBuffer);

	var _ObjectArrayView = __webpack_require__(/*! ./ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function ObjectBuffer(type, optionalArrayType, optionalElementSize) {

	  _BlockBuffer2.default.call(this, optionalArrayType || Float32Array);

	  this.elementSize = optionalElementSize || type.InstanceScalarSize;
	  this.type = type;
	};

	ObjectBuffer.prototype = (0, _assign2.default)((0, _create2.default)(_BlockBuffer2.default.prototype), {

	  constructor: ObjectBuffer,

	  toObjectArrayViewAndClear: function toObjectArrayViewAndClear() {

	    return new _ObjectArrayView2.default(this.type, null, this.toArrayAndClear());
	  },

	  getAt: function getAt(index, optionalValue) {

	    var result = optionalValue || new this.type();

	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & this.intraBlockIndexMask;

	    return result.fromArray(this.blocks[blockIndex], blockOffset * this.elementSize);
	  },

	  setAt: function setAt(index, value) {

	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & this.intraBlockIndexMask;

	    value.toArray(this.blocks[blockIndex], blockOffset * this.elementSize);
	  },

	  push: function push(value) {

	    var index = this.length++;
	    var block = this.lastBlock;
	    var blockOffset = index & this.intraBlockIndexMask;

	    if (blockOffset === 0) {

	      var blockSize = this.intraBlockIndexMask + 1;
	      block = new this.arrayType(blockSize * this.elementSize);
	      this.lastBlock = block;
	      this.blocks.push(block);
	    }

	    value.toArray(block, blockOffset * this.elementSize);

	    return index + 1;
	  }

	});

/***/ },
/* 198 */
/*!*******************************************************!*\
  !*** ./src/polyMesh/generic/container/BlockBuffer.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = BlockBuffer;

	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function BlockBuffer(arrayType, nIntraBlockIndexBits) {

	  this.blocks = [];
	  this.lastBlock = null;
	  this.arrayType = arrayType;

	  var nBits = nIntraBlockIndexBits || 12;
	  this.intraBlockIndexBits = nBits;
	  this.intraBlockIndexMask = (1 << nBits) - 1;

	  this.length = 0;
	};

	BlockBuffer.prototype = {

	  constructor: BlockBuffer,

	  elementSize: 1, // in scalars, constant default

	  toArrayAndClear: function toArrayAndClear() {

	    var result = this.toArray();
	    this.clear();
	    return result;
	  },

	  newRangeArray: function newRangeArray(optionalNumberOfElements) {

	    var n = optionalNumberOfElements || 1;
	    return new this.arrayType(n * this.elementSize);
	  },

	  rangeToArray: function rangeToArray(index, n, optionalArray, optionalWriteOffset) {

	    var intraBlockIndexMask = this.intraBlockIndexMask;
	    var elementSize = this.elementSize;

	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & intraBlockIndexMask;

	    var block = this.blocks[blockIndex];

	    var array = optionalArray || new this.arrayType(n * elementSize);
	    var writeOffset = optionalWriteOffset === undefined ? 0 : optionalWriteOffset;

	    for (var i = 0; i < n; ++i) {

	      for (var j = blockOffset * elementSize, s = j + elementSize; j !== s; ++j) {

	        array[writeOffset++] = block[j];
	      }if ((++blockOffset & intraBlockIndexMask) === 0) block = this.blocks[++blockIndex];
	    }

	    return array;
	  },

	  arrayToRange: function arrayToRange(array, index, n, optionalReadOffset) {

	    var intraBlockIndexMask = this.intraBlockIndexMask;
	    var elementSize = this.elementSize;

	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & intraBlockIndexMask;

	    var block = this.blocks[blockIndex];

	    var readOffset = optionalReadOffset === undefined ? 0 : optionalReadOffset;

	    for (var i = 0; i < n; ++i) {

	      for (var j = blockOffset * elementSize, s = j + elementSize; j !== s; ++j) {

	        block[j] = array[readOffset++];
	      }if ((++blockOffset & intraBlockIndexMask) === 0) block = this.blocks[++blockIndex];
	    }

	    return this;
	  },

	  pushArrayRange: function pushArrayRange(array, n, optionalReadOffset) {

	    var intraBlockIndexMask = this.intraBlockIndexMask;
	    var elementSize = this.elementSize;

	    var blockOffset = this.length; // masked later

	    var block = this.lastBlock;

	    var readOffset = optionalReadOffset === undefined ? 0 : optionalReadOffset;

	    for (var i = 0; i < n; ++i) {

	      if ((blockOffset &= intraBlockIndexMask) === 0) {

	        var blockSize = intraBlockIndexMask + 1;
	        block = new this.arrayType(blockSize * elementSize);
	        this.lastBlock = block;
	        this.blocks.push(block);
	      }

	      for (var j = blockOffset++ * elementSize, s = j + elementSize; j !== s; ++j) {

	        block[j] = array[readOffset++];
	      }
	    }

	    return this.length += n;
	  },

	  clear: function clear() {

	    this.blocks = [];
	    this.length = 0;
	    this.lastBlock = null;

	    return this;
	  },

	  toArray: function toArray(optionalArrayOrType, optionalOffset) {

	    var writeOffset = optionalOffset === undefined ? 0 : optionalOffset;
	    var elementSize = this.elementSize;
	    var minArraySize = this.length * elementSize + writeOffset;

	    var array = _Arrays2.default.maybeCreate(optionalArrayOrType || this.arrayType, minArraySize);

	    var blocks = this.blocks;
	    var blockSize = (1 << this.intraBlockIndexBits) * elementSize;
	    var nFullBlocks = Math.max(blocks.length - 1, 0);

	    for (var i = 0; i !== nFullBlocks; ++i) {

	      array.set(blocks[i], writeOffset);
	      writeOffset += blockSize;
	    }

	    var lastBlockUse = minArraySize - writeOffset;

	    if (lastBlockUse !== 0) array.set(blocks[nFullBlocks].subarray(0, lastBlockUse), writeOffset);

	    return array;
	  }

	};

/***/ },
/* 199 */
/*!***********************************************************!*\
  !*** ./src/polyMesh/generic/container/ScalarArrayView.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 188);

	var _create2 = _interopRequireDefault(_create);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.default = ScalarArrayView;

	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	var _FlatArrayView = __webpack_require__(/*! ./FlatArrayView */ 196);

	var _FlatArrayView2 = _interopRequireDefault(_FlatArrayView);

	var _ScalarBuffer = __webpack_require__(/*! ./ScalarBuffer */ 200);

	var _ScalarBuffer2 = _interopRequireDefault(_ScalarBuffer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function ScalarArrayView(length, optionalArrayOrType, optionalOffset, optionalStride) {

	  var offset = optionalOffset === undefined ? 0 : optionalOffset;
	  var stride = optionalStride === undefined ? 1 : optionalStride;

	  var offsetLength = (offset + stride - 1) / stride | 0;
	  var minArrayLength = length !== null ? (offsetLength + length) * stride : null;

	  var array = _Arrays2.default.maybeCreate(optionalArrayOrType || Uint32Array, minArrayLength);

	  _FlatArrayView2.default.call(this, array, length !== null ? length :
	  // figure out length from user-provided array
	  (array.length - offset + stride - 1) / stride | 0);

	  this.offset = offset;
	  this.stride = stride;
	};

	ScalarArrayView.prototype = (0, _assign2.default)((0, _create2.default)(_FlatArrayView2.default.prototype), {

	  constructor: ScalarArrayView,

	  getAt: function getAt(index) {

	    return this.array[this.offset + index * this.stride];
	  },

	  setAt: function setAt(index, value) {

	    this.array[this.offset + index * this.stride] = value;
	  },

	  newCompatibleView: function newCompatibleView(arrayOrType, optionalLength) {

	    return new ScalarArrayView(optionalLength || null, arrayOrType, 0);
	  },

	  newCompatibleBuffer: function newCompatibleBuffer() {

	    return new _ScalarBuffer2.default(this.data.constructor);
	  }

	});

/***/ },
/* 200 */
/*!********************************************************!*\
  !*** ./src/polyMesh/generic/container/ScalarBuffer.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 188);

	var _create2 = _interopRequireDefault(_create);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.default = ScalarBuffer;

	var _BlockBuffer = __webpack_require__(/*! ./BlockBuffer */ 198);

	var _BlockBuffer2 = _interopRequireDefault(_BlockBuffer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function ScalarBuffer(optionalArrayType) {

	  _BlockBuffer2.default.call(this, optionalArrayType || Uint32Array);
	};

	ScalarBuffer.prototype = (0, _assign2.default)((0, _create2.default)(_BlockBuffer2.default.prototype), {

	  constructor: ScalarBuffer,

	  getAt: function getAt(index) {

	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & this.intraBlockIndexMask;

	    return this.blocks[blockIndex][blockOffset];
	  },

	  setAt: function setAt(index, value) {

	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & this.intraBlockIndexMask;

	    this.blocks[blockIndex][blockOffset] = value;
	    return this;
	  },

	  push: function push(value) {

	    var index = this.length++;
	    var block = this.lastBlock;
	    var blockOffset = index & this.intraBlockIndexMask;

	    if (blockOffset === 0) {

	      var blockSize = this.intraBlockIndexMask + 1;
	      block = new this.arrayType(blockSize);
	      this.lastBlock = block;
	      this.blocks.push(block);
	    }

	    block[blockOffset] = value;

	    return index + 1;
	  }

	});

/***/ },
/* 201 */
/*!**************************************************!*\
  !*** ./src/polyMesh/geometric/model/PolyMaps.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 188);

	var _create2 = _interopRequireDefault(_create);

	exports.default = PolyMaps;

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function PolyMaps() {

	  _ObjectsByName2.default.call(this);
	};

	PolyMaps.prototype = (0, _create2.default)(_ObjectsByName2.default.prototype);
	PolyMaps.prototype.constructor = PolyMaps;

	// Pretty much an alias to ObjectsByName, adding a static interface
	// and a custom iterator for uniform access of maps within a mesh...

	(0, _assign2.default)(PolyMaps, {

	  TypePosition: 1,
	  TypeNormal: 2,
	  TypeTangent: 4,
	  TypeUV: 8,
	  TypeColor: 16,

	  id: function id(typeId, name) {

	    var anchorName = PolyMaps.TypeInfo[typeId].AnchorName;
	    return name != null ? anchorName + '.' + name : anchorName;
	  },

	  checkId: function checkId(id) {

	    var anchorName = PolyMaps.getAnchorName(id);
	    var mapName = PolyMaps.getMapName(id, anchorName);
	    var typeInfo = PolyMaps.getTypeInfo(anchorName);

	    if (typeInfo === null || mapName === '') throw Error("Invalid PolyMap ID '" + id + "'!");

	    return id;
	  },

	  getAnchorName: function getAnchorName(id) {

	    var dot = id.indexOf('.');
	    return dot === -1 ? id : id.slice(0, dot);
	  },

	  getMapName: function getMapName(id, anchorName) {

	    return id === anchorName ? null : id.slice(anchorName.length + 1);
	  },

	  getTypeInfo: function getTypeInfo(anchorName) {

	    var info = PolyMaps.TypeInfo;
	    for (var i = 0, n = info.length; i !== n; ++i) {
	      var entry = info[i];
	      if (entry !== null && entry.AnchorName === anchorName) return info[i];
	    }

	    return null;
	  },

	  resolveMap: function resolveMap(mesh, id) {

	    var anchorName = PolyMaps.getAnchorName(id);
	    if (id === anchorName) return mesh[anchorName];

	    var maps = mesh[anchorName];
	    return maps && maps.byName[id.slice(anchorName.length + 1)];
	  },

	  assignMap: function assignMap(mesh, id, map) {

	    var anchorName = PolyMaps.getAnchorName(id);
	    var mapName = PolyMaps.getMapName(id, anchorName);

	    if (mapName === null) {

	      mesh[anchorName] = map;
	    } else {

	      var maps = mesh[anchorName];

	      if (maps === null) {

	        maps = new PolyMaps();
	        mesh[anchorName] = maps;
	      }

	      maps.set(mapName, map);
	    }
	  },

	  Iterator: function Iterator(mesh) {

	    _ObjectsByName2.default.Iterator.call(this);
	    this.reset(mesh || null);
	  }

	});

	PolyMaps.TypeInfo = [null, { // 1
	  Type: PolyMaps.TypePosition,
	  AnchorName: 'positions',
	  ElementType: THREE.Vector3
	}, { // 2
	  Type: PolyMaps.TypeNormal,
	  AnchorName: 'normalMap',
	  ElementType: THREE.Vector3
	}, null, { // 4
	  Type: PolyMaps.TypeTangent,
	  AnchorName: 'tangentMap',
	  ElementType: THREE.Vector3
	}, null, null, null, { // 8
	  Type: PolyMaps.TypeUV,
	  AnchorName: 'uvMaps',
	  ElementType: THREE.Vector2
	}, null, null, null, null, null, null, null, {
	  Type: PolyMaps.TypeColor,
	  AnchorName: 'colorMaps',
	  ElementType: THREE.Color
	}];

	(0, _assign2.default)(PolyMaps, {

	  IdPositions: PolyMaps.id(PolyMaps.TypePosition),
	  IdNormals: PolyMaps.id(PolyMaps.TypeNormal),
	  IdTangents: PolyMaps.id(PolyMaps.TypeTangent)

	});

	PolyMaps.Iterator.prototype = (0, _assign2.default)((0, _create2.default)(_ObjectsByName2.default.Iterator.prototype), {

	  constructor: PolyMaps.Iterator,
	  _super: _ObjectsByName2.default.Iterator.prototype,

	  reset: function reset(optionalMesh) {

	    this._super.reset.call(this, null);

	    var mesh = optionalMesh || null;
	    this.mesh = mesh;
	    this.byName = mesh;
	    this.typeId = 0;
	  },

	  getId: function getId() {

	    return PolyMaps.id(this.typeId, this.name);
	  },

	  next: function next() {

	    // Note: Not using dynamic resolution here because it may impact
	    // compiler optimizations in a negative way.

	    // If iterating a collection, keep going:

	    if (this._super.next.call(this)) return true;

	    // Otherwise count up the id:

	    var mesh = this.mesh;
	    var type = this.typeId;

	    var elem = null;
	    var object = null;

	    type <<= 1;

	    switch (type) {

	      case 0:
	        type = 1;
	      // v-v-v

	      case PolyMaps.TypePosition:
	        elem = mesh.positions;
	        break;

	      case PolyMaps.TypeNormal:
	        elem = mesh.normalMap;
	        break;

	      case PolyMaps.TypeTangent:
	        elem = mesh.tangentMap;
	        break;

	      case PolyMaps.TypeUV:
	        object = mesh.uvMaps;
	        break;

	      case PolyMaps.TypeColor:
	        object = mesh.colorMaps;
	        break;

	      default:

	        this.reset(null);
	        return false;

	    }

	    this.typeId = type;

	    if (object !== null && object !== undefined) {

	      this.byName = object.byName;
	      return this._super.reset.call(this, object).next();
	    } else if (elem !== null && elem !== undefined) {

	      this.element = elem;
	      this.index = type;
	      this.name = null;
	      return true;
	    }

	    return this.next();
	  }

	});

/***/ },
/* 202 */
/*!*********************************************************!*\
  !*** ./src/polyMesh/generic/container/ObjectsByName.js ***!
  \*********************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ObjectsByName;
	/**
	 * This class works around the problem that {@code for .. in} loops poison
	 * the surrounding function and inhibit all optimizations with V8. This is
	 * of course undesirable, especially since some data processing may happen
	 * in the same function, and redundant workarounds would obscure the code.
	 *
	 * Therefore we use an extra data structure with an array of names.
	 *
	 * A noteworthy property is that there is no reliance on the indices, so
	 * {@code .namesByIndex} can be sorted (unless within an ongoing iteration,
	 * of course) in-place, e.g. alphabetically or by use frequency for UI or
	 * caching purposes.
	 *
	 * Further, we provide a nested {@code Iterator} class that treats {@code
	 * null} values gracefully.
	 *
	 * Example:
	 * <pre>
	 * // Create an iterator
	 * const iterator = new ObjectsByName.Iterator( objects );
	 *
	 * // Iterate when this.objects is an ObjectsByName instance, do nothing
	 * // in case it is null
	 * for ( iterator.next(); ) {
	 *     // [... use iterator.name, iterator.index and iterator.element ...]
	 * }
	 * </pre>
	 *
	 * @template T
	 * @constructor
	 */
	function ObjectsByName() {

	  /** @const @type {!Object<!string,T>} */
	  this.byName = {};

	  /** @const @type {!Array<T>} */
	  this.namesByIndex = [];
	};

	ObjectsByName.prototype = {

	  constructor: ObjectsByName,

	  /** @type {!number} */
	  get length() {
	    return this.namesByIndex.length;
	  },

	  set: function set(name, object) {

	    var byName = this.byName;
	    if (name in byName === false) this.namesByIndex.push(name);
	    byName[name] = object;
	  }

	};

	/**
	 * @template T
	 * @constructor
	 * @param {ObjectsByName<T>=} optionalContainer
	 */
	ObjectsByName.Iterator = function (optionalContainer) {

	  this.reset(optionalContainer || null);
	};

	ObjectsByName.Iterator.prototype = {

	  constructor: ObjectsByName.Iterator,

	  /**
	   * @param {ObjectsByName<T>=} optionalContainer
	   * @return {!ObjectsByName.Iterator<T>}
	   */
	  reset: function reset(optionalContainer) {

	    if (optionalContainer !== undefined) this.container = optionalContainer;

	    this.name = null;
	    this.index = -1;
	    this.element = null;
	    return this;
	  },

	  /**
	   * @return {!boolean}
	   */
	  next: function next() {

	    var map = this.container;
	    if (map === null) return false;

	    var names = map.namesByIndex;
	    var index = ++this.index;

	    if (index >= names.length) {

	      this.name = null;
	      return false;
	    }

	    this.element = map.byName[this.name = names[index]];
	    return true;
	  },

	  /**
	   * @param {!string} name
	   * @param {T} element
	   * @return {!ObjectsByName<T>}
	   */
	  add: function add(name, element) {

	    // TODO if ( this === null ) this = new ObjectsByName();

	    var namesByIndex = this.namesByIndex;

	    if (namesByIndex.indexOf(name) !== -1) throw Error("ObjectsByName: Name '" + name + "' not unique!");

	    namesByIndex.push(name);
	    this.byName[name] = element;

	    return this;
	  }

	};

	ObjectsByName.shallowClone = function () {

	  var i = new ObjectsByName.Iterator();

	  return function shallowClone(that) {

	    var newMap = new ObjectsByName();

	    if (!that) return newMap;

	    var byName = newMap.byName;
	    var names = newMap.namesByIndex;

	    names.length = that.namesByIndex.length;

	    for (i.reset(that); i.next();) {

	      var name = i.name;
	      byName[name] = i.element;
	      names[i.index] = name;
	    }

	    i.reset(null); // (!)

	    return newMap;
	  };
	}();

/***/ },
/* 203 */
/*!*************************************************!*\
  !*** ./src/polyMesh/geometric/model/PolyMap.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = PolyMap;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _IndexMappings = __webpack_require__(/*! ../../generic/algorithm/IndexMappings */ 204);

	var _IndexMappings2 = _interopRequireDefault(_IndexMappings);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	var _EdgeVertexAdjacency = __webpack_require__(/*! ./adjacency/EdgeVertexAdjacency */ 205);

	var _EdgeVertexAdjacency2 = _interopRequireDefault(_EdgeVertexAdjacency);

	var _FaceEdgeAdjacency = __webpack_require__(/*! ./adjacency/FaceEdgeAdjacency */ 207);

	var _FaceEdgeAdjacency2 = _interopRequireDefault(_FaceEdgeAdjacency);

	var _ValueAdjacency = __webpack_require__(/*! ./adjacency/ValueAdjacency */ 208);

	var _ValueAdjacency2 = _interopRequireDefault(_ValueAdjacency);

	var _FaceFaceAdjacency = __webpack_require__(/*! ./adjacency/FaceFaceAdjacency */ 209);

	var _FaceFaceAdjacency2 = _interopRequireDefault(_FaceFaceAdjacency);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * @template T
	 * @constructor
	 *
	 * @param {!PolyMap|!Object} from object to copy the properties from
	 */
	function PolyMap(from) {

	  if (!from) {
	    this.faceRangeOffsets = new Uint32Array(1);
	    this.faceValueIndices = new Uint32Array(0);
	    this.values = new _ObjectArrayView2.default(THREE.Vector3, 0);
	  } else {

	    this.faceRangeOffsets = from.faceRangeOffsets; //Uint32Array
	    this.faceValueIndices = from.faceValueIndices; //Uint32Array
	    this.values = from.values; //ObjectArrayView contains Three.Vector3 or Three.Vector2 usually

	    // Cached transient information (can be rebuilt from the above):

	    // Inverse index (value indices -> faces):
	    var valueFaceIndices = from.valueFaceIndices || null;
	    this.valueFaceIndices = valueFaceIndices;
	    this.valueFaceIndexOffsets = // only reuse when complete
	    valueFaceIndices && from.valueFaceIndexOffsets || null;

	    // The low value index acts as the pivot for edge enumeration, so
	    // the following array is indexed by edge UIDs:
	    this._edgeVertexAdjacency = null;
	    this._faceEdgeAdjacency = null;
	    this._valueAdjacency = null;
	    this._valueValueAdjacency = null;
	    this._faceFaceAdjacency = null;
	  }
	};

	PolyMap.fromData = function (faceOffsets, indices, values) {

	  var result = new PolyMap({

	    faceRangeOffsets: faceOffsets,

	    faceValueIndices: indices || _IndexMappings2.default.identity(values.length, Uint32Array),

	    values: values.repack(Float32Array)

	  });

	  var nFaceVertices = faceOffsets[faceOffsets.length - 1];

	  if (result.faceValueIndices.length !== nFaceVertices) throw Error('Number of postition indices or unindexed ' + 'data values does not match the number of face vertices!');

	  return result;
	};

	PolyMap.prototype = {

	  constructor: PolyMap,
	  isPolyMap: true,

	  findValueIndexOffset: function findValueIndexOffset(faceIndex, valueIndex) {

	    var offsets = this.faceRangeOffsets;
	    var indices = this.faceValueIndices;

	    var begin = offsets[faceIndex];
	    var until = offsets[faceIndex + 1];

	    for (var i = begin; i !== until; ++i) {
	      if (indices[i] === valueIndex) return i;
	    }return -1;
	  },

	  // adjacency structures, computed on-demand adjacency structures.

	  get edgeVertexAdjacency() {

	    if (!this._edgeVertexAdjacency) this._edgeVertexAdjacency = new _EdgeVertexAdjacency2.default(this);

	    return this._edgeVertexAdjacency;
	  },

	  get faceEdgeAdjacency() {

	    if (!this._faceEdgeAdjacency) this._faceEdgeAdjacency = new _FaceEdgeAdjacency2.default(this);

	    return this._faceEdgeAdjacency;
	  },

	  get valueAdjacency() {

	    if (!this._valueAdjacency) this._valueAdjacency = new _ValueAdjacency2.default(this);

	    return this._valueAdjacency;
	  },

	  get valueValueAdjacency() {

	    if (!this._valueValueAdjacency) this._valueValueAdjacency = new ValueValueAdjacency(this);

	    return this._valueValueAdjacency;
	  },

	  get faceFaceAdjacency() {

	    if (!this._faceFaceAdjacency) this._faceFaceAdjacency = new _FaceFaceAdjacency2.default(this);

	    return this._faceFaceAdjacency;
	  },

	  // Inverse index (value index -> faces) build

	  updateInverseIndex: function updateInverseIndex() {

	    if (this.valueFaceIndices === null) {

	      var faceOffsets = this.faceRangeOffsets;

	      var faceIndex = -1;
	      var nextFaceStart = faceOffsets[0];

	      var indices = this.faceValueIndices;

	      var writeOffsets = this._updateValueFaceIndexOffsets();
	      var nDestOffsets = writeOffsets.length;

	      var nFaceIndices = indices.length;
	      var faceIndices = new Uint32Array(nFaceIndices);

	      for (var i = 0; i !== nFaceIndices; ++i) {

	        if (i === nextFaceStart) nextFaceStart = faceOffsets[++faceIndex + 1];

	        faceIndices[writeOffsets[indices[i]]++] = faceIndex;
	      }

	      this.valueFaceIndices = faceIndices;

	      // Shift the write offsets back to their initial values:

	      if (writeOffsets.byteOffset === 0) throw Error('Invalid .valueFaceIndexOffsets != null!');

	      this.valueFaceIndexOffsets = new Uint32Array(writeOffsets.buffer, 0, nDestOffsets);
	    }

	    return this;
	  },

	  _updateValueFaceIndexOffsets: function _updateValueFaceIndexOffsets() {

	    var result = this.valueFaceIndexOffsets;

	    if (result === null) {

	      var nValues = this.values.length;
	      var requiredLength = nValues + 2;

	      // Two extra values... Why?
	      //
	      // 1. For uniform access we keep n+1 offsets, that is
	      //    0, o_0, o_1, o_2 ..., <length>
	      //
	      // 2. The build of the inverse indices is destructive
	      //    and shifts the offsets by one index. The result
	      //    is something like:
	      //
	      //    o_0, o_1, o_2, ..., <length>, <length>
	      //
	      //    Now we will want our leading zero back.

	      var buffer = new Uint32Array(requiredLength);
	      var histogramArea = buffer.subarray(2);

	      result = buffer.subarray(1);

	      _IndexMappings2.default.histogram(this.faceValueIndices, nValues, histogramArea);

	      _Arrays2.default.accumulate(histogramArea);

	      this.valueFaceIndices = null;
	      this.valueFaceIndexOffsets = result;
	    }

	    return result;
	  },

	  // Compaction

	  compactValues: function compactValues() {

	    var values = this.values;
	    var nValues = values.length;

	    if (nValues !== 0) {

	      var sourceToTargetMap = new Uint32Array(nValues);
	      var nCompactValues = this._compactFaceIndexOffsets(sourceToTargetMap);

	      if (nCompactValues !== nValues) {

	        this._compactData(sourceToTargetMap, nCompactValues);
	        this._compactIndices(sourceToTargetMap);
	      }
	    }

	    return this;
	  },

	  _compactFaceIndexOffsets: function _compactFaceIndexOffsets(outSourceToTargetMap) {

	    var faceIndexOffsets = this._updateValueFaceIndexOffsets();
	    var nValues = outSourceToTargetMap.length;

	    var nCompactValues = 0;
	    var offset = 0; // == faceIndexOffsets[ 0 ]

	    for (var i = 0; i !== nValues; ++i) {

	      var nextOffset = faceIndexOffsets[i + 1];

	      outSourceToTargetMap[i] = nCompactValues;
	      // Note: Filling in incorrect values at indices that are no longer
	      // used, actually. But those allow to replay the compaction of the
	      // offsets on the values once the size is known.
	      //
	      // The value that corresponds to the last index in an equal range
	      // is the one to keep.

	      if (offset !== nextOffset) {

	        if (nCompactValues !== i) faceIndexOffsets[nCompactValues] = offset;

	        offset = nextOffset;
	        ++nCompactValues;
	      }
	    }

	    faceIndexOffsets[nCompactValues] = offset;

	    if (nCompactValues !== nValues) {

	      // Note: Since only empty ranges were removed, neither need to null
	      // nor rebuild .valueFaceIndices.

	      if (faceIndexOffsets.byteOffset !== 0) {
	        // this will be our leading zero and we want to keep it, so have
	        // a little dance with the typed arrays API...

	        var bufferView = new Uint32Array(faceIndexOffsets.buffer),
	            slice = _Arrays2.default.slice(bufferView, 0, nCompactValues + 2);

	        faceIndexOffsets = slice.subarray(1);

	        // ... phew!
	      } else {

	        faceIndexOffsets = _Arrays2.default.slice(faceIndexOffsets, 0, nCompactValues + 1);
	      }
	    }

	    this.valueFaceIndexOffsets = faceIndexOffsets;
	    return nCompactValues;
	  },

	  _compactData: function _compactData(sourceToTargetMap, nCompactValues) {

	    // Rewrite the values to a new buffer, avoiding to build another
	    // temporary map, instead exploit the bogus padding of the STTM:

	    var values = this.values;
	    var nValues = values.length;
	    var newValues = new _ObjectArrayView2.default(values.type, nCompactValues);
	    var writeIndex = sourceToTargetMap[0];
	    var element = newValues.newRangeArray();

	    for (var i = 1; i !== nValues; ++i) {

	      var nextWriteIndex = sourceToTargetMap[i];

	      if (writeIndex !== nextWriteIndex) {
	        // now i - 1 is the source position we want

	        values.rangeToArray(i - 1, 1, element);
	        newValues.arrayToRange(element, writeIndex, 1);

	        writeIndex = nextWriteIndex;
	      }
	    }

	    values.rangeToArray(nValues - 1, 1, element);
	    newValues.arrayToRange(element, writeIndex, 1);

	    this.values = newValues;
	  },

	  _compactIndices: function _compactIndices(sourceToTargetMap) {

	    // The size of the index array does not change - it has already (else
	    // there'd be no unused indices), but we don't know when (the typical
	    // case would be in a previous transaction), so the same array can be
	    // in use elsewhere...

	    var indices = this.faceValueIndices;
	    var nIndices = indices.length;

	    var newIndices = new Uint32Array(nIndices);

	    _IndexMappings2.default.apply(indices, sourceToTargetMap, newIndices);
	    this.faceValueIndices = newIndices;
	  }

	};

/***/ },
/* 204 */
/*!*********************************************************!*\
  !*** ./src/polyMesh/generic/algorithm/IndexMappings.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Utilties for working with arrays of indices that are broadly useful and not
	 * tailored towards a specific purpose.
	 *
	 * @namespace
	 */
	var IndexMappings = {

	  /**
	   * Create or populate an array with elements equal to their indices.
	   *
	   * @param {!number} n
	   * @param {ArrayOrType=} arrayOrType defaults to Uint32Array
	   * @return {!Array<!number>}
	   */
	  identity: function identity(n, arrayOrType) {

	    var result = _Arrays2.default.maybeCreate(arrayOrType || Uint32Array, n);
	    for (var i = 0; i !== n; ++i) {
	      result[i] = i;
	    }return result;
	  },

	  /**
	   * Get an identity map as a view onto a globally shared buffer which
	   * must not be changed.
	   *
	   * @param {!number} n
	   * @return {!Uint32Array}
	   */
	  identityForReading: function identityForReading(n) {

	    var proto = IndexMappings._identityProto;

	    if (n > proto.length) {

	      proto = IndexMappings.identity(n * 5 / 4 | 0);
	      IndexMappings._identityProto = proto;
	    }

	    return proto.subarray(0, n);
	  },

	  _identityProto: _Arrays2.default.Empty.Uint32Array,

	  /**
	   * Create an array where each index corresponds to the values and the
	   * values map back to the index of the source array.
	   *
	   * For non-surjective mappings, the missing indices are not written to.
	   * For non-injective mappings, duplicate indices will map to their last
	   * position of occurence in the input.
	   *
	   * @param {!Array<!number>} source integer indices
	   * @param {number} n
	   *    maximum entry in source map + 1
	   *    can be {@code null} when an existing array is given
	   * @param {ArrayOrType=} arrayOrType defaults to Uint32Array
	   * @return {!Array<!number>}
	   */
	  inverse: function inverse(source, n, arrayOrType) {

	    var result = _Arrays2.default.maybeCreate(arrayOrType || Uint32Array, n);

	    for (var i = 0, e = source.length; i !== e; ++i) {
	      result[source[i]] = i;
	    }return result;
	  },

	  /**
	   * Transform one mapping with another, in-place unless an explicit
	   * destination is given.
	   *
	   * @param {!Array<!number>} map indices to transform
	   * @param {!Array<!number>} transform mapping to apply
	   * @param {Array<!number>=} optionalDestination
	   * @return {!Array<!number>} same as {@code map}
	   */
	  apply: function apply(map, transform, optionalDestination) {

	    var dst = optionalDestination || map;

	    for (var i = 0, n = map.length; i !== n; ++i) {
	      dst[i] = transform[map[i]];
	    }return map;
	  },

	  /**
	   * Count the equal elements.
	   *
	   * When an existing array is used for the destination, it must be
	   * filled with zeroes.
	   *
	   * @param {!Array<!number>} source integer indices
	   * @param {!number} n maximum entry in source map + 1
	   * @param {ArrayOrType=} arrayOrType defaults to Uint32Array
	   * @return {!Array<!number>}
	   */
	  histogram: function histogram(source, n, arrayOrType) {

	    var result = _Arrays2.default.maybeCreate(arrayOrType || Uint32Array, n);

	    for (var i = 0, e = source.length; i !== e; ++i) {
	      ++result[source[i]];
	    }return result;
	  }

	};
	exports.default = IndexMappings;

/***/ },
/* 205 */
/*!***********************************************************************!*\
  !*** ./src/polyMesh/geometric/model/adjacency/EdgeVertexAdjacency.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = EdgeVertexAdjacency;

	var _MergeSort = __webpack_require__(/*! ../../../generic/algorithm/MergeSort */ 206);

	var _MergeSort2 = _interopRequireDefault(_MergeSort);

	var _Arrays = __webpack_require__(/*! ../../../generic/utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @template T
	 * @constructor
	 *
	 */
	function EdgeVertexAdjacency(polyMap) {

	  this.polyMap = polyMap;

	  // The low value index acts as the pivot for edge enumeration, so
	  // the following array is indexed by edge UIDs:
	  this.edgeHighVertexIndices = null;

	  // Low -> high value index mapping (describes ranges of edge UIDs):
	  this.edgePivotRangeOffsets = null;

	  this.edgeVertices = null;

	  this._compactEdgeLowToHighMap(this._buildEdgeLowToHighMap());

	  this._inverseMapping();
	};

	EdgeVertexAdjacency.prototype = {

	  constructor: EdgeVertexAdjacency,

	  getNumEdges: function getNumEdges() {

	    return this.edgeHighVertexIndices.length;
	  },

	  // VV -> E
	  findEdgeId: function findEdgeId(faceValueIndexA, faceValueIndexB) {

	    var loVertex = faceValueIndexA;
	    var hiVertex = faceValueIndexB;

	    if (hiVertex < loVertex) {
	      loVertex = faceValueIndexB;
	      hiVertex = faceValueIndexA;
	    }

	    var rangeOffsets = this.edgePivotRangeOffsets;

	    return _Arrays2.default.binarySearch(this.edgeHighVertexIndices, hiVertex, rangeOffsets[loVertex], rangeOffsets[loVertex + 1]);
	  },

	  // E -> VV
	  getVerticesForEdge: function getVerticesForEdge(edgeId) {
	    return {
	      v: this.edgeVertices[edgeId * 2],
	      vNext: this.edgeVertices[edgeId * 2 + 1]
	    };
	  },

	  _inverseMapping: function _inverseMapping() {

	    var numEdges = this.getNumEdges();

	    var edgeVertices = new Uint32Array(numEdges * 2);

	    for (var v0 = 0; v0 < this.edgePivotRangeOffsets.length - 1; v0++) {

	      var edgeBegin = this.edgePivotRangeOffsets[v0];
	      var edgeEnd = this.edgePivotRangeOffsets[v0 + 1];

	      for (var i = edgeBegin; i <= edgeEnd; i++) {
	        var v1 = this.edgeHighVertexIndices[i];

	        edgeVertices[i * 2 + 0] = v0;
	        edgeVertices[i * 2 + 1] = v1;
	      }
	    }

	    this.edgeVertices = edgeVertices;
	  },

	  _buildEdgeLowToHighMap: function _buildEdgeLowToHighMap() {

	    var faceOffsets = this.polyMap.faceRangeOffsets;
	    var valueIndices = this.polyMap.faceValueIndices;

	    var nValues = this.polyMap.values.length;
	    var offsets = new Uint32Array(nValues + 2);
	    var histogramArea = offsets.subarray(2);

	    var faceBegin = faceOffsets[0];
	    var maxEdgesSharingPivot = 0;

	    // Construct histogram and accumulate:

	    for (var i = 1, n = faceOffsets.length; i !== n; ++i) {

	      var faceUntil = faceOffsets[i];
	      var vertexA = valueIndices[faceUntil - 1];

	      for (var j = faceBegin; j !== faceUntil; ++j) {

	        var vertexB = valueIndices[j];
	        var loVertex = vertexB < vertexA ? vertexB : vertexA;

	        var nEdges = ++histogramArea[loVertex];

	        if (nEdges > maxEdgesSharingPivot) maxEdgesSharingPivot = nEdges;

	        vertexA = vertexB;
	      }

	      faceBegin = faceUntil;
	    }

	    _Arrays2.default.accumulate(histogramArea);

	    // Build the indices array (shifting the offsets):

	    var writeOffsets = offsets.subarray(1);
	    var indices = new Uint32Array(writeOffsets[nValues]);

	    faceBegin = faceOffsets[0];

	    for (var _i = 1, _n = faceOffsets.length; _i !== _n; ++_i) {

	      var _faceUntil = faceOffsets[_i];
	      var _vertexA = valueIndices[_faceUntil - 1];

	      for (var _j = faceBegin; _j !== _faceUntil; ++_j) {

	        var _vertexB = valueIndices[_j];

	        var _loVertex = _vertexA;
	        var hiVertex = _vertexB;

	        if (hiVertex < _loVertex) {

	          _loVertex = _vertexB;
	          hiVertex = _vertexA;
	        }

	        indices[writeOffsets[_loVertex]++] = hiVertex;

	        _vertexA = _vertexB;
	      }

	      faceBegin = _faceUntil;
	    }

	    this.edgePivotRangeOffsets = offsets;
	    this.edgeHighVertexIndices = indices;

	    return maxEdgesSharingPivot;
	  },

	  _compactEdgeLowToHighMap: function _compactEdgeLowToHighMap(maxEdgesSharingPivot) {

	    var offsets = this.edgePivotRangeOffsets;
	    var indices = this.edgeHighVertexIndices;

	    var sorter = new _MergeSort2.default(Uint32Array, maxEdgesSharingPivot);

	    var nOffsets = this.polyMap.values.length + 1;

	    var rangeUntil = 0;
	    var rangeBegin = 0;
	    var writeOffset = 0;

	    for (var i = 1; i !== nOffsets; ++i) {

	      rangeUntil = offsets[i];

	      if (rangeBegin !== rangeUntil) {

	        sorter.sortRange(indices, rangeBegin, rangeUntil);

	        // Unique-compact indices within each range:

	        var prevElement = indices[rangeBegin];
	        indices[writeOffset++] = prevElement;

	        for (var j = rangeBegin + 1; j < rangeUntil; ++j) {

	          var element = indices[j];
	          if (element !== prevElement) {

	            indices[writeOffset++] = element;
	            prevElement = element;
	          }
	        }
	      }

	      offsets[i] = writeOffset; // re-write compact offsets
	      rangeBegin = rangeUntil; // certainly >= writeOffset
	    }

	    // Shrink to fit (offsets only has 2 extra elements, so view it):

	    this.edgeHighVertexIndices = _Arrays2.default.slice(indices, 0, writeOffset);

	    this.edgePivotRangeOffsets = offsets.subarray(0, nOffsets);
	  }

	};

/***/ },
/* 206 */
/*!*****************************************************!*\
  !*** ./src/polyMesh/generic/algorithm/MergeSort.js ***!
  \*****************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = MergeSort;
	function MergeSort(arrayType, maxRangeLength) {

	  this.ping = new arrayType(maxRangeLength);
	  this.pong = new arrayType(maxRangeLength);
	};

	MergeSort.apply = function (array) {

	  var sorter = new MergeSort(array.constructor, array.length);
	  sorter.sortRange(array, 0, array.length);
	};

	MergeSort.prototype = {

	  constructor: MergeSort,

	  sortRange: function sortRange(array, begin, until) {

	    var length = until - begin;

	    if (length <= 4) {
	      // this implementation requires at least three elements and also
	      // has a high base cost when it comes to very short ranges

	      if (length >= 2) this._handleShortRange(array, begin, length);
	      return;
	    }

	    var read = array;
	    var readBegin = begin;
	    var readUntil = until;

	    var write = this.ping;
	    var writeOffset = 0;

	    var blockSize = 1;
	    var blockPairSize = 2;

	    for (var run = true; run;) {

	      var nMerges = (length + blockSize - 1) / blockSize >> 1,
	          l = readBegin,
	          endR = readBegin + blockPairSize;

	      for (var last = 0; last <= 1; ++last) {

	        for (var i = 1; i !== nMerges; ++i, l += blockSize, endR += blockPairSize) {

	          var r = l + blockSize,
	              endL = r,
	              valL = read[l],
	              valR = read[r];

	          for (var merge = true; merge;) {

	            if (valR < valL) {

	              write[writeOffset++] = valR;

	              if (++r === endR) {

	                write[writeOffset++] = valL;
	                while (++l !== endL) {
	                  write[writeOffset++] = read[l];
	                }merge = false;
	              } else valR = read[r];
	            } else {

	              write[writeOffset++] = valL;

	              if (++l === endL) {

	                write[writeOffset++] = valR;
	                while (++r !== endR) {
	                  write[writeOffset++] = read[r];
	                }merge = false;
	              } else valL = read[l];
	            }
	          }
	        }

	        // Handle edge cases before the last pass:

	        if (last === 0) {

	          nMerges = 2; // one more merge (1-based, exclusive)

	          if (endR > readUntil) endR = readUntil;else if (endR !== readUntil) {

	            var writeOffsetTemp = writeOffset + blockPairSize;

	            for (var j = endR; j !== readUntil; ++j) {
	              write[writeOffsetTemp++] = read[j];
	            }
	          }
	        }
	      }

	      if (write !== array) {
	        // not done yet? prepare next level

	        blockSize = blockPairSize;
	        blockPairSize <<= 1;

	        read = write;
	        readBegin = 0;
	        readUntil = length;

	        if (blockPairSize < length) {
	          // at least two more levels? destination is temporary

	          var ping = this.ping;
	          write = write === ping ? this.pong : ping;
	          writeOffset = 0;
	        } else {
	          // next will be the last level -> write back to source

	          write = array;
	          writeOffset = begin;
	        }
	      } else run = false;
	    }
	  },

	  _handleShortRange: function _handleShortRange(array, begin, length) {

	    var valA = array[begin];
	    var valB = array[begin + 1];

	    switch (length) {

	      case 2:

	        if (valB < valA) {

	          array[begin] = valB;
	          array[begin + 1] = valA;
	        }

	        break;

	      case 3:
	        {

	          var valC = array[begin + 2];

	          if (valB < valA) {

	            var tmp = valA;valA = valB;valB = tmp;
	          }

	          if (valC < valB) {

	            var _tmp = valB;valB = valC;valC = _tmp;
	          }

	          if (valB < valA) {

	            var _tmp2 = valA;valA = valB;valB = _tmp2;
	          }

	          array[begin] = valA;
	          array[begin + 1] = valB;
	          array[begin + 2] = valC;

	          break;
	        }

	      case 4:
	        {

	          var _valC = array[begin + 2];
	          var valD = array[begin + 3];

	          if (valB < valA) {

	            var _tmp3 = valA;valA = valB;valB = _tmp3;
	          }

	          if (valD < _valC) {

	            var _tmp4 = _valC;_valC = valD;valD = _tmp4;
	          }

	          if (_valC < valA) {

	            var _tmp5 = valA;valA = _valC;_valC = _tmp5;
	          }

	          if (valD < valB) {

	            var _tmp6 = valB;valB = valD;valD = _tmp6;
	          }

	          if (_valC < valB) {

	            var _tmp7 = valB;valB = _valC;_valC = _tmp7;
	          }

	          array[begin] = valA;
	          array[begin + 1] = valB;
	          array[begin + 2] = _valC;
	          array[begin + 3] = valD;
	        }
	    }
	  }

	};

/***/ },
/* 207 */
/*!*********************************************************************!*\
  !*** ./src/polyMesh/geometric/model/adjacency/FaceEdgeAdjacency.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = FaceEdgeAdjacency;
	function FaceEdgeAdjacency(polyMap) {

	  this.polyMap = polyMap;

	  this.faceEdgeIndices = null;

	  this.edgeFaceCounts = null;
	  this.edgeFaceIndices = null;

	  this._compute();
	};

	FaceEdgeAdjacency.prototype = {

	  constructor: FaceEdgeAdjacency,

	  // F -> E
	  //faceValueIndex is the index of value on the face
	  //ie: the index of the value in faceValueIndices
	  //    not the value of faceValueIndices
	  getEdgeIdFromFaceValueIndex: function getEdgeIdFromFaceValueIndex(faceValueIndex) {
	    return this.faceEdgeIndices[faceValueIndex];
	  },

	  // E -> F, part 1
	  getNumFacesForEdgeId: function getNumFacesForEdgeId(edgeID) {
	    return this.edgeFaceCounts[edgeID];
	  },
	  // E -> F, part 2
	  getFaceForEdgeId: function getFaceForEdgeId(edgeId, faceOffset) {
	    return this.edgeFaceIndices[edgeId * 2 + faceOffset];
	  },

	  //returns false if there is an invalid surface
	  //if this function returns false this adjacency structure is invalid and cannot be used
	  checkValidity: function checkValidity() {
	    var invalidSurface = true;
	    for (var i = 0; i < this.edgeFaceCounts.length; i++) {
	      if (this.edgeFaceCounts[i] > 2) invalidSurface = false;
	    }

	    return invalidSurface;
	  },

	  _compute: function _compute() {

	    var polyMap = this.polyMap;
	    var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;

	    var faceRangeOffsets = polyMap.faceRangeOffsets;
	    var faceValueIndices = polyMap.faceValueIndices;

	    var numEdges = edgeVertexAdjacency.edgeHighVertexIndices.length;
	    //const numFaces = faceRangeOffsets.length - 1;
	    var edgeFaceCounts = new Uint32Array(numEdges);
	    var edgeFaceIndices = new Uint32Array(numEdges * 2);
	    var faceEdgeIndices = new Uint32Array(faceValueIndices.length);

	    for (var f = 0; f < faceRangeOffsets.length - 1; f++) {

	      var faceBegin = faceRangeOffsets[f];
	      var faceUntil = faceRangeOffsets[f + 1];
	      var numFaceValues = faceUntil - faceBegin;

	      var vNext = faceValueIndices[faceBegin];

	      // count faces on each edge.
	      for (var fv = 0; fv < numFaceValues; fv++) {

	        var v = vNext;
	        vNext = faceValueIndices[faceBegin + (fv + 1) % numFaceValues];

	        var edgeId = edgeVertexAdjacency.findEdgeId(v, vNext);

	        var faceValueIndex = faceBegin + fv;

	        faceEdgeIndices[faceValueIndex] = edgeId;

	        edgeFaceIndices[edgeId * 2 + edgeFaceCounts[edgeId]] = f;
	        edgeFaceCounts[edgeId]++;
	      }
	    }

	    this.faceEdgeIndices = faceEdgeIndices;

	    this.edgeFaceCounts = edgeFaceCounts;
	    this.edgeFaceIndices = edgeFaceIndices;

	    return this;
	  }
	};

/***/ },
/* 208 */
/*!******************************************************************!*\
  !*** ./src/polyMesh/geometric/model/adjacency/ValueAdjacency.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ValueAdjacency;
	function ValueAdjacency(polyMap) {

	  this.polyMap = polyMap;

	  this._compute();
	};

	ValueAdjacency.prototype = {

	  constructor: ValueAdjacency,

	  // V -> E, part 1
	  getNumEdgesForVertex: function getNumEdgesForVertex(valueIndex) {
	    var valueBegin = this.valueEdgeOffsets[valueIndex];
	    var valueUntil = this.valueEdgeOffsets[valueIndex + 1];
	    var numValueEdges = valueUntil - valueBegin;

	    return numValueEdges;
	  },

	  // V -> E, part 2
	  getEdgeForVertexId: function getEdgeForVertexId(valueIndex, edgeOffset) {
	    var valueBegin = this.valueEdgeOffsets[valueIndex];
	    return this.valueEdgeIndices[valueBegin + edgeOffset];
	  },

	  //V->VV returns the adjacent values to a given vertex
	  getAdjacentValues: function getAdjacentValues(valueIndex) {
	    var edgeVertexAdjacency = this.polyMap.edgeVertexAdjacency;
	    var adjacentValues = [];
	    var numEdges = this.getNumEdgesForVertex(valueIndex);

	    for (var i = 0; i < numEdges; i++) {
	      var edge = this.getEdgeForVertexId(valueIndex, i);
	      var values = edgeVertexAdjacency.getVerticesForEdge(edge);
	      var adjacentValue = values.v === valueIndex ? values.vNext : values.v;
	      adjacentValues.push(adjacentValue);
	    }

	    return adjacentValues;
	  },

	  //V->VV for a given faceValueIndex and face, returns the (0-2) adjacent faceValueIndices on that face
	  getAdjacentFaceValuesIndicesOnFace: function getAdjacentFaceValuesIndicesOnFace(faceValueIndex, face) {

	    var adjacentValuesOnFace = [];
	    var faceBegin = this.polyMap.faceRangeOffsets[face];
	    var faceEnd = this.polyMap.faceRangeOffsets[face + 1];
	    var faceSize = faceEnd - faceBegin;
	    if (faceSize < 3) return adjacentValuesOnFace;

	    var next = faceValueIndex === faceEnd - 1 ? faceBegin : faceValueIndex + 1;
	    var prev = faceValueIndex === faceBegin ? faceEnd - 1 : faceValueIndex - 1;

	    adjacentValuesOnFace.push(prev);
	    adjacentValuesOnFace.push(next);

	    return adjacentValuesOnFace;
	  },

	  // V -> F, part 1
	  getNumFacesForVertex: function getNumFacesForVertex(faceValueIndex) {
	    var valueBegin = this.valueFaceOffsets[faceValueIndex];
	    var valueUntil = this.valueFaceOffsets[faceValueIndex + 1];
	    var numValueFace = valueUntil - valueBegin;

	    return numValueFace;
	  },

	  // V -> F, part 2
	  getFaceForVertexId: function getFaceForVertexId(faceValueIndex, faceOffset) {
	    var valueBegin = this.valueFaceOffsets[faceValueIndex];
	    return this.valueFaceIndices[valueBegin + faceOffset];
	  },

	  _compute: function _compute() {

	    var polyMap = this.polyMap;

	    var faceRangeOffsets = polyMap.faceRangeOffsets;
	    var faceValueIndices = polyMap.faceValueIndices;

	    var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;

	    var valueFaceCount = new Uint32Array(polyMap.values.length);
	    var valueEdgeCount = new Uint32Array(polyMap.values.length);
	    //const numFaces = faceRangeOffsets.length - 1;

	    var numEdges = edgeVertexAdjacency.getNumEdges();
	    var edgeUnique = new Uint8Array(numEdges);

	    // histogram.
	    for (var f = 0; f < polyMap.faceRangeOffsets.length - 1; f++) {

	      var faceBegin = polyMap.faceRangeOffsets[f];
	      var faceUntil = polyMap.faceRangeOffsets[f + 1];
	      var numFaceValues = faceUntil - faceBegin;

	      var vNext = polyMap.faceValueIndices[faceBegin];

	      for (var fv = 0; fv < numFaceValues; fv++) {

	        var v = vNext;
	        vNext = polyMap.faceValueIndices[faceBegin + (fv + 1) % numFaceValues];

	        var e = edgeVertexAdjacency.findEdgeId(v, vNext);

	        valueFaceCount[v]++;

	        // is this the first time processing this edge
	        if (edgeUnique[e] === 0) {
	          edgeUnique[e] = 1;

	          valueEdgeCount[v]++;
	          valueEdgeCount[vNext]++;
	        }
	      }
	    }

	    // create offset arrays.
	    var faceSum = 0,
	        edgeSum = 0;
	    var valueFaceOffsets = new Uint32Array(valueFaceCount.length + 1);
	    var valueEdgeOffsets = new Uint32Array(valueEdgeCount.length + 1);
	    for (var i = 0; i < valueFaceCount.length; i++) {
	      valueFaceOffsets[i] = faceSum;
	      faceSum += valueFaceCount[i];
	      valueFaceCount[i] = 0;

	      valueEdgeOffsets[i] = edgeSum;
	      edgeSum += valueEdgeCount[i];
	      valueEdgeCount[i] = 0;
	    }

	    valueFaceOffsets[valueFaceCount.length] = faceSum;
	    valueEdgeOffsets[valueEdgeCount.length] = edgeSum;

	    // fill in the values
	    var valueFaceIndices = new Uint32Array(faceSum);
	    var valueEdgeIndices = new Uint32Array(edgeSum);

	    for (var _f = 0; _f < polyMap.faceRangeOffsets.length - 1; _f++) {

	      var _faceBegin = polyMap.faceRangeOffsets[_f];
	      var _faceUntil = polyMap.faceRangeOffsets[_f + 1];
	      var _numFaceValues = _faceUntil - _faceBegin;

	      var _vNext = polyMap.faceValueIndices[_faceBegin];

	      for (var _fv = 0; _fv < _numFaceValues; _fv++) {

	        var _v = _vNext;
	        _vNext = polyMap.faceValueIndices[_faceBegin + (_fv + 1) % _numFaceValues];

	        var _e = edgeVertexAdjacency.findEdgeId(_v, _vNext);

	        valueFaceIndices[valueFaceOffsets[_v] + valueFaceCount[_v]++] = _f;

	        // is this the first time processing this edge
	        if (edgeUnique[_e] === 1) {
	          edgeUnique[_e] = 2;

	          valueEdgeIndices[valueEdgeOffsets[_v] + valueEdgeCount[_v]++] = _e;
	          valueEdgeIndices[valueEdgeOffsets[_vNext] + valueEdgeCount[_vNext]++] = _e;
	        }
	      }
	    }

	    this.valueFaceOffsets = valueFaceOffsets;
	    this.valueFaceIndices = valueFaceIndices;

	    this.valueEdgeOffsets = valueEdgeOffsets;
	    this.valueEdgeIndices = valueEdgeIndices;
	  }
	};

/***/ },
/* 209 */
/*!*********************************************************************!*\
  !*** ./src/polyMesh/geometric/model/adjacency/FaceFaceAdjacency.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = FaceFaceAdjacency;
	function FaceFaceAdjacency(polyMap) {

	  //for each face there is an offset array (faceFaceCounts)
	  //this offset array indexes into an array of all faces that are adjacent (faceFaceIndices)

	  this.polyMap = polyMap;

	  this.faceFaceCounts = null;
	  this.faceFaceIndices = null;

	  this._compute();
	};

	FaceFaceAdjacency.prototype = {

	  constructor: FaceFaceAdjacency,

	  //F->F
	  getAdjacentFaces: function getAdjacentFaces(face) {
	    var numAdjacentFaces = this.faceFaceCounts[face + 1] - this.faceFaceCounts[face];
	    var adjacentFaces = new Uint32Array(numAdjacentFaces);
	    for (var i = this.faceFaceCounts[face], j = 0; i < this.faceFaceCounts[face + 1]; i++, j++) {
	      adjacentFaces[j] = this.faceFaceIndices[i];
	    }

	    return adjacentFaces;
	  },

	  //return array of 0-2 faces
	  //valuesIndex is the index of the vertex in the values array
	  adjacentFacesOnVertex: function adjacentFacesOnVertex(face, valuesIndex) {
	    var adjacentFaces = this.getAdjacentFaces(face);
	    var faceRangeOffsets = this.polyMap.faceRangeOffsets;
	    var faceValueIndices = this.polyMap.faceValueIndices;
	    var adjacentFacesOnVertex = [];

	    for (var i = 0; i < adjacentFaces.length; i++) {
	      for (var j = faceRangeOffsets[adjacentFaces[i]]; j < faceRangeOffsets[adjacentFaces[i] + 1]; j++) {
	        if (faceValueIndices[j] === valuesIndex) {
	          adjacentFacesOnVertex.push(adjacentFaces[i]);
	          break;
	        }
	      }
	    }

	    return adjacentFacesOnVertex;
	  },

	  _compute: function _compute() {

	    var faceRangeOffsets = this.polyMap.faceRangeOffsets;
	    var faceValueIndices = this.polyMap.faceValueIndices;
	    var faceEdgeAdjacency = this.polyMap.faceEdgeAdjacency;

	    var faceFaceCounts = new Uint32Array(faceRangeOffsets.length);
	    var faceFaceIndices = [];

	    for (var i = 0; i < faceRangeOffsets.length - 1; i++) {

	      var adjacentFaces = [];
	      for (var j = faceRangeOffsets[i]; j < faceRangeOffsets[i + 1]; j++) {
	        var edge = faceEdgeAdjacency.getEdgeIdFromFaceValueIndex(j);

	        //if edge has 2 faces then find the adjacent face that isnt the given face
	        var numFaces = faceEdgeAdjacency.getNumFacesForEdgeId(edge);
	        if (numFaces > 1) {
	          var adjacentFaceIndex = faceEdgeAdjacency.getFaceForEdgeId(edge, 0);
	          if (adjacentFaceIndex === i) adjacentFaceIndex = faceEdgeAdjacency.getFaceForEdgeId(edge, 1);
	          adjacentFaces.push(adjacentFaceIndex);
	        }
	      }

	      faceFaceCounts[i + 1] = faceFaceCounts[i] + adjacentFaces.length;
	      faceFaceIndices.push.apply(faceFaceIndices, adjacentFaces);
	    }

	    this.faceFaceCounts = faceFaceCounts;
	    this.faceFaceIndices = Uint32Array.from(faceFaceIndices);

	    return this;
	  }
	};

/***/ },
/* 210 */
/*!**************************************************!*\
  !*** ./src/polyMesh/geometric/model/PolyMesh.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = PolyMesh;

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	var _PolyMaps = __webpack_require__(/*! ./PolyMaps */ 201);

	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

	var _PolyMap = __webpack_require__(/*! ./PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function PolyMesh(from) {
	  if (!from) {
	    this.faceRangeOffsets = new Uint32Array(1);
	    this.positions = new _PolyMap2.default();

	    this.colorMaps = new _ObjectsByName2.default();
	    this.uvMaps = new _ObjectsByName2.default();
	  } else {

	    if (!from.colorMaps) console.error('Polymesh must have initialized colorMaps container.');
	    if (!from.uvMaps) console.error('Polymesh must have initialized uvMaps container.');

	    this.faceRangeOffsets = from.faceRangeOffsets; //Uint32Array
	    this.positions = from.positions; //PolyMap Object
	    this.normalMap = from.normalMap; //PolyMap Object
	    this.uvMaps = _ObjectsByName2.default.shallowClone(from.uvMaps); //ObjectsByName contains PolyMap Object

	    //optional properties discarded topology change:
	    if (from.skinning) this.skinning = from.skinning; //Skinning Object
	    if (from.edgeCreaseWeights) this.edgeCreaseWeights = from.edgeCreaseWeights; //Float32Array : index === edge, value === weight {0..1}
	    if (from.materialIds) this.materialIds = from.materialIds; //Uint32Array  : index === face

	    //not implemented:
	    //this.tangentMap = from.tangentMap;                         //PolyMap Object
	    this.colorMaps = _ObjectsByName2.default.shallowClone(from.colorMaps); //ObjectsByName contains PolyMap Object
	  }
	};

	PolyMesh.prototype = {

	  constructor: PolyMesh,

	  getNumFaces: function getNumFaces() {

	    return this.faceRangeOffsets.length - 1;
	  },

	  getNumFaceVertices: function getNumFaceVertices() {

	    return this.positions.faceValueIndices.length;
	  },

	  getNumVertices: function getNumVertices() {

	    return this.positions.values.length;
	  },

	  getMapById: function getMapById(mapId) {

	    return _PolyMaps2.default.resolveMap(this, mapId) || null;
	  },

	  topologyChanged: function topologyChanged() {
	    //this function is only to be called during construction of a new polymesh
	    //its purpose is to nullify data that would become invalidated due to a change in topology
	    //the data to remain intact would have to also be correctly mapped in each operator
	    //in the future operators will instead generate a mapping that can be applied through
	    //a general mapping function so such additions can be done in a singular location
	    if (this.skinning) this.skinning = null;
	    if (this.edgeCreaseWeights) this.edgeCreaseWeights = null;
	    if (this.materialIds) this.materialIds = null;
	    return this;
	  }

	};

	PolyMesh.fromData = function (faceRangeOffsets, positions, optionalIndices, optionalMaterialIds) {

	  var polyMesh = new PolyMesh({
	    faceRangeOffsets: faceRangeOffsets,
	    positions: positions.isPolyMap ? positions : _PolyMap2.default.fromData(faceRangeOffsets, optionalIndices || null, positions),
	    uvMaps: new _ObjectsByName2.default(), // ObjectsByName< PolyMap<THREE.Vector2> >
	    colorMaps: new _ObjectsByName2.default() });

	  if (optionalMaterialIds) polyMesh.materialIds = optionalMaterialIds;

	  return polyMesh;
	};

/***/ },
/* 211 */
/*!**************************************************!*\
  !*** ./src/polyMesh/geometric/model/Skinning.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Skinning;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Skinning(from) {

	  this.positionSkinRange = from.positionSkinRange; //Uint32Array
	  this.skinWeights = from.skinWeights; //Float32Array
	  this.skinBoneIndices = from.skinBoneIndices; //Uint16Array

	  this.poseSkinToPoseBoneTransform = from.poseSkinToPoseBoneTransform; //ObjectArrayView of Matrix4's
	};

	Skinning.prototype = {

	  constructor: Skinning,

	  applyTransforms: function applyTransforms(positions, skinToWorldTransform, boneWorldTransforms, rootBoneIndex) {
	    return this.deform(this.createFinalTransforms(skinToWorldTransform, boneWorldTransforms, rootBoneIndex), positions);
	  },

	  createFinalTransforms: function createFinalTransforms(skinToWorldTransform, boneWorldTransforms, rootBoneIndex) {

	    var poseSkinToPoseBoneTransform = this.poseSkinToPoseBoneTransform;
	    var worldToSkinTransform = new THREE.Matrix4().getInverse(skinToWorldTransform, true);
	    var finalTransforms = new Array(poseSkinToPoseBoneTransform.length);

	    var identity = new THREE.Matrix4().identity();

	    if (poseSkinToPoseBoneTransform.length === 0) {
	      return finalTransforms;
	    }

	    var rootToWorldTransform = void 0;
	    var worldToRootTransform = void 0;
	    var poseRootToSkinTransform = void 0;

	    if (rootBoneIndex > -1) {
	      rootToWorldTransform = boneWorldTransforms[rootBoneIndex];
	      worldToRootTransform = new THREE.Matrix4().getInverse(rootToWorldTransform, true);
	      poseRootToSkinTransform = new THREE.Matrix4().getInverse(poseSkinToPoseBoneTransform.getAt(rootBoneIndex), true);
	    }

	    var boneToRootTransform = new THREE.Matrix4();
	    var boneToSkinTransform = new THREE.Matrix4();
	    var finalTransform = new THREE.Matrix4();

	    for (var i = 0, il = poseSkinToPoseBoneTransform.length; i < il; i++) {

	      var boneToWorldTransform = boneWorldTransforms[i];
	      if (rootBoneIndex > -1) {
	        boneToRootTransform.multiplyMatrices(worldToRootTransform, boneToWorldTransform);
	        boneToSkinTransform.multiplyMatrices(poseRootToSkinTransform, boneToRootTransform);
	      } else {
	        boneToSkinTransform.multiplyMatrices(worldToSkinTransform, boneToWorldTransform);
	      }

	      finalTransforms[i] = new THREE.Matrix4().multiplyMatrices(boneToSkinTransform, poseSkinToPoseBoneTransform.getAt(i));
	    }

	    return finalTransforms;
	  },

	  deform: function deform(finalTransforms, positions) {

	    var positionSkinRange = this.positionSkinRange;
	    var skinWeights = this.skinWeights;
	    var skinBoneIndices = this.skinBoneIndices;

	    var deformedPositions = new _ObjectArrayView2.default(THREE.Vector3, positions.length);
	    var v = new THREE.Vector3();
	    var d = new THREE.Vector3();

	    for (var i = 0; i < positions.length; i++) {
	      positions.getAt(i, v);
	      d.multiplyScalar(0);
	      for (var j = positionSkinRange[i]; j < positionSkinRange[i + 1]; j++) {
	        positions.getAt(i, v);
	        v.applyMatrix4(finalTransforms[skinBoneIndices[j]]);
	        v.multiplyScalar(skinWeights[j]);
	        d.addVectors(d, v);
	      }

	      if (positionSkinRange[i + 1] - positionSkinRange[i] === 0) {
	        d.copy(v);
	      }

	      deformedPositions.setAt(i, d);
	    }

	    return deformedPositions;
	  }

	};

/***/ },
/* 212 */
/*!***************************************************************!*\
  !*** ./src/polyMesh/geometric/algorithm/ImportConversions.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	var _GlobalCompaction = __webpack_require__(/*! ../../generic/algorithm/GlobalCompaction */ 213);

	var _GlobalCompaction2 = _interopRequireDefault(_GlobalCompaction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ImportConversions = {

	  collapsePositions: function collapsePositions(positions, indices) {

	    var compaction = new _GlobalCompaction2.default(positions),
	        compactPositions = compaction.compactedValues(positions);

	    if (indices) compaction.transcribeIndices(indices);

	    return compactPositions;
	  },

	  collapseMapVertexValues: function collapseMapVertexValues(polyMesh, polyMap) {

	    var positions = polyMesh.positions.updateInverseIndex(),
	        indexRanges = polyMesh.faceRangeOffsets,
	        positionIndices = positions.faceValueIndices,
	        faceRangeOffsets = positions.faceRangeOffsets,
	        currFaceIndex = -1,
	        nextFaceStart = 0,
	        faceIndexOffsets = positions.valueFaceIndexOffsets,
	        faceIndices = positions.valueFaceIndices,
	        values = polyMap.values,
	        data = values.data,
	        elementSize = values.elementSize,
	        valueIndices = polyMap.faceValueIndices;

	    for (var i = 0, n = polyMesh.getNumFaceVertices(); i !== n; ++i) {

	      var positionIndex = positionIndices[i],
	          currValueIndex = valueIndices[i],
	          currValueOffset = currValueIndex * elementSize;

	      if (i === nextFaceStart) nextFaceStart = faceRangeOffsets[++currFaceIndex + 1];

	      var facesStart = faceIndexOffsets[positionIndex],
	          facesUntil = faceIndexOffsets[positionIndex + 1];

	      for (var j = facesStart; j !== facesUntil; ++j) {

	        var faceIndex = faceIndices[j];
	        if (faceIndex === currFaceIndex) break;

	        var valueIndexOffset = positions.findValueIndexOffset(faceIndex, positionIndex),
	            valueIndex = valueIndices[valueIndexOffset];

	        if (valueIndex !== currValueIndex) {

	          if (_Arrays2.default.rangeEquals(data, currValueOffset, data, valueIndex * elementSize, elementSize)) valueIndices[i] = valueIndex;
	        }
	      }
	    }
	  }

	};

	exports.default = ImportConversions;

/***/ },
/* 213 */
/*!************************************************************!*\
  !*** ./src/polyMesh/generic/algorithm/GlobalCompaction.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = GlobalCompaction;

	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	var _BitSet = __webpack_require__(/*! ../container/BitSet */ 214);

	var _BitSet2 = _interopRequireDefault(_BitSet);

	var _ObjectArrayView = __webpack_require__(/*! ../container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _IndexMappings = __webpack_require__(/*! ./IndexMappings */ 204);

	var _IndexMappings2 = _interopRequireDefault(_IndexMappings);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Construct a compact (injective / scattering) map to globally unique values
	 * within an ObjectArrayView and optionally also the (injective / compacting)
	 * source-to-target mapping (STTM).
	 *
	 * For each index in the input data, the STTM contains the index in compacted
	 * form. The STTM can be used to transcribe existing indices into the data or,
	 * if the data is "unindexed", it is the indices.
	 *
	 * @constructor
	 *
	 * @param {!ObjectArrayView} values
	 * @param {boolean=} ttsOnly whether to only create the target-to-source map
	 */
	function GlobalCompaction(values, ttsOnly) {

	  var nValues = values.length;

	  var tupleOrder = _Arrays2.default.sort(_IndexMappings2.default.identity(nValues), values.newCompareAtIndicesStable());

	  var nUnique = 0;
	  var sourceToTargetMap = null;

	  var compare = values.newCompareAtIndices();

	  if (ttsOnly) {

	    nUnique = _Arrays2.default.unique(tupleOrder, compare);
	  } else {
	    // customized UNIQUE algo that builds the STTM on the fly

	    sourceToTargetMap = new Uint32Array(nValues);

	    var writeIndex = 0;
	    var prevUniqueAt = 0;
	    var minValueIndex = tupleOrder[0];

	    for (var i = 1; i < nValues; ++i) {

	      var valueIndex = tupleOrder[i];

	      if (compare(valueIndex, minValueIndex) !== 0) {

	        for (var j = prevUniqueAt; j !== i; ++j) {
	          sourceToTargetMap[tupleOrder[j]] = minValueIndex;
	        }prevUniqueAt = i;
	        minValueIndex = valueIndex;

	        if (++writeIndex !== i) tupleOrder[writeIndex] = valueIndex;
	      }
	    }

	    for (var _j = prevUniqueAt; _j !== nValues; ++_j) {
	      sourceToTargetMap[tupleOrder[_j]] = minValueIndex;
	    }nUnique = writeIndex + 1;
	  }

	  // Now that duplicates have been removed, restore the original order by
	  // sorting the indices (since we have a finite integer range, we can do
	  // so very quickly using a BitSet):

	  var targetToSourceMap = new _BitSet2.default(nValues).includeFromArray(tupleOrder, 0, nUnique).toIndexArray(nUnique);

	  if (sourceToTargetMap !== null) {

	    // The STTM already has all equal indices mapped to the first, but
	    // these indices are still in respect to the input, so they need to
	    // be translated to refer to compact data:

	    var reusableMemory = tupleOrder;

	    var sparseCompaction = _IndexMappings2.default.inverse(targetToSourceMap, null, reusableMemory);

	    _IndexMappings2.default.apply(sourceToTargetMap, sparseCompaction);
	  }

	  this.targetToSourceMap = targetToSourceMap;
	  this.sourceToTargetMap = sourceToTargetMap;
	};

	GlobalCompaction.prototype = {

	  constructor: GlobalCompaction,

	  compactedValues: function compactedValues(data) {

	    var map = this.targetToSourceMap;
	    var nCompact = map.length;

	    var result = new _ObjectArrayView2.default(data.type, nCompact);

	    var elementData = data.newRangeArray();

	    for (var i = 0; i !== nCompact; ++i) {

	      data.rangeToArray(map[i], 1, elementData);
	      result.arrayToRange(elementData, i, 1);
	    }

	    return result;
	  },

	  indices: function indices(nFaceVertices) {

	    return new Uint32Array(this.sourceToTargetMap);
	  },

	  transcribeIndices: function transcribeIndices(indices) {

	    return _IndexMappings2.default.apply(indices, this.sourceToTargetMap);
	  }

	};

/***/ },
/* 214 */
/*!**************************************************!*\
  !*** ./src/polyMesh/generic/container/BitSet.js ***!
  \**************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = BitSet;
	function BitSet(length) {

	  this.data = new Uint32Array(length + 31 >>> 5);
	  this.length = length;

	  this.byteView = null;
	};

	BitSet.prototype = {

	  constructor: BitSet,

	  clear: function clear() {

	    this.data.fill(0);
	    return this;
	  },

	  fill: function fill(optionalOffset, optionalLength) {

	    var data = this.data;

	    var begin = optionalOffset !== undefined ? optionalOffset : 0;
	    var until = optionalLength !== undefined ? begin + optionalLength : this.length;

	    var wordIndexBegin = begin >>> 5;
	    var wordIndexUntil = until >>> 5;

	    // Smear the highbit with a signed shift for a pattern of MSBs:
	    var maskBegin = -0x80000000 >> ~begin;

	    // Power of two minus one yields a pattern of LSBs:
	    var maskUntil = (1 << until) - 1;

	    if (wordIndexBegin === wordIndexUntil) data[wordIndexBegin] |= maskBegin & maskUntil;else {

	      data[wordIndexBegin] |= maskBegin;

	      if (++wordIndexBegin !== wordIndexUntil) data.fill(~0, wordIndexBegin, wordIndexUntil);

	      data[wordIndexUntil] |= maskUntil;
	    }

	    return this;
	  },

	  include: function include(i) {

	    this.data[i >>> 5] |= 1 << i;
	  },

	  exclude: function exclude(i) {

	    this.data[i >>> 5] &= ~(1 << i);
	  },

	  contains: function contains(i) {

	    return (this.data[i >>> 5] & 1 << i) !== 0;
	  },

	  swap: function swap(i, j) {

	    var data = this.data;

	    var wordIndexI = i >>> 5,
	        maskI = 1 << i;
	    var wordIndexJ = j >>> 5,
	        maskJ = 1 << j;

	    var stateI = (data[wordIndexI] & maskI) !== 0;
	    var stateJ = (data[wordIndexJ] & maskJ) !== 0;

	    if (stateI !== stateJ) {

	      if (stateI) {

	        data[wordIndexI] &= ~maskI;
	        data[wordIndexJ] |= maskJ;
	      } else {

	        data[wordIndexI] |= maskI;
	        data[wordIndexJ] &= ~maskJ;
	      }
	    }
	  },

	  testAndInclude: function testAndInclude(i) {

	    var data = this.data;

	    var wordIndex = i >>> 5,
	        mask = 1 << i;

	    var unchangedWord = data[wordIndex];

	    data[wordIndex] = unchangedWord | mask;
	    return (unchangedWord & mask) !== 0;
	  },

	  includeFromArray: function includeFromArray(array, optionalOffset, optionalUntil) {

	    var data = this.data;

	    for (var j = optionalOffset || 0, e = optionalUntil || array.length; j < e; ++j) {

	      var i = array[j];

	      data[i >>> 5] |= 1 << i;
	    }

	    return this;
	  },

	  containsAnyIn: function containsAnyIn(array, optionalOffset, optionalUntil) {

	    var result = false;
	    var data = this.data;

	    for (var j = optionalOffset || 0, e = optionalUntil || array.length; j < e && !result; ++j) {

	      var i = array[j];

	      result = (data[i >>> 5] & 1 << i) !== 0;
	    }

	    return result;
	  },

	  countSetBits: function countSetBits(optionalOffset, optionalUntil) {

	    var result = 0;

	    var begin = optionalOffset !== undefined ? optionalOffset : 0;
	    var until = optionalUntil !== undefined ? optionalUntil : this.length;

	    if ((until - begin & -0x4000) === 0)
	      // that is, 'begin' is less than 'until' and fewer than 2048 bytes

	      result = this.countSetBitsInShortRange(begin, until);else if (begin < until) {
	      // use a LUT - it's several times faster at scale

	      var data = this.byteView;
	      var lut = BitSet._ByteBitCount;

	      if (data === null) {

	        data = new Uint8Array(this.data.buffer);
	        this.byteView = data;
	      }

	      var wordIndexBegin = begin >>> 3;
	      var wordIndexUntil = until >>> 3;

	      // Smear the highbit with a signed shift for a pattern of MSBs:
	      var maskBegin = -0x80000000 >> 31 - (begin & 7);
	      // Power of two minus one yields a pattern of LSBs:
	      var maskUntil = (1 << (until & 7)) - 1;

	      result = lut[data[wordIndexBegin] & maskBegin];

	      for (var j = wordIndexBegin + 1; j !== wordIndexUntil; ++j) {
	        result += lut[data[j]];
	      }result += lut[data[wordIndexUntil] & maskUntil];
	    }

	    return result;
	  },

	  countSetBitsInShortRange: function countSetBitsInShortRange(begin, until) {

	    // Note: For some odd reason the data word must be signed to keep
	    // V8 from deoptimizing - all unsigned access won't do.

	    var result = 0;

	    var data = this.data;

	    var here = begin;
	    var index = here >>> 5;

	    var word = data[index] >> here;

	    result = word & 1;

	    while (++here !== until) {

	      if ((here & 31) !== 0) word >>= 1;else word = data[++index] | 0; // cast to signed (important)

	      result += word & 1;
	    }

	    return result;
	  },

	  toIndexArray: function toIndexArray(optionalKnownLength) {

	    var result = new Uint32Array(optionalKnownLength === undefined ? this.countSetBits() : optionalKnownLength);
	    var baseIndex = 0;
	    var writeOffset = 0;
	    var data = this.data;

	    for (var j = 0, n = data.length; j !== n; ++j) {

	      for (var mask = data[j], i = baseIndex; mask !== 0; mask >>>= 1, ++i) {

	        if ((mask & 1) !== 0) result[writeOffset++] = i;
	      }baseIndex += 32;
	    }

	    return result;
	  }

	};

	BitSet._ByteBitCount = function () {

	  var lut = new Uint8Array(256);

	  for (var i = 0; i !== 256; ++i) {

	    var value = 0;
	    for (var m = i; m !== 0; m >>>= 1) {
	      if ((m & 1) !== 0) ++value;
	    }lut[i] = value;
	  }

	  return lut;
	}();

/***/ },
/* 215 */
/*!*******************************************************!*\
  !*** ./src/polyMesh/geometric/transient/Selection.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Selection;

	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	var _PolyMaps = __webpack_require__(/*! ../model/PolyMaps */ 201);

	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

	var _ScalarBuffer = __webpack_require__(/*! ../../generic/container/ScalarBuffer */ 200);

	var _ScalarBuffer2 = _interopRequireDefault(_ScalarBuffer);

	var _BitSet = __webpack_require__(/*! ../../generic/container/BitSet */ 214);

	var _BitSet2 = _interopRequireDefault(_BitSet);

	var _IndexMappings = __webpack_require__(/*! ../../generic/algorithm/IndexMappings */ 204);

	var _IndexMappings2 = _interopRequireDefault(_IndexMappings);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function Selection(indices, meaning, optionalMapId) {

	  this.indices = indices;
	  this.meaning = meaning;
	  this.mapId = optionalMapId || _PolyMaps2.default.IdPositions;
	};

	Selection.Faces = 0;
	Selection.Vertices = 1;
	Selection.Edges = 2;

	Selection.prototype = {

	  constructor: Selection,

	  getIndices: function getIndices(mesh, meaning, optionalMapId) {

	    var indices = this.indices,
	        convTab = Selection.ConversionTable,
	        convFunc = convTab[this.meaning][meaning];

	    if (convFunc !== null) indices = convFunc.call(null, mesh, indices, this.mapId, optionalMapId || _PolyMaps2.default.IdPositions);

	    return indices;
	  }

	};

	Selection.newRandomSelection = function (seed, density, polyMesh, meaning, optionalMapId) {

	  var n = Selection.getNumElements(polyMesh, meaning, optionalMapId),
	      nPopulation = density * n | 0,
	      bits = new _BitSet2.default(n).fill(0, nPopulation),
	      prng = seed;

	  for (var i = 0, e = n - 1; i < e; ++i) {

	    // Magic constants taken from
	    // https://en.wikipedia.org/wiki/Linear_congruential_generator
	    prng = prng * 22695477 + 1 >>> 0;

	    bits.swap(i, i + (prng & 0x3fffffff) % (n - i));
	  }

	  return new Selection(bits.toIndexArray(), meaning, optionalMapId);
	};

	// Provides an identity mapping in case a selection is not provided:

	Selection.getIndices = function (mesh, meaning, optionalSelectionOrMapId, optionalSelection) {

	  var mapId = _PolyMaps2.default.IdPositions,
	      selection = optionalSelection;

	  if (typeof optionalSelectionOrMapId === 'string') mapId = optionalSelectionOrMapId;else selection = optionalSelectionOrMapId;

	  return !selection ? _IndexMappings2.default.identityForReading(Selection.getNumElements(mesh, meaning, mapId)) : selection.getIndices(mesh, meaning, mapId);
	};

	Selection.getNumElements = function (mesh, meaning, optionalMapId) {

	  switch (meaning) {

	    case Selection.Faces:
	      return mesh.getNumFaces();

	    case Selection.Vertices:
	      return _PolyMaps2.default.resolveMap(mesh, optionalMapId || _PolyMaps2.default.IdPositions).values.length;

	    case Selection.Edges:
	      return _PolyMaps2.default.resolveMap(mesh, optionalMapId || _PolyMaps2.default.IdPositions).getNumEdges();

	    default:
	      throw Error('Bad meaning argument!');
	  }
	};

	// Conversions:

	Selection.convFacesToVertices = function (mesh, indices, _, mapId) {

	  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapId),
	      result = new _BitSet2.default(mapOut.values.length),
	      faceRangeOffsets = mesh.faceRangeOffsets,
	      mapValueIndices = mapOut.faceValueIndices;

	  for (var i = 0, n = indices.length; i !== n; ++i) {

	    var faceIndex = indices[i],
	        begin = faceRangeOffsets[faceIndex],
	        until = faceRangeOffsets[faceIndex + 1];

	    result.includeFromArray(mapValueIndices, begin, until);
	  }

	  return result.toIndexArray();
	};

	Selection.convFacesToEdges = function (mesh, indices, _, mapId) {

	  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapId),
	      result = new _BitSet2.default(mapOut.getNumEdges()),
	      faceRangeOffsets = mesh.faceRangeOffsets,
	      mapValueIndices = mapOut.faceValueIndices;

	  for (var i = 0, n = indices.length; i !== n; ++i) {

	    var faceIndex = indices[i],
	        begin = faceRangeOffsets[faceIndex],
	        until = faceRangeOffsets[faceIndex + 1];

	    if (begin !== until) {

	      var vertexA = mapValueIndices[until - 1];

	      for (var j = begin; j !== until; ++j) {

	        var vertexB = mapValueIndices[j];
	        result.include(mapOut.findEdgeId(vertexA, vertexB));
	        vertexA = vertexB;
	      }
	    }
	  }

	  return result.toIndexArray();
	};

	//

	Selection.convVerticesToFaces = function (mesh, indices, mapId, _) {

	  var buffer = new _ScalarBuffer2.default(Uint32Array),
	      faceRangeOffsets = mesh.faceRangeOffsets,
	      mapValueIndices = _PolyMaps2.default.resolveMap(mesh, mapId).faceValueIndices,
	      nFaces = mesh.getNumFaces();

	  for (var faceIndex = 0; faceIndex !== nFaces; ++faceIndex) {

	    var begin = faceRangeOffsets[faceIndex],
	        until = faceRangeOffsets[faceIndex + 1],
	        allVerticesFound = true;

	    for (var i = begin; i !== until && allVerticesFound; ++i) {

	      allVerticesFound = -1 < _Arrays2.default.binarySearch(indices, mapValueIndices[i]);
	    }if (allVerticesFound) buffer.push(faceIndex);
	  }

	  return buffer.toArrayAndClear();
	};

	Selection.convVerticesToVertices = function (mesh, indices, mapIdIn, mapIdOut) {

	  if (mapIdIn === mapIdOut) return indices;

	  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapIdOut),
	      result = new _BitSet2.default(mapOut.values.length),
	      mapOutValueIndices = mapOut.faceValueIndices,
	      mapIn = _PolyMaps2.default.resolveMap(mesh, mapIdIn).updateInverseIndex(),
	      faceIndexOffsets = mapIn.valueFaceIndexOffsets,
	      faceIndices = mapIn.valueFaceIndices;

	  for (var i = 0, n = indices.length; i !== n; ++i) {

	    var mapInValueIndex = indices[i],
	        facesBegin = faceIndexOffsets[mapInValueIndex],
	        facesUntil = faceIndexOffsets[mapInValueIndex + 1];

	    for (var j = facesBegin; j !== facesUntil; ++j) {

	      var vertexOffset = mapIn.findValueIndexOffset(faceIndices[j], mapInValueIndex);

	      result.include(mapOutValueIndices[vertexOffset]);
	    }
	  }

	  return result.toIndexArray();
	};

	Selection.convVerticesToEdges = function (mesh, indices, mapIdIn, mapIdOut) {

	  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapIdOut),
	      result = new _BitSet2.default(mapOut.getNumEdges()),
	      faceRangeOffsets = mesh.faceRangeOffsets,
	      mapValueIndices = _PolyMaps2.default.resolveMap(mesh, mapIdIn).faceValueIndices,
	      nFaces = mesh.getNumFaces();

	  for (var faceIndex = 0; faceIndex !== nFaces; ++faceIndex) {

	    var begin = faceRangeOffsets[faceIndex],
	        until = faceRangeOffsets[faceIndex + 1];

	    if (begin !== until) {

	      var last = mapValueIndices[--until],
	          lastSelected = -1 < _Arrays2.default.binarySearch(indices, last),
	          vertexA = last,
	          prevSelected = lastSelected;

	      for (var j = begin; j !== until; ++j) {

	        var vertexB = mapValueIndices[j],
	            selected = -1 < _Arrays2.default.binarySearch(indices, vertexB);

	        if (prevSelected && selected) result.include(mapOut.findEdgeId(vertexA, vertexB));

	        vertexA = vertexB;
	        prevSelected = selected;
	      }

	      if (prevSelected && lastSelected) result.include(mapOut.findEdgeId(vertexA, last));
	    }
	  }

	  return result.toIndexArray();
	};

	//

	Selection.convEdgesToFaces = function (mesh, indices, mapIdIn, _) {

	  var tmp = Selection.convEdgesToVertices(mesh, indices, mapIdIn, mapIdIn);

	  return Selection.convVerticesToFaces(mesh, tmp, mapIdIn, '');
	};

	Selection.convEdgesToVertices = function (mesh, indices, mapIdIn, mapIdOut) {

	  var tmp = Selection.convEdgesToVerticesOfSameMap(mesh, indices, mapIdIn);

	  return Selection.convVerticesToVertices(mesh, tmp, mapIdIn, mapIdOut);
	};

	Selection.convEdgesToEdges = function (mesh, indices, mapIdIn, mapIdOut) {

	  if (mapIdIn === mapIdOut) return indices;

	  var tmp = Selection.convEdgesToVerticesOfSameMap(mesh, indices, mapIdIn);

	  return Selection.convVerticesToEdges(mesh, indices, mapIdIn, mapIdOut);
	};

	Selection.convEdgesToVerticesOfSameMap = function (mesh, indices, mapId) {

	  var map = _PolyMaps2.default.resolveMap(mesh, mapId).updateEdgeMap(),
	      edgeRangeOffsets = map.edgePivotRangeOffsets,
	      highVertexIndices = map.edgeHighVertexIndices,
	      result = new _BitSet2.default(map.values.length);

	  for (var i = 0, n = indices.length; i !== n; ++i) {

	    var edgeId = indices[i],
	        hiVertex = highVertexIndices[edgeId],
	        searchResult = _Arrays2.default.binarySearch(edgeRangeOffsets, edgeId + 1);

	    if (searchResult < 0) searchResult = ~searchResult;

	    var loVertex = searchResult - 1;

	    result.include(hiVertex);
	    result.include(loVertex);
	  }

	  return result.toIndexArray();
	};

	Selection.ConversionTable = [

	// From Faces to...
	[
	// ... Faces
	null,
	// ... Vertices
	Selection.convFacesToVertices,
	// ... Edges
	Selection.convFacesToEdges],
	// From Vertices to...
	[
	// ... Faces
	Selection.convVerticesToFaces,
	// ... Vertices
	Selection.convVerticesToVertices,
	// ... Edges
	Selection.convVerticesToEdges],
	// From Edges to...
	[
	// ... Faces
	Selection.convEdgesToFaces,
	// ... Vertices
	Selection.convEdgesToVertices,
	// ... Edges
	Selection.convEdgesToEdges]];

/***/ },
/* 216 */
/*!*******************************************!*\
  !*** ./src/polyMesh/three/ThreeExport.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _PolyMaps = __webpack_require__(/*! ../geometric/model/PolyMaps */ 201);

	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

	var _Exporter = __webpack_require__(/*! ../geometric/tool/Exporter */ 217);

	var _Exporter2 = _interopRequireDefault(_Exporter);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ThreeExport = {

	  NoIndices: 0,
	  SimpleIndices: 1,
	  CompactIndices: 2,

	  exportBufferGeometry: function exportBufferGeometry(polyMesh, indicesMode, interleaved, exportTangents, oldMesh, prevTriangulation, prevIndexing, prevValueMap) {
	    var result = new THREE.BufferGeometry(),
	        exportSpec = [],
	        _ThreeExport$_prepare = ThreeExport._prepare(polyMesh, exportSpec, indicesMode, interleaved, exportTangents, oldMesh, prevTriangulation, prevIndexing),
	        exporter = _ThreeExport$_prepare.exporter,
	        triangulationChanged = _ThreeExport$_prepare.triangulationChanged,
	        IdPositions = _PolyMaps2.default.IdPositions,
	        valueMap = {};


	    if (indicesMode !== ThreeExport.NoIndices) {

	      var indices = indicesMode === ThreeExport.SimpleIndices ? exporter.getTriangulatingIndices() : exporter.getMapIndices(IdPositions);

	      result.setIndex(new THREE.BufferAttribute(indices, 1, false));
	    }

	    if (!interleaved) {

	      for (var i = 0; i !== exportSpec.length; ++i) {

	        //console.log(indicesMode);

	        var attrSpec = exportSpec[i],
	            triangulateValues = indicesMode === ThreeExport.NoIndices;

	        var data;
	        var newMap = _PolyMaps2.default.resolveMap(polyMesh, attrSpec.mapId),
	            oldMap = oldMesh && _PolyMaps2.default.resolveMap(oldMesh, attrSpec.mapId);

	        if (oldMap !== newMap || !prevValueMap) {
	          data = indicesMode !== ThreeExport.CompactIndices ? exporter.getUnindexedMapValues(attrSpec.mapId, triangulateValues) : exporter.getMapValues(attrSpec.mapId);
	        } else {
	          //console.log('skip');
	          data = prevValueMap[attrSpec.mapId];
	        }

	        valueMap[attrSpec.mapId] = data;
	        result.addAttribute(attrSpec.threeName, new THREE.BufferAttribute(data, attrSpec.itemSize, attrSpec.normalized));
	      }
	    } else {

	      var stride = 0;
	      for (var i = 0; i !== exportSpec.length; ++i) {
	        stride += exportSpec[i].itemSize;
	      }var nValuess = 0;
	      switch (indicesMode) {

	        case ThreeExport.NoIndices:
	          // no. of triangulated vertices
	          nValuess = exporter.getNumFaceVertices();
	          break;

	        case ThreeExport.SimpleIndices:
	          // no. of values
	          nValuess = exporter.mesh.getNumFaceVertices();
	          break;

	        case ThreeExport.CompactIndices:
	          // as calculated
	          nValuess = exporter.getNumMapValues(_PolyMaps2.default.IdPositions);
	      }

	      var data = new Float32Array(stride * nValuess),
	          buffer = new THREE.InterleavedBuffer(data, stride),
	          offset = 0;

	      for (var i = 0; i !== exportSpec.length; ++i) {

	        var attrSpec = exportSpec[i],
	            itemSize = attrSpec.itemSize,
	            mapId = attrSpec.mapId;

	        if (indicesMode !== ThreeExport.CompactIndices) {

	          exporter.getUnindexedMapValues(mapId, indicesMode === ThreeExport.NoIndices, data, offset, stride);
	        } else {

	          exporter.getMapValues(mapId, data, offset, stride);
	        }

	        result.addAttribute(attrSpec.threeName, new THREE.InterleavedBufferAttribute(buffer, itemSize, offset));

	        offset += itemSize;
	      }
	    }
	    // add group to buffer geometry if there is materialId list in polymesh
	    var groups = exporter.getGroups();
	    if (polyMesh.materialIds && groups) {
	      for (var i = 0; i < groups.groupCounts.length; i++) {
	        if (groups.groupCounts[i] > 0) {
	          result.addGroup(groups.groupStarts[i], groups.groupCounts[i], i);
	        }
	      }
	    }
	    return {
	      geometry: result,
	      triangulation: exporter.triangulation,
	      renderIndexing: exporter.renderIndexing,
	      triangulationChanged: triangulationChanged,
	      valueMap: valueMap
	    };
	  },

	  _prepare: function _prepare(polyMesh, outSpec, indicesMode, interleaved, exportTangents, oldMesh, prevTriangulation, prevIndexing) {

	    var exporter = new _Exporter2.default(polyMesh),
	        mapsToExport = [];

	    var retriangulate = !oldMesh || !prevTriangulation || oldMesh.positions.faceValueIndices !== polyMesh.positions.faceValueIndices;
	    var reIndex = !oldMesh || !prevIndexing;

	    var mapOffset = 0;
	    //console.log(polyMesh);
	    for (var iter = new _PolyMaps2.default.Iterator(polyMesh); iter.next();) {

	      var threeName = '',
	          itemSize = 3,
	          normalized = false;

	      switch (iter.typeId) {

	        case _PolyMaps2.default.TypePosition:
	          threeName = 'position';
	          break;

	        case _PolyMaps2.default.TypeTangent:
	          // Note: Since tangents are normally ignored by the three.js
	          // renderer, they must be requested explicitly.
	          if (!exportTangents) break;
	          threeName = 'tangent';
	          break;

	        case _PolyMaps2.default.TypeNormal:
	          threeName = 'normal';
	          break;

	        case _PolyMaps2.default.TypeUV:
	          if (iter.index >= 2) break; // max two UV maps
	          threeName = 'uv' + (iter.index !== 0 ? iter.index + 1 : '');
	          itemSize = 2;
	          break;

	        case _PolyMaps2.default.TypeColor:

	          if (iter.index >= 1) break; // use first color map
	          threeName = 'color';
	          normalized = true;

	      }

	      if (!threeName || interleaved && normalized) continue;

	      var mapId = iter.getId();
	      mapsToExport.push(mapId);

	      outSpec.push({
	        mapId: mapId,
	        threeName: threeName,
	        itemSize: itemSize,
	        normalized: normalized
	      });
	      ++mapOffset;
	    }

	    for (var i = 0; i < outSpec.length && !reIndex; i++) {
	      var oldMap = _PolyMaps2.default.resolveMap(oldMesh, outSpec[i].mapId),
	          newMap = _PolyMaps2.default.resolveMap(polyMesh, outSpec[i].mapId);
	      if (oldMap.faceValueIndices !== newMap.faceValueIndices) reIndex = true;
	    }

	    //console.log(polyMesh===(prevData && prevData.mesh));
	    if (indicesMode === ThreeExport.CompactIndices && !reIndex) {
	      prevIndexing.mesh = polyMesh;
	      exporter.renderIndexing = prevIndexing;
	    } else if (indicesMode === ThreeExport.CompactIndices && reIndex) {

	      exporter.reindexForRendering(mapsToExport);
	    }

	    var triangulationChanged = false;
	    if (retriangulate) {
	      exporter.triangulate();
	      triangulationChanged = true;
	    } else {
	      exporter.triangulation = prevTriangulation;
	    }

	    return { exporter: exporter, triangulationChanged: triangulationChanged };
	  }

	};

	exports.default = ThreeExport;

/***/ },
/* 217 */
/*!*************************************************!*\
  !*** ./src/polyMesh/geometric/tool/Exporter.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Exporter;

	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 191);

	var _Arrays2 = _interopRequireDefault(_Arrays);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ScalarArrayView = __webpack_require__(/*! ../../generic/container/ScalarArrayView */ 199);

	var _ScalarArrayView2 = _interopRequireDefault(_ScalarArrayView);

	var _IndexMappings = __webpack_require__(/*! ../../generic/algorithm/IndexMappings */ 204);

	var _IndexMappings2 = _interopRequireDefault(_IndexMappings);

	var _RenderIndexing = __webpack_require__(/*! ../algorithm/RenderIndexing */ 218);

	var _RenderIndexing2 = _interopRequireDefault(_RenderIndexing);

	var _SimpleFanTriangulation = __webpack_require__(/*! ../algorithm/SimpleFanTriangulation */ 219);

	var _SimpleFanTriangulation2 = _interopRequireDefault(_SimpleFanTriangulation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function Exporter(polyMesh) {

	  this.mesh = polyMesh;

	  this.triangulation = null;
	  this.renderIndexing = null;
	};

	Exporter.prototype = {

	  constructor: Exporter,

	  reindexForRendering: function reindexForRendering(optionalMapIdWhitelist) {

	    if (this.triangulation !== null) throw Error('Reindex must come before triangulation!');

	    this.renderIndexing = new _RenderIndexing2.default(this.mesh, optionalMapIdWhitelist);

	    return this;
	  },

	  triangulate: function triangulate(optionalTriangulationType) {

	    var triangulationType = optionalTriangulationType || _SimpleFanTriangulation2.default;

	    this.triangulation = new triangulationType(this.mesh, this.renderIndexing);

	    return this;
	  },

	  getNumFaces: function getNumFaces() {

	    var triangulation = this.triangulation;

	    return triangulation === null ? this.mesh.getNumFaces() : triangulation.numTriangles;
	  },

	  getNumFaceVertices: function getNumFaceVertices() {

	    return this.triangulation === null ? this.mesh.getNumFaceVertices() : this.getNumFaces() * 3;
	  },

	  getNumMapValues: function getNumMapValues(mapId) {

	    var renderIndexing = this.renderIndexing;

	    return renderIndexing !== null ? renderIndexing.numVertices : this.mesh.getMapById(mapId).values.length;
	  },

	  getFaceArities: function getFaceArities(optionalArrayOrType, optionalOffset, optionalStride) {

	    if (this.triangulation !== null) throw Error('No face arity export for triangular meshes!');

	    var result = new _ScalarArrayView2.default(this.getNumFaces(), optionalArrayOrType, optionalOffset, optionalStride),
	        offsets = this.mesh.faceRangeOffsets,
	        nOffsets = offsets.length;

	    if (nOffsets > 1) {

	      var prevOffset = offsets[0];

	      for (var i = 1; i !== nOffsets; ++i) {

	        var offset = offsets[i];
	        result.setAt(i - 1, offset - prevOffset);
	        prevOffset = offset;
	      }
	    }

	    return result.data;
	  },

	  getMaterialIds: function getMaterialIds(optionalArrayOrType, optionalOffset, optionalStride) {

	    var result = null,
	        source = this.mesh.materialIDs;

	    if (source === null) return null;

	    if (this.triangulation === null) {

	      var offset = optionalOffset || 0,
	          stride = optionalStride || 1,
	          arrayOrType = optionalArrayOrType || source.data.constructor;

	      if (offset === 0 && stride === 1 && arrayOrType === source.data.constructor) return source;

	      result = new _ScalarArrayView2.default(source.length, arrayOrType, offset, stride);

	      result.fromArray(source);
	    } else {

	      this.triangulation.translateMaterialIds(source, result);
	    }

	    return result.data;
	  },

	  getMapValues: function getMapValues(mapId, optionalArrayOrType, optionalOffset, optionalStride) {

	    var result = null,
	        renderIndexing = this.renderIndexing,
	        source = this.mesh.getMapById(mapId).values,
	        type = source.type,
	        offset = optionalOffset || 0,
	        stride = optionalStride || type.InstanceScalarSize,
	        arrayOrType = optionalArrayOrType || source.data.constructor;

	    if (renderIndexing === null && offset === 0 && stride === type.InstanceScalarSize && arrayOrType === source.data.constructor) result = source; // compatible format, just expose the data

	    else {

	        var length = renderIndexing === null ? source.length : renderIndexing.numVertices;

	        result = this._offsetObjects(type, length, arrayOrType, offset, stride);

	        if (renderIndexing !== null) {

	          renderIndexing.getMapValues(mapId, result);
	        } else {

	          result.fromArray(source.data);
	        }
	      }

	    return result.data;
	  },
	  getGroups: function getGroups() {
	    var triangulation = this.triangulation;
	    var result = triangulation.groups;
	    return result;
	  },
	  getMapIndices: function getMapIndices(mapId, optionalArrayOrType, optionalOffset, optionalStride) {

	    var result = null,
	        renderIndexing = this.renderIndexing,
	        triangulation = this.triangulation,
	        source = renderIndexing !== null ? renderIndexing.renderIndices : this.mesh.getMapById(mapId).faceValueIndices;

	    if (triangulation === null) {

	      var offset = optionalOffset || 0,
	          stride = optionalStride || 1,
	          arrayOrType = optionalArrayOrType || source.constructor;

	      if (offset === 0 && stride === 1 && arrayOrType === source.constructor) return source;

	      result = new _ScalarArrayView2.default(source.length, arrayOrType, offset, stride);

	      result.fromArray(source);
	    } else {

	      result = new _ScalarArrayView2.default(this.triangulation.numTriangles * 3, optionalArrayOrType, optionalOffset, optionalStride);

	      triangulation.translateIndices(source, result);
	    }

	    return result.data;
	  },

	  getUnindexedMapValues: function getUnindexedMapValues(mapId, allowTriangulation, optionalArrayOrType, optionalOffset, optionalStride) {

	    var result = null,
	        polyMap = this.mesh.getMapById(mapId),
	        values = polyMap.values,
	        valueType = values.type,
	        indices = polyMap.faceValueIndices,
	        triangulation = this.triangulation;

	    if (!allowTriangulation || triangulation === null) {

	      result = this._offsetObjects(valueType, indices.length, optionalArrayOrType || values.data.constructor, optionalOffset, optionalStride);

	      var temp = values.newRangeArray(1);

	      for (var i = 0, n = indices.length; i !== n; ++i) {

	        result.arrayToRange(values.rangeToArray(indices[i], 1, temp), i, 1);
	      }
	    } else {

	      result = this._offsetObjects(valueType, triangulation.numTriangles * 3, optionalArrayOrType || values.data.constructor, optionalOffset, optionalStride);

	      triangulation.translateToUnindexedValues(values, result, indices);
	    }

	    return result.data;
	  },

	  getTriangulatingIndices: function getTriangulatingIndices(optionalArrayOrType, optionalOffset, optionalStride) {

	    var triangulation = this.triangulation;

	    if (triangulation === null) return null;

	    var result = new _ScalarArrayView2.default(this.getNumFaceVertices(), optionalArrayOrType, optionalOffset, optionalStride),
	        nFaceVertices = this.getNumFaceVertices(),
	        identityMap = _IndexMappings2.default.identityForReading(nFaceVertices);

	    triangulation.translateIndices(identityMap, result);

	    return result.data;
	  },

	  _offsetObjects: function _offsetObjects(type, length, arrayOrType, optionalOffset, optionalStride) {

	    var offset = optionalOffset || 0,
	        stride = optionalStride || type.InstanceScalarSize,
	        offsetLength = offset / stride | 0,
	        minArrayLength = (offsetLength + length) * stride,
	        array = _Arrays2.default.maybeCreate(arrayOrType, minArrayLength),
	        offsetView = offset === 0 ? array : array.subarray(offset);

	    return new _ObjectArrayView2.default(type, null, offsetView, stride);
	  }

	};

/***/ },
/* 218 */
/*!************************************************************!*\
  !*** ./src/polyMesh/geometric/algorithm/RenderIndexing.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = RenderIndexing;

	var _PolyMaps = __webpack_require__(/*! ../model/PolyMaps */ 201);

	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function RenderIndexing(polyMesh, optionalMapIdWhitelist) {

	  var mapIds = [],
	      mapStates = [];

	  for (var iter = new _PolyMaps2.default.Iterator(polyMesh); iter.next();) {

	    var map = iter.element,
	        mapId = iter.getId();

	    if (optionalMapIdWhitelist && optionalMapIdWhitelist.indexOf(mapId) === -1) continue;

	    mapIds.push(mapId);

	    mapStates.push({
	      map: map,
	      faceIndices: map.updateInverseIndex().valueFaceIndices,
	      facesOffset: 0
	    });
	  }

	  // Processing face vertices, an n-way MERGE-like step is performed to
	  // identify a previously processed face that uses the same combination
	  // of value indices. Forward processing and the sorted nature of the
	  // inverse PolyMap indices allow this algorithm to be very efficient.

	  var nFaceVertices = polyMesh.getNumFaceVertices(),
	      nMaps = mapStates.length,
	      renderIndices = new Uint32Array(nFaceVertices),
	      valueIndices = new Uint32Array(nFaceVertices * nMaps),
	      writeOffset = 0,
	      nVertices = 0,
	      faceRangeOffsets = polyMesh.faceRangeOffsets,
	      faceIndex = -1,
	      nextFaceStart = 0,
	      pivotState = mapStates[nMaps - 1],
	      pivotFaces = pivotState.faceIndices,
	      mapScanStart = nMaps - 2;

	  for (var i = 0; i !== nFaceVertices; ++i) {

	    if (i === nextFaceStart) nextFaceStart = faceRangeOffsets[++faceIndex + 1];

	    // Try to find a face before this one that already uses all the
	    // values for this vertex:

	    var reusePossible = true,
	        reuseFromFace = 0;

	    for (var j = 0; j !== nMaps; ++j) {

	      var mapState = mapStates[j],
	          map = mapState.map,
	          valueIndex = map.faceValueIndices[i];

	      // Speculatively write data:
	      valueIndices[writeOffset + j] = valueIndex;

	      if (reusePossible) {

	        var facesBegin = map.valueFaceIndexOffsets[valueIndex],
	            firstFaceIndex = map.valueFaceIndices[facesBegin];

	        // Speculatively prepare the scanning state:
	        mapState.facesOffset = facesBegin;

	        // Early-out when a value index is used for the first time:
	        reusePossible = firstFaceIndex !== faceIndex;
	      }
	    }

	    if (reusePossible) {

	      var pivotFaceIdxPos = pivotState.facesOffset,
	          pivotFaceIndex = 0,
	          pivotFaceGood = true;

	      do {

	        pivotFaceIndex = pivotFaces[pivotFaceIdxPos++];
	        pivotFaceGood = pivotFaceIndex !== faceIndex;
	        reusePossible = pivotFaceGood;

	        for (var j = mapScanStart; pivotFaceGood && j !== -1; --j) {

	          var mapState = mapStates[j],
	              faceIdxPos = mapState.facesOffset,
	              faceIndices = mapState.faceIndices,
	              candidate = faceIndices[faceIdxPos];

	          while (candidate < pivotFaceIndex) {
	            candidate = faceIndices[++faceIdxPos];
	          }if (candidate !== pivotFaceIndex) pivotFaceGood = false;
	          if (candidate === faceIndex) reusePossible = false;else mapState.facesOffset = faceIdxPos;

	          // Note that the next pivot face will have a higher index
	          // and that we'll see the current face when out of input.
	          // Also note that the pivot face has a lower index than
	          // the current face.
	        }
	      } while (reusePossible && !pivotFaceGood);

	      reusePossible = pivotFaceGood;
	      reuseFromFace = pivotFaceIndex;
	    }

	    if (reusePossible) {

	      var positionMap = mapStates[0].map,
	          faceVertexIndex = positionMap.findValueIndexOffset(reuseFromFace, positionMap.faceValueIndices[i]),
	          reuseIndex = renderIndices[faceVertexIndex];

	      renderIndices[i] = reuseIndex;
	    } else {

	      renderIndices[i] = nVertices++;
	      writeOffset += nMaps;
	    }
	  }

	  this.mesh = polyMesh;
	  this.mapIds = mapIds;
	  this.renderIndices = renderIndices;
	  this.valueIndices = valueIndices.slice(0, writeOffset);
	  this.numVertices = nVertices;
	};

	RenderIndexing.prototype = {

	  constructor: RenderIndexing,

	  getMapValues: function getMapValues(mapId, targetView) {

	    var mapIds = this.mapIds,
	        mapIndex = mapIds.indexOf(mapId),
	        nVertices = this.numVertices,
	        valueIndices = this.valueIndices;

	    if (mapIndex === -1) throw Error("Map with id '" + mapId + "' not found!");

	    var map = _PolyMaps2.default.resolveMap(this.mesh, mapId),
	        mapValues = map.values;

	    if (targetView.length < nVertices) throw Error("Data won't fit!");

	    var viOffset = mapIndex,
	        viStride = mapIds.length,
	        tmp = new targetView.type();

	    for (var i = 0; i !== nVertices; ++i) {

	      var valueIndex = valueIndices[viOffset + i * viStride];
	      targetView.setAt(i, mapValues.getAt(valueIndex, tmp));
	    }
	  }

	};

/***/ },
/* 219 */
/*!********************************************************************!*\
  !*** ./src/polyMesh/geometric/algorithm/SimpleFanTriangulation.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = SimpleFanTriangulation;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function SimpleFanTriangulation(mesh) {

	  this.mesh = mesh;
	  this.groups = null;
	  var nTriangles = 0,
	      faceOffsets = mesh.faceRangeOffsets,
	      faceBegin = faceOffsets[0],
	      maxNumVerticesPerFace = 0;;

	  for (var i = 1, n = faceOffsets.length; i < n; ++i) {

	    var faceUntil = faceOffsets[i],
	        nVertices = faceUntil - faceBegin;

	    if (nVertices >= 3) nTriangles += nVertices - 2;

	    maxNumVerticesPerFace = Math.max(maxNumVerticesPerFace, nVertices);

	    faceBegin = faceUntil;
	  }

	  this.startFaceIndices = this.getStartFaceIndices(mesh.positions, maxNumVerticesPerFace);
	  //console.log( 'this.startFaceIndices', this.startFaceIndices );

	  this.numTriangles = nTriangles;
	};

	SimpleFanTriangulation.prototype = {

	  constructor: SimpleFanTriangulation,

	  getStartFaceIndices: function getStartFaceIndices(positionsPolyMap, maxNumVerticesPerFace) {

	    //return an array of size faces, that says which face vertex index to use as the starting vertex in simple fan triangulation.
	    // you will want return the first convex vertex face vertex index (in the range 0 to number of vertices in that face), if there is one
	    // otherwise you can return 0.

	    var faceOffsets = this.mesh.faceRangeOffsets;

	    var numFaces = this.mesh.faceRangeOffsets.length - 1;
	    var startFaceIndices = new Uint32Array(numFaces);
	    var faceEdgeSign = new Float32Array(maxNumVerticesPerFace);

	    var faceValueIndices = positionsPolyMap.faceValueIndices;
	    var positionValues = positionsPolyMap.values;

	    var dPrev = new THREE.Vector3();
	    var d = new THREE.Vector3();
	    var dNext = new THREE.Vector3();
	    var dTemp;

	    var pPrev = new THREE.Vector3();
	    var p = new THREE.Vector3();
	    var pNext = new THREE.Vector3();
	    var pNextNext = new THREE.Vector3();
	    var pTemp;

	    var cpTemp;
	    var cp = new THREE.Vector3();
	    var cpNext = new THREE.Vector3();

	    for (var i = 0, il = faceOffsets.length - 1; i < il; ++i) {

	      var faceBegin = faceOffsets[i];
	      var faceUntil = faceOffsets[i + 1];
	      var numFaceVertices = faceUntil - faceBegin;

	      if (numFaceVertices <= 3) {
	        continue;
	      }

	      var vPrev;
	      var v = faceValueIndices[faceBegin + (numFaceVertices - 1)];
	      var vNext = faceValueIndices[faceBegin];
	      var vNextNext = faceValueIndices[faceBegin + 1 % numFaceVertices];

	      positionValues.getAt(v, p);
	      positionValues.getAt(vNext, pNext);
	      positionValues.getAt(vNextNext, pNextNext);

	      d.copy(pNext).sub(p);
	      dNext.copy(pNextNext).sub(pNext);

	      cpNext.copy(dNext).cross(d);

	      for (var j = 0; j < numFaceVertices; ++j) {

	        vPrev = v;
	        v = vNext;
	        vNext = vNextNext;
	        vNextNext = faceValueIndices[faceBegin + (j + 2) % numFaceVertices];

	        pTemp = pPrev;
	        pPrev = p;
	        p = pNext;
	        pNext = pNextNext;
	        pNextNext = pTemp;
	        positionValues.getAt(vNextNext, pNextNext);

	        dTemp = dPrev;
	        dPrev = d;
	        d = dNext;
	        dNext = dTemp;
	        dNext.copy(pNextNext).sub(pNext);

	        cpTemp = cp;
	        cp = cpNext;
	        cpNext = cpTemp;
	        cpNext.copy(dNext).cross(d);

	        var sign = cp.dot(cpNext);

	        faceEdgeSign[j] = sign;
	      }

	      //console.log( 'faceEdgeSign for face: ', i, faceEdgeSign );

	      for (var j = 0; j < numFaceVertices; ++j) {
	        var sign = faceEdgeSign[j];
	        var signNext = faceEdgeSign[(j + 1) % numFaceVertices];
	        if (sign >= 0 && signNext >= 0) {
	          startFaceIndices[i] = (j + 1) % numFaceVertices;
	          break;
	        }
	      }
	    }

	    return startFaceIndices;
	  },

	  translateIndices: function translateIndices(inputArray, outputView) {

	    var faceOffsets = this.mesh.faceRangeOffsets,
	        outputArray = outputView.data,
	        writeIndex = outputView.offset,
	        stride = outputView.stride;

	    var materialIds = null;
	    var polygonOrder = null;
	    var groupMin = null;
	    var groupMax = null;

	    // if multi-materials, sort polygons in material order and create material groups
	    if (this.mesh.materialIds) {

	      materialIds = this.mesh.materialIds;

	      var numPolygons = faceOffsets.length - 1;
	      var polygonOrder = new Uint32Array(numPolygons);
	      for (var i = 0; i < polygonOrder.length; i++) {
	        polygonOrder[i] = i;
	      }

	      polygonOrder.sort(function (a, b) {
	        return materialIds[a] - materialIds[b];
	      });

	      var numMaterials = materialIds[polygonOrder[numPolygons - 1]] + 1;

	      groupMin = new Uint32Array(numMaterials);
	      for (var i = 0; i < numMaterials; i++) {
	        groupMin[i] = outputArray.length;
	      }
	      groupMax = new Uint32Array(numMaterials);
	    }

	    for (var i = 0; i < this.startFaceIndices.length; ++i) {

	      var polygonIndex = i;
	      if (polygonOrder) {
	        polygonIndex = polygonOrder[i];
	      }

	      var startOffset = this.startFaceIndices[polygonIndex];
	      var startIndex = faceOffsets[polygonIndex];
	      var endIndex = faceOffsets[polygonIndex + 1];
	      var polygonLength = endIndex - startIndex;

	      for (var j = 0; j < polygonLength - 2; ++j) {

	        if (materialIds) {
	          var materialId = materialIds[polygonIndex];
	          groupMin[materialId] = Math.min(groupMin[materialId], writeIndex);
	          groupMax[materialId] = Math.max(groupMax[materialId], writeIndex + stride * 2);
	        }

	        outputArray[writeIndex] = inputArray[startIndex + startOffset];
	        writeIndex += stride;

	        outputArray[writeIndex] = inputArray[startIndex + (startOffset + j + 1) % polygonLength];
	        writeIndex += stride;

	        outputArray[writeIndex] = inputArray[startIndex + (startOffset + j + 2) % polygonLength];
	        writeIndex += stride;
	      }
	    }

	    if (materialIds) {
	      // convert max to length in place
	      for (var i = 0; i < groupMax.length; i++) {
	        groupMax[i] = groupMax[i] - groupMin[i] + 1;
	      }
	      this.groups = {
	        groupStarts: groupMin,
	        groupCounts: groupMax
	      };
	    }
	  },

	  translateMaterialIds: function translateMaterialIds(outputView) {

	    var faceOffsets = this.mesh.faceRangeOffsets,
	        inputArray = this.mesh.materialIds,
	        faceBegin = faceOffsets[0];

	    for (var i = 1, j = 0, n = faceOffsets.length; i < n; ++i) {

	      var materialId = inputArray[i - 1],
	          faceUntil = faceOffsets[i],
	          nVertices = faceUntil - faceBegin,
	          nTriangles = nVertices >= 3 ? nVertices - 2 : 0;

	      for (var writeUntil = writeIndex + nTriangles * stride; writeIndex !== writeUntil; writeIndex += stride) {

	        outputArray[writeIndex] = materialId;
	      }faceBegin = faceUntil;
	    }
	  },

	  translateToUnindexedValues: function translateToUnindexedValues(inputView, outputView, indices) {

	    var faceOffsets = this.mesh.faceRangeOffsets,
	        writeIndex = 0,
	        temp = inputView.newRangeArray(1);

	    var materialIds = null;
	    var polygonOrder = null;
	    var groupMin = null;
	    var groupMax = null;

	    // if multi-materials, sort polygons in material order and create material groups
	    if (this.mesh.materialIds) {

	      materialIds = this.mesh.materialIds;

	      var numPolygons = faceOffsets.length - 1;
	      var polygonOrder = new Uint32Array(numPolygons);
	      for (var i = 0; i < polygonOrder.length; i++) {
	        polygonOrder[i] = i;
	      }

	      polygonOrder.sort(function (a, b) {
	        return materialIds[a] - materialIds[b];
	      });

	      var numMaterials = materialIds[polygonOrder[numPolygons - 1]] + 1;

	      groupMin = new Uint32Array(numMaterials);
	      for (var i = 0; i < numMaterials; i++) {
	        groupMin[i] = outputView.length;
	      }
	      groupMax = new Uint32Array(numMaterials);
	    }

	    for (var i = 0; i < this.startFaceIndices.length; ++i) {

	      var polygonIndex = i;
	      if (polygonOrder) {
	        polygonIndex = polygonOrder[i];
	      }

	      var startOffset = this.startFaceIndices[polygonIndex];
	      var startIndex = faceOffsets[polygonIndex];
	      var endIndex = faceOffsets[polygonIndex + 1];
	      var polygonLength = endIndex - startIndex;

	      for (var j = 0; j < polygonLength - 2; ++j) {

	        if (materialIds) {
	          var materialId = materialIds[polygonIndex];
	          groupMin[materialId] = Math.min(groupMin[materialId], writeIndex);
	          groupMax[materialId] = Math.max(groupMax[materialId], writeIndex + 2);
	        }

	        outputView.arrayToRange(inputView.rangeToArray(indices[startIndex + startOffset], 1, temp), writeIndex, 1);

	        outputView.arrayToRange(inputView.rangeToArray(indices[startIndex + (startOffset + j + 1) % polygonLength], 1, temp), writeIndex + 1, 1);

	        outputView.arrayToRange(inputView.rangeToArray(indices[startIndex + (startOffset + j + 2) % polygonLength], 1, temp), writeIndex + 2, 1);

	        writeIndex += 3;
	      }
	    }

	    if (materialIds) {
	      // convert max to length in place
	      for (var i = 0; i < groupMax.length; i++) {
	        groupMax[i] = groupMax[i] - groupMin[i] + 1;
	      }
	      this.groups = {
	        groupStarts: groupMin,
	        groupCounts: groupMax
	      };
	    }
	  }

	};

/***/ },
/* 220 */
/*!**********************************************!*\
  !*** ./src/operators/PolyMesh/MeshSmooth.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _subdivision = __webpack_require__(/*! ../../polyMesh/geometric/operator/subdivision */ 221);

	var _subdivision2 = _interopRequireDefault(_subdivision);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var MeshSmooth = {
	  schema: {
	    subdivisions: { label: 'Subdivisions', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 4 },
	    smoothByMaterialIds: { label: 'Smooth by Material Ids', type: 'Boolean', defaultValue: true }
	  },

	  update: function update(operator, primitive) {
	    var mesh = primitive.mesh;
	    var subdivisions = operator.subdivisions !== undefined ? operator.subdivisions : 1;
	    //currently we are always assuming hard edges
	    //const hardEdges = operator.hardEdges || true;
	    if (!mesh) return primitive;

	    for (var i = 0; i < subdivisions; i++) {
	      mesh = (0, _subdivision2.default)(mesh, operator.smoothByMaterialIds);
	    }

	    primitive.mesh = mesh;
	    return primitive;
	  }
	};

	exports.default = MeshSmooth;

/***/ },
/* 221 */
/*!********************************************************!*\
  !*** ./src/polyMesh/geometric/operator/subdivision.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = subdivision;

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _polyMeshValidation = __webpack_require__(/*! ./polyMeshValidation */ 222);

	var _polyMeshValidation2 = _interopRequireDefault(_polyMeshValidation);

	var _removeDuplicateNormals = __webpack_require__(/*! ./removeDuplicateNormals */ 223);

	var _removeDuplicateNormals2 = _interopRequireDefault(_removeDuplicateNormals);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function subdivision(mesh, smoothByMaterialIds) {

	  // based on theory given on pages 623-624 of "Real-Time Rendering"
	  var subdividePolyMap = function subdividePolyMap(polyMap, newFaceRangeOffsets, faceEdgeCreases, faceValueCorners) {

	    var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;
	    var valueAdjacency = polyMap.valueAdjacency;
	    var faceEdgeAdjacency = polyMap.faceEdgeAdjacency;
	    /*
	    if(!faceEdgeAdjacency.checkValidity()){
	      throw 'This polymap contains an invalid surface and cannot be subdivided. Edge Adjacency will fail.';
	    }//*/

	    var values = polyMap.values;
	    var valueType = values.type;
	    var numValues = values.length;
	    var faceRangeOffsets = polyMap.faceRangeOffsets;
	    var numFaces = faceRangeOffsets.length - 1;
	    var faceValueIndices = polyMap.faceValueIndices;
	    var numEdges = edgeVertexAdjacency.getNumEdges();
	    var numNewFaces = faceValueIndices.length;

	    var vertexCorners = new Uint8Array(polyMap.values.length);
	    for (var i = 0; i < faceValueCorners.length; i++) {
	      vertexCorners[faceValueIndices[i]] = faceValueCorners[i];
	    }

	    if (!newFaceRangeOffsets) {
	      newFaceRangeOffsets = new Uint32Array(numNewFaces + 1);
	      for (var f = 0; f < newFaceRangeOffsets.length; f++) {
	        newFaceRangeOffsets[f] = f * 4;
	      }
	    }

	    var numNewFaceValueIndices = numNewFaces * 4;
	    var newFaceValueIndices = new Uint32Array(numNewFaceValueIndices);

	    // pre allocate all new vertices
	    //    updated vertices (V) + edge centroids (E) + face centroids (V)
	    var edgeOffset = numValues;
	    var faceOffset = edgeOffset + numEdges;
	    var numNewValues = numValues + numEdges + numFaces;
	    var newValues = new _ObjectArrayView2.default(valueType, numNewValues);

	    var valueEdgeValence = new Uint8Array(numValues);
	    var valueFaceValence = new Uint8Array(numValues);
	    var edgeFaceValence = new Uint8Array(numEdges);
	    var edgeUnique = new Uint8Array(numEdges);

	    var tempFaceCentroid = new valueType();
	    var tempValue = new valueType();
	    var tempNextValue = new valueType();
	    var tempEdgeCentroid = new valueType();
	    var tempConnectedValue = new valueType();
	    var tempConnectedFace = new valueType();

	    var nf = 0;

	    var edgeCreases = new Uint8Array(numEdges);
	    var valueCreases = new Uint8Array(numValues);

	    for (var _f = 0; _f < numFaces; _f++) {

	      var faceBegin = faceRangeOffsets[_f];
	      var faceUntil = faceRangeOffsets[_f + 1];
	      var numFaceValues = faceUntil - faceBegin;

	      var vNext = faceValueIndices[faceBegin];
	      var vNextNext = faceValueIndices[faceBegin + 1 % numFaceValues];

	      var eNext = edgeVertexAdjacency.findEdgeId(vNext, vNextNext);

	      // calculate face centroid
	      tempFaceCentroid.multiplyScalar(0.0);

	      for (var fv = 0; fv < numFaceValues; fv++) {

	        var v = vNext;
	        vNext = vNextNext;
	        vNextNext = faceValueIndices[faceBegin + (fv + 2) % numFaceValues];

	        var e = eNext;
	        eNext = edgeVertexAdjacency.findEdgeId(vNext, vNextNext);

	        edgeFaceValence[e]++;
	        valueFaceValence[v]++;

	        // is this the first time processing this edge
	        if (edgeUnique[e] === 0) {
	          edgeUnique[e] = 1;

	          valueEdgeValence[v]++;
	          valueEdgeValence[vNext]++;

	          if (faceEdgeCreases[faceBegin + fv]) {
	            edgeCreases[e] = 1;
	            valueCreases[v]++;
	            valueCreases[vNext]++;
	          }
	        }

	        values.getAt(v, tempValue);
	        tempFaceCentroid.add(tempValue);

	        newFaceValueIndices[nf++] = edgeOffset + e;
	        newFaceValueIndices[nf++] = vNext;
	        newFaceValueIndices[nf++] = edgeOffset + eNext;
	        newFaceValueIndices[nf++] = faceOffset + _f;
	      }

	      tempFaceCentroid.multiplyScalar(1.0 / numFaceValues);
	      newValues.setAt(faceOffset + _f, tempFaceCentroid);
	    }
	    // create new edges
	    for (var _e = 0; _e < numEdges; _e++) {

	      var _v = edgeVertexAdjacency.edgeVertices[_e * 2];
	      var _vNext = edgeVertexAdjacency.edgeVertices[_e * 2 + 1];

	      values.getAt(_v, tempEdgeCentroid);
	      values.getAt(_vNext, tempValue);
	      tempEdgeCentroid.add(tempValue);
	      var numNeighbors = 2;

	      var edgeFaceCount = faceEdgeAdjacency.edgeFaceCounts[_e];

	      if (!edgeCreases[_e] && edgeFaceCount === 2) {

	        //if the edge contains 2 corners do not average with face
	        if (!(vertexCorners[_v] && vertexCorners[_vNext])) {

	          for (var ef = 0; ef < edgeFaceCount; ef++) {
	            var _f2 = faceEdgeAdjacency.edgeFaceIndices[_e * 2 + ef];
	            newValues.getAt(faceOffset + _f2, tempValue);
	            tempEdgeCentroid.add(tempValue);
	            numNeighbors++;
	          }
	        }
	      }

	      tempEdgeCentroid.multiplyScalar(1.0 / numNeighbors);

	      newValues.setAt(edgeOffset + _e, tempEdgeCentroid);
	    }

	    var useBoundaryValues = true;

	    // create new values
	    for (var _v2 = 0; _v2 < numValues; _v2++) {

	      values.getAt(_v2, tempNextValue);
	      var boundaryValue = valueEdgeValence[_v2] !== valueFaceValence[_v2];

	      if (valueEdgeValence[_v2] !== 0 && vertexCorners[_v2] < 1) {

	        // sum of connected vertices.
	        var valueBegin = valueAdjacency.valueEdgeOffsets[_v2];
	        var valueUntil = valueAdjacency.valueEdgeOffsets[_v2 + 1];
	        var numValueEdges = valueUntil - valueBegin;

	        tempConnectedValue.multiplyScalar(0.0);
	        var numConnectedValues = 0;

	        if (useBoundaryValues && boundaryValue || valueCreases[_v2]) {

	          for (var ve = 0; ve < numValueEdges; ve++) {
	            var _e2 = valueAdjacency.valueEdgeIndices[valueBegin + ve];
	            if (edgeCreases[_e2]) {
	              var vOther = edgeVertexAdjacency.edgeVertices[_e2 * 2];
	              if (vOther === _v2) {
	                vOther = edgeVertexAdjacency.edgeVertices[_e2 * 2 + 1];
	              }

	              values.getAt(vOther, tempValue);
	              tempConnectedValue.add(tempValue);
	              numConnectedValues++;
	            }
	          }

	          tempNextValue.multiplyScalar(0.75).add(tempConnectedValue.multiplyScalar(0.25 / numConnectedValues));
	        } else {

	          for (var _ve = 0; _ve < numValueEdges; _ve++) {
	            var _e3 = valueAdjacency.valueEdgeIndices[valueBegin + _ve];
	            var _vOther = edgeVertexAdjacency.edgeVertices[_e3 * 2];
	            if (_vOther === _v2) {
	              _vOther = edgeVertexAdjacency.edgeVertices[_e3 * 2 + 1];
	            }

	            values.getAt(_vOther, tempValue);
	            tempConnectedValue.add(tempValue);
	            numConnectedValues++;
	          }

	          tempConnectedValue.multiplyScalar(1 / (numConnectedValues * numConnectedValues));

	          var valueBeginF = valueAdjacency.valueFaceOffsets[_v2];
	          var valueUntilF = valueAdjacency.valueFaceOffsets[_v2 + 1];
	          var numValueFacesF = valueUntilF - valueBeginF;

	          tempConnectedFace.multiplyScalar(0.0);
	          var numConnectedFaces = 0;

	          for (var vf = 0; vf < numValueFacesF; vf++) {

	            var _f3 = valueAdjacency.valueFaceIndices[valueBeginF + vf];
	            newValues.getAt(faceOffset + _f3, tempValue);
	            tempConnectedFace.add(tempValue);
	            numConnectedFaces++;
	          }

	          tempConnectedFace.multiplyScalar(1 / (numConnectedFaces * numConnectedFaces));

	          tempNextValue.multiplyScalar((numConnectedFaces - 2) / numConnectedFaces);
	          tempNextValue.add(tempConnectedValue);
	          tempNextValue.add(tempConnectedFace);
	        }
	      }

	      newValues.setAt(_v2, tempNextValue);
	    }

	    var pm = {
	      faceRangeOffsets: newFaceRangeOffsets,
	      faceValueIndices: newFaceValueIndices,
	      values: newValues
	    };

	    return new _PolyMap2.default(pm);
	  };

	  (0, _polyMeshValidation2.default)(mesh);
	  var polyMesh = (0, _removeDuplicateNormals2.default)(mesh);

	  var faceEdgeCreases = new Uint8Array(polyMesh.positions.faceValueIndices.length);

	  if (polyMesh.normalMap) {
	    getFaceEdgeCreases(polyMesh.normalMap, faceEdgeCreases);
	  }

	  if (polyMesh.edgeCreaseWeights) {
	    var faceEdgeAdjacency = polyMesh.positions.faceEdgeAdjacency;
	    for (var fe = 0; fe < faceEdgeAdjacency.faceEdgeIndices.length; fe++) {
	      var edgeIndex = faceEdgeAdjacency.faceEdgeIndices[fe];
	      faceEdgeCreases[fe] = faceEdgeCreases[fe] || (polyMesh.edgeCreaseWeights[edgeIndex] > 0 ? 1 : 0);
	    }
	  }

	  if (smoothByMaterialIds && polyMesh.materialIds) {
	    var _faceEdgeAdjacency = polyMesh.positions.faceEdgeAdjacency;

	    for (var _fe = 0; _fe < _faceEdgeAdjacency.faceEdgeIndices.length; _fe++) {
	      var _edgeIndex = _faceEdgeAdjacency.faceEdgeIndices[_fe];
	      if (_faceEdgeAdjacency.getNumFacesForEdgeId(_edgeIndex) === 2 && polyMesh.materialIds[_faceEdgeAdjacency.getFaceForEdgeId(_edgeIndex, 0)] !== polyMesh.materialIds[_faceEdgeAdjacency.getFaceForEdgeId(_edgeIndex, 1)]) {

	        faceEdgeCreases[_fe] += 1;
	      }
	    }
	  }

	  var faceValueCorners = getValueCorners(polyMesh.positions, faceEdgeCreases);

	  var results = new _PolyMesh2.default();
	  results.positions = subdividePolyMap(polyMesh.positions, null, faceEdgeCreases, faceValueCorners);
	  results.faceRangeOffsets = results.positions.faceRangeOffsets;

	  if (polyMesh.normalMap) {
	    results.normalMap = subdividePolyMap(polyMesh.normalMap, results.faceRangeOffsets, faceEdgeCreases, faceValueCorners);
	  }

	  if (polyMesh.uvMaps) {
	    var uvMaps = new _ObjectsByName2.default();

	    for (var i = 0; i < polyMesh.uvMaps.length; i++) {
	      var name = polyMesh.uvMaps.namesByIndex[i];
	      var uvEdgeCreases = new Uint8Array(polyMesh.uvMaps.byName[name].faceValueIndices.length);
	      getFaceEdgeCreases(polyMesh.uvMaps.byName[name], uvEdgeCreases);

	      for (var j = 0; j < faceEdgeCreases.length; j++) {
	        uvEdgeCreases[j] = uvEdgeCreases[j] || faceEdgeCreases[j];
	      }

	      var uvFaceValueCorners = getValueCorners(polyMesh.uvMaps.byName[name], uvEdgeCreases);
	      for (var _j = 0; _j < uvFaceValueCorners.length; _j++) {
	        uvFaceValueCorners[_j] = uvFaceValueCorners[_j] || faceValueCorners[_j];
	      }
	      uvMaps.set(name, subdividePolyMap(polyMesh.uvMaps.byName[name], results.faceRangeOffsets, uvEdgeCreases, uvFaceValueCorners));
	    }

	    results.uvMaps = uvMaps;
	  }

	  results.topologyChanged();
	  return results;
	};

	var getFaceEdgeCreases = function getFaceEdgeCreases(polyMap, faceEdgeCreases) {
	  var faceEdgeAdjacency = polyMap.faceEdgeAdjacency;

	  for (var fe = 0; fe < faceEdgeAdjacency.faceEdgeIndices.length; fe++) {
	    var edgeIndex = faceEdgeAdjacency.faceEdgeIndices[fe];
	    faceEdgeCreases[fe] = faceEdgeAdjacency.edgeFaceCounts[edgeIndex] !== 2 ? 1 : 0;
	  }
	};

	var getValueCorners = function getValueCorners(polyMap, faceEdgeCreases) {
	  var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;

	  //converted to track indices that are corners instead of values
	  var faceValueCorners = new Uint8Array(polyMap.faceValueIndices.length);
	  var valueCreaseEdgeCount = new Uint8Array(polyMap.values.length);
	  var edgeProcessed = new Uint8Array(edgeVertexAdjacency.getNumEdges());

	  for (var f = 0; f < polyMap.faceRangeOffsets.length - 1; f++) {

	    var faceBegin = polyMap.faceRangeOffsets[f];
	    var faceUntil = polyMap.faceRangeOffsets[f + 1];
	    var numFaceValues = faceUntil - faceBegin;

	    var vNext = polyMap.faceValueIndices[faceBegin];

	    for (var fv = 0; fv < numFaceValues; fv++) {
	      var v = vNext;
	      vNext = polyMap.faceValueIndices[faceBegin + (fv + 1) % numFaceValues];

	      var e = edgeVertexAdjacency.findEdgeId(v, vNext);
	      if (edgeProcessed[e] === 0) {
	        edgeProcessed[e] = 1;

	        if (faceEdgeCreases[faceBegin + fv]) {
	          valueCreaseEdgeCount[v]++;
	          valueCreaseEdgeCount[vNext]++;
	        }
	      }
	    }
	  }

	  for (var i = 0; i < faceValueCorners.length; i++) {
	    var valueIndex = polyMap.faceValueIndices[i];
	    if (valueCreaseEdgeCount[valueIndex] > 2) {
	      faceValueCorners[i] = 1;
	    }
	  }

	  return faceValueCorners;
	};

/***/ },
/* 222 */
/*!***************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/polyMeshValidation.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = polyMeshValidation;

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var isVec3NaN = function isVec3NaN(v) {
	  return isNaN(v.x) || isNaN(v.y) || isNaN(v.z);
	};

	var isVec3Zero = function isVec3Zero(v) {
	  return v.length() === 0;
	};

	var isVec2NaN = function isVec2NaN(v) {
	  return isNaN(v.x) || isNaN(v.y);
	};

	var validateValues = function validateValues(polyMapName, values, validationFunc) {
	  //console.log( polyMapName, values.length );
	  var temp = new values.type();
	  var replacement = new values.type();
	  for (var i = 0; i < values.length; i++) {
	    values.getAt(i, temp);
	    if (!validationFunc(temp)) {
	      //console.log( "  badValue at " + i + " is ", temp );
	      values.setAt(i, replacement);
	    }
	  }
	};

	function polyMeshValidation(mesh) {

	  validateValues('positions', mesh.positions.values, function (v) {
	    return !isVec3NaN(v);
	  });

	  if (mesh.normalMap) {
	    validateValues('normalMap', mesh.normalMap.values, function (v) {
	      return !isVec3NaN(v) && !isVec3Zero(v);
	    });
	  }

	  if (mesh.uvMaps) {
	    var uvMaps = new _ObjectsByName2.default();
	    for (var i = 0; i < mesh.uvMaps.length; i++) {
	      var name = mesh.uvMaps.namesByIndex[i];
	      validateValues('uvMap[' + name + ']', mesh.uvMaps.byName[name].values, function (v) {
	        return !isVec2NaN(v);
	      });
	    }
	  }

	  return mesh;
	};

/***/ },
/* 223 */
/*!*******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeDuplicateNormals.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeDuplicateNormals;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ObjectBuffer = __webpack_require__(/*! ../../generic/container/ObjectBuffer */ 197);

	var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function removeDuplicateNormals(polyMesh, removeUnusedValues, withLogging) {

	  if (!polyMesh.normalMap) return polyMesh;

	  var ru = removeUnusedValues || true;
	  var l = withLogging || false;

	  var faceValueIndices = polyMesh.positions.faceValueIndices;
	  var values = polyMesh.positions.values;

	  var normalFaceValueIndices = new Uint32Array(polyMesh.normalMap.faceValueIndices);
	  var normalValues = polyMesh.normalMap.values;

	  var duplicatesFound = 0;

	  var n1 = void 0,
	      n2 = void 0;

	  //TODO bad nested array
	  var valuesToIndices = [];
	  for (var i = 0; i < values.length; i++) {
	    valuesToIndices[i] = [];
	  }

	  for (var _i = 0; _i < faceValueIndices.length; _i++) {
	    valuesToIndices[faceValueIndices[_i]].push(_i);
	  }

	  //compares every normal on specific vertices to each other
	  //then remaps indices of normals that are the same
	  for (var _i2 = 0; _i2 < valuesToIndices.length; _i2++) {

	    for (var j = 0; j < valuesToIndices[_i2].length; j++) {

	      n1 = normalFaceValueIndices[valuesToIndices[_i2][j]];
	      for (var k = 0; k < valuesToIndices[_i2].length; k++) {

	        n2 = normalFaceValueIndices[valuesToIndices[_i2][j + k]];
	        if (n1 !== n2 && normalValues.getAt(n1).dot(normalValues.getAt(n2)) > 0.99) {
	          normalFaceValueIndices[valuesToIndices[_i2][j + k]] = n1;
	          duplicatesFound++;
	        }
	      }
	    }
	  }

	  if (l) console.log('Normal Duplicates Found: ' + duplicatesFound);

	  var normals = normalValues;
	  if (ru && duplicatesFound) {
	    var newNormalValuesBuffer = new _ObjectBuffer2.default(THREE.Vector3);
	    var isUsed = new Int32Array(normalValues.length);
	    isUsed.fill(-1);

	    var newNormalsCount = 0;
	    for (var _i3 = 0; _i3 < normalFaceValueIndices.length; _i3++) {
	      if (isUsed[normalFaceValueIndices[_i3]] === -1) {
	        newNormalValuesBuffer.push(normalValues.getAt(normalFaceValueIndices[_i3]));
	        isUsed[normalFaceValueIndices[_i3]] = newNormalsCount++;
	      }

	      normalFaceValueIndices[_i3] = isUsed[normalFaceValueIndices[_i3]];
	    }

	    var newNormalValues = new _ObjectArrayView2.default(THREE.Vector3, newNormalsCount);
	    newNormalValues.fromArray(newNormalValuesBuffer.toArray());

	    normals = newNormalValues;
	    if (l) console.log('' + normalValues.length + ' normal values reduced to ' + newNormalValues.length + ', duplicates removed: ' + (normalValues.length - newNormalValues.length));
	  }

	  var newNormals = new _PolyMap2.default({
	    faceRangeOffsets: polyMesh.faceRangeOffsets,
	    faceValueIndices: normalFaceValueIndices,
	    values: normals
	  });

	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.normalMap = newNormals;
	  return resultMesh;
	};

/***/ },
/* 224 */
/*!*********************************!*\
  !*** ./src/operators/Camera.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var filmSizes = {
	  '-1': '[ Custom ]',
	  35: '35mm',
	  70: 'IMAX'
	};

	var viewType = {
	  values: [0, 1],
	  labels: ['Field of View', 'Focal Length']
	};

	var Camera = {
	  schema: {
	    targeted: { label: 'Enable Look Target', type: 'Boolean', defaultValue: false },
	    focalDepthEnabled: { label: 'Use Focal Depth', type: 'Boolean', defaultValue: false },
	    focalDepth: { label: 'Focal Depth', type: 'Number', defaultValue: 100, minValue: 0.001, animatable: true, hidden: true },

	    axisDirection: { type: 'Object', hidden: true },
	    zoomAxis: { type: 'Object', hidden: true },
	    //size: { type: 'Object', hidden: true},  // Call getSize() to access this field, and call viewport.getViewRect(() for view resolution

	    projection: { label: 'Projection', type: 'Options', defaultValue: 'Perspective', values: ['Perspective', 'Orthographic'] },

	    viewCtrl: { type: 'Options', defaultValue: 0, values: viewType.values, labels: viewType.labels, label: 'View Control' },
	    fieldOfView: { label: 'Field of View', type: 'Number', defaultValue: 45, minValue: 5, maxValue: 179, animatable: true },
	    focalLength: { label: 'Focal Length (mm)', type: 'Number', defaultValue: 40, minValue: 1, maxValue: 400, step: 1, animatable: true },
	    filmSizeBox: { type: 'Options', defaultValue: '35', values: (0, _keys2.default)(filmSizes), labels: filmSizes, label: 'Film Size' },
	    customFilmSize: { label: 'Custom Film Size (mm)', type: 'Number', defaultValue: 35, step: 0.1, minValue: 1, maxValue: 1000 },
	    fStop: { label: 'F-Stop', type: 'Number', defaultValue: 2.8, minValue: 0.7, maxValue: 32, step: 0.1 },
	    filmOffset: { label: 'Film Offset (mm)', type: 'Vec2', defaultValue: { x: 0, y: 0 }, minValue: -1000.0, step: 1.0, maxValue: 1000.0 },

	    aspectRatio: { label: 'Aspect Ratio', type: 'Number', defaultValue: 16.0 / 9.0, step: 0.01, minValue: 0.01, maxValue: 10 },
	    nearClip: { label: 'Near Clip', type: 'Number', step: 0.01, defaultValue: 0.1, minValue: 0.01 },
	    farClip: { label: 'Far Clip', type: 'Number', defaultValue: 50000, step: 1, minValue: 0.00001, maxValue: 1000000 },
	    orthoZoom: { label: 'Ortho Zoom', type: 'Number', defaultValue: 1, minValue: 0.01, step: 0.1 },

	    // Orbit around
	    targetDistance: { label: 'Distance to Target', type: 'Number', defaultValue: 5.0, minValue: 0.01 }, // Distance to target, in world space
	    target: { label: 'Virtual Target', type: 'Vec3', defaultValue: { x: 0, y: 0, z: 0 }, hidden: true }, // Virtual target, in world space

	    // Display
	    showFrustum: { label: 'Show Frustum', type: 'Boolean', defaultValue: false },
	    frustumColor: { label: 'Frustum Color', type: 'Color', defaultValue: { r: 1, g: 0.78, b: 0 }, animatable: true },
	    showClipping: { label: 'Show Clipping', type: 'Boolean', defaultValue: false },
	    showTarget: { label: 'Show Virtual Target', type: 'Boolean', defaultValue: false }
	  },

	  update: function update(operator, primitive, _ref) {
	    var previousResult = _ref.previousResult;

	    //console.log('Camera update?', operator.aspectRatio, operator.fieldOfView, primitive, previousResult);
	    (0, _assign2.default)(primitive, operator);

	    // Values initialized / editor from the translator that we carry through
	    var keepKeys = ['pivotMatrix', 'upPosition', 'radiusConstraint', 'newRadiusConstraint', 'offset'];
	    if (previousResult) {
	      for (var i = 0; i < keepKeys.length; i++) {
	        if (previousResult[keepKeys[i]]) primitive[keepKeys[i]] = previousResult[keepKeys[i]];
	      }
	    }

	    var box = operator.filmSizeBox;
	    primitive.filmSize = box === -1 ? operator.customFilmSize : parseFloat(box);
	  }
	};

	exports.default = { Camera: Camera };

/***/ },
/* 225 */
/*!**************************************!*\
  !*** ./src/operators/Environment.js ***!
  \**************************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var backgroundStyle = {
	  values: [0, 1, 2, 3, 4],
	  labels: ['Default', 'Color', 'Image', 'CubeMap', 'EnvironmentMap']
	};

	var Environment = {
	  schema: {
	    ambientLight: { label: 'Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0 } },
	    environmentMap: { label: 'Environment Map', type: 'Plug', plug: 'Material' },

	    backgroundStyle: { label: 'Style', type: 'Options', defaultValue: 0, values: backgroundStyle.values, labels: backgroundStyle.labels },
	    backgroundColor: { label: 'Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0 } },
	    backgroundOpacity: { label: 'Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1 },

	    background: { label: 'Image', type: 'Plug', plug: 'Image' },

	    cubeMapBlurring: { label: 'CubeMap Blur', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 10, step: 0.5, animatable: true },
	    cubeMap: { label: 'CubeMap', type: 'Plug', plug: 'Material' }
	  }
	};

	exports.default = { Environment: Environment };

/***/ },
/* 226 */
/*!******************************************!*\
  !*** ./src/operators/GeneralRenderer.js ***!
  \******************************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var RES_LIST = {
	  values: [0, 1, 2, 3, 4, 5, 6, 7],
	  labels: ['[ Custom ]', 'HD 720', 'HD 1080', '640x480', 'Full 1024', '1k Square', '2k Square', 'Retina']
	};

	var GeneralRenderer = {

	  schema: {
	    // general settings
	    res: { label: 'Resolution', type: 'Options', defaultValue: '1', values: RES_LIST.values, labels: RES_LIST.labels },
	    res_w: { label: 'Custom Width', type: 'Number', defaultValue: 1280, minValue: 100, isInteger: true },
	    res_h: { label: 'Custom Height', type: 'Number', defaultValue: 720, minValue: 100, isInteger: true },
	    output_dir: { label: 'Output directory', type: 'Text' },

	    // current pass
	    curPass: { label: 'Current Pass', type: 'Node' },

	    // batch rendering
	    frm_start: { label: 'Start Frame', type: 'Number', defaultValue: 1 },
	    frm_last: { label: 'Last Frame', type: 'Number', defaultValue: 24 },
	    frm_by: { label: 'By Frame', type: 'Number', defaultValue: 1 },

	    ren_start: { label: 'Start number', type: 'Number', defaultValue: 1, isInteger: true },
	    ren_by: { label: 'By Frame', type: 'Number', defaultValue: 1, isInteger: true },
	    frm_pad: { label: 'Frame padding', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 10, isInteger: true }
	  }

	};

	exports.default = { GeneralRenderer: GeneralRenderer };

/***/ },
/* 227 */
/*!********************************!*\
  !*** ./src/operators/Image.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _asset = __webpack_require__(/*! ../translators/asset */ 228);

	var _assets = __webpack_require__(/*! ../modules/assets */ 168);

	var _path = __webpack_require__(/*! path */ 229);

	var _path2 = _interopRequireDefault(_path);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;

	var Linear = 3000;
	var sRGB = 3001;
	var RGBE = 3002;
	var LogLUV = 3003;
	var RGBM7 = 3004;
	var RGBM16 = 3005;

	var renderType = {
	  Original: 0, WebGL: 1, Renderer: 3
	};

	var renderTypes = {
	  values: [0, 1, 2],
	  labels: ['Original', 'WebGL', 'Renderer']
	};

	var wrapType = {
	  values: [0, 1, 2],
	  labels: ['None', 'Wrap', 'Mirror']
	};

	var sampleFilter = {
	  values: [NearestFilter, NearestMipMapNearestFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipMapNearestFilter, LinearMipMapLinearFilter],
	  labels: ['Nearest', 'Nearest MipMap Nearest', 'Nearest MipMap Linear', 'Linear', 'Linear MipMap Nearest', 'Linear MipMap Linear']
	};

	var encodingType = {
	  values: [Linear, sRGB, RGBE, LogLUV, RGBM7, RGBM16],
	  labels: ['Linear', 'sRGB', 'RGBE/Radiance', 'Log LUV', 'RGBM 7', 'RGBM 16']
	};

	var Image = {
	  schema: {
	    originalBitmapFile: { type: 'Image', hidden: true },
	    glBitmapFile: { type: 'Image', hidden: true },
	    rendererBitmapFile: { type: 'Image', hidden: true },
	    hdrBitmapFile: { type: 'Image', hidden: true },

	    renderOption: { label: 'Server Image', type: 'Options', defaultValue: 0, values: renderTypes.values, labels: renderTypes.labels },
	    glOption: { label: 'WebGL Image', type: 'Options', defaultValue: 1, values: renderTypes.values, labels: renderTypes.labels },

	    uOffset: { type: 'Number', label: 'U Offset', defaultValue: 0, step: 0.1, animatable: true },
	    vOffset: { type: 'Number', label: 'V Offset', defaultValue: 0, step: 0.1, animatable: true },
	    uTile: { type: 'Number', label: 'U Tile', defaultValue: 1, step: 0.1, animatable: true },
	    vTile: { type: 'Number', label: 'V Tile', defaultValue: 1, step: 0.1, animatable: true },
	    rotation: { type: 'Number', label: 'Rotation', defaultValue: 0, step: 0.1, animatable: true },
	    wrapU: { type: 'Options', defaultValue: 1, values: wrapType.values, labels: wrapType.labels, label: 'U Wrap Style' },
	    wrapV: { type: 'Options', defaultValue: 1, values: wrapType.values, labels: wrapType.labels, label: 'V Wrap Style' },

	    invert: { type: 'Boolean', label: 'Invert', defaultValue: false, animatable: true },
	    gainPivot: { type: 'Number', label: 'Gain Pivot', defaultValue: 0, step: 0.1, animatable: true },
	    gain: { type: 'Number', label: 'Gain', defaultValue: 1.0, step: 0.1, animatable: true },
	    brightness: { type: 'Number', label: 'Brightness', defaultValue: 0, step: 0.1, animatable: true },

	    magFilter: { type: 'Options', defaultValue: LinearFilter, values: sampleFilter.values, labels: sampleFilter.labels, label: 'Magnify Filter' },
	    minFilter: { type: 'Options', defaultValue: LinearMipMapLinearFilter, values: sampleFilter.values, labels: sampleFilter.labels, label: 'Minify Filter' },
	    generateMipMaps: { label: 'Use MipMaps', type: 'Boolean', defaultValue: true },

	    hdrEncoding: { type: 'Options', defaultValue: RGBM16, values: encodingType.values, labels: encodingType.labels, label: 'HDR Encoding' }
	  },

	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node,
	        store = _ref.store;

	    var asset = null;

	    //const renderOption = __SERVER__ ? operator.renderOption : operator.glOption;
	    var renderOption = operator.glOption;

	    if (renderOption == renderType.Original) {
	      asset = operator.originalBitmapFile;
	    } else if (renderOption === renderType.WebGL) {
	      asset = operator.glBitmapFile || operator.originalBitmapFile;
	    } else {
	      asset = operator.rendererBitmapFile || operator.originalBitmapFile;
	    }

	    primitive.asset = asset;
	    primitive.hdr = operator.hdrBitmapFile;

	    // need reference to original hdr since headless/IE are not handling the hdr.png's properly
	    // hdr extension must be 'hdr' - we do not support alternative hdr formats (ex. 'exr')
	    var hdrSourceUrl = (0, _assets.getUrl)(store, operator.originalBitmapFile);
	    if (operator.hdrBitmapFile && _path2.default.extname(hdrSourceUrl) === '.hdr') primitive.hdrSource = operator.originalBitmapFile;

	    (0, _ramda.forEach)(function (key) {
	      primitive[key] = operator[key];
	    }, ['uOffset', 'vOffset', 'uTile', 'vTile', 'rotation', 'wrapU', 'wrapV', 'gain', 'gainPivot', 'brightness', 'magFilter', 'minFilter', 'generateMipMaps', 'hdrEncoding', 'invert']);

	    primitive.preferHDR = operator.hdrEncoding !== Linear && !!operator.hdrBitmapFile;

	    return primitive;
	  }
	};

	var Canvas = {
	  schema: {
	    width: { type: 'Number', defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: 'Width' },
	    height: { type: 'Number', defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: 'Height' },

	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0, a: 0 }, animatable: true },
	    opacity: { label: 'Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1, animatable: true },

	    uOffset: { type: 'Number', label: 'U Offset', defaultValue: 0, step: 0.1, animatable: true },
	    vOffset: { type: 'Number', label: 'V Offset', defaultValue: 0, step: 0.1, animatable: true },
	    uTile: { type: 'Number', label: 'U Tile', defaultValue: 1, step: 0.1, animatable: true },
	    vTile: { type: 'Number', label: 'V Tile', defaultValue: 1, step: 0.1, animatable: true },
	    rotation: { type: 'Number', label: 'Rotation', defaultValue: 0, step: 0.1, animatable: true },
	    wrapU: { type: 'Options', defaultValue: 1, values: wrapType.values, labels: wrapType.labels, label: 'U Wrap Style' },
	    wrapV: { type: 'Options', defaultValue: 1, values: wrapType.values, labels: wrapType.labels, label: 'V Wrap Style' },

	    invert: { type: 'Boolean', label: 'Invert', defaultValue: false, animatable: true },
	    gainPivot: { type: 'Number', label: 'Gain Pivot', defaultValue: 0, step: 0.1, animatable: true },
	    gain: { type: 'Number', label: 'Gain', defaultValue: 1.0, step: 0.1, animatable: true },
	    brightness: { type: 'Number', label: 'Brightness', defaultValue: 0, step: 0.1, animatable: true },

	    magFilter: { type: 'Options', defaultValue: THREE.LinearFilter, values: sampleFilter.values, labels: sampleFilter.labels, label: 'Magnify Filter' },
	    minFilter: { type: 'Options', defaultValue: THREE.LinearMipMapLinearFilter, values: sampleFilter.values, labels: sampleFilter.labels, label: 'Minify Filter' },
	    generateMipMaps: { label: 'Use MipMaps', type: 'Boolean', defaultValue: true },

	    hdrEncoding: { type: 'Options', defaultValue: THREE.RGBM16Encoding, values: encodingType.values, labels: encodingType.labels, label: 'HDR Encoding' }
	  },

	  update: function update(operator, primitive, _ref2) {
	    var node = _ref2.node;


	    var ctxWidth = operator.width;
	    var ctxHeight = operator.height;

	    var color = operator.color;
	    if (color) color = 'rgba(' + parseInt(color.r * 255) + ',' + parseInt(color.g * 255) + ',' + parseInt(color.b * 255) + ',' + operator.opacity + ')';

	    (0, _ramda.forEach)(function (key) {
	      primitive[key] = operator[key];
	    }, ['uOffset', 'vOffset', 'uTile', 'vTile', 'rotation', 'wrapU', 'wrapV', 'gain', 'gainPivot', 'brightness', 'magFilter', 'minFilter', 'generateMipMaps', 'hdrEncoding', 'invert', 'width', 'height']);

	    var op = function op(context) {
	      context.fillStyle = color;
	      context.fillRect(0, 0, ctxWidth, ctxHeight);
	      return true;
	    };

	    if (!primitive.canvasOperations) {
	      primitive.canvasOperations = [op];
	    } else {
	      primitive.canvasOperations.push(op);
	    }

	    return primitive;
	  }

	};

	var CanvasLinearGradient = {
	  schema: {
	    startIs: { label: 'Start Is', type: 'Options', values: ['top', 'left', 'top-left', 'bottom-left'], initialValue: 'top' },
	    startColor: { label: 'Start Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0, a: 0 }, animatable: true },
	    startOpacity: { label: 'Start Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1, animatable: true },
	    endColor: { label: 'End Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0, a: 0 }, animatable: true },
	    endOpacity: { label: 'End Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1, animatable: true },

	    xOffset: { type: 'Number', defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: 'X', animatable: true },
	    yOffset: { type: 'Number', defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: 'Y', animatable: true },
	    width: { type: 'Number', defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: 'Width' },
	    height: { type: 'Number', defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: 'Height' },

	    composition: { label: 'Mode', type: 'Options', values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'], initialValue: 'source-over' }

	  },

	  update: function update(operator, primitive) {
	    var xOffset = operator.xOffset;
	    var yOffset = operator.yOffset;
	    var width = operator.width;
	    var height = operator.height;

	    var startColor = operator.startColor;
	    var endColor = operator.endColor;
	    if (startColor) startColor = 'rgba(' + parseInt(startColor.r * 255) + ',' + parseInt(startColor.g * 255) + ',' + parseInt(startColor.b * 255) + ',' + operator.startOpacity + ')';
	    if (endColor) endColor = 'rgba(' + parseInt(endColor.r * 255) + ',' + parseInt(endColor.g * 255) + ',' + parseInt(endColor.b * 255) + ',' + operator.endOpacity + ')';

	    var op = function op(canvasContext) {
	      var grd = void 0;
	      switch (operator.startIs) {
	        case 'top':
	          grd = canvasContext.createLinearGradient(xOffset, yOffset, xOffset, yOffset + height);break;
	        case 'left':
	          grd = canvasContext.createLinearGradient(xOffset, yOffset, xOffset + width, yOffset);break;
	        case 'top-left':
	          grd = canvasContext.createLinearGradient(xOffset, yOffset, xOffset + width, yOffset + height);break;
	        default:
	          grd = canvasContext.createLinearGradient(xOffset, yOffset + height, xOffset + width, yOffset);break;
	      }
	      grd.addColorStop(0, startColor);
	      grd.addColorStop(1, endColor);
	      canvasContext.fillStyle = grd;

	      canvasContext.globalCompositeOperation = operator.composition;

	      canvasContext.fillRect(xOffset, yOffset, width, height);
	      return true;
	    };

	    if (!primitive.canvasOperations) {
	      primitive.canvasOperations = [op];
	    } else {
	      primitive.canvasOperations.push(op);
	    }

	    return primitive;
	  }

	};

	var CanvasFill = {
	  schema: {
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0, a: 0 }, animatable: true },
	    opacity: { label: 'Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1, animatable: true },

	    xOffset: { type: 'Number', defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: 'X', animatable: true },
	    yOffset: { type: 'Number', defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: 'Y', animatable: true },
	    width: { type: 'Number', defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: 'Width' },
	    height: { type: 'Number', defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: 'Height' },

	    composition: { label: 'Mode', type: 'Options', values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'], initialValue: 'source-over' }

	  },

	  update: function update(operator, primitive) {
	    var xOffset = operator.xOffset;
	    var yOffset = operator.yOffset;
	    var width = operator.width;
	    var height = operator.height;

	    var color = operator.color;
	    if (color) color = 'rgba(' + parseInt(color.r * 255) + ',' + parseInt(color.g * 255) + ',' + parseInt(color.b * 255) + ',' + operator.opacity + ')';

	    var op = function op(canvasContext) {
	      canvasContext.fillStyle = color;
	      canvasContext.globalCompositeOperation = operator.composition;
	      canvasContext.fillRect(xOffset, yOffset, width, height);
	      return true;
	    };

	    if (!primitive.canvasOperations) {
	      primitive.canvasOperations = [op];
	    } else {
	      primitive.canvasOperations.push(op);
	    }

	    return primitive;
	  }
	};

	var CanvasComposite = {
	  schema: {
	    sourceImage: { type: 'Plug', plug: 'Image' },
	    xOffset: { type: 'Number', defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: 'X', animatable: true },
	    yOffset: { type: 'Number', defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: 'Y', animatable: true },

	    overrideSize: { type: 'Boolean', label: 'Override Default Size', defaultValue: false, animatable: true },
	    overrideWidth: { type: 'Number', defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: 'Override Width', animatable: true },
	    overrideHeight: { type: 'Number', defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: 'Override Height', animatable: true },

	    composition: { label: 'Composition', type: 'Options', values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'], initialValue: 'source-over' }

	  },

	  update: function update(operator, primitive, _ref3) {
	    var node = _ref3.node;

	    var sourceImage = operator.sourceImage;

	    var xOffset = operator.xOffset;
	    var yOffset = operator.yOffset;
	    var overrideSize = operator.overrideSize;
	    var overrideWidth = operator.overrideWidth;
	    var overrideHeight = operator.overrideHeight;
	    var composition = operator.composition;

	    var op = function op(context, store) {
	      if (!sourceImage) return false;

	      var textureImage = (0, _asset.fetchTextureImage)(store, sourceImage);
	      if (!textureImage) {
	        return false;
	      }

	      if (!overrideSize) {
	        overrideWidth = textureImage.width;
	        overrideHeight = textureImage.height;
	      }

	      if (overrideWidth == 0) {
	        overrideWidth = 1;
	      }

	      if (overrideHeight == 0) {
	        overrideHeight = 1;
	      }

	      var imgCanvas = document.createElement('canvas');
	      imgCanvas.width = overrideWidth;
	      imgCanvas.height = overrideHeight;
	      var imgCanvasContext = imgCanvas.getContext('2d');

	      imgCanvasContext.drawImage(textureImage, 0, 0, overrideWidth, overrideHeight);

	      context.globalCompositeOperation = composition;

	      context.drawImage(imgCanvas, xOffset, yOffset, overrideWidth, overrideHeight);

	      return true;
	    };

	    if (!primitive.canvasOperations) {
	      primitive.canvasOperations = [op];
	    } else {
	      primitive.canvasOperations.push(op);
	    }

	    return primitive;
	  }
	};

	var CanvasText = {
	  schema: {

	    fontName: { label: 'Font Name', type: 'Options', defaultValue: 'Serif', values: ['Serif', 'Sans Serif', 'Monoscape'] },
	    text: { label: 'Text', type: 'String', defaultValue: 'Text' },
	    fontSize: { label: 'Font Size', type: 'Number', defaultValue: 100, minValue: 1, maxValue: 512, step: 1, animatable: true },
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0 }, animatable: true },
	    opacity: { label: 'Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.01, animatable: true },

	    positionX: { type: "Number", defaultValue: 256, minValue: 0, maxValue: 512, step: 1, label: "Position X", animatable: true },
	    positionY: { type: "Number", defaultValue: 256, minValue: 0, maxValue: 512, step: 1, label: "Position Y", animatable: true },

	    horizontalAlign: { type: "Options", defaultValue: 'center', values: ['left', 'center', 'right'], label: "Horizontal Align" },
	    verticalAlign: { type: "Options", defaultValue: 'middle', values: ['top', 'middle', 'bottom'], label: "Vertical Align" }

	  },

	  update: function update(operator, primitive) {
	    var fontName = operator.fontName;
	    switch (fontName) {
	      case 'Serif':
	        fontName = "Times New Roman";
	        break;
	      case 'Sans Serif':
	        fontName = "Arial";
	        break;
	      case 'Monoscape':
	        fontName = "Courier New";
	        break;
	    }

	    var text = operator.text;
	    var fontSize = operator.fontSize;

	    var color = operator.color;
	    var opacity = operator.opacity;
	    color = 'rgba(' + parseInt(color.r * 255) + ',' + parseInt(color.g * 255) + ',' + parseInt(color.b * 255) + ',' + opacity + ')';

	    var positionX = operator.positionX;
	    var positionY = operator.positionY;
	    var horizontalAlign = operator.horizontalAlign;
	    var verticalAlign = operator.verticalAlign;

	    var op = function op(canvasContext) {
	      canvasContext.fillStyle = color;
	      canvasContext.font = fontSize + 'px ' + fontName;
	      canvasContext.textAlign = horizontalAlign;
	      canvasContext.textBaseline = verticalAlign;
	      canvasContext.fillText(text, positionX, positionY);
	      return true;
	    };

	    if (!primitive.canvasOperations) {
	      primitive.canvasOperations = [op];
	    } else {
	      primitive.canvasOperations.push(op);
	    }

	    return primitive;
	  }
	};

	exports.default = { Image: Image, Canvas: Canvas, CanvasLinearGradient: CanvasLinearGradient, CanvasFill: CanvasFill, CanvasComposite: CanvasComposite, CanvasText: CanvasText };

/***/ },
/* 228 */
/*!**********************************!*\
  !*** ./src/translators/asset.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getAssetIdFromImage = getAssetIdFromImage;
	exports.fetchTextureImage = fetchTextureImage;
	exports.fetchHDRSourceData = fetchHDRSourceData;

	var _assets = __webpack_require__(/*! ../modules/assets */ 168);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function getAssetIdFromImage(store, image, preferHDR) {
	  var asset = image.asset,
	      hdr = image.hdr;

	  return preferHDR && image.preferHDR && hdr ? hdr : asset;
	}

	function fetchTextureImage(store, image, preferHDR) {
	  var id = getAssetIdFromImage(store, image, preferHDR);
	  return id && (0, _assets.getOrFetchImage)(id)(store);
	}

	/**
	 * Fetches and parses hdr file buffer into usage image texture data
	 *
	 * @param {any} store
	 * @param {any} image
	 * @returns {Object} rgbe hdr data of form {width, height, data, header, gamma, exposure, format, type}
	 */
	function fetchHDRSourceData(store, image) {
	  var id = image.hdrSource;
	  if (!id) return null;
	  var hdrBuffer = (0, _assets.getOrFetchBinary)(id)(store);
	  if (!hdrBuffer) return null;
	  var hdrArrayBuffer = new Uint8Array(hdrBuffer);
	  var rgbeImageData = new THREE.RGBELoader()._parser(hdrArrayBuffer);
	  return rgbeImageData;
	}

/***/ },
/* 229 */
/*!************************************!*\
  !*** ./~/path-browserify/index.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/process/browser.js */ 107)))

/***/ },
/* 230 */
/*!********************************!*\
  !*** ./src/operators/Light.js ***!
  \********************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var DirectionalLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'DirectionalLight' },
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0.94, g: 0.94, b: 0.94 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.8 }
	  }
	};

	var SpotLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'SpotLight' },
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0.94, g: 0.94, b: 0.94 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.8 }
	  }
	};

	var PointLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'PointLight' },
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0.94, g: 0.94, b: 0.94 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.8 }
	  }
	};

	var HemisphereLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'HemisphereLight' },
	    color: { label: 'Sky Color', type: 'Color', defaultValue: { r: 0.2, g: 0.52, b: 1 } },
	    gndColor: { label: 'Sky Color', type: 'Color', defaultValue: { r: 1, g: 0.78, b: 0.5 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.6 }
	  }
	};

	var AreaLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'AreaLight' },
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0.94, g: 0.94, b: 0.94 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 10 }
	  }
	};

	exports.default = { DirectionalLight: DirectionalLight, SpotLight: SpotLight, PointLight: PointLight, HemisphereLight: HemisphereLight, AreaLight: AreaLight };

/***/ },
/* 231 */
/*!***********************************!*\
  !*** ./src/operators/Material.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var Material = {
	  schema: {
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0.94, g: 0.94, b: 0.94 } }
	  },
	  update: function update(operator, primitive) {
	    return primitive.color = operator.color;
	  }
	};

	var Physical = {
	  environment: true,

	  schema: {
	    baseMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    baseMapTransparent: { label: 'Image Transparent', type: 'Boolean', defaultValue: false },
	    baseColor: { label: 'Color', type: 'Color', defaultValue: { r: 0.94, g: 0.94, b: 0.94 } },

	    baseFalloff: { label: 'Falloff', type: 'Boolean', defaultValue: false },
	    baseFalloffMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    baseFalloffColor: { label: 'Falloff Color', type: 'Color', defaultValue: { r: 0.94, g: 0.94, b: 0.94 }, animatable: true },

	    opacityMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    opacityFactor: { label: 'Factor', type: 'Number', defaultValue: 1.0, maxValue: 1.0, minValue: 0.0, step: 0.01, animatable: true },

	    opacityFalloffMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    opacityFalloffFactor: { label: 'Falloff Factor', type: 'Number', defaultValue: 1.0, maxValue: 1.0, minValue: 0.0, step: 0.01, animatable: true },

	    depthWrite: { label: 'Depth Write', type: 'Boolean', defaultValue: true },
	    depthTest: { label: 'Depth Test', type: 'Boolean', defaultValue: true },

	    specularMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    specularColor: { label: 'Color', type: 'Color', defaultValue: { r: 1, g: 1, b: 1 }, animatable: true },

	    roughness: { label: 'Roughness', type: 'Number', defaultValue: 0.25, minValue: 0.0, maxValue: 1.0, step: 0.01, animatable: true },
	    roughnessMap: { label: 'Image', type: 'Plug', plug: 'Image' },

	    metallic: { label: 'Metallic', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 1.0, step: 0.01, animatable: true },
	    metallicMap: { label: 'Image', type: 'Plug', plug: 'Image' },

	    clearCoat: { label: 'Thickness', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 1.0, step: 0.01, animatable: true },
	    clearCoatRoughness: { label: 'Roughness', type: 'Number', defaultValue: 0.25, minValue: 0.0, maxValue: 1.0, step: 0.01, animatable: true },

	    lightMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    ambientColor2: { label: 'Color', type: 'Color', animatable: true, defaultValue: { r: 0, g: 0, b: 0 } },

	    emissiveMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    emissiveColor: { label: 'Color', type: 'Color', animatable: true, defaultValue: { r: 0, g: 0, b: 0 } },
	    emissiveScale: { label: 'Scale', type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 100.0, step: 0.1, animatable: true },
	    emissiveLabel: { type: 'Label', align: 'right', defaultValue: 'Emissive uses the second UV channel.' },

	    translucencyColor: { label: 'Color', type: 'Color', animatable: true, defaultValue: { r: 0, g: 0, b: 0 } },
	    translucencyMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    translucencyNormalAlpha: { label: 'Normal Alpha', type: 'Number', defaultValue: 0.75, minValue: 0.0, maxValue: 1.0, step: 0.05, animatable: true },
	    translucencyNormalPower: { label: 'Normal Power', type: 'Number', defaultValue: 2.0, minValue: 0.01, maxValue: 100.0, step: 0.05, animatable: true },
	    translucencyViewAlpha: { label: 'View Alpha', type: 'Number', defaultValue: 0.75, minValue: 0.0, maxValue: 1.0, step: 0.05, animatable: true },
	    translucencyViewPower: { label: 'View Power', type: 'Number', defaultValue: 2.0, minValue: 0.01, maxValue: 100.0, step: 0.05, animatable: true },

	    bumpMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    bumpFactor: { label: 'Scale Factor', type: 'Number', defaultValue: 0.03, minValue: -5.0, maxValue: 5.0, step: 0.001, animatable: true },

	    normalMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    normalFactor: { label: 'Scale Factor', type: 'Number', defaultValue: 1.0, minValue: -100.0, maxValue: 100.0, step: 0.001, animatable: true },
	    normalRedFlip: { label: "Red Channel Flip", type: "Boolean", defaultValue: false },
	    normalGreenFlip: { label: "Green Channel Flip", type: "Boolean", defaultValue: false },

	    anisotropyLabel: { type: 'Label', align: 'right', defaultValue: 'Anisotropy requires the Tangent operator.' },
	    anisotropyMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    anisotropy: { label: 'Offset', type: 'Number', defaultValue: 0.0, minValue: -1.0, maxValue: 1.0, step: 0.025, animatable: true },

	    anisotropyRotationMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    anisotropyRotation: { label: 'Rotation Offset', type: 'Number', defaultValue: 0.0, minValue: -1.0, maxValue: 1.0, step: 0.025, animatable: true },

	    overrideEnvironment: { label: 'Override Environment', type: 'Boolean', defaultValue: false }
	  }
	};

	var MaterialReference = {
	  schema: {
	    defaultColor: { label: 'Default Color', type: 'Color', defaultValue: { r: 1, g: 1, b: 1 } },
	    reference: { type: 'Plug', plug: 'Material', label: 'Reference' }
	  },
	  update: function update(operator, primitive) {
	    primitive.color = operator.defaultColor;
	    //return operator.reference || primitive.color = operator.defaultColor;
	  }
	};

	var Reference = {
	  schema: {
	    defaultColor: { label: 'Default Color', type: 'Color', defaultValue: { r: 1, g: 1, b: 1 } },
	    reference: { type: 'Plug', plug: 'Material', label: 'Reference' }
	  },
	  update: function update(operator, primitive) {
	    if (operator.reference) return operator.reference;
	    primitive.defaultColor = operator.defaultColor;
	  }
	};

	var EnvironmentMap = {
	  schema: {
	    thumbnailImage: { label: 'Thumbnail', type: 'Plug', plug: 'Image' },

	    irradianceCubeMap: { label: 'Irradiance', type: 'Plug', plug: 'Material' }, //filter: cubeMapFilter },
	    specularCubeMap: { label: 'Specular', type: 'Plug', plug: 'Material' }, //filter: cubeMapFilter },
	    intensity: { label: "Intensity", type: 'Number', defaultValue: 1.0, minValue: 0.001, maxValue: 100.0, step: 0.1, animatable: true }

	  }
	};

	var CubeMap = {
	  schema: {
	    map0: { label: 'Map ( x)', type: 'Plug', plug: 'Image' },
	    map1: { label: 'Map (-x)', type: 'Plug', plug: 'Image' },
	    map2: { label: 'Map ( y)', type: 'Plug', plug: 'Image' },
	    map3: { label: 'Map (-y)', type: 'Plug', plug: 'Image' },
	    map4: { label: 'Map ( z)', type: 'Plug', plug: 'Image' },
	    map5: { label: 'Map (-z)', type: 'Plug', plug: 'Image' }
	  },
	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;

	    primitive.maps = [operator.map0, operator.map1, operator.map2, operator.map3, operator.map4, operator.map5];
	  }
	};

	var ProxyReference = {
	  schema: {
	    webgl: { type: 'Plug', label: 'WebGL Material', plug: 'Material' },
	    vray: { type: 'Plug', label: 'VRay Material', plug: 'Material' }
	  },
	  update: function update(operator, primitive) {
	    return operator.webgl || primitive;
	  }
	};

	var Standard = {
	  schema: {
	    diffuseColor: { label: 'Color', type: 'Color', defaultValue: { r: 0.94, g: 0.94, b: 0.94 } }
	  }
	};

	var MultiID = {
	  schema: {

	    defaultColor: { label: 'Default Color', type: 'Color', defaultValue: { r: 0.5, g: 0.5, b: 0.5 } },

	    material0: { type: 'Plug', plug: 'Material', label: 'Material ID 0' },
	    material1: { type: 'Plug', plug: 'Material', label: 'Material ID 1' },
	    material2: { type: 'Plug', plug: 'Material', label: 'Material ID 2' },
	    material3: { type: 'Plug', plug: 'Material', label: 'Material ID 3' },
	    material4: { type: 'Plug', plug: 'Material', label: 'Material ID 4' },
	    material5: { type: 'Plug', plug: 'Material', label: 'Material ID 5' },
	    material6: { type: 'Plug', plug: 'Material', label: 'Material ID 6' },
	    material7: { type: 'Plug', plug: 'Material', label: 'Material ID 7' },
	    material8: { type: 'Plug', plug: 'Material', label: 'Material ID 8' },
	    material9: { type: 'Plug', plug: 'Material', label: 'Material ID 9' },
	    material10: { type: 'Plug', plug: 'Material', label: 'Material ID 10' },
	    material11: { type: 'Plug', plug: 'Material', label: 'Material ID 11' },
	    material12: { type: 'Plug', plug: 'Material', label: 'Material ID 12' },
	    material13: { type: 'Plug', plug: 'Material', label: 'Material ID 13' },
	    material14: { type: 'Plug', plug: 'Material', label: 'Material ID 14' },
	    material15: { type: 'Plug', plug: 'Material', label: 'Material ID 15' },
	    material16: { type: 'Plug', plug: 'Material', label: 'Material ID 16' },
	    material17: { type: 'Plug', plug: 'Material', label: 'Material ID 17' },
	    material18: { type: 'Plug', plug: 'Material', label: 'Material ID 18' },
	    material19: { type: 'Plug', plug: 'Material', label: 'Material ID 19' },
	    material20: { type: 'Plug', plug: 'Material', label: 'Material ID 20' },
	    material21: { type: 'Plug', plug: 'Material', label: 'Material ID 21' },
	    material22: { type: 'Plug', plug: 'Material', label: 'Material ID 22' },
	    material23: { type: 'Plug', plug: 'Material', label: 'Material ID 23' },
	    material24: { type: 'Plug', plug: 'Material', label: 'Material ID 24' },
	    material25: { type: 'Plug', plug: 'Material', label: 'Material ID 25' },
	    material26: { type: 'Plug', plug: 'Material', label: 'Material ID 26' },
	    material27: { type: 'Plug', plug: 'Material', label: 'Material ID 27' },
	    material28: { type: 'Plug', plug: 'Material', label: 'Material ID 28' },
	    material29: { type: 'Plug', plug: 'Material', label: 'Material ID 29' },

	    multiID: { type: 'Boolean', label: 'Is MultiID', defaultValue: true }
	  }
	};

	var VRmat = {
	  schema: {
	    visMatZipFile: { type: 'File', hidden: true },
	    viewColor: { type: 'Color', defaultValue: { r: 0.94, g: 0.94, b: 0.94 }, label: 'Viewport Color' }
	  }
	};

	exports.default = { Material: Material, Physical: Physical, MaterialReference: MaterialReference, Reference: Reference, EnvironmentMap: EnvironmentMap,
	  CubeMap: CubeMap, Standard: Standard, ProxyReference: ProxyReference, MultiID: MultiID, 'vray/VRmat': VRmat };

/***/ },
/* 232 */
/*!*******************************!*\
  !*** ./src/operators/Pass.js ***!
  \*******************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var targetCam = function targetCam(n) {
	  return n.get('type') === 'Camera';
	};
	var targetRen = function targetRen(n) {
	  return n.get('type') === 'Renderer';
	};

	var Pass = {

	  schema: {
	    activated: { label: 'Activated', type: 'Boolean', defaultValue: true },
	    filename: { label: 'Filename', type: 'Text', defaultValue: null },
	    fileFormat: { label: 'File Format', type: 'Text', defaultValue: null },

	    over_res: { label: 'On', type: 'Boolean', defaultValue: false },
	    over_res_x: { label: 'Image Width', type: 'Number', defaultValue: 1280, isInteger: true },
	    over_res_y: { label: 'Image Height', type: 'Number', defaultValue: 720, isInteger: true },

	    render_cam: { type: 'Node', label: 'Camera', filter: targetCam },
	    render_red: { type: 'Node', label: 'Renderer', filter: targetRen }
	  }
	};

	exports.default = { Pass: Pass };

/***/ },
/* 233 */
/*!*********************************!*\
  !*** ./src/operators/Player.js ***!
  \*********************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var Player = {
	  schema: {
	    autoRotate: { label: 'Auto-Rotate Camera', type: 'Boolean', defaultValue: false },
	    autoRotateNode: { label: 'Rotate Node', type: 'Node' },
	    autoRotateSpeed: { label: 'Rotate Speed (seconds)', type: 'Number', minValue: 1, maxValue: 60, defaultValue: 12 },
	    autoRotateDirection: { label: 'Rotate Direction', type: 'Options', values: ['-', '+'], labels: ['Clockwise', 'Counter-clockwise'], defaultValue: '-' },

	    camera: { label: 'Camera', type: 'Node' },
	    constraintCameraY: { label: 'Constrain Camera to Positive Y', type: 'Boolean', defaultValue: false },
	    orbitTarget: { label: 'Orbit Target', type: 'Node' },
	    orbitMode: { label: 'Orbit Mode', type: 'Options', values: ['gyroscope', 'trackball', 'firstPerson'], labels: ['Gyropscope', 'Trackball', 'First Person'], defaultValue: 'gyroscope' },

	    toneMapStyle: { label: 'Style', type: 'Options', values: ['Linear', 'Reinhard', 'Cineon', 'Filmic'], defaultValue: 'Linear' },
	    toneMapExposureGain: { label: 'Exposure Gain', type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 20.0, step: 0.1 },
	    toneMapWhitePoint: { label: 'White Point', type: 'Number', defaultValue: 4.0, minValue: 0.0, maxValue: 20.0, step: 0.1 },

	    dofPass: { label: 'Enabled', type: 'Boolean', defaultValue: false },
	    dofMaxBlur: { label: 'Max Blur', type: 'Number', defaultValue: 10.0, minValue: 0.0, maxValue: 100.0, step: 0.1 },

	    saoPass: { label: 'Enabled', type: 'Boolean', defaultValue: false },
	    saoIntensity: { label: 'Intensity', type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 1000.0, step: 0.1 },
	    saoScale: { label: 'Scale', type: 'Number', defaultValue: 24.0, minValue: 0.0, maxValue: 1000.0, step: 0.1 },

	    bloomPass: { label: 'Enabled', type: 'Boolean', defaultValue: false },
	    bloomThreshold: { label: 'Luminance Threshold', type: 'Number', defaultValue: 0.9, minValue: 0.0, maxValue: 1.0, step: 0.1 },
	    //bloomBlendRange: { label: 'Blend Range', type: 'Number', defaultValue: 0.1, minValue: 0.0, maxValue: 10.0, step: 0.1 }, //not configurable in threejs yet

	    reflectiveFloor: { label: 'Enabled', type: 'Boolean', defaultValue: false },
	    reflectiveFloorWidth: { label: 'Width', type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 1000.0, step: 1.0 },
	    reflectiveFloorRoughness: { label: 'Roughness', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 10.0, step: 0.1 },
	    reflectiveFloorMetallic: { label: 'Metallic', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 1.0, step: 0.1 },
	    reflectiveFloorFade: { label: 'Fade', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 10000.0, step: 0.1 },
	    reflectiveFloorHeight: { label: 'Height', type: 'Number', defaultValue: 0.0, minValue: -100.0, maxValue: 100.0, step: 0.1 },
	    reflectiveFloorOpacity: { label: 'Opacity', type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 1.0, step: 0.1 },
	    reflectiveFloorFresnel: { label: 'Fresnel Strength', type: 'Number', defaultValue: 1.0, minValue: -1.0, maxValue: 1.0, step: 0.1 },
	    reflectiveFloorExcludeServer: { label: 'Exclude on Server', type: 'Boolean', defaultValue: false },

	    configurator: { label: 'Configurator', type: 'String', hidden: true, defaultValue: '{}' },

	    // Physics
	    gravity: { label: 'Gravity', type: 'Vec3', step: 1.0, defaultValue: [0.0, -9.8, 0.0] }
	  }
	};

	exports.default = { Player: Player };

/***/ },
/* 234 */
/*!*****************************************!*\
  !*** ./src/operators/PolyMesh/index.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Mesh = __webpack_require__(/*! ./Mesh */ 235);

	var _Mesh2 = _interopRequireDefault(_Mesh);

	var _TransformVertices = __webpack_require__(/*! ./TransformVertices */ 236);

	var _TransformVertices2 = _interopRequireDefault(_TransformVertices);

	var _MeshSmooth = __webpack_require__(/*! ./MeshSmooth */ 220);

	var _MeshSmooth2 = _interopRequireDefault(_MeshSmooth);

	var _UVMap = __webpack_require__(/*! ./UVMap */ 237);

	var _UVMap2 = _interopRequireDefault(_UVMap);

	var _UVTransform = __webpack_require__(/*! ./UVTransform */ 238);

	var _UVTransform2 = _interopRequireDefault(_UVTransform);

	var _Skin = __webpack_require__(/*! ./Skin */ 239);

	var _Skin2 = _interopRequireDefault(_Skin);

	var _Box = __webpack_require__(/*! ./Box */ 240);

	var _Box2 = _interopRequireDefault(_Box);

	var _Sphere = __webpack_require__(/*! ./Sphere */ 254);

	var _Sphere2 = _interopRequireDefault(_Sphere);

	var _Cone = __webpack_require__(/*! ./Cone */ 262);

	var _Cone2 = _interopRequireDefault(_Cone);

	var _Capsule = __webpack_require__(/*! ./Capsule */ 264);

	var _Capsule2 = _interopRequireDefault(_Capsule);

	var _Cylinder = __webpack_require__(/*! ./Cylinder */ 266);

	var _Cylinder2 = _interopRequireDefault(_Cylinder);

	var _Plane = __webpack_require__(/*! ./Plane */ 268);

	var _Plane2 = _interopRequireDefault(_Plane);

	var _Torus = __webpack_require__(/*! ./Torus */ 270);

	var _Torus2 = _interopRequireDefault(_Torus);

	var _Disk = __webpack_require__(/*! ./Disk */ 272);

	var _Disk2 = _interopRequireDefault(_Disk);

	var _ProxyMesh = __webpack_require__(/*! ./ProxyMesh */ 274);

	var _ProxyMesh2 = _interopRequireDefault(_ProxyMesh);

	var _Instance = __webpack_require__(/*! ./Instance */ 275);

	var _Instance2 = _interopRequireDefault(_Instance);

	var _SortFacesByAxis = __webpack_require__(/*! ./SortFacesByAxis */ 276);

	var _SortFacesByAxis2 = _interopRequireDefault(_SortFacesByAxis);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = { Mesh: _Mesh2.default, MeshSmooth: _MeshSmooth2.default, Skin: _Skin2.default, TransformVertices: _TransformVertices2.default, UVMap: _UVMap2.default, UVTransform: _UVTransform2.default, Box: _Box2.default, Sphere: _Sphere2.default,
	  Cone: _Cone2.default, Capsule: _Capsule2.default, Cylinder: _Cylinder2.default, Plane: _Plane2.default, Torus: _Torus2.default, Disk: _Disk2.default, ProxyMesh: _ProxyMesh2.default, Instance: _Instance2.default, SortFacesByAxis: _SortFacesByAxis2.default };

/***/ },
/* 235 */
/*!****************************************!*\
  !*** ./src/operators/PolyMesh/Mesh.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _bingeom = __webpack_require__(/*! ../../translators/bingeom */ 182);

	var _assets = __webpack_require__(/*! ../../modules/assets */ 168);

	var Mesh = {
	  schema: {
	    geometry: { type: 'File', label: 'PolyMesh Geometry File' }
	  },

	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node,
	        store = _ref.store,
	        properties = _ref.properties,
	        previousResult = _ref.previousResult,
	        loaded = _ref.loaded;

	    var visible = properties.visible;
	    var geom = operator.geometry; // Request geometry so the asset gets referenced
	    var fetch = visible || properties.prefetch && loaded;
	    var ref = fetch && geom;
	    var bingeom = ref && store.hasApi() && (0, _assets.getOrFetchBinary)(ref)(store);
	    var mesh = bingeom && (0, _bingeom.convertToCNSPolyMesh)(bingeom, ref);
	    //console.log('Mesh update', 'visible:', visible, 'prefetch:', properties.prefetch, 'fetch:', fetch, 'bingeom:', !!bingeom,  node.name, mesh);
	    primitive.mesh = mesh;
	    primitive.previousMesh = previousResult && previousResult.mesh;
	    return primitive;
	  }
	};

	exports.default = Mesh;

/***/ },
/* 236 */
/*!*****************************************************!*\
  !*** ./src/operators/PolyMesh/TransformVertices.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 97);

	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _polyMesh = __webpack_require__(/*! ../../polyMesh */ 183);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function stringIndicesToArray() {
	  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	  var indices = str.split(',');
	  var outIndices = [];
	  var i = void 0,
	      j = void 0,
	      start = void 0,
	      end = void 0,
	      v = void 0;
	  for (i = 0; i < indices.length; i++) {
	    v = indices[i];
	    if (v.indexOf('-') !== -1) {
	      var _v$split = v.split('-');

	      var _v$split2 = (0, _slicedToArray3.default)(_v$split, 2);

	      start = _v$split2[0];
	      end = _v$split2[1];

	      start = Number(start);
	      end = Number(end);
	      for (j = start; j <= end; j++) {
	        outIndices.push(j);
	      }
	    } else {
	      outIndices.push(Number(v));
	    }
	  }

	  return outIndices;
	}

	var TransformVertices = {
	  schema: {
	    translation: { label: 'Translation', type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    rotation: { label: 'Rotation', type: 'Vec3', step: 1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true, hidden: true },
	    scale: { label: 'Scale', type: 'Vec3', minValue: 0.0001, step: 0.1, defaultValue: { x: 1, y: 1, z: 1 }, animatable: true, hidden: true },
	    updateNormals: { label: 'Update Normals', type: 'Boolean', defaultValue: true, hidden: true },
	    //centerType: { label: 'Center', type: 'Options', display: 'Dropdown',
	    //      labels: ['Selection Center', 'World Center', 'Pivot'],
	    //      values: ['SelectionCenter', 'WorldCenter', 'Pivot'],
	    //      defaultValue: 'SelectionCenter' },
	    //// matrix is used in baking transform and overrides other parameters
	    //matrix: { label: 'Translation', type: 'Object', defaultValue: null, hidden: true },
	    vertexIndices: { label: 'Selection', type: 'String', defaultValue: '' }
	  },

	  update: function update(operator, primitive) {
	    var mesh = primitive.mesh;
	    if (!mesh) return primitive;

	    var seed = Math.random();
	    var density = 0.5;
	    var meaning = _polyMesh.Selection.Vertices;

	    var indices = stringIndicesToArray(operator.vertexIndices);
	    //console.log('create selection from: ', operator.vertexIndices, indices);

	    var selection = new _polyMesh.Selection(indices, _polyMesh.Selection.Vertices);

	    var newMesh = new _polyMesh.PolyMesh(mesh);
	    var newPolyMap = new _polyMesh.PolyMap(_polyMesh.PolyMaps.resolveMap(mesh, 'positions'));
	    var newMapValues = newPolyMap.values.clone();
	    newPolyMap.values = newMapValues;
	    _polyMesh.PolyMaps.assignMap(newMesh, 'positions', newPolyMap);

	    var vertexIndices = _polyMesh.Selection.getIndices(mesh, _polyMesh.Selection.Vertices, 'positions', selection);

	    var nonuniform = !!selection;

	    for (var j = 0, n = vertexIndices.length; j !== n; ++j) {
	      var i = vertexIndices[j];

	      newMapValues.setAt(i, newMapValues.getAt(i, new THREE.Vector3()).add(operator.translation));
	    }

	    primitive.mesh = newMesh;
	  }
	};

	exports.default = TransformVertices;

/***/ },
/* 237 */
/*!*****************************************!*\
  !*** ./src/operators/PolyMesh/UVMap.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _PolyMesh = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _ObjectArrayView = __webpack_require__(/*! ../../polyMesh/generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ObjectsByName = __webpack_require__(/*! ../../polyMesh/generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var UVMap = {
	  schema: {
	    mWidth: { type: 'Number', label: 'Width', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    mHeight: { type: 'Number', label: 'Height', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    mLength: { type: 'Number', label: 'Length', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },

	    center: { label: 'Center', type: 'Vec3', step: 0.1, defaultValue: new THREE.Vector3(0, 0, 0), animatable: true },
	    rotation: { label: 'Rotation', type: 'Vec3', step: 1, minValue: -360, maxValue: 360, defaultValue: new THREE.Vector3(0, 0, 0), animatable: true },
	    uTile: { label: 'U Tile', type: 'Number', step: 0.1, defaultValue: 1.0, animatable: true },
	    vTile: { label: 'V Tile', type: 'Number', step: 0.1, defaultValue: 1.0, animatable: true },

	    uvProjectionMode: { label: 'Projection', type: 'Options', display: 'Radio',
	      values: [], // FIXME UVMAP type // 0, 1, 2, 3
	      labels: ['Planar', 'Box', 'Cylindrical', 'Spherical'], defaultValue: 0 },
	    xAxis: { label: 'Align Local Axis', type: 'Options', display: 'Radio',
	      values: [], //0, 1, 2, 3
	      labels: ['X', 'Y', 'Z', 'Average Normals'], defaultValue: 1 },
	    //uvMapChannel: { label: 'UV Channel', type: 'String', defaultValue: 'default' },

	    autoFit: { label: 'Auto Fit', type: 'Button' },
	    autoAlign: { label: 'Auto Align', type: 'Button' }, // Hidden until local manipulators fixed
	    autoFitAlign: { label: 'Best Fit', type: 'Button' }, // Hidden until local manipulators fixed
	    autoCenter: { label: 'Auto Center', type: 'Button' },
	    resetUVs: { label: 'Reset', type: 'Button' }

	  },

	  update: function update(operator, primitive) {
	    var mesh = primitive.mesh;
	    if (!mesh) return primitive;

	    var options = {};

	    options.uTile = operator.uTile;
	    options.vTile = operator.vTile;
	    options.uvProjectionMode = operator.uvProjectionMode;
	    options.alignmentAxis = operator.xAxis;
	    options.center = operator.center;
	    options.rotation = operator.rotation;
	    options.mapChannel = operator.uvMapChannel;
	    options.scale = new THREE.Vector3(operator.mWidth, operator.mHeight, operator.mLength);

	    primitive.mesh = applyUVMap(mesh, options);
	  }
	};

	function applyUVMap(polyMesh, uvMapOptions) {

	  uvMapOptions = uvMapOptions || {}; // because all values can be defaulted, uvMapOptions should be allowed to be null/undefined too!

	  var rotation = uvMapOptions.rotation.multiplyScalar(180 / Math.PI) || new THREE.Vector3();
	  var scale = uvMapOptions.scale || new THREE.Vector3(1, 1, 1);
	  var center = uvMapOptions.center || new THREE.Vector3();
	  var uvProjectionMode = uvMapOptions.uvProjectionMode !== undefined ? uvMapOptions.uvProjectionMode : 0;
	  var alignmentAxis = uvMapOptions.alignmentAxis !== undefined ? uvMapOptions.alignmentAxis : 1;
	  var mapChannel = uvMapOptions.mapChannel !== undefined ? uvMapOptions.mapChannel : 'default';
	  var uTile = uvMapOptions.uTile !== undefined ? uvMapOptions.uTile : 1.0;
	  var vTile = uvMapOptions.vTile !== undefined ? uvMapOptions.vTile : 1.0;

	  // Inverse matrix should be used, so uv map follows the gimzo
	  var matrixRotation = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler().setFromVector3(rotation, 'ZYX'));
	  var matrixRotationInv = new THREE.Matrix4().getInverse(matrixRotation);

	  var faceRangeOffsets = polyMesh.faceRangeOffsets;
	  var faceValueIndices = polyMesh.positions.faceValueIndices;
	  var values = polyMesh.positions.values;

	  var uvFaceValueIndices = new Uint32Array(faceValueIndices.length);
	  var uvValues = new _ObjectArrayView2.default(THREE.Vector2, faceValueIndices.length);

	  var vertex1 = new THREE.Vector3();
	  var vertex2 = new THREE.Vector3();
	  var faceNormal = new THREE.Vector3();
	  var newUV = new THREE.Vector2();

	  //for every face
	  var faceBegin = 0;
	  var faceEnd = 0;
	  var uvValueCounter = 0;
	  for (var i = 1; i < faceRangeOffsets.length; i++) {
	    faceEnd = faceRangeOffsets[i];

	    //compute the face normal
	    faceNormal.multiplyScalar(0);
	    for (var j = faceBegin; j < faceEnd; j++) {

	      var k = j + 1;
	      if (k >= faceEnd) {
	        k = faceBegin;
	      }

	      values.getAt(faceValueIndices[j], vertex1);
	      values.getAt(faceValueIndices[k], vertex2);

	      faceNormal.x += (vertex1.y - vertex2.y) * (vertex1.z + vertex2.z);
	      faceNormal.y += (vertex1.z - vertex2.z) * (vertex1.x + vertex2.x);
	      faceNormal.z += (vertex1.x - vertex2.x) * (vertex1.y + vertex2.y);
	    }

	    faceNormal.normalize();

	    //for every index on that face
	    for (var _j = faceBegin; _j < faceEnd; _j++) {

	      values.getAt(faceValueIndices[_j], vertex1);

	      vertex1.sub(center); // Translate to center
	      vertex1.applyMatrix4(matrixRotationInv); // Apply Inverse rotation to the vertex (to follow gizmo)

	      switch (uvProjectionMode) {

	        case 0:
	          //Planar
	          planarUVMap(vertex1, alignmentAxis, scale, newUV);
	          break;

	        case 1:
	          //Box
	          boxUVMap(vertex1, faceNormal, scale, newUV);
	          break;

	        case 2:
	          //Cylindrical
	          cylindricalUVMap(vertex1, alignmentAxis, scale, newUV);
	          break;

	        case 3:
	          //Spherical
	          sphericalUVMap(vertex1, alignmentAxis, scale, newUV);
	          break;

	        default:
	          newUV.set(0, 0);
	          break;
	      }

	      // Apply tiling
	      if (uTile !== 1.0) {
	        newUV.x *= uTile;
	      }

	      if (vTile !== 1.0) {
	        newUV.y *= vTile;
	      }

	      // Avoid disconnected uv faces
	      //TODO check for duplicate uv's on that vertex and don't store it twice;

	      uvFaceValueIndices[_j] = uvValueCounter;
	      uvValues.setAt(uvValueCounter++, newUV);
	    }

	    faceBegin = faceEnd;
	  }

	  var resultMesh = new _PolyMesh2.default(polyMesh);

	  var newUVMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: uvFaceValueIndices,
	    values: uvValues
	  });

	  if (!resultMesh.uvMaps) resultMesh.uvMaps = new _ObjectsByName2.default();
	  resultMesh.uvMaps.set(mapChannel, newUVMap);

	  return resultMesh;
	};

	function boxUVMap(vertex, normal, scale, uv) {

	  var s = 0;
	  var t = 0;

	  var x = vertex.x;
	  var y = vertex.y;
	  var z = vertex.z;
	  // Face normal
	  var nx = Math.abs(normal.x);
	  var ny = Math.abs(normal.y);
	  var nz = Math.abs(normal.z);

	  if (nx >= ny && nx >= nz) {
	    s = -z / scale.z + 0.5;
	    t = y / scale.y + 0.5;
	  }

	  if (ny >= nx && ny >= nz) {
	    s = x / scale.x + 0.5;
	    t = -z / scale.z + 0.5;
	  }

	  if (nz >= nx && nz >= ny) {
	    s = x / scale.x + 0.5;
	    t = y / scale.y + 0.5;
	  }

	  // Otherside of box is mirror of the other side
	  // However, only making them negative is not a good solution for tiling, so we add them to 1 to be flipped in positive side
	  if (normal.x < 0) {
	    s = -s + 1;
	  }

	  if (normal.y < 0) {
	    s = -s + 1;
	  }

	  if (normal.z < 0) {
	    s = -s + 1;
	  }

	  uv.set(s, t);
	  return uv;
	};

	function planarUVMap(vertex, planeAxis, scale, uv) {

	  // Note: In case of plane we will not use scale.z
	  var u = planeAxis === 0 ? -vertex.z : vertex.x;
	  var v = planeAxis === 1 ? -vertex.z : vertex.y;

	  u = u / scale.x + 0.5;
	  v = v / scale.y + 0.5;

	  uv.set(u, v);

	  return uv;
	};

	function cylindricalUVMap(vertex, cylinderAxis, scale, uv) {

	  var lon = void 0;
	  var t = void 0;

	  switch (cylinderAxis) {
	    case 0:
	      lon = xyz_to_longitude(vertex.z / scale.z, vertex.x / scale.x, -vertex.y / scale.y);
	      t = -vertex.x / scale.x + 0.5;
	      break;

	    case 1:
	      lon = xyz_to_longitude(vertex.x / scale.x, vertex.y / scale.y, vertex.z / scale.z);
	      t = vertex.y / scale.y + 0.5;
	      break;

	    case 2:
	      lon = xyz_to_longitude(-vertex.x / scale.x, vertex.z / scale.z, -vertex.y / scale.y);
	      t = -vertex.z / scale.z + 0.5;
	      break;
	  }

	  // convert it from [0-2PI] to [0-1]
	  lon = lon / (Math.PI * 2);
	  uv.set(lon, t);

	  return uv;
	};

	function sphericalUVMap(vertex, sphereAxis, scale, uv) {

	  var lonlat = void 0;
	  var lat = void 0,
	      lon = void 0;

	  switch (sphereAxis) {
	    case 0:
	      lonlat = xyz_to_longitudelatitude(vertex.z / scale.z, vertex.x / scale.x, -vertex.y / scale.y);
	      break;

	    case 1:
	      lonlat = xyz_to_longitudelatitude(vertex.x / scale.x, -vertex.y / scale.y, vertex.z / scale.z);
	      break;

	    case 2:
	      lonlat = xyz_to_longitudelatitude(-vertex.x / scale.x, vertex.z / scale.z, -vertex.y / scale.y);
	      break;
	  }

	  // convert longitude from [0, 2PI] to [0,1], and latitude from [-PI, +PI] to [0,1]
	  lon = lonlat.lon / (Math.PI * 2);
	  lat = 0.5 - lonlat.lat / Math.PI;
	  uv.set(lon, lat);

	  return uv;
	};

	// convert XYZ space to longitude
	// Returns longitude is in interval [-PI,+PI]
	function xyz_to_longitude(x, y, z) {

	  var lon = void 0;

	  if (x === 0 && z === 0) {

	    lon = 0;
	  } else {
	    lon = Math.atan2(x, z);

	    // longitude is in interval [-PI,+PI], so we add two PI to negative longitudes to be between [0,2PI]
	    if (lon < 0) {
	      lon += Math.PI * 2;
	    }
	  }

	  return lon;
	};

	// convert XYZ space to longitude and latitude
	// Returns longitude [0, 2PI] and latitude [-PI, +PI]
	function xyz_to_longitudelatitude(x, y, z) {

	  var lo = void 0,
	      la = void 0;

	  if (x === 0 && z === 0) {
	    lo = 0;

	    if (y !== 0) {
	      la = y < 0 ? -(Math.PI / 2) : Math.PI / 2;
	    } else {
	      la = 0;
	    }
	  } else {

	    lo = Math.atan2(x, z);

	    // longitude is in interval [-PI,+PI], so we add two PI to negative longitudes to be between [0,2PI]
	    if (lo < 0) {
	      lo += Math.PI * 2;
	    }

	    var h = Math.sqrt(x * x + z * z);
	    // latitude is in [-PI,+PI]
	    la = Math.atan2(y, h);
	  }

	  return {
	    lon: lo,
	    lat: la
	  };
	};

	exports.default = UVMap;

/***/ },
/* 238 */
/*!***********************************************!*\
  !*** ./src/operators/PolyMesh/UVTransform.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _PolyMesh = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _ObjectArrayView = __webpack_require__(/*! ../../polyMesh/generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var ScaleMode = {
	  Scale: 0,
	  Tiling: 1
	};

	var UVTransform = {
	  name: 'UVTransform',
	  label: 'UV Transform',

	  schema: {
	    rotation: { label: 'Rotation', type: 'Number', step: 0.1, minValue: -360, maxValue: 360, defaultValue: 0, animatable: true },
	    scaleMode: { label: 'Scale Mode', type: 'Options', display: 'Dropdown',
	      labels: ['Scale', 'Tiling'],
	      values: [ScaleMode.Scale, ScaleMode.Tiling],
	      defaultValue: ScaleMode.Scale },
	    tiling: { label: 'Tiling', type: 'Vec2', step: 0.1, defaultValue: new THREE.Vector2(1, 1), animatable: true },
	    scale: { label: 'Scale', type: 'Vec2', step: 0.1, defaultValue: new THREE.Vector2(1, 1), animatable: true },
	    translation: { label: 'Translation', type: 'Vec2', step: 0.1, defaultValue: new THREE.Vector2(0, 0), animatable: true },
	    pivotCenter: { label: 'Pivot Center', type: 'Vec2', step: 0.1, defaultValue: new THREE.Vector2(0, 0), animatable: true },

	    uvMapChannel: { label: 'UV Channel', type: 'String', defaultValue: 'default' }

	  },

	  update: function update(operator, primitive) {

	    var mesh = primitive.mesh;
	    if (!mesh) return primitive;

	    var mapChannel = operator.uvMapChannel || 'default'; //consider empty channel as default

	    var uvMap = mesh.uvMaps ? mesh.uvMaps.byName[mapChannel] : null;
	    if (!uvMap) return primitive;

	    var uvVec3 = new THREE.Vector3();
	    var uv = new THREE.Vector2();
	    var uvValues = new _ObjectArrayView2.default(THREE.Vector2, uvMap.values.length);

	    var rotation = operator.rotation;
	    var scaleMode = operator.scaleMode;
	    var scale = operator.scale;
	    var tiling = operator.tiling;
	    var translation = operator.translation;
	    var pivotCenter = operator.pivotCenter;

	    var uvTransform = getUVTransform(rotation, tiling, scaleMode === ScaleMode.Scale, scale, translation, pivotCenter);

	    for (var i = 0; i < uvMap.values.length; i++) {
	      uvMap.values.getAt(i, uv);
	      uvVec3.set(uv.x, uv.y, 0);
	      uvVec3.applyMatrix4(uvTransform);
	      uv.set(uvVec3.x, uvVec3.y);
	      uvValues.setAt(i, uv);
	    }

	    var resultMesh = new _PolyMesh2.default(mesh);

	    var newUVMap = new _PolyMap2.default({
	      faceRangeOffsets: mesh.faceRangeOffsets,
	      faceValueIndices: uvMap.faceValueIndices,
	      values: uvValues
	    });

	    resultMesh.uvMaps.set(mapChannel, newUVMap);

	    primitive.mesh = resultMesh;
	  }
	};

	function getUVTransform(rotation, tiling, useScale, scale, translation, pivotCenter) {

	  var result = new THREE.Matrix4();

	  result.multiply(new THREE.Matrix4().makeTranslation(pivotCenter.x, pivotCenter.y, 0));
	  result.multiply(new THREE.Matrix4().makeRotationZ(THREE.Math.degToRad(rotation)));
	  if (useScale) {
	    result.multiply(new THREE.Matrix4().makeScale(scale.x, scale.y, 0));
	  } else {
	    var safeInverse = function safeInverse(v) {
	      return v == 0 ? 1 : 1 / v;
	    };

	    result.multiply(new THREE.Matrix4().makeScale(safeInverse(tiling.x), safeInverse(tiling.y), 0));
	  }

	  result.multiply(new THREE.Matrix4().makeTranslation(-pivotCenter.x, -pivotCenter.y, 0));
	  result.multiply(new THREE.Matrix4().makeTranslation(translation.x, translation.y, 0));

	  return result;
	};

	exports.default = UVTransform;

/***/ },
/* 239 */
/*!****************************************!*\
  !*** ./src/operators/PolyMesh/Skin.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _PolyMap = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _PolyMesh = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Skin = {
	  schema: {
	    boneNodeList: { type: 'NodeList', label: 'Select Bones', plug: 'Bone' },
	    optionalRootBone: { type: 'Node', label: 'Optional Root Bone', defaultValue: null, filter: function filter(n) {
	        return n.isBone();
	      } }
	  },

	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node,
	        getWorldTransform = _ref.getWorldTransform;

	    var skinWorldTransform = getWorldTransform(node.id);

	    // Ensure we reference the bone node list, so that the dependency
	    // graph gets updated properly.
	    var nodeList = operator.boneNodeList;
	    var rootBone = operator.optionalRootBone;
	    var rootBoneIndex = -1;

	    if (nodeList.length === 0) return primitive;

	    //get world transforms for each bone
	    var boneWorldTransforms = nodeList.map(function (boneNode) {
	      return getWorldTransform(boneNode);
	    });

	    //get the index of the root bone
	    if (rootBone) {
	      for (var i = 0, il = nodeList.length; i < il; i++) {
	        var boneNode = nodeList[i];
	        if (boneNode == rootBone) {
	          rootBoneIndex = i;
	          break;
	        }
	      }
	    }

	    var polyMesh = primitive.mesh;
	    var skinToWorldTransform = skinWorldTransform;

	    primitive.mesh = skin(polyMesh, skinToWorldTransform, boneWorldTransforms, rootBoneIndex);
	  }
	};

	function skin(polyMesh, skinToWorldTransform, boneWorldTransforms, rootBoneIndex) {
	  if (!polyMesh || !polyMesh.skinning) {
	    return polyMesh;
	  }

	  var skinning = polyMesh.skinning;
	  var newValues = skinning.applyTransforms(polyMesh.positions.values, skinToWorldTransform, boneWorldTransforms, rootBoneIndex);

	  var newPositions = new _PolyMap2.default({
	    faceRangeOffsets: polyMesh.faceRangeOffsets,
	    faceValueIndices: polyMesh.positions.faceValueIndices,
	    values: newValues
	  });

	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.positions = newPositions;

	  return resultMesh;
	};

	exports.default = Skin;

/***/ },
/* 240 */
/*!***************************************!*\
  !*** ./src/operators/PolyMesh/Box.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Box = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Box */ 241);

	var _Box2 = _interopRequireDefault(_Box);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Box = {
	  schema: {
	    depth: { type: 'Number', label: 'Depth', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    width: { type: 'Number', label: 'Width', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    height: { type: 'Number', label: 'Height', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    depthSegments: { type: 'Number', label: 'Depth Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true, i18n: { en: {}, xn: { label: 'XXX' }, hn: { label: 'DX' } } },
	    widthSegments: { type: 'Number', label: 'Width Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true },
	    heightSegments: { type: 'Number', label: 'Height Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true }
	  },

	  update: function update(operator, primitive) {
	    var width = operator.width,
	        height = operator.height,
	        depth = operator.depth,
	        widthSegments = operator.widthSegments,
	        heightSegments = operator.heightSegments,
	        depthSegments = operator.depthSegments;

	    primitive.mesh = (0, _Box2.default)(width, height, depth, widthSegments, heightSegments, depthSegments);
	  }
	};

	exports.default = Box;

/***/ },
/* 241 */
/*!**************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Box.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Box;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _removeDuplicateValues = __webpack_require__(/*! ../operator/removeDuplicateValues */ 242);

	var _removeDuplicateValues2 = _interopRequireDefault(_removeDuplicateValues);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Box(width, height, depth, widthSegments, heightSegments, depthSegments) {

	  widthSegments = Math.floor(widthSegments) || 1;
	  heightSegments = Math.floor(heightSegments) || 1;
	  depthSegments = Math.floor(depthSegments) || 1;

	  var faceRangeOffsets = new Uint32Array(widthSegments * heightSegments * 2 + widthSegments * depthSegments * 2 + heightSegments * depthSegments * 2 + 1); //number of faces
	  var faceValueIndices = new Uint32Array((widthSegments * heightSegments * 2 + widthSegments * depthSegments * 2 + heightSegments * depthSegments * 2) * 4); //number of faces*4
	  var values = new _ObjectArrayView2.default(THREE.Vector3, (widthSegments + 1) * (heightSegments + 1) * 2 + (widthSegments + 1) * (depthSegments + 1) * 2 + (heightSegments + 1) * (depthSegments + 1) * 2);
	  var normals = new _ObjectArrayView2.default(THREE.Vector3, (widthSegments + 1) * (heightSegments + 1) * 2 + (widthSegments + 1) * (depthSegments + 1) * 2 + (heightSegments + 1) * (depthSegments + 1) * 2);
	  var uvValues = new _ObjectArrayView2.default(THREE.Vector2, (widthSegments + 1) * (heightSegments + 1) * 2 + (widthSegments + 1) * (depthSegments + 1) * 2 + (heightSegments + 1) * (depthSegments + 1) * 2);

	  var segment_width = width / widthSegments;
	  var segment_height = height / heightSegments;
	  var segment_depth = depth / depthSegments;

	  var width_half = width / 2;
	  var height_half = height / 2;
	  var depth_half = depth / 2;

	  var ix = void 0,
	      iy = void 0,
	      iz = void 0;
	  var indOffset = 0;

	  var newValue = new THREE.Vector3();
	  var newNormal = new THREE.Vector3();
	  var newUV = new THREE.Vector2();

	  //push utility for faceValueIndices
	  var indLengthMarker = 0;
	  function pushInd(value) {
	    faceValueIndices[indLengthMarker] = value;
	    indLengthMarker++;
	  }

	  //populate FaceRangeOffsets
	  for (iz = 0, ix = 0; iz < faceRangeOffsets.length; iz++, ix += 4) {
	    faceRangeOffsets[iz] = ix; //0 4 8 12 16 20 ...
	  }

	  //front and back
	  for (iz = 0; iz < 2; iz++) {
	    //do twice, one for each face
	    for (iy = 0; iy < heightSegments; iy++) {
	      for (ix = 0; ix < widthSegments; ix++) {
	        pushInd(indOffset + iy * (widthSegments + 1) + ix);
	        pushInd(indOffset + iy * (widthSegments + 1) + ix + 1);
	        pushInd(indOffset + (iy + 1) * (widthSegments + 1) + ix + 1);
	        pushInd(indOffset + (iy + 1) * (widthSegments + 1) + ix);
	      }
	    }

	    indOffset += (widthSegments + 1) * (heightSegments + 1);
	  }

	  //top and bottom face
	  for (iy = 0; iy < 2; iy++) {
	    //do twice, one for each face
	    for (ix = 0; ix < widthSegments; ix++) {
	      for (iz = 0; iz < depthSegments; iz++) {
	        pushInd(indOffset + ix * (depthSegments + 1) + iz);
	        pushInd(indOffset + ix * (depthSegments + 1) + iz + 1);
	        pushInd(indOffset + (ix + 1) * (depthSegments + 1) + iz + 1);
	        pushInd(indOffset + (ix + 1) * (depthSegments + 1) + iz);
	      }
	    }

	    indOffset += (widthSegments + 1) * (depthSegments + 1);
	  }

	  //left and right face
	  for (ix = 0; ix < 2; ix++) {
	    //do twice, one for each face
	    for (iz = 0; iz < depthSegments; iz++) {
	      for (iy = 0; iy < heightSegments; iy++) {
	        pushInd(indOffset + iz * (heightSegments + 1) + iy);
	        pushInd(indOffset + iz * (heightSegments + 1) + iy + 1);
	        pushInd(indOffset + (iz + 1) * (heightSegments + 1) + iy + 1);
	        pushInd(indOffset + (iz + 1) * (heightSegments + 1) + iy);
	      }
	    }

	    indOffset += (depthSegments + 1) * (heightSegments + 1);
	  }

	  //push utility for faceValueIndices
	  var valLengthMarker = 0;
	  function pushVal(value) {
	    values.setAt(valLengthMarker, value);
	    valLengthMarker++;
	  }

	  //push utility for uv's and normals
	  var uv_normLengthMarker = 0;
	  function push_uv_norm(uv, norm) {
	    uvValues.setAt(uv_normLengthMarker, uv);
	    normals.setAt(uv_normLengthMarker, norm);
	    uv_normLengthMarker++;
	  }

	  //populate values, normals, and uv values
	  //front and back
	  for (iz = -1; iz < 2; iz += 2) {
	    //do twice for each side with -1 for first and +1 for second
	    for (iy = 0; iy < heightSegments + 1; iy++) {

	      //calculate y coord
	      var y = -1 * iz * iy * segment_height + iz * height_half;

	      for (ix = 0; ix < widthSegments + 1; ix++) {
	        //calculate x coord
	        var x = ix * segment_width - width_half;

	        //set value
	        newValue.set(x, y, -1 * iz * depth_half);
	        pushVal(newValue);

	        //set normal
	        newNormal.set(0, 0, -1 * iz);

	        //set uv value
	        newUV.set(ix / widthSegments, iy / heightSegments);
	        push_uv_norm(newUV, newNormal);
	      }
	    }
	  }

	  //top and bottom
	  for (iy = -1; iy < 2; iy += 2) {
	    //do twice for each side with -1 for first and +1 for second
	    for (ix = 0; ix < widthSegments + 1; ix++) {

	      //calculate z coord
	      var _x = -1 * ix * iy * segment_width + iy * width_half;

	      for (iz = 0; iz < depthSegments + 1; iz++) {
	        //calculate x coord
	        var z = iz * segment_depth - depth_half;

	        //set value
	        newValue.set(_x, -1 * iy * height_half, z);
	        pushVal(newValue);

	        //set normal
	        newNormal.set(0, -1 * iy, 0);

	        //set uv value
	        newUV.set(ix / widthSegments, iz / depthSegments);
	        push_uv_norm(newUV, newNormal);
	      }
	    }
	  }

	  //left and right
	  for (ix = -1; ix < 2; ix += 2) {
	    //do twice for each side with -1 for first and +1 for second
	    for (iz = 0; iz < depthSegments + 1; iz++) {

	      //calculate y coord
	      var _z = -1 * ix * iz * segment_depth + ix * depth_half;

	      for (iy = 0; iy < heightSegments + 1; iy++) {
	        //calculate z coord
	        var _y = iy * segment_height - height_half;

	        //set value
	        newValue.set(-1 * ix * width_half, _y, _z);
	        pushVal(newValue);

	        //set normal
	        newNormal.set(-1 * ix, 0, 0);

	        //set uv value
	        newUV.set(iz / depthSegments, iy / heightSegments);
	        push_uv_norm(newUV, newNormal);
	      }
	    }
	  }

	  var positionsMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: values
	  });

	  var normalMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: normals
	  });

	  var uvMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: uvValues
	  });

	  var uvMapsByName = new _ObjectsByName2.default();
	  uvMapsByName.set('default', uvMap);

	  var polyMesh = new _PolyMesh2.default();
	  polyMesh.faceRangeOffsets = faceRangeOffsets;
	  polyMesh.positions = positionsMap;
	  polyMesh.normalMap = normalMap;
	  polyMesh.uvMaps = uvMapsByName;

	  return (0, _removeDuplicateValues2.default)(polyMesh);
	};

/***/ },
/* 242 */
/*!******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeDuplicateValues.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _map = __webpack_require__(/*! babel-runtime/core-js/map */ 243);

	var _map2 = _interopRequireDefault(_map);

	exports.default = removeDuplicateValues;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ObjectBuffer = __webpack_require__(/*! ../../generic/container/ObjectBuffer */ 197);

	var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function removeDuplicateValues(polyMesh, withLogging) {

	  //removes indentical values in the values array and remaps the indices
	  //also has the side effect of removing values not used by a face

	  var l = withLogging || false;

	  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
	  var values = polyMesh.positions.values;

	  var newValues = new _ObjectBuffer2.default(THREE.Vector3);

	  var valueMappings = new _map2.default();
	  var newValuesLength = 0;

	  var key = 0;
	  var newIndex = 0;
	  var value = new THREE.Vector3();
	  var keyValue = new THREE.Vector3();

	  var boundingBox = new THREE.Box3();
	  boundingBox.setFromArray(new Float32Array(values.data));
	  var boundingBoxDiagonalWithShift = boundingBox.getSize().length() * Math.pow(2, 17);

	  for (var ix = 0; ix < faceValueIndices.length; ix++) {

	    values.getAt(faceValueIndices[ix], value);
	    //hash function scales values to the diagonal of the bounding box and stores 17 bits of precision in 3 buckets in a 64 bit float (52 bits usable)
	    keyValue.subVectors(value, boundingBox.min).multiplyScalar(boundingBoxDiagonalWithShift);
	    key = keyValue.x * 1000000000000 + keyValue.y * 100000 + keyValue.z;

	    if (!valueMappings.has(key)) {
	      valueMappings.set(key, newValuesLength); //save location of value in map
	      newIndex = newValuesLength;
	      newValues.push(value); //push value to the newValues array
	      newValuesLength++;
	    } else {
	      newIndex = valueMappings.get(key);
	    }

	    faceValueIndices[ix] = newIndex; //update indices array with new value
	  }

	  if (l) console.log('' + values.length + ' values reduced to ' + newValuesLength + ', duplicates removed: ' + (values.length - newValuesLength));

	  if (values.length === newValuesLength) return polyMesh;

	  var newValuesArray = new _ObjectArrayView2.default(THREE.Vector3, newValuesLength);
	  newValuesArray.fromArray(newValues.toArray());

	  var newPositions = new _PolyMap2.default({
	    faceRangeOffsets: polyMesh.faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: newValuesArray
	  });

	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.positions = newPositions;

	  resultMesh.topologyChanged();
	  return resultMesh;
	};

/***/ },
/* 243 */
/*!****************************************!*\
  !*** ./~/babel-runtime/core-js/map.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/map */ 244), __esModule: true };

/***/ },
/* 244 */
/*!*****************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/map.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/es6.object.to-string */ 83);
	__webpack_require__(/*! ../modules/es6.string.iterator */ 5);
	__webpack_require__(/*! ../modules/web.dom.iterable */ 84);
	__webpack_require__(/*! ../modules/es6.map */ 245);
	__webpack_require__(/*! ../modules/es7.map.to-json */ 251);
	module.exports = __webpack_require__(/*! ../modules/_core */ 13).Map;

/***/ },
/* 245 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.map.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(/*! ./_collection-strong */ 246);

	// 23.1 Map Objects
	module.exports = __webpack_require__(/*! ./_collection */ 247)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 246 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_collection-strong.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(/*! ./_object-dp */ 17).f
	  , create      = __webpack_require__(/*! ./_object-create */ 30)
	  , redefineAll = __webpack_require__(/*! ./_redefine-all */ 95)
	  , ctx         = __webpack_require__(/*! ./_ctx */ 14)
	  , anInstance  = __webpack_require__(/*! ./_an-instance */ 89)
	  , defined     = __webpack_require__(/*! ./_defined */ 8)
	  , forOf       = __webpack_require__(/*! ./_for-of */ 90)
	  , $iterDefine = __webpack_require__(/*! ./_iter-define */ 9)
	  , step        = __webpack_require__(/*! ./_iter-step */ 87)
	  , setSpecies  = __webpack_require__(/*! ./_set-species */ 96)
	  , DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ 21)
	  , fastKey     = __webpack_require__(/*! ./_meta */ 119).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';

	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 247 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_collection.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(/*! ./_global */ 12)
	  , $export        = __webpack_require__(/*! ./_export */ 11)
	  , meta           = __webpack_require__(/*! ./_meta */ 119)
	  , fails          = __webpack_require__(/*! ./_fails */ 22)
	  , hide           = __webpack_require__(/*! ./_hide */ 16)
	  , redefineAll    = __webpack_require__(/*! ./_redefine-all */ 95)
	  , forOf          = __webpack_require__(/*! ./_for-of */ 90)
	  , anInstance     = __webpack_require__(/*! ./_an-instance */ 89)
	  , isObject       = __webpack_require__(/*! ./_is-object */ 19)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 45)
	  , dP             = __webpack_require__(/*! ./_object-dp */ 17).f
	  , each           = __webpack_require__(/*! ./_array-methods */ 248)(0)
	  , DESCRIPTORS    = __webpack_require__(/*! ./_descriptors */ 21);

	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }

	  setToStringTag(C, NAME);

	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);

	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

/***/ },
/* 248 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_array-methods.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(/*! ./_ctx */ 14)
	  , IObject  = __webpack_require__(/*! ./_iobject */ 35)
	  , toObject = __webpack_require__(/*! ./_to-object */ 48)
	  , toLength = __webpack_require__(/*! ./_to-length */ 38)
	  , asc      = __webpack_require__(/*! ./_array-species-create */ 249);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 249 */
/*!****************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_array-species-create.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ 250);

	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 250 */
/*!*********************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_array-species-constructor.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , isArray  = __webpack_require__(/*! ./_is-array */ 123)
	  , SPECIES  = __webpack_require__(/*! ./_wks */ 46)('species');

	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 251 */
/*!**********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es7.map.to-json.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(/*! ./_export */ 11);

	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(/*! ./_collection-to-json */ 252)('Map')});

/***/ },
/* 252 */
/*!**************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_collection-to-json.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(/*! ./_classof */ 54)
	  , from    = __webpack_require__(/*! ./_array-from-iterable */ 253);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 253 */
/*!***************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_array-from-iterable.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(/*! ./_for-of */ 90);

	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 254 */
/*!******************************************!*\
  !*** ./src/operators/PolyMesh/Sphere.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Sphere = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Sphere */ 255);

	var _Sphere2 = _interopRequireDefault(_Sphere);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Sphere = {
	  schema: {
	    radius: { label: 'Radius', type: 'Number', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    widthSegments: { label: 'Longitudinal Segments', type: 'Integer', defaultValue: 24, minValue: 3, maxValue: 200, step: 1, animatable: true },
	    heightSegments: { label: 'Latitudinal Segments', type: 'Integer', defaultValue: 24, minValue: 3, maxValue: 200, step: 1, animatable: true },
	    phiStart: { label: 'Phi Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    phiLength: { label: 'Phi Length', type: 'Number', defaultValue: 360, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    thetaStart: { label: 'Theta Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 180, step: 10, animatable: true },
	    thetaLength: { label: 'Theta Length', type: 'Number', defaultValue: 180, minValue: 0, maxValue: 180, step: 10, animatable: true }
	  },

	  update: function update(operator, primitive) {
	    var radius = operator.radius,
	        widthSegments = operator.widthSegments,
	        heightSegments = operator.heightSegments,
	        phiStart = operator.phiStart,
	        phiLength = operator.phiLength,
	        thetaStart = operator.thetaStart,
	        thetaLength = operator.thetaLength;

	    primitive.mesh = (0, _Sphere2.default)(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
	  }
	};

	exports.default = Sphere;

/***/ },
/* 255 */
/*!*****************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Sphere.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Sphere;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _Lathe = __webpack_require__(/*! ./Lathe */ 256);

	var _Lathe2 = _interopRequireDefault(_Lathe);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Sphere(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {

	  radius = radius || 50;

	  widthSegments = Math.max(3, Math.floor(widthSegments || 8));
	  heightSegments = Math.max(2, Math.floor(heightSegments || 6));

	  phiStart = THREE.Math.clamp(phiStart || 0, 0, Math.PI * 2);
	  phiLength = THREE.Math.clamp(phiLength || Math.PI * 2, 0, Math.PI * 2 - phiStart);

	  thetaStart = THREE.Math.clamp(thetaStart || 0, 0, Math.PI);
	  thetaLength = THREE.Math.clamp(thetaLength || Math.PI, 0, Math.PI - thetaStart);

	  var inverseHeightSegments = 1.0 / heightSegments;
	  var points = new _ObjectArrayView2.default(THREE.Vector3, heightSegments + 1);
	  var norms = new _ObjectArrayView2.default(THREE.Vector3, heightSegments + 1);
	  var pt = new THREE.Vector3();

	  for (var i = 0, il = heightSegments; i <= il; i++) {

	    var theta = thetaStart + i * inverseHeightSegments * thetaLength;

	    pt.set(radius * Math.sin(theta), -radius * Math.cos(theta), 0);

	    points.setAt(i, pt);
	    norms.setAt(i, pt.normalize());
	  }

	  return (0, _Lathe2.default)(points, norms, widthSegments, phiStart, phiLength);
	}

/***/ },
/* 256 */
/*!****************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Lathe.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Lathe;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _cleanPolyMesh = __webpack_require__(/*! ../operator/cleanPolyMesh */ 257);

	var _cleanPolyMesh2 = _interopRequireDefault(_cleanPolyMesh);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Lathe(points, norms, segments, phiStart, phiLength) {
	  //assumes one normal per point
	  var positions = new _ObjectArrayView2.default(THREE.Vector3, (segments + 1) * points.length);
	  var normals = new _ObjectArrayView2.default(THREE.Vector3, (segments + 1) * norms.length);
	  var positionCounter = 0;
	  var faceRangeOffsets = new Uint32Array(segments * (points.length - 1) + 1); //number of faces
	  var faceValueIndices = new Uint32Array(segments * (points.length - 1) * 4); //number of faces*4
	  var indCounter = 0;
	  var uvValues = new _ObjectArrayView2.default(THREE.Vector2, (segments + 1) * points.length);
	  var uvCounter = 0;

	  segments = segments || 12;
	  phiStart = phiStart || 0;
	  phiLength = phiLength || 2 * Math.PI;

	  var inversePointLength = 1.0 / (points.length - 1);
	  var inverseSegments = 1.0 / segments;

	  faceRangeOffsets[0] = 0;
	  var faceCounter = 1;

	  var tempUV = new THREE.Vector2();
	  var vertex = new THREE.Vector3();
	  var normal = new THREE.Vector3();

	  var rotationMatrix4 = new THREE.Matrix4().identity();
	  var rotationMatrix = new THREE.Matrix3().identity();

	  for (var i = 0, il = segments; i <= il; i++) {

	    var phi = phiStart + i * inverseSegments * phiLength;
	    rotationMatrix4.copy(rotationMatrix4.makeRotationY(phi));
	    rotationMatrix.getNormalMatrix(rotationMatrix4);

	    var u = i * inverseSegments;

	    for (var j = 0, jl = points.length; j < jl; j++) {

	      points.getAt(j, vertex);
	      norms.getAt(j, normal);

	      vertex.applyMatrix3(rotationMatrix);
	      normal.applyMatrix3(rotationMatrix);

	      vertex.set(Math.round(vertex.x * 1000) / 1000, Math.round(vertex.y * 1000) / 1000, Math.round(vertex.z * 1000) / 1000);

	      normal.set(Math.round(normal.x * 1000) / 1000, Math.round(normal.y * 1000) / 1000, Math.round(normal.z * 1000) / 1000);

	      positions.setAt(positionCounter, vertex);
	      normals.setAt(positionCounter, normal);

	      var v = j / (points.length - 1);

	      tempUV.set(u, v);
	      uvValues.setAt(positionCounter++, tempUV);
	    }
	  }

	  var np = points.length;

	  for (var _i = 0, _il = segments; _i < _il; _i++) {

	    for (var _j = 0, _jl = points.length - 1; _j < _jl; _j++) {

	      var base = _j + np * _i;
	      var a = base;
	      var b = base + np;
	      var c = base + 1 + np;
	      var d = base + 1;

	      faceValueIndices[indCounter++] = a;
	      faceValueIndices[indCounter++] = b;
	      faceValueIndices[indCounter++] = c;
	      faceValueIndices[indCounter++] = d;
	      faceRangeOffsets[faceCounter++] = indCounter;
	    }
	  }

	  var positionsMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: positions
	  });

	  var normalMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: normals
	  });

	  var uvMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: uvValues
	  });

	  var uvMapsByName = new _ObjectsByName2.default();
	  var name = 'default';
	  uvMapsByName.set(name, uvMap);

	  var polyMesh = new _PolyMesh2.default();
	  polyMesh.faceRangeOffsets = positionsMap.faceRangeOffsets;
	  polyMesh.positions = positionsMap;
	  polyMesh.normalMap = normalMap;
	  polyMesh.uvMaps = uvMapsByName;

	  return (0, _cleanPolyMesh2.default)(new _PolyMesh2.default(polyMesh));
	  //return new PolyMesh( new PolyMesh( polyMesh ) );
	}

/***/ },
/* 257 */
/*!**********************************************************!*\
  !*** ./src/polyMesh/geometric/operator/cleanPolyMesh.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = cleanPolyMesh;

	var _removeDuplicateValues = __webpack_require__(/*! ../operator/removeDuplicateValues */ 242);

	var _removeDuplicateValues2 = _interopRequireDefault(_removeDuplicateValues);

	var _removeDuplicateIndices = __webpack_require__(/*! ../operator/removeDuplicateIndices */ 258);

	var _removeDuplicateIndices2 = _interopRequireDefault(_removeDuplicateIndices);

	var _removeInvalidSurfaces = __webpack_require__(/*! ../operator/removeInvalidSurfaces */ 259);

	var _removeInvalidSurfaces2 = _interopRequireDefault(_removeInvalidSurfaces);

	var _removeDuplicateNormals = __webpack_require__(/*! ../operator/removeDuplicateNormals */ 223);

	var _removeDuplicateNormals2 = _interopRequireDefault(_removeDuplicateNormals);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function cleanPolyMesh(polyMesh) {
	  //not advisable to remove normals by default. can lead to fusing of normals on joints while doing animation
	  //return removeDuplicateNormals(removeInvalidSurfaces(removeDuplicateIndices(removeDuplicateValues(polyMesh))));
	  return (0, _removeInvalidSurfaces2.default)((0, _removeDuplicateIndices2.default)((0, _removeDuplicateValues2.default)(polyMesh)));
	}

/***/ },
/* 258 */
/*!*******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeDuplicateIndices.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 101);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	var _map = __webpack_require__(/*! babel-runtime/core-js/map */ 243);

	var _map2 = _interopRequireDefault(_map);

	exports.default = removeDuplicateIndices;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	var _ObjectBuffer = __webpack_require__(/*! ../../generic/container/ObjectBuffer */ 197);

	var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function removeDuplicateIndices(polyMesh, withLogging) {

	  var l = withLogging || false;

	  var faceRangeOffsets = new Uint32Array(polyMesh.positions.faceRangeOffsets);
	  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
	  var normalFaceValueIndices = new Uint32Array(polyMesh.normalMap.faceValueIndices);

	  var uvMapNames = [];
	  var uvMapsNewIndices = [];
	  if (polyMesh.uvMaps) {
	    for (var i = 0; i < polyMesh.uvMaps.length; i++) {
	      uvMapNames.push(polyMesh.uvMaps.namesByIndex[i]);
	      uvMapsNewIndices.push(new Uint32Array(polyMesh.uvMaps.byName[uvMapNames[i]].faceValueIndices));
	    }
	  }

	  var newIndicesMarker = 0;

	  var previousFaceIndex = 0;
	  var currentFaceIndex = 0;
	  var currentFaceSize = 0;
	  var newFaceSize = 0;

	  //stores [index value, index];
	  var uniqueIndicesMap = new _map2.default();

	  //Check every face
	  for (var _i = 1; _i < faceRangeOffsets.length; _i++) {

	    currentFaceIndex = faceRangeOffsets[_i];
	    currentFaceSize = currentFaceIndex - previousFaceIndex;
	    newFaceSize = currentFaceSize;

	    //check unique
	    uniqueIndicesMap.clear();
	    for (var j = 0; j < currentFaceSize; j++) {
	      uniqueIndicesMap.set(faceValueIndices[previousFaceIndex + j], previousFaceIndex + j);
	    }

	    newFaceSize = uniqueIndicesMap.size;
	    //special case face of size 1
	    if (newFaceSize === 1) {
	      if (l && currentFaceSize > 1) console.log('Face ' + _i + ' has only 1 unique value. Reducing to a point...');
	      faceRangeOffsets[_i] = faceRangeOffsets[_i - 1] + 1;
	      faceValueIndices[newIndicesMarker++] = faceValueIndices[previousFaceIndex];
	    } else {
	      if (l && currentFaceSize === 2) console.log('Face ' + _i + ' has only 2 unique values. Reducing to a line...');

	      faceRangeOffsets[_i] = faceRangeOffsets[_i - 1] + newFaceSize;
	      var entries = uniqueIndicesMap.entries();

	      var element = void 0;
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = (0, _getIterator3.default)(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          element = _step.value;

	          normalFaceValueIndices[newIndicesMarker] = normalFaceValueIndices[element[1]];
	          for (var k = 0; k < uvMapsNewIndices.length; k++) {
	            uvMapsNewIndices[k][newIndicesMarker] = uvMapsNewIndices[k][element[1]];
	          }

	          faceValueIndices[newIndicesMarker++] = element[0];
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }

	    previousFaceIndex = currentFaceIndex;
	  }

	  if (l) console.log('' + faceValueIndices.length + ' index values reduced to ' + newIndicesMarker + ', duplicates removed: ' + (faceValueIndices.length - newIndicesMarker));

	  var newIndices = new Uint32Array(faceValueIndices.subarray(0, newIndicesMarker));
	  var newNormalIndices = new Uint32Array(normalFaceValueIndices.subarray(0, newIndicesMarker));

	  var positions = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: newIndices,
	    values: polyMesh.positions.values
	  });

	  var results = new _PolyMesh2.default();
	  results.positions = positions;
	  results.faceRangeOffsets = results.positions.faceRangeOffsets;

	  var normalMap = new _PolyMap2.default({
	    faceRangeOffsets: results.faceRangeOffsets,
	    faceValueIndices: newNormalIndices,
	    values: polyMesh.normalMap.values
	  });
	  results.normalMap = normalMap;

	  if (polyMesh.uvMaps) {
	    var uvMaps = new _ObjectsByName2.default();
	    for (var _i2 = 0; _i2 < polyMesh.uvMaps.length; _i2++) {
	      var name = polyMesh.uvMaps.namesByIndex[_i2];
	      var uvMap = new _PolyMap2.default({
	        faceRangeOffsets: results.faceRangeOffsets,
	        faceValueIndices: uvMapsNewIndices[_i2],
	        values: polyMesh.uvMaps.byName[name].values
	      });
	      uvMaps.set(name, uvMap);
	    }

	    results.uvMaps = uvMaps;
	  }

	  return results;
	};

/***/ },
/* 259 */
/*!******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeInvalidSurfaces.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeInvalidSurfaces;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _removeUnusedValues = __webpack_require__(/*! ../operator/removeUnusedValues */ 260);

	var _removeUnusedValues2 = _interopRequireDefault(_removeUnusedValues);

	var _applyFunctionToPolyMap = __webpack_require__(/*! ./applyFunctionToPolyMap */ 261);

	var _applyFunctionToPolyMap2 = _interopRequireDefault(_applyFunctionToPolyMap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function removeInvalidSurfaces(polyMesh, withLogging) {

	  //this algorithm assumes no duplicate indices
	  //to remove those use removeDuplicateIndices first

	  function removeInvalidSurfacesFromMap(polyMap, polyMapName, additionalArguments) {
	    var l = additionalArguments.withLogging || false;

	    var faceRangeOffsets = new Uint32Array(polyMap.faceRangeOffsets);
	    var faceValueIndices = new Uint32Array(polyMap.faceValueIndices);
	    var values = polyMap.values;

	    var currentFaceIndex = 0;
	    var previousFaceIndex = 0;
	    var size = 0;

	    var newFacesMarker = 1;
	    var newIndicesMarker = 0;

	    for (var i = 1; i < faceRangeOffsets.length; i++) {

	      currentFaceIndex = faceRangeOffsets[i];
	      size = currentFaceIndex - previousFaceIndex;

	      if (size > 2) {
	        //store face
	        faceRangeOffsets[newFacesMarker] = faceRangeOffsets[newFacesMarker - 1] + size;
	        newFacesMarker++;

	        //store all the indices on that face
	        for (var j = 0; j < size; j++) {
	          faceValueIndices[newIndicesMarker++] = faceValueIndices[previousFaceIndex + j];
	        }
	      } else if (l) {
	        console.log('Removed face ' + i + ' of size ' + size);
	      }

	      previousFaceIndex = currentFaceIndex;
	    }

	    var newFaceRangeOffsets = new Uint32Array(faceRangeOffsets.subarray(0, newFacesMarker));
	    var newFaceValueIndices = new Uint32Array(faceValueIndices.subarray(0, newIndicesMarker));

	    var resultMap = new _PolyMap2.default({
	      faceRangeOffsets: newFaceRangeOffsets,
	      faceValueIndices: newFaceValueIndices,
	      values: values
	    });
	    return resultMap;
	  }

	  var args = { withLogging: withLogging };
	  var resultMesh = (0, _applyFunctionToPolyMap2.default)(polyMesh, removeInvalidSurfacesFromMap, args);

	  if (withLogging) console.log('' + (polyMesh.faceRangeOffsets.length - 1) + ' faces reduced to ' + (resultMesh.faceRangeOffsets.length - 1) + ', faces removed: ' + (polyMesh.faceRangeOffsets.length - resultMesh.faceRangeOffsets.length));

	  return (0, _removeUnusedValues2.default)(resultMesh).topologyChanged();
	}

/***/ },
/* 260 */
/*!***************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeUnusedValues.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _map = __webpack_require__(/*! babel-runtime/core-js/map */ 243);

	var _map2 = _interopRequireDefault(_map);

	exports.default = removeUnusedValues;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function removeUnusedValues(polyMesh, withLogging) {

	  var l = withLogging || false;

	  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
	  var values = polyMesh.positions.values;

	  var newValues = new _ObjectArrayView2.default(THREE.Vector3, values.length);

	  var valueMappings = new _map2.default();
	  var newValuesLength = 0;

	  var newIndex = 0;
	  var value = new THREE.Vector3();

	  for (var i = 0; i < faceValueIndices.length; i++) {
	    if (!valueMappings.has(faceValueIndices[i])) {
	      valueMappings.set(faceValueIndices[i], newValuesLength);
	      newIndex = newValuesLength;
	      values.getAt(faceValueIndices[i], value);
	      newValues.setAt(newValuesLength, value);
	      newValuesLength++;
	    } else {
	      newIndex = valueMappings.get(faceValueIndices[i]);
	    }

	    faceValueIndices[i] = newIndex;
	  }

	  if (l) console.log('' + values.length + ' values reduced to ' + newValuesLength + ', unused values removed: ' + (values.length - newValuesLength));

	  if (values.length === newValuesLength) return polyMesh;

	  var newValuesArray = new _ObjectArrayView2.default(THREE.Vector3, newValuesLength);
	  newValuesArray.fromArray(newValues.toArray());

	  var newPositions = new _PolyMap2.default({
	    faceRangeOffsets: polyMesh.faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: newValuesArray
	  });

	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.positions = newPositions;

	  return resultMesh;
	};

/***/ },
/* 261 */
/*!*******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/applyFunctionToPolyMap.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = applyFunctionToPolyMap;

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function applyFunctionToPolyMap(polyMesh, applyToPolyMapFunction, additionalArguments) {
	  var args = additionalArguments || {};

	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.positions = applyToPolyMapFunction(resultMesh.positions, 'positions', args);
	  if (resultMesh.normalMap) resultMesh.normalMap = applyToPolyMapFunction(resultMesh.normalMap, 'normalMap', args);

	  var uvMaps = new _ObjectsByName2.default();
	  for (var i = 0; i < polyMesh.uvMaps.length; i++) {
	    var name = polyMesh.uvMaps.namesByIndex[i];
	    var uvMap = applyToPolyMapFunction(polyMesh.uvMaps.byName[name], name, args);
	    uvMaps.set(name, uvMap);
	  }

	  resultMesh.uvMaps = uvMaps;
	  resultMesh.faceRangeOffsets = resultMesh.positions.faceRangeOffsets;

	  return resultMesh;
	};

/***/ },
/* 262 */
/*!****************************************!*\
  !*** ./src/operators/PolyMesh/Cone.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Cone = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Cone */ 263);

	var _Cone2 = _interopRequireDefault(_Cone);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Cone = {
	  schema: {
	    base: { type: 'Number', label: 'Base Radius', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    height: { type: 'Number', label: 'Height', defaultValue: 1, minValue: 0.0, step: 0.1, animatable: true },
	    radiusSegments: { label: 'Radial Segments', type: 'Integer', defaultValue: 12, minValue: 3, maxValue: 200, animatable: true },
	    heightSegments: { label: 'Height Segments', type: 'Integer', defaultValue: 1, minValue: 1, maxValue: 200, animatable: true },
	    openEnded: { label: 'Open Base', type: 'Boolean', defaultValue: false, animatable: true }
	  },

	  update: function update(operator, primitive) {
	    var base = operator.base,
	        height = operator.height,
	        radiusSegments = operator.radiusSegments,
	        heightSegments = operator.heightSegments;

	    primitive.mesh = (0, _Cone2.default)(base, radiusSegments, height);
	  }
	};

	exports.default = Cone;

/***/ },
/* 263 */
/*!***************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Cone.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Cone;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _Lathe = __webpack_require__(/*! ./Lathe */ 256);

	var _Lathe2 = _interopRequireDefault(_Lathe);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Cone(radius, segments, height, thetaStart, thetaLength) {

	  radius = radius || 50;

	  segments = Math.max(1, Math.floor(segments || 8));
	  var segmentLength = radius / segments;
	  var heightSegmentLength = height / segments;

	  thetaStart = THREE.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = THREE.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);

	  var points = new _ObjectArrayView2.default(THREE.Vector3, (segments + 1) * 2);
	  var norms = new _ObjectArrayView2.default(THREE.Vector3, (segments + 1) * 2);
	  var normPt = new THREE.Vector3(0, -1, 0);
	  var pt = new THREE.Vector3();

	  for (var i = 0, il = segments; i <= il; i++) {

	    pt.set(i * segmentLength, -height / 2, 0);

	    points.setAt(i, pt);
	    norms.setAt(i, normPt);
	  }

	  normPt.set(height, radius, 0);
	  normPt.normalize();
	  for (var _i = 0, _il = segments; _i <= _il; _i++) {

	    pt.set(radius - _i * segmentLength, _i * heightSegmentLength - height / 2, 0);

	    points.setAt(segments + 1 + _i, pt);
	    norms.setAt(segments + 1 + _i, normPt);
	  }

	  var latheSegments = segments < 3 ? 3 : segments;
	  return (0, _Lathe2.default)(points, norms, latheSegments, thetaStart, thetaLength);
	}

/***/ },
/* 264 */
/*!*******************************************!*\
  !*** ./src/operators/PolyMesh/Capsule.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Capsule = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Capsule */ 265);

	var _Capsule2 = _interopRequireDefault(_Capsule);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Capsule = {
	  schema: {
	    radius: { type: 'Number', label: 'Radius', defaultValue: 0.5, minValue: 0.1, step: 0.1 },
	    height: { type: 'Number', label: 'Height', defaultValue: 1, minValue: 0.1, step: 0.1 },
	    radiusSegments: { label: 'Radial Segments', type: 'Integer', defaultValue: 12, minValue: 4, maxValue: 100 },
	    heightSegments: { label: 'Height Segments', type: 'Integer', defaultValue: 10, minValue: 1, maxValue: 100 }
	  },

	  update: function update(operator, primitive) {
	    var radius = operator.radius,
	        height = operator.height,
	        radiusSegments = operator.radiusSegments,
	        heightSegments = operator.heightSegments;

	    primitive.mesh = (0, _Capsule2.default)(radius, height, radiusSegments, heightSegments);
	  }
	};

	exports.default = Capsule;

/***/ },
/* 265 */
/*!******************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Capsule.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Capsule;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _Lathe = __webpack_require__(/*! ./Lathe */ 256);

	var _Lathe2 = _interopRequireDefault(_Lathe);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Capsule(radius, height, radialSegments, heightSegments, thetaStart, thetaLength) {

	  radius = radius !== undefined ? radius : 20;
	  height = height !== undefined ? height : 100;

	  radialSegments = Math.max(1, Math.floor(radialSegments || 8));
	  heightSegments = Math.max(1, Math.floor(heightSegments || 8));

	  thetaStart = THREE.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = THREE.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);

	  var heightSegmentLength = height / heightSegments;
	  var halfHeight = height / 2;
	  var inverseRadialSegments = 1 / radialSegments;

	  var points = new _ObjectArrayView2.default(THREE.Vector3, heightSegments + 1 + (radialSegments + 1) * 2);
	  var norms = new _ObjectArrayView2.default(THREE.Vector3, heightSegments + 1 + (radialSegments + 1) * 2);
	  var pt = new THREE.Vector3();
	  var normPt = new THREE.Vector3();

	  //top
	  for (var i = 0, il = radialSegments; i <= il; i++) {

	    var theta = i * (Math.PI / 2) * inverseRadialSegments;

	    pt.set(radius * Math.sin(theta), -radius * Math.cos(theta) - halfHeight, 0);

	    normPt.set(Math.sin(theta), -Math.cos(theta), 0);

	    points.setAt(i, pt);
	    norms.setAt(i, normPt.normalize());
	  }

	  //body
	  normPt.set(1, 0, 0);
	  for (var _i = 0, _il = heightSegments; _i <= _il; _i++) {

	    pt.set(radius, _i * heightSegmentLength - halfHeight, 0);

	    points.setAt(_i + radialSegments + 1, pt);
	    norms.setAt(_i + radialSegments + 1, normPt);
	  }

	  //bottom
	  for (var _i2 = 0, _il2 = radialSegments; _i2 <= _il2; _i2++) {

	    var _theta = Math.PI / 2 + _i2 * (Math.PI / 2) * inverseRadialSegments;

	    pt.set(radius * Math.sin(_theta), -radius * Math.cos(_theta) + halfHeight, 0);

	    normPt.set(Math.sin(_theta), -Math.cos(_theta), 0);

	    points.setAt(_i2 + radialSegments + heightSegments + 2, pt);
	    norms.setAt(_i2 + radialSegments + heightSegments + 2, normPt.normalize());
	  }

	  var latheSegments = radialSegments < 3 ? 3 : radialSegments;
	  return (0, _Lathe2.default)(points, norms, latheSegments, thetaStart, thetaLength);
	}

/***/ },
/* 266 */
/*!********************************************!*\
  !*** ./src/operators/PolyMesh/Cylinder.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Cylinder = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Cylinder */ 267);

	var _Cylinder2 = _interopRequireDefault(_Cylinder);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Cylinder = {
	  schema: {
	    radiusTop: { type: 'Number', label: 'Top Radius', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    radiusBottom: { type: 'Number', label: 'Bottom Radius', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    height: { type: 'Number', label: 'Height', defaultValue: 1, minValue: 0.0, step: 0.1, animatable: true },
	    radiusSegments: { label: 'Radial Segments', type: 'Integer', defaultValue: 24, minValue: 3, maxValue: 200, animatable: true },
	    heightSegments: { label: 'Height Segments', type: 'Integer', defaultValue: 1, minValue: 1, maxValue: 200, animatable: true },
	    openEnded: { label: 'Open Ended', type: 'Boolean', defaultValue: false, animatable: true }
	  },

	  update: function update(operator, primitive) {
	    var radiusTop = operator.radiusTop,
	        radiusBottom = operator.radiusBottom,
	        height = operator.height,
	        radiusSegments = operator.radiusSegments,
	        heightSegments = operator.heightSegments,
	        openEnded = operator.openEnded;

	    primitive.mesh = (0, _Cylinder2.default)(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded);
	  }
	};

	exports.default = Cylinder;

/***/ },
/* 267 */
/*!*******************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Cylinder.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Cylinder;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _Lathe = __webpack_require__(/*! ./Lathe */ 256);

	var _Lathe2 = _interopRequireDefault(_Lathe);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Cylinder(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

	  radiusTop = radiusTop !== undefined ? radiusTop : 20;
	  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	  height = height !== undefined ? height : 100;

	  openEnded = openEnded || false;

	  radialSegments = Math.max(1, Math.floor(radialSegments || 8));
	  heightSegments = Math.max(1, Math.floor(heightSegments || 8));

	  thetaStart = THREE.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = THREE.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);

	  var heightSegmentLength = height / heightSegments;
	  var halfHeight = height / 2;
	  var slope = (radiusBottom - radiusTop) / height;

	  var radialSegmentsLengthTop = radiusTop / radialSegments;
	  var radialSegmentsLengthBottom = radiusBottom / radialSegments;

	  var points = void 0;
	  var norms = void 0;

	  if (openEnded) {
	    points = new _ObjectArrayView2.default(THREE.Vector3, heightSegments + 1);
	    norms = new _ObjectArrayView2.default(THREE.Vector3, heightSegments + 1);
	  } else {
	    points = new _ObjectArrayView2.default(THREE.Vector3, heightSegments + 1 + (radialSegments + 1) * 2);
	    norms = new _ObjectArrayView2.default(THREE.Vector3, heightSegments + 1 + (radialSegments + 1) * 2);
	  }

	  var pt = new THREE.Vector3();
	  var normPt = new THREE.Vector3(0, -1, 0);

	  if (!openEnded) {
	    //top
	    for (var i = 0, il = radialSegments; i <= il; i++) {

	      pt.set(i * radialSegmentsLengthTop, -1 * halfHeight, 0);
	      points.setAt(i, pt);
	      norms.setAt(i, normPt);
	    }
	  }

	  //body
	  normPt.set(height, radiusTop - radiusBottom, 0);
	  normPt.normalize();
	  for (var _i = 0, _il = heightSegments; _i <= _il; _i++) {

	    pt.set(slope * _i * heightSegmentLength + radiusTop, _i * heightSegmentLength - halfHeight, 0);

	    if (openEnded) {
	      points.setAt(_i, pt);
	      norms.setAt(_i, normPt);
	    } else {
	      points.setAt(_i + radialSegments + 1, pt);
	      norms.setAt(_i + radialSegments + 1, normPt);
	    }
	  }

	  if (!openEnded) {
	    //bottom
	    normPt.set(0, 1, 0);

	    for (var _i2 = 0, _il2 = radialSegments; _i2 <= _il2; _i2++) {

	      pt.set(radiusBottom - _i2 * radialSegmentsLengthBottom, 1 * halfHeight, 0);
	      points.setAt(_i2 + radialSegments + heightSegments + 2, pt);
	      norms.setAt(_i2 + radialSegments + heightSegments + 2, normPt);
	    }
	  }

	  var latheSegments = radialSegments < 3 ? 3 : radialSegments;
	  return (0, _Lathe2.default)(points, norms, latheSegments, thetaStart, thetaLength);
	}

/***/ },
/* 268 */
/*!*****************************************!*\
  !*** ./src/operators/PolyMesh/Plane.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Plane = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Plane */ 269);

	var _Plane2 = _interopRequireDefault(_Plane);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Plane = {
	  schema: {
	    width: { label: 'Width', type: 'Number', defaultValue: 4, minValue: 0.0, step: 0.1, animatable: true },
	    height: { label: 'Height', type: 'Number', defaultValue: 4, minValue: 0.0, step: 0.1, animatable: true },
	    widthSegments: { type: 'Number', label: 'Width Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true },
	    heightSegments: { type: 'Number', label: 'Height Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true }
	  },

	  update: function update(operator, primitive) {
	    var width = operator.width,
	        height = operator.height,
	        widthSegments = operator.widthSegments,
	        heightSegments = operator.heightSegments;

	    primitive.mesh = (0, _Plane2.default)(width, height, widthSegments, heightSegments);
	  }
	};

	exports.default = Plane;

/***/ },
/* 269 */
/*!****************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Plane.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Plane;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 202);

	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 210);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Plane(width, height, widthSegments, heightSegments) {

	  widthSegments = Math.floor(widthSegments);
	  heightSegments = Math.floor(heightSegments);

	  var faceRangeOffsets = new Uint32Array(widthSegments * heightSegments + 1);
	  var faceValueIndices = new Uint32Array(widthSegments * heightSegments * 4);
	  var values = new _ObjectArrayView2.default(THREE.Vector3, (widthSegments + 1) * (heightSegments + 1));
	  var normals = new _ObjectArrayView2.default(THREE.Vector3, (widthSegments + 1) * (heightSegments + 1));
	  var uvValues = new _ObjectArrayView2.default(THREE.Vector2, (widthSegments + 1) * (heightSegments + 1));

	  var segment_width = width / widthSegments;
	  var segment_height = height / heightSegments;

	  var width_half = width / 2;
	  var height_half = height / 2;

	  var iz = void 0,
	      ix = void 0;

	  var newValue = new THREE.Vector3();
	  var newNormal = new THREE.Vector3(0, 1, 0);
	  var newUV = new THREE.Vector2();

	  //populate FaceRangeOffsets
	  for (iz = 0, ix = 0; iz < faceRangeOffsets.length; iz++, ix += 4) {
	    faceRangeOffsets[iz] = ix; //0 4 8 12 16 20 ...
	  }

	  //populate faceValueIndices
	  for (iz = 0; iz < heightSegments; iz++) {
	    for (ix = 0; ix < widthSegments; ix++) {
	      faceValueIndices[(iz * widthSegments + ix) * 4] = iz * (widthSegments + 1) + ix;
	      faceValueIndices[(iz * widthSegments + ix) * 4 + 1] = iz * (widthSegments + 1) + ix + 1;
	      faceValueIndices[(iz * widthSegments + ix) * 4 + 2] = (iz + 1) * (widthSegments + 1) + ix + 1;
	      faceValueIndices[(iz * widthSegments + ix) * 4 + 3] = (iz + 1) * (widthSegments + 1) + ix;
	    }
	  }

	  //populate values, normals, and uv values
	  for (iz = 0; iz < heightSegments + 1; iz++) {

	    //calculate z coord
	    var z = iz * segment_height - height_half;

	    for (ix = 0; ix < widthSegments + 1; ix++) {
	      //calculate x coord
	      var x = ix * segment_width - width_half;

	      //set value
	      newValue.set(x, 0, -z);
	      values.setAt(iz * (widthSegments + 1) + ix, newValue);

	      //set normal
	      normals.setAt(iz * (widthSegments + 1) + ix, newNormal);

	      //set uv value
	      newUV.set(ix / widthSegments, iz / heightSegments);
	      uvValues.setAt(iz * (widthSegments + 1) + ix, newUV);
	    }
	  }

	  var positionsMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: values
	  });

	  var normalMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: normals
	  });

	  var uvMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: uvValues
	  });

	  var uvMapsByName = new _ObjectsByName2.default();
	  var name = 'default';
	  uvMapsByName.set(name, uvMap);

	  var polyMesh = new _PolyMesh2.default();
	  polyMesh.faceRangeOffsets = faceRangeOffsets;
	  polyMesh.positions = positionsMap;
	  polyMesh.normalMap = normalMap;
	  polyMesh.uvMaps = uvMapsByName;

	  return polyMesh;
	};

/***/ },
/* 270 */
/*!*****************************************!*\
  !*** ./src/operators/PolyMesh/Torus.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Torus = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Torus */ 271);

	var _Torus2 = _interopRequireDefault(_Torus);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Torus = {
	  schema: {
	    radius: { label: 'Radius', type: 'Number', defaultValue: 0.3, minValue: 0.0, step: 0.1, animatable: true },
	    tube: { label: 'Tube Radius', type: 'Number', defaultValue: 0.2, minValue: 0.0, step: 0.1, animatable: true },
	    radialSegments: { label: 'Longitudinal Segments', type: 'Integer', defaultValue: 24, minValue: 3, step: 1, animatable: true },
	    tubularSegments: { label: 'Latitudinal Segments', type: 'Integer', defaultValue: 24, minValue: 3, step: 1, animatable: true },
	    phiStart: { label: 'Phi Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    phiLength: { label: 'Phi Length', type: 'Number', defaultValue: 360, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    thetaStart: { label: 'Theta Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    thetaLength: { label: 'Theta Length', type: 'Number', defaultValue: 360, minValue: 0, maxValue: 360, step: 10, animatable: true }
	  },

	  update: function update(operator, primitive) {
	    var radius = operator.radius,
	        tube = operator.tube,
	        radialSegments = operator.radialSegments,
	        tubularSegments = operator.tubularSegments,
	        phiStart = operator.phiStart,
	        phiLength = operator.phiLength,
	        thetaStart = operator.thetaStart,
	        thetalength = operator.thetalength;

	    primitive.mesh = (0, _Torus2.default)(radius, tube, radialSegments, tubularSegments, phiStart, phiLength, thetaStart, thetalength);
	  }
	};

	exports.default = Torus;

/***/ },
/* 271 */
/*!****************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Torus.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Torus;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _Lathe = __webpack_require__(/*! ./Lathe */ 256);

	var _Lathe2 = _interopRequireDefault(_Lathe);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Torus(radius, tube, radialSegments, tubularSegments, phiStart, phiLength, thetaStart, thetaLength) {

	  radialSegments = Math.floor(radialSegments) || 1;
	  tubularSegments = Math.floor(tubularSegments) || 1;

	  radius = radius || 100;
	  tube = tube || 40;

	  radialSegments = Math.max(radialSegments || 8, 3);
	  tubularSegments = Math.max(tubularSegments || 6, 3);

	  phiStart = THREE.Math.clamp(phiStart || 0, 0, Math.PI * 2);
	  phiLength = THREE.Math.clamp(phiLength || Math.PI * 2, 0, Math.PI * 2 - phiStart);

	  thetaStart = THREE.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = THREE.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);

	  var inverseTubularSegments = 1.0 / tubularSegments;
	  var points = new _ObjectArrayView2.default(THREE.Vector3, tubularSegments + 1);
	  var norms = new _ObjectArrayView2.default(THREE.Vector3, tubularSegments + 1);
	  var pt = new THREE.Vector3();
	  var normPt = new THREE.Vector3();

	  for (var i = 0, il = tubularSegments; i <= il; i++) {

	    var theta = thetaStart + i * inverseTubularSegments * thetaLength;

	    pt.set(radius + tube * Math.cos(theta), tube * Math.sin(theta), 0);

	    normPt.set(Math.cos(theta), Math.sin(theta), 0);

	    points.setAt(i, pt);
	    norms.setAt(i, normPt.normalize());
	  }

	  return (0, _Lathe2.default)(points, norms, radialSegments, phiStart, phiLength);
	};

/***/ },
/* 272 */
/*!****************************************!*\
  !*** ./src/operators/PolyMesh/Disk.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Disk = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Disk */ 273);

	var _Disk2 = _interopRequireDefault(_Disk);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Disk = {
	  schema: {
	    radius: { type: 'Number', label: 'Radius', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    segments: { type: 'Integer', label: 'Segments', defaultValue: 12, minValue: 3, maxValue: 200, animatable: true },
	    thetaStart: { label: 'Theta Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    thetaLength: { label: 'Theta Length', type: 'Number', defaultValue: 360, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    removeDuplicate: { label: 'Remove Duplicate Vertices', type: 'Boolean', defaultValue: false, hidden: true }
	  },

	  update: function update(operator, primitive) {
	    var radius = operator.radius,
	        segments = operator.segments,
	        thetaStart = operator.thetaStart,
	        thetaLength = operator.thetaLength;

	    primitive.mesh = (0, _Disk2.default)(radius, segments, thetaStart, thetaLength);
	  }
	};

	exports.default = Disk;

/***/ },
/* 273 */
/*!***************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Disk.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Disk;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 187);

	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

	var _Lathe = __webpack_require__(/*! ./Lathe */ 256);

	var _Lathe2 = _interopRequireDefault(_Lathe);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function Disk(radius, segments, thetaStart, thetaLength) {

	  radius = radius || 50;

	  segments = Math.max(1, Math.floor(segments || 8));
	  var segmentLength = radius / segments;

	  thetaStart = THREE.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = THREE.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);

	  var points = new _ObjectArrayView2.default(THREE.Vector3, segments + 1);
	  var norms = new _ObjectArrayView2.default(THREE.Vector3, segments + 1);
	  var normPt = new THREE.Vector3(0, 1, 0);
	  var pt = new THREE.Vector3();

	  for (var i = 0, il = segments; i <= il; i++) {

	    pt.set(radius - i * segmentLength, 0, 0);

	    points.setAt(i, pt);
	    norms.setAt(i, normPt);
	  }

	  var latheSegments = segments < 3 ? 3 : segments;
	  return (0, _Lathe2.default)(points, norms, latheSegments, thetaStart, thetaLength);
	}

/***/ },
/* 274 */
/*!*********************************************!*\
  !*** ./src/operators/PolyMesh/ProxyMesh.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _bingeom = __webpack_require__(/*! ../../translators/bingeom */ 182);

	var _assets = __webpack_require__(/*! ../../modules/assets */ 168);

	var ProxyMesh = {
	  schema: {
	    binary: { type: 'Binary', label: 'Binary Geometry File' },
	    reducedBinary: { type: 'Binary', label: 'Reduced Binary Geometry File' },
	    operatorDisplay: { type: 'Number', defaultValue: 1, label: 'Operator Display Type' },
	    nbLevel: { type: 'Number', defaultValue: 1 }, // 1 -> only binary, 2 -> level0 and binary, 3 -> level0, level1, binary, ....
	    level0: { type: 'Binary', label: 'Binary Geometry File' },
	    level1: { type: 'Binary', label: 'Binary Geometry File' },
	    level2: { type: 'Binary', label: 'Binary Geometry File' },
	    level3: { type: 'Binary', label: 'Binary Geometry File' },
	    level4: { type: 'Binary', label: 'Binary Geometry File' }
	  },

	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node,
	        store = _ref.store,
	        properties = _ref.properties,
	        previousResult = _ref.previousResult,
	        loaded = _ref.loaded;

	    var visible = properties.visible;
	    var binary = operator.binary;
	    var fetch = visible || properties.prefetch && loaded;
	    var bingeom = fetch && binary && store.hasApi() && (0, _assets.getOrFetchBinary)(binary)(store);
	    var mesh = bingeom && (0, _bingeom.convertToCNSPolyMesh)(bingeom, binary);
	    //console.log('Mesh update', 'visible:', visible, 'prefetch:', properties.prefetch, 'fetch:', fetch, 'bingeom:', !!bingeom, node.name, mesh);
	    primitive.mesh = mesh;
	    primitive.previousMesh = previousResult && previousResult.mesh;
	  }
	};

	exports.default = ProxyMesh;

/***/ },
/* 275 */
/*!********************************************!*\
  !*** ./src/operators/PolyMesh/Instance.js ***!
  \********************************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Instance = {
	  schema: {
	    geometry: { label: 'Mesh', plug: 'PolyMesh', type: 'Plug' }
	  },

	  update: function update(operator, primitive) {
	    primitive.mesh = operator.geometry && operator.geometry.mesh;
	  }
	};

	exports.default = Instance;

/***/ },
/* 276 */
/*!***************************************************!*\
  !*** ./src/operators/PolyMesh/SortFacesByAxis.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sortFacesByAxis = __webpack_require__(/*! ../../polyMesh/geometric/operator/sortFacesByAxis */ 277);

	var _sortFacesByAxis2 = _interopRequireDefault(_sortFacesByAxis);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SortFacesByAxis = {
	  schema: {
	    axis: { label: 'Direction', type: 'Vec3', step: 0.1, defaultValue: { x: 1, y: 1, z: 0 }, animatable: true }
	  },

	  update: function update(operator, primitive, _ref) {
	    var store = _ref.store;

	    //using an import from player.js for getThreeCamera for some reason wipes the active camera
	    //const camera =  store.getIn(['player','threeCamera']);
	    //const cameraWorldMatrix = camera.matrix;
	    var axis = operator.axis.normalize();

	    //does not account for the local space of an object
	    //const cameraDirection = new THREE.Vector3(0,0,-1);
	    //cameraDirection.transformDirection(cameraWorldMatrix);

	    var polyMesh = primitive.mesh;
	    primitive.mesh = (0, _sortFacesByAxis2.default)(polyMesh, axis);
	  }
	};

	exports.default = SortFacesByAxis;

/***/ },
/* 277 */
/*!************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/sortFacesByAxis.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = sortFacesByAxis;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _applyFunctionToPolyMap = __webpack_require__(/*! ./applyFunctionToPolyMap */ 261);

	var _applyFunctionToPolyMap2 = _interopRequireDefault(_applyFunctionToPolyMap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function sortFacesByAxis(polyMesh, axis, withLogging) {

	  function reorderFacesOnPolymap(polyMap, polyMapName, additionalArguments) {
	    var newFaceRangeOffsets = additionalArguments.newFaceRangeOffsets;
	    var reMapping = additionalArguments.reMapping;

	    var faceRangeOffsets = polyMap.faceRangeOffsets;
	    var faceValueIndices = polyMap.faceValueIndices;
	    var newFaceValueIndices = new Uint32Array(faceValueIndices.length);
	    var newFaceValueIndicesMarker = 0;

	    for (var i = 0; i < reMapping.length; i++) {
	      for (var j = faceRangeOffsets[reMapping[i]]; j < faceRangeOffsets[reMapping[i] + 1]; j++) {
	        newFaceValueIndices[newFaceValueIndicesMarker++] = faceValueIndices[j];
	      }
	    }

	    var newPolyMap = new _PolyMap2.default({
	      faceRangeOffsets: newFaceRangeOffsets,
	      faceValueIndices: newFaceValueIndices,
	      values: polyMap.values
	    });

	    return newPolyMap;
	  };

	  var l = withLogging || false;
	  if (!axis || !polyMesh) return polyMesh;
	  if (axis.x === 0 && axis.y === 0 && axis.z === 0) return polyMesh;

	  var faceRangeOffsets = polyMesh.faceRangeOffsets;
	  var newFaceRangeOffsets = new Uint32Array(polyMesh.faceRangeOffsets.length);
	  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
	  var values = polyMesh.positions.values;

	  //create a mapping for the faces (0, 1, 2, 3, 4...)
	  var faces = [];
	  var faceDistances = [];

	  var centroid = new THREE.Vector3();
	  var tempValue = new THREE.Vector3();

	  for (var i = 0; i < faceRangeOffsets.length - 1; i++) {
	    faces[i] = i;

	    var faceStart = faceRangeOffsets[i];
	    var faceEnd = faceRangeOffsets[i + 1];

	    centroid.set(0, 0, 0);
	    for (var j = faceStart; j < faceEnd; j++) {
	      values.getAt(faceValueIndices[j], tempValue);
	      centroid.add(tempValue);
	    }

	    centroid.multiplyScalar(1 / (faceEnd - faceStart));

	    //projection of v1 and v2 on camera axis compare magnitudes
	    faceDistances[i] = centroid.dot(axis);
	  }

	  //sort the face mapping by the values of their indices
	  faces.sort(function (a, b) {
	    return faceDistances[b] - faceDistances[a];
	  });

	  for (var _i = 0; _i < faces.length; _i++) {
	    newFaceRangeOffsets[_i + 1] = newFaceRangeOffsets[_i] + (faceRangeOffsets[faces[_i] + 1] - faceRangeOffsets[faces[_i]]);
	  }

	  if (l) {
	    //print out all the faces to compare old and new
	    console.log('Face List [old][new]:');
	    for (var _i2 = 0; _i2 < faces.length; _i2++) {
	      var face = [];
	      var newFace = [];
	      for (var _j = faceRangeOffsets[_i2]; _j < faceRangeOffsets[_i2 + 1]; _j++) {
	        face.push(faceValueIndices[_j]);
	      }

	      for (var _j2 = faceRangeOffsets[faces[_i2]]; _j2 < faceRangeOffsets[faces[_i2] + 1]; _j2++) {
	        newFace.push(faceValueIndices[_j2]);
	      }

	      console.log(face, newFace);
	    }
	  }

	  var args = { newFaceRangeOffsets: newFaceRangeOffsets, reMapping: faces };
	  return (0, _applyFunctionToPolyMap2.default)(polyMesh, reorderFacesOnPolymap, args).topologyChanged();
	};

/***/ },
/* 278 */
/*!*************************************!*\
  !*** ./src/operators/Properties.js ***!
  \*************************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PolyMeshProperties = {
	  schema: {
	    // Note: right now we use double-sided rendering by default in threehub. This property is currently
	    // used only to set the appropriate value in the V2 importers for export back to V1
	    doubleSided: { label: 'Double Sided', type: 'Boolean', defaultValue: false },
	    visible: { label: 'Visible', type: 'Boolean', defaultValue: true, animatable: true },
	    prefetch: { label: 'Pre-fetch mesh', type: 'Boolean', defaultValue: false }
	  }
	};

	var MaterialProperties = {
	  schema: {
	    prefetch: { label: 'Pre-fetch Material', type: 'Boolean', defaultValue: false }
	  }
	};

	var ImageProperties = {
	  schema: {
	    prefetch: { label: 'Pre-fetch Image', type: 'Boolean', defaultValue: false }
	  }
	};

	var Default = {
	  schema: {
	    visible: { label: 'Visible', type: 'Boolean', defaultValue: true, animatable: true }
	  }
	};

	var motionTypes = ['Static', 'Kinematic', 'Dynamic'];
	var shapeValues = ['Box', 'Convex', 'Mesh'];
	var shapeLabels = ['Bounding Box', 'Convex Hull', 'Mesh (Non-Dynamic)'];

	var RigidBodyProperties = {
	  schema: {
	    collisionShape: {
	      label: 'Collision Shape',
	      type: 'Options',
	      display: 'Dropdown',
	      values: shapeValues,
	      labels: shapeLabels,
	      defaultValue: 'Convex'
	    },
	    motionType: {
	      label: 'Motion Type',
	      type: 'Options',
	      display: 'Dropdown',
	      values: motionTypes,
	      labels: motionTypes,
	      defaultValue: 'Dynamic'
	    },
	    mass: { label: 'Mass', type: 'Number', defaultValue: 1.0, minValue: 0.0, step: 1 },
	    linearDamping: { label: 'Linear Damping', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 1.0, step: 0.1 },
	    angularDamping: { label: 'Angular Damping', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 1.0, step: 0.1 },
	    //   gravity: { label: 'Local Gravity', type: 'Vec3', step: 1.0, defaultValue: [0, -9.8, 0] },
	    linearFactor: { label: 'Linear Factor', type: 'Vec3', defaultValue: [1.0, 1.0, 1.0] },
	    angularFactor: { label: 'Angular Factor', type: 'Vec3', defaultValue: [1.0, 1.0, 1.0] },
	    linearVelocity: { label: 'Linear Velocity', type: 'Vec3', defaultValue: [0.0, 0.0, 0.0] },
	    angularVelocity: { label: 'Angular Velocity', type: 'Vec3', defaultValue: [0.0, 0.0, 0.0] },
	    linearSleepingThreshold: { label: 'Linear Sleep Threshold', type: 'Number', defaultValue: 0.8, minValue: 0.0, step: 0.1 },
	    angularSleepingThreshold: { label: 'Angular Sleep Threshold', type: 'Number', defaultValue: 1.0, minValue: 0.0, step: 0.1 },
	    friction: { label: 'Friction', type: 'Number', defaultValue: 0.5, minValue: 0.0, step: 0.1 },
	    rollingFriction: { label: 'Rolling Friction', type: 'Number', defaultValue: 0.0, minValue: 0.0, step: 0.1 },
	    restitution: { label: 'Bounce', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 1.0, step: 0.1 }
	  }
	};

	exports.default = {
	  Default: Default,
	  PolyMeshProperties: PolyMeshProperties,
	  MaterialProperties: MaterialProperties,
	  ImageProperties: ImageProperties,
	  RigidBodyProperties: RigidBodyProperties
	};

/***/ },
/* 279 */
/*!***********************************!*\
  !*** ./src/operators/Renderer.js ***!
  \***********************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var WebGLRenderer = {
	  schema: {
	    format: { type: 'Options', defaultValue: 'jpeg', values: ['jpeg', 'png'], labels: ['JPEG', 'PNG'], label: 'Output Format' },
	    v2renderer: { type: 'Boolean', defaultValue: false, label: 'v2 renderer' }
	  }
	};

	exports.default = { WebGLRenderer: WebGLRenderer };

/***/ },
/* 280 */
/*!************************************!*\
  !*** ./src/operators/Transform.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _scene = __webpack_require__(/*! ../modules/scene */ 171);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var Transform = {
	  schema: {
	    translation: { label: 'Translation', type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    rotation: { label: 'Rotation', type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    scale: { label: 'Scale', type: 'Vec3', step: 0.01, defaultValue: { x: 1, y: 1, z: 1 }, animatable: true }, // Scale's step must be 0.01 as 1 percent
	    shear: { label: 'Shear', type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    rotateOrder: { label: 'Rotate Order', type: 'Options', display: 'Dropdown',
	      values: ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'], defaultValue: 'ZYX' },
	    preRotation: { label: 'Pre-Rotation', type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 } },
	    rotatePivotOffset: { label: 'Rotate Pivot Offset', type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 } },
	    scalePivotOffset: { label: 'Scale Pivot Offset', type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 } },
	    localRotatePivot: { label: 'Local Rotate Pivot', type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 } },
	    localScalePivot: { label: 'Local Scale Pivot', type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 } }
	  },

	  update: function update(operator, primitive) {
	    primitive.transform = (0, _scene.getLocalTransform)(operator);
	  }
	};

	var LookAt = {
	  schema: {
	    target: { label: 'LookAt Target', type: 'Plug', plug: 'Transform' },
	    orientation: { label: 'Orientation', type: 'Vec3', defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },

	    lookAtAxis: { label: 'Look Axis', type: 'Options', display: 'Dropdown', defaultValue: 'Z',
	      labels: ['X', 'Y', 'Z'], values: ['X', 'Y', 'Z'] },
	    flipLookAtAxis: { label: 'Flip Look Axis', type: 'Boolean', defaultValue: true },

	    upAxis: { label: 'Up Axis', type: 'Options', display: 'Dropdown', defaultValue: 'Y',
	      labels: ['X', 'Y', 'Z'], values: ['X', 'Y', 'Z'] },
	    flipUpAxis: { label: 'Flip Up Axis', type: 'Boolean', defaultValue: false }
	  }
	};

	var BoneTransform = {
	  schema: {
	    translation: { label: 'Translation', type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    rotation: { label: 'Rotation', type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    scale: { label: 'Scale', type: 'Vec3', step: 0.1, defaultValue: { x: 1, y: 1, z: 1 }, animatable: true },
	    rotateOrder: { label: 'Rotate Order', type: 'Options', display: 'Dropdown',
	      values: ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'], defaultValue: 'ZYX' },
	    preRotation: { label: 'Pre-Rotation', type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 } }, // hidden: true
	    rotateAxis: { label: 'Rotate Axis', type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 } }
	  },

	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;
	    var translation = operator.translation,
	        rotation = operator.rotation,
	        scale = operator.scale,
	        rotateOrder = operator.rotateOrder,
	        preRotation = operator.preRotation,
	        rotateAxis = operator.rotateAxis;

	    if (scale.x === 0) scale.x = 0.0000001;
	    if (scale.y === 0) scale.y = 0.0000001;
	    if (scale.z === 0) scale.z = 0.0000001;

	    var translationM = new THREE.Matrix4().makeTranslation(translation.x, translation.y, translation.z);
	    var rotationRadians = new THREE.Vector3().copy(rotation).multiplyScalar(Math.PI / 180);
	    var rotationM = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(rotationRadians.x, rotationRadians.y, rotationRadians.z, 'ZYX'));
	    var shearM = new THREE.Matrix4();
	    var scaleM = new THREE.Matrix4().makeScale(scale.x, scale.y, scale.z);

	    var preRotationRadians = new THREE.Vector3().copy(preRotation).multiplyScalar(Math.PI / 180);
	    var lPreRotationM = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(preRotationRadians.x, preRotationRadians.y, preRotationRadians.z, 'ZYX'));

	    var rotateAxisRadians = new THREE.Vector3().copy(rotateAxis).multiplyScalar(Math.PI / 180);
	    var lPostRotationM = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(rotateAxisRadians.x, rotateAxisRadians.y, rotateAxisRadians.z, 'ZYX'));

	    primitive.transform = new THREE.Matrix4().multiply(translationM).multiply(lPreRotationM).multiply(rotationM).multiply(lPostRotationM).multiply(scaleM);
	  }

	};

	exports.default = { Transform: Transform, BoneTransform: BoneTransform, LookAt: LookAt };

/***/ },
/* 281 */
/*!************************************!*\
  !*** ./src/modules/actionTypes.js ***!
  \************************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	// shared:
	//
	var LOAD_SCENE = exports.LOAD_SCENE = 'LOAD_SCENE';
	var ADD_NODE = exports.ADD_NODE = 'ADDNODE';
	var ADD_VR_CAMERA = exports.ADD_VR_CAMERA = 'ADD_VR_CAMERA';
	var SET_VR_CAMERA = exports.SET_VR_CAMERA = 'SET_VR_CAMERA';
	var DELETE_NODE = exports.DELETE_NODE = 'DELETE_NODE';
	var LOADING_FILE = exports.LOADING_FILE = 'LOADING_FILE';
	var LOADED_FILE = exports.LOADED_FILE = 'LOADED_FILE';
	var LOADING_FILE_ERROR = exports.LOADING_FILE_ERROR = 'LOADING_FILE_ERROR';
	var CLEAR_SCENE = exports.CLEAR_SCENE = 'CLEAR_SCENE';

/***/ },
/* 282 */
/*!*********************************************!*\
  !*** ./src/modules/utils/evalSceneGraph.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 97);

	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 101);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 169);

	var _stringify2 = _interopRequireDefault(_stringify);

	exports.updateReferenceList = updateReferenceList;
	exports.updateReference = updateReference;
	exports.evaluateSceneGraph = evaluateSceneGraph;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _sceneIO = __webpack_require__(/*! ../sceneIO */ 283);

	var _nonImmutable = __webpack_require__(/*! ../../operators/nonImmutable */ 173);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var doLog = false;
	function log() {
	  var _console;

	  if (doLog) (_console = console).log.apply(_console, arguments);
	}

	function updateReferenceList(_ref, nodeId, plugName, opIdx, key, refs) {
	  var from = _ref.from,
	      to = _ref.to;

	  var refKey = (0, _stringify2.default)([nodeId, plugName, opIdx, key]);
	  var existingRefs = to[refKey];
	  if (existingRefs) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = (0, _getIterator3.default)(existingRefs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var existingRefId = _step.value;

	        if (refs.indexOf(existingRefId) === -1) {
	          delete from[existingRefId][refKey];
	          if (!(0, _keys2.default)(from[existingRefId]).length) {
	            delete from[existingRefId];
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }

	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;

	  try {
	    for (var _iterator2 = (0, _getIterator3.default)(refs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var refId = _step2.value;

	      if (!from[refId]) from[refId] = {};
	      from[refId][refKey] = true;
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }

	  to[refKey] = refs;
	};

	//
	// refKey = JSON.stringify([nodeId,plugName,opIdx]);
	// from: { [fileId]:  refKey },
	// from: { [refId]:  { [refKey}: refPlug } }
	// to:  { [refKey]: fileId },
	//
	function updateReference(sceneGraph, _ref2, nodeId, plugName, opIdx, key, op, refPlug) {
	  var from = _ref2.from,
	      to = _ref2.to;

	  var refId = op[key];
	  if (refId && sceneGraph && !sceneGraph.nodes[refId]) {
	    console.warn('No reference to:', refId, 'from', nodeId, plugName, opIdx, key);
	    op[key] = refId = null;
	  }

	  var refKey = (0, _stringify2.default)([nodeId, plugName, opIdx, key]);
	  var existingRef = to[refKey];
	  if (existingRef) {
	    if (existingRef !== refId) {
	      delete from[existingRef][refKey];
	      if (refId) {
	        if (!from[refId]) from[refId] = {};
	        from[refId][refKey] = refPlug || true;
	        to[refKey] = refId;
	      } else {
	        if (!(0, _keys2.default)(from[existingRef]).length) {
	          delete from[existingRef];
	        }

	        delete to[refKey];
	      }
	    }
	  } else if (refId) {
	    if (!from[refId]) from[refId] = {};
	    from[refId][refKey] = refPlug || true;
	    to[refKey] = refId;
	  }
	};

	function evaluateSceneGraph(store, sceneId, sceneGraph) {
	  var start = new Date();
	  var i = 0;
	  var id = null;

	  var sceneNodeIds = (0, _keys2.default)(sceneGraph.nodes);
	  var evaluatedNodeIds = (0, _keys2.default)(sceneGraph.evaluatedNodes);
	  var _sceneGraph$nodeRefer = sceneGraph.nodeReferences,
	      from = _sceneGraph$nodeRefer.from,
	      to = _sceneGraph$nodeRefer.to;

	  // First evaluation after sceneGraph is loaded

	  var transitionToLoaded = !sceneGraph.loaded && (0, _sceneIO.isSceneLoaded)(store);
	  if (!sceneGraph.loaded) sceneGraph.loaded = transitionToLoaded;

	  var worldTransforms = {};
	  var toUpdate = {};
	  var toDelete = {};
	  var updating = {};
	  var nodeUpdates = {};

	  function getEvaluated(id, plug) {
	    if (updating[id] && !nodeUpdates[id]) {
	      console.error('Circular reference, updating', sceneGraph.nodes[id].name);
	      throw new Error('Circular reference: ' + id);
	    }

	    if (toUpdate[id] && !updating[id]) updateNode(id, toUpdate[id]);

	    //addReference(id, {id: nodeId, sourcePlug, destPlug}, toPlugKey(destPlug, opIndex, fromKey));
	    var result = nodeUpdates[id] || sceneGraph.evaluatedNodes[id];
	    if (plug) result = result && result[plug];
	    return result;
	  }

	  function getWorldTransform(id) {
	    if (worldTransforms[id]) return worldTransforms[id];

	    if (toUpdate[id] && !updating[id]) updateNode(id, toUpdate[id]);
	    var localTransform = getEvaluated(id, 'Transform');
	    if (!localTransform) return null;

	    var node = sceneGraph.nodes[id];
	    var parent = node && node.parent;
	    var parentTransform = parent && getWorldTransform(parent);

	    worldTransforms[id] = parentTransform ? new THREE.Matrix4().copy(parentTransform).multiply(localTransform.transform) : new THREE.Matrix4().copy(localTransform.transform);
	    return worldTransforms[id];
	  }

	  function updateNode(id, updatePlug) {
	    var node = sceneGraph.nodes[id];

	    var evalNode = sceneGraph.evaluatedNodes[id];
	    if (!evalNode) {
	      evalNode = sceneGraph.evaluatedNodes[id] = { name: node.name, _ev: 0, plugs: [] };
	      if (node.plugs.Properties) evalNode.plugs.push('Properties');
	      if (node.plugs.Transform) evalNode.plugs.push('Transform');
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var plug = _step3.value;

	          if (plug !== 'Properties' && plug !== 'Transform') evalNode.plugs.push(plug);
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	    }

	    nodeUpdates[id] = evalNode;
	    //console.log('evaluateSceneGraph::updateNode', node.name, updatePlug);
	    updating[id] = true;

	    var nodeEvaluatedVersion = 0;

	    function doUpdatePlug(plug) {
	      //console.log('  - ', plug);
	      var ops = node.plugs[plug];
	      var previousResult = evalNode[plug];
	      var previousVersion = previousResult ? previousResult._v : 0;

	      evalNode[plug] = ops.reduce(function (result, op, idx) {

	        var operator = (0, _nonImmutable.lookupOperator)(plug, op.type, []);
	        var _iteratorNormalCompletion4 = true;
	        var _didIteratorError4 = false;
	        var _iteratorError4 = undefined;

	        try {
	          for (var _iterator4 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            var key = _step4.value;

	            updateReference(null, sceneGraph.fileReferences, id, plug, idx, key, op);
	          }
	        } catch (err) {
	          _didIteratorError4 = true;
	          _iteratorError4 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	              _iterator4.return();
	            }
	          } finally {
	            if (_didIteratorError4) {
	              throw _iteratorError4;
	            }
	          }
	        }

	        var _iteratorNormalCompletion5 = true;
	        var _didIteratorError5 = false;
	        var _iteratorError5 = undefined;

	        try {
	          for (var _iterator5 = (0, _getIterator3.default)(operator.nodeReferenceKeys), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	            var _key = _step5.value;

	            updateReference(sceneGraph, sceneGraph.nodeReferences, id, plug, idx, _key, op);
	          }
	        } catch (err) {
	          _didIteratorError5 = true;
	          _iteratorError5 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion5 && _iterator5.return) {
	              _iterator5.return();
	            }
	          } finally {
	            if (_didIteratorError5) {
	              throw _iteratorError5;
	            }
	          }
	        }

	        var plugs = {};
	        var _iteratorNormalCompletion6 = true;
	        var _didIteratorError6 = false;
	        var _iteratorError6 = undefined;

	        try {
	          for (var _iterator6 = (0, _getIterator3.default)((0, _keys2.default)(operator.plugReferences)), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	            var _key2 = _step6.value;

	            updateReference(sceneGraph, sceneGraph.nodeReferences, id, plug, idx, _key2, op, operator.plugReferences[_key2]);
	            if (op[_key2]) plugs[_key2] = getEvaluated(op[_key2], operator.plugReferences[_key2]);
	          }
	        } catch (err) {
	          _didIteratorError6 = true;
	          _iteratorError6 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion6 && _iterator6.return) {
	              _iterator6.return();
	            }
	          } finally {
	            if (_didIteratorError6) {
	              throw _iteratorError6;
	            }
	          }
	        }

	        var _iteratorNormalCompletion7 = true;
	        var _didIteratorError7 = false;
	        var _iteratorError7 = undefined;

	        try {
	          for (var _iterator7 = (0, _getIterator3.default)(operator.nodeReferenceListKeys), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	            var _key3 = _step7.value;

	            updateReferenceList(sceneGraph.nodeReferences, id, plug, idx, _key3, op[_key3]);
	          }
	        } catch (err) {
	          _didIteratorError7 = true;
	          _iteratorError7 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion7 && _iterator7.return) {
	              _iterator7.return();
	            }
	          } finally {
	            if (_didIteratorError7) {
	              throw _iteratorError7;
	            }
	          }
	        }

	        if (operator.environment) {
	          updateReference(sceneGraph, sceneGraph.nodeReferences, id, plug, idx, 'environment', { environment: sceneId }, 'Environment');
	          plugs.environment = getEvaluated(sceneId, 'Environment');
	        }

	        return operator.update((0, _assign2.default)({}, op, plugs), result, {
	          sceneId: sceneId,
	          node: node,
	          store: store,
	          properties: evalNode.Properties,
	          getWorldTransform: getWorldTransform,
	          previousResult: previousResult,
	          loaded: sceneGraph.loaded
	        });
	      }, {});

	      evalNode[plug]._v = previousVersion + 1;
	    }

	    var _iteratorNormalCompletion8 = true;
	    var _didIteratorError8 = false;
	    var _iteratorError8 = undefined;

	    try {
	      for (var _iterator8 = (0, _getIterator3.default)(evalNode.plugs), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	        var _plug = _step8.value;

	        if (updatePlug === true || updatePlug === _plug) doUpdatePlug(_plug);
	        nodeEvaluatedVersion += evalNode[_plug]._v;
	      }
	    } catch (err) {
	      _didIteratorError8 = true;
	      _iteratorError8 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion8 && _iterator8.return) {
	          _iterator8.return();
	        }
	      } finally {
	        if (_didIteratorError8) {
	          throw _iteratorError8;
	        }
	      }
	    }

	    evalNode._v = node._v;
	    evalNode._ev = nodeEvaluatedVersion;

	    delete updating[id];
	    delete toUpdate[id];
	  };

	  var _iteratorNormalCompletion9 = true;
	  var _didIteratorError9 = false;
	  var _iteratorError9 = undefined;

	  try {
	    for (var _iterator9 = (0, _getIterator3.default)(sceneNodeIds), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	      var _id2 = _step9.value;

	      if (!sceneGraph.evaluatedNodes[_id2] || sceneGraph.evaluatedNodes[_id2]._v !== sceneGraph.nodes[_id2]._v) {
	        toUpdate[_id2] = true;
	      }
	    }
	  } catch (err) {
	    _didIteratorError9 = true;
	    _iteratorError9 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion9 && _iterator9.return) {
	        _iterator9.return();
	      }
	    } finally {
	      if (_didIteratorError9) {
	        throw _iteratorError9;
	      }
	    }
	  }

	  var _iteratorNormalCompletion10 = true;
	  var _didIteratorError10 = false;
	  var _iteratorError10 = undefined;

	  try {
	    for (var _iterator10 = (0, _getIterator3.default)(evaluatedNodeIds), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	      var _id3 = _step10.value;

	      if (!sceneGraph.nodes[_id3]) {
	        toDelete[_id3] = true;
	      }
	    }
	  } catch (err) {
	    _didIteratorError10 = true;
	    _iteratorError10 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion10 && _iterator10.return) {
	        _iterator10.return();
	      }
	    } finally {
	      if (_didIteratorError10) {
	        throw _iteratorError10;
	      }
	    }
	  }

	  if (transitionToLoaded) {
	    var _iteratorNormalCompletion11 = true;
	    var _didIteratorError11 = false;
	    var _iteratorError11 = undefined;

	    try {
	      for (var _iterator11 = (0, _getIterator3.default)(sceneNodeIds), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
	        var _id = _step11.value;

	        var evalNode = sceneGraph.evaluatedNodes[_id];
	        if (evalNode && evalNode.Properties && evalNode.Properties.prefetch) {
	          toUpdate[_id] = sceneGraph.nodes[_id].type;
	        }
	      }
	    } catch (err) {
	      _didIteratorError11 = true;
	      _iteratorError11 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion11 && _iterator11.return) {
	          _iterator11.return();
	        }
	      } finally {
	        if (_didIteratorError11) {
	          throw _iteratorError11;
	        }
	      }
	    }
	  }

	  function needsUpdateReference(refId, fromPlug) {
	    if (from[refId]) {
	      var _iteratorNormalCompletion12 = true;
	      var _didIteratorError12 = false;
	      var _iteratorError12 = undefined;

	      try {
	        for (var _iterator12 = (0, _getIterator3.default)((0, _keys2.default)(from[refId])), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
	          var refKey = _step12.value;

	          var refPlug = from[refId][refKey];

	          var _JSON$parse = JSON.parse(refKey),
	              _JSON$parse2 = (0, _slicedToArray3.default)(_JSON$parse, 4),
	              nodeId = _JSON$parse2[0],
	              plugName = _JSON$parse2[1],
	              opIdx = _JSON$parse2[2],
	              key = _JSON$parse2[3];
	          //console.log(' - ref ', sceneGraph.nodes[nodeId].name, '-', plugName, '-', key, 'fromPlug: ', toUpdate[nodeId]);

	          if (!fromPlug || refPlug === true || refPlug === fromPlug) {
	            if (!toUpdate[nodeId]) {
	              toUpdate[nodeId] = plugName;
	              needsUpdateReference(nodeId, plugName);
	            } else if (toUpdate[nodeId] !== plugName) {
	              toUpdate[nodeId] = true;
	              needsUpdateReference(nodeId, plugName);
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError12 = true;
	        _iteratorError12 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion12 && _iterator12.return) {
	            _iterator12.return();
	          }
	        } finally {
	          if (_didIteratorError12) {
	            throw _iteratorError12;
	          }
	        }
	      }
	    }
	  }

	  var _iteratorNormalCompletion13 = true;
	  var _didIteratorError13 = false;
	  var _iteratorError13 = undefined;

	  try {
	    for (var _iterator13 = (0, _getIterator3.default)((0, _keys2.default)(toUpdate)), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
	      var _id4 = _step13.value;

	      if (from[_id4]) needsUpdateReference(_id4);
	    }
	  } catch (err) {
	    _didIteratorError13 = true;
	    _iteratorError13 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion13 && _iterator13.return) {
	        _iterator13.return();
	      }
	    } finally {
	      if (_didIteratorError13) {
	        throw _iteratorError13;
	      }
	    }
	  }

	  var _iteratorNormalCompletion14 = true;
	  var _didIteratorError14 = false;
	  var _iteratorError14 = undefined;

	  try {
	    for (var _iterator14 = (0, _getIterator3.default)((0, _keys2.default)(toDelete)), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
	      var _id5 = _step14.value;

	      delete sceneGraph.evaluatedNodes[_id5];
	    }

	    // console.log('evalSceneGraph updating: ', Object.keys(toUpdate).length);
	  } catch (err) {
	    _didIteratorError14 = true;
	    _iteratorError14 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion14 && _iterator14.return) {
	        _iterator14.return();
	      }
	    } finally {
	      if (_didIteratorError14) {
	        throw _iteratorError14;
	      }
	    }
	  }

	  var _iteratorNormalCompletion15 = true;
	  var _didIteratorError15 = false;
	  var _iteratorError15 = undefined;

	  try {
	    for (var _iterator15 = (0, _getIterator3.default)((0, _keys2.default)(toUpdate)), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
	      var _id6 = _step15.value;

	      if (toUpdate[_id6]) updateNode(_id6, toUpdate[_id6]);
	    }

	    //if (nowLoaded) evalSceneGraph.loaded = true;

	    // Store the current files and sceneGraph used to calculate evalSceneGraph
	    //console.log('Update scene graph in: ', new Date() - start);
	  } catch (err) {
	    _didIteratorError15 = true;
	    _iteratorError15 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion15 && _iterator15.return) {
	        _iterator15.return();
	      }
	    } finally {
	      if (_didIteratorError15) {
	        throw _iteratorError15;
	      }
	    }
	  }

	  sceneGraph._ev = sceneGraph._v;
	}

/***/ },
/* 283 */
/*!********************************!*\
  !*** ./src/modules/sceneIO.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SCENE_PHASES = undefined;

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 169);

	var _stringify2 = _interopRequireDefault(_stringify);

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _createReducer;

	exports.reportError = reportError;
	exports.useScene = useScene;
	exports.getSceneId = getSceneId;
	exports.loadScene = loadScene;
	exports.errorLoadingScene = errorLoadingScene;
	exports.markRenderingScene = markRenderingScene;
	exports.markRenderedScene = markRenderedScene;
	exports.fetch = fetch;
	exports.savePublished = savePublished;
	exports.fetchAndUse = fetchAndUse;
	exports.loadingProgress = loadingProgress;
	exports.areAssetsLoaded = areAssetsLoaded;
	exports.areAssetsPreloaded = areAssetsPreloaded;
	exports.isSceneLoaded = isSceneLoaded;
	exports.isSceneRendered = isSceneRendered;
	exports.markPreloaded = markPreloaded;
	exports.preloadCommand = preloadCommand;
	exports.markLoaded = markLoaded;
	exports.markLoadingFile = markLoadingFile;
	exports.markLoadedFile = markLoadedFile;
	exports.convertFromJSON = convertFromJSON;
	exports.writeScene = writeScene;
	exports.exportJSON = exportJSON;
	exports.numErrors = numErrors;
	exports.getErrors = getErrors;
	exports.getScenePhase = getScenePhase;
	exports.clearScene = clearScene;

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 143);

	var _createReducer3 = _interopRequireDefault(_createReducer2);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 144);

	var _assets = __webpack_require__(/*! ./assets */ 168);

	var _animation = __webpack_require__(/*! ./animation */ 134);

	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 281);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Loading, reading, exporting of the scene.
	 *
	 * @module sceneIO
	 * @public
	 */

	var USE_SCENE = 'USE_SCENE';
	var LOADING_SCENEGRAPH = 'LOADING_SCENEGRAPH';
	var LOADED_SCENEGRAPH = 'LOADED_SCENEGRAPH';
	var ERROR_LOADING_SCENEGRAPH = 'ERROR_LOADING_SCENEGRAPH';
	var RENDERING_SCENE = 'RENDERING_SCENE';
	var RENDERED_SCENE = 'RENDERED_SCENE';
	var PRELOADING_SCENE = 'PRELOADING_SCENE';
	var PRELOADED_SCENE = 'PRELOADED_SCENE';
	var LOADED_SCENE = 'LOADED_SCENE';
	var SCENE_ERROR = 'SCENE_ERROR';
	var PRELOAD_COMMAND = 'PRELOAD_COMMAND';

	var SCENE_PHASES = exports.SCENE_PHASES = {
	  FAILED: -1,
	  UNKNOWN: 0,
	  LOADING_SCENEGRAPH: 1,
	  LOADED_SCENEGRAPH: 2,
	  RENDERING: 3,
	  PRELOADING: 4,
	  PRELOADED: 5,
	  LOADED: 6,
	  RENDERED: 7
	};

	var initialState = (0, _immutable.Map)({
	  id: null, // Active scene id
	  errors: (0, _immutable.List)(), // List of scene errors
	  phase: SCENE_PHASES.UNKNOWN,
	  progress: 0,
	  loadingFiles: (0, _immutable.Map)(),
	  loadedFiles: (0, _immutable.Map)(),
	  loaded: false,
	  preloadCommands: (0, _immutable.List)()
	});

	function setProgress(state, createEvent) {
	  if (state.get('phase') !== SCENE_PHASES.RENDERING) return state;

	  var loadingFiles = state.get('loadingFiles').size;
	  var loadedFiles = state.get('loadedFiles').size;
	  var totalFiles = loadingFiles + loadedFiles;
	  var progress = totalFiles === 0 ? 1 : (1 + loadedFiles / totalFiles) / 2;
	  //console.log('progress: ', loadingFiles, loadedFiles, progress);

	  if (progress < 1) {
	    createEvent('loading', progress);
	    return state.set('progress', progress);
	  }

	  createEvent('loading', 1);
	  return state.set('progress', 1);
	};

	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, USE_SCENE, function (state, id) {
	  return state.set('id', id);
	}), (0, _defineProperty3.default)(_createReducer, LOADING_SCENEGRAPH, function (state, id) {
	  var hasActiveScene = state.get('loaded') || state.get('id') && state.get('id') !== id;
	  return hasActiveScene ? state : state.set('phase', SCENE_PHASES.LOADING_SCENEGRAPH).set('progress', 1 / 4);
	}), (0, _defineProperty3.default)(_createReducer, LOADED_SCENEGRAPH, function (state, id) {
	  var hasActiveScene = state.get('loaded') || state.get('id') && state.get('id') !== id;
	  return hasActiveScene ? state : state.set('phase', SCENE_PHASES.LOADED_SCENEGRAPH).set('progress', 1 / 2);
	}), (0, _defineProperty3.default)(_createReducer, ERROR_LOADING_SCENEGRAPH, function (state, xhr, _ref) {
	  var action = _ref.action;
	  var error = action.error;

	  var msg = 'Error Loading Scene: ' + error.status + ' ' + error.statusText; //' + (error && error.response ? ': '+error.response : '');
	  return state.updateIn(['errors'], (0, _immutable.List)(), function (list) {
	    return list.push(msg);
	  });
	}), (0, _defineProperty3.default)(_createReducer, RENDERING_SCENE, function (state, payload, _ref2) {
	  var createEvent = _ref2.createEvent;

	  return setProgress(state.set('phase', SCENE_PHASES.RENDERING), createEvent);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADING_FILE, function (state, id) {
	  return state.setIn(['loadingFiles', id], true);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADED_FILE, function (state, id, _ref3) {
	  var createEvent = _ref3.createEvent;

	  return setProgress(state.deleteIn(['loadingFiles', id]).setIn(['loadedFiles', id], true), createEvent);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADING_FILE_ERROR, function (state, id, _ref4) {
	  var createEvent = _ref4.createEvent;

	  return setProgress(state.deleteIn(['loadingFiles', id]), createEvent);
	}), (0, _defineProperty3.default)(_createReducer, PRELOADING_SCENE, function (state, _, _ref5) {
	  var createEvent = _ref5.createEvent;

	  createEvent('preloading');
	  return state.set('phase', SCENE_PHASES.PRELOADING);
	}), (0, _defineProperty3.default)(_createReducer, PRELOADED_SCENE, function (state, _, _ref6) {
	  var createEvent = _ref6.createEvent;

	  createEvent('preloaded');
	  return state.set('phase', SCENE_PHASES.PRELOADED);
	}), (0, _defineProperty3.default)(_createReducer, PRELOAD_COMMAND, function (state, fn) {
	  return state.updateIn(['preloadCommands'], (0, _immutable.List)(), function (list) {
	    return list.push(fn);
	  });
	}), (0, _defineProperty3.default)(_createReducer, LOADED_SCENE, function (state, _, _ref7) {
	  var createEvent = _ref7.createEvent;

	  createEvent('loaded');
	  return state.set('loaded', true).set('phase', SCENE_PHASES.LOADED);
	}), (0, _defineProperty3.default)(_createReducer, RENDERED_SCENE, function (state, _, _ref8) {
	  var createEvent = _ref8.createEvent;

	  createEvent('rendered');
	  return state.set('phase', SCENE_PHASES.RENDERED);
	}), (0, _defineProperty3.default)(_createReducer, SCENE_ERROR, function (state, msg) {
	  return state.updateIn(['errors'], (0, _immutable.List)(), function (list) {
	    return list.push(msg);
	  });
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state) {
	  return initialState;
	}), _createReducer));

	var apiRoot = ("https://editor.vimarket.io") + '/api';

	function reportError(msg) {
	  return { type: SCENE_ERROR, payload: msg };
	}

	/**
	 * sets the active scene.
	 *
	 * @param {string} id the scene uuid
	 */
	function useScene(id) {
	  return { type: USE_SCENE, payload: id };
	}

	/**
	 * Returns the active scene Id
	 *
	 * @public
	 * @returns {uuid}
	 *
	 */
	function getSceneId(store) {
	  return store.getIn(['sceneIO', 'id']);
	};

	/**
	 * Loads the published scene
	 *
	 * @public
	 * @param {string} id the scene uuid.
	 * @param {string} transitString the published, exported scene
	 * @returns {Promise}
	 *
	 */
	function loadScene(id, transitString, loadTime) {
	  return function (store) {
	    var payload = store.read(transitString);
	    store.logPageView('/player/v2/' + id, loadTime);
	    return store.dispatch({ type: _actionTypes.LOAD_SCENE, payload: payload });
	  };
	}

	function errorLoadingScene(id) {
	  return reportError('Error Loading Scene');
	}

	function markRenderingScene() {
	  return { type: RENDERING_SCENE };
	}

	function markRenderedScene() {
	  return { type: RENDERED_SCENE };
	}

	var LOAD_SLOW_THRESHOLD = 10000;
	var LOAD_FAIL_THRESHOLD = 30000;

	/**
	 * Fetch the scene
	 *
	 * If `hash` is provided it will fetch directly from resources, otherwise it will fetch from
	 * `/api/scenes/:uuid/published`. By default, it will fetch the latest published version. If you
	 *  wish to ensure you are fetching the latest scene version, set `waitForPublish: true`.
	 *
	 *  @public
	 *  @param {uuid} sceneId
	 *  @param {String} hash - md5 hash of published content (Optional)
	 *  @param {Object} options
	 *  @param {Boolean} options.waitForPublish Wait for the latest scene version to be published (default false);
	 *
	 */
	function fetch(sceneId, hash) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  var startTime = new Date();
	  var wait = options.waitForPublish;

	  return function (store) {
	    if (store.getIn(['sceneGraph', sceneId])) return _promise2.default.resolve(true);

	    var fetch = hash ? (0, _assets.fetchText)(hash)(store) : store.callApi({
	      contentType: 'text',
	      types: [LOADING_SCENEGRAPH, LOADED_SCENEGRAPH, ERROR_LOADING_SCENEGRAPH],
	      url: apiRoot + '/scenes/' + sceneId + '/published?wait=' + (wait ? 'true' : 'false'),
	      queryKey: 'SCENE' + sceneId,
	      payload: sceneId
	    });

	    var slowLoadTimeout = setTimeout(function () {
	      if (true) {
	        store.error(new Error('Slow Load'), null, { sceneId: sceneId });
	      } else {
	        console.log('Slow Load');
	      }
	    }, LOAD_SLOW_THRESHOLD);

	    var loadFailureTimeout = setTimeout(function () {
	      if (true) {
	        store.error(new Error('Load Failure'), null, { sceneId: sceneId });
	      } else {
	        console.log('Really Slow Load');
	      }
	    }, LOAD_FAIL_THRESHOLD);

	    var promise = fetch.then(function (transit) {
	      clearTimeout(slowLoadTimeout);
	      clearTimeout(loadFailureTimeout);
	      return store.dispatch(loadScene(sceneId, transit, new Date() - startTime));
	    });

	    return promise;
	  };
	};

	function savePublished() {
	  return function (store) {
	    var transit = writeScene(store);
	    var sceneId = getSceneId(store);
	    return store.callApi({
	      contentType: 'text',
	      url: apiRoot + '/scenes/' + sceneId + '/published',
	      method: 'PUT',
	      body: (0, _stringify2.default)({ content: transit })
	    });
	  };
	}

	/**
	 * Fetch, Load and Use published scene
	 *
	 * If `hash` is provided it will fetch directly from resources, otherwise it will fetch from
	 * `/api/scenes/:uuid/published`.
	 *
	 *  @public
	 *  @param {uuid} sceneId
	 *  @param {String} hash - md5 hash of published content (Optional)
	 *  @param {Object} options
	 *  @param {Boolean} options.waitForPublish Wait for the latest scene version to be published (default false);
	 *
	 */
	function fetchAndUse(sceneId, hash) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  return function (store) {
	    return store.dispatch(fetch(sceneId, hash, options)).then(function () {
	      return store.dispatch(useScene(sceneId));
	    });
	  };
	};

	function loadingProgress(_ref9) {
	  var getIn = _ref9.getIn,
	      dispatch = _ref9.dispatch;

	  return getIn(['sceneIO', 'progress']);
	};

	/*
	 * Have preloaded commands run, and are all assets loaded
	 */
	function areAssetsLoaded(store) {
	  return store.getIn(['sceneIO', 'phase']) >= SCENE_PHASES.PRELOADED && store.getIn(['sceneIO', 'loadingFiles']).size === 0;
	}

	/*
	 * Are all assets loaded before preload commands are run
	 */
	function areAssetsPreloaded(store) {
	  return store.getIn(['sceneIO', 'phase']) >= SCENE_PHASES.RENDERING && store.getIn(['sceneIO', 'loadingFiles']).size === 0;
	}

	function isSceneLoaded(store) {
	  return store.getIn(['sceneIO', 'loaded']);
	}

	function isSceneRendered(store) {
	  return store.getIn(['sceneIO', 'phase']) >= SCENE_PHASES.RENDERED;
	}

	function markPreloaded() {
	  return function (store) {
	    var preloadCommands = store.getIn(['sceneIO', 'preloadCommands']);
	    if (!preloadCommands.size) return store.dispatch({ type: PRELOADED_SCENE });

	    store.dispatch({ type: PRELOADING_SCENE });

	    _promise2.default.all(preloadCommands.map(function (fn) {
	      return _promise2.default.resolve(fn());
	    }).toArray()).then(function () {
	      store.dispatch({ type: PRELOADED_SCENE });
	    }).catch(function (err) {
	      console.log('Caught plugin error: ', err.message);
	      console.log('Caught plugin error, stack: ', err.stack);
	      store.dispatch({ type: PRELOADED_SCENE });
	    });
	  };
	}

	function preloadCommand(fn) {
	  return { type: PRELOAD_COMMAND, payload: fn };
	}

	function markLoaded() {
	  return { type: LOADED_SCENE };
	}

	function markLoadingFile(id) {
	  return { type: _actionTypes.LOADING_FILE, payload: id };
	};

	function markLoadedFile(id) {
	  return { type: _actionTypes.LOADED_FILE, payload: id };
	};

	function convertPlugs(plugArray) {
	  var plugs = {};
	  plugArray.forEach(function (plug) {
	    plugs[plug.type] = plug.operators.map(function (op) {
	      var name = op.name;
	      var type = op.type || name;
	      return [type, (0, _ramda.omit)(['_id', 'primitive', 'name', 'type'], op), name];
	    });
	  });
	  return plugs;
	};

	var convertNode = (0, _ramda.curry)(function (store, sceneJSON, parent, json) {
	  var id = json._id;
	  var name = json.name;
	  var type = json.type;

	  var plugs = convertPlugs(json.plugs);

	  store.dispatch((0, _sceneGraph.addNode)({ id: id, name: name, type: type, plugs: plugs, parent: parent }));

	  (0, _ramda.forEach)(convertNode(store, sceneJSON, id), json.nodes);
	});

	function convertFiles(store, files) {
	  (0, _ramda.forEach)(function (file) {
	    store.dispatch((0, _assets.addFile)((0, _assign2.default)({ id: file._id }, (0, _ramda.omit)(['_id', '__v'], file))));
	  }, files);
	}

	function convertFromJSON(store, json) {
	  convertNode(store, json, null, json);
	  convertFiles(store, json.files);

	  (0, _ramda.mapObjIndexed)(function (clip, id) {
	    store.dispatch((0, _animation.addClip)(clip, id));
	  }, json.clips);
	};

	function writeScene(store) {
	  var sceneGraph = (0, _sceneGraph.getEvalSceneGraph)(store);

	  return store.write({
	    nodes: (0, _stringify2.default)(sceneGraph.nodes),
	    assets: (0, _assets.getActiveAssets)(store),
	    clips: store.getIn(['animation', 'clips'])
	  });
	}

	function exportJSON(store) {
	  return {
	    scene: store.get('sceneGraph').toJS(),
	    assets: (0, _assets.getActiveAssets)(store).toJS()
	  };
	}

	function numErrors(store) {
	  return store.getIn(['sceneIO', 'errors']).size;
	}

	function getErrors(store) {
	  return store.getIn(['sceneIO', 'errors']);
	}

	function getScenePhase(store) {
	  return store.getIn(['sceneIO', 'phase']);
	}

	/**
	 *  Clears current scene
	 *
	 *  @public
	 *  @returns {Promise}
	 */
	function clearScene() {
	  return { type: _actionTypes.CLEAR_SCENE };
	}

	var publicApi = {
	  reducer: reducer,
	  actions: { fetch: fetch, fetchAndUse: fetchAndUse, loadScene: loadScene, useScene: useScene, reportError: reportError, preloadCommand: preloadCommand, savePublished: savePublished, clearScene: clearScene },
	  selectors: { isSceneLoaded: isSceneLoaded, isSceneRendered: isSceneRendered, loadingProgress: loadingProgress, getErrors: getErrors, numErrors: numErrors, getSceneId: getSceneId, writeScene: writeScene }
	};
	exports.default = publicApi;

/***/ },
/* 284 */
/*!**********************************!*\
  !*** ./src/store/createStore.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ActionTypes = undefined;

	var _setImmediate2 = __webpack_require__(/*! babel-runtime/core-js/set-immediate */ 285);

	var _setImmediate3 = _interopRequireDefault(_setImmediate2);

	exports.default = createStore;

	var _isPlainObject = __webpack_require__(/*! ./isPlainObject */ 129);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _transitImmutable = __webpack_require__(/*! ./transitImmutable */ 288);

	var _rsvp = __webpack_require__(/*! rsvp */ 106);

	var _rsvp2 = _interopRequireDefault(_rsvp);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var raf = void 0,
	    rafContext = void 0;

	function setRequestAnimationFrame(newRequestAnimationFrame, context) {
	  if (newRequestAnimationFrame) {
	    raf = newRequestAnimationFrame;
	    rafContext = context;
	  } else {
	    raf =  true ? requestAnimationFrame : _setImmediate3.default;
	    rafContext =  true ? window : this;
	  }
	}

	setRequestAnimationFrame();

	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};

	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }

	  if (typeof enhancer === 'function') {
	    return enhancer(createStore)(reducer, initialState);
	  }

	  var transitInstance = void 0;
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var listeners = [];
	  var events = [];
	  var isDispatching = false;
	  var records = [];
	  var rollbar = false;
	  var currentTranslator = null;
	  var currentNavigator = null;
	  var apiFunction = null;

	  function createEvent(type) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    events.push({ type: type, args: args });
	  }

	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }

	  function getIn(path) {
	    return currentState.getIn(path);
	  }

	  function get(key) {
	    return currentState.get(key);
	  }

	  function getTranslator() {
	    return currentTranslator;
	  };

	  function setTranslator(translator) {
	    currentTranslator = translator;
	  };

	  function setApi(api) {
	    apiFunction = api;
	  };

	  function hasApi() {
	    return !!apiFunction;
	  };

	  function callApi() {
	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }

	    return apiFunction.apply(undefined, [this].concat(args));
	  };

	  function logPageView(path, loadTime) {
	    if (false) return;

	    var url = 'https://www.google-analytics.com/collect?v=1&tid=' + ("UA-38840155-3") + ('&cid=555&t=pageview&dh=' + encodeURI(window.location.hostname)) + ('&dt=' + encodeURI(document.title) + '&dp=' + encodeURI(path)) + (loadTime ? '&plt=' + loadTime : '');

	    store.callApi({ contentType: 'text', method: 'POST', url: url }).catch(function (e) {
	      // console.log('Ignore api errors from ga');
	    });
	  }

	  /**
	   * Adds 'Record' types required for reading/writing transit format.
	   */
	  function addRecords(newRecords) {
	    records = records.concat(newRecords);
	  };

	  function initTransit() {
	    transitInstance = (0, _transitImmutable.withRecords)(records, 'NoneNoOp');
	  };

	  function read(transitString) {
	    if (!transitInstance) initTransit();
	    return transitInstance.fromJSON(transitString);
	  };

	  function write(data) {
	    if (!transitInstance) initTransit();
	    return transitInstance.toJSON(data); //sceneGraph: Map(), files: Map()});
	  };

	  function useRollbar(rb) {
	    rollbar = rb;
	  };

	  function error(err, label) {
	    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    if (label) console.error(label);
	    if (rollbar) {
	      rollbar.error(err, data);
	      if (err.message) {
	        console.error(err.message);
	        if (err.stack) console.log(err.stack);
	      } else {
	        console.error(err);
	      }
	    } else {
	      throw err;
	    }
	  };

	  _rsvp2.default.on('error', error);

	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    listeners.push(listener);
	    var isSubscribed = true;

	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }

	      isSubscribed = false;
	      var index = listeners.indexOf(listener);
	      listeners.splice(index, 1);
	    };
	  }

	  // Custom debounce function, lodash.debounce is bigger and slower.
	  function batchNotify() {
	    var notifying = false;
	    var requestNotify = false;

	    function notify() {
	      if (notifying) {
	        requestNotify = true;
	      } else {
	        notifying = true;
	        requestNotify = false;

	        raf.call(rafContext, function () {
	          // Actual notify code
	          try {
	            var evs = events.splice(0, events.length);
	            listeners.slice().forEach(function (listener) {
	              return listener(evs);
	            });
	          } catch (e) {
	            error(e);
	          }

	          notifying = false;
	          if (requestNotify) {
	            notify();
	          }
	        });
	      }
	    }

	    return notify;
	  }

	  var notifyListenersBatched = batchNotify();

	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2.default)(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }

	    if (typeof action.type === 'undefined') {
	      console.error('Invalid action: ', action);
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }

	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }

	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action, createEvent);
	    } catch (e) {
	      error(e);
	    } finally {
	      isDispatching = false;
	    }

	    notifyListenersBatched();
	    // listeners.slice().forEach(listener => listener())

	    return _rsvp2.default.Promise.resolve(action.resolve ? action.resolve : action.payload);
	  }

	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }

	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });

	  var store = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    getIn: getIn,
	    get: get,
	    replaceReducer: replaceReducer,
	    setTranslator: setTranslator,
	    getTranslator: getTranslator,
	    addRecords: addRecords,
	    read: read,
	    write: write,
	    useRollbar: useRollbar,
	    error: error,
	    setApi: setApi,
	    hasApi: hasApi,
	    callApi: callApi,
	    createEvent: createEvent,
	    setRequestAnimationFrame: setRequestAnimationFrame,
	    logPageView: logPageView
	  };

	  return store;
	}

/***/ },
/* 285 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/set-immediate.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/set-immediate */ 286), __esModule: true };

/***/ },
/* 286 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/set-immediate.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/web.immediate */ 287);
	module.exports = __webpack_require__(/*! ../modules/_core */ 13).setImmediate;

/***/ },
/* 287 */
/*!********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/web.immediate.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 11)
	  , $task   = __webpack_require__(/*! ./_task */ 92);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 288 */
/*!***************************************!*\
  !*** ./src/store/transitImmutable.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	exports.toJSON = toJSON;
	exports.fromJSON = fromJSON;
	exports.withFilter = withFilter;
	exports.withRecords = withRecords;

	var _transitJs = __webpack_require__(/*! transit-js */ 289);

	var _transitJs2 = _interopRequireDefault(_transitJs);

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _immutable2 = _interopRequireDefault(_immutable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Modified from:
	// https://github.com/thomasboyt/transit-immutable-js/blob/records-support/index.js

	// With changes:
	//  * Records can't simply be serialized with 'toJS', since
	//    records may contain other composite types.
	//  * Serialize with array for efficiency.
	//  * Build records into an object first instead of using 'asMutable',
	//    due to weird bug with 'id' containing records.

	function createReader(recordMap, defaultRecord) {
	  return _transitJs2.default.reader('json', {
	    mapBuilder: {
	      init: function init() {
	        return {};
	      },

	      add: function add(m, k, v) {
	        m[k] = v;
	        return m;
	      },

	      finalize: function finalize(m) {
	        return m;
	      }
	    },
	    handlers: {
	      iM: function iM(v) {
	        var o = {};
	        for (var i = 0; i < v.length; i += 2) {
	          o[v[i]] = v[i + 1];
	        }

	        return new _immutable2.default.Map(o);
	      },

	      iL: function iL(v) {
	        return _immutable2.default.List(v);
	      },

	      iR: function iR(v) {
	        var Record = recordMap[v[0]];
	        if (!Record) {
	          var msg = 'Tried to deserialize Record type named `' + v[0] + '`, ' + 'but no type with that name was passed to withRecords()';
	          if (defaultRecord) {
	            if (console) console.error(msg);
	            return new recordMap[defaultRecord]();
	          } else {
	            throw new Error(msg);
	          }
	        }

	        var o = {};
	        for (var i = 1; i < v.length; i += 2) {
	          o[v[i]] = v[i + 1];
	        }

	        return new Record(o);
	      }
	    }
	  });
	}

	var reader = createReader([]);
	var writer = createWriter(false, []);

	function toJSON(data) {
	  return writer.write(data);
	}

	function fromJSON(data) {
	  return reader.read(data);
	}

	function withFilter(predicate) {
	  var filteredWriter = createWriter(predicate, []);
	  return {
	    toJSON: function toJSON(data) {
	      return filteredWriter.write(data);
	    },

	    fromJSON: fromJSON
	  };
	}

	function withRecords(records, defaultRecord, predicate) {
	  var recordMap = {};

	  records.forEach(function (RecordType) {
	    var rec = new RecordType({});

	    if (!rec._name) {
	      throw new Error('Cannot (de)serialize Record() without a name field');
	    }

	    recordMap[rec._name] = RecordType;
	  });

	  var recordWriter = createWriter(predicate, recordMap);
	  var recordReader = createReader(recordMap, defaultRecord);

	  return {
	    toJSON: function toJSON(data) {
	      return recordWriter.write(data);
	    },

	    fromJSON: function fromJSON(data) {
	      return recordReader.read(data);
	    }
	  };
	}

	function createWriter(predicate, recordMap) {
	  var handlers = _transitJs2.default.map([_immutable2.default.Map, _transitJs2.default.makeWriteHandler({
	    tag: function tag() {
	      return 'iM';
	    },

	    rep: function rep(m) {
	      var i = 0,
	          a = new Array(2 * m.size);
	      if (predicate) {
	        m = m.filter(predicate);
	      }

	      m.forEach(function (v, k) {
	        a[i++] = k;
	        a[i++] = v;
	      });

	      return a;
	    }
	  }), _immutable2.default.List, _transitJs2.default.makeWriteHandler({
	    tag: function tag() {
	      return 'iL';
	    },

	    rep: function rep(v) {
	      if (predicate) {
	        v = v.filter(predicate);
	      }

	      return v.toArray();
	    }
	  }), Function, _transitJs2.default.makeWriteHandler({
	    tag: function tag() {
	      return '_';
	    },

	    rep: function rep() {
	      return null;
	    }
	  })]);

	  (0, _keys2.default)(recordMap).forEach(function (name) {
	    handlers.set(recordMap[name], makeRecordHandler(name, recordMap[name], predicate));
	  });

	  return _transitJs2.default.writer('json', {
	    handlers: handlers
	  });
	}

	function makeRecordHandler(name, Record, predicate) {
	  var rec = new Record();
	  return _transitJs2.default.makeWriteHandler({
	    tag: function tag() {
	      return 'iR';
	    },

	    rep: function rep(m) {
	      var i = 0,
	          a = new Array(); //2 * m.size + 1);
	      a.push(name); //a[i++] = name;
	      if (predicate) {
	        m = m.filter(predicate);
	      }

	      m.forEach(function (v, k) {
	        var d = rec.get(k);
	        if (d !== v && !_immutable2.default.is(d, v)) {
	          a.push(k); //a[i++] = k;
	          a.push(v); //a[i++] = v;
	        }
	      });

	      return a;
	    }
	  });
	}

/***/ },
/* 289 */
/*!***************************************!*\
  !*** ./vendor/transit-0.8.837-min.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// transit-js 0.8.837
	// http://transit-format.org
	//
	// Copyright 2014 Cognitect. All Rights Reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//      http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS-IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License..
	;(function(){var aa=this;
	function ba(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==
	b&&"undefined"==typeof a.call)return"object";return b}function k(a,b){var c=a.split("."),d=aa;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var e;c.length&&(e=c.shift());)c.length||void 0===b?d[e]?d=d[e]:d=d[e]={}:d[e]=b};function l(a,b){this.v=a|0;this.j=b|0}var ca,da,ea,fa,ga,ia,ja={};function m(a){if(-128<=a&&128>a){var b=ja[a];if(b)return b}b=new l(a|0,0>a?-1:0);-128<=a&&128>a&&(ja[a]=b);return b}function n(a){isNaN(a)||!isFinite(a)?a=p():a<=-ka?a=q():a+1>=ka?(fa||(fa=r(-1,2147483647)),a=fa):a=0>a?t(n(-a)):new l(a%v|0,a/v|0);return a}function r(a,b){return new l(a,b)}
	function la(a,b){if(0==a.length)throw Error("number format error: empty string");var c=b||10;if(2>c||36<c)throw Error("radix out of range: "+c);if("-"==a.charAt(0))return t(la(a.substring(1),c));if(0<=a.indexOf("-"))throw Error('number format error: interior "-" character: '+a);for(var d=n(Math.pow(c,8)),e=p(),f=0;f<a.length;f+=8){var g=Math.min(8,a.length-f),h=parseInt(a.substring(f,f+g),c);8>g?(g=n(Math.pow(c,g)),e=w(e,g).add(n(h))):(e=w(e,d),e=e.add(n(h)))}return e}var v=4294967296,ka=v*v/2;
	function p(){ca||(ca=m(0));return ca}function x(){da||(da=m(1));return da}function ma(){ea||(ea=m(-1));return ea}function q(){ga||(ga=r(0,-2147483648));return ga}function na(){ia||(ia=m(16777216));return ia}function y(a){return a.j*v+(0<=a.v?a.v:v+a.v)}
	l.prototype.toString=function(a){a=a||10;if(2>a||36<a)throw Error("radix out of range: "+a);if(z(this))return"0";if(0>this.j){if(A(this,q())){var b=n(a),c=B(this,b),b=oa(w(c,b),this);return c.toString(a)+b.v.toString(a)}return"-"+t(this).toString(a)}for(var c=n(Math.pow(a,6)),b=this,d="";;){var e=B(b,c),f=oa(b,w(e,c)).v.toString(a),b=e;if(z(b))return f+d;for(;6>f.length;)f="0"+f;d=""+f+d}};function z(a){return 0==a.j&&0==a.v}function A(a,b){return a.j==b.j&&a.v==b.v}
	function C(a,b){if(A(a,b))return 0;var c=0>a.j,d=0>b.j;return c&&!d?-1:!c&&d?1:0>oa(a,b).j?-1:1}function t(a){return A(a,q())?q():r(~a.v,~a.j).add(x())}l.prototype.add=function(a){var b=this.j>>>16,c=this.j&65535,d=this.v>>>16,e=a.j>>>16,f=a.j&65535,g=a.v>>>16,h;h=0+((this.v&65535)+(a.v&65535));a=0+(h>>>16);a+=d+g;d=0+(a>>>16);d+=c+f;c=0+(d>>>16);c=c+(b+e)&65535;return r((a&65535)<<16|h&65535,c<<16|d&65535)};function oa(a,b){return a.add(t(b))}
	function w(a,b){if(z(a)||z(b))return p();if(A(a,q()))return 1==(b.v&1)?q():p();if(A(b,q()))return 1==(a.v&1)?q():p();if(0>a.j)return 0>b.j?w(t(a),t(b)):t(w(t(a),b));if(0>b.j)return t(w(a,t(b)));var c=na();if(c=0>C(a,c))c=na(),c=0>C(b,c);if(c)return n(y(a)*y(b));var c=a.j>>>16,d=a.j&65535,e=a.v>>>16,f=a.v&65535,g=b.j>>>16,h=b.j&65535,Ia=b.v>>>16,ha=b.v&65535,M,u,H,Ja;Ja=0+f*ha;H=0+(Ja>>>16);H+=e*ha;u=0+(H>>>16);H=(H&65535)+f*Ia;u+=H>>>16;H&=65535;u+=d*ha;M=0+(u>>>16);u=(u&65535)+e*Ia;M+=u>>>16;u&=
	65535;u+=f*h;M+=u>>>16;u&=65535;M=M+(c*ha+d*Ia+e*h+f*g)&65535;return r(H<<16|Ja&65535,M<<16|u)}
	function B(a,b){if(z(b))throw Error("division by zero");if(z(a))return p();if(A(a,q())){if(A(b,x())||A(b,ma()))return q();if(A(b,q()))return x();var c;c=1;if(0==c)c=a;else{var d=a.j;c=32>c?r(a.v>>>c|d<<32-c,d>>c):r(d>>c-32,0<=d?0:-1)}c=pa(B(c,b),1);if(A(c,p()))return 0>b.j?x():ma();d=oa(a,w(b,c));return c.add(B(d,b))}if(A(b,q()))return p();if(0>a.j)return 0>b.j?B(t(a),t(b)):t(B(t(a),b));if(0>b.j)return t(B(a,t(b)));for(var e=p(),d=a;0<=C(d,b);){c=Math.max(1,Math.floor(y(d)/y(b)));for(var f=Math.ceil(Math.log(c)/
	Math.LN2),f=48>=f?1:Math.pow(2,f-48),g=n(c),h=w(g,b);0>h.j||0<C(h,d);)c-=f,g=n(c),h=w(g,b);z(g)&&(g=x());e=e.add(g);d=oa(d,h)}return e}function pa(a,b){b&=63;if(0==b)return a;var c=a.v;return 32>b?r(c<<b,a.j<<b|c>>>32-b):r(0,c<<b-32)}function qa(a,b){b&=63;if(0==b)return a;var c=a.j;return 32>b?r(a.v>>>b|c<<32-b,c>>>b):32==b?r(c,0):r(c>>>b-32,0)};function ra(a,b){if(3<a.length){if(b)return!0;var c=a.charAt(1);return"~"===a.charAt(0)?":"===c||"$"===c||"#"===c:!1}return!1}function sa(a){var b=Math.floor(a/44);a=String.fromCharCode(a%44+48);return 0===b?"^"+a:"^"+String.fromCharCode(b+48)+a}function ta(){this.a=this.s=0;this.g={}}ta.prototype.write=function(a,b){if(ra(a,b)){1936===this.s&&this.clear();var c=this.g[a];return null==c?(this.g[a]=[sa(this.s),this.a],this.s++,a):c[1]!=this.a?(c[1]=this.a,c[0]=sa(this.s),this.s++,a):c[0]}return a};
	ta.prototype.clear=function(){this.s=0;this.a++};function ua(){this.s=0;this.a=[]}ua.prototype.write=function(a){1936==this.s&&(this.s=0);this.a[this.s]=a;this.s++;return a};ua.prototype.P=function(a){return this.a[2===a.length?a.charCodeAt(1)-48:44*(a.charCodeAt(1)-48)+(a.charCodeAt(2)-48)]};ua.prototype.clear=function(){this.s=0};var D="undefined"!=typeof Object.keys?function(a){return Object.keys(a)}:function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b},E="undefined"!=typeof Array.isArray?function(a){return Array.isArray(a)}:function(a){return"array"===ba(a)};function F(){return Math.round(15*Math.random()).toString(16)}
	function va(){var a=(8|3&Math.round(14*Math.random())).toString(16);return F()+F()+F()+F()+F()+F()+F()+F()+"-"+F()+F()+F()+F()+"-4"+F()+F()+F()+"-"+a+F()+F()+F()+"-"+F()+F()+F()+F()+F()+F()+F()+F()+F()+F()+F()+F()};var wa=1;function G(a,b){if(null==a)return null==b;if(a===b)return!0;if("object"===typeof a){if(E(a)){if(E(b)&&a.length===b.length){for(var c=0;c<a.length;c++)if(!G(a[c],b[c]))return!1;return!0}return!1}if(a.C)return a.C(b);if(null!=b&&"object"===typeof b){if(b.C)return b.C(a);var c=0,d=D(b).length,e;for(e in a)if(a.hasOwnProperty(e)&&(c++,!b.hasOwnProperty(e)||!G(a[e],b[e])))return!1;return c===d}}return!1}function xa(a,b){return a^b+2654435769+(a<<6)+(a>>2)}var ya={},za=0;
	function Aa(a){var b=0;if(null!=a.forEach)a.forEach(function(a,c){b=(b+(I(c)^I(a)))%4503599627370496});else for(var c=D(a),d=0;d<c.length;d++)var e=c[d],f=a[e],b=(b+(I(e)^I(f)))%4503599627370496;return b}function Ba(a){var b=0;if(E(a))for(var c=0;c<a.length;c++)b=xa(b,I(a[c]));else a.forEach&&a.forEach(function(a){b=xa(b,I(a))});return b}
	function I(a){if(null==a)return 0;switch(typeof a){case "number":return a;case "boolean":return!0===a?1:0;case "string":var b=ya[a];if(null==b){for(var c=b=0;c<a.length;++c)b=31*b+a.charCodeAt(c),b%=4294967296;za++;256<=za&&(ya={},za=1);ya[a]=b}a=b;return a;case "function":if(b=a.transit$hashCode$)return b;b=wa;"undefined"!=typeof Object.defineProperty?Object.defineProperty(a,"transit$hashCode$",{value:b,enumerable:!1}):a.transit$hashCode$=b;wa++;return b;default:return a instanceof Date?a.valueOf():
	E(a)?Ba(a):a.D?a.D():Aa(a)}};var Ca="undefined"!=typeof Symbol?Symbol.iterator:"@@iterator";function J(a,b){this.tag=a;this.rep=b;this.a=-1}J.prototype.toString=function(){return"[TaggedValue: "+this.tag+", "+this.rep+"]"};J.prototype.g=function(a){return G(this,a)};J.prototype.equiv=J.prototype.g;J.prototype.C=function(a){return a instanceof J?this.tag===a.tag&&G(this.rep,a.rep):!1};J.prototype.D=function(){-1===this.a&&(this.a=xa(I(this.tag),I(this.rep)));return this.a};function K(a,b){return new J(a,b)}
	var Da=la("9007199254740991"),Ea=la("-9007199254740991");function Fa(a){if("number"===typeof a)return a;if(a instanceof l)return a;a=la(a,10);return 0<C(a,Da)||0>C(a,Ea)?a:y(a)}l.prototype.a=function(a){return G(this,a)};l.prototype.equiv=l.prototype.a;l.prototype.C=function(a){return a instanceof l&&A(this,a)};l.prototype.D=function(){return this.v};function Ga(a){return K("n",a)}function Ha(a){return K("f",a)}function L(a){this.w=a;this.a=-1}L.prototype.toString=function(){return":"+this.w};
	L.prototype.namespace=function(){var a=this.w.indexOf("/");return-1!=a?this.w.substring(0,a):null};L.prototype.name=function(){var a=this.w.indexOf("/");return-1!=a?this.w.substring(a+1,this.w.length):this.w};L.prototype.g=function(a){return G(this,a)};L.prototype.equiv=L.prototype.g;L.prototype.C=function(a){return a instanceof L&&this.w==a.w};L.prototype.D=function(){-1===this.a&&(this.a=I(this.w));return this.a};function Ka(a){return new L(a)}function N(a){this.w=a;this.a=-1}
	N.prototype.namespace=function(){var a=this.w.indexOf("/");return-1!=a?this.w.substring(0,a):null};N.prototype.name=function(){var a=this.w.indexOf("/");return-1!=a?this.w.substring(a+1,this.w.length):this.w};N.prototype.toString=function(){return this.w};N.prototype.g=function(a){return G(this,a)};N.prototype.equiv=N.prototype.g;N.prototype.C=function(a){return a instanceof N&&this.w==a.w};N.prototype.D=function(){-1===this.a&&(this.a=I(this.w));return this.a};function La(a){return new N(a)}
	function Ma(a,b,c){var d="";c=c||b+1;for(var e=8*(7-b),f=pa(m(255),e);b<c;b++,e-=8,f=qa(f,8)){var g=qa(r(a.v&f.v,a.j&f.j),e).toString(16);1==g.length&&(g="0"+g);d+=g}return d}function O(a,b){this.g=a;this.o=b;this.a=-1}O.prototype.toString=function(){var a,b=this.g,c=this.o;a=""+(Ma(b,0,4)+"-");a+=Ma(b,4,6)+"-";a+=Ma(b,6,8)+"-";a+=Ma(c,0,2)+"-";return a+=Ma(c,2,8)};O.prototype.F=function(a){return G(this,a)};O.prototype.equiv=O.prototype.F;
	O.prototype.C=function(a){return a instanceof O&&A(this.g,a.g)&&A(this.o,a.o)};O.prototype.D=function(){-1===this.a&&(this.a=I(this.toString()));return this.a};
	function Na(a){a=a.replace(/-/g,"");for(var b=null,c=null,d=c=0,e=24,f=0,f=c=0,e=24;8>f;f+=2,e-=8)c|=parseInt(a.substring(f,f+2),16)<<e;d=0;f=8;for(e=24;16>f;f+=2,e-=8)d|=parseInt(a.substring(f,f+2),16)<<e;b=r(d,c);c=0;f=16;for(e=24;24>f;f+=2,e-=8)c|=parseInt(a.substring(f,f+2),16)<<e;d=0;for(e=f=24;32>f;f+=2,e-=8)d|=parseInt(a.substring(f,f+2),16)<<e;c=r(d,c);return new O(b,c)}function Oa(a){a="number"===typeof a?a:parseInt(a,10);return new Date(a)}
	Date.prototype.C=function(a){return a instanceof Date?this.valueOf()===a.valueOf():!1};Date.prototype.D=function(){return this.valueOf()};
	function Pa(a,b){var c;if(b&&!1===b.O||"undefined"==typeof Buffer)if("undefined"!=typeof Uint8Array){if("undefined"!=typeof atob)c=atob(a);else{c=String(a).replace(/=+$/,"");if(1==c.length%4)throw Error("'atob' failed: The string to be decoded is not correctly encoded.");for(var d=0,e,f,g=0,h="";f=c.charAt(g++);~f&&(e=d%4?64*e+f:f,d++%4)?h+=String.fromCharCode(255&e>>(-2*d&6)):0)f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(f);c=h}d=c.length;e=new Uint8Array(d);for(f=
	0;f<d;f++)e[f]=c.charCodeAt(f);c=e}else c=K("b",a);else c=new Buffer(a,"base64");return c}function Qa(a){return K("r",a)}function P(a,b){this.a=a;this.type=b||0;this.s=0}P.prototype.next=function(){if(this.s<this.a.length){var a=null;0===this.type?a=this.a[this.s]:1===this.type?a=this.a[this.s+1]:a=[this.a[this.s],this.a[this.s+1]];a={value:a,done:!1};this.s+=2;return a}return{value:null,done:!0}};P.prototype.next=P.prototype.next;P.prototype[Ca]=function(){return this};
	function Q(a,b){this.map=a;this.type=b||0;this.keys=Ra(this.map);this.s=0;this.g=null;this.a=0}Q.prototype.next=function(){if(this.s<this.map.size){null!=this.g&&this.a<this.g.length||(this.g=this.map.map[this.keys[this.s]],this.a=0);var a=null;0===this.type?a=this.g[this.a]:1===this.type?a=this.g[this.a+1]:a=[this.g[this.a],this.g[this.a+1]];a={value:a,done:!1};this.s++;this.a+=2;return a}return{value:null,done:!0}};Q.prototype.next=Q.prototype.next;Q.prototype[Ca]=function(){return this};
	function Sa(a,b){if(a instanceof R&&Ta(b)){if(a.size!==b.size)return!1;for(var c in a.map)for(var d=a.map[c],e=0;e<d.length;e+=2)if(!G(d[e+1],b.get(d[e])))return!1;return!0}if(a instanceof S&&Ta(b)){if(a.size!==b.size)return!1;c=a.l;for(e=0;e<c.length;e+=2)if(!G(c[e+1],b.get(c[e])))return!1;return!0}if(null!=b&&"object"===typeof b&&(e=D(b),c=e.length,a.size===c)){for(d=0;d<c;d++){var f=e[d];if(!a.has(f)||!G(b[f],a.get(f)))return!1}return!0}return!1}
	function Ua(a){return null==a?"null":"array"==ba(a)?"["+a.toString()+"]":"string"==typeof a?'"'+a+'"':a.toString()}function Va(a){var b=0,c="TransitMap {";a.forEach(function(d,e){c+=Ua(e)+" => "+Ua(d);b<a.size-1&&(c+=", ");b++});return c+"}"}function Wa(a){var b=0,c="TransitSet {";a.forEach(function(d){c+=Ua(d);b<a.size-1&&(c+=", ");b++});return c+"}"}function S(a){this.l=a;this.h=null;this.a=-1;this.size=a.length/2;this.g=0}S.prototype.toString=function(){return Va(this)};S.prototype.inspect=function(){return this.toString()};
	function Xa(a){if(a.h)throw Error("Invalid operation, already converted");if(8>a.size)return!1;a.g++;return 32<a.g?(a.h=T(a.l,!1,!0),a.l=[],!0):!1}S.prototype.clear=function(){this.a=-1;this.h?this.h.clear():this.l=[];this.size=0};S.prototype.clear=S.prototype.clear;S.prototype.keys=function(){return this.h?this.h.keys():new P(this.l,0)};S.prototype.keys=S.prototype.keys;S.prototype.o=function(){if(this.h)return this.h.o();for(var a=[],b=0,c=0;c<this.l.length;b++,c+=2)a[b]=this.l[c];return a};
	S.prototype.keySet=S.prototype.o;S.prototype.entries=function(){return this.h?this.h.entries():new P(this.l,2)};S.prototype.entries=S.prototype.entries;S.prototype.values=function(){return this.h?this.h.values():new P(this.l,1)};S.prototype.values=S.prototype.values;S.prototype.forEach=function(a){if(this.h)this.h.forEach(a);else for(var b=0;b<this.l.length;b+=2)a(this.l[b+1],this.l[b])};S.prototype.forEach=S.prototype.forEach;
	S.prototype.get=function(a,b){if(this.h)return this.h.get(a);if(Xa(this))return this.get(a);for(var c=0;c<this.l.length;c+=2)if(G(this.l[c],a))return this.l[c+1];return b};S.prototype.get=S.prototype.get;S.prototype.has=function(a){if(this.h)return this.h.has(a);if(Xa(this))return this.has(a);for(var b=0;b<this.l.length;b+=2)if(G(this.l[b],a))return!0;return!1};S.prototype.has=S.prototype.has;
	S.prototype.set=function(a,b){this.a=-1;if(this.h)this.h.set(a,b),this.size=this.h.size;else{for(var c=0;c<this.l.length;c+=2)if(G(this.l[c],a)){this.l[c+1]=b;return}this.l.push(a);this.l.push(b);this.size++;32<this.size&&(this.h=T(this.l,!1,!0),this.l=null)}};S.prototype.set=S.prototype.set;
	S.prototype["delete"]=function(a){this.a=-1;if(this.h)return a=this.h["delete"](a),this.size=this.h.size,a;for(var b=0;b<this.l.length;b+=2)if(G(this.l[b],a))return a=this.l[b+1],this.l.splice(b,2),this.size--,a};S.prototype.clone=function(){var a=T();this.forEach(function(b,c){a.set(c,b)});return a};S.prototype.clone=S.prototype.clone;S.prototype[Ca]=function(){return this.entries()};S.prototype.D=function(){if(this.h)return this.h.D();-1===this.a&&(this.a=Aa(this));return this.a};
	S.prototype.C=function(a){return this.h?Sa(this.h,a):Sa(this,a)};function R(a,b,c){this.map=b||{};this.a=a||[];this.size=c||0;this.g=-1}R.prototype.toString=function(){return Va(this)};R.prototype.inspect=function(){return this.toString()};R.prototype.clear=function(){this.g=-1;this.map={};this.a=[];this.size=0};R.prototype.clear=R.prototype.clear;function Ra(a){return null!=a.a?a.a:D(a.map)}
	R.prototype["delete"]=function(a){this.g=-1;this.a=null;for(var b=I(a),c=this.map[b],d=0;d<c.length;d+=2)if(G(a,c[d]))return a=c[d+1],c.splice(d,2),0===c.length&&delete this.map[b],this.size--,a};R.prototype.entries=function(){return new Q(this,2)};R.prototype.entries=R.prototype.entries;R.prototype.forEach=function(a){for(var b=Ra(this),c=0;c<b.length;c++)for(var d=this.map[b[c]],e=0;e<d.length;e+=2)a(d[e+1],d[e],this)};R.prototype.forEach=R.prototype.forEach;
	R.prototype.get=function(a,b){var c=I(a),c=this.map[c];if(null!=c)for(var d=0;d<c.length;d+=2){if(G(a,c[d]))return c[d+1]}else return b};R.prototype.get=R.prototype.get;R.prototype.has=function(a){var b=I(a),b=this.map[b];if(null!=b)for(var c=0;c<b.length;c+=2)if(G(a,b[c]))return!0;return!1};R.prototype.has=R.prototype.has;R.prototype.keys=function(){return new Q(this,0)};R.prototype.keys=R.prototype.keys;
	R.prototype.o=function(){for(var a=Ra(this),b=[],c=0;c<a.length;c++)for(var d=this.map[a[c]],e=0;e<d.length;e+=2)b.push(d[e]);return b};R.prototype.keySet=R.prototype.o;R.prototype.set=function(a,b){this.g=-1;var c=I(a),d=this.map[c];if(null==d)this.a&&this.a.push(c),this.map[c]=[a,b],this.size++;else{for(var c=!0,e=0;e<d.length;e+=2)if(G(b,d[e])){c=!1;d[e]=b;break}c&&(d.push(a),d.push(b),this.size++)}};R.prototype.set=R.prototype.set;R.prototype.values=function(){return new Q(this,1)};
	R.prototype.values=R.prototype.values;R.prototype.clone=function(){var a=T();this.forEach(function(b,c){a.set(c,b)});return a};R.prototype.clone=R.prototype.clone;R.prototype[Ca]=function(){return this.entries()};R.prototype.D=function(){-1===this.g&&(this.g=Aa(this));return this.g};R.prototype.C=function(a){return Sa(this,a)};
	function T(a,b,c){a=a||[];b=!1===b?b:!0;if((!0!==c||!c)&&64>=a.length){if(b){var d=a;a=[];for(b=0;b<d.length;b+=2){var e=!1;for(c=0;c<a.length;c+=2)if(G(a[c],d[b])){a[c+1]=d[b+1];e=!0;break}e||(a.push(d[b]),a.push(d[b+1]))}}return new S(a)}var d={},e=[],f=0;for(b=0;b<a.length;b+=2){c=I(a[b]);var g=d[c];if(null==g)e.push(c),d[c]=[a[b],a[b+1]],f++;else{var h=!0;for(c=0;c<g.length;c+=2)if(G(g[c],a[b])){g[c+1]=a[b+1];h=!1;break}h&&(g.push(a[b]),g.push(a[b+1]),f++)}}return new R(e,d,f)}
	function Ta(a){return a instanceof S||a instanceof R}function U(a){this.map=a;this.size=a.size}U.prototype.toString=function(){return Wa(this)};U.prototype.inspect=function(){return this.toString()};U.prototype.add=function(a){this.map.set(a,a);this.size=this.map.size};U.prototype.add=U.prototype.add;U.prototype.clear=function(){this.map=new R;this.size=0};U.prototype.clear=U.prototype.clear;U.prototype["delete"]=function(a){a=this.map["delete"](a);this.size=this.map.size;return a};
	U.prototype.g=function(){return this.map.entries()};U.prototype.entries=U.prototype.g;U.prototype.forEach=function(a){var b=this;this.map.forEach(function(c,d){a(d,b)})};U.prototype.forEach=U.prototype.forEach;U.prototype.has=function(a){return this.map.has(a)};U.prototype.has=U.prototype.has;U.prototype.keys=function(){return this.map.keys()};U.prototype.keys=U.prototype.keys;U.prototype.o=function(){return this.map.o()};U.prototype.keySet=U.prototype.o;U.prototype.a=function(){return this.map.values()};
	U.prototype.values=U.prototype.a;U.prototype.clone=function(){var a=Ya();this.forEach(function(b){a.add(b)});return a};U.prototype.clone=U.prototype.clone;U.prototype[Ca]=function(){return this.a()};U.prototype.C=function(a){if(a instanceof U){if(this.size===a.size)return G(this.map,a.map)}else return!1};U.prototype.D=function(){return I(this.map)};
	function Ya(a){a=a||[];for(var b={},c=[],d=0,e=0;e<a.length;e++){var f=I(a[e]),g=b[f];if(null==g)c.push(f),b[f]=[a[e],a[e]],d++;else{for(var f=!0,h=0;h<g.length;h+=2)if(G(g[h],a[e])){f=!1;break}f&&(g.push(a[e]),g.push(a[e]),d++)}}return new U(new R(c,b,d))}function Za(a){return K("'",a)}function $a(a){return K("list",a)}function ab(a){return K("link",a)};var bb=0,cb="transit$guid$"+va();function db(a){if(null==a)return"null";if(a===String)return"string";if(a===Boolean)return"boolean";if(a===Number)return"number";if(a===Array)return"array";if(a===Object)return"map";var b=a[cb];null==b&&("undefined"!=typeof Object.defineProperty?(b=++bb,Object.defineProperty(a,cb,{value:b,enumerable:!1})):a[cb]=b=++bb);return b}function V(a,b){for(var c=a.toString(),d=c.length;d<b;d++)c="0"+c;return c}function eb(){}eb.prototype.tag=function(){return"_"};
	eb.prototype.rep=function(){return null};eb.prototype.B=function(){return"null"};function fb(){}fb.prototype.tag=function(){return"s"};fb.prototype.rep=function(a){return a};fb.prototype.B=function(a){return a};function gb(){}gb.prototype.tag=function(){return"i"};gb.prototype.rep=function(a){return a};gb.prototype.B=function(a){return a.toString()};function hb(){}hb.prototype.tag=function(){return"i"};hb.prototype.rep=function(a){return a.toString()};hb.prototype.B=function(a){return a.toString()};
	function ib(){}ib.prototype.tag=function(){return"?"};ib.prototype.rep=function(a){return a};ib.prototype.B=function(a){return a.toString()};function jb(){}jb.prototype.tag=function(){return"array"};jb.prototype.rep=function(a){return a};jb.prototype.B=function(){return null};function kb(){}kb.prototype.tag=function(){return"map"};kb.prototype.rep=function(a){return a};kb.prototype.B=function(){return null};function lb(){}lb.prototype.tag=function(){return"t"};
	lb.prototype.rep=function(a){return a.getUTCFullYear()+"-"+V(a.getUTCMonth()+1,2)+"-"+V(a.getUTCDate(),2)+"T"+V(a.getUTCHours(),2)+":"+V(a.getUTCMinutes(),2)+":"+V(a.getUTCSeconds(),2)+"."+V(a.getUTCMilliseconds(),3)+"Z"};lb.prototype.B=function(a,b){return b.rep(a)};function mb(){}mb.prototype.tag=function(){return"m"};mb.prototype.rep=function(a){return a.valueOf()};mb.prototype.B=function(a){return a.valueOf().toString()};mb.prototype.R=function(){return new lb};function nb(){}
	nb.prototype.tag=function(){return"u"};nb.prototype.rep=function(a){return a.toString()};nb.prototype.B=function(a){return a.toString()};function ob(){}ob.prototype.tag=function(){return":"};ob.prototype.rep=function(a){return a.w};ob.prototype.B=function(a,b){return b.rep(a)};function pb(){}pb.prototype.tag=function(){return"$"};pb.prototype.rep=function(a){return a.w};pb.prototype.B=function(a,b){return b.rep(a)};function qb(){}qb.prototype.tag=function(a){return a.tag};qb.prototype.rep=function(a){return a.rep};
	qb.prototype.B=function(){return null};function rb(){}rb.prototype.tag=function(){return"set"};rb.prototype.rep=function(a){var b=[];a.forEach(function(a){b.push(a)});return K("array",b)};rb.prototype.B=function(){return null};function sb(){}sb.prototype.tag=function(){return"map"};sb.prototype.rep=function(a){return a};sb.prototype.B=function(){return null};function tb(){}tb.prototype.tag=function(){return"map"};tb.prototype.rep=function(a){return a};tb.prototype.B=function(){return null};
	function ub(){}ub.prototype.tag=function(){return"b"};ub.prototype.rep=function(a){return a.toString("base64")};ub.prototype.B=function(){return null};function vb(){}vb.prototype.tag=function(){return"b"};
	vb.prototype.rep=function(a){for(var b=0,c=a.length,d="",e=null;b<c;)e=a.subarray(b,Math.min(b+32768,c)),d+=String.fromCharCode.apply(null,e),b+=32768;var f;if("undefined"!=typeof btoa)f=btoa(d);else{a=String(d);c=0;d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";for(e="";a.charAt(c|0)||(d="=",c%1);e+=d.charAt(63&f>>8-c%1*8)){b=a.charCodeAt(c+=.75);if(255<b)throw Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");f=f<<8|b}f=e}return f};
	vb.prototype.B=function(){return null};function wb(){this.A={};this.set(null,new eb);this.set(String,new fb);this.set(Number,new gb);this.set(l,new hb);this.set(Boolean,new ib);this.set(Array,new jb);this.set(Object,new kb);this.set(Date,new mb);this.set(O,new nb);this.set(L,new ob);this.set(N,new pb);this.set(J,new qb);this.set(U,new rb);this.set(S,new sb);this.set(R,new tb);"undefined"!=typeof Buffer&&this.set(Buffer,new ub);"undefined"!=typeof Uint8Array&&this.set(Uint8Array,new vb)}
	wb.prototype.get=function(a){var b=null,b="string"===typeof a?this.A[a]:this.A[db(a)];return null!=b?b:this.A["default"]};wb.prototype.get=wb.prototype.get;wb.prototype.set=function(a,b){var c;if(c="string"===typeof a)a:{switch(a){case "null":case "string":case "boolean":case "number":case "array":case "map":c=!1;break a}c=!0}c?this.A[a]=b:this.A[db(a)]=b};function xb(a){this.K=a}
	function W(a){this.o=a||{};this.A={};for(var b in this.G.A)this.A[b]=this.G.A[b];for(b in this.o.handlers){a:{switch(b){case "_":case "s":case "?":case "i":case "d":case "b":case "'":case "array":case "map":a=!0;break a}a=!1}if(a)throw Error('Cannot override handler for ground type "'+b+'"');this.A[b]=this.o.handlers[b]}this.J=null!=this.o.preferStrings?this.o.preferStrings:this.G.J;this.O=null!=this.o.preferBuffers?this.o.preferBuffers:this.G.O;this.M=this.o.defaultHandler||this.G.M;this.g=this.o.mapBuilder;
	this.F=this.o.arrayBuilder}
	W.prototype.G={A:{_:function(){return null},"?":function(a){return"t"===a},b:function(a,b){return Pa(a,b)},i:function(a){return Fa(a)},n:function(a){return Ga(a)},d:function(a){return parseFloat(a)},f:function(a){return Ha(a)},c:function(a){return a},":":function(a){return Ka(a)},$:function(a){return La(a)},r:function(a){return Qa(a)},z:function(a){a:switch(a){case "-INF":a=-Infinity;break a;case "INF":a=Infinity;break a;case "NaN":a=NaN;break a;default:throw Error("Invalid special double value "+a);
	}return a},"'":function(a){return a},m:function(a){return Oa(a)},t:function(a){return new Date(a)},u:function(a){return Na(a)},set:function(a){return Ya(a)},list:function(a){return $a(a)},link:function(a){return ab(a)},cmap:function(a){return T(a,!1)}},M:function(a,b){return K(a,b)},J:!0,O:!0};
	W.prototype.a=function(a,b,c,d){if(null==a)return null;switch(typeof a){case "string":return ra(a,c)?(a=yb(this,a),b&&b.write(a,c),b=a):b="^"===a.charAt(0)&&" "!==a.charAt(1)?b.P(a,c):yb(this,a),b;case "object":if(E(a))if("^ "===a[0])if(this.g)if(17>a.length&&this.g.fromArray){d=[];for(c=1;c<a.length;c+=2)d.push(this.a(a[c],b,!0,!1)),d.push(this.a(a[c+1],b,!1,!1));b=this.g.fromArray(d,a)}else{d=this.g.init(a);for(c=1;c<a.length;c+=2)d=this.g.add(d,this.a(a[c],b,!0,!1),this.a(a[c+1],b,!1,!1),a);b=
	this.g.finalize(d,a)}else{d=[];for(c=1;c<a.length;c+=2)d.push(this.a(a[c],b,!0,!1)),d.push(this.a(a[c+1],b,!1,!1));b=T(d,!1)}else b=zb(this,a,b,c,d);else{c=D(a);var e=c[0];if((d=1==c.length?this.a(e,b,!1,!1):null)&&d instanceof xb)a=a[e],c=this.A[d.K],b=null!=c?c(this.a(a,b,!1,!0),this):K(d.K,this.a(a,b,!1,!1));else if(this.g)if(16>c.length&&this.g.fromArray){var f=[];for(d=0;d<c.length;d++)e=c[d],f.push(this.a(e,b,!0,!1)),f.push(this.a(a[e],b,!1,!1));b=this.g.fromArray(f,a)}else{f=this.g.init(a);
	for(d=0;d<c.length;d++)e=c[d],f=this.g.add(f,this.a(e,b,!0,!1),this.a(a[e],b,!1,!1),a);b=this.g.finalize(f,a)}else{f=[];for(d=0;d<c.length;d++)e=c[d],f.push(this.a(e,b,!0,!1)),f.push(this.a(a[e],b,!1,!1));b=T(f,!1)}}return b}return a};W.prototype.decode=W.prototype.a;
	function zb(a,b,c,d,e){if(e){var f=[];for(e=0;e<b.length;e++)f.push(a.a(b[e],c,d,!1));return f}f=c&&c.s;if(2===b.length&&"string"===typeof b[0]&&(e=a.a(b[0],c,!1,!1))&&e instanceof xb)return b=b[1],f=a.A[e.K],null!=f?f=f(a.a(b,c,d,!0),a):K(e.K,a.a(b,c,d,!1));c&&f!=c.s&&(c.s=f);if(a.F){if(32>=b.length&&a.F.fromArray){f=[];for(e=0;e<b.length;e++)f.push(a.a(b[e],c,d,!1));return a.F.fromArray(f,b)}f=a.F.init(b);for(e=0;e<b.length;e++)f=a.F.add(f,a.a(b[e],c,d,!1),b);return a.F.finalize(f,b)}f=[];for(e=
	0;e<b.length;e++)f.push(a.a(b[e],c,d,!1));return f}function yb(a,b){if("~"===b.charAt(0)){var c=b.charAt(1);if("~"===c||"^"===c||"`"===c)return b.substring(1);if("#"===c)return new xb(b.substring(2));var d=a.A[c];return null==d?a.M(c,b.substring(2)):d(b.substring(2),a)}return b};function Ab(a){this.a=new W(a)}function Bb(a,b){this.o=a;this.g=b||{};this.a=this.g.cache?this.g.cache:new ua}Bb.prototype.P=function(a){var b=this.a;a=this.o.a.a(JSON.parse(a),b);this.a.clear();return a};Bb.prototype.read=Bb.prototype.P;function Cb(a){this.a=a||{};this.J=null!=this.a.preferStrings?this.a.preferStrings:!0;this.S=this.a.objectBuilder||null;this.A=new wb;if(a=this.a.handlers){if(E(a)||!a.forEach)throw Error('transit writer "handlers" option must be a map');var b=this;a.forEach(function(a,d){if(void 0!==d)b.A.set(d,a);else throw Error("Cannot create handler for JavaScript undefined");})}this.H=this.a.handlerForForeign;this.L=this.a.unpack||function(a){return a instanceof S&&null===a.h?a.l:!1};this.I=this.a&&this.a.verbose||
	!1}function Db(a,b){var c=a.A.get(null==b?null:b.constructor);return null!=c?c:(c=b&&b.transitTag)?a.A.get(c):null}function X(a,b,c,d,e){a=a+b+c;return e?e.write(a,d):a}function Eb(a,b,c){var d=[];if(E(b))for(var e=0;e<b.length;e++)d.push(Y(a,b[e],!1,c));else b.forEach(function(b){d.push(Y(a,b,!1,c))});return d}function Fb(a,b){if("string"!==typeof b){var c=Db(a,b);return c&&1===c.tag(b).length}return!0}
	function Gb(a,b){var c=a.L(b),d=!0;if(c){for(var e=0;e<c.length&&(d=Fb(a,c[e]),d);e+=2);return d}if(b.keys&&(c=b.keys(),e=null,c.next)){for(e=c.next();!e.done;){d=Fb(a,e.value);if(!d)break;e=c.next()}return d}if(b.forEach)return b.forEach(function(b,c){d=d&&Fb(a,c)}),d;throw Error("Cannot walk keys of object type "+(null==b?null:b.constructor).name);}
	function Hb(a){if(a.constructor.transit$isObject)return!0;var b=a.constructor.toString(),b=b.substr(9),b=b.substr(0,b.indexOf("(")),b="Object"==b;"undefined"!=typeof Object.defineProperty?Object.defineProperty(a.constructor,"transit$isObject",{value:b,enumerable:!1}):a.constructor.transit$isObject=b;return b}
	function Ib(a,b,c){if(b.constructor===Object||null!=b.forEach||a.H&&Hb(b)){if(a.I){if(null!=b.forEach){if(Gb(a,b)){var d={};b.forEach(function(b,e){d[Y(a,e,!0,!1)]=Y(a,b,!1,c)});return d}var e=a.L(b),f=[],g=X("~#","cmap","",!0,c);if(e)for(var h=0;h<e.length;h+=2)f.push(Y(a,e[h],!0,!1)),f.push(Y(a,e[h+1],!1,c));else b.forEach(function(b,d){f.push(Y(a,d,!0,!1));f.push(Y(a,b,!1,c))});d={};d[g]=f;return d}d={};e=D(b);for(h=0;h<e.length;h++)d[Y(a,e[h],!0,!1)]=Y(a,b[e[h]],!1,c);return d}if(null!=b.forEach){if(Gb(a,
	b)){e=a.L(b);d=["^ "];if(e)for(h=0;h<e.length;h+=2)d.push(Y(a,e[h],!0,c)),d.push(Y(a,e[h+1],!1,c));else b.forEach(function(b,e){d.push(Y(a,e,!0,c));d.push(Y(a,b,!1,c))});return d}e=a.L(b);f=[];g=X("~#","cmap","",!0,c);if(e)for(h=0;h<e.length;h+=2)f.push(Y(a,e[h],!0,c)),f.push(Y(a,e[h+1],!1,c));else b.forEach(function(b,d){f.push(Y(a,d,!0,c));f.push(Y(a,b,!1,c))});return[g,f]}d=["^ "];e=D(b);for(h=0;h<e.length;h++)d.push(Y(a,e[h],!0,c)),d.push(Y(a,b[e[h]],!1,c));return d}if(null!=a.S)return a.S(b,
	function(b){return Y(a,b,!0,c)},function(b){return Y(a,b,!1,c)});h=(null==b?null:b.constructor).name;e=Error("Cannot write "+h);e.data={N:b,type:h};throw e;}
	function Y(a,b,c,d){var e=Db(a,b)||(a.H?a.H(b,a.A):null),f=e?e.tag(b):null,g=e?e.rep(b):null;if(null!=e&&null!=f)switch(f){case "_":return c?X("~","_","",c,d):null;case "s":return 0<g.length?(a=g.charAt(0),a="~"===a||"^"===a||"`"===a?"~"+g:g):a=g,X("","",a,c,d);case "?":return c?X("~","?",g.toString()[0],c,d):g;case "i":return Infinity===g?X("~","z","INF",c,d):-Infinity===g?X("~","z","-INF",c,d):isNaN(g)?X("~","z","NaN",c,d):c||"string"===typeof g||g instanceof l?X("~","i",g.toString(),c,d):g;case "d":return c?
	X(g.T,"d",g,c,d):g;case "b":return X("~","b",g,c,d);case "'":return a.I?(b={},c=X("~#","'","",!0,d),b[c]=Y(a,g,!1,d),d=b):d=[X("~#","'","",!0,d),Y(a,g,!1,d)],d;case "array":return Eb(a,g,d);case "map":return Ib(a,g,d);default:a:{if(1===f.length){if("string"===typeof g){d=X("~",f,g,c,d);break a}if(c||a.J){(a=a.I&&e.R())?(f=a.tag(b),g=a.B(b,a)):g=e.B(b,e);if(null!==g){d=X("~",f,g,c,d);break a}d=Error('Tag "'+f+'" cannot be encoded as string');d.data={tag:f,rep:g,N:b};throw d;}}b=f;c=g;a.I?(g={},g[X("~#",
	b,"",!0,d)]=Y(a,c,!1,d),d=g):d=[X("~#",b,"",!0,d),Y(a,c,!1,d)]}return d}else throw d=(null==b?null:b.constructor).name,a=Error("Cannot write "+d),a.data={N:b,type:d},a;}function Jb(a,b){var c=Db(a,b)||(a.H?a.H(b,a.A):null);if(null!=c)return 1===c.tag(b).length?Za(b):b;var c=(null==b?null:b.constructor).name,d=Error("Cannot write "+c);d.data={N:b,type:c};throw d;}function Z(a,b){this.a=a;this.o=b||{};!1===this.o.cache?this.g=null:this.g=this.o.cache?this.o.cache:new ta}Z.prototype.G=function(){return this.a};
	Z.prototype.marshaller=Z.prototype.G;Z.prototype.write=function(a,b){var c=null,d=b||{},c=d.asMapKey||!1,e=this.a.I?!1:this.g;!1===d.marshalTop?c=Y(this.a,a,c,e):(d=this.a,c=JSON.stringify(Y(d,Jb(d,a),c,e)));null!=this.g&&this.g.clear();return c};Z.prototype.write=Z.prototype.write;Z.prototype.F=function(a,b){this.a.A.set(a,b)};Z.prototype.register=Z.prototype.F;var Kb=T;k("transit.reader",function(a,b){if("json"===a||"json-verbose"===a||null==a){var c=new Ab(b);return new Bb(c,b)}throw Error("Cannot create reader of type "+a);});k("transit.writer",function(a,b){if("json"===a||"json-verbose"===a||null==a){"json-verbose"===a&&(null==b&&(b={}),b.verbose=!0);var c=new Cb(b);return new Z(c,b)}c=Error('Type must be "json"');c.data={type:a};throw c;});
	k("transit.makeBuilder",function(a){function b(){}b.prototype.init=a.init;b.prototype.add=a.add;b.prototype.finalize=a.finalize;b.prototype.fromArray=a.fromArray;return new b});k("transit.makeWriteHandler",function(a){function b(){}b.prototype.tag=a.tag;b.prototype.rep=a.rep;b.prototype.B=a.stringRep;b.prototype.R=a.getVerboseHandler;return new b});k("transit.date",Oa);k("transit.integer",Fa);
	k("transit.isInteger",function(a){return a instanceof l?!0:"number"===typeof a&&!isNaN(a)&&Infinity!==a&&parseFloat(a)===parseInt(a,10)});k("transit.uuid",function(a){return Na(a)});k("transit.isUUID",function(a){return a instanceof O});k("transit.bigInt",Ga);k("transit.isBigInt",function(a){return a instanceof J&&"n"===a.tag});k("transit.bigDec",Ha);k("transit.isBigDec",function(a){return a instanceof J&&"f"===a.tag});k("transit.keyword",Ka);k("transit.isKeyword",function(a){return a instanceof L});
	k("transit.symbol",La);k("transit.isSymbol",function(a){return a instanceof N});k("transit.binary",Pa);k("transit.isBinary",function(a){return"undefined"!=typeof Buffer&&a instanceof Buffer?!0:"undefined"!=typeof Uint8Array&&a instanceof Uint8Array?!0:a instanceof J&&"b"===a.tag});k("transit.uri",Qa);k("transit.isURI",function(a){return a instanceof J&&"r"===a.tag});k("transit.map",T);k("transit.isMap",Ta);k("transit.set",Ya);k("transit.isSet",function(a){return a instanceof U});
	k("transit.list",$a);k("transit.isList",function(a){return a instanceof J&&"list"===a.tag});k("transit.quoted",Za);k("transit.isQuoted",function(a){return a instanceof J&&"'"===a.tag});k("transit.tagged",K);k("transit.isTaggedValue",function(a){return a instanceof J});k("transit.link",ab);k("transit.isLink",function(a){return a instanceof J&&"link"===a.tag});k("transit.hash",I);k("transit.hashMapLike",Aa);k("transit.hashArrayLike",Ba);k("transit.equals",G);
	k("transit.extendToEQ",function(a,b){a.D=b.hashCode;a.C=b.equals;return a});k("transit.mapToObject",function(a){var b={};a.forEach(function(a,d){if("string"!==typeof d)throw Error("Cannot convert map with non-string keys");b[d]=a});return b});k("transit.objectToMap",function(a){var b=Kb(),c;for(c in a)a.hasOwnProperty(c)&&b.set(c,a[c]);return b});k("transit.decoder",function(a){return new W(a)});k("transit.UUIDfromString",Na);k("transit.randomUUID",va);k("transit.stringableKeys",Gb);
	k("transit.readCache",function(){return new ua});k("transit.writeCache",function(){return new ta});})();
	module.exports = transit;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 146).Buffer))

/***/ },
/* 290 */
/*!*********************************************!*\
  !*** ./src/modules/utils/tweenFunctions.js ***!
  \*********************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	// From: https://github.com/chenglou/tween-functions/blob/master/index.js
	// t: current time, b: beginning value, _c: final value, d: total duration
	var tweenFunctions = {
	  linear: function linear(t, b, _c, d) {
	    var c = _c - b;
	    return c * t / d + b;
	  },

	  easeInQuad: function easeInQuad(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t + b;
	  },

	  easeOutQuad: function easeOutQuad(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (t /= d) * (t - 2) + b;
	  },

	  easeInOutQuad: function easeInOutQuad(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t + b;
	    } else {
	      return -c / 2 * (--t * (t - 2) - 1) + b;
	    }
	  },

	  easeInCubic: function easeInCubic(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t + b;
	  },

	  easeOutCubic: function easeOutCubic(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t + 1) + b;
	  },

	  easeInOutCubic: function easeInOutCubic(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t + 2) + b;
	    }
	  },

	  easeInQuart: function easeInQuart(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t + b;
	  },

	  easeOutQuart: function easeOutQuart(t, b, _c, d) {
	    var c = _c - b;
	    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	  },

	  easeInOutQuart: function easeInOutQuart(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t + b;
	    } else {
	      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	    }
	  },

	  easeInQuint: function easeInQuint(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t * t + b;
	  },

	  easeOutQuint: function easeOutQuint(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	  },

	  easeInOutQuint: function easeInOutQuint(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	    }
	  },

	  easeInSine: function easeInSine(t, b, _c, d) {
	    var c = _c - b;
	    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	  },

	  easeOutSine: function easeOutSine(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sin(t / d * (Math.PI / 2)) + b;
	  },

	  easeInOutSine: function easeInOutSine(t, b, _c, d) {
	    var c = _c - b;
	    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	  },

	  easeInExpo: function easeInExpo(t, b, _c, d) {
	    var c = _c - b;
	    var _ref;
	    return (_ref = t === 0) !== null ? _ref : {
	      b: c * Math.pow(2, 10 * (t / d - 1)) + b
	    };
	  },

	  easeOutExpo: function easeOutExpo(t, b, _c, d) {
	    var c = _c - b;
	    var _ref;
	    return (_ref = t === d) !== null ? _ref : b + {
	      c: c * (-Math.pow(2, -10 * t / d) + 1) + b
	    };
	  },

	  easeInOutExpo: function easeInOutExpo(t, b, _c, d) {
	    var c = _c - b;
	    if (t === 0) {
	      b;
	    }

	    if (t === d) {
	      b + c;
	    }

	    if ((t /= d / 2) < 1) {
	      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
	    } else {
	      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	    }
	  },

	  easeInCirc: function easeInCirc(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	  },

	  easeOutCirc: function easeOutCirc(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
	  },

	  easeInOutCirc: function easeInOutCirc(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
	    } else {
	      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	    }
	  },

	  easeInElastic: function easeInElastic(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      b;
	    } else if ((t /= d) === 1) {
	      b + c;
	    }

	    if (!p) {
	      p = d * 0.3;
	    }

	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }

	    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	  },

	  easeOutElastic: function easeOutElastic(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      b;
	    } else if ((t /= d) === 1) {
	      b + c;
	    }

	    if (!p) {
	      p = d * 0.3;
	    }

	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }

	    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
	  },

	  easeInOutElastic: function easeInOutElastic(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      b;
	    } else if ((t /= d / 2) === 2) {
	      b + c;
	    }

	    if (!p) {
	      p = d * (0.3 * 1.5);
	    }

	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }

	    if (t < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	    } else {
	      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
	    }
	  },

	  easeInBack: function easeInBack(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }

	    return c * (t /= d) * t * ((s + 1) * t - s) + b;
	  },

	  easeOutBack: function easeOutBack(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }

	    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	  },

	  easeInOutBack: function easeInOutBack(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }

	    if ((t /= d / 2) < 1) {
	      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
	    }
	  },

	  easeInBounce: function easeInBounce(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    v = tweenFunctions.easeOutBounce(d - t, 0, c, d);
	    return c - v + b;
	  },

	  easeOutBounce: function easeOutBounce(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d) < 1 / 2.75) {
	      return c * (7.5625 * t * t) + b;
	    } else if (t < 2 / 2.75) {
	      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
	    } else if (t < 2.5 / 2.75) {
	      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
	    } else {
	      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
	    }
	  },

	  easeInOutBounce: function easeInOutBounce(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    if (t < d / 2) {
	      v = tweenFunctions.easeInBounce(t * 2, 0, c, d);
	      return v * 0.5 + b;
	    } else {
	      v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);
	      return v * 0.5 + c * 0.5 + b;
	    }
	  }
	};

	exports.default = tweenFunctions;

/***/ },
/* 291 */
/*!**************************************!*\
  !*** ./src/modules/utils/physics.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	exports.initPhysics = initPhysics;
	exports.updatePhysics = updatePhysics;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _scene = __webpack_require__(/*! ../scene */ 171);

	var _physicsConstants = __webpack_require__(/*! ./physicsConstants */ 292);

	var _physicsConstants2 = _interopRequireDefault(_physicsConstants);

	var _triangulateMesh = __webpack_require__(/*! ../../polyMesh/geometric/operator/triangulateMesh */ 293);

	var _triangulateMesh2 = _interopRequireDefault(_triangulateMesh);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// re-usable threeJS matrix decompose targets
	var translation = new THREE.Vector3();
	var rotation = new THREE.Quaternion();
	var scale = new THREE.Vector3();

	function initWorld(store) {
	  var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
	  var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
	  var overlappingPairCache = new Ammo.btDbvtBroadphase();
	  var solver = new Ammo.btSequentialImpulseConstraintSolver();
	  var dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);

	  var gravity = (0, _scene.get)(store, { plug: 'Player', property: 'gravity' });
	  if (!gravity) gravity = new THREE.Vector3(0, -9.8, 0);
	  dynamicsWorld.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z));
	  return dynamicsWorld;
	}

	function createConvexHullFromPolyMesh(polyMesh) {
	  var shape = new Ammo.btConvexHullShape();
	  var verts = polyMesh.positions.values;

	  var tmpVec3 = new THREE.Vector3();
	  for (var i = 0; i < verts.length; i++) {
	    verts.getAt(i, tmpVec3);
	    var pt = new Ammo.btVector3(tmpVec3.x, tmpVec3.y, tmpVec3.z);
	    shape.addPoint(pt);
	  }
	  return shape;
	}

	function createCollisionMeshFromPolyMesh(polyMesh, store, id) {
	  // try to get already-triangulated mesh from ThreeJS, otherwise create new triangulation to use
	  var threeMesh = store.getTranslator().getThreeObject(id);
	  var triMesh = null;
	  if (threeMesh && threeMesh.userData && threeMesh.userData.triangulation) {
	    triMesh = threeMesh.userData.triangulation.mesh;
	  }
	  if (!triMesh) {
	    triMesh = (0, _triangulateMesh2.default)(polyMesh);
	  }

	  var verts = triMesh.positions.values;
	  var indices = triMesh.positions.faceValueIndices;

	  var mesh = new Ammo.btTriangleMesh(true, true);

	  var tmpVec3a = new THREE.Vector3();
	  var tmpVec3b = new THREE.Vector3();
	  var tmpVec3c = new THREE.Vector3();
	  for (var i = 0; i < indices.length; i += 3) {
	    verts.getAt(i, tmpVec3a);
	    verts.getAt(i + 1, tmpVec3b);
	    verts.getAt(i + 2, tmpVec3c);
	    var ptA = new Ammo.btVector3(tmpVec3a.x, tmpVec3a.y, tmpVec3a.z);
	    var ptB = new Ammo.btVector3(tmpVec3b.x, tmpVec3b.y, tmpVec3b.z);
	    var ptC = new Ammo.btVector3(tmpVec3c.x, tmpVec3c.y, tmpVec3c.z);

	    mesh.addTriangle(ptA, ptB, ptC, false);
	  }

	  var shape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
	  return shape;
	}

	function createBoundingBoxShapeFromNode(nodeID, bbox) {
	  var halfExtents = new Ammo.btVector3((bbox.max.x - bbox.min.x) / 2, (bbox.max.y - bbox.min.y) / 2, (bbox.max.z - bbox.min.z) / 2);
	  return new Ammo.btBoxShape(halfExtents);
	}

	/*
	 * Creates the Dynamics World, and initializes the Kinematic and Dynamic Bodies
	 */
	function initPhysics(store) {
	  var kinematicBodies = {};
	  var dynamicBodies = {};

	  function createBodyWithProps(props, id) {
	    var isKinematic = false;
	    var isStatic = false;
	    if (props.motionType === 'Kinematic') isKinematic = true;
	    if (props.motionType === 'Static') isStatic = true;

	    var colShape = null;
	    var shapeLocalTransform = null;

	    var worldTransformV2 = (0, _scene.getWorldTransform)(store, id);
	    worldTransformV2.decompose(translation, rotation, scale);

	    var shapeType = props.collisionShape;

	    if (shapeType === 'Mesh') {
	      var polyMesh = (0, _scene.get)(store, { id: id, evalPlug: 'PolyMesh', property: 'mesh' });
	      if (polyMesh) {
	        colShape = createCollisionMeshFromPolyMesh(polyMesh, store, id);
	        colShape.setLocalScaling(new Ammo.btVector3(scale.x, scale.y, scale.z));
	      }
	    } else if (shapeType === 'Box') {
	      var bbox = api.scene.getNodeBoundingBox(id);
	      colShape = createBoundingBoxShapeFromNode(id, bbox);
	      var bbCenter = new THREE.Vector3((bbox.max.x + bbox.min.x) / 2, (bbox.max.y + bbox.min.y) / 2, (bbox.max.z + bbox.min.z) / 2);
	      shapeLocalTransform = new THREE.Matrix4().getInverse(worldTransformV2, true);
	      shapeLocalTransform.multiply(new THREE.Matrix4().makeTranslation(bbCenter.x, bbCenter.y, bbCenter.z));
	      // bounding box already uses scaling?
	    } else {
	      // 'Convex'
	      var _polyMesh = (0, _scene.get)(store, { id: id, evalPlug: 'PolyMesh', property: 'mesh' });
	      if (_polyMesh) {
	        colShape = createConvexHullFromPolyMesh(_polyMesh);
	        // convex hull is created from base geometry, so still need to scale appropriately
	        colShape.setLocalScaling(new Ammo.btVector3(scale.x, scale.y, scale.z));
	        // colShape.setMargin(0.01);
	      }
	    }

	    if (!colShape) {
	      var nodeName = (0, _scene.get)(store, { id: id, property: 'name' });
	      console.warn('Could not create collision shape for \'' + nodeName + '\', defaulting to a unit sphere');
	      colShape = new Ammo.btSphereShape(1);
	    }

	    // some shapes need custom offset compensation relative to the node's transform to be positioned/oriented correctly
	    if (shapeLocalTransform) {
	      worldTransformV2.multiply(shapeLocalTransform);
	    }

	    worldTransformV2.decompose(translation, rotation, scale);

	    var startTransform = new Ammo.btTransform();
	    startTransform.setIdentity();
	    startTransform.setOrigin(new Ammo.btVector3(translation.x, translation.y, translation.z));
	    startTransform.setRotation(new Ammo.btQuaternion(rotation.x, rotation.y, rotation.z, rotation.w));

	    var mass = isKinematic || isStatic ? 0 : props.mass;
	    var isDynamic = mass !== 0;
	    var localInertia = new Ammo.btVector3(0, 0, 0);
	    if (isDynamic) {
	      colShape.calculateLocalInertia(mass, localInertia);
	    }

	    var myMotionState = new Ammo.btDefaultMotionState(startTransform);
	    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);
	    rbInfo.m_linearDamping = props.linearDamping;
	    rbInfo.m_angularDamping = props.angularDamping;
	    rbInfo.m_friction = props.friction;
	    rbInfo.m_rollingFriction = props.rollingFriction;
	    rbInfo.m_linearSleepingThreshold = props.linearSleepingThreshold;
	    rbInfo.m_angularSleepingThreshold = props.angularSleepingThreshold;
	    rbInfo.m_restitution = props.restitution;
	    var body = new Ammo.btRigidBody(rbInfo);

	    if (isKinematic) {
	      body.setCollisionFlags(body.getCollisionFlags() | _physicsConstants2.default.BODYFLAG_KINEMATIC_OBJECT);
	      body.setActivationState(_physicsConstants2.default.BODYSTATE_DISABLE_DEACTIVATION);
	    }

	    dynamicsWorld.addRigidBody(body);
	    if (isKinematic) kinematicBodies[id] = { body: body, shapeLocalTransform: shapeLocalTransform };else if (!isStatic) dynamicBodies[id] = { body: body, shapeLocalTransform: shapeLocalTransform };
	    // don't need to do process any updates with static bodies after they are added to the world
	  }

	  var dynamicsWorld = initWorld(store);

	  var physicsNodes = (0, _scene.getAll)(store, { plug: 'Properties', properties: { name: 'RigidBodyProperties' } });

	  (0, _ramda.mapObjIndexed)(createBodyWithProps, physicsNodes);

	  return { dynamicsWorld: dynamicsWorld, kinematicBodies: kinematicBodies, dynamicBodies: dynamicBodies };
	}

	// Where do we want to perform this cleanup in the context of the V2 player?
	function cleanupPhysics() {
	  // Delete objects we created through |new|. We just do a few of them here, but you should do them all if you are not shutting down ammo.js
	  // we'll free the objects in reversed order as they were created via 'new' to avoid the 'dead' object links
	  // Ammo.destroy(dynamicsWorld);
	  // Ammo.destroy(solver);
	  // Ammo.destroy(overlappingPairCache);
	  // Ammo.destroy(dispatcher);
	  // Ammo.destroy(collisionConfiguration);
	}

	var internalSimulationInterval = 1 / 60;
	var maxSubsteps = 4;

	function updatePhysics(store, delta, globalTime, dynamicsWorld, dynamicBodies, kinematicBodies) {
	  // run simulation step
	  // see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World for param details
	  // (actual deltaT in seconds, max # substeps, fixed minimum internal timestep)
	  dynamicsWorld.stepSimulation(delta / 1000, maxSubsteps, internalSimulationInterval);

	  var trans = new Ammo.btTransform();
	  var rotationPhysics = new Ammo.btQuaternion();
	  var translationPhysics = new Ammo.btVector3();
	  var threeQuat = new THREE.Quaternion();
	  var euler = new THREE.Euler();

	  // process kinematic bodies
	  (0, _keys2.default)(kinematicBodies).forEach(function (id) {
	    var body = kinematicBodies[id].body;
	    var worldTransformV2 = (0, _scene.getWorldTransform)(store, id);

	    if (kinematicBodies[id].shapeLocalTransform) {
	      worldTransformV2.premultiply(kinematicBodies[id].shapeLocalTransform);
	    }

	    worldTransformV2.decompose(translation, rotation, scale);

	    var motionState = body.getMotionState();
	    var worldTransformPhysics = body.getWorldTransform();

	    translationPhysics.setX(translation.x);
	    translationPhysics.setY(translation.y);
	    translationPhysics.setZ(translation.z);

	    rotationPhysics.setX(rotation.x);
	    rotationPhysics.setY(rotation.y);
	    rotationPhysics.setZ(rotation.z);
	    rotationPhysics.setW(rotation.w);

	    worldTransformPhysics.setOrigin(translationPhysics);
	    worldTransformPhysics.setRotation(rotationPhysics);
	    motionState.setWorldTransform(worldTransformPhysics);
	  });

	  // process dynamic bodies
	  (0, _keys2.default)(dynamicBodies).forEach(function (id) {
	    var body = dynamicBodies[id].body;
	    body.getMotionState().getWorldTransform(trans);
	    store.dispatch((0, _scene.set)({ id: id, plug: 'Transform', property: 'translation' }, [trans.getOrigin().x(), trans.getOrigin().y(), trans.getOrigin().z()]));

	    rotationPhysics = trans.getRotation();
	    rotation.set(rotationPhysics.x(), rotationPhysics.y(), rotationPhysics.z(), rotationPhysics.w());
	    euler.setFromQuaternion(rotation, 'ZYX');

	    store.dispatch((0, _scene.set)({ id: id, plug: 'Transform', property: 'rotation' }, [THREE.Math.RAD2DEG * euler.x, THREE.Math.RAD2DEG * euler.y, THREE.Math.RAD2DEG * euler.z]));
	  });
	}

/***/ },
/* 292 */
/*!***********************************************!*\
  !*** ./src/modules/utils/physicsConstants.js ***!
  \***********************************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	// Adapted from:
	// https://github.com/playcanvas/engine/blob/18bdc36d108031beca3fbfab948feb911eea2159/src/framework/components/rigid-body/constants.js

	// Copyright (c) 2011-2017 PlayCanvas Ltd.

	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:

	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.

	var CONSTANTS = {
	  // types
	  BODYTYPE_STATIC: 'Static',
	  BODYTYPE_DYNAMIC: 'Dynamic',
	  BODYTYPE_KINEMATIC: 'Kinematic',

	  // Collision flags
	  BODYFLAG_STATIC_OBJECT: 1,
	  BODYFLAG_KINEMATIC_OBJECT: 2,
	  BODYFLAG_NORESPONSE_OBJECT: 4,

	  // Activation states
	  BODYSTATE_ACTIVE_TAG: 1,
	  BODYSTATE_ISLAND_SLEEPING: 2,
	  BODYSTATE_WANTS_DEACTIVATION: 3,
	  BODYSTATE_DISABLE_DEACTIVATION: 4,
	  BODYSTATE_DISABLE_SIMULATION: 5,

	  // groups
	  BODYGROUP_NONE: 0,
	  BODYGROUP_DEFAULT: 1,
	  BODYGROUP_DYNAMIC: 1,
	  BODYGROUP_STATIC: 2,
	  BODYGROUP_KINEMATIC: 4,
	  BODYGROUP_ENGINE_1: 8,
	  BODYGROUP_TRIGGER: 16,
	  BODYGROUP_ENGINE_2: 32,
	  BODYGROUP_ENGINE_3: 64,
	  BODYGROUP_USER_1: 128,
	  BODYGROUP_USER_2: 256,
	  BODYGROUP_USER_3: 512,
	  BODYGROUP_USER_4: 1024,
	  BODYGROUP_USER_5: 2048,
	  BODYGROUP_USER_6: 4096,
	  BODYGROUP_USER_7: 8192,
	  BODYGROUP_USER_8: 16384,

	  // masks
	  BODYMASK_NONE: 0,
	  BODYMASK_ALL: 65535,
	  BODYMASK_STATIC: 2,
	  BODYMASK_NOT_STATIC: 65535 ^ 2,
	  BODYMASK_NOT_STATIC_KINEMATIC: 65535 ^ (2 | 4)
	};

	exports.default = CONSTANTS;

/***/ },
/* 293 */
/*!************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/triangulateMesh.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = triangulateMesh;

	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 203);

	var _PolyMap2 = _interopRequireDefault(_PolyMap);

	var _ScalarArrayView = __webpack_require__(/*! ../../generic/container/ScalarArrayView */ 199);

	var _ScalarArrayView2 = _interopRequireDefault(_ScalarArrayView);

	var _SimpleFanTriangulation = __webpack_require__(/*! ../algorithm/SimpleFanTriangulation */ 219);

	var _SimpleFanTriangulation2 = _interopRequireDefault(_SimpleFanTriangulation);

	var _applyFunctionToPolyMap = __webpack_require__(/*! ./applyFunctionToPolyMap */ 261);

	var _applyFunctionToPolyMap2 = _interopRequireDefault(_applyFunctionToPolyMap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function triangulateMesh(polyMesh) {

	  function triangulateMap(polyMap, polyMapName, additionalArguments) {
	    var newFaceRangeOffsets = additionalArguments.newFaceRangeOffsets;
	    var triangulation = additionalArguments.triangulation;

	    var result = new _ScalarArrayView2.default(triangulation.numTriangles * 3);
	    triangulation.translateIndices(polyMap.faceValueIndices, result);
	    var newFaceValueIndices = result.data;

	    return new _PolyMap2.default({
	      faceRangeOffsets: newFaceRangeOffsets,
	      faceValueIndices: newFaceValueIndices,
	      values: polyMap.values
	    });
	  };

	  var triangulation = new _SimpleFanTriangulation2.default(polyMesh);

	  var newFaceRangeOffsets = new Uint32Array(triangulation.numTriangles + 1);
	  for (var i = 1; i < newFaceRangeOffsets.length; i++) {
	    newFaceRangeOffsets[i] = newFaceRangeOffsets[i - 1] + 3;
	  }

	  var args = { newFaceRangeOffsets: newFaceRangeOffsets, triangulation: triangulation };
	  return (0, _applyFunctionToPolyMap2.default)(polyMesh, triangulateMap, args).topologyChanged();
	};

/***/ },
/* 294 */
/*!************************************!*\
  !*** ./src/modules/annotations.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _createReducer;

	exports.setAnnotationProperties = setAnnotationProperties;
	exports.openAnnotation = openAnnotation;
	exports.closeAnnotation = closeAnnotation;
	exports.useCustomAnnotationFunction = useCustomAnnotationFunction;
	exports.getCustomAnnotationFunction = getCustomAnnotationFunction;

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 143);

	var _createReducer3 = _interopRequireDefault(_createReducer2);

	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 281);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SET_ANNOTATION_PROPERTIES = 'SET_ANNOTATION_PROPERTIES';
	var USE_CUSTOM_ANNOTATION_FUNCTION = 'USE_CUSTOM_ANNOTATION_FUNCTION';

	/**
	 * Annotations
	 *
	 * @module annotations
	 * @public
	 *
	 */

	var initialState = (0, _immutable.Map)({
	  customAnnotationFn: null
	});

	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SET_ANNOTATION_PROPERTIES, function (state, _ref) {
	  var id = _ref.id,
	      attrs = _ref.attrs;

	  var props = state.get('id') || (0, _immutable.Map)();
	  return state.set(id, props.merge(attrs));
	}), (0, _defineProperty3.default)(_createReducer, USE_CUSTOM_ANNOTATION_FUNCTION, function (state, annotationFn) {
	  return state.set('customAnnotationFn', annotationFn);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state) {
	  return (0, _immutable.Map)({ customAnnotationFn: state.get('customAnnotationFn') });
	}), _createReducer));

	function setAnnotationProperties(id, attrs) {
	  return { type: SET_ANNOTATION_PROPERTIES, payload: { id: id, attrs: attrs } };
	};

	/**
	 * Open annotation node in the player.
	 * @param {String} id - id of the annotation node.
	 * @public
	 */
	function openAnnotation(id) {
	  return { type: SET_ANNOTATION_PROPERTIES, payload: { id: id, attrs: { pinned: true, open: true } } };
	};

	/**
	 * Close annotation node.
	 * @param {String} id - id of the annotation node.
	 * @public
	 */
	function closeAnnotation(id) {
	  return { type: SET_ANNOTATION_PROPERTIES, payload: { id: id, attrs: { pinned: false, open: false } } };
	};

	/**
	 * Use custom annotations. Set a custom function that will be called for every
	 * annotation on every scene update. The arguments passed to this function
	 * will be the [annotation object](global.html#Annotation), and the div that
	 * any annotations may be created under. This div has `pointer-events` set
	 * to none so that the scene below it will receive all mouse/touch events.
	 * If you wish to handle events in your annotations, make sure to set `pointer-events`.
	 *
	 * @public
	 * @param {Function} fn The function to be called for every annotation update.
	 */
	function useCustomAnnotationFunction(fn) {
	  return { type: USE_CUSTOM_ANNOTATION_FUNCTION, payload: fn };
	};

	function getCustomAnnotationFunction(store) {
	  return store.getIn(['annotations', 'customAnnotationFn']);
	};

	var publicApi = {
	  reducer: reducer,
	  actions: {
	    setAnnotationProperties: setAnnotationProperties, openAnnotation: openAnnotation, closeAnnotation: closeAnnotation,
	    useCustomAnnotationFunction: useCustomAnnotationFunction
	  },
	  selectors: { getCustomAnnotationFunction: getCustomAnnotationFunction }
	};

	exports.default = publicApi;

/***/ },
/* 295 */
/*!*******************************!*\
  !*** ./src/modules/player.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.manipulators = exports.RENDER_MODES = undefined;

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _createReducer;

	exports.useManipulator = useManipulator;
	exports.getActiveManipulator = getActiveManipulator;
	exports.addTool = addTool;
	exports.removeTool = removeTool;
	exports.showTool = showTool;
	exports.hideTool = hideTool;
	exports.updateToolOptions = updateToolOptions;
	exports.getRect = getRect;
	exports.setRect = setRect;
	exports.setCameraAttrs = setCameraAttrs;
	exports.getCameraAttrs = getCameraAttrs;
	exports.getCameraWorldTransform = getCameraWorldTransform;
	exports.useCamera = useCamera;
	exports.useVrCamera = useVrCamera;
	exports.setCamera = setCamera;
	exports.setThreeScene = setThreeScene;
	exports.getThreeScene = getThreeScene;
	exports.getThreeCamera = getThreeCamera;
	exports.getBoundingBox = getBoundingBox;
	exports.getCamera = getCamera;
	exports.getTools = getTools;
	exports.setCameraPosition = setCameraPosition;
	exports.getInitialCameraPosition = getInitialCameraPosition;
	exports.requestFullscreen = requestFullscreen;
	exports.exitFullscreen = exitFullscreen;
	exports.toggleFullscreen = toggleFullscreen;
	exports.isFullscreen = isFullscreen;
	exports.setFullscreen = setFullscreen;
	exports.getRenderingMode = getRenderingMode;
	exports.isNormalRenderingMode = isNormalRenderingMode;
	exports.isVRMode = isVRMode;
	exports.isLenticularMode = isLenticularMode;
	exports.activateTool = activateTool;
	exports.isToolActive = isToolActive;
	exports.getActiveTools = getActiveTools;
	exports.requestLenticularMode = requestLenticularMode;
	exports.requestNormalMode = requestNormalMode;
	exports.getPrevCamera = getPrevCamera;
	exports.setRenderMode = setRenderMode;
	exports.toggleLenticularMode = toggleLenticularMode;
	exports.enableDeviceTracking = enableDeviceTracking;
	exports.disableDeviceTracking = disableDeviceTracking;
	exports.toggleDeviceTracking = toggleDeviceTracking;
	exports.isDeviceTracking = isDeviceTracking;
	exports.setPlayerElement = setPlayerElement;
	exports.setActiveColor = setActiveColor;
	exports.setHoverColor = setHoverColor;
	exports.setFullscreenBGColor = setFullscreenBGColor;
	exports.getActiveColor = getActiveColor;
	exports.getHoverColor = getHoverColor;
	exports.getFullscreenBGColor = getFullscreenBGColor;
	exports.animateCameraTo = animateCameraTo;
	exports.resize = resize;
	exports.filterNodesFromPosition = filterNodesFromPosition;
	exports.setCameraRadiusConstraint = setCameraRadiusConstraint;
	exports.getCanvasElement = getCanvasElement;
	exports.getCameraRadiusConstraint = getCameraRadiusConstraint;
	exports.displayThumbnail = displayThumbnail;
	exports.shouldDisplayThumbnail = shouldDisplayThumbnail;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 143);

	var _createReducer3 = _interopRequireDefault(_createReducer2);

	var _scene = __webpack_require__(/*! ./scene */ 171);

	var _animation = __webpack_require__(/*! ./animation */ 134);

	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 144);

	var _updateCameraLookAtTarget = __webpack_require__(/*! ../translators/utils/updateCameraLookAtTarget */ 296);

	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

	var _calculateBoundingBox = __webpack_require__(/*! ../translators/utils/calculateBoundingBox */ 297);

	var _calculateBoundingBox2 = _interopRequireDefault(_calculateBoundingBox);

	var _camera = __webpack_require__(/*! ../translators/camera */ 298);

	var _setMatrixOnNode = __webpack_require__(/*! ../translators/utils/setMatrixOnNode */ 301);

	var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);

	var _decompose = __webpack_require__(/*! ../translators/utils/decompose */ 302);

	var _decompose2 = _interopRequireDefault(_decompose);

	var _getTargetWorldMatrix = __webpack_require__(/*! ../translators/utils/getTargetWorldMatrix */ 299);

	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

	var _commands = __webpack_require__(/*! ./commands */ 305);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var RENDER_MODES = exports.RENDER_MODES = {
	  normal: 'normal',
	  vr: 'vr',
	  lenticular: 'lenticular'
	};

	/**
	 * This module supports the UI for the player.
	 *
	 * @module player
	 * @public
	 */

	var manipulators = exports.manipulators = {
	  orbit: 'orbit',
	  pan: 'pan',
	  zoom: 'zoom',
	  nodeRotate: 'nodeRotate',
	  nodeMove: 'nodeMove',
	  nodeScale: 'nodeScale'
	};

	var USE_MANIPULATOR = 'USE_MANIPULATOR';
	var SET_CAMERA = 'SET_CAMERA';
	var SET_PREV_CAMERA = 'SET_PREV_CAMERA';
	var SET_CAMERA_ATTRS = 'SET_CAMERA_ATTRS';
	var SET_CAMERA_POSITION = 'SET_CAMERA_POSITION';
	var SET_RECT = 'SET_RECT';
	var DISPLAY_THUMBNAIL = 'DISPLAY_THUMBNAIL';
	var SET_ACTIVE_COLOR = 'SET_ACTIVE_COLOR';
	var SET_HOVER_COLOR = 'SET_HOVER_COLOR';
	var SET_PLAYER_ELEMENT = 'SET_PLAYER_ELEMENT';
	var REQUEST_FULL_SCREEN = 'REQUEST_FULL_SCREEN';
	var EXIT_FULL_SCREEN = 'EXIT_FULL_SCREEN';
	var SET_FULL_SCREEN = 'SET_FULL_SCREEN';
	var SET_RENDER_MODE = 'SET_RENDER_MODE';

	var REQUEST_NORMAL_MODE = 'REQUEST_NORMAL_MODE';
	var REQUEST_LENTICULAR_MODE = 'REQUEST_LENTICULAR_MODE';
	var SET_DEVICE_TRACKING = 'SET_DEVICE_TRACKING';
	var SET_BACKGROUND_COLOR = 'SET_BACKGROUND_COLOR';
	var REQUEST_STEREO_MODE = 'REQUEST_STEREO_MODE';
	var REQUEST_PARALLAX_MODE = 'REQUEST_PARALLAX_MODE';
	var EXIT_STEREOPARALLAX_MODE = 'EXIT_STEREOPARALLAX_MODE';
	var SET_CONSTRAIN_CAMERA_RADIUS = 'SET_CONSTRAIN_CAMERA_RADIUS';
	var SET_THREE_SCENE = 'SET_THREE_SCENE';

	var initialState = (0, _immutable.Map)({
	  activeColor: '#ffc85f',
	  hoverColor: '#C08618',
	  fullscreenBackgroundColor: '#FFF',
	  activeManipulator: manipulators.orbit,
	  fullScreen: false,
	  renderingMode: RENDER_MODES.normal,
	  deviceTracking: false,
	  camera: (0, _immutable.Map)({
	    polarAngle: null, azimuthAngle: null, boundingRadius: null
	  }),
	  rect: (0, _immutable.Map)({ width: 400, height: 300 }),
	  initialCameraWorldMatrix: null,
	  initialTargetWorldMatrix: null,
	  cameraWorldMatrix: null,
	  displayThumbnail: true,
	  playerElement: null,
	  canvasElement: null,
	  activeCamera: _sceneGraph.virtualCameraId,
	  vrCamera: _sceneGraph.vrCameraId,
	  threeScene: null,
	  prevCamera: null,
	  orientationHandler: null,
	  constrainCameraRadius: null
	});

	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, USE_MANIPULATOR, function (state, manipulator) {
	  return state.set('activeManipulator', manipulator);
	}), (0, _defineProperty3.default)(_createReducer, SET_CAMERA, function (state, _ref) {
	  var id = _ref.id,
	      prevCameraId = _ref.prevCameraId;

	  return state.set('activeCamera', id).set('prevCamera', prevCameraId);
	}), (0, _defineProperty3.default)(_createReducer, SET_CAMERA_ATTRS, function (state, attrs) {
	  return state.mergeIn(['camera'], attrs);
	}), (0, _defineProperty3.default)(_createReducer, SET_RECT, function (state, rect) {
	  return state.set('rect', rect);
	}), (0, _defineProperty3.default)(_createReducer, SET_CAMERA_POSITION, function (state, attrs) {
	  return state.merge(attrs);
	}), (0, _defineProperty3.default)(_createReducer, SET_PLAYER_ELEMENT, function (state, _ref2) {
	  var playerEl = _ref2.playerEl,
	      canvasEl = _ref2.canvasEl;

	  return state.set('playerElement', playerEl).set('canvasElement', canvasEl);
	}), (0, _defineProperty3.default)(_createReducer, DISPLAY_THUMBNAIL, function (state, display) {
	  return state.set('displayThumbnail', !!display);
	}), (0, _defineProperty3.default)(_createReducer, SET_ACTIVE_COLOR, function (state, color) {
	  return state.set('activeColor', color);
	}), (0, _defineProperty3.default)(_createReducer, SET_HOVER_COLOR, function (state, color) {
	  return state.set('hoverColor', color);
	}), (0, _defineProperty3.default)(_createReducer, SET_BACKGROUND_COLOR, function (state, color) {
	  return state.set('fullscreenBackgroundColor', color);
	}), (0, _defineProperty3.default)(_createReducer, REQUEST_FULL_SCREEN, function (state) {
	  return state.set('fullScreen', true);
	}), (0, _defineProperty3.default)(_createReducer, EXIT_FULL_SCREEN, function (state) {
	  return state.set('fullScreen', false);
	}), (0, _defineProperty3.default)(_createReducer, SET_FULL_SCREEN, function (state, fullScreen) {
	  return state.set('fullScreen', fullScreen);
	}), (0, _defineProperty3.default)(_createReducer, SET_RENDER_MODE, function (state, mode) {
	  return state.set('renderingMode', mode);
	}), (0, _defineProperty3.default)(_createReducer, REQUEST_LENTICULAR_MODE, function (state, _ref3) {
	  var trackDevice = _ref3.trackDevice,
	      cameraId = _ref3.cameraId;

	  return state.merge({
	    renderingMode: 'lenticular',
	    deviceTracking: trackDevice,
	    prevCamera: cameraId
	  });
	}), (0, _defineProperty3.default)(_createReducer, REQUEST_NORMAL_MODE, function (state) {
	  return state.merge({
	    renderingMode: 'normal',
	    deviceTracking: false
	  });
	}), (0, _defineProperty3.default)(_createReducer, SET_DEVICE_TRACKING, function (state, deviceTracking) {
	  return state.set('deviceTracking', deviceTracking);
	}), (0, _defineProperty3.default)(_createReducer, SET_CONSTRAIN_CAMERA_RADIUS, function (state, radius) {
	  return state.set('constrainCameraRadius', radius);
	}), (0, _defineProperty3.default)(_createReducer, SET_THREE_SCENE, function (state, _ref4) {
	  var scene = _ref4.scene,
	      camera = _ref4.camera;

	  return state.set('threeScene', scene).set('threeCamera', camera);
	}), _createReducer));

	function useManipulator(manipulator) {
	  return { type: USE_MANIPULATOR, payload: manipulator };
	}

	function getActiveManipulator(store) {
	  return store.getIn(['player', 'activeManipulator']);
	}

	/**
	 * Add a tool (See {@tutorial sdk-Tools})
	 *
	 * @public
	 * @param {Tool} Tool
	 * @param {String} name provide a name for the tool to allow removing it.
	 * @returns {Promise}
	 *
	 */
	function addTool(tool, name) {
	  return (0, _commands.addCommand)({ tool: tool, enabled: true }, name);
	}

	/**
	 * Remove a tool (See {@tutorial sdk-Tools})
	 *
	 * @public
	 * @param {String} name The name of the tool to remove
	 * @returns {Promise}
	 */
	function removeTool(name) {
	  return (0, _commands.removeCommand)(name);
	}

	function showTool(name) {
	  return (0, _commands.updateCommand)(name, { display: { playerTools: true } });
	}

	function hideTool(name) {
	  return (0, _commands.updateCommand)(name, { display: { playerTools: false } });
	}

	function updateToolOptions(name, options) {
	  return { type: UPDATE_COMMAND_OPTIONS, payload: { name: name, options: options } };
	}

	function getRect(store) {
	  return store.getIn(['player', 'rect']);
	}

	function setRect(rect) {
	  return { type: SET_RECT, payload: rect };
	}

	function setCameraAttrs(attrs) {
	  return { type: SET_CAMERA_ATTRS, payload: attrs };
	}

	function getCameraAttrs(store) {
	  return store.getIn(['player', 'camera']);
	}

	/**
	 * Returns the world matrix of the active camera
	 */
	function getCameraWorldTransform(store) {
	  return (0, _scene.getWorldTransform)(store, store.getIn(['player', 'activeCamera']));
	}

	/**
	 * This sets the scene to use the camera.
	 */
	function useCamera(id) {
	  return function (store) {
	    // store.dispatch(setCamera(id, getCamera(store)));
	    return store.dispatch((0, _scene.set)({ scene: true, plug: 'Player', property: 'camera' }, id));
	  };
	}

	function useVrCamera(switchToVR) {
	  return function (store) {
	    if (switchToVR) {
	      var activeCamera = store.getIn(['player', 'activeCamera']);
	      store.dispatch(setCamera(_sceneGraph.vrCameraId, activeCamera));
	    } else {
	      var prevCamera = store.getIn(['player', 'prevCamera']) || _sceneGraph.virtualCameraId;
	      store.dispatch(setCamera(prevCamera, null));
	    }
	  };
	}

	/**
	 * Sets the active camera for the scene
	 * @private
	 */
	function setCamera(id, prevCameraId) {
	  return function (store) {
	    var target = (0, _getTargetWorldMatrix2.default)(store, prevCameraId);
	    var oldCamData = (0, _scene.get)(store, { id: prevCameraId, evalPlug: 'Camera' });
	    var oldCameraTransform = (0, _scene.get)(store, { id: prevCameraId, evalPlug: 'Transform' });
	    if (oldCameraTransform && !oldCameraTransform.target) {
	      oldCamData.targetWorldMatrix = target;
	    }

	    var newCamData = (0, _scene.get)(store, { id: id, evalPlug: 'Camera' });
	    if (newCamData.targetWorldMatrix) {
	      store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(newCamData.targetWorldMatrix)));
	      newCamData.targetWorldMatrix = null;
	    }

	    store.dispatch({ type: SET_CAMERA, payload: { id: id, prevCameraId: prevCameraId } });
	  };
	}

	/**
	 * @private
	 */
	function setThreeScene(scene, camera) {
	  return { type: SET_THREE_SCENE, payload: { scene: scene, camera: camera } };
	}

	function getThreeScene(store) {
	  return store.getIn(['player', 'threeScene']);
	}

	function getThreeCamera(store) {
	  return store.getIn(['player', 'threeCamera']);
	}

	function getBoundingBox(store) {
	  var threeScene = getThreeScene(store);
	  return (0, _calculateBoundingBox2.default)(threeScene);
	}

	/**
	 * Returns the current active camera
	 * @public
	 */
	function getCamera(store) {
	  return store.getIn(['player', 'activeCamera']);
	}

	function getTools(store) {
	  return store.getIn(['player', 'tools']);
	}

	function setCameraPosition(attrs) {
	  return { type: SET_CAMERA_POSITION, payload: attrs };
	}

	function getInitialCameraPosition(store) {
	  return {
	    initialCameraWorldMatrix: store.getIn(['player', 'initialCameraWorldMatrix']),
	    initialTargetWorldMatrix: store.getIn(['player', 'initialTargetWorldMatrix'])
	  };
	}

	/**
	 *
	 * Enable fullscreen mode.
	 * @public
	 *
	 */
	function requestFullscreen() {
	  return function (store) {
	    var playerEl = store.getIn(['player', 'playerElement']);
	    ['requestFullscreen', 'webkitRequestFullscreen', 'mozRequestFullScreen', 'msRequestFullscreen'].forEach(function (fn) {
	      if (playerEl[fn]) return playerEl[fn]();
	    });

	    store.dispatch({ type: REQUEST_FULL_SCREEN });
	  };
	}

	/**
	 * Exit fullscreen mode
	 * @public
	 */
	function exitFullscreen() {
	  return function (store) {
	    ['exitFullscreen', 'webkitExitFullscreen', 'mozCancelFullScreen', 'msExitFullscreen'].forEach(function (fn) {
	      if (document[fn]) return document[fn]();
	    });

	    return store.dispatch({ type: EXIT_FULL_SCREEN });
	  };
	};

	/**
	 * Toggle fullscreen mode
	 * @public
	 *
	 */
	function toggleFullscreen() {
	  return function (store) {
	    return store.dispatch(isFullscreen(store) ? exitFullscreen() : requestFullscreen());
	  };
	};

	/**
	 * Check whether were in fullscreen mode.
	 * @public
	 *
	 */
	function isFullscreen(store) {
	  return store.getIn(['player', 'fullScreen']);
	};

	/**
	 * Set the value of fullscreen (set on an event handler, if the native
	 * browser control is used to escape full screen mode.
	 */
	function setFullscreen(fullScreen) {
	  return function (store) {
	    if (isFullscreen(store) !== fullScreen) {
	      store.dispatch({ type: SET_FULL_SCREEN, payload: fullScreen });
	    }

	    if (!fullScreen && isVRMode(store)) {
	      store.dispatch((0, _commands.deactivateCommand)('vrMode'));
	    }
	  };
	};

	function getRenderingMode(store) {
	  return store.getIn(['player', 'renderingMode']);
	}

	/**
	 * @public
	 *
	 */
	function isNormalRenderingMode(store) {
	  return store.getIn(['player', 'renderingMode']) === RENDER_MODES.normal;
	};

	/**
	 * Check whether we are in VR mode.
	 * @public
	 *
	 */
	function isVRMode(store) {
	  return store.getIn(['player', 'renderingMode']) === RENDER_MODES.vr;
	};

	/**
	 * Check whether we are in Lenticular rendering mode.
	 * @public
	 */
	function isLenticularMode(store) {
	  return store.getIn(['player', 'renderingMode']) === RENDER_MODES.lenticular;
	};

	function activateTool(toolName) {
	  return function (store) {
	    var tool = store.getIn(['player', 'tools', toolName]);
	    if (!tool) return;
	    if (tool.get('action')) return tool.get('action')(store);
	    var isActive = _isToolActive(store, tool);
	    if (tool.get('activate') && !isActive) return tool.get('activate')(store);
	    if (tool.get('deactivate') && isActive) return tool.get('deactivate')(store);
	    return store.dispatch(useManipulator(toolName));
	  };
	}

	function _isToolActive(store, tool) {
	  if (tool.get('isActive')) return tool.get('isActive')(store);
	  return store.getIn(['player', 'activeManipulator']) === tool.get('name');
	}

	function isToolActive(store, toolName) {
	  var tool = store.getIn(['player', 'tools', toolName]);
	  return tool && _isToolActive(store, tool);
	}

	function getActiveTools(store) {
	  return store.getIn(['player', 'tools']).filter(function (tool) {
	    return _isToolActive(store, tool);
	  });
	}

	function requestLenticularMode(_ref5) {
	  var trackDevice = _ref5.trackDevice;

	  return function (store) {
	    //store.dispatch(requestFullscreen());
	    var cameraId = getCamera(store);
	    store.dispatch({ type: REQUEST_LENTICULAR_MODE, payload: { trackDevice: trackDevice, cameraId: cameraId } });
	  };
	};

	function requestNormalMode() {
	  return { type: REQUEST_NORMAL_MODE };
	};

	function getPrevCamera(store) {
	  return store.getIn(['player', 'prevCamera']);
	}

	function setRenderMode(mode) {
	  if (!RENDER_MODES[mode]) throw new Error('Invalid Render Mode: ' + mode);
	  return { type: SET_RENDER_MODE, payload: mode };
	}

	function toggleLenticularMode() {
	  return function (store) {
	    store.dispatch(isLenticularMode(store) ? requestNormalMode() : requestLenticularMode({}));
	  };
	};

	function enableDeviceTracking() {
	  return { type: SET_DEVICE_TRACKING, payload: true };
	};

	function disableDeviceTracking() {
	  return { type: SET_DEVICE_TRACKING, payload: false };
	};

	function toggleDeviceTracking() {
	  return function (store) {
	    console.log('toggle device tracking', !isDeviceTracking(store));
	    store.dispatch(isDeviceTracking(store) ? disableDeviceTracking() : enableDeviceTracking());
	  };
	};

	function isDeviceTracking(store) {
	  return store.getIn(['player', 'deviceTracking']);
	};

	/**
	 * Store the rendered player element
	 */
	function setPlayerElement(playerEl, canvasEl) {
	  return { type: SET_PLAYER_ELEMENT, payload: { playerEl: playerEl, canvasEl: canvasEl } };
	};

	/**
	 * Set the active color and timeline color to be used for the player css.
	 *
	 * @public
	 * @param {Color} color a valid css color (ex. '#ff0000'}.
	 * @returns {Promise}
	 *
	 */
	function setActiveColor(color) {
	  return { type: SET_ACTIVE_COLOR, payload: color };
	};

	/**
	 * Set the hover color to be used for the player css.
	 *
	 * @public
	 * @param {Color} color a valid css color (ex. '#ff0000'}.
	 * @returns {Promise}
	 *
	 */
	function setHoverColor(color) {
	  return { type: SET_HOVER_COLOR, payload: color };
	};

	/**
	 * Set the fullscreen background color to be used for the player css.
	 *
	 * @public
	 * @param {Color} color a valid css color (ex. '#ff0000'}.
	 * @returns {Promise}
	 *
	 */
	function setFullscreenBGColor(color) {
	  return { type: SET_BACKGROUND_COLOR, payload: color };
	};

	/**
	 * Return the active color.
	 *
	 * @public
	 */
	function getActiveColor(store) {
	  return store.getIn(['player', 'activeColor']);
	};

	/**
	 * Return the hover color.
	 *
	 * @public
	 */
	function getHoverColor(store) {
	  return store.getIn(['player', 'hoverColor']);
	};

	/**
	 * Return the fullscreen background color.
	 *
	 * @public
	 */
	function getFullscreenBGColor(store) {
	  return store.getIn(['player', 'fullscreenBackgroundColor']);
	};

	function slerpTween(startMatrix, endMatrix) {
	  var startPosition = new THREE.Vector3();
	  var startQuaternion = new THREE.Quaternion();
	  var scale = new THREE.Vector3(1, 1, 1);
	  startMatrix.decompose(startPosition, startQuaternion, scale);

	  var endPosition = new THREE.Vector3();
	  var endQuaternion = new THREE.Quaternion();
	  endMatrix.decompose(endPosition, endQuaternion, scale);

	  var position = new THREE.Vector3();
	  var quaternion = new THREE.Quaternion();
	  scale.set(1, 1, 1);
	  var matrix = new THREE.Matrix4();

	  return function (time, start, end, duration) {
	    position.lerpVectors(startPosition, endPosition, time / duration);
	    THREE.Quaternion.slerp(startQuaternion, endQuaternion, quaternion, time / duration);
	    matrix.compose(position, quaternion, scale);
	    return matrix;
	  };
	};

	/**
	 * Animate the camera to the position of another.
	 *
	 * @public
	 * @param {String} id - the id of the camera to move to.
	 * @param {Number} duration - length of the animation (ms), default 300.
	 * @returns {Promise}
	 */
	function animateCameraTo(id, duration) {
	  return function (store) {
	    var cameraId = getCamera(store);
	    if (!cameraId || !id) return;

	    var prep = _promise2.default.resolve();

	    // if camera is targeted, temporarily disable targeting during animation
	    var camTarget = (0, _scene.find)(store, { id: cameraId, plug: 'Transform', property: 'target' });
	    var targetingDisabled = false;
	    if (camTarget && (0, _scene.get)(store, { id: cameraId, plug: 'Camera', property: 'targeted' })) {
	      var target = (0, _scene.get)(store, camTarget);
	      if (target) {
	        prep = store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Camera', property: 'targeted' }, false));
	        targetingDisabled = true;
	      }
	    }

	    return prep.then(function () {
	      var currentCameraTransform = (0, _scene.getWorldTransform)(store, cameraId);
	      var newCameraTransform = (0, _camera.initCamera)(store, false, id);
	      var actualDuration = duration || 300;

	      return new _promise2.default(function (resolve, reject) {
	        store.dispatch((0, _animation.queueAnimation)({
	          autoplay: true,
	          name: 'Move Camera',
	          iterations: 1,
	          tracks: [{
	            path: { id: cameraId, evalPlug: 'Transform' },
	            duration: actualDuration,
	            value: newCameraTransform,
	            startValue: currentCameraTransform,
	            tween: slerpTween(currentCameraTransform, newCameraTransform),
	            set: function set(_path, to) {
	              (0, _setMatrixOnNode2.default)(store, cameraId, to);
	            }
	          }],
	          onEnd: function onEnd() {
	            resolve(store.dispatch(useCamera(id)).then(function () {
	              // if camera was targeted, re-enable targeting now that animation is over
	              return targetingDisabled ? store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Camera', property: 'targeted' }, true)) : null;
	            }));
	          }
	        }));
	      });
	    });
	  };
	};

	/**
	 * Trigger a resize event. If you manually resize the player's dom element,
	 * use this to force the player to rerender with the updated size.
	 *
	 * @public
	 */
	function resize() {
	  return function (store) {
	    var translator = store.getTranslator();
	    if (translator) translator.resize();
	  };
	};

	/**
	 * Given a manipulator event, return the list of node ids at that position
	 *
	 * @public
	 * @param {Event} event generated by the manipulator interface. (See {@tutorial sdk-Tools})
	 * @returns {Array} list of node ids found.
	 *
	 * @example
	 *
	 * api.player.addTool({
	 *   click: (ev) => {
	 *     var nodes = api.player.filterNodesFromPosition(ev);
	 *     console.log('Found: ', nodes.map((id) => api.scene.get({id: id, property: 'name'})));
	 *   }
	 * }, 'FindNode');
	 *
	 */
	function filterNodesFromPosition(store, event) {
	  var translator = store.getTranslator();
	  if (!translator || !translator.raycastSelect) return null;
	  var x = event.clientX / (event.rect.width / 2) - 1;
	  var y = -(event.clientY / (event.rect.height / 2) - 1);
	  var hits = translator.raycastSelect({ x: x, y: y });
	  return hits.map(function (hit) {
	    return hit.id;
	  });
	};

	/**
	* Will constrain the target of the camera to remain inside the bounding sphere of the scene.
	* The camera will not be allowed to enter the bounding sphere of the scene nor leave  bounding sphere defined by arguments
	*
	* @public
	* @param {Number} radius distance around the center of the scene that defineds outer bounding sphere, setting radius to null disables bounding spheres
	*/
	function setCameraRadiusConstraint(radius) {
	  return function (store) {
	    store.dispatch({ type: SET_CONSTRAIN_CAMERA_RADIUS, payload: radius });
	    var cameraId = getCamera(store);
	    if (!cameraId) return;

	    // Store the radius constraint in the camera data, and touch the cameraNode
	    // to rerender
	    var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	    if (cameraData) {
	      if (!cameraData.radiusConstraint || cameraData.radiusConstraint.radius !== radius) {
	        cameraData.newRadiusConstraint = radius;
	      }
	    }

	    store.dispatch((0, _sceneGraph.touch)(cameraId));
	  };
	}

	function getCanvasElement(store) {
	  return store.getIn(['player', 'canvasElement']);
	}

	function getCameraRadiusConstraint(store) {
	  return store.getIn(['player', 'constrainCameraRadius']);
	};

	/**
	 * Turn thumbnail display on or off
	 * @public
	 * @param {Boolean} display - Display thumbnail (default true)
	 */
	function displayThumbnail(display) {
	  return { type: DISPLAY_THUMBNAIL, payload: display };
	};

	function shouldDisplayThumbnail(store) {
	  return store.getIn(['player', 'displayThumbnail']);
	};

	var publicApi = {
	  reducer: reducer,
	  actions: { addTool: addTool, removeTool: removeTool, showTool: showTool, hideTool: hideTool, useManipulator: useManipulator,
	    setCameraAttrs: setCameraAttrs, useCamera: useCamera, setCameraPosition: setCameraPosition, animateCameraTo: animateCameraTo, resize: resize,
	    displayThumbnail: displayThumbnail, setActiveColor: setActiveColor, requestFullscreen: requestFullscreen, exitFullscreen: exitFullscreen, setFullscreen: setFullscreen,
	    toggleFullscreen: toggleFullscreen, setHoverColor: setHoverColor, requestLenticularMode: requestLenticularMode,
	    enableDeviceTracking: enableDeviceTracking, disableDeviceTracking: disableDeviceTracking, toggleDeviceTracking: toggleDeviceTracking,
	    requestNormalMode: requestNormalMode, setFullscreenBGColor: setFullscreenBGColor,
	    setCameraRadiusConstraint: setCameraRadiusConstraint, updateToolOptions: updateToolOptions
	  },
	  selectors: { getCamera: getCamera, getCameraAttrs: getCameraAttrs, getInitialCameraPosition: getInitialCameraPosition, getCameraWorldTransform: getCameraWorldTransform,
	    getActiveColor: getActiveColor, isFullscreen: isFullscreen, isVRMode: isVRMode, isLenticularMode: isLenticularMode, getFullscreenBGColor: getFullscreenBGColor,
	    isDeviceTracking: isDeviceTracking, shouldDisplayThumbnail: shouldDisplayThumbnail, filterNodesFromPosition: filterNodesFromPosition,
	    getThreeScene: getThreeScene, getThreeCamera: getThreeCamera
	  }
	};
	exports.default = publicApi;

/***/ },
/* 296 */
/*!***********************************************************!*\
  !*** ./src/translators/utils/updateCameraLookAtTarget.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = updateCameraLookAtTarget;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var targetPosition = new THREE.Vector3();
	var cameraPosition = new THREE.Vector3();
	var targetUp = new THREE.Vector3(0, 1, 1);
	var lookAtMatrix = new THREE.Matrix4();
	var lookAtPosition = new THREE.Vector3();
	var lookAtScale = new THREE.Vector3();
	var lookAtRotation = new THREE.Quaternion();
	var cameraScale = new THREE.Vector3();
	var cameraRotation = new THREE.Quaternion();

	function updateCameraLookAtTarget(cameraWorldMatrix, targetWorldMatrix, upPosition) {
	  // console.trace('navigator.updateCameraLookAtTarget');
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	  targetPosition.setFromMatrixPosition(targetWorldMatrix);
	  // var te = targetWorldMatrix.elements;
	  //targetUp.set(0, 1, 0); // .applyMatrix4( targetWorldMatrix );
	  // console.log( "targetUp", JSON.stringify( targetUp ) );
	  //console.log(upPosition);
	  lookAtMatrix.makeTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z);
	  lookAtMatrix.lookAt(cameraPosition, targetPosition, upPosition || targetUp);
	  lookAtMatrix.decompose(lookAtPosition, lookAtRotation, lookAtScale);

	  cameraWorldMatrix.decompose(cameraPosition, cameraRotation, cameraScale);
	  cameraWorldMatrix.compose(cameraPosition, lookAtRotation, cameraScale);
	}

/***/ },
/* 297 */
/*!*******************************************************!*\
  !*** ./src/translators/utils/calculateBoundingBox.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = calculateBoundingBox;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function calculateBoundingBox(object) {
	  var box = new THREE.Box3();
	  var result = new THREE.Box3();

	  if (!object) return result;

	  var objectsRoot = object;
	  object.children.forEach(function (child) {
	    if (child.type === 'Object3D' && child.name === 'Objects') objectsRoot = child;
	  });

	  result.makeEmpty();

	  object.updateMatrixWorld(true);

	  objectsRoot.traverse(function (node) {
	    if (!node.visible) return;
	    if (!node.geometry) return;

	    var geometry = node.geometry;

	    if (geometry.boundingBox === null) {
	      geometry.computeBoundingBox();
	    }

	    if (geometry.boundingBox.isEmpty() === false) {
	      box.copy(geometry.boundingBox);
	      node.matrix.compose(node.position, node.quaternion, node.scale);
	      node.updateMatrixWorld(true);
	      box.applyMatrix4(node.matrixWorld);
	      result.union(box);
	    }
	  });

	  return result;
	}

/***/ },
/* 298 */
/*!***********************************!*\
  !*** ./src/translators/camera.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.resizeCamera = resizeCamera;
	exports.updateLookatTarget = updateLookatTarget;
	exports.initCamera = initCamera;
	exports.initCameraRadiusConstraint = initCameraRadiusConstraint;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _scene = __webpack_require__(/*! ../modules/scene */ 171);

	var _getTargetWorldMatrix = __webpack_require__(/*! ./utils/getTargetWorldMatrix */ 299);

	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

	var _updateCameraLookAtTarget = __webpack_require__(/*! ./utils/updateCameraLookAtTarget */ 296);

	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

	var _player = __webpack_require__(/*! ../modules/player */ 295);

	var _sceneGraph = __webpack_require__(/*! ../modules/sceneGraph */ 144);

	var _clamp = __webpack_require__(/*! ./utils/clamp */ 300);

	var _clamp2 = _interopRequireDefault(_clamp);

	var _setMatrixOnNode = __webpack_require__(/*! ./utils/setMatrixOnNode */ 301);

	var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);

	var _orbit = __webpack_require__(/*! ./tools/orbit */ 303);

	var _zoom = __webpack_require__(/*! ./tools/zoom */ 304);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var _THREE$Math = THREE.Math,
	    degToRad = _THREE$Math.degToRad,
	    radToDeg = _THREE$Math.radToDeg;
	var tan = Math.tan,
	    cos = Math.cos,
	    atan = Math.atan,
	    acos = Math.acos,
	    min = Math.min,
	    max = Math.max,
	    pow = Math.pow,
	    PI = Math.PI,
	    sqrt = Math.sqrt;

	// Temporary variables for intermediate calculations

	var t_cameraPosition = new THREE.Vector3();
	var t_oldTargetPosition = new THREE.Vector3();
	var t_targetPosition = new THREE.Vector3();
	var t_sphericalCamera = new THREE.Spherical();
	var t_sphericalTarget = new THREE.Spherical();
	var t_invTargetWorldMatrix = new THREE.Matrix4();
	var t_invPivotMatrix = new THREE.Matrix4();
	var t_changeQuaternion = new THREE.Quaternion();

	function resizeCamera(store, cameraId, rect) {
	  var aspectRatio = rect.x / rect.y;
	  store.dispatch((0, _player.setRect)(rect));
	  var name = (0, _sceneGraph.get)(store, [cameraId, 'name']);
	  if (name) store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Camera', property: 'aspectRatio' }, aspectRatio));
	}

	function updateLookatTarget(store, cameraId, transformData, cameraData) {
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);

	  if (playerData.orbitMode === 'trackball') {
	    t_cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	    t_oldTargetPosition.set(0, 0, -1).transformDirection(cameraWorldMatrix);
	    t_targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(t_cameraPosition).normalize();

	    t_changeQuaternion.setFromUnitVectors(t_targetPosition, t_oldTargetPosition);
	    cameraData.upPosition.applyQuaternion(t_changeQuaternion);
	  }

	  t_targetPosition.setFromMatrixPosition(targetWorldMatrix);
	  cameraData.pivotMatrix.setPosition(t_targetPosition.sub(cameraData.offset));

	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	  return cameraWorldMatrix;
	}

	function initCamera(store, dispatch, fromCameraId, toCameraId, fromRect) {
	  var toId = toCameraId || _sceneGraph.virtualCameraId;
	  var fromId = fromCameraId || _sceneGraph.virtualCameraId;
	  var boundingBox = (0, _player.getBoundingBox)(store);
	  var rect = fromRect || (0, _player.getRect)(store);
	  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, fromId);
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, fromId);
	  var cameraPosition = new THREE.Vector3().setFromMatrixPosition(cameraWorldMatrix);

	  resizeCamera(store, toId, rect);

	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var fromCameraData = (0, _scene.get)(store, { id: fromId, evalPlug: 'Camera' });
	  var toCameraData = fromId === toId ? fromCameraData : (0, _scene.get)(store, { id: toId, evalPlug: 'Camera' });

	  var pivotMatrix = targetWorldMatrix.clone();
	  var pivotPosition = new THREE.Vector3().setFromMatrixPosition(pivotMatrix);
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix).sub(pivotPosition);

	  var upPosition = new THREE.Vector3(0, 1, 0);
	  if (playerData.orbitMode === 'trackball') {
	    upPosition.transformDirection(cameraWorldMatrix);

	    var normal = new THREE.Vector3().copy(cameraPosition).normalize();
	    var cameraViewPlane = new THREE.Plane(normal, 0);
	    upPosition.copy(cameraViewPlane.projectPoint(upPosition).normalize());
	  }

	  var pivY = pivotMatrix.elements[13];
	  if (pivY + cameraPosition.length() < 0 && playerData.constraintCameraY) {
	    cameraPosition.normalize().multiplyScalar(pivY);
	  }

	  cameraWorldMatrix.setPosition(cameraPosition.add(pivotPosition));

	  toCameraData.upPosition = upPosition;
	  toCameraData.pivotMatrix = pivotMatrix;
	  toCameraData.offset = new THREE.Vector3(0, 0, 0);

	  adjustAngleAndRadius(store, fromId, cameraWorldMatrix, targetWorldMatrix, fromCameraData, boundingBox);

	  if (playerData.constraintCameraY) (0, _orbit.updateSphericalRotation)(store, toId, cameraWorldMatrix, targetWorldMatrix, new THREE.Vector2(0, 0));

	  var radiusConstraint = (0, _player.getCameraRadiusConstraint)(store);
	  if (radiusConstraint) {
	    initCameraRadiusConstraint(store, toId, toCameraData, radiusConstraint, cameraWorldMatrix, targetWorldMatrix);
	  }

	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, upPosition);
	  if (dispatch) (0, _setMatrixOnNode2.default)(store, toId, cameraWorldMatrix);
	  return cameraWorldMatrix;
	}

	function initCameraRadiusConstraint(store, cameraId, cameraData, outerRadius, initCameraWorldMatrix, initTargetWorldMatrix) {
	  var boundingBox = (0, _player.getBoundingBox)(store);
	  var minBoundingSphere = new THREE.Sphere();
	  var cameraWorldMatrix = initCameraWorldMatrix || (0, _scene.getWorldTransform)(store, cameraId);
	  var targetWorldMatrix = initTargetWorldMatrix || (0, _getTargetWorldMatrix2.default)(store, cameraId);
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });

	  boundingBox.getBoundingSphere(minBoundingSphere);
	  if (outerRadius <= minBoundingSphere.radius) {
	    return;
	  }

	  var maxBoundingSphere = new THREE.Sphere(minBoundingSphere.center, outerRadius);

	  t_targetPosition.setFromMatrixPosition(targetWorldMatrix);
	  t_cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	  var targetToCamera = new THREE.Vector3().subVectors(t_cameraPosition, t_targetPosition);

	  var thirdVector = new THREE.Vector3().crossVectors(targetToCamera, cameraData.upPosition).normalize();
	  var newTargetPosition = minBoundingSphere.clampPoint(t_targetPosition);
	  var newCameraPosition = maxBoundingSphere.clampPoint(t_cameraPosition);
	  cameraWorldMatrix.setPosition(newCameraPosition);
	  targetWorldMatrix.setPosition(newTargetPosition);

	  if (playerData.orbitMode === 'trackball') {
	    var newTargetToCamera = new THREE.Vector3().subVectors(newCameraPosition, newTargetPosition);
	    cameraData.upPosition.crossVectors(thirdVector, newTargetToCamera).normalize();
	  }

	  cameraData.radiusConstraint = { outerRadius: outerRadius, maxBoundingSphere: maxBoundingSphere, minBoundingSphere: minBoundingSphere };
	  cameraData.newRadiusConstraint = null;
	  (0, _zoom.updateZoom)(store, 0, cameraId, cameraWorldMatrix);

	  if (!initCameraWorldMatrix) (0, _setMatrixOnNode2.default)(store, cameraId, cameraWorldMatrix);
	}

	/*
	 * Set the camera angle and radius.
	 */
	function adjustAngleAndRadius(store, cameraId, cameraWorldMatrix, targetWorldMatrix, cameraData, boundingBox) {
	  var _getCameraAttrs$toJS = (0, _player.getCameraAttrs)(store).toJS(),
	      azimuthAngle = _getCameraAttrs$toJS.azimuthAngle,
	      polarAngle = _getCameraAttrs$toJS.polarAngle,
	      boundingRadius = _getCameraAttrs$toJS.boundingRadius;

	  var initialMinPolarAngle = 0;
	  var initialMaxPolarAngle = PI;
	  var minPolarAngle = 0;
	  var maxPolarAngle = PI;

	  if (cameraId === _sceneGraph.virtualCameraId) {
	    // Use defaults for the virtual camera only
	    if (azimuthAngle == null) azimuthAngle = 45;
	    if (polarAngle == null) polarAngle = 20;
	    if (boundingRadius == null) boundingRadius = 1;
	  }

	  if (azimuthAngle == null && polarAngle == null) {
	    return;
	  }

	  t_invTargetWorldMatrix.getInverse(targetWorldMatrix, true);
	  // world to relative
	  t_cameraPosition.setFromMatrixPosition(cameraWorldMatrix).applyMatrix4(t_invTargetWorldMatrix);

	  t_sphericalCamera.setFromVector3(t_cameraPosition);
	  t_sphericalCamera.theta = degToRad(azimuthAngle);
	  t_sphericalCamera.phi = degToRad(90 - polarAngle);

	  minPolarAngle = max(minPolarAngle || 0, initialMinPolarAngle); // radians
	  maxPolarAngle = min(maxPolarAngle || PI, initialMaxPolarAngle); // radians

	  t_sphericalCamera.phi = (0, _clamp2.default)(t_sphericalCamera.phi, minPolarAngle, maxPolarAngle);

	  if (boundingRadius != null) {
	    var fixRadius = boundingRadius * boundingBox.getBoundingSphere().radius;
	    t_sphericalCamera.radius = (fixRadius <= 0 ? 1 : fixRadius) / tan(degToRad(cameraData.fieldOfView * 0.5));
	    t_sphericalCamera.radius = (fixRadius <= 0 || fixRadius === Infinity ? 1 : fixRadius) / tan(degToRad(cameraData.fieldOfView * 0.5));
	  }

	  t_sphericalCamera.makeSafe();

	  t_cameraPosition.setFromSpherical(t_sphericalCamera);
	  t_sphericalCamera.setFromVector3(t_cameraPosition);

	  // relative to world
	  t_cameraPosition.applyMatrix4(targetWorldMatrix);
	  cameraWorldMatrix.setPosition(t_cameraPosition);
	}

/***/ },
/* 299 */
/*!*******************************************************!*\
  !*** ./src/translators/utils/getTargetWorldMatrix.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getTargetWorldMatrix;

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 144);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var position = new THREE.Vector3();
	var rotation = new THREE.Quaternion();
	var scale = new THREE.Vector3();
	/**
	 * If the Camera has a look at attached, return that, otherwise the
	 * virtual target transform
	 * @returns {Matrix4}
	 */
	function getTargetWorldMatrix(store, cameraId, initCameraTransform) {
	  var cameraTransform = initCameraTransform || (0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' });
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	  if (cameraTransform && cameraTransform.target) {
	    var lookAtTarget = (0, _scene.getWorldTransform)(store, cameraTransform.target.nodeId);
	    var offset = cameraData.offset;
	    lookAtTarget.decompose(position, rotation, scale);
	    return !offset ? lookAtTarget : lookAtTarget.compose(position.add(offset), rotation, scale);
	  } else {
	    return (0, _scene.getWorldTransform)(store, _sceneGraph.virtualTargetId);
	  }
	}

/***/ },
/* 300 */
/*!****************************************!*\
  !*** ./src/translators/utils/clamp.js ***!
  \****************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = clamp;
	function clamp(value, min, max) {
	  return Math.max(Math.min(value, max), min);
	}

/***/ },
/* 301 */
/*!**************************************************!*\
  !*** ./src/translators/utils/setMatrixOnNode.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = setMatrixOnNode;

	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 144);

	var _decompose = __webpack_require__(/*! ./decompose */ 302);

	var _decompose2 = _interopRequireDefault(_decompose);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function setMatrixOnNode(store, nodeId, matrix4) {
	  store.dispatch((0, _sceneGraph.merge)([nodeId, 'Transform', 0], (0, _decompose2.default)(matrix4)));
	}

/***/ },
/* 302 */
/*!********************************************!*\
  !*** ./src/translators/utils/decompose.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = decompose;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function decompose(matrix4) {
	  var translation = new THREE.Vector3();
	  var rotQuat = new THREE.Quaternion();
	  var scale = new THREE.Vector3();
	  matrix4.decompose(translation, rotQuat, scale);
	  var rotation = new THREE.Vector3().copy(new THREE.Euler().setFromQuaternion(rotQuat, 'ZYX'));
	  rotation.multiplyScalar(180 / Math.PI); // convert to degrees
	  return { translation: translation, rotation: rotation };
	};

/***/ },
/* 303 */
/*!****************************************!*\
  !*** ./src/translators/tools/orbit.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.updateSphericalRotation = updateSphericalRotation;
	exports.default = orbit;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _clamp = __webpack_require__(/*! ../utils/clamp */ 300);

	var _clamp2 = _interopRequireDefault(_clamp);

	var _decompose = __webpack_require__(/*! ../utils/decompose */ 302);

	var _decompose2 = _interopRequireDefault(_decompose);

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 144);

	var _updateCameraLookAtTarget = __webpack_require__(/*! ../utils/updateCameraLookAtTarget */ 296);

	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 299);

	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var tan = Math.tan,
	    cos = Math.cos,
	    atan = Math.atan,
	    acos = Math.acos,
	    min = Math.min,
	    max = Math.max,
	    pow = Math.pow,
	    PI = Math.PI,
	    sqrt = Math.sqrt;
	function updateSphericalRotation(store, cameraId, cameraWorldMatrix, targetWorldMatrix, mouseDelta) {
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });

	  var rect = (0, _player.getRect)(store);

	  var updateFns = { trackball: trackballUpdate, firstPerson: firstPersonUpdate };
	  var updateFn = updateFns[playerData.orbitMode] || gyroscopeUpdate;
	  updateFn(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, mouseDelta);
	}

	function orbit(store, translator) {
	  return {
	    label: 'Orbit',
	    active: true,
	    enabled: true,

	    display: {
	      playerTools: true
	    },
	    options: {},

	    tool: {
	      drag: function drag(ev) {
	        if (ev.which !== 1 || !(this.active || ev.metaKey)) return false;

	        return {
	          momentum: true,

	          handle: function handle(_ref) {
	            var deltaX = _ref.deltaX,
	                deltaY = _ref.deltaY;

	            var cameraId = (0, _player.getCamera)(store);
	            var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	            var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);

	            updateSphericalRotation(store, cameraId, cameraWorldMatrix, targetWorldMatrix, new THREE.Vector2(deltaX, deltaY));
	            store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));

	            if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
	              store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
	            }
	          }
	        };
	      }
	    }
	  };
	}

	var cameraPosition = new THREE.Vector3();
	var targetPosition = new THREE.Vector3();
	var sphericalCamera = new THREE.Spherical();
	var sphericalTarget = new THREE.Spherical();
	var invTargetWorldMatrix = new THREE.Matrix4();
	var invPivotMatrix = new THREE.Matrix4();

	// changes cameraWorldMatrix by rotating by delta
	function gyroscopeUpdate(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, _ref2) {
	  var x = _ref2.x,
	      y = _ref2.y;


	  //to target space
	  targetPosition.setFromMatrixPosition(targetWorldMatrix);
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix).sub(targetPosition);

	  var cameraSpherical = new THREE.Spherical().setFromVector3(cameraPosition);

	  var azimuthalAngle = 2 * PI * (-x / rect.x);
	  cameraSpherical.theta += azimuthalAngle;

	  var polarAngle = 2 * PI * (-y / rect.y);
	  cameraSpherical.phi += polarAngle;
	  var maxPolarAngle = void 0;
	  if (targetPosition.y / cameraPosition.length() <= 1) {
	    maxPolarAngle = playerData.constraintCameraY ? acos(-targetPosition.y / cameraPosition.length()) : PI;
	  } else {
	    maxPolarAngle = PI;
	  }

	  cameraSpherical.phi = (0, _clamp2.default)(cameraSpherical.phi, 0, maxPolarAngle);

	  cameraSpherical.makeSafe();
	  cameraPosition.setFromSpherical(cameraSpherical).add(targetPosition);

	  if (cameraData.radiusConstraint) {
	    var _cameraData$radiusCon = cameraData.radiusConstraint,
	        maxBoundingSphere = _cameraData$radiusCon.maxBoundingSphere,
	        minBoundingSphere = _cameraData$radiusCon.minBoundingSphere;

	    var camToTarg = new THREE.Vector3().subVectors(targetPosition, cameraPosition);
	    if (minBoundingSphere.containsPoint(cameraPosition)) {
	      var backwardRay = new THREE.Ray(cameraPosition, camToTarg.multiplyScalar(-1));
	      var newPosition = backwardRay.intersectSphere(minBoundingSphere).addScaledVector(camToTarg, (0.001));
	      cameraPosition.copy(newPosition);
	    } else if (!maxBoundingSphere.containsPoint(cameraPosition)) {
	      var forwardRay = new THREE.Ray(cameraPosition, camToTarg);
	      var _newPosition = forwardRay.intersectSphere(maxBoundingSphere).addScaledVector(camToTarg, (0.001));
	      cameraPosition.copy(_newPosition);
	    } else {}
	  }

	  cameraWorldMatrix.setPosition(cameraPosition);

	  // update orientation
	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	}

	// changes cameraWorldMatrix by rotating by delta
	function trackballUpdate(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, _ref3) {
	  var x = _ref3.x,
	      y = _ref3.y;

	  var radius = min(rect.x, rect.y);

	  var pivotMatrix = cameraData.pivotMatrix;
	  var pivotPosition = new THREE.Vector3().setFromMatrixPosition(pivotMatrix);

	  var relativeDelta = new THREE.Vector3().set(-2 * x / radius, 2 * y / radius, 0);
	  if (relativeDelta.length() > 1) relativeDelta.normalize();
	  if (relativeDelta.x === 0 && relativeDelta.y === 0) return;
	  var delta = relativeDelta.length();

	  //world to relative pivot space
	  relativeDelta.transformDirection(cameraWorldMatrix).multiplyScalar(delta);
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix).sub(pivotPosition);
	  targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(pivotPosition);
	  //upPosition.transformDirection(invPivotMatrix);
	  var camNorm = new THREE.Vector3().copy(cameraPosition).normalize();
	  //create rotational Quaternion
	  var scaleFactor = sqrt(1 - relativeDelta.lengthSq());
	  relativeDelta.addScaledVector(camNorm, scaleFactor).normalize();

	  var rotationalAxis = new THREE.Vector3().crossVectors(camNorm, relativeDelta).normalize();
	  var rotationalAngle = camNorm.angleTo(relativeDelta);
	  var rotationalQuaternion = new THREE.Quaternion().setFromAxisAngle(rotationalAxis, rotationalAngle);

	  //pivot relative to world space
	  cameraPosition.applyQuaternion(rotationalQuaternion).add(pivotPosition);
	  targetPosition.applyQuaternion(rotationalQuaternion).add(pivotPosition);
	  cameraData.upPosition.applyQuaternion(rotationalQuaternion); //.transformDirection(pivotMatrix);
	  cameraData.offset.applyQuaternion(rotationalQuaternion);

	  //bounding box constraining
	  if (cameraData.radiusConstraint) {
	    var _cameraData$radiusCon2 = cameraData.radiusConstraint,
	        maxBoundingSphere = _cameraData$radiusCon2.maxBoundingSphere,
	        minBoundingSphere = _cameraData$radiusCon2.minBoundingSphere;

	    var camToTarg = new THREE.Vector3().subVectors(targetPosition, cameraPosition);

	    if (minBoundingSphere.containsPoint(cameraPosition)) {
	      var backwardRay = new THREE.Ray(cameraPosition, new THREE.Vector3().copy(camToTarg).multiplyScalar(-1));

	      var newPosition = backwardRay.intersectSphere(minBoundingSphere).addScaledVector(camToTarg, -(0.001));

	      cameraPosition.copy(newPosition);
	    } else if (!maxBoundingSphere.containsPoint(cameraPosition)) {
	      var forwardRay = new THREE.Ray(cameraPosition, camToTarg);

	      var _newPosition2 = forwardRay.intersectSphere(maxBoundingSphere).addScaledVector(camToTarg, (0.001));

	      cameraPosition.copy(_newPosition2);
	    } else {}

	    if (!minBoundingSphere.containsPoint(targetPosition)) {
	      var thirdVector = new THREE.Vector3().crossVectors(camToTarg, cameraData.upPosition);
	      var _newPosition3 = minBoundingSphere.clampPoint(targetPosition);

	      var posChange = new THREE.Vector3().subVectors(_newPosition3, targetPosition);
	      _newPosition3.addScaledVector(posChange, (0.001));

	      cameraData.upPosition.crossVectors(thirdVector, camToTarg.subVectors(_newPosition3, cameraPosition)).normalize();
	      targetPosition.copy(_newPosition3);
	    }
	  }

	  cameraWorldMatrix.setPosition(cameraPosition);
	  targetWorldMatrix.setPosition(targetPosition);

	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	}

	function firstPersonUpdate(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, _ref4) {
	  var x = _ref4.x,
	      y = _ref4.y;

	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	  targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(cameraPosition);

	  var targetSpherical = new THREE.Spherical().setFromVector3(targetPosition);

	  var azimuthalAngle = 2 * PI * (-x / rect.x);
	  targetSpherical.theta += azimuthalAngle;

	  var polarAngle = 2 * PI * (y / rect.y);
	  targetSpherical.phi += polarAngle;

	  targetSpherical.makeSafe();
	  targetPosition.setFromSpherical(targetSpherical).add(cameraPosition);

	  targetWorldMatrix.setPosition(targetPosition);

	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	}

/***/ },
/* 304 */
/*!***************************************!*\
  !*** ./src/translators/tools/zoom.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = zoom;
	exports.updateZoom = updateZoom;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _clamp = __webpack_require__(/*! ../utils/clamp */ 300);

	var _clamp2 = _interopRequireDefault(_clamp);

	var _decompose = __webpack_require__(/*! ../utils/decompose */ 302);

	var _decompose2 = _interopRequireDefault(_decompose);

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 144);

	var _updateCameraLookAtTarget = __webpack_require__(/*! ../utils/updateCameraLookAtTarget */ 296);

	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 299);

	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var tan = Math.tan,
	    cos = Math.cos,
	    atan = Math.atan,
	    acos = Math.acos,
	    min = Math.min,
	    max = Math.max,
	    pow = Math.pow,
	    PI = Math.PI,
	    sqrt = Math.sqrt;


	var EPS = 0.000001;
	var cameraPosition = new THREE.Vector3();
	var targetPosition = new THREE.Vector3();
	var targetToCamera = new THREE.Vector3();

	function zoom(store, translator) {
	  function zoomBy(_ref) {
	    var delta = _ref.delta,
	        deltaX = _ref.deltaX,
	        deltaY = _ref.deltaY;

	    var d = delta !== undefined ? delta : deltaX / 30 + -deltaY / 30;
	    var cameraId = (0, _player.getCamera)(store);
	    var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
	    updateZoom(store, -d, cameraId, cameraWorldMatrix);
	    store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
	  }

	  return {
	    label: 'Zoom',
	    enabled: true,
	    display: {
	      playerTools: true
	    },
	    options: {},

	    tool: {
	      drag: function drag(ev) {
	        if (!this.active && !ev.ctrlKey) return false;

	        return {
	          momentum: true,
	          handle: function handle(ev) {
	            var newEv = { delta: ev.delta !== undefined ? ev.delta : ev.deltaX / 30 + -ev.deltaY / 30 };
	            zoomBy(newEv);
	          }
	        };
	      },

	      pinch: function pinch(ev) {
	        zoomBy(ev);
	      },

	      scroll: function scroll(ev) {
	        zoomBy(ev);
	      }
	    }
	  };
	}

	function updateZoom(store, mouseDelta, cameraId, cameraWorldMatrix) {
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
	  var rect = (0, _player.getRect)(store);

	  var deltaZoom = mouseDelta / rect.y;
	  var decayZoomFactor = pow(2, deltaZoom * 100); // this ensures the zoom has consistent speed no matter the size

	  if (cameraData.projection === 'Perspective') {

	    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	    targetPosition.setFromMatrixPosition(targetWorldMatrix);

	    targetToCamera.copy(cameraPosition).sub(targetPosition);
	    var targetToCameraDistance = max(targetToCamera.length(), EPS);
	    var newTargetToCameraDistance = targetToCameraDistance * decayZoomFactor;

	    if (cameraData.radiusConstraint) {
	      var _cameraData$radiusCon = cameraData.radiusConstraint,
	          maxBoundingSphere = _cameraData$radiusCon.maxBoundingSphere,
	          minBoundingSphere = _cameraData$radiusCon.minBoundingSphere;

	      var camToTargetBackward = new THREE.Vector3().copy(targetToCamera).normalize();
	      var camToTargetForward = new THREE.Vector3().copy(camToTargetBackward).multiplyScalar(-1);

	      var forwardRay = new THREE.Ray(cameraPosition, camToTargetForward);
	      var backwardRay = new THREE.Ray(cameraPosition, camToTargetBackward);

	      var lowerBound = new THREE.Vector3(),
	          upperBound = new THREE.Vector3();

	      forwardRay.intersectSphere(minBoundingSphere, lowerBound);
	      backwardRay.intersectSphere(maxBoundingSphere, upperBound);

	      var minZoom = lowerBound.sub(targetPosition).length();
	      var maxZoom = upperBound.sub(targetPosition).length();

	      newTargetToCameraDistance = (0, _clamp2.default)(newTargetToCameraDistance, minZoom + (0.001), maxZoom - (0.001));
	    }

	    targetToCamera.multiplyScalar(newTargetToCameraDistance / targetToCameraDistance);
	    cameraPosition.copy(targetPosition).add(targetToCamera);
	    if (cameraPosition.y < 0 && playerData.constraintCameraY && playerData.orbitMode !== 'trackball') {
	      var thirdVector = new THREE.Vector3().crossVectors(targetToCamera, cameraData.upPosition).normalize();
	      cameraPosition.y = 0;
	      targetToCamera.copy(cameraPosition).sub(targetPosition);
	    }

	    cameraWorldMatrix.setPosition(cameraPosition);

	    (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	  } else if (cameraData.projection === 'Orthographic') {
	    var _zoom = (0, _scene.get)(store, { id: cameraId, plug: 'Camera', property: 'orthoZoom' });
	    store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Camera', property: 'orthoZoom' }, _zoom * decayZoomFactor));
	  }
	};

/***/ },
/* 305 */
/*!*********************************!*\
  !*** ./src/modules/commands.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MOUSE_CONTROLS = undefined;

	var _values = __webpack_require__(/*! babel-runtime/core-js/object/values */ 306);

	var _values2 = _interopRequireDefault(_values);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _createReducer;

	exports.addCommand = addCommand;
	exports.removeCommand = removeCommand;
	exports.updateCommand = updateCommand;
	exports.setCommandOptions = setCommandOptions;
	exports.getTools = getTools;
	exports.getCommands = getCommands;
	exports.isCommandActive = isCommandActive;
	exports.getActiveCommandsWithWidgets = getActiveCommandsWithWidgets;
	exports.activateCommand = activateCommand;
	exports.deactivateCommand = deactivateCommand;
	exports.runCommand = runCommand;
	exports.updateCommands = updateCommands;

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 143);

	var _createReducer3 = _interopRequireDefault(_createReducer2);

	var _player = __webpack_require__(/*! ./player */ 295);

	var _createStore = __webpack_require__(/*! ../store/createStore */ 284);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var MOUSE_CONTROLS = exports.MOUSE_CONTROLS = ['orbit', 'pan', 'zoom'];

	/**
	 * This module manages commands and tools of the player
	 *
	 * @module commands
	 * @public
	 */

	var ADD_COMMAND = 'ADD_COMMAND';
	var REMOVE_COMMAND = 'REMOVE_COMMAND';
	var UPDATE_COMMAND = 'UPDATE_COMMAND';
	var FAIL_COMMAND = 'FAIL_COMMAND';
	var FINISH_COMMAND = 'FINISH_COMMAND';
	var RUN_COMMAND = 'RUN_COMMAND';
	var UPDATE_COMMAND_OPTIONS = 'UPDATE_COMMAND_OPTIONS;';

	var defaultCommand = {
	  enabled: true,
	  display: {},
	  options: {},

	  isEnabled: function isEnabled(store, command) {
	    return command.enabled;
	  },
	  isVisible: function isVisible(store, command) {
	    return command.display;
	  },

	  command: null,
	  widget: null
	};

	function makeCommand(state, command) {
	  return state.set(command.name, command);
	}

	function newInitialState() {
	  return (0, _immutable.Map)({
	    all: {},
	    allCommands: (0, _immutable.List)(),
	    tools: (0, _immutable.List)(),
	    activeCommand: null
	  });
	}

	function initCommand(attrs, name) {
	  var cmd = (0, _assign2.default)({}, defaultCommand, attrs, { name: name });
	  if (cmd.display === true) cmd.display = { playerTools: true };
	  return cmd;
	}

	var reducer = (0, _createReducer3.default)({}, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, _createStore.ActionTypes.INIT, function (state) {
	  return newInitialState();
	}), (0, _defineProperty3.default)(_createReducer, ADD_COMMAND, function (state, _ref) {
	  var command = _ref.command,
	      name = _ref.name;

	  var cmd = initCommand(command, name);
	  var commands = state.get('all');
	  commands[name] = cmd;
	  var newState = state.updateIn(['allCommands'], (0, _immutable.List)(), function (list) {
	    return list.push(name);
	  });
	  if (cmd.tool) newState = newState.updateIn(['tools'], (0, _immutable.List)(), function (list) {
	    return list.push(name);
	  });
	  return newState;
	}), (0, _defineProperty3.default)(_createReducer, REMOVE_COMMAND, function (state, commandName) {
	  var commands = state.get('all');
	  delete commands[commandName];
	  var idx = state.getIn(['tools']).indexOf(commandName);
	  var idx2 = state.getIn(['allCommands']).indexOf(commandName);
	  return state.deleteIn(['tools', idx]).deleteIn(['allCommands', idx2]);
	  // FIXME: remove from commands/widgets
	}), (0, _defineProperty3.default)(_createReducer, UPDATE_COMMAND, function (state, _ref2) {
	  var name = _ref2.name,
	      opts = _ref2.opts;

	  var command = state.get('all')[name];
	  if (command) (0, _assign2.default)(command, opts);
	  return state;
	}), (0, _defineProperty3.default)(_createReducer, UPDATE_COMMAND_OPTIONS, function (state, _ref3) {
	  var name = _ref3.name,
	      opts = _ref3.opts;

	  var command = state.get('all')[name];
	  if (command) (0, _assign2.default)(command.options, opts);
	  return state;
	}), _createReducer));

	/**
	 * Add a command
	 *
	 * @public
	 * @param {Command} command Command to be added
	 * @param {String} name provide a name for the tool to allow removing it.
	 * @returns {Promise}
	 *
	 */
	function addCommand(command, name) {
	  return { type: ADD_COMMAND, payload: { command: command, name: name } };
	}

	/**
	 * Remove a command
	 *
	 * @public
	 * @param {String} name The name of the command to remove
	 * @returns {Promise}
	 */
	function removeCommand(commandName) {
	  return { type: REMOVE_COMMAND, payload: commandName };
	}

	/**
	 * Updates Atributes of Command
	 *
	 * @public
	 * @param {String} name The name of the command to be updated
	 * @param {Object} opts Attributes to set in the command
	 * @returns {Promise}
	 *
	 */
	function updateCommand(name, opts) {
	  return { type: UPDATE_COMMAND, payload: { name: name, opts: opts } };
	}

	/**
	 * Updates Options object of Command
	 *
	 * @public
	 * @param {String} name The name of the command to be updated
	 * @param {Object} opts Options to be set in the command
	 * @returns {Promise}
	 *
	 */
	function setCommandOptions(name, opts) {
	  return { type: UPDATE_COMMAND_OPTIONS, payload: { name: name, opts: opts } };
	}

	function getTools(store) {
	  return store.getIn(['commands', 'tools']);
	}

	function getCommands(store, displayLocation) {
	  var commands = store.getIn(['commands', 'all']);
	  return !displayLocation ? commands : (0, _ramda.reduce)(function (cmds, key) {
	    var cmd = commands[key];
	    if (cmd.enabled && cmd.display[displayLocation]) cmds[key] = cmd;
	    return cmds;
	  }, {}, (0, _keys2.default)(commands));
	}

	function _isCommandActive(store, command) {
	  if (command.active) return true;
	  if (command.isActive) return command.isActive(store);
	  return false;
	}

	function isCommandActive(store, commandName) {
	  var command = store.getIn(['commands', 'all'])[commandName];
	  return command && _isCommandActive(store, command);
	}

	function getActiveCommandsWithWidgets(store) {
	  var commands = getCommands(store);
	  var result = {};
	  (0, _values2.default)(commands).forEach(function (command) {
	    if (command.widget && _isCommandActive(store, command)) result[command.name] = command;
	  });
	  return result;
	}

	function activateCommand(commandName) {
	  return function (store) {
	    var tools = getTools(store);
	    var commands = getCommands(store);
	    var command = commands[commandName];

	    if (command.activate) {
	      if (!_isCommandActive(store, command)) {
	        command.activate.call(command);
	        store.dispatch(updateCommand(commandName, { active: true }));
	      }
	    } else {
	      tools.forEach(function (toolName) {
	        var command = commands[toolName];
	        if (command.active && command.name !== commandName) {
	          store.dispatch(updateCommand(command.name, { active: false }));
	        }

	        if (command.name === commandName) {
	          store.dispatch(updateCommand(command.name, { active: true }));
	        }
	      });
	    }
	  };
	}

	function deactivateCommand(commandName) {
	  return function (store) {
	    var commands = getCommands(store);
	    var command = commands[commandName];
	    if (!command) return;

	    if (command.active) store.dispatch(updateCommand(command.name, { active: false }));
	    if (command.deactivate) command.deactivate.call(command);
	  };
	}

	/**
	 * Executes, Activates/Deactivates, or makes Command Active
	 *
	 * @public
	 * @param {String} commandName The name of the command to be run
	 * @returns {Promise}
	 *
	 */
	function runCommand(commandName) {
	  return function (store) {
	    var command = store.getIn(['commands', 'all'])[commandName];
	    if (!command || !command.enabled) return;

	    if (command.execute) return command.execute(store);
	    var isActive = _isCommandActive(store, command);
	    if (command.deactivate && isActive) return store.dispatch(deactivateCommand(commandName));
	    return store.dispatch(activateCommand(commandName));
	  };
	}

	/**
	 * Updates multiple commands with given Attributes
	 *
	 * @public
	 * @param {String} commandList The name of the command to be run
	 * @params {Object} attrs Attributes to be set in the command
	 * @returns {Promise}
	 *
	 */
	function updateCommands(commandList, attrs) {
	  return function (store) {
	    commandList.forEach(function (name) {
	      store.dispatch(updateCommand(name, attrs));
	    });
	  };
	}

	/**
	 * Return a Map with the command commands.
	 *
	 * @private
	 */
	// export function getcommands(store) {
	//   return store.get(['commands']).map((command) => command.get('command'));
	// }

	var publicApi = {
	  reducer: reducer,
	  actions: { activateCommand: activateCommand, addCommand: addCommand, deactivateCommand: deactivateCommand, runCommand: runCommand, setCommandOptions: setCommandOptions, updateCommand: updateCommand, updateCommands: updateCommands, removeCommand: removeCommand },
	  selectors: {}
	};

	exports.default = publicApi;

/***/ },
/* 306 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/object/values.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/values */ 307), __esModule: true };

/***/ },
/* 307 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/values.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es7.object.values */ 308);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.values;

/***/ },
/* 308 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es7.object.values.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(/*! ./_export */ 11)
	  , $values = __webpack_require__(/*! ./_object-to-array */ 309)(false);

	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 309 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-to-array.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(/*! ./_object-keys */ 32)
	  , toIObject = __webpack_require__(/*! ./_to-iobject */ 34)
	  , isEnum    = __webpack_require__(/*! ./_object-pie */ 61).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 310 */
/*!********************************!*\
  !*** ./src/modules/plugins.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 97);

	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _createReducer;

	exports.get = get;
	exports.setApi = setApi;
	exports.getSetupCommand = getSetupCommand;

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 143);

	var _createReducer3 = _interopRequireDefault(_createReducer2);

	var _rsvp = __webpack_require__(/*! rsvp */ 106);

	var _rsvp2 = _interopRequireDefault(_rsvp);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Plugins: loading, running
	 *
	 * @module plugins
	 * @private
	 */

	var SET_API = 'SET_API';
	var LOAD_PLUGIN = 'LOAD_PLUGIN';
	var LOADING_PLUGIN = 'LOADING_PLUGIN';
	var LOADED_PLUGIN = 'LOADED_PLUGIN';
	var SET_PLUGIN = 'SET_PLUGIN';
	var LOADING_PLUGIN_ERROR = 'LOADING_PLUGIN_ERROR';

	var initialState = (0, _immutable.Map)({
	  api: null,
	  plugins: (0, _immutable.Map)(),
	  loading: (0, _immutable.Map)()
	});

	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SET_API, function (state, api) {
	  return state.set('api', api);
	}), (0, _defineProperty3.default)(_createReducer, LOADING_PLUGIN, function (state, name) {
	  return state.setIn(['loading', name], true);
	}), (0, _defineProperty3.default)(_createReducer, LOADED_PLUGIN, function (state, name, _ref) {
	  var action = _ref.action;

	  return state.setIn(['loading', name], false);
	}), (0, _defineProperty3.default)(_createReducer, SET_PLUGIN, function (state, _ref2) {
	  var name = _ref2.name,
	      plugin = _ref2.plugin;

	  return state.setIn(['plugins', name], plugin);
	}), _createReducer));

	function initPlugin(store, name, response) {
	  try {
	    var _ret = function () {
	      var buildPluginFn = function buildPluginFn(content) {
	        var fn = new Function('api', content || '');
	        return fn(store.getIn(['plugins', 'api']));
	      };

	      var content = response.content,
	          loadFromServer = response.loadFromServer,
	          url = response.url;

	      if (!loadFromServer) return {
	          v: _promise2.default.resolve(buildPluginFn(content))
	        };

	      console.log('Load plugin from server', url);
	      return {
	        v: new _rsvp2.default.Promise(function (resolve, reject) {
	          store.callApi({
	            types: [LOADING_PLUGIN, LOADED_PLUGIN, LOADING_PLUGIN_ERROR],
	            url: url,
	            payload: name,
	            queryKey: 'PLUGINexternal' + name,
	            contentType: 'external'
	          }).then(function (content) {
	            resolve(buildPluginFn(content));
	          }).catch(function (e) {
	            console.log('Error loading external plugin!', url);
	            resolve({});
	          });
	        })
	      };
	    }();

	    if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
	  } catch (e) {
	    console.log('error', e);
	  }
	};

	function loadPlugin(name) {
	  return function (store) {
	    var sceneId = store.getIn(['sceneIO', 'id']);
	    if (!sceneId) return _promise2.default.reject('No scene attached');

	    var api = store.getIn(['plugins', 'api']);
	    if (api && api[name]) return _promise2.default.resolve(api[name]);

	    return store.callApi({
	      types: [LOADING_PLUGIN, LOADED_PLUGIN, LOADING_PLUGIN_ERROR],
	      url: ("https://editor.vimarket.io/api") + '/scenes/' + sceneId + '/plugins/' + name,
	      payload: name,
	      queryKey: 'PLUGIN' + name
	    }).then(function (response) {
	      return initPlugin(store, name, response).then(function (plugin) {
	        store.dispatch({ type: SET_PLUGIN, payload: { name: name, plugin: plugin } });
	        return plugin;
	      });
	    });
	  };
	}

	function get(store, name) {
	  var plugin = store.getIn(['plugins', 'plugins', name]);
	  return plugin ? _promise2.default.resolve(plugin) : store.dispatch(loadPlugin(name));
	}

	function setApi(api) {
	  return { type: SET_API, payload: api };
	}

	/**
	 * Returns a function that will run the setup command
	 */
	function getSetupCommand(store, cmd, data) {
	  try {
	    var _ret2 = function () {
	      var err = function err(msg) {
	        console.log('Error getting plugin: ' + pluginName);
	        return _promise2.default.resolve(true);
	      };

	      var _cmd$split = cmd.split('/'),
	          _cmd$split2 = (0, _slicedToArray3.default)(_cmd$split, 2),
	          pluginName = _cmd$split2[0],
	          command = _cmd$split2[1];

	      var setupData = typeof data === 'string' ? JSON.parse(data) : data;
	      return {
	        v: function v() {
	          return get(store, pluginName).then(function (plugin) {
	            if (!plugin) return err('Error getting plugin: ' + pluginName);
	            if (!plugin[command]) return err('Unknown command: ' + command + ' for plugin: ' + pluginName);
	            if (typeof plugin[command] !== 'function') return err('Command: ' + command + ' in plugin: ' + pluginName + ' is not a function');

	            if (Array.isArray(setupData)) {
	              return _promise2.default.resolve(plugin[command].apply(plugin, setupData));
	            } else {
	              return _promise2.default.resolve(plugin[command](setupData));
	            }
	          });
	        }
	      };
	    }();

	    if ((typeof _ret2 === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret2)) === "object") return _ret2.v;
	  } catch (e) {
	    return function () {
	      console.error(e);
	    };
	  }
	}

	var publicApi = {
	  reducer: reducer,
	  actions: { loadPlugin: loadPlugin },
	  selectors: { get: get, getSetupCommand: getSetupCommand }
	};

	exports.default = publicApi;

/***/ },
/* 311 */
/*!**************************************!*\
  !*** ./src/modules/configuration.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	exports.executeVariant = executeVariant;
	exports.setOptions = setOptions;
	exports.getOptions = getOptions;
	exports.putOption = putOption;
	exports.putVariant = putVariant;
	exports.removeVariant = removeVariant;
	exports.getVariant = getVariant;

	var _scene = __webpack_require__(/*! ./scene */ 171);

	var _annotations = __webpack_require__(/*! ./annotations */ 294);

	var _player = __webpack_require__(/*! ./player */ 295);

	var _animation = __webpack_require__(/*! ./animation */ 134);

	var _sceneIO = __webpack_require__(/*! ./sceneIO */ 283);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var CONFIG_QUERY = { type: 'Scene', plug: 'Player', property: 'configurator' };
	//let configDetails = null;
	var configDetails = {};

	function set(_ref) {
	  var tags = _ref.tags,
	      value = _ref.value;

	  return (0, _scene.set)(tags, value);
	}

	function show(_ref2) {
	  var tags = _ref2.tags;

	  return function (store) {
	    return _promise2.default.all((0, _scene.filter)(store, tags).map(function (id) {
	      return store.dispatch((0, _scene.set)({ id: id, plug: 'Properties', property: 'visible' }, true));
	    }));
	  };
	}

	function hide(_ref3) {
	  var tags = _ref3.tags;

	  return function (store) {
	    return _promise2.default.all((0, _scene.filter)(store, tags).map(function (id) {
	      return store.dispatch((0, _scene.set)({ id: id, plug: 'Properties', property: 'visible' }, false));
	    }));
	  };
	}

	function setDefaultColor(_ref4) {
	  var tags = _ref4.tags,
	      value = _ref4.value;

	  return function (store) {
	    return _promise2.default.all((0, _scene.filter)(store, tags).map(function (id) {
	      return store.dispatch((0, _scene.set)({ id: id, plug: 'Material', property: 'defaultColor' }, Number(value)));
	    }));
	  };
	}

	function moveCamera(_ref5) {
	  var tags = _ref5.tags;

	  return function (store) {
	    var cameraId = (0, _scene.find)(store, tags);
	    return cameraId ? store.dispatch((0, _player.animateCameraTo)(cameraId, 500)) : _promise2.default.resolve(true);
	  };
	}

	function assignMaterial(_ref6) {
	  var tags = _ref6.tags,
	      value = _ref6.value;

	  return function (store) {
	    var materialId = (0, _scene.get)(store, { name: value, evalPlug: 'Material', property: 'id' });
	    (0, _scene.set)({ name: tags, plug: 'Material', property: 'reference' }, materialId)(store);
	  };
	}

	function playClip(_ref7) {
	  var tags = _ref7.tags;

	  return function (store) {
	    var clips = (0, _animation.getClips)(store).filter(function (clip) {
	      return clip.name === tags;
	    });
	    return _promise2.default.all(clips.map(function (clip) {
	      return store.dispatch((0, _animation.queueClip)(clip.id, { autoplay: true }));
	    }));
	  };
	}

	var availableActions = {
	  show: show,
	  hide: hide,
	  set: set,
	  'assign-material': assignMaterial,
	  'set-default-color': setDefaultColor,
	  'move-camera': moveCamera,
	  'play-clip': playClip
	};

	function executeVariant(optionName, variantName) {
	  return function (store) {
	    var option = getOptions(store)[optionName.trim()];
	    if (!option) {
	      throw new Error('Option: ' + optionName + ' does not exist');
	    }
	    var variant = option[variantName.trim()];
	    if (!variant) {
	      throw new Error('Variant: ' + variantName + ' does not exist within option: ' + optionName);
	    }
	    return _promise2.default.all(variant.map(function (_ref8) {
	      var action = _ref8.action,
	          tags = _ref8.tags,
	          value = _ref8.value;

	      var actionFn = availableActions[action];
	      return actionFn && tags !== '' && store.dispatch(actionFn({ tags: tags, value: value }));
	    }));
	  };
	}

	/**
	 * Add an option to the configurator.
	 *
	 * @private
	 * @param {Option} option Object containing variant(s).
	 * @returns {Promise}
	 *
	 */
	function setOptions(store, options) {
	  var oldOptions = getOptions(store);
	  (0, _assign2.default)(oldOptions, options);
	}

	function getOptions(store) {
	  var sceneId = (0, _sceneIO.getSceneId)(store);
	  if (!configDetails[sceneId]) {
	    (function () {
	      var options = (0, _scene.get)(store, CONFIG_QUERY);
	      try {
	        options = JSON.parse(options);
	      } catch (err) {
	        options = {};
	      }
	      (0, _keys2.default)(options).map(function (op) {
	        var variants = options[op];
	        (0, _keys2.default)(variants).map(function (variant) {
	          if (variants[variant] === null) {
	            variants[variant] = [];
	          }
	        });
	      });
	      configDetails[sceneId] = options;
	    })();
	  }
	  return configDetails[sceneId];
	}

	function putOption(store, name) {
	  var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  var config = getOptions(store);
	  (0, _assign2.default)(config[name], option);
	}

	/**
	 * Add a variant to an option.
	 *
	 * @private
	 * @param {Variant} variant An array of properties.
	 * @returns {Promise}
	 *
	 */
	function putVariant(optionName, variantName) {
	  var variant = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

	  putOption(optionName, (0, _defineProperty3.default)({}, variantName, variant));
	}

	function removeVariant(optionName, variantName) {
	  putOption(optionName, (0, _defineProperty3.default)({}, variantName, undefined));
	}

	function getVariant(store, optionName, variantName) {
	  var options = getOptions(store);
	  return !options || !options[optionName] ? [] : options[variantName];
	}

	var publicApi = {
	  actions: { executeVariant: executeVariant },
	  selectors: { getOptions: getOptions, setOptions: setOptions, putOption: putOption, putVariant: putVariant, removeVariant: removeVariant, getVariant: getVariant }
	};

	exports.default = publicApi;

/***/ },
/* 312 */
/*!**********************************!*\
  !*** ./src/modules/selection.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 138);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _createReducer;

	exports.selectNode = selectNode;
	exports.isSelected = isSelected;
	exports.lastSelectedNode = lastSelectedNode;
	exports.getSelectedNodes = getSelectedNodes;
	exports.deselectAll = deselectAll;
	exports.setHighlighting = setHighlighting;
	exports.isHighlighting = isHighlighting;

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 143);

	var _createReducer3 = _interopRequireDefault(_createReducer2);

	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 281);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SELECT_NODE = 'SELECT_NODE';
	var DESELECT_ALL = 'DESELECT_ALL';
	var SET_HIGHLIGHTING = 'SET_HIGHLIGHTING';

	/**
	 * Controls selection
	 *
	 * @module selection
	 * @public
	 */

	var initialState = (0, _immutable.Map)({
	  nodes: (0, _immutable.List)(),
	  highlightNodes: false
	});

	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SELECT_NODE, function (state, nodeId) {
	  var nodes = state.get('nodes');
	  return state.set('nodes', !nodes.includes(nodeId) ? nodes.clear().push(nodeId) : nodes);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.DELETE_NODE, function (state, nodeId) {
	  var idx = state.get('nodes').indexOf(nodeId);
	  return idx === -1 ? state : state.deleteIn(['nodes', idx]);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state) {
	  return state.set('nodes', state.get('nodes').clear());
	}), (0, _defineProperty3.default)(_createReducer, DESELECT_ALL, function (state) {
	  return state.set('nodes', state.get('nodes').clear());
	}), (0, _defineProperty3.default)(_createReducer, SET_HIGHLIGHTING, function (state, highlight) {
	  return state.set('highlightNodes', highlight);
	}), _createReducer));

	function selectNode(nodeId) {
	  return { type: SELECT_NODE, payload: nodeId };
	};

	function isSelected(store, nodeId) {
	  return store.getIn(['selection', 'nodes']).includes(nodeId);
	};

	function lastSelectedNode(store) {
	  return store.getIn(['selection', 'nodes']).last();
	};

	function getSelectedNodes(store) {
	  return store.getIn(['selection', 'nodes']).toArray();
	};

	function deselectAll() {
	  return { type: DESELECT_ALL };
	};

	function setHighlighting(highlight) {
	  return { type: SET_HIGHLIGHTING, payload: highlight };
	};

	function isHighlighting(store) {
	  return store.getIn(['selection', 'highlightNodes']);
	}

	var publicApi = {
	  reducer: reducer,
	  actions: { selectNode: selectNode, deselectAll: deselectAll, setHighlighting: setHighlighting },
	  selectors: { isSelected: isSelected, lastSelectedNode: lastSelectedNode }
	};
	exports.default = publicApi;

/***/ },
/* 313 */
/*!********************************!*\
  !*** ./src/operators/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _makeAllOperators = __webpack_require__(/*! ./makeAllOperators */ 314);

	var _makeAllOperators2 = _interopRequireDefault(_makeAllOperators);

	var _minimal = __webpack_require__(/*! ./minimal */ 327);

	var _minimal2 = _interopRequireDefault(_minimal);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _minimal2.default;

/***/ },
/* 314 */
/*!*******************************************!*\
  !*** ./src/operators/makeAllOperators.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ 130);

	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

	var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ 315);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ 316);

	var _createClass3 = _interopRequireDefault(_createClass2);

	var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ 317);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _get2 = __webpack_require__(/*! babel-runtime/helpers/get */ 318);

	var _get3 = _interopRequireDefault(_get2);

	var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ 322);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _keys2 = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys3 = _interopRequireDefault(_keys2);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.default = makeAllOperators;

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _schemaTypes = __webpack_require__(/*! ./schemaTypes */ 175);

	var _schemaTypes2 = _interopRequireDefault(_schemaTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function makeAllOperators(hierarchy, _ref) {
	  var withNone = _ref.withNone;

	  var records = (0, _ramda.mapObjIndexed)(function (ops, plug) {
	    return (0, _ramda.mapObjIndexed)(function (op, name) {
	      return makeOperator(plug, op, name);
	    }, ops);
	  }, hierarchy);
	  if (withNone) records.None = { NoOp: makeOperator('None', { schema: {} }, 'NoOp') };
	  return records;
	};

	// export const Operator = Record({type: '', name: '', attributes: null});

	function makeOperator(plug, op, name) {
	  var props = (0, _ramda.map)(function (info, key) {
	    if (_schemaTypes2.default[info.type]) return (0, _assign2.default)({ type: info.type, schema: info }, _schemaTypes2.default[info.type](info));
	    return {
	      set: function set(v) {
	        return v;
	      },
	      get: function get(v) {
	        return v;
	      }
	    };
	  }, op.schema);

	  var _keys = (0, _keys3.default)(props);

	  var defaults = (0, _ramda.map)(function (prop, key) {
	    return prop.defaultValue;
	  }, props);
	  defaults.type = name;
	  defaults.name = name;

	  var references = (0, _ramda.pickBy)(function (prop, key) {
	    return prop.isReference;
	  }, props);
	  var fileReferences = (0, _ramda.pickBy)(function (prop, key) {
	    return prop.isFileReference;
	  }, props);

	  var Operator = function (_Record) {
	    (0, _inherits3.default)(R, _Record);

	    function R() {
	      (0, _classCallCheck3.default)(this, R);
	      return (0, _possibleConstructorReturn3.default)(this, (R.__proto__ || (0, _getPrototypeOf2.default)(R)).apply(this, arguments));
	    }

	    (0, _createClass3.default)(R, [{
	      key: 'keys',
	      value: function keys() {
	        return _keys;
	      }
	    }, {
	      key: 'getProperties',
	      value: function getProperties() {
	        return props;
	      }
	    }, {
	      key: 'getReferences',
	      value: function getReferences() {
	        var _this2 = this;

	        return (0, _immutable.Map)((0, _ramda.pickBy)(function (v) {
	          return !!v;
	        }, (0, _ramda.mapObjIndexed)(function (schema, key) {
	          return _this2.get(key);
	        }, references)));
	      }
	    }, {
	      key: 'getFileReferences',
	      value: function getFileReferences() {
	        var _this3 = this;

	        return (0, _immutable.Map)((0, _ramda.pickBy)(function (v) {
	          return !!v;
	        }, (0, _ramda.mapObjIndexed)(function (schema, key) {
	          return _this3.get(key);
	        }, fileReferences)));
	      }
	    }, {
	      key: 'typeOf',
	      value: function typeOf(key) {
	        return op.schema[key] && op.schema[key].type;
	      }
	    }, {
	      key: 'set',
	      value: function set(key, val) {
	        var newVal = props[key] ? props[key].set(val) : val;
	        return (0, _get3.default)(R.prototype.__proto__ || (0, _getPrototypeOf2.default)(R.prototype), 'set', this).call(this, key, newVal);
	      }
	    }, {
	      key: 'export',
	      value: function _export() {
	        var _this4 = this;

	        var op = (0, _ramda.mapObjIndexed)(function (prop, key) {
	          var v = _this4.get(key);
	          return fileReferences[key] || references[key] ? v ? v.get('id') : null : v;
	        }, props);
	        op.name = name;
	        op.primitive = plug;
	        return op;
	      }
	    }, {
	      key: 'doUpdate',
	      value: function doUpdate(operator, primitive, sceneId) {
	        var result = op.update ? op.update.call(op, operator, primitive, sceneId) : operator.mergeInto(operator, primitive);
	        if (!result) {
	          console.error('Operator not returning its result: ', name, op);
	        }

	        return result || (0, _immutable.Map)();
	      }
	    }], [{
	      key: 'keys',
	      value: function keys() {
	        return _keys;
	      }
	    }]);
	    return R;
	  }((0, _immutable.Record)(defaults, plug + name));
	  return Operator;
	}

/***/ },
/* 315 */
/*!***************************************************!*\
  !*** ./~/babel-runtime/helpers/classCallCheck.js ***!
  \***************************************************/
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 316 */
/*!************************************************!*\
  !*** ./~/babel-runtime/helpers/createClass.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ 139);

	var _defineProperty2 = _interopRequireDefault(_defineProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 317 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _typeof2 = __webpack_require__(/*! ../helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 318 */
/*!****************************************!*\
  !*** ./~/babel-runtime/helpers/get.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _getPrototypeOf = __webpack_require__(/*! ../core-js/object/get-prototype-of */ 130);

	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

	var _getOwnPropertyDescriptor = __webpack_require__(/*! ../core-js/object/get-own-property-descriptor */ 319);

	var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function get(object, property, receiver) {
	  if (object === null) object = Function.prototype;
	  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

	  if (desc === undefined) {
	    var parent = (0, _getPrototypeOf2.default)(object);

	    if (parent === null) {
	      return undefined;
	    } else {
	      return get(parent, property, receiver);
	    }
	  } else if ("value" in desc) {
	    return desc.value;
	  } else {
	    var getter = desc.get;

	    if (getter === undefined) {
	      return undefined;
	    }

	    return getter.call(receiver);
	  }
	};

/***/ },
/* 319 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/core-js/object/get-own-property-descriptor.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-own-property-descriptor */ 320), __esModule: true };

/***/ },
/* 320 */
/*!************************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/get-own-property-descriptor.js ***!
  \************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.get-own-property-descriptor */ 321);
	var $Object = __webpack_require__(/*! ../../modules/_core */ 13).Object;
	module.exports = function getOwnPropertyDescriptor(it, key){
	  return $Object.getOwnPropertyDescriptor(it, key);
	};

/***/ },
/* 321 */
/*!*********************************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.get-own-property-descriptor.js ***!
  \*********************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(/*! ./_to-iobject */ 34)
	  , $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ 126).f;

	__webpack_require__(/*! ./_object-sap */ 133)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 322 */
/*!*********************************************!*\
  !*** ./~/babel-runtime/helpers/inherits.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _setPrototypeOf = __webpack_require__(/*! ../core-js/object/set-prototype-of */ 323);

	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

	var _create = __webpack_require__(/*! ../core-js/object/create */ 188);

	var _create2 = _interopRequireDefault(_create);

	var _typeof2 = __webpack_require__(/*! ../helpers/typeof */ 112);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }

	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 323 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/core-js/object/set-prototype-of.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/set-prototype-of */ 324), __esModule: true };

/***/ },
/* 324 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/set-prototype-of.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.set-prototype-of */ 325);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.setPrototypeOf;

/***/ },
/* 325 */
/*!**********************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.set-prototype-of.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(/*! ./_export */ 11);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(/*! ./_set-proto */ 326).set});

/***/ },
/* 326 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_set-proto.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , anObject = __webpack_require__(/*! ./_an-object */ 18);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(/*! ./_ctx */ 14)(Function.call, __webpack_require__(/*! ./_object-gopd */ 126).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 327 */
/*!**********************************!*\
  !*** ./src/operators/minimal.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _makeAllOperators = __webpack_require__(/*! ./makeAllOperators */ 314);

	var _makeAllOperators2 = _interopRequireDefault(_makeAllOperators);

	var _Annotation = __webpack_require__(/*! ./Annotation */ 180);

	var _Annotation2 = _interopRequireDefault(_Annotation);

	var _BinMesh = __webpack_require__(/*! ./BinMesh */ 181);

	var _BinMesh2 = _interopRequireDefault(_BinMesh);

	var _Camera = __webpack_require__(/*! ./Camera */ 224);

	var _Camera2 = _interopRequireDefault(_Camera);

	var _Environment = __webpack_require__(/*! ./Environment */ 225);

	var _Environment2 = _interopRequireDefault(_Environment);

	var _Image = __webpack_require__(/*! ./Image */ 227);

	var _Image2 = _interopRequireDefault(_Image);

	var _Light = __webpack_require__(/*! ./Light */ 230);

	var _Light2 = _interopRequireDefault(_Light);

	var _Material = __webpack_require__(/*! ./Material */ 231);

	var _Material2 = _interopRequireDefault(_Material);

	var _Player = __webpack_require__(/*! ./Player */ 233);

	var _Player2 = _interopRequireDefault(_Player);

	var _PolyMesh = __webpack_require__(/*! ./PolyMesh */ 234);

	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

	var _Properties = __webpack_require__(/*! ./Properties */ 278);

	var _Properties2 = _interopRequireDefault(_Properties);

	var _Transform = __webpack_require__(/*! ./Transform */ 280);

	var _Transform2 = _interopRequireDefault(_Transform);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var NoOp = { schema: {} };

	var Bone = { Bone: NoOp };
	var Null = { Null: NoOp };
	var Pass = { Pass: NoOp };
	var Mixer = { Action: NoOp, Mixer: NoOp };
	var Renderer = { 'vray/create': NoOp, WebGLRenderer: NoOp };
	var Timeline = { Timeline: NoOp };
	var GeneralRenderer = { GeneralRenderer: NoOp };
	var Viewport = { Viewport: NoOp };

	var records = (0, _makeAllOperators2.default)({
	  Annotation: _Annotation2.default, BinMesh: _BinMesh2.default, Bone: Bone, Camera: _Camera2.default, Environment: _Environment2.default, GeneralRenderer: GeneralRenderer, Light: _Light2.default, Material: _Material2.default,
	  Mixer: Mixer, Null: Null, Pass: Pass, Player: _Player2.default, PolyMesh: _PolyMesh2.default, Properties: _Properties2.default,
	  Renderer: Renderer, Timeline: Timeline, Transform: _Transform2.default, Image: _Image2.default, Viewport: Viewport
	}, { withNone: true });

	exports.default = records;

/***/ },
/* 328 */
/*!*************************************!*\
  !*** ./src/operators/primitives.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Color = exports.Vec3 = exports.Vec2 = exports.OperatorReference = exports.PlugReference = exports.NodeReference = exports.FileReference = undefined;

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var FileReference = exports.FileReference = (0, _immutable.Record)({ id: '' }, 'FileReference');
	var NodeReference = exports.NodeReference = (0, _immutable.Record)({ id: '' }, 'NodeReference');
	var PlugReference = exports.PlugReference = (0, _immutable.Record)({ id: '', plug: '' }, 'PlugReference');
	var OperatorReference = exports.OperatorReference = (0, _immutable.Record)({ id: '', plug: '', index: 0 }, 'OperatorReference');

	var Vec2 = exports.Vec2 = (0, _immutable.Record)({ x: 0, y: 0 }, 'Vec2');
	var Vec3 = exports.Vec3 = (0, _immutable.Record)({ x: 0, y: 0, z: 0 }, 'Vec3');
	var Color = exports.Color = (0, _immutable.Record)({ r: 0, g: 0, b: 0 }, 'Color');

	exports.default = {
	  FileReference: FileReference, NodeReference: NodeReference, PlugReference: PlugReference, OperatorReference: OperatorReference,
	  Vec2: Vec2, Vec3: Vec3, Color: Color
	};

/***/ },
/* 329 */
/*!****************************!*\
  !*** ./src/store/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ 2);

	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

	exports.default = buildStore;

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _createReducer = __webpack_require__(/*! ./createReducer */ 330);

	var _createReducer2 = _interopRequireDefault(_createReducer);

	var _applyMiddleware = __webpack_require__(/*! ./applyMiddleware */ 331);

	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

	var _createStore = __webpack_require__(/*! ./createStore */ 284);

	var _createStore2 = _interopRequireDefault(_createStore);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function buildStore(reducers, operatorRecords, primitives, middleware) {
	  var reducer = (0, _createReducer2.default)(reducers, operatorRecords);
	  var records = (0, _ramda.chain)(_ramda.values, (0, _ramda.values)(operatorRecords)).concat((0, _ramda.values)(primitives));
	  var store = (0, _createStore2.default)(reducer, _applyMiddleware2.default.apply(undefined, (0, _toConsumableArray3.default)(middleware)));
	  store.addRecords(records);
	  return store;
	}

/***/ },
/* 330 */
/*!************************************!*\
  !*** ./src/store/createReducer.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	exports.default = function (reducers, operatorRecords) {
	  var keys = (0, _keys2.default)(reducers);

	  var defaultState = (0, _ramda.reduce)(function (state, key) {
	    return state.set(key, reducers[key]());
	  }, (0, _immutable.Map)(), keys);

	  return function reducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;
	    var action = arguments[1];
	    var createEvent = arguments[2];

	    return (0, _ramda.reduce)(function (state, key) {
	      var previousStateForKey = state.get(key);
	      var nextStateForKey = reducers[key](previousStateForKey, action, state, createEvent);
	      if (false) {
	        if (!nextStateForKey) {
	          throw new Error('Reducer: ' + key + ' failed to return state');
	        }
	      }

	      return (0, _immutable.is)(previousStateForKey, nextStateForKey) ? state : state.set(key, nextStateForKey);
	    }, state, keys);
	  };
	};

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	;

/***/ },
/* 331 */
/*!**************************************!*\
  !*** ./src/store/applyMiddleware.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ 2);

	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

	exports.default = applyMiddleware;

	var _ramda = __webpack_require__(/*! ramda */ 78);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }

	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;

	      var chain = [];

	      var middlewareAPI = {
	        get: store.get,
	        getIn: store.getIn,
	        getState: store.getState,
	        getTranslator: store.getTranslator,
	        getDerived: store.getDerived,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        },
	        read: store.read,
	        write: store.write,
	        hasApi: store.hasApi,
	        callApi: store.callApi,
	        logPageView: store.logPageView,
	        error: store.error
	      };

	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _ramda.compose.apply(undefined, (0, _toConsumableArray3.default)(chain))(store.dispatch);

	      return (0, _assign2.default)({}, store, { dispatch: _dispatch });
	    };
	  };
	}

/***/ },
/* 332 */
/*!*****************************************************!*\
  !*** ./src/store/bindActionCreatorsAndSelectors.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.default = bindActionCreatorsAndSelectors;

	var _ramda = __webpack_require__(/*! ramda */ 78);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function bindActionCreators(dispatch, actionCreators) {
	  return (0, _ramda.map)(function (actionCreator) {
	    return function () {
	      return dispatch(actionCreator.apply(undefined, arguments));
	    };
	  }, actionCreators);
	};

	function bindSelectors(store, selectors) {
	  return (0, _ramda.map)(function (selector) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return selector.apply(undefined, [store].concat(args));
	    };
	  }, selectors);
	};

	/**
	 * Iterate over modules,
	 */
	function bindActionCreatorsAndSelectors(store, modules) {
	  return (0, _ramda.map)(function (module) {
	    return (0, _assign2.default)({}, bindActionCreators(store.dispatch, module.actions), bindSelectors(store, module.selectors));
	  }, modules);
	};

/***/ },
/* 333 */,
/* 334 */
/*!**********************************!*\
  !*** ./src/components/styles.js ***!
  \**********************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var headerFont = '-apple-system,".SFNSDisplay-Bold","Helvetica Neue","Roboto","Segoe UI",sans-serif';
	var bodyFont = "'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', Verdana, Tahoma, sans-serif";
	var colors = {
	  gray: '#999',
	  black: '#333',
	  lightBg: '#eee',
	  border: '#ccc',
	  white: '#fff'
	};

	exports.default = {
	  root: {
	    height: '100%',
	    fontSize: '14px',
	    fontFamily: bodyFont,
	    position: 'absolute',
	    top: 0, left: 0, right: 0, bottom: 0
	  },
	  absoluteMaxCentered: {
	    position: 'absolute',
	    top: 0, left: 0, right: 0, bottom: 0,
	    display: 'flex',
	    alignItems: 'center',
	    justifyContent: 'center'
	  },
	  header: {
	    display: 'flex',
	    flex: '0 0 auto',
	    justifyContent: 'center',
	    margin: '0',
	    backgroundColor: colors.lightBg,
	    fontFamily: headerFont
	  },
	  mainRow: {
	    display: 'flex',
	    flex: '1 1 100px',
	    justifyContent: 'center'
	  },
	  commandsRow: {
	    flex: '0 0 auto'
	  },
	  statsRow: {
	    flex: '0 0 auto',
	    backgroundColor: colors.gray,
	    color: colors.lightBg,
	    padding: '5px'
	  },
	  player: {
	    position: 'relative',
	    top: 0, left: 0, right: 0, bottom: 0,
	    height: '100%',
	    width: '100%'
	  },
	  maxRow: {
	    flex: '1 1 auto'
	  },
	  leftCol: {
	    flex: '1 1 200px',
	    maxWidth: '300px',
	    overflow: 'scroll'
	  },
	  centerCol: {
	    flex: '2 2 500px',
	    border: '1px solid ' + colors.border
	  },
	  rightCol: {
	    flex: '1 1 200px',
	    maxWidth: '300px',
	    overflow: 'scroll'
	  },
	  footer: {
	    flex: '0 0 auto',
	    padding: '5px',
	    backgroundColor: colors.lightBg,
	    margin: '0'
	  },
	  explorerSelected: {
	    backgroundColor: colors.gray
	  },
	  explorerNotSelected: {
	    backgroundColor: colors.white,
	    cursor: 'pointer'
	  }
	};

/***/ },
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */
/*!*********************************!*\
  !*** ./src/components/error.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = error;

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _styles = __webpack_require__(/*! ./styles */ 334);

	var _styles2 = _interopRequireDefault(_styles);

	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 283);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function error(store) {
	  return (0, _h2.default)('div', { key: 'error', style: _styles2.default.absoluteMaxCentered }, [(0, _h2.default)('div', { style: { flex: '0 0 100%' } }, (0, _sceneIO.getErrors)(store).map(function (err) {
	    return (0, _h2.default)('h2', err);
	  }).toArray())]);
	};

/***/ },
/* 345 */
/*!************************************!*\
  !*** ./src/components/progress.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 346);

	var _extends3 = _interopRequireDefault(_extends2);

	exports.default = progress;

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	var _styles = __webpack_require__(/*! ./styles */ 334);

	var _styles2 = _interopRequireDefault(_styles);

	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 283);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var stats = statsReporter();

	function statsReporter() {
	  var pageLoadTime, toRenderedTime;
	  if (typeof performace === 'undefined') return function () {};

	  return function (store, pct) {
	    if (pageLoadTime && toRenderedTime) return;
	    if (!pageLoadTime) pageLoadTime = new Date().getTime() - performance.timing.navigationStart;
	    if (pct < 1) return;
	    toRenderedTime = new Date().getTime() - performance.timing.navigationStart;
	    console.log('Page loaded in ' + pageLoadTime + 'ms and rendered in ' + toRenderedTime + 'ms');
	  };
	};

	//
	var spinnerColor = '#646766';

	var circleDiv = {
	  flex: '0 0 25%'
	};

	var r = 90;
	var PIR2 = Math.PI * r * 2;

	var outer = {
	  r: r, cx: 100, cy: 100,
	  fill: 'transparent',
	  'stroke-dasharray': PIR2,
	  'stroke-dashoffset': 0,
	  'stroke-width': '1em',
	  stroke: '#eee'
	};
	var inner = {
	  r: r, cx: 100, cy: 100,
	  fill: 'transparent',
	  stroke: spinnerColor,
	  transition: 'stroke-dashoffset 1s linear',
	  'stroke-width': '1em',
	  'stroke-dashoffset': PIR2,
	  'stroke-dasharray': PIR2
	};
	var svg = {
	  height: '100%',
	  width: '100%',
	  viewport: '0 0 100 100',
	  viewBox: '0 0 200 200'
	};

	function progress(store) {
	  var pct = (0, _sceneIO.loadingProgress)(store);
	  var degrees = PIR2 * (1 - pct);
	  stats(store, pct);

	  return (0, _h2.default)('div', { style: (0, _extends3.default)({}, _styles2.default.absoluteMaxCentered, { backgroundColor: 'transparent', boxSizing: 'border-box' }) }, [(0, _h2.default)('div', { style: circleDiv }, [(0, _h2.default)('svg', { attrs: svg }, [(0, _h2.default)('circle', { attrs: outer }), (0, _h2.default)('circle', { props: { id: 'bar' }, attrs: (0, _extends3.default)({}, inner, { 'stroke-dashoffset': degrees }) })])])]);
	}

/***/ },
/* 346 */
/*!********************************************!*\
  !*** ./~/babel-runtime/helpers/extends.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _assign = __webpack_require__(/*! ../core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

/***/ },
/* 347 */
/*!**********************************!*\
  !*** ./src/components/canvas.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _values = __webpack_require__(/*! babel-runtime/core-js/object/values */ 306);

	var _values2 = _interopRequireDefault(_values);

	exports.default = canvas;

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _annotation = __webpack_require__(/*! ./annotation */ 348);

	var _annotation2 = _interopRequireDefault(_annotation);

	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 283);

	var _annotations = __webpack_require__(/*! ../modules/annotations */ 294);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var attachTranslator = function attachTranslator(store, translator) {
	  return function (info) {
	    translator.attach(info.elm);

	    function onResize() {
	      translator.resize();
	    }

	    window.addEventListener('resize', onResize);
	  };
	};

	function ignoreRightClick(ev) {
	  ev.preventDefault();
	};

	function canvas(store) {
	  var translator = store.getTranslator();
	  var rendered = (0, _sceneIO.isSceneRendered)(store);

	  translator.update();

	  var annotationFn = (0, _annotations.getCustomAnnotationFunction)(store);

	  var annotations = (0, _ramda.filter)(function (a) {
	    return !!a;
	  }, (0, _ramda.map)(function (obj) {
	    return (0, _annotation.getAnnotationProperties)(store, obj);
	  }, (0, _values2.default)(translator.getAnnotations())));

	  function callCustomAnnotationFn(vnode) {
	    annotations.forEach(function (annotation) {
	      return annotationFn(annotation, vnode.elm);
	    });
	  }

	  var children = annotationFn ? [(0, _h2.default)('div.annotations', {
	    style: { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, pointerEvents: 'none' },
	    hook: {
	      insert: callCustomAnnotationFn,
	      update: callCustomAnnotationFn
	    }
	  })] : (0, _ramda.map)((0, _annotation2.default)(store), annotations);

	  return (0, _h2.default)('div', {
	    style: { position: 'relative', display: rendered ? 'block' : 'none' },
	    on: { contextmenu: ignoreRightClick },
	    hook: { insert: attachTranslator(store, translator) }
	  }, children);
	};

/***/ },
/* 348 */
/*!**************************************!*\
  !*** ./src/components/annotation.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 346);

	var _extends3 = _interopRequireDefault(_extends2);

	exports.getAnnotationProperties = getAnnotationProperties;

	exports.default = function (store) {
	  var rect = (0, _player.getRect)(store);
	  var compact = (0, _ramda.filter)(function (n) {
	    return n;
	  });

	  return function (annotation) {
	    var id = annotation.id,
	        text = annotation.text,
	        left = annotation.left,
	        bottom = annotation.bottom,
	        visible = annotation.visible,
	        position = annotation.position,
	        normal = annotation.normal,
	        alpha = annotation.alpha; //data.position(store);

	    if (position === undefined) return (0, _h2.default)('span');

	    var state = store.getIn(['annotations', id]) || (0, _immutable.Map)({ open: annotation.open, pinned: annotation.open });
	    var open = state.get('open');
	    var pinned = state.get('pinned');

	    var tb = position.y > 0.5 ? 't' : 'b';
	    var lr = position.x < 0.6 ? 'l' : 'r';
	    var side = [tb, lr].join('');

	    function click(ev) {
	      ev.preventDefault();
	      store.dispatch((0, _annotations.setAnnotationProperties)(id, {
	        open: !pinned ? true : !open,
	        pinned: !pinned
	      }));
	    }

	    function mouseover(ev) {
	      if (!pinned) store.dispatch((0, _annotations.setAnnotationProperties)(id, { open: true }));
	    }

	    function mouseout(ev) {
	      if (!pinned) store.dispatch((0, _annotations.setAnnotationProperties)(id, { open: false }));
	    };

	    var children = [(0, _h2.default)('img', { style: { cursor: 'pointer' }, props: {
	        width: 24,
	        height: 24,
	        src: ("https://editor.vimarket.io") + '/img/annotation-' + (open ? 'open' : 'closed') + '-2.svg'
	      } })];

	    if (open) {
	      var textCss = {
	        fontSize: '12px', padding: '10px', color: '#fff', backgroundColor: '#000',
	        borderRadius: '3px', opacity: '0.8', cursor: 'pointer', lineHeight: 1.3,
	        width: text.length > 10 ? text.length > 50 ? '200px' : '150px' : '100px'
	      };

	      children.push((0, _h2.default)('div', { style: popupCsses[side] }, compact([lr === 'l' && (0, _h2.default)('div', { key: side, style: arrows[side] }), (0, _h2.default)('div', { key: 'text', style: textCss, on: { click: click } }, text), lr === 'r' && (0, _h2.default)('div', { key: side, style: arrows[side] })])));
	    }

	    return (0, _h2.default)('div', {
	      key: id,
	      style: {
	        visibility: visible ? 'visible' : 'hidden',
	        opacity: alpha,
	        position: 'absolute',
	        left: Math.round(left) + 'px',
	        bottom: Math.round(bottom) + 'px'
	      },
	      on: { click: click, mouseover: mouseover, mouseout: mouseout }
	    }, children);
	  };
	};

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _player = __webpack_require__(/*! ../modules/player */ 295);

	var _annotations = __webpack_require__(/*! ../modules/annotations */ 294);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var imgStyle = { cursor: 'pointer' };

	var initialAnnotationState = (0, _immutable.Map)({ open: false, pinned: false });

	var bs = '5px solid #333';
	var bi = '5px solid transparent';

	var arrowCss = {
	  position: 'absolute',
	  display: 'inline-block',
	  borderTop: bi, borderLeft: bi, borderRight: bi, borderBottom: bi,
	  height: 0,
	  width: 0,
	  top: '', bottom: '', right: '', left: ''
	};

	var arrows = {
	  tl: (0, _extends3.default)({}, arrowCss, { borderRight: bs, top: '12px', left: '-10px', marginTop: '-5px' }),
	  bl: (0, _extends3.default)({}, arrowCss, { borderRight: bs, bottom: '8px', left: '-10px', marginTop: '-5px' }),
	  tr: (0, _extends3.default)({}, arrowCss, { borderLeft: bs, top: '12px', right: '-10px', marginTop: '-5px' }),
	  br: (0, _extends3.default)({}, arrowCss, { borderLeft: bs, bottom: '8px', right: '-10px', marginTop: '-5px' })
	};

	var popupCss = { position: 'absolute', textAlign: 'left',
	  left: '', top: '', bottom: '', right: '',
	  transition: 'opacity 0.3s ease-out', webkitTransition: 'opacity 0.3s ease-out',
	  fontFamily: 'sans-serif', delayed: { opacity: 1 }, remove: { opacity: 0 }
	};

	var popupCsses = {
	  tl: (0, _extends3.default)({}, popupCss, { left: '30px', top: '0' }),
	  bl: (0, _extends3.default)({}, popupCss, { left: '30px', bottom: '0' }),
	  tr: (0, _extends3.default)({}, popupCss, { right: '30px', top: '0' }),
	  br: (0, _extends3.default)({}, popupCss, { right: '30px', bottom: '0' })
	};

	function getAnnotationProperties(store, data) {
	  var rect = (0, _player.getRect)(store);

	  var _data$position = data.position(store),
	      position = _data$position.position,
	      normal = _data$position.normal,
	      alpha = _data$position.alpha;

	  if (!position) return false;

	  var left = rect.width * position.x;
	  var bottom = rect.height * position.y;
	  var visible = !(left < 0 || left > rect.width - 24 || bottom < 0 || bottom > rect.height - 24) && data.visible;

	  return (0, _extends3.default)({}, data.annotation, {
	    id: data.id,
	    alpha: alpha,
	    normal: normal,
	    position: position,
	    top: rect.height - bottom,
	    right: rect.width - left,
	    bottom: bottom,
	    left: left,
	    visible: visible
	  });
	};

/***/ },
/* 349 */
/*!********************************************!*\
  !*** ./src/components/manipulatorTools.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	exports.hoverStyle = hoverStyle;
	exports.default = manipulatorTools;

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _icons = __webpack_require__(/*! ./icons */ 350);

	var svgIcons = _interopRequireWildcard(_icons);

	var _player = __webpack_require__(/*! ../modules/player */ 295);

	var _commands = __webpack_require__(/*! ../modules/commands */ 305);

	var _timeline = __webpack_require__(/*! ./timeline */ 351);

	var _timeline2 = _interopRequireDefault(_timeline);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var isTouch = (true) && (!!('ontouchstart' in window) || window.navigator.msMaxTouchPoints > 0);

	function hoverStyle(store) {
	  var hoverColor = (0, _player.getHoverColor)(store);

	  var hoverStyle = isTouch ? '' : '\ndiv.claraplayer ul.tools li:not(.active):hover svg path {\n  fill: ' + hoverColor + ';\n}\n';
	  return (0, _h2.default)('style', { props: { innerHTML: hoverStyle } });
	}

	function manipulatorTools(store) {
	  var tools = (0, _commands.getCommands)(store, 'playerTools');
	  var activeColor = (0, _player.getActiveColor)(store);

	  function click(what) {
	    return function (ev) {
	      store.dispatch((0, _commands.runCommand)(what));
	      var canvas = (0, _player.getCanvasElement)(store);
	      if (canvas) canvas.focus();
	    };
	  }

	  var toolChildren = [hoverStyle(store), (0, _h2.default)('ul.tools', { style: {
	      position: 'relative',
	      bottom: 0,
	      left: 0,
	      listStyleType: 'none',
	      padding: '0 5px',
	      margin: 0,
	      zIndex: 2147483647
	    } }, [svgIcons.glowFilter()].concat((0, _ramda.map)(function (key) {
	    var command = tools[key];
	    var active = command.isActive ? command.isActive(store) : command.active;
	    var label = command.active && command.activeLabel ? command.activeLabel : command.label;
	    var svgIcon = svgIcons[command.options.icon || key];
	    var iconChildren = [];

	    if (typeof svgIcon === 'function') {
	      iconChildren.push(svgIcon({ width: 34, height: 34, title: label }, { active: active, activeColor: activeColor }));
	    } else {
	      iconChildren.push((0, _h2.default)('span', { style: { color: active ? activeColor : '#fff' } }, label));
	    }

	    return (0, _h2.default)('li' + (active ? '.active' : ''), {
	      attrs: { title: label },
	      on: { click: click(key) },
	      style: {
	        cursor: 'pointer',
	        float: 'left',
	        borderRadius: '5px',
	        padding: '5px',
	        boxSizing: 'border-box'
	      }
	    }, iconChildren);
	  }, (0, _keys2.default)(tools))))];

	  var tLine = (0, _timeline2.default)(store);
	  if (tLine) toolChildren.push(tLine);

	  return (0, _h2.default)('span', { style: {
	      position: 'absolute',
	      left: '5px',
	      right: '5px',
	      bottom: '5px',
	      display: 'flex',
	      flexWrap: 'nowrap',
	      height: '54px'
	    } }, toolChildren);
	};

/***/ },
/* 350 */
/*!*********************************!*\
  !*** ./src/components/icons.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 346);

	var _extends3 = _interopRequireDefault(_extends2);

	exports.glowFilter = glowFilter;
	exports.home = home;
	exports.orbit = orbit;
	exports.pan = pan;
	exports.zoom = zoom;
	exports.fullscreen = fullscreen;
	exports.vrMode = vrMode;
	exports.lenticularMode = lenticularMode;
	exports.deviceTracking = deviceTracking;
	exports.nodeRotate = nodeRotate;
	exports.nodeMove = nodeMove;
	exports.nodeScale = nodeScale;
	exports.pause = pause;
	exports.play = play;
	exports.select = select;

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var filter = 'url(#glowfilter)';
	var activeColor = '#ffc85f';
	var blurColor = '#000';
	var color = '#fff';
	var padding = '0';
	var boxSizing = 'border-box';
	var viewBox = '-300 -300 1624 1624';
	var panViewBox = '-150 -150 812 812';

	function glowFilter() {
	  return (0, _h2.default)('svg', { attrs: { width: 0, height: 0 } }, [(0, _h2.default)('filter', { attrs: { id: 'glowfilter' } }, [(0, _h2.default)('feGaussianBlur', { attrs: { in: 'SourceAlpha', stdDeviation: 50, result: 'blur' } }), (0, _h2.default)('feOffset', { attrs: { in: 'blur', dx: 0, dy: 0, result: 'offsetBlur' } }), (0, _h2.default)('feFlood', { attrs: { 'flood-color': blurColor, 'flood-opacity': 1, result: 'offsetColor' } }), (0, _h2.default)('feComposite', { attrs: { in: 'offsetColor', in2: 'offsetBlur', operator: 'in', result: 'offsetBlurComposed' } }), (0, _h2.default)('feMerge', [(0, _h2.default)('feMergeNode', { attrs: { in: 'offsetBlurComposed' } }), (0, _h2.default)('feMergeNode', { attrs: { in: 'SourceGraphic' } })])])]);
	}

	// icomoon free svg icons

	function home(attrs, options) {
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [
	  //blurFilter('homefilter'),
	  (0, _h2.default)('path', { attrs: { fill: color, filter: filter, d: 'M1024 608l-192-192v-288h-128v160l-192-192-512 512v32h128v320h320v-192h128v192h320v-320h128z' } })]);
	};

	function orbit(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M1024 384h-384l143.53-143.53c-72.53-72.526-168.96-112.47-271.53-112.47s-199 39.944-271.53 112.47c-72.526 72.53-112.47 168.96-112.47 271.53s39.944 199 112.47 271.53c72.53 72.526 168.96 112.47 271.53 112.47s199-39.944 271.528-112.472c6.056-6.054 11.86-12.292 17.456-18.668l96.32 84.282c-93.846 107.166-231.664 174.858-385.304 174.858-282.77 0-512-229.23-512-512s229.23-512 512-512c141.386 0 269.368 57.326 362.016 149.984l149.984-149.984v384z' } })]);
	}

	function pan(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: panViewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('g', { attrs: { transform: 'matrix(0.49680763,0.49680763,-0.49680763,0.49680763,255.01217,2.6223229)' } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M -0.49680099,-1.4900844 -0.49680795,206.9137 79.659562,126.75733 207.90699,255.00476 79.657586,383.25416 -0.49680795,303.09977 l 4.41e-6,208.40379 208.40379354,0 -80.15637,-80.15637 128.2494,-128.2494 c 43.4197,43.41971 90.25956,90.25956 128.2494,128.2494 l -80.15637,80.15637 208.4038,0 0,-208.40379 -80.1544,80.15439 -128.2494,-128.2494 c 42.74914,-42.74914 85.49828,-85.49828 128.24743,-128.24743 l 80.15637,80.15637 -10e-6,-208.4037813 -208.40379,-1e-5 80.1544,80.1543943 C 341.4983,121.41344 298.74916,164.16259 256.00002,206.91173 L 127.75259,78.664303 207.90699,-1.4900913 Z' } })])]);
	}

	// paths for diagonal arrows
	//h('path', { attrs: { fill, filter, d: "M1024 0h-416l160 160-192 192 96 96 192-192 160 160z"} }),
	//h('path', { attrs: { fill, filter, d: "M1024 1024v-416l-160 160-192-192-96 96 192 192-160 160z" } }),
	//h('path', { attrs: { fill, filter, d: "M0 1024h416l-160-160 192-192-96-96-192 192-160-160z" } }),
	//h('path', { attrs: { fill, filter, d: "M0 0v416l160-160 192 192 96-96-192-192 160-160z" } }),

	function zoom(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M992.262 871.396l-242.552-206.294c-25.074-22.566-51.89-32.926-73.552-31.926 57.256-67.068 91.842-154.078 91.842-249.176 0-212.078-171.922-384-384-384-212.076 0-384 171.922-384 384s171.922 384 384 384c95.098 0 182.108-34.586 249.176-91.844-1 21.662 9.36 48.478 31.926 73.552l206.294 242.552c35.322 39.246 93.022 42.554 128.22 7.356s31.892-92.898-7.354-128.22zM384 640c-141.384 0-256-114.616-256-256s114.616-256 256-256 256 114.616 256 256-114.614 256-256 256z' } })]);
	}

	function fullscreen(attrs, options) {
	  var fill = options.active ? options.activeColor : color;

	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [options.active ? (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M448 576v416l-160-160-192 192-96-96 192-192-160-160zM1024 96l-192 192 160 160h-416v-416l160 160 192-192z' } }) : (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M1024 0v416l-160-160-192 192-96-96 192-192-160-160zM448 672l-192 192 160 160h-416v-416l160 160 192-192z' } })]);
	}

	function vrMode(attrs, options) {
	  var fill = options.active ? options.activeColor : color;

	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M884.907 256h-748.373c-27.733 0-51.2 24.32-51.2 54.187v446.293c0 29.867 23.467 54.187 52.48 54.187h203.52c23.040 0 42.667-13.653 49.493-33.707l59.307-148.053c10.24-24.747 34.133-42.24 61.867-42.24s51.627 17.493 61.867 42.24l59.307 148.053c8.107 20.053 26.453 33.707 47.36 33.707h204.373c30.293 0 53.76-24.32 53.76-54.187v-446.293c0-29.867-23.467-54.187-53.76-54.187zM308.053 622.080c-52.053 0-94.72-43.947-94.72-97.707 0-55.040 42.667-97.707 94.72-97.707s94.293 42.667 94.293 97.707c0 53.76-42.24 97.707-94.293 97.707zM715.947 622.080c-52.053 0-94.293-43.947-94.293-97.707s42.24-97.707 94.293-97.707c52.053 0 94.72 43.947 94.72 97.707s-42.667 97.707-94.72 97.707z' } })]);
	}

	function lenticularMode(attrs, options) {
	  var fill = options.active ? options.activeColor : color;

	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [options.active ? (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M317.143 762.857l44.571-80.571q-49.714-36-77.714-90.857t-28-116q0-69.143 34.857-128.571-130.857 66.857-217.714 201.714 95.429 147.429 244 214.286zM539.429 329.143q0-11.429-8-19.429t-19.429-8q-71.429 0-122.571 51.143t-51.143 122.571q0 11.429 8 19.429t19.429 8 19.429-8 8-19.429q0-49.143 34.857-84t84-34.857q11.429 0 19.429-8t8-19.429zM746.857 220q0 4-0.571 5.143-60 107.429-180 323.429t-180.571 324l-28 50.857q-5.714 9.143-16 9.143-6.857 0-76.571-40-9.143-5.714-9.143-16 0-6.857 25.143-49.714-81.714-37.143-150.571-98.857t-119.143-140q-11.429-17.714-11.429-39.429t11.429-39.429q87.429-134.286 217.143-212t283.429-77.714q50.857 0 102.857 9.714l30.857-55.429q5.714-9.143 16-9.143 2.857 0 10.286 3.429t17.714 8.857 18.857 10.571 18 10.571 11.143 6.571q9.143 5.714 9.143 15.429zM768 475.429q0 79.429-45.143 144.857t-119.429 94l160-286.857q4.571 25.714 4.571 48zM1024 548.571q0 20-11.429 39.429-22.286 36.571-62.286 82.857-85.714 98.286-198.571 152.571t-239.714 54.286l42.286-75.429q121.143-10.286 224.286-78.286t172.286-175.429q-65.714-102.286-161.143-168l36-64q54.286 36.571 104.286 87.429t82.571 105.143q11.429 19.429 11.429 39.429z' } }) : (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M950.857 548.571q-86.857-134.857-217.714-201.714 34.857 59.429 34.857 128.571 0 105.714-75.143 180.857t-180.857 75.143-180.857-75.143-75.143-180.857q0-69.143 34.857-128.571-130.857 66.857-217.714 201.714 76 117.143 190.571 186.571t248.286 69.429 248.286-69.429 190.571-186.571zM539.429 329.143q0-11.429-8-19.429t-19.429-8q-71.429 0-122.571 51.143t-51.143 122.571q0 11.429 8 19.429t19.429 8 19.429-8 8-19.429q0-49.143 34.857-84t84-34.857q11.429 0 19.429-8t8-19.429zM1024 548.571q0 19.429-11.429 39.429-80 131.429-215.143 210.571t-285.429 79.143-285.429-79.429-215.143-210.286q-11.429-20-11.429-39.429t11.429-39.429q80-130.857 215.143-210.286t285.429-79.429 285.429 79.429 215.143 210.286q11.429 20 11.429 39.429z' } })]);
	}

	//export function enableParallaxmode(attrs, options) {
	//  const fill = options.active ? options.activeColor : color;

	//  return h('svg', { attrs: { viewBox, ...attrs }, style: { padding: boxSizing }}, [
	//    h('path', { attrs: { fill, filter, d: "M494.464 96.192l-427.584 184.224 428 182.784 432.416-183.2-432.832-183.808zM512 486.208v441.6l415.84-197.408v-420.832l-415.84 176.64zM64.16 730.4l417.248 197.408v-441.6l-417.248-176.64v420.832z" } }),
	//  ]);
	//}

	//export function disableParallaxmode(attrs, options) {
	//  const fill = '#000';

	//  return h('svg', { attrs: { viewBox, ...attrs }, style: { padding: boxSizing }}, [
	//    h('path', { attrs: { fill, filter, d: "M494.464 96.192l-427.584 184.224 428 182.784 432.416-183.2-432.832-183.808zM512 486.208v441.6l415.84-197.408v-420.832l-415.84 176.64zM64.16 730.4l417.248 197.408v-441.6l-417.248-176.64v420.832z" } }),
	//  ]);
	//}
	//
	function deviceTracking(attrs, options) {
	  var fill = options.active ? options.activeColor : color;

	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M395 37.2c-24.2 1.4-50.2 3.6-57.8 4.8-28.2 4.4-60.2 22.8-77.4 44.4-7.8 9.8-23.4 39-21.6 40.4 1.2 1 26.4 9.2 26.6 8.6 0.2-0.2 3.2-6.4 7-13.8 11.6-23.6 38.8-44 65.4-49.6 9.2-1.8 59.8-6 74.4-6h6.4v85.6l-16.4 1.2c-9.2 0.6-38.2 2-64.6 3.2-52.8 2.4-92.6 6.4-108 11-13 3.8-24.6 11.4-31.4 20.8-5 7-15.6 38.6-21.6 64l-2.6 10.6-8.2-1.2c-4.4-0.8-11.4-1.8-15.2-2.4l-7-1.2-17.6 88.4c-12.8 63.6-17 89-15.4 90 1.2 0.8 8.4 2.4 15.8 3.8l13.4 2.4-1.8 13.4c-1 7.4-1.8 31-2 52.4-0.2 34.6 0.2 40.4 4 51.4 15.2 45.6 59.8 72 133 78.6 24 2.2 25.2 2.2 42.6-3 62.8-18.2 121.4-24.2 219-22.4 79 1.6 130.2 8 175.6 22.4 15 4.8 17 5 38.6 3.2 73.4-6.2 118.6-32.2 134.8-77.2 4.6-13.2 6.4-64.6 3.2-95.2-1.4-12.2-2-22.6-1.6-23s6.8-2 14.2-3.6c7.4-1.4 13.8-3.2 14.4-3.6 0.4-0.6-7-40.4-16.8-88.8l-17.6-87.8-5.8 0.2c-3.4 0-10.2 0.8-15.2 1.6l-9.2 1.6-6.2-25c-9-35.4-13.2-45.8-22.2-54-8.8-8-30-18.4-43.6-21.6-15.4-3.4-63.8-7.4-120-10.2l-52.6-2.4v-85.6l5.6 1.2c3 0.6 18 1.6 33.4 2.2 15.4 0.8 34 2.6 41.6 4 28.2 5.8 54.4 26 67 51.6 3.8 7.6 7.8 13.2 9 12.8 1.4-0.4 7.2-2.4 13-4.2 5.6-2 10.4-4.6 10.4-6 0-1.6-3.4-9.4-7.4-17.4-10.6-21.4-32.6-43-54.4-53.6-9.2-4.4-23-9.4-31-11-38.2-8.2-203.8-11.6-296.2-6zM592 186c68.4 3.2 106 9 132.2 20.2 12 5.2 16.8 11.8 34.2 46.8 37.6 75 76.8 210.6 72.6 250.6-0.8 7.4-2.6 15.6-4 18.6-3.6 6.8-18.4 20.2-32.4 29.2-12.4 7.8-61.8 32-76.6 37.4-8.6 3-8.8 3-4-0.4 49.6-35 63.4-45.6 76.6-58.4 17.8-17.6 17.4-16 12.4-56-4.8-39-20-94.8-40.4-149-11-29.4-36.4-82.4-42.4-88.4-7.4-7.8-43.2-16.4-86.2-20.6-34.4-3.4-158.2-4.8-206.8-2.2-60.4 3.2-89.4 7.4-112.2 16.4-12 4.6-16.8 11.6-33.6 49.8-38 86.6-61.4 172.2-61.4 224.4v15.4l13.2 13.2c12.8 12.6 43.4 35.6 67.4 50.4 6.2 4 11.2 7.6 10.6 8-1.2 1.4-40.4-15-62.8-26.2-24.8-12.4-45-26.6-49-34.6-1.6-3-4-15.6-5.4-27.6-2.2-20-2-24.2 1.8-46.4 8-46.4 22.4-94.6 45.6-153.6 13.4-34 32-73 40.2-84.2 7.8-10.6 21.2-17 46.4-22.4 19.2-4.2 70.6-10 98-11 38.6-1.6 127.2-1.2 166 0.6zM194 656.8c0 6.4 6 33 10 45.2 21.6 63.6 98.4 169.8 171 236.8 28 25.8 44 37.4 60.8 44.2 25.2 10.4 69 15 103.6 11.2 52.2-6 69.8-16 125.6-71 90-89.2 156-193 163.8-257.8l1.4-11.4h-30.2v7.6c0 19.8-18 63.4-41.8 101.4-38 60.2-102 134.8-150 174.8-25.4 21-49.8 28.2-96.2 28.2-41.2 0-63.6-5.4-85.6-20.4-15.8-10.8-56-49.2-79-75.6-73.4-83.8-117.8-157.2-124.4-205.6l-1.4-10.4h-13.8c-10.6 0-13.8 0.6-13.8 2.8zM407.2 770.6c-1.8 7.4-3.2 13.6-3.2 14.2 0 1.6 28 7.4 55 11.4 43.2 6.4 79.6 4.6 136-6.2 12.2-2.4 22.2-4.6 22.6-5 0.4-0.2-1-6.6-2.8-14l-3.4-13.4-7.2 1c-4 0.6-17.6 3.2-30.2 5.6-33.6 6.6-93.2 6.6-126 0.2-12.6-2.6-26.2-5.2-30.2-5.8l-7.2-1-3.4 13z' } })]);
	}

	function nodeRotate(attrs, options) {
	  var fill = options.active ? options.activeColor : color;

	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M1024 384h-384l143.53-143.53c-72.53-72.526-168.96-112.47-271.53-112.47s-199 39.944-271.53 112.47c-72.526 72.53-112.47 168.96-112.47 271.53s39.944 199 112.47 271.53c72.53 72.526 168.96 112.47 271.53 112.47s199-39.944 271.528-112.472c6.056-6.054 11.86-12.292 17.456-18.668l96.32 84.282c-93.846 107.166-231.664 174.858-385.304 174.858-282.77 0-512-229.23-512-512s229.23-512 512-512c141.386 0 269.368 57.326 362.016 149.984l149.984-149.984v384z' } }), (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M512 250l262 262-262 262-262-262z' } })]);
	}

	function nodeMove(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: panViewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('g', { attrs: { transform: 'matrix(0.49680763,0.49680763,-0.49680763,0.49680763,255.01217,2.6223229)' } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M -0.49680099,-1.4900844 -0.49680795,206.9137 79.659562,126.75733 207.90699,255.00476 79.657586,383.25416 -0.49680795,303.09977 l 4.41e-6,208.40379 208.40379354,0 -80.15637,-80.15637 128.2494,-128.2494 c 43.4197,43.41971 90.25956,90.25956 128.2494,128.2494 l -80.15637,80.15637 208.4038,0 0,-208.40379 -80.1544,80.15439 -128.2494,-128.2494 c 42.74914,-42.74914 85.49828,-85.49828 128.24743,-128.24743 l 80.15637,80.15637 -10e-6,-208.4037813 -208.40379,-1e-5 80.1544,80.1543943 C 341.4983,121.41344 298.74916,164.16259 256.00002,206.91173 L 127.75259,78.664303 207.90699,-1.4900913 Z' } }), (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M256 0l256 256-256 256-256-256z' } })])]);
	}

	function nodeScale(attrs, options) {
	  var fill = options.active ? options.activeColor : color;

	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M992.262 871.396l-242.552-206.294c-25.074-22.566-51.89-32.926-73.552-31.926 57.256-67.068 91.842-154.078 91.842-249.176 0-212.078-171.922-384-384-384-212.076 0-384 171.922-384 384s171.922 384 384 384c95.098 0 182.108-34.586 249.176-91.844-1 21.662 9.36 48.478 31.926 73.552l206.294 242.552c35.322 39.246 93.022 42.554 128.22 7.356s31.892-92.898-7.354-128.22zM384 640c-141.384 0-256-114.616-256-256s114.616-256 256-256 256 114.616 256 256-114.614 256-256 256z' } }), (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M375 181l200 200-200 200-200-200z' } })]);
	}

	function pause(attrs, options) {
	  var fill = options.active ? options.activeColor : color;

	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M64 0h384v1024h-384z' } }), (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M576 0h384v1024h-384z' } })]);
	}

	function play(attrs, options) {
	  var fill = options.active ? options.activeColor : color;

	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M138 0L1024 512L138 1024z' } })]);
	}

	function select(attrs, options) {
	  var fill = options.active ? options.activeColor : '#000'; // FIXME white default not displayed?
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: '0 0 32 32' }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M16 0c-8.837 0-16 7.163-16 16s7.163 16 16 16 16-7.163 16-16-7.163-16-16-16zM16 28c-6.627 0-12-5.373-12-12s5.373-12 12-12c6.627 0 12 5.373 12 12s-5.373 12-12 12zM10 16c0-3.314 2.686-6 6-6s6 2.686 6 6c0 3.314-2.686 6-6 6s-6-2.686-6-6z' } })]);
	}

/***/ },
/* 351 */
/*!************************************!*\
  !*** ./src/components/timeline.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = timeline;

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	var _icons = __webpack_require__(/*! ./icons */ 350);

	var _marker = __webpack_require__(/*! ./marker */ 352);

	var _marker2 = _interopRequireDefault(_marker);

	var _player = __webpack_require__(/*! ../modules/player */ 295);

	var _animation = __webpack_require__(/*! ../modules/animation */ 134);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var dragHandler = null;
	var timeoutHandler = null;
	var visible = false;

	function timeline(store) {
	  var timelineStyle = {
	    flex: '1 1 auto',
	    position: 'relative',
	    bottom: 0,
	    right: 0,
	    borderRadius: '5px',
	    padding: '0 20px'
	  };

	  var rulerStyle = {
	    boxSizing: 'border-box',
	    backgroundColor: 'rgba(0, 0, 0, 0.2)',
	    border: '1px solid #ccc',
	    position: 'relative',
	    top: '17px',
	    left: '56px',
	    height: '10px',
	    width: 'calc(100% - 55px)',
	    cursor: 'pointer'
	  };

	  var activeColor = (0, _player.getActiveColor)(store);
	  var hoverColor = (0, _player.getHoverColor)(store);
	  var iconAttrs = { width: 34, height: 34, title: 'play' };
	  var iconOptions = { active: false, activeColor: activeColor };

	  var timeAnimation = (0, _animation.getTimelineAnimation)(store);
	  if (!timeAnimation) return null;
	  var startTime = timeAnimation.start;
	  var duration = timeAnimation.duration / Math.abs(timeAnimation.playSpeed);
	  var played = Math.max(Math.min(((0, _animation.getTime)(store) - startTime) / duration, 1), 0) * 100;

	  var playedStyle = {
	    backgroundColor: activeColor,
	    width: 'calc(' + played + '% - 2px)',
	    height: '6px',
	    position: 'absolute',
	    left: '1px',
	    top: '1px',
	    cursor: 'pointer'
	  };

	  var buttonStyle = {
	    position: 'relative',
	    display: 'inline-block',
	    verticalAlign: 'middle',
	    top: '-5px',
	    cursor: 'pointer'
	  };

	  var hoverStyle = '\n    div.claraplayer div div svg:hover path {\n    fill: ' + hoverColor + ';\n  }';

	  function createHandleDrag(_ref, touch) {
	    var width = _ref.width,
	        left = _ref.left;

	    return function (ev) {
	      visible = true;
	      if (timeoutHandler) {
	        window.clearTimeout(timeoutHandler);
	      }

	      timeoutHandler = window.setTimeout(function () {
	        visible = false;
	        store.dispatch({ type: 'POKE' });
	      }, 2000);

	      var evX = touch ? ev.touches[0].pageX : ev.pageX;
	      var percentTime = Math.max(Math.min((evX - left) / width, 1), 0);
	      var time = percentTime * duration + startTime;
	      store.dispatch((0, _animation.setTime)(time));
	    };
	  }

	  function handleClick(ev) {
	    //console.log(ev.target.parentNode);
	    visible = true;
	    if (timeoutHandler) {
	      window.clearTimeout(timeoutHandler);
	    }

	    timeoutHandler = window.setTimeout(function () {
	      visible = false;
	      store.dispatch({ type: 'POKE' });
	    }, 2000);

	    if (dragHandler !== null) {
	      window.removeEventListener('mousemove', dragHandler);
	      window.removeEventListener('mouseup', endDrag);
	      window.removeEventListener('touchmove', dragHandler);
	      window.removeEventListener('touchend', endDrag);
	    }

	    var touch = !!ev.touches;
	    var evX = touch ? ev.touches[0].clientX : ev.clientX;

	    var rectElement = ev.target.className === 'ruler' ? ev.target : ev.target.parentNode;
	    var rect = rectElement.getBoundingClientRect();

	    var time = (evX - rect.left) / rect.width * duration + startTime;
	    store.dispatch((0, _animation.setTime)(time));

	    dragHandler = createHandleDrag(rect, touch);
	    if (!touch) {
	      window.addEventListener('mousemove', dragHandler);
	      window.addEventListener('mouseup', endDrag);
	    } else {
	      window.addEventListener('touchmove', dragHandler);
	      window.addEventListener('touchend', endDrag);
	    }
	  }

	  function endDrag(ev) {
	    window.removeEventListener('mousemove', dragHandler);
	    window.removeEventListener('mouseup', endDrag);
	    window.removeEventListener('touchmove', dragHandler);
	    window.removeEventListener('touchend', endDrag);
	    dragHandler = null;
	  }

	  var icon = (0, _animation.isPlaying)(store) ? (0, _icons.pause)(iconAttrs, iconOptions) : (0, _icons.play)(iconAttrs, iconOptions);
	  var clickAction = (0, _animation.isPlaying)(store) ? function () {
	    return store.dispatch((0, _animation.stopPlaying)());
	  } : function () {
	    return store.dispatch((0, _animation.startPlaying)());
	  };

	  return (0, _h2.default)('div', { style: timelineStyle }, [(0, _h2.default)('style', { props: { innerHTML: hoverStyle } }), (0, _h2.default)('div.ruler', { style: rulerStyle, on: { mousedown: handleClick, touchstart: handleClick } }, [(0, _h2.default)('div.played', { style: playedStyle }), (0, _marker2.default)(store, played, duration, visible)]), (0, _h2.default)('div', { style: buttonStyle, on: { click: clickAction } }, [icon])]);
	}

/***/ },
/* 352 */
/*!**********************************!*\
  !*** ./src/components/marker.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = marker;

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function marker(store, percentPlayed, duration, visible) {

	  var markerStyle = {
	    width: '0',
	    height: '100%',
	    position: 'absolute',
	    left: percentPlayed + '%',
	    top: '0',
	    pointerEvents: 'auto',
	    cursor: 'pointer'
	  };

	  var toolTipStyle = {
	    boxSizing: 'border-box',
	    position: 'absolute',
	    zIndex: '1070',
	    display: 'block',
	    visibility: 'visible',
	    fontSize: '12px',
	    fontWeight: 'normal',
	    lineHeight: '1.4',
	    top: '-32px',
	    left: '-25px',
	    width: '50px',
	    height: '22px',
	    marginTop: '-3px',
	    padding: '5px 0',
	    opacity: '1'
	  };
	  if (!visible) {
	    toolTipStyle.opacity = '0';
	    toolTipStyle.transition = 'opacity 0.15s linear';
	  }

	  var innerStyle = {
	    maxWidth: '200px',
	    padding: '3px 8px',
	    color: '#ffffff',
	    textAlign: 'center',
	    textDecoration: 'none',
	    backgroundColor: '#000000',
	    borderRadius: '4px',
	    boxShadow: '#000 0 0 5px',
	    margin: '0 auto',
	    userSelect: 'none',
	    WebkitUserSelect: 'none',
	    MozUserSelect: 'none'
	  };

	  var arrowStyle = {
	    boxSizing: 'border-box',
	    position: 'absolute',
	    width: '0',
	    height: '0',
	    bottom: '-10px',
	    left: '50%',
	    marginLeft: '-5px',
	    borderWidth: '5px 5px 0',
	    borderTopColor: '#000000',
	    borderRightColor: 'transparent',
	    borderBottomColor: 'transparent',
	    borderLeftColor: 'transparent',
	    borderStyle: 'solid'
	  };

	  function stopEvent(ev) {
	    ev.stopPropagation();
	  }

	  return (0, _h2.default)('div.marker', { style: markerStyle, on: { mousedown: stopEvent, touchstart: stopEvent } }, [(0, _h2.default)('div.tooltip', { style: toolTipStyle }, [(0, _h2.default)('div.tooltip-arrow', { style: arrowStyle }), (0, _h2.default)('div.tooltip-inner', { style: innerStyle }, (duration * percentPlayed / 100000).toFixed(1))])]);
	}

/***/ },
/* 353 */,
/* 354 */,
/* 355 */
/*!****************************************!*\
  !*** ./src/translators/tools/index.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _orbit = __webpack_require__(/*! ./orbit */ 303);

	var _orbit2 = _interopRequireDefault(_orbit);

	var _pan = __webpack_require__(/*! ./pan */ 356);

	var _pan2 = _interopRequireDefault(_pan);

	var _zoom = __webpack_require__(/*! ./zoom */ 304);

	var _zoom2 = _interopRequireDefault(_zoom);

	var _nodeMove = __webpack_require__(/*! ./nodeMove */ 358);

	var _nodeMove2 = _interopRequireDefault(_nodeMove);

	var _nodeRotate = __webpack_require__(/*! ./nodeRotate */ 361);

	var _nodeRotate2 = _interopRequireDefault(_nodeRotate);

	var _nodeScale = __webpack_require__(/*! ./nodeScale */ 363);

	var _nodeScale2 = _interopRequireDefault(_nodeScale);

	var _select = __webpack_require__(/*! ./select */ 364);

	var _select2 = _interopRequireDefault(_select);

	var _fullscreen = __webpack_require__(/*! ./fullscreen */ 365);

	var _fullscreen2 = _interopRequireDefault(_fullscreen);

	var _home = __webpack_require__(/*! ./home */ 366);

	var _home2 = _interopRequireDefault(_home);

	var _vrMode = __webpack_require__(/*! ./vrMode */ 367);

	var _vrMode2 = _interopRequireDefault(_vrMode);

	var _firstPersonMode = __webpack_require__(/*! ./firstPersonMode */ 374);

	var _firstPersonMode2 = _interopRequireDefault(_firstPersonMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var tools = {
	  orbit: _orbit2.default,
	  pan: _pan2.default,
	  zoom: _zoom2.default,
	  home: _home2.default,
	  nodeMove: _nodeMove2.default,
	  nodeRotate: _nodeRotate2.default,
	  nodeScale: _nodeScale2.default,
	  select: _select2.default,
	  fullscreen: _fullscreen2.default,
	  vrMode: _vrMode2.default,
	  firstPersonMode: _firstPersonMode2.default
	};

	exports.default = tools;

/***/ },
/* 356 */
/*!**************************************!*\
  !*** ./src/translators/tools/pan.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = pan;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _decompose = __webpack_require__(/*! ../utils/decompose */ 302);

	var _decompose2 = _interopRequireDefault(_decompose);

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 144);

	var _updateCameraLookAtTarget = __webpack_require__(/*! ../utils/updateCameraLookAtTarget */ 296);

	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

	var _getProjectionMatrix = __webpack_require__(/*! ../utils/getProjectionMatrix */ 357);

	var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);

	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 299);

	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var tan = Math.tan,
	    cos = Math.cos,
	    atan = Math.atan,
	    acos = Math.acos,
	    min = Math.min,
	    max = Math.max,
	    pow = Math.pow,
	    PI = Math.PI,
	    sqrt = Math.sqrt;


	var cameraProjectMatrix = new THREE.Matrix4();
	var cameraUnprojectMatrix = new THREE.Matrix4();
	var ndcReferencePoint = new THREE.Vector3();
	var worldRelative = new THREE.Vector3();
	var deltaReferencePoint = new THREE.Vector3();
	var referencePoint = new THREE.Vector3();
	var translationMatrix = new THREE.Matrix4();

	var cameraPosition = new THREE.Vector3();
	var targetPosition = new THREE.Vector3();
	var offset = new THREE.Vector3();

	function pan(store, translator) {
	  function move(_ref) {
	    var deltaX = _ref.deltaX,
	        deltaY = _ref.deltaY;

	    var zoom = 1;
	    if (true) zoom = window.devicePixelRatio;
	    updatePan(store, new THREE.Vector2(deltaX / zoom, deltaY / zoom));
	  }

	  return {
	    label: 'Pan',
	    enabled: true,
	    display: {
	      playerTools: true
	    },
	    options: {},

	    tool: {
	      drag: function drag(ev) {
	        if (!this.active && ev.which !== 2 && ev.which !== 3 && !ev.shiftKey) return false;

	        return {
	          momentum: true,
	          handle: function handle(ev) {
	            move(ev);
	          }
	        };
	      },

	      swipe: function swipe(ev) {
	        move(ev);
	      }
	    }
	  };
	}

	function updatePan(store, mouseDelta) {

	  var cameraId = (0, _player.getCamera)(store);
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
	  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
	  var rect = (0, _player.getRect)(store);
	  var projectionMatrix = (0, _getProjectionMatrix2.default)((0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' }));

	  // convert mouse delta into relative delta in NDC.
	  var relativeDelta = new THREE.Vector2().copy(mouseDelta).divide(rect).multiplyScalar(2.0);
	  relativeDelta.x *= -1;

	  var invCameraWorldMatrix = new THREE.Matrix4().getInverse(cameraWorldMatrix, true);
	  cameraProjectMatrix.copy(projectionMatrix).multiply(invCameraWorldMatrix);

	  ndcReferencePoint.setFromMatrixPosition(targetWorldMatrix).applyMatrix4(cameraProjectMatrix);
	  cameraUnprojectMatrix.getInverse(cameraProjectMatrix, true);

	  referencePoint.set(0, 0, ndcReferencePoint.z).applyMatrix4(cameraUnprojectMatrix);
	  deltaReferencePoint.set(relativeDelta.x, relativeDelta.y, ndcReferencePoint.z).applyMatrix4(cameraUnprojectMatrix);

	  // ensure that NDC has the same layout as mouseDelta coordinate space
	  worldRelative.copy(deltaReferencePoint).sub(referencePoint);
	  //bounding box constraining
	  if (cameraData.radiusConstraint && worldRelative.length() > 0) {
	    var _cameraData$radiusCon = cameraData.radiusConstraint,
	        maxBoundingSphere = _cameraData$radiusCon.maxBoundingSphere,
	        minBoundingSphere = _cameraData$radiusCon.minBoundingSphere;

	    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	    targetPosition.setFromMatrixPosition(targetWorldMatrix);

	    var directionNorm = new THREE.Vector3().copy(worldRelative).normalize();
	    var camRay = new THREE.Ray(cameraPosition, directionNorm);
	    var targRay = new THREE.Ray(targetPosition, directionNorm);

	    var targHit = targRay.intersectSphere(minBoundingSphere).sub(targetPosition).length() - (0.001);

	    var inCamHit = camRay.intersectSphere(minBoundingSphere);
	    if (inCamHit) inCamHit = inCamHit.sub(cameraPosition).length() - (0.001);else inCamHit = Infinity;

	    var outCamHit = camRay.intersectSphere(maxBoundingSphere).sub(cameraPosition).length() - (0.001);

	    var moveLength = Math.min(worldRelative.length(), targHit, inCamHit, outCamHit);
	    worldRelative.normalize().multiplyScalar(moveLength);
	  }

	  translationMatrix.makeTranslation(worldRelative.x, worldRelative.y, worldRelative.z);
	  offset.addVectors(cameraData.offset, worldRelative);
	  cameraData.offset = offset;

	  targetWorldMatrix.multiplyMatrices(translationMatrix, targetWorldMatrix);
	  cameraWorldMatrix.multiplyMatrices(translationMatrix, cameraWorldMatrix);

	  if (playerData.constraintCameraY && playerData.orbitMode !== 'trackball') {
	    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	    targetPosition.setFromMatrixPosition(targetWorldMatrix);

	    if (cameraPosition.y < 0) {
	      targetPosition.y -= cameraPosition.y;
	      cameraPosition.y = 0;
	    }

	    targetWorldMatrix.setPosition(targetPosition);
	    cameraWorldMatrix.setPosition(cameraPosition);
	  }

	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);

	  store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
	  store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
	  //store.dispatch(merge([cameraId, 'Camera', 0], {offset}));
	}

/***/ },
/* 357 */
/*!******************************************************!*\
  !*** ./src/translators/utils/getProjectionMatrix.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getProjectionMatrix;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function getProjectionMatrix(cameraData) {
	  var projectionMatrix = new THREE.Matrix4();
	  if (cameraData.projection === 'Orthographic') {
	    var size = computeCameraSize(true, cameraData) || { width: 1, height: 1 };
	    projectionMatrix.makeOrthographic(-size.width, size.width, size.height, -size.height, cameraData.nearClip, cameraData.farClip);
	  } else {
	    // const filmSizeVec = new THREE.Vector2(cameraData.get('filmSize'),
	    //     cameraData.get('filmSize') * cameraData.get('aspectRatio'));
	    //  console.log(navigator.getProjectionMatrix:, data.fieldOfView, data.aspectRatio);

	    var ymax = cameraData.nearClip * Math.tan(THREE.Math.DEG2RAD * cameraData.fieldOfView * 0.5);
	    var ymin = -ymax;
	    var xmin = ymin * cameraData.aspectRatio;
	    var xmax = ymax * cameraData.aspectRatio;

	    return projectionMatrix.makePerspective(xmin, xmax, ymax, ymin, cameraData.nearClip, cameraData.farClip);
	  }

	  return projectionMatrix;
	}

	function computeCameraSize(halfSize, cameraData) {

	  if (!(cameraData && cameraData.fieldOfView && cameraData.orthoZoom && cameraData.aspectRatio)) return false;

	  var tangent = Math.tan(THREE.Math.degToRad(cameraData.fieldOfView / 2));
	  var camHeight_half = tangent * cameraData.orthoZoom;
	  var camWidth_half = camHeight_half * cameraData.aspectRatio;

	  //  Horizontal fov ?
	  // var hFOV_Half = Math.atan( Math.tan( this.fieldOfView / 2 ) * this.aspectRatio );
	  // var camWidth = Math.tan( hFOV_Half ) * dist * 2;

	  if (halfSize === true) {
	    return { width: camWidth_half, height: camHeight_half };
	  } else {
	    return { width: camWidth_half * 2, height: camHeight_half * 2 };
	  }
	}

/***/ },
/* 358 */
/*!*******************************************!*\
  !*** ./src/translators/tools/nodeMove.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = nodeMove;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _getProjectionMatrix = __webpack_require__(/*! ../utils/getProjectionMatrix */ 357);

	var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	var _selection = __webpack_require__(/*! ../../modules/selection */ 312);

	var _gizmos = __webpack_require__(/*! ./gizmos */ 359);

	var _getProjectedPoint = __webpack_require__(/*! ./utils/getProjectedPoint */ 360);

	var _getProjectedPoint2 = _interopRequireDefault(_getProjectedPoint);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var PI = Math.PI,
	    sin = Math.sin;


	var invCameraWorldMatrix = new THREE.Matrix4();
	var cameraProjectMatrix = new THREE.Matrix4();
	var cameraUnprojectMatrix = new THREE.Matrix4();
	var inverseParent = new THREE.Matrix4();
	var referencePoint = new THREE.Vector3();
	var deltaReferencePoint = new THREE.Vector3();

	//const defaultOptions = {
	//  displayGizmo: true,
	//  useXAxis: true,
	//  useYAxis: true,
	//  useZAxis: true,
	//  defaultPlane: { x: 0, y: 0 },
	//}

	//updateTool('nodeMove', { displayGizmo: false });

	function nodeMove(store, translator) {
	  var activeAxis = false;

	  return {
	    label: 'Move Node',
	    enabled: true,
	    display: {
	      playerTools: false
	    },

	    options: {
	      displayGizmo: true,
	      mode: 'free',
	      plane: {
	        normal: { x: 0, y: 1, z: 0 },
	        constant: 0
	      }
	    },

	    tool: {
	      hover: function hover(ev) {
	        if (!this.active) return;
	        activeAxis = (0, _gizmos.highlightAxis)(translator, ev, activeAxis);
	      },

	      drag: function drag(ev) {
	        if (ev.which !== 1 || !this.active || ev.metaKey) return false;
	        var self = this;
	        return {
	          momentum: !activeAxis,
	          handle: function handle(ev) {
	            switch (self.options.mode) {
	              case 'plane':
	                moveNodeOnPlane(store, ev.deltaX, ev.deltaY, self.options.plane);
	                break;
	              case 'objects':
	                moveNodeOnObjects(store, ev.clientX, ev.clientY, self.options.objects);
	                break;
	              default:
	                moveNodeFree(store, ev.deltaX, ev.deltaY, activeAxis);
	                break;
	            }
	          }
	        };
	      }
	    },

	    widget: {
	      draw: function draw(manipulatorsObject) {
	        manipulatorsObject.add((0, _gizmos.drawMoveGizmo)());
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      },

	      position: function position(manipulatorsObject) {
	        var selectedNodes = (0, _selection.getSelectedNodes)(store);
	        if (!selectedNodes.length) {
	          manipulatorsObject.visible = false;
	          return;
	        }

	        manipulatorsObject.visible = true;
	        var manipId = selectedNodes[0];
	        var worldTransform = (0, _scene.getWorldTransform)(store, manipId);
	        var position = new THREE.Vector3();
	        position.setFromMatrixPosition(worldTransform);
	        manipulatorsObject.position.set(position.x, position.y, position.z);
	        //manipulatorsObject.scale.set(2,2,2);
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      }
	    }
	  };
	}

	function moveNodeFree(store, x, y, restrictToAxis) {
	  var selectedNodes = (0, _selection.getSelectedNodes)(store);
	  if (!selectedNodes.length) return;
	  var manipId = selectedNodes[0];

	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	  var nodeMatrix = (0, _scene.getWorldTransform)(store, manipId);
	  if (!nodeMatrix) return;

	  var parentMatrix = (0, _scene.getWorldTransform)(store, (0, _scene.find)(store, { id: manipId, parent: true }));
	  var nodePosition = new THREE.Vector3().setFromMatrixPosition(nodeMatrix);
	  deltaReferencePoint.copy((0, _getProjectedPoint2.default)(store, manipId, x, y));

	  if (restrictToAxis) {
	    var projVector = new THREE.Vector3(0, 0, 0);
	    projVector[restrictToAxis] = 1;

	    var targToCam = new THREE.Vector3().setFromMatrixPosition(cameraWorldMatrix).sub(nodePosition);
	    var origin = new THREE.Vector3(0, 0, 0);
	    var plane = new THREE.Plane().setFromCoplanarPoints(targToCam, projVector, origin);
	    deltaReferencePoint.projectOnPlane(plane.normal);

	    var camToMove = new THREE.Vector3().subVectors(deltaReferencePoint, targToCam);
	    deltaReferencePoint.projectOnVector(projVector).normalize();
	    var alpha = targToCam.angleTo(deltaReferencePoint);
	    var beta = PI - targToCam.angleTo(camToMove);
	    var gamma = PI - alpha - beta;
	    var axis = targToCam.length() * sin(beta) / sin(gamma);
	    deltaReferencePoint.multiplyScalar(axis);
	  }

	  nodePosition.add(deltaReferencePoint);

	  nodeMatrix.setPosition(nodePosition);
	  if (parentMatrix) nodeMatrix.premultiply(inverseParent.getInverse(parentMatrix));

	  nodePosition.setFromMatrixPosition(nodeMatrix);

	  // FIXME: Restrict to axis:
	  //if (restrictToAxis) console.log('restrict to axis: ', restrictToAxis);

	  store.dispatch((0, _scene.set)({ id: manipId, plug: 'Transform', property: 'translation' }, nodePosition));
	}

	var upVector = new THREE.Vector3(0, 1, 0);

	var stripParentTransform = function () {
	  var newLocalTransform = new THREE.Matrix4();
	  var invParentTransform = new THREE.Matrix4();

	  return function (store, nodeId, position, quaternion, scale) {
	    newLocalTransform.compose(position, quaternion, scale);

	    var parentId = (0, _scene.find)(store, { id: nodeId, parent: true });
	    var parentTransform = (0, _scene.getWorldTransform)(store, parentId);
	    if (parentTransform) {
	      invParentTransform.getInverse(parentTransform, true);
	      newLocalTransform.premultiply(invParentTransform);
	      newLocalTransform.decompose(position, quaternion, scale);
	    }
	  };
	}();

	var setNodePosition = function () {
	  var scale = new THREE.Vector3();
	  var quaternion = new THREE.Quaternion();
	  var euler = new THREE.Euler();

	  return function (store, nodeId, position) {
	    var scaleNode = (0, _scene.get)(store, { id: nodeId, plug: 'Transform', property: 'scale' });
	    var rotateNode = (0, _scene.get)(store, { id: nodeId, plug: 'Transform', property: 'rotation' });
	    var rotateOrder = (0, _scene.get)(store, { id: nodeId, plug: 'Transform', property: 'rotateOrder' });
	    scale.set(scaleNode.x, scaleNode.y, scaleNode.z);
	    euler.set(rotateNode, rotateOrder);
	    quaternion.setFromEuler(euler);

	    stripParentTransform(store, nodeId, position, quaternion, scale);

	    //store.dispatch(set({id:nodeId, plug:'Transform', property:'rotation'}, newEuler.toVector3().multiplyScalar(180/Math.PI)));
	    store.dispatch((0, _scene.set)({ id: nodeId, plug: 'Transform', property: 'translation' }, position));
	  };
	}();

	var getNodeNdc = function () {
	  var oldPosition = new THREE.Vector3();
	  var inverseCameraMatrix = new THREE.Matrix4();

	  return function (store, nodeId) {
	    oldPosition.setFromMatrixPosition((0, _scene.getWorldTransform)(store, nodeId));
	    var camera = (0, _player.getThreeCamera)(store);
	    inverseCameraMatrix.getInverse(camera.matrix, true).premultiply(camera.projectionMatrix);
	    oldPosition.applyMatrix4(inverseCameraMatrix);
	    return oldPosition;
	  };
	}();

	var moveNodeOnObjects = function () {
	  var newQuaternion = new THREE.Quaternion();

	  return function (store, x, y, objects) {
	    var rect = (0, _player.getRect)(store);
	    var nodeId = (0, _selection.getSelectedNodes)(store)[0];
	    if (!nodeId) return;

	    var ndc = { x: 2 * x / rect.width - 1, y: -2 * y / rect.height + 1 };
	    var hits = store.getTranslator().raycastSelect(ndc);
	    var nodeChildren = (0, _scene.filter)(store, { from: { id: nodeId } });
	    var nodeHit = hits.find(function (hit) {
	      var foundIndex = objects.findIndex(function (id) {
	        return id === hit.id && id !== nodeId && nodeChildren.indexOf(id) < 0;
	      });
	      return foundIndex >= 0;
	    });

	    if (!nodeHit) return;

	    var newPosition = nodeHit.data[0].point;

	    setNodePosition(store, nodeId, newPosition);
	  };
	}();

	var moveNodeOnPlane = function () {
	  var newPosition = new THREE.Vector3();
	  var newQuaternion = new THREE.Quaternion();
	  var moveOnPlane = new THREE.Plane();
	  var moveOnNormal = new THREE.Vector3();

	  return function (store, x, y, plane) {
	    var rect = (0, _player.getRect)(store);
	    var nodeId = (0, _selection.getSelectedNodes)(store)[0];
	    if (!nodeId) return;
	    var oldNdc = getNodeNdc(store, nodeId);

	    //const plane = store.getIn(['selection', 'collisionPlane']);
	    var normal = plane.normal;

	    moveOnNormal.set(normal.x, normal.y, normal.z);
	    moveOnPlane.set(moveOnNormal, plane.constant);

	    var ndc = { x: oldNdc.x + 2 * x / rect.width, y: oldNdc.y - 2 * y / rect.height };
	    var ray = store.getTranslator().getCameraMouseRay(ndc).ray;
	    if (!ray.intersectsPlane(moveOnPlane)) return;
	    ray.intersectPlane(moveOnPlane, newPosition);

	    store.dispatch((0, _scene.set)({ id: nodeId }));
	    setNodePosition(store, nodeId, newPosition);
	  };
	}();

/***/ },
/* 359 */
/*!*****************************************!*\
  !*** ./src/translators/tools/gizmos.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getViewScale = getViewScale;
	exports.drawMoveGizmo = drawMoveGizmo;
	exports.drawRotateGizmo = drawRotateGizmo;
	exports.drawScaleGizmo = drawScaleGizmo;
	exports.highlightAxis = highlightAxis;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _selection = __webpack_require__(/*! ../../modules/selection */ 312);

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var axisColors = { x: 0xff0000, y: 0x00ff00, z: 0x0000ff };

	var materials = {
	  x: new THREE.MeshStandardMaterial({ color: axisColors.x, depthTest: false }),
	  y: new THREE.MeshStandardMaterial({ color: axisColors.y, depthTest: false }),
	  z: new THREE.MeshStandardMaterial({ color: axisColors.z, depthTest: false })
	};

	var lineRadius = 0.02;

	function cancelAxis(axis) {
	  materials[axis].color = new THREE.Color(axisColors[axis]);
	  materials[axis].needsUpdate = true;
	}

	function resetMaterials() {
	  ['x', 'y', 'z'].forEach(cancelAxis);
	}

	function getViewScale(store) {
	  var viewRect = (0, _player.getRect)(store);
	  var posObj = new THREE.Vector3().copy(viewRect.height < viewRect.width ? { x: 0, y: 0.4, z: 0 } : { x: 0.4, y: 0, z: 0 });

	  var node = (0, _selection.getSelectedNodes)(store)[0];
	  if (!node) return 0;
	  var nodePosition = new THREE.Vector3().setFromMatrixPosition((0, _scene.getWorldTransform)(store, node));

	  var camera = (0, _player.getThreeCamera)(store);
	  var cameraPosition = new THREE.Vector3().setFromMatrixPosition(camera.matrix);

	  var inverseProjectionMatrix = new THREE.Matrix4().getInverse(camera.projectionMatrix, true);
	  var referencePoint = new THREE.Vector3().copy(nodePosition).applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
	  referencePoint.add(posObj).applyMatrix4(inverseProjectionMatrix).applyMatrix4(camera.matrix);

	  var scale = referencePoint.sub(nodePosition).length();
	  return scale;
	}

	function drawMoveGizmo() {
	  resetMaterials();
	  var coneRadius = 0.08;
	  var cone = new THREE.ConeGeometry(coneRadius, 0.25, 25);
	  var yArrow = new THREE.CylinderGeometry(lineRadius, lineRadius, 2, 32);
	  var cone2 = cone.clone();
	  cone.translate(0, 1, 0);
	  cone2.rotateX(Math.PI);
	  cone2.translate(0, -1, 0);
	  yArrow.merge(cone);
	  yArrow.merge(cone2);

	  var zArrow = yArrow.clone();
	  var xArrow = yArrow.clone();

	  var yMesh = new THREE.Mesh(yArrow, materials.y);
	  yMesh.axis = 'y';

	  zArrow.rotateX(Math.PI / 2);
	  var zMesh = new THREE.Mesh(zArrow, materials.z);
	  zMesh.axis = 'z';

	  xArrow.rotateZ(Math.PI / 2);
	  var xMesh = new THREE.Mesh(xArrow, materials.x);
	  xMesh.axis = 'x';

	  var moveGizmo = new THREE.Object3D();
	  moveGizmo.add(xMesh);
	  moveGizmo.add(yMesh);
	  moveGizmo.add(zMesh);

	  return moveGizmo;
	};

	function drawRotateGizmo() {
	  resetMaterials();
	  var xRotation = new THREE.TorusGeometry(1, lineRadius, 16, 100);
	  var yRotation = xRotation.clone();
	  var zRotation = xRotation.clone();

	  xRotation.rotateY(Math.PI / 2);
	  yRotation.rotateX(Math.PI / 2);

	  var rotateGizmo = new THREE.Object3D();
	  var xMesh = new THREE.Mesh(xRotation, materials.x);
	  xMesh.axis = 'x';
	  var yMesh = new THREE.Mesh(yRotation, materials.y);
	  yMesh.axis = 'y';
	  var zMesh = new THREE.Mesh(zRotation, materials.z);
	  zMesh.axis = 'z';
	  rotateGizmo.add(xMesh);
	  rotateGizmo.add(yMesh);
	  rotateGizmo.add(zMesh);

	  return rotateGizmo;
	};

	function drawScaleGizmo() {
	  resetMaterials();
	  var boxWidth = 0.2;
	  var box = new THREE.BoxGeometry(boxWidth, boxWidth, boxWidth);
	  var yArrow = new THREE.CylinderGeometry(lineRadius, lineRadius, 1, 32);
	  yArrow.translate(0, 0.5, 0);
	  //const box2 = box.clone();
	  box.translate(0, 1, 0);
	  //box2.rotateX(Math.PI);
	  //box2.translate(0, -1, 0);
	  yArrow.merge(box);
	  //yArrow.merge(box2);

	  var zArrow = yArrow.clone();
	  var xArrow = yArrow.clone();

	  var yMesh = new THREE.Mesh(yArrow, materials.y);
	  yMesh.axis = 'y';

	  zArrow.rotateX(Math.PI / 2);
	  var zMesh = new THREE.Mesh(zArrow, materials.z);
	  zMesh.axis = 'z';

	  xArrow.rotateZ(-Math.PI / 2);
	  var xMesh = new THREE.Mesh(xArrow, materials.x);
	  xMesh.axis = 'x';

	  var scaleGizmo = new THREE.Object3D();
	  scaleGizmo.add(xMesh);
	  scaleGizmo.add(yMesh);
	  scaleGizmo.add(zMesh);

	  return scaleGizmo;
	};

	function highlightAxis(translator, ev, activeAxis) {
	  var axis = null;
	  var x = ev.clientX / (ev.rect.width / 2) - 1;
	  var y = -(ev.clientY / (ev.rect.height / 2) - 1);
	  var hits = translator.raycastSelect({ x: x, y: y }, 'Widgets');

	  if (hits && hits[0] && hits[0].node && hits[0].node.axis) {
	    if (activeAxis) cancelAxis(activeAxis);
	    axis = hits[0].node.axis;
	    materials[axis].color = new THREE.Color(1, 1, 0);
	    materials[axis].needsUpdate = true;
	    translator.postTranslate('normal', true);
	  } else if (activeAxis) {
	    cancelAxis(activeAxis);
	    translator.postTranslate('normal', true);
	  }

	  return axis;
	};

/***/ },
/* 360 */
/*!**********************************************************!*\
  !*** ./src/translators/tools/utils/getProjectedPoint.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getProjectedPoint;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _getProjectionMatrix = __webpack_require__(/*! ../../utils/getProjectionMatrix */ 357);

	var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);

	var _player = __webpack_require__(/*! ../../../modules/player */ 295);

	var _scene = __webpack_require__(/*! ../../../modules/scene */ 171);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var invCameraWorldMatrix = new THREE.Matrix4();
	var cameraProjectMatrix = new THREE.Matrix4();
	var cameraUnprojectMatrix = new THREE.Matrix4();

	var nodePosition = new THREE.Vector3();
	var referencePoint = new THREE.Vector3();
	var relativeDelta = new THREE.Vector2();
	var deltaReferencePoint = new THREE.Vector3();

	function getProjectedPoint(store, nodeId, x, y) {
	  var cameraId = (0, _player.getCamera)(store);
	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	  var projectionMatrix = (0, _getProjectionMatrix2.default)((0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' }));
	  invCameraWorldMatrix.getInverse(cameraWorldMatrix, true);
	  cameraProjectMatrix.copy(projectionMatrix).multiply(invCameraWorldMatrix);

	  var nodeMatrix = (0, _scene.getWorldTransform)(store, nodeId);
	  if (!nodeMatrix) return;

	  var rect = (0, _player.getRect)(store);
	  var parentMatrix = (0, _scene.getWorldTransform)(store, (0, _scene.find)(store, { id: nodeId, parent: true }));
	  nodePosition.setFromMatrixPosition(nodeMatrix);
	  relativeDelta.set(x, -y).divide(rect).multiplyScalar(2.0);

	  referencePoint.copy(nodePosition).applyMatrix4(cameraProjectMatrix);
	  referencePoint.x = 0;
	  referencePoint.y = 0;
	  deltaReferencePoint.set(relativeDelta.x, relativeDelta.y, referencePoint.z);

	  cameraUnprojectMatrix.getInverse(cameraProjectMatrix, true);
	  referencePoint.applyMatrix4(cameraUnprojectMatrix);
	  deltaReferencePoint.applyMatrix4(cameraUnprojectMatrix).sub(referencePoint);

	  return deltaReferencePoint;
	};

/***/ },
/* 361 */
/*!*********************************************!*\
  !*** ./src/translators/tools/nodeRotate.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = nodeRotate;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	var _selection = __webpack_require__(/*! ../../modules/selection */ 312);

	var _gizmos = __webpack_require__(/*! ./gizmos */ 359);

	var _getBoundingRadius = __webpack_require__(/*! ./utils/getBoundingRadius */ 362);

	var _getBoundingRadius2 = _interopRequireDefault(_getBoundingRadius);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var min = Math.min,
	    PI = Math.PI,
	    sqrt = Math.sqrt;


	var parentInvMatrix = new THREE.Matrix4();
	var nodeRotationQuaternion = new THREE.Quaternion();
	var nodePosition = new THREE.Vector3();
	var nodeScale = new THREE.Vector3();
	var nodeRotationEuler = new THREE.Euler();
	var cameraPosition = new THREE.Vector3();

	function nodeRotate(store, translator) {
	  var activeAxis = false;

	  return {
	    label: 'Rotate Node',
	    enabled: true,
	    display: {
	      playerTools: false
	    },
	    options: {},

	    tool: {
	      hover: function hover(ev) {
	        if (!this.active) return;
	        activeAxis = (0, _gizmos.highlightAxis)(translator, ev, activeAxis);
	      },

	      drag: function drag(ev) {
	        if (ev.which !== 1 || !this.active || ev.metaKey) return false;

	        return {
	          momentum: !activeAxis,
	          handle: function handle(ev) {
	            rotateNode(store, ev.deltaX, ev.deltaY, activeAxis);
	          }
	        };
	      }
	    },

	    widget: {
	      draw: function draw(manipulatorsObject) {
	        manipulatorsObject.add((0, _gizmos.drawRotateGizmo)());
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      },

	      position: function position(manipulatorsObject) {
	        var selectedNodes = (0, _selection.getSelectedNodes)(store);
	        if (!selectedNodes.length) {
	          manipulatorsObject.visible = false;
	          return;
	        }

	        manipulatorsObject.visible = true;
	        var manipId = selectedNodes[0];
	        var worldTransform = (0, _scene.getWorldTransform)(store, manipId);
	        var position = new THREE.Vector3();
	        position.setFromMatrixPosition(worldTransform);
	        manipulatorsObject.position.set(position.x, position.y, position.z);

	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      }
	    }
	  };
	}

	function rotateNode(store, x, y, restrictToAxis) {
	  var rect = (0, _player.getRect)(store);
	  var selectedNodes = (0, _selection.getSelectedNodes)(store);
	  if (!selectedNodes.length) return;
	  var manipId = selectedNodes[0];
	  var nodeTransform = (0, _scene.getWorldTransform)(store, manipId);
	  if (!nodeTransform) return;

	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	  nodeTransform.decompose(nodePosition, nodeRotationQuaternion, nodeScale);
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);

	  var radius = (0, _getBoundingRadius2.default)(store, manipId);

	  var relativeDelta = new THREE.Vector3().set(2 * x / rect.x / radius, -2 * y / rect.y / radius, 0);

	  if (relativeDelta.length() > 1) relativeDelta.normalize();else if (relativeDelta.length() === 0) return;

	  var delta = relativeDelta.length();
	  relativeDelta.transformDirection(cameraWorldMatrix).multiplyScalar(delta);

	  var objNormal = new THREE.Vector3().subVectors(cameraPosition, nodePosition).normalize();

	  if (restrictToAxis) {
	    var projVector = new THREE.Vector3(0, 0, 0);
	    projVector[restrictToAxis] = 1;
	    relativeDelta.projectOnPlane(projVector);
	    objNormal.projectOnPlane(projVector);
	  }

	  var scaleFactor = sqrt(1 - relativeDelta.lengthSq());
	  relativeDelta.addScaledVector(objNormal, scaleFactor).normalize();
	  var modifyQuaternion = new THREE.Quaternion().setFromUnitVectors(objNormal, relativeDelta);
	  nodeRotationQuaternion.premultiply(modifyQuaternion);

	  nodeTransform.compose(nodePosition, nodeRotationQuaternion, nodeScale);
	  var parentMatrix = (0, _scene.getWorldTransform)(store, (0, _scene.find)(store, { id: manipId, parent: true }));
	  if (parentMatrix) {
	    parentInvMatrix.getInverse(parentMatrix, true);
	    nodeTransform.premultiply(parentInvMatrix);
	  }

	  nodeTransform.decompose(nodePosition, nodeRotationQuaternion, nodeScale);

	  // FIXME: resrictToAxis
	  // console.log('restrictToAxis: ', restrictToAxis);

	  nodeRotationEuler.setFromQuaternion(nodeRotationQuaternion, 'ZYX');
	  store.dispatch((0, _scene.set)({ id: manipId, plug: 'Transform', property: 'rotation' }, nodeRotationEuler.toVector3().multiplyScalar(180 / PI)));
	}

/***/ },
/* 362 */
/*!**********************************************************!*\
  !*** ./src/translators/tools/utils/getBoundingRadius.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getBoundingRadius;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _scene = __webpack_require__(/*! ../../../modules/scene */ 171);

	var _player = __webpack_require__(/*! ../../../modules/player */ 295);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var cameraPosition = new THREE.Vector3();
	var nodePosition = new THREE.Vector3();
	var boundingVector = new THREE.Vector3();
	var boundingSphere = new THREE.Sphere();

	function getBoundingRadius(store, nodeId) {
	  var camera = (0, _player.getThreeCamera)(store);
	  var nodeTransform = (0, _scene.getWorldTransform)(store, nodeId);
	  cameraPosition.setFromMatrixPosition(camera.matrix);

	  var boundingRadius = store.getTranslator().getNodeBoundingBox(nodeId).getBoundingSphere(boundingSphere).radius;
	  boundingVector.subVectors(cameraPosition, nodePosition);
	  boundingVector.z = -boundingVector.length();
	  boundingVector.y = boundingRadius;
	  boundingVector.x = 0;

	  boundingVector.applyMatrix4(camera.projectionMatrix);
	  boundingVector.z = 0;
	  return boundingVector.length();
	}

/***/ },
/* 363 */
/*!********************************************!*\
  !*** ./src/translators/tools/nodeScale.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = nodeScale;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	var _selection = __webpack_require__(/*! ../../modules/selection */ 312);

	var _gizmos = __webpack_require__(/*! ./gizmos */ 359);

	var _getProjectedPoint = __webpack_require__(/*! ./utils/getProjectedPoint */ 360);

	var _getProjectedPoint2 = _interopRequireDefault(_getProjectedPoint);

	var _getBoundingRadius = __webpack_require__(/*! ./utils/getBoundingRadius */ 362);

	var _getBoundingRadius2 = _interopRequireDefault(_getBoundingRadius);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var max = Math.max,
	    pow = Math.pow,
	    PI = Math.PI,
	    sin = Math.sin,
	    min = Math.min,
	    sqrt = Math.sqrt;


	var EPS = 0.000001;

	function nodeScale(store, translator) {
	  var activeAxis = false;

	  return {
	    label: 'Scale Node',
	    enabled: true,
	    display: {
	      playerTools: false
	    },
	    options: {},

	    tool: {
	      hover: function hover(ev) {
	        if (!this.active) return;

	        activeAxis = (0, _gizmos.highlightAxis)(translator, ev, activeAxis);
	      },

	      drag: function drag(ev) {
	        if (ev.which !== 1 || !this.active || ev.metaKey) return false;

	        return {
	          momentum: !activeAxis,
	          handle: function handle(ev) {
	            scaleNode(store, ev, activeAxis);
	          }
	        };
	      }
	    },

	    widget: {
	      draw: function draw(manipulatorsObject) {
	        manipulatorsObject.add((0, _gizmos.drawScaleGizmo)());
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      },

	      position: function position(manipulatorsObject) {
	        var selectedNodes = (0, _selection.getSelectedNodes)(store);
	        if (!selectedNodes.length) {
	          manipulatorsObject.visible = false;
	          return;
	        }

	        manipulatorsObject.visible = true;
	        var manipId = selectedNodes[0];
	        var worldTransform = (0, _scene.getWorldTransform)(store, manipId);
	        var position = new THREE.Vector3();
	        position.setFromMatrixPosition(worldTransform);
	        manipulatorsObject.position.set(position.x, position.y, position.z);

	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      }
	    }
	  };
	}

	function scaleNode(store, ev, restrictToAxis) {
	  var rect = (0, _player.getRect)(store);
	  var selectedNodes = (0, _selection.getSelectedNodes)(store);
	  if (!selectedNodes.length) return;
	  var id = selectedNodes[0];

	  var nodeGraphScale = (0, _scene.get)(store, { id: id, plug: 'Transform', property: 'scale' });
	  if (!nodeGraphScale) return;
	  var radius = max((0, _getBoundingRadius2.default)(store, id), EPS) || EPS;

	  var delta = ev.delta || ev.deltaX / 30 - ev.deltaY / 30;
	  var deltaZoom = max(min(2 * delta / rect.y / radius, 0.001), -0.001);
	  var decayZoomFactor = pow(2, deltaZoom * 100);

	  var nodeMatrix = (0, _scene.getWorldTransform)(store, id);
	  var nodePosition = new THREE.Vector3().setFromMatrixPosition(nodeMatrix);
	  var nodeScale = new THREE.Vector3().copy(nodeGraphScale);
	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);

	  if (!restrictToAxis) {
	    var oldScale = max(nodeScale.length(), EPS);
	    nodeScale.setLength(oldScale * decayZoomFactor);
	  } else {
	    var projVector = new THREE.Vector3(0, 0, 0);
	    projVector[restrictToAxis] = 1;
	    var projectedMouse = (0, _getProjectedPoint2.default)(store, id, ev.deltaX, ev.deltaY);
	    projectedMouse.projectOnVector(projVector);

	    var targToCam = new THREE.Vector3().setFromMatrixPosition(cameraWorldMatrix).sub(nodePosition);
	    var origin = new THREE.Vector3(0, 0, 0);
	    var plane = new THREE.Plane().setFromCoplanarPoints(targToCam, projVector, origin);
	    projectedMouse.projectOnPlane(plane.normal);

	    var camToMove = new THREE.Vector3().subVectors(projectedMouse, targToCam);
	    projectedMouse.projectOnVector(projVector).normalize();
	    var alpha = targToCam.angleTo(projectedMouse);
	    var beta = PI - targToCam.angleTo(camToMove);
	    var gamma = PI - alpha - beta;
	    var axis = targToCam.length() * sin(beta) / sin(gamma);
	    projectedMouse.multiplyScalar(axis);

	    projVector.set(1, 1, 1);

	    projVector[restrictToAxis] = 1 + 2 * projectedMouse[restrictToAxis] / nodeScale[restrictToAxis];
	    nodeScale.multiply(projVector);
	  }

	  // FIXME: restrict axis
	  //console.log('scaleToAxis', restrictToAxis);
	  store.dispatch((0, _scene.set)({ id: id, plug: 'Transform', property: 'scale' }, nodeScale));
	}

/***/ },
/* 364 */
/*!*****************************************!*\
  !*** ./src/translators/tools/select.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = select;

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _selection = __webpack_require__(/*! ../../modules/selection */ 312);

	function select(store, translator) {
	  return {
	    label: 'Select',
	    enabled: true,
	    display: {
	      playerTools: false
	    },
	    options: {},

	    tool: {
	      click: function click(ev) {
	        var nodes = (0, _player.filterNodesFromPosition)(store, ev);
	        if (nodes.length) store.dispatch((0, _selection.selectNode)(nodes[0]));
	      },

	      drag: function drag(ev) {
	        if (ev.which !== 1 || !this.active) return false;

	        return {
	          momentum: false,

	          handle: function handle(ev) {
	            //console.log('drag select', ev.deltaX, ev.deltaY);
	          }
	        };
	      }
	    }
	  };
	};

/***/ },
/* 365 */
/*!*********************************************!*\
  !*** ./src/translators/tools/fullscreen.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = fullscreen;

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	function fullscreen(store, translator) {
	  return {
	    enabled: true,
	    display: true,
	    options: {},

	    isActive: _player.isFullscreen,

	    activate: function activate() {
	      var playerEl = store.getIn(['player', 'playerElement']);
	      ['requestFullscreen', 'webkitRequestFullscreen', 'mozRequestFullScreen', 'msRequestFullscreen'].forEach(function (fn) {
	        if (playerEl[fn]) return playerEl[fn]();
	      });

	      store.dispatch((0, _player.setFullscreen)(true));
	    },

	    deactivate: function deactivate() {
	      ['exitFullscreen', 'webkitExitFullscreen', 'mozCancelFullScreen', 'msExitFullscreen'].forEach(function (fn) {
	        if (document[fn]) return document[fn]();
	      });

	      store.dispatch((0, _player.setFullscreen)(false));
	    }
	  };
	}

/***/ },
/* 366 */
/*!***************************************!*\
  !*** ./src/translators/tools/home.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = home;

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	var _camera = __webpack_require__(/*! ../camera */ 298);

	function home(store, translator) {
	  return {
	    label: 'Home',
	    enabled: true,
	    display: {
	      playerTools: true
	    },
	    options: {},

	    execute: function execute() {
	      var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	      (0, _camera.initCamera)(store, true, playerData && playerData.camera);
	    }
	  };
	}

/***/ },
/* 367 */
/*!*****************************************!*\
  !*** ./src/translators/tools/vrMode.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (store, translator) {
	  var vrEffect = void 0,
	      vrDisplay = void 0,
	      vrReticle = void 0,
	      vrFloor = void 0,
	      vrControls = void 0,
	      hasExternalDisplay = void 0,
	      controller1 = void 0,
	      controller2 = void 0,
	      viveHandler = void 0,
	      mobileNavHandler = void 0,
	      threeVrCamera = void 0,
	      prevMoveMode = void 0;

	  var scene = translator.scene;
	  var camera = translator.camera;

	  var vrCapable = false;
	  if (true) {
	    window.navigator.getVRDisplays().then(function (displays) {
	      if (!displays.length) return;
	      vrDisplay = displays[0];
	      vrCapable = displays[0].capabilities.canPresent;
	      hasExternalDisplay = displays[0].capabilities.hasExternalDisplay;
	      store.dispatch((0, _commands.updateCommand)('vrMode', { enabled: vrCapable }));
	    });
	  }

	  function viveNavHandle(manipulatorsObject) {
	    return function (ev) {
	      console.log('viveNavHandle', !!vrReticle.armObject);
	      if (!vrReticle.armObject) return;

	      var pos = vrReticle.getReticlePosition().clone();
	      pos.y = 0;
	      var vrdpPos = threeVrCamera.position.clone();
	      var offset = pos.addScaledVector(vrControls.offset, 2).sub(vrdpPos);
	      offset.y = 0;
	      vrControls.setOffset(offset);
	    };
	  }

	  function navHandle(manipulatorsObject) {
	    return function (ev) {
	      if (!vrReticle.armObject) return;

	      var cameraId = (0, _player.getCamera)(store);
	      var pos = vrReticle.getReticlePosition().clone();
	      pos.y = 0;
	      manipulatorsObject.position.add(pos);
	      manipulatorsObject.updateMatrix();

	      var newCameraPosition = manipulatorsObject.position.clone();
	      vrControls.setOffset(newCameraPosition);
	      //store.dispatch(merge([cameraId, 'Transform', 0], decompose(newCameraPosition)));
	    };
	  }

	  return {
	    label: 'VR mode',
	    activeLabel: 'Exit VR Mode',

	    enabled: vrCapable,
	    display: {
	      playerTools: true
	    },
	    options: {
	      planeEnabled: false
	    },

	    isActive: _player.isVRMode,

	    widget: {
	      draw: function draw(manipulatorsObject) {
	        var cbgeometry = new THREE.PlaneGeometry(20, 20, 1, 1);
	        var mat = new THREE.MeshBasicMaterial({ color: 0x666666 });
	        mat.transparent = true; //!this.options.planeEnabled;
	        mat.opacity = this.options.planeEnabled ? 1.0 : 0.0;
	        vrFloor = new THREE.Mesh(cbgeometry, mat);
	        vrFloor.rotation.x = -Math.PI * 0.5;

	        vrReticle = new THREE.Reticle(camera);
	        vrReticle.addCollider(vrFloor);

	        manipulatorsObject.add(vrReticle.dot);
	        manipulatorsObject.add(vrFloor);

	        // This floor grid is __UGLY__!
	        manipulatorsObject.add(floorGrid());

	        if (!hasExternalDisplay) {
	          //scene.add(camera);
	          mobileNavHandler = navHandle(manipulatorsObject);
	          window.addEventListener('touchend', mobileNavHandler);
	          manipulatorsObject.add(vrReticle.armObject);
	        } else if (vrControls) {
	          //------Add vive controllers-----------
	          controller1 = new THREE.ViveController(0);
	          controller1.standingMatrix = vrControls.getStandingMatrix();

	          manipulatorsObject.add(controller1);

	          controller2 = new THREE.ViveController(1);
	          controller2.standingMatrix = vrControls.getStandingMatrix();

	          manipulatorsObject.add(controller2);

	          if (controller1.getGamepad()) manipulatorsObject.add(vrReticle.armObject);

	          var loader = new THREE.OBJLoader();
	          loader.setPath('models/');
	          loader.load('vr_controller_vive_1_5.obj', function (object) {
	            var loader = new THREE.TextureLoader();
	            loader.setPath('models/');

	            var controller = object.children[0];
	            var material = new THREE.MeshBasicMaterial();
	            material.map = loader.load('onepointfive_texture.png');
	            material.specularMap = loader.load('onepointfive_spec.png');
	            controller.material = material;

	            controller1.add(object.clone());
	            controller2.add(object.clone());
	          });
	          viveHandler = viveNavHandle(manipulatorsObject);
	          window.addEventListener('thumbpadup', viveHandler);
	        }
	      },

	      remove: function remove(manipulatorsObject) {
	        if (!hasExternalDisplay) {
	          scene.remove(camera);
	          window.removeEventListener('touchend', mobileNavHandler);
	        } else {
	          window.removeEventListener('thumbpadup', viveHandler);
	        }
	      },

	      position: function position(manipulatorsObject) {
	        if (vrControls) {
	          vrControls.update();
	          manipulatorsObject.position.copy(vrControls.offset);
	        }

	        if (threeVrCamera) {
	          threeVrCamera.updateMatrix();
	          matchToCamera(store, threeVrCamera);
	        }

	        vrReticle.update(manipulatorsObject);
	        if (hasExternalDisplay && controller1 && controller2) {
	          controller1.update();
	          controller2.update();
	        }

	        manipulatorsObject.updateMatrix();
	      }
	    },

	    activate: function activate() {
	      var translator = store.getTranslator();
	      var cameraId = (0, _player.getCamera)(store);
	      var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
	      var camPosition = new THREE.Vector3().setFromMatrixPosition(cameraWorldMatrix);
	      var camDirection = new THREE.Vector3(0, 0, -1).transformDirection(cameraWorldMatrix);
	      camDirection.y = 0;
	      var camRotation = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), camDirection.normalize());

	      if (!vrDisplay || !vrDisplay.capabilities.canPresent) return;

	      vrEffect = new _vrEffect2.default(translator.renderer, vrDisplay);
	      translator.externals.vrEffect = vrEffect;

	      hasExternalDisplay = vrDisplay.capabilities.hasExternalDisplay;

	      store.dispatch((0, _player.useVrCamera)(true));
	      // If we have external display, then use vive controls?
	      return vrEffect.requestPresent().then(function () {
	        store.dispatch((0, _commands.activateCommand)('firstPersonMode'));
	        prevMoveMode = (0, _commands.getCommands)(store).firstPersonMode.options.movementMode;
	        store.dispatch((0, _commands.setCommandOptions)('firstPersonMode', { movementMode: 'plane' }));

	        threeVrCamera = translator.camera.clone();
	        vrControls = new _vrControls2.default(threeVrCamera);
	        translator.externals.vrControls = vrControls;
	        vrControls.standing = true;
	        vrControls.resetPose(); // zero orientation controls
	        camPosition.y = 0;
	        vrControls.setOffset(camPosition);
	        vrControls.setRotationalOffset(camRotation);

	        store.dispatch((0, _player.setRenderMode)(_player.RENDER_MODES.vr));
	        store.dispatch((0, _commands.updateCommands)(_commands.MOUSE_CONTROLS, { enabled: false }));

	        store.setRequestAnimationFrame(vrDisplay.requestAnimationFrame, vrDisplay);

	        return vrDisplay;
	      }).catch(function (err) {
	        console.log('Error Activating VR');
	        throw err;
	      });
	    },

	    deactivate: function deactivate() {
	      var translator = store.getTranslator();

	      vrEffect.exitPresent();
	      store.setRequestAnimationFrame();

	      store.dispatch((0, _commands.deactivateCommand)('firstPersonMode'));
	      store.dispatch((0, _commands.setCommandOptions)('firstPersonMode', { movementMode: prevMoveMode }));

	      store.dispatch((0, _player.setRenderMode)(_player.RENDER_MODES.normal));
	      store.dispatch((0, _commands.updateCommands)(_commands.MOUSE_CONTROLS, { enabled: true }));
	      store.dispatch((0, _player.useVrCamera)(false));

	      vrDisplay = null;

	      /*const prevCameraId = getPrevCamera(store);
	      if (prevCameraId) store.dispatch(useCamera(prevCameraId));*/

	      if (!hasExternalDisplay) {
	        //scene.remove(camera);
	        window.removeEventListener('touchend', navHandle);
	      } else {
	        controller1 = null;
	        controller2 = null;
	        //scene.position.set(0, 0, 0);
	        //vrElements.position.set(0, 0, 0);
	        window.removeEventListener('thumbpadup', viveHandler);
	      }

	      vrControls.standing = false;
	      vrReticle.removeCollider(vrFloor);
	      translator.renderer.setScissorTest(false);
	      //vrElements.children = [];
	      //scene.remove(vrElements);
	    }
	  };
	};

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	__webpack_require__(/*! webvr-polyfill */ 368);

	var _vrEffect = __webpack_require__(/*! ../utils/vrEffect */ 369);

	var _vrEffect2 = _interopRequireDefault(_vrEffect);

	__webpack_require__(/*! ../utils/viveController */ 370);

	__webpack_require__(/*! ../utils/objLoader */ 371);

	__webpack_require__(/*! ../utils/reticle */ 372);

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _commands = __webpack_require__(/*! ../../modules/commands */ 305);

	var _decompose = __webpack_require__(/*! ../utils/decompose */ 302);

	var _decompose2 = _interopRequireDefault(_decompose);

	var _vrControls = __webpack_require__(/*! ../utils/vrControls */ 373);

	var _vrControls2 = _interopRequireDefault(_vrControls);

	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 299);

	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 144);

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// extend three with VRControls
	function floorGrid() {
	  // Materials
	  var mat = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 5, depthTest: true });

	  var lineGeometry = new THREE.BufferGeometry();
	  var positions = new Float32Array(80 * 2 * 3);

	  for (var x = -10, i = 0; x < 10; x += 0.5, i++) {
	    positions[i * 6 + 0] = x;
	    positions[i * 6 + 1] = 0;
	    positions[i * 6 + 2] = -10;
	    positions[i * 6 + 3 + 0] = x;
	    positions[i * 6 + 3 + 1] = 0;
	    positions[i * 6 + 3 + 2] = 10;
	  }

	  for (var z = -10, _i = 40; z < 10; z += 0.5, _i++) {
	    positions[_i * 6 + 0] = -10;
	    positions[_i * 6 + 1] = 0;
	    positions[_i * 6 + 2] = z;
	    positions[_i * 6 + 3 + 0] = 10;
	    positions[_i * 6 + 3 + 1] = 0;
	    positions[_i * 6 + 3 + 2] = z;
	  }

	  lineGeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));

	  var mesh = new THREE.LineSegments(lineGeometry, mat);
	  mesh.mode = THREE.LineSegments;
	  //mesh.position.set(0,0.1,0);

	  return mesh;
	} // Extend three with VREffect


	function matchToCamera(store, threeCamera) {
	  var cameraId = (0, _player.getCamera)(store);
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store);
	  var targetPosition = new THREE.Vector3().setFromMatrixPosition(targetWorldMatrix);

	  var length = targetPosition.sub(threeCamera.position).length();
	  targetPosition.set(0, 0, -length).applyQuaternion(threeCamera.quaternion).add(threeCamera.position);
	  var upPosition = new THREE.Vector3(0, 1, 0).applyQuaternion(threeCamera.quaternion);

	  targetWorldMatrix.setPosition(targetPosition);
	  var camData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	  camData.upPosition = upPosition;
	  store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(threeCamera.matrix.clone())));
	  if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
	    store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
	  }
	}

/***/ },
/* 368 */
/*!**************************************************!*\
  !*** ./~/webvr-polyfill/build/webvr-polyfill.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	},{}],2:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var Util = _dereq_('./util.js');
	var WakeLock = _dereq_('./wakelock.js');

	// Start at a higher number to reduce chance of conflict.
	var nextDisplayId = 1000;
	var hasShowDeprecationWarning = false;

	var defaultLeftBounds = [0, 0, 0.5, 1];
	var defaultRightBounds = [0.5, 0, 0.5, 1];

	/**
	 * The base class for all VR frame data.
	 */

	function VRFrameData() {
	  this.leftProjectionMatrix = new Float32Array(16);
	  this.leftViewMatrix = new Float32Array(16);
	  this.rightProjectionMatrix = new Float32Array(16);
	  this.rightViewMatrix = new Float32Array(16);
	  this.pose = null;
	};

	/**
	 * The base class for all VR displays.
	 */
	function VRDisplay() {
	  this.isPolyfilled = true;
	  this.displayId = nextDisplayId++;
	  this.displayName = 'webvr-polyfill displayName';

	  this.depthNear = 0.01;
	  this.depthFar = 10000.0;

	  this.isConnected = true;
	  this.isPresenting = false;
	  this.capabilities = {
	    hasPosition: false,
	    hasOrientation: false,
	    hasExternalDisplay: false,
	    canPresent: false,
	    maxLayers: 1
	  };
	  this.stageParameters = null;

	  // "Private" members.
	  this.waitingForPresent_ = false;
	  this.layer_ = null;

	  this.fullscreenElement_ = null;
	  this.fullscreenWrapper_ = null;
	  this.fullscreenElementCachedStyle_ = null;

	  this.fullscreenEventTarget_ = null;
	  this.fullscreenChangeHandler_ = null;
	  this.fullscreenErrorHandler_ = null;

	  this.wakelock_ = new WakeLock();
	}

	VRDisplay.prototype.getFrameData = function(frameData) {
	  // TODO: Technically this should retain it's value for the duration of a frame
	  // but I doubt that's practical to do in javascript.
	  return Util.frameDataFromPose(frameData, this.getPose(), this);
	};

	VRDisplay.prototype.getPose = function() {
	  // TODO: Technically this should retain it's value for the duration of a frame
	  // but I doubt that's practical to do in javascript.
	  return this.getImmediatePose();
	};

	VRDisplay.prototype.requestAnimationFrame = function(callback) {
	  return window.requestAnimationFrame(callback);
	};

	VRDisplay.prototype.cancelAnimationFrame = function(id) {
	  return window.cancelAnimationFrame(id);
	};

	VRDisplay.prototype.wrapForFullscreen = function(element) {
	  // Don't wrap in iOS.
	  if (Util.isIOS()) {
	    return element;
	  }
	  if (!this.fullscreenWrapper_) {
	    this.fullscreenWrapper_ = document.createElement('div');
	    var cssProperties = [
	      'height: ' + Math.min(screen.height, screen.width) + 'px !important',
	      'top: 0 !important',
	      'left: 0 !important',
	      'right: 0 !important',
	      'border: 0',
	      'margin: 0',
	      'padding: 0',
	      'z-index: 999999 !important',
	      'position: fixed',
	    ];
	    this.fullscreenWrapper_.setAttribute('style', cssProperties.join('; ') + ';');
	    this.fullscreenWrapper_.classList.add('webvr-polyfill-fullscreen-wrapper');
	  }

	  if (this.fullscreenElement_ == element) {
	    return this.fullscreenWrapper_;
	  }

	  // Remove any previously applied wrappers
	  this.removeFullscreenWrapper();

	  this.fullscreenElement_ = element;
	  var parent = this.fullscreenElement_.parentElement;
	  parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
	  parent.removeChild(this.fullscreenElement_);
	  this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
	  this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute('style');

	  var self = this;
	  function applyFullscreenElementStyle() {
	    if (!self.fullscreenElement_) {
	      return;
	    }

	    var cssProperties = [
	      'position: absolute',
	      'top: 0',
	      'left: 0',
	      'width: ' + Math.max(screen.width, screen.height) + 'px',
	      'height: ' + Math.min(screen.height, screen.width) + 'px',
	      'border: 0',
	      'margin: 0',
	      'padding: 0',
	    ];
	    self.fullscreenElement_.setAttribute('style', cssProperties.join('; ') + ';');
	  }

	  applyFullscreenElementStyle();

	  return this.fullscreenWrapper_;
	};

	VRDisplay.prototype.removeFullscreenWrapper = function() {
	  if (!this.fullscreenElement_) {
	    return;
	  }

	  var element = this.fullscreenElement_;
	  if (this.fullscreenElementCachedStyle_) {
	    element.setAttribute('style', this.fullscreenElementCachedStyle_);
	  } else {
	    element.removeAttribute('style');
	  }
	  this.fullscreenElement_ = null;
	  this.fullscreenElementCachedStyle_ = null;

	  var parent = this.fullscreenWrapper_.parentElement;
	  this.fullscreenWrapper_.removeChild(element);
	  parent.insertBefore(element, this.fullscreenWrapper_);
	  parent.removeChild(this.fullscreenWrapper_);

	  return element;
	};

	VRDisplay.prototype.requestPresent = function(layers) {
	  var wasPresenting = this.isPresenting;
	  var self = this;

	  if (!(layers instanceof Array)) {
	    if (!hasShowDeprecationWarning) {
	      console.warn("Using a deprecated form of requestPresent. Should pass in an array of VRLayers.");
	      hasShowDeprecationWarning = true;
	    }
	    layers = [layers];
	  }

	  return new Promise(function(resolve, reject) {
	    if (!self.capabilities.canPresent) {
	      reject(new Error('VRDisplay is not capable of presenting.'));
	      return;
	    }

	    if (layers.length == 0 || layers.length > self.capabilities.maxLayers) {
	      reject(new Error('Invalid number of layers.'));
	      return;
	    }

	    var incomingLayer = layers[0];
	    if (!incomingLayer.source) {
	      /*
	      todo: figure out the correct behavior if the source is not provided.
	      see https://github.com/w3c/webvr/issues/58
	      */
	      resolve();
	      return;
	    }

	    var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
	    var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
	    if (wasPresenting) {
	      // Already presenting, just changing configuration
	      var layer = self.layer_;
	      if (layer.source !== incomingLayer.source) {
	        layer.source = incomingLayer.source;
	      }

	      for (var i = 0; i < 4; i++) {
	        if (layer.leftBounds[i] !== leftBounds[i]) {
	          layer.leftBounds[i] = leftBounds[i];
	        }
	        if (layer.rightBounds[i] !== rightBounds[i]) {
	          layer.rightBounds[i] = rightBounds[i];
	        }
	      }

	      resolve();
	      return;
	    }

	    // Was not already presenting.
	    self.layer_ = {
	      predistorted: incomingLayer.predistorted,
	      source: incomingLayer.source,
	      leftBounds: leftBounds.slice(0),
	      rightBounds: rightBounds.slice(0)
	    };

	    self.waitingForPresent_ = false;
	    if (self.layer_ && self.layer_.source) {
	      var fullscreenElement = self.wrapForFullscreen(self.layer_.source);

	      function onFullscreenChange() {
	        var actualFullscreenElement = Util.getFullscreenElement();

	        self.isPresenting = (fullscreenElement === actualFullscreenElement);
	        if (self.isPresenting) {
	          if (screen.orientation && screen.orientation.lock) {
	            screen.orientation.lock('landscape-primary').catch(function(error){
	                    console.error('screen.orientation.lock() failed due to', error.message)
	            });
	          }
	          self.waitingForPresent_ = false;
	          self.beginPresent_();
	          resolve();
	        } else {
	          if (screen.orientation && screen.orientation.unlock) {
	            screen.orientation.unlock();
	          }
	          self.removeFullscreenWrapper();
	          self.wakelock_.release();
	          self.endPresent_();
	          self.removeFullscreenListeners_();
	        }
	        self.fireVRDisplayPresentChange_();
	      }
	      function onFullscreenError() {
	        if (!self.waitingForPresent_) {
	          return;
	        }

	        self.removeFullscreenWrapper();
	        self.removeFullscreenListeners_();

	        self.wakelock_.release();
	        self.waitingForPresent_ = false;
	        self.isPresenting = false;

	        reject(new Error('Unable to present.'));
	      }

	      self.addFullscreenListeners_(fullscreenElement,
	          onFullscreenChange, onFullscreenError);

	      if (Util.requestFullscreen(fullscreenElement)) {
	        self.wakelock_.request();
	        self.waitingForPresent_ = true;
	      } else if (Util.isIOS()) {
	        // *sigh* Just fake it.
	        self.wakelock_.request();
	        self.isPresenting = true;
	        self.beginPresent_();
	        self.fireVRDisplayPresentChange_();
	        resolve();
	      }
	    }

	    if (!self.waitingForPresent_ && !Util.isIOS()) {
	      Util.exitFullscreen();
	      reject(new Error('Unable to present.'));
	    }
	  });
	};

	VRDisplay.prototype.exitPresent = function() {
	  var wasPresenting = this.isPresenting;
	  var self = this;
	  this.isPresenting = false;
	  this.layer_ = null;
	  this.wakelock_.release();

	  return new Promise(function(resolve, reject) {
	    if (wasPresenting) {
	      if (!Util.exitFullscreen() && Util.isIOS()) {
	        self.endPresent_();
	        self.fireVRDisplayPresentChange_();
	      }

	      resolve();
	    } else {
	      reject(new Error('Was not presenting to VRDisplay.'));
	    }
	  });
	};

	VRDisplay.prototype.getLayers = function() {
	  if (this.layer_) {
	    return [this.layer_];
	  }
	  return [];
	};

	VRDisplay.prototype.fireVRDisplayPresentChange_ = function() {
	  var event = new CustomEvent('vrdisplaypresentchange', {detail: {display: this}});
	  window.dispatchEvent(event);
	};

	VRDisplay.prototype.addFullscreenListeners_ = function(element, changeHandler, errorHandler) {
	  this.removeFullscreenListeners_();

	  this.fullscreenEventTarget_ = element;
	  this.fullscreenChangeHandler_ = changeHandler;
	  this.fullscreenErrorHandler_ = errorHandler;

	  if (changeHandler) {
	    if (document.fullscreenEnabled) {
	      element.addEventListener('fullscreenchange', changeHandler, false);
	    } else if (document.webkitFullscreenEnabled) {
	      element.addEventListener('webkitfullscreenchange', changeHandler, false);
	    } else if (document.mozFullScreenEnabled) {
	      document.addEventListener('mozfullscreenchange', changeHandler, false);
	    } else if (document.msFullscreenEnabled) {
	      element.addEventListener('msfullscreenchange', changeHandler, false);
	    }
	  }

	  if (errorHandler) {
	    if (document.fullscreenEnabled) {
	      element.addEventListener('fullscreenerror', errorHandler, false);
	    } else if (document.webkitFullscreenEnabled) {
	      element.addEventListener('webkitfullscreenerror', errorHandler, false);
	    } else if (document.mozFullScreenEnabled) {
	      document.addEventListener('mozfullscreenerror', errorHandler, false);
	    } else if (document.msFullscreenEnabled) {
	      element.addEventListener('msfullscreenerror', errorHandler, false);
	    }
	  }
	};

	VRDisplay.prototype.removeFullscreenListeners_ = function() {
	  if (!this.fullscreenEventTarget_)
	    return;

	  var element = this.fullscreenEventTarget_;

	  if (this.fullscreenChangeHandler_) {
	    var changeHandler = this.fullscreenChangeHandler_;
	    element.removeEventListener('fullscreenchange', changeHandler, false);
	    element.removeEventListener('webkitfullscreenchange', changeHandler, false);
	    document.removeEventListener('mozfullscreenchange', changeHandler, false);
	    element.removeEventListener('msfullscreenchange', changeHandler, false);
	  }

	  if (this.fullscreenErrorHandler_) {
	    var errorHandler = this.fullscreenErrorHandler_;
	    element.removeEventListener('fullscreenerror', errorHandler, false);
	    element.removeEventListener('webkitfullscreenerror', errorHandler, false);
	    document.removeEventListener('mozfullscreenerror', errorHandler, false);
	    element.removeEventListener('msfullscreenerror', errorHandler, false);
	  }

	  this.fullscreenEventTarget_ = null;
	  this.fullscreenChangeHandler_ = null;
	  this.fullscreenErrorHandler_ = null;
	};

	VRDisplay.prototype.beginPresent_ = function() {
	  // Override to add custom behavior when presentation begins.
	};

	VRDisplay.prototype.endPresent_ = function() {
	  // Override to add custom behavior when presentation ends.
	};

	VRDisplay.prototype.submitFrame = function(pose) {
	  // Override to add custom behavior for frame submission.
	};

	VRDisplay.prototype.getEyeParameters = function(whichEye) {
	  // Override to return accurate eye parameters if canPresent is true.
	  return null;
	};

	/*
	 * Deprecated classes
	 */

	/**
	 * The base class for all VR devices. (Deprecated)
	 */
	function VRDevice() {
	  this.isPolyfilled = true;
	  this.hardwareUnitId = 'webvr-polyfill hardwareUnitId';
	  this.deviceId = 'webvr-polyfill deviceId';
	  this.deviceName = 'webvr-polyfill deviceName';
	}

	/**
	 * The base class for all VR HMD devices. (Deprecated)
	 */
	function HMDVRDevice() {
	}
	HMDVRDevice.prototype = new VRDevice();

	/**
	 * The base class for all VR position sensor devices. (Deprecated)
	 */
	function PositionSensorVRDevice() {
	}
	PositionSensorVRDevice.prototype = new VRDevice();

	module.exports.VRFrameData = VRFrameData;
	module.exports.VRDisplay = VRDisplay;
	module.exports.VRDevice = VRDevice;
	module.exports.HMDVRDevice = HMDVRDevice;
	module.exports.PositionSensorVRDevice = PositionSensorVRDevice;

	},{"./util.js":22,"./wakelock.js":24}],3:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var CardboardUI = _dereq_('./cardboard-ui.js');
	var Util = _dereq_('./util.js');
	var WGLUPreserveGLState = _dereq_('./deps/wglu-preserve-state.js');

	var distortionVS = [
	  'attribute vec2 position;',
	  'attribute vec3 texCoord;',

	  'varying vec2 vTexCoord;',

	  'uniform vec4 viewportOffsetScale[2];',

	  'void main() {',
	  '  vec4 viewport = viewportOffsetScale[int(texCoord.z)];',
	  '  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;',
	  '  gl_Position = vec4( position, 1.0, 1.0 );',
	  '}',
	].join('\n');

	var distortionFS = [
	  'precision mediump float;',
	  'uniform sampler2D diffuse;',

	  'varying vec2 vTexCoord;',

	  'void main() {',
	  '  gl_FragColor = texture2D(diffuse, vTexCoord);',
	  '}',
	].join('\n');

	/**
	 * A mesh-based distorter.
	 */
	function CardboardDistorter(gl) {
	  this.gl = gl;
	  this.ctxAttribs = gl.getContextAttributes();

	  this.meshWidth = 20;
	  this.meshHeight = 20;

	  this.bufferScale = WebVRConfig.BUFFER_SCALE;

	  this.bufferWidth = gl.drawingBufferWidth;
	  this.bufferHeight = gl.drawingBufferHeight;

	  // Patching support
	  this.realBindFramebuffer = gl.bindFramebuffer;
	  this.realEnable = gl.enable;
	  this.realDisable = gl.disable;
	  this.realColorMask = gl.colorMask;
	  this.realClearColor = gl.clearColor;
	  this.realViewport = gl.viewport;

	  if (!Util.isIOS()) {
	    this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'width');
	    this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'height');
	  }

	  this.isPatched = false;

	  // State tracking
	  this.lastBoundFramebuffer = null;
	  this.cullFace = false;
	  this.depthTest = false;
	  this.blend = false;
	  this.scissorTest = false;
	  this.stencilTest = false;
	  this.viewport = [0, 0, 0, 0];
	  this.colorMask = [true, true, true, true];
	  this.clearColor = [0, 0, 0, 0];

	  this.attribs = {
	    position: 0,
	    texCoord: 1
	  };
	  this.program = Util.linkProgram(gl, distortionVS, distortionFS, this.attribs);
	  this.uniforms = Util.getProgramUniforms(gl, this.program);

	  this.viewportOffsetScale = new Float32Array(8);
	  this.setTextureBounds();

	  this.vertexBuffer = gl.createBuffer();
	  this.indexBuffer = gl.createBuffer();
	  this.indexCount = 0;

	  this.renderTarget = gl.createTexture();
	  this.framebuffer = gl.createFramebuffer();

	  this.depthStencilBuffer = null;
	  this.depthBuffer = null;
	  this.stencilBuffer = null;

	  if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
	    this.depthStencilBuffer = gl.createRenderbuffer();
	  } else if (this.ctxAttribs.depth) {
	    this.depthBuffer = gl.createRenderbuffer();
	  } else if (this.ctxAttribs.stencil) {
	    this.stencilBuffer = gl.createRenderbuffer();
	  }

	  this.patch();

	  this.onResize();

	  if (!WebVRConfig.CARDBOARD_UI_DISABLED) {
	    this.cardboardUI = new CardboardUI(gl);
	  }
	};

	/**
	 * Tears down all the resources created by the distorter and removes any
	 * patches.
	 */
	CardboardDistorter.prototype.destroy = function() {
	  var gl = this.gl;

	  this.unpatch();

	  gl.deleteProgram(this.program);
	  gl.deleteBuffer(this.vertexBuffer);
	  gl.deleteBuffer(this.indexBuffer);
	  gl.deleteTexture(this.renderTarget);
	  gl.deleteFramebuffer(this.framebuffer);
	  if (this.depthStencilBuffer) {
	    gl.deleteRenderbuffer(this.depthStencilBuffer);
	  }
	  if (this.depthBuffer) {
	    gl.deleteRenderbuffer(this.depthBuffer);
	  }
	  if (this.stencilBuffer) {
	    gl.deleteRenderbuffer(this.stencilBuffer);
	  }

	  if (this.cardboardUI) {
	    this.cardboardUI.destroy();
	  }
	};


	/**
	 * Resizes the backbuffer to match the canvas width and height.
	 */
	CardboardDistorter.prototype.onResize = function() {
	  var gl = this.gl;
	  var self = this;

	  var glState = [
	    gl.RENDERBUFFER_BINDING,
	    gl.TEXTURE_BINDING_2D, gl.TEXTURE0
	  ];

	  WGLUPreserveGLState(gl, glState, function(gl) {
	    // Bind real backbuffer and clear it once. We don't need to clear it again
	    // after that because we're overwriting the same area every frame.
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);

	    // Put things in a good state
	    if (self.scissorTest) { self.realDisable.call(gl, gl.SCISSOR_TEST); }
	    self.realColorMask.call(gl, true, true, true, true);
	    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	    self.realClearColor.call(gl, 0, 0, 0, 1);

	    gl.clear(gl.COLOR_BUFFER_BIT);

	    // Now bind and resize the fake backbuffer
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.framebuffer);

	    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
	    gl.texImage2D(gl.TEXTURE_2D, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB,
	        self.bufferWidth, self.bufferHeight, 0,
	        self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, gl.UNSIGNED_BYTE, null);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, self.renderTarget, 0);

	    if (self.ctxAttribs.depth && self.ctxAttribs.stencil) {
	      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthStencilBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,
	          self.bufferWidth, self.bufferHeight);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT,
	          gl.RENDERBUFFER, self.depthStencilBuffer);
	    } else if (self.ctxAttribs.depth) {
	      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
	          self.bufferWidth, self.bufferHeight);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
	          gl.RENDERBUFFER, self.depthBuffer);
	    } else if (self.ctxAttribs.stencil) {
	      gl.bindRenderbuffer(gl.RENDERBUFFER, self.stencilBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8,
	          self.bufferWidth, self.bufferHeight);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT,
	          gl.RENDERBUFFER, self.stencilBuffer);
	    }

	    if (!gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
	      console.error('Framebuffer incomplete!');
	    }

	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);

	    if (self.scissorTest) { self.realEnable.call(gl, gl.SCISSOR_TEST); }

	    self.realColorMask.apply(gl, self.colorMask);
	    self.realViewport.apply(gl, self.viewport);
	    self.realClearColor.apply(gl, self.clearColor);
	  });

	  if (this.cardboardUI) {
	    this.cardboardUI.onResize();
	  }
	};

	CardboardDistorter.prototype.patch = function() {
	  if (this.isPatched) {
	    return;
	  }

	  var self = this;
	  var canvas = this.gl.canvas;
	  var gl = this.gl;

	  if (!Util.isIOS()) {
	    canvas.width = Util.getScreenWidth() * this.bufferScale;
	    canvas.height = Util.getScreenHeight() * this.bufferScale;

	    Object.defineProperty(canvas, 'width', {
	      configurable: true,
	      enumerable: true,
	      get: function() {
	        return self.bufferWidth;
	      },
	      set: function(value) {
	        self.bufferWidth = value;
	        self.realCanvasWidth.set.call(canvas, value);
	        self.onResize();
	      }
	    });

	    Object.defineProperty(canvas, 'height', {
	      configurable: true,
	      enumerable: true,
	      get: function() {
	        return self.bufferHeight;
	      },
	      set: function(value) {
	        self.bufferHeight = value;
	        self.realCanvasHeight.set.call(canvas, value);
	        self.onResize();
	      }
	    });
	  }

	  this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);

	  if (this.lastBoundFramebuffer == null) {
	    this.lastBoundFramebuffer = this.framebuffer;
	    this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
	  }

	  this.gl.bindFramebuffer = function(target, framebuffer) {
	    self.lastBoundFramebuffer = framebuffer ? framebuffer : self.framebuffer;
	    // Silently make calls to bind the default framebuffer bind ours instead.
	    self.realBindFramebuffer.call(gl, target, self.lastBoundFramebuffer);
	  };

	  this.cullFace = gl.getParameter(gl.CULL_FACE);
	  this.depthTest = gl.getParameter(gl.DEPTH_TEST);
	  this.blend = gl.getParameter(gl.BLEND);
	  this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
	  this.stencilTest = gl.getParameter(gl.STENCIL_TEST);

	  gl.enable = function(pname) {
	    switch (pname) {
	      case gl.CULL_FACE: self.cullFace = true; break;
	      case gl.DEPTH_TEST: self.depthTest = true; break;
	      case gl.BLEND: self.blend = true; break;
	      case gl.SCISSOR_TEST: self.scissorTest = true; break;
	      case gl.STENCIL_TEST: self.stencilTest = true; break;
	    }
	    self.realEnable.call(gl, pname);
	  };

	  gl.disable = function(pname) {
	    switch (pname) {
	      case gl.CULL_FACE: self.cullFace = false; break;
	      case gl.DEPTH_TEST: self.depthTest = false; break;
	      case gl.BLEND: self.blend = false; break;
	      case gl.SCISSOR_TEST: self.scissorTest = false; break;
	      case gl.STENCIL_TEST: self.stencilTest = false; break;
	    }
	    self.realDisable.call(gl, pname);
	  };

	  this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
	  gl.colorMask = function(r, g, b, a) {
	    self.colorMask[0] = r;
	    self.colorMask[1] = g;
	    self.colorMask[2] = b;
	    self.colorMask[3] = a;
	    self.realColorMask.call(gl, r, g, b, a);
	  };

	  this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
	  gl.clearColor = function(r, g, b, a) {
	    self.clearColor[0] = r;
	    self.clearColor[1] = g;
	    self.clearColor[2] = b;
	    self.clearColor[3] = a;
	    self.realClearColor.call(gl, r, g, b, a);
	  };

	  this.viewport = gl.getParameter(gl.VIEWPORT);
	  gl.viewport = function(x, y, w, h) {
	    self.viewport[0] = x;
	    self.viewport[1] = y;
	    self.viewport[2] = w;
	    self.viewport[3] = h;
	    self.realViewport.call(gl, x, y, w, h);
	  };

	  this.isPatched = true;
	  Util.safariCssSizeWorkaround(canvas);
	};

	CardboardDistorter.prototype.unpatch = function() {
	  if (!this.isPatched) {
	    return;
	  }

	  var gl = this.gl;
	  var canvas = this.gl.canvas;

	  if (!Util.isIOS()) {
	    Object.defineProperty(canvas, 'width', this.realCanvasWidth);
	    Object.defineProperty(canvas, 'height', this.realCanvasHeight);
	  }
	  canvas.width = this.bufferWidth;
	  canvas.height = this.bufferHeight;

	  gl.bindFramebuffer = this.realBindFramebuffer;
	  gl.enable = this.realEnable;
	  gl.disable = this.realDisable;
	  gl.colorMask = this.realColorMask;
	  gl.clearColor = this.realClearColor;
	  gl.viewport = this.realViewport;

	  // Check to see if our fake backbuffer is bound and bind the real backbuffer
	  // if that's the case.
	  if (this.lastBoundFramebuffer == this.framebuffer) {
	    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	  }

	  this.isPatched = false;

	  setTimeout(function() {
	    Util.safariCssSizeWorkaround(canvas);
	  }, 1);
	};

	CardboardDistorter.prototype.setTextureBounds = function(leftBounds, rightBounds) {
	  if (!leftBounds) {
	    leftBounds = [0, 0, 0.5, 1];
	  }

	  if (!rightBounds) {
	    rightBounds = [0.5, 0, 0.5, 1];
	  }

	  // Left eye
	  this.viewportOffsetScale[0] = leftBounds[0]; // X
	  this.viewportOffsetScale[1] = leftBounds[1]; // Y
	  this.viewportOffsetScale[2] = leftBounds[2]; // Width
	  this.viewportOffsetScale[3] = leftBounds[3]; // Height

	  // Right eye
	  this.viewportOffsetScale[4] = rightBounds[0]; // X
	  this.viewportOffsetScale[5] = rightBounds[1]; // Y
	  this.viewportOffsetScale[6] = rightBounds[2]; // Width
	  this.viewportOffsetScale[7] = rightBounds[3]; // Height
	};

	/**
	 * Performs distortion pass on the injected backbuffer, rendering it to the real
	 * backbuffer.
	 */
	CardboardDistorter.prototype.submitFrame = function() {
	  var gl = this.gl;
	  var self = this;

	  var glState = [];

	  if (!WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
	    glState.push(
	      gl.CURRENT_PROGRAM,
	      gl.ARRAY_BUFFER_BINDING,
	      gl.ELEMENT_ARRAY_BUFFER_BINDING,
	      gl.TEXTURE_BINDING_2D, gl.TEXTURE0
	    );
	  }

	  WGLUPreserveGLState(gl, glState, function(gl) {
	    // Bind the real default framebuffer
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);

	    // Make sure the GL state is in a good place
	    if (self.cullFace) { self.realDisable.call(gl, gl.CULL_FACE); }
	    if (self.depthTest) { self.realDisable.call(gl, gl.DEPTH_TEST); }
	    if (self.blend) { self.realDisable.call(gl, gl.BLEND); }
	    if (self.scissorTest) { self.realDisable.call(gl, gl.SCISSOR_TEST); }
	    if (self.stencilTest) { self.realDisable.call(gl, gl.STENCIL_TEST); }
	    self.realColorMask.call(gl, true, true, true, true);
	    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

	    // If the backbuffer has an alpha channel clear every frame so the page
	    // doesn't show through.
	    if (self.ctxAttribs.alpha || Util.isIOS()) {
	      self.realClearColor.call(gl, 0, 0, 0, 1);
	      gl.clear(gl.COLOR_BUFFER_BIT);
	    }

	    // Bind distortion program and mesh
	    gl.useProgram(self.program);

	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);

	    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
	    gl.enableVertexAttribArray(self.attribs.position);
	    gl.enableVertexAttribArray(self.attribs.texCoord);
	    gl.vertexAttribPointer(self.attribs.position, 2, gl.FLOAT, false, 20, 0);
	    gl.vertexAttribPointer(self.attribs.texCoord, 3, gl.FLOAT, false, 20, 8);

	    gl.activeTexture(gl.TEXTURE0);
	    gl.uniform1i(self.uniforms.diffuse, 0);
	    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);

	    gl.uniform4fv(self.uniforms.viewportOffsetScale, self.viewportOffsetScale);

	    // Draws both eyes
	    gl.drawElements(gl.TRIANGLES, self.indexCount, gl.UNSIGNED_SHORT, 0);

	    if (self.cardboardUI) {
	      self.cardboardUI.renderNoState();
	    }

	    // Bind the fake default framebuffer again
	    self.realBindFramebuffer.call(self.gl, gl.FRAMEBUFFER, self.framebuffer);

	    // If preserveDrawingBuffer == false clear the framebuffer
	    if (!self.ctxAttribs.preserveDrawingBuffer) {
	      self.realClearColor.call(gl, 0, 0, 0, 0);
	      gl.clear(gl.COLOR_BUFFER_BIT);
	    }

	    if (!WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
	      self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
	    }

	    // Restore state
	    if (self.cullFace) { self.realEnable.call(gl, gl.CULL_FACE); }
	    if (self.depthTest) { self.realEnable.call(gl, gl.DEPTH_TEST); }
	    if (self.blend) { self.realEnable.call(gl, gl.BLEND); }
	    if (self.scissorTest) { self.realEnable.call(gl, gl.SCISSOR_TEST); }
	    if (self.stencilTest) { self.realEnable.call(gl, gl.STENCIL_TEST); }

	    self.realColorMask.apply(gl, self.colorMask);
	    self.realViewport.apply(gl, self.viewport);
	    if (self.ctxAttribs.alpha || !self.ctxAttribs.preserveDrawingBuffer) {
	      self.realClearColor.apply(gl, self.clearColor);
	    }
	  });

	  // Workaround for the fact that Safari doesn't allow us to patch the canvas
	  // width and height correctly. After each submit frame check to see what the
	  // real backbuffer size has been set to and resize the fake backbuffer size
	  // to match.
	  if (Util.isIOS()) {
	    var canvas = gl.canvas;
	    if (canvas.width != self.bufferWidth || canvas.height != self.bufferHeight) {
	      self.bufferWidth = canvas.width;
	      self.bufferHeight = canvas.height;
	      self.onResize();
	    }
	  }
	};

	/**
	 * Call when the deviceInfo has changed. At this point we need
	 * to re-calculate the distortion mesh.
	 */
	CardboardDistorter.prototype.updateDeviceInfo = function(deviceInfo) {
	  var gl = this.gl;
	  var self = this;

	  var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
	  WGLUPreserveGLState(gl, glState, function(gl) {
	    var vertices = self.computeMeshVertices_(self.meshWidth, self.meshHeight, deviceInfo);
	    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

	    // Indices don't change based on device parameters, so only compute once.
	    if (!self.indexCount) {
	      var indices = self.computeMeshIndices_(self.meshWidth, self.meshHeight);
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
	      self.indexCount = indices.length;
	    }
	  });
	};

	/**
	 * Build the distortion mesh vertices.
	 * Based on code from the Unity cardboard plugin.
	 */
	CardboardDistorter.prototype.computeMeshVertices_ = function(width, height, deviceInfo) {
	  var vertices = new Float32Array(2 * width * height * 5);

	  var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
	  var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
	  var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
	  var vidx = 0;
	  var iidx = 0;
	  for (var e = 0; e < 2; e++) {
	    for (var j = 0; j < height; j++) {
	      for (var i = 0; i < width; i++, vidx++) {
	        var u = i / (width - 1);
	        var v = j / (height - 1);

	        // Grid points regularly spaced in StreoScreen, and barrel distorted in
	        // the mesh.
	        var s = u;
	        var t = v;
	        var x = Util.lerp(lensFrustum[0], lensFrustum[2], u);
	        var y = Util.lerp(lensFrustum[3], lensFrustum[1], v);
	        var d = Math.sqrt(x * x + y * y);
	        var r = deviceInfo.distortion.distortInverse(d);
	        var p = x * r / d;
	        var q = y * r / d;
	        u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
	        v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);

	        // Convert u,v to mesh screen coordinates.
	        var aspect = deviceInfo.device.widthMeters / deviceInfo.device.heightMeters;

	        // FIXME: The original Unity plugin multiplied U by the aspect ratio
	        // and didn't multiply either value by 2, but that seems to get it
	        // really close to correct looking for me. I hate this kind of "Don't
	        // know why it works" code though, and wold love a more logical
	        // explanation of what needs to happen here.
	        u = (viewport.x + u * viewport.width - 0.5) * 2.0; //* aspect;
	        v = (viewport.y + v * viewport.height - 0.5) * 2.0;

	        vertices[(vidx * 5) + 0] = u; // position.x
	        vertices[(vidx * 5) + 1] = v; // position.y
	        vertices[(vidx * 5) + 2] = s; // texCoord.x
	        vertices[(vidx * 5) + 3] = t; // texCoord.y
	        vertices[(vidx * 5) + 4] = e; // texCoord.z (viewport index)
	      }
	    }
	    var w = lensFrustum[2] - lensFrustum[0];
	    lensFrustum[0] = -(w + lensFrustum[0]);
	    lensFrustum[2] = w - lensFrustum[2];
	    w = noLensFrustum[2] - noLensFrustum[0];
	    noLensFrustum[0] = -(w + noLensFrustum[0]);
	    noLensFrustum[2] = w - noLensFrustum[2];
	    viewport.x = 1 - (viewport.x + viewport.width);
	  }
	  return vertices;
	}

	/**
	 * Build the distortion mesh indices.
	 * Based on code from the Unity cardboard plugin.
	 */
	CardboardDistorter.prototype.computeMeshIndices_ = function(width, height) {
	  var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
	  var halfwidth = width / 2;
	  var halfheight = height / 2;
	  var vidx = 0;
	  var iidx = 0;
	  for (var e = 0; e < 2; e++) {
	    for (var j = 0; j < height; j++) {
	      for (var i = 0; i < width; i++, vidx++) {
	        if (i == 0 || j == 0)
	          continue;
	        // Build a quad.  Lower right and upper left quadrants have quads with
	        // the triangle diagonal flipped to get the vignette to interpolate
	        // correctly.
	        if ((i <= halfwidth) == (j <= halfheight)) {
	          // Quad diagonal lower left to upper right.
	          indices[iidx++] = vidx;
	          indices[iidx++] = vidx - width - 1;
	          indices[iidx++] = vidx - width;
	          indices[iidx++] = vidx - width - 1;
	          indices[iidx++] = vidx;
	          indices[iidx++] = vidx - 1;
	        } else {
	          // Quad diagonal upper left to lower right.
	          indices[iidx++] = vidx - 1;
	          indices[iidx++] = vidx - width;
	          indices[iidx++] = vidx;
	          indices[iidx++] = vidx - width;
	          indices[iidx++] = vidx - 1;
	          indices[iidx++] = vidx - width - 1;
	        }
	      }
	    }
	  }
	  return indices;
	};

	CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function(proto, attrName) {
	  var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
	  // In some cases (ahem... Safari), the descriptor returns undefined get and
	  // set fields. In this case, we need to create a synthetic property
	  // descriptor. This works around some of the issues in
	  // https://github.com/borismus/webvr-polyfill/issues/46
	  if (descriptor.get === undefined || descriptor.set === undefined) {
	    descriptor.configurable = true;
	    descriptor.enumerable = true;
	    descriptor.get = function() {
	      return this.getAttribute(attrName);
	    };
	    descriptor.set = function(val) {
	      this.setAttribute(attrName, val);
	    };
	  }
	  return descriptor;
	};

	module.exports = CardboardDistorter;

	},{"./cardboard-ui.js":4,"./deps/wglu-preserve-state.js":6,"./util.js":22}],4:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var Util = _dereq_('./util.js');
	var WGLUPreserveGLState = _dereq_('./deps/wglu-preserve-state.js');

	var uiVS = [
	  'attribute vec2 position;',

	  'uniform mat4 projectionMat;',

	  'void main() {',
	  '  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );',
	  '}',
	].join('\n');

	var uiFS = [
	  'precision mediump float;',

	  'uniform vec4 color;',

	  'void main() {',
	  '  gl_FragColor = color;',
	  '}',
	].join('\n');

	var DEG2RAD = Math.PI/180.0;

	// The gear has 6 identical sections, each spanning 60 degrees.
	var kAnglePerGearSection = 60;

	// Half-angle of the span of the outer rim.
	var kOuterRimEndAngle = 12;

	// Angle between the middle of the outer rim and the start of the inner rim.
	var kInnerRimBeginAngle = 20;

	// Distance from center to outer rim, normalized so that the entire model
	// fits in a [-1, 1] x [-1, 1] square.
	var kOuterRadius = 1;

	// Distance from center to depressed rim, in model units.
	var kMiddleRadius = 0.75;

	// Radius of the inner hollow circle, in model units.
	var kInnerRadius = 0.3125;

	// Center line thickness in DP.
	var kCenterLineThicknessDp = 4;

	// Button width in DP.
	var kButtonWidthDp = 28;

	// Factor to scale the touch area that responds to the touch.
	var kTouchSlopFactor = 1.5;

	var Angles = [
	  0, kOuterRimEndAngle, kInnerRimBeginAngle,
	  kAnglePerGearSection - kInnerRimBeginAngle,
	  kAnglePerGearSection - kOuterRimEndAngle
	];

	/**
	 * Renders the alignment line and "options" gear. It is assumed that the canvas
	 * this is rendered into covers the entire screen (or close to it.)
	 */
	function CardboardUI(gl) {
	  this.gl = gl;

	  this.attribs = {
	    position: 0
	  };
	  this.program = Util.linkProgram(gl, uiVS, uiFS, this.attribs);
	  this.uniforms = Util.getProgramUniforms(gl, this.program);

	  this.vertexBuffer = gl.createBuffer();
	  this.gearOffset = 0;
	  this.gearVertexCount = 0;
	  this.arrowOffset = 0;
	  this.arrowVertexCount = 0;

	  this.projMat = new Float32Array(16);

	  this.listener = null;

	  this.onResize();
	};

	/**
	 * Tears down all the resources created by the UI renderer.
	 */
	CardboardUI.prototype.destroy = function() {
	  var gl = this.gl;

	  if (this.listener) {
	    gl.canvas.removeEventListener('click', this.listener, false);
	  }

	  gl.deleteProgram(this.program);
	  gl.deleteBuffer(this.vertexBuffer);
	};

	/**
	 * Adds a listener to clicks on the gear and back icons
	 */
	CardboardUI.prototype.listen = function(optionsCallback, backCallback) {
	  var canvas = this.gl.canvas;
	  this.listener = function(event) {
	    var midline = canvas.clientWidth / 2;
	    var buttonSize = kButtonWidthDp * kTouchSlopFactor;
	    // Check to see if the user clicked on (or around) the gear icon
	    if (event.clientX > midline - buttonSize &&
	        event.clientX < midline + buttonSize &&
	        event.clientY > canvas.clientHeight - buttonSize) {
	      optionsCallback(event);
	    }
	    // Check to see if the user clicked on (or around) the back icon
	    else if (event.clientX < buttonSize && event.clientY < buttonSize) {
	      backCallback(event);
	    }
	  };
	  canvas.addEventListener('click', this.listener, false);
	};

	/**
	 * Builds the UI mesh.
	 */
	CardboardUI.prototype.onResize = function() {
	  var gl = this.gl;
	  var self = this;

	  var glState = [
	    gl.ARRAY_BUFFER_BINDING
	  ];

	  WGLUPreserveGLState(gl, glState, function(gl) {
	    var vertices = [];

	    var midline = gl.drawingBufferWidth / 2;

	    // Assumes your canvas width and height is scaled proportionately.
	    // TODO(smus): The following causes buttons to become huge on iOS, but seems
	    // like the right thing to do. For now, added a hack. But really, investigate why.
	    var dps = (gl.drawingBufferWidth / (screen.width * window.devicePixelRatio));
	    if (!Util.isIOS()) {
	      dps *= window.devicePixelRatio;
	    }

	    var lineWidth = kCenterLineThicknessDp * dps / 2;
	    var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
	    var buttonScale = kButtonWidthDp * dps / 2;
	    var buttonBorder = ((kButtonWidthDp * kTouchSlopFactor) - kButtonWidthDp) * dps;

	    // Build centerline
	    vertices.push(midline - lineWidth, buttonSize);
	    vertices.push(midline - lineWidth, gl.drawingBufferHeight);
	    vertices.push(midline + lineWidth, buttonSize);
	    vertices.push(midline + lineWidth, gl.drawingBufferHeight);

	    // Build gear
	    self.gearOffset = (vertices.length / 2);

	    function addGearSegment(theta, r) {
	      var angle = (90 - theta) * DEG2RAD;
	      var x = Math.cos(angle);
	      var y = Math.sin(angle);
	      vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
	      vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
	    }

	    for (var i = 0; i <= 6; i++) {
	      var segmentTheta = i * kAnglePerGearSection;

	      addGearSegment(segmentTheta, kOuterRadius);
	      addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
	      addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
	      addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
	      addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
	    }

	    self.gearVertexCount = (vertices.length / 2) - self.gearOffset;

	    // Build back arrow
	    self.arrowOffset = (vertices.length / 2);

	    function addArrowVertex(x, y) {
	      vertices.push(buttonBorder + x, gl.drawingBufferHeight - buttonBorder - y);
	    }

	    var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);

	    addArrowVertex(0, buttonScale);
	    addArrowVertex(buttonScale, 0);
	    addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
	    addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);

	    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
	    addArrowVertex(0, buttonScale);
	    addArrowVertex(buttonScale, buttonScale * 2);
	    addArrowVertex(buttonScale + angledLineWidth, (buttonScale * 2) - angledLineWidth);

	    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
	    addArrowVertex(0, buttonScale);

	    addArrowVertex(angledLineWidth, buttonScale - lineWidth);
	    addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
	    addArrowVertex(angledLineWidth, buttonScale + lineWidth);
	    addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);

	    self.arrowVertexCount = (vertices.length / 2) - self.arrowOffset;

	    // Buffer data
	    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	  });
	};

	/**
	 * Performs distortion pass on the injected backbuffer, rendering it to the real
	 * backbuffer.
	 */
	CardboardUI.prototype.render = function() {
	  var gl = this.gl;
	  var self = this;

	  var glState = [
	    gl.CULL_FACE,
	    gl.DEPTH_TEST,
	    gl.BLEND,
	    gl.SCISSOR_TEST,
	    gl.STENCIL_TEST,
	    gl.COLOR_WRITEMASK,
	    gl.VIEWPORT,

	    gl.CURRENT_PROGRAM,
	    gl.ARRAY_BUFFER_BINDING
	  ];

	  WGLUPreserveGLState(gl, glState, function(gl) {
	    // Make sure the GL state is in a good place
	    gl.disable(gl.CULL_FACE);
	    gl.disable(gl.DEPTH_TEST);
	    gl.disable(gl.BLEND);
	    gl.disable(gl.SCISSOR_TEST);
	    gl.disable(gl.STENCIL_TEST);
	    gl.colorMask(true, true, true, true);
	    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

	    self.renderNoState();
	  });
	};

	CardboardUI.prototype.renderNoState = function() {
	  var gl = this.gl;

	  // Bind distortion program and mesh
	  gl.useProgram(this.program);

	  gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	  gl.enableVertexAttribArray(this.attribs.position);
	  gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);

	  gl.uniform4f(this.uniforms.color, 1.0, 1.0, 1.0, 1.0);

	  Util.orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024.0);
	  gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);

	  // Draws UI element
	  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	  gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
	  gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
	};

	module.exports = CardboardUI;

	},{"./deps/wglu-preserve-state.js":6,"./util.js":22}],5:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var CardboardDistorter = _dereq_('./cardboard-distorter.js');
	var CardboardUI = _dereq_('./cardboard-ui.js');
	var DeviceInfo = _dereq_('./device-info.js');
	var Dpdb = _dereq_('./dpdb/dpdb.js');
	var FusionPoseSensor = _dereq_('./sensor-fusion/fusion-pose-sensor.js');
	var RotateInstructions = _dereq_('./rotate-instructions.js');
	var ViewerSelector = _dereq_('./viewer-selector.js');
	var VRDisplay = _dereq_('./base.js').VRDisplay;
	var Util = _dereq_('./util.js');

	var Eye = {
	  LEFT: 'left',
	  RIGHT: 'right'
	};

	/**
	 * VRDisplay based on mobile device parameters and DeviceMotion APIs.
	 */
	function CardboardVRDisplay() {
	  this.displayName = 'Cardboard VRDisplay (webvr-polyfill)';

	  this.capabilities.hasOrientation = true;
	  this.capabilities.canPresent = true;

	  // "Private" members.
	  this.bufferScale_ = WebVRConfig.BUFFER_SCALE;
	  this.poseSensor_ = new FusionPoseSensor();
	  this.distorter_ = null;
	  this.cardboardUI_ = null;

	  this.dpdb_ = new Dpdb(true, this.onDeviceParamsUpdated_.bind(this));
	  this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams());

	  this.viewerSelector_ = new ViewerSelector();
	  this.viewerSelector_.on('change', this.onViewerChanged_.bind(this));

	  // Set the correct initial viewer.
	  this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());

	  if (!WebVRConfig.ROTATE_INSTRUCTIONS_DISABLED) {
	    this.rotateInstructions_ = new RotateInstructions();
	  }

	  if (Util.isIOS()) {
	    // Listen for resize events to workaround this awful Safari bug.
	    window.addEventListener('resize', this.onResize_.bind(this));
	  }
	}
	CardboardVRDisplay.prototype = new VRDisplay();

	CardboardVRDisplay.prototype.getImmediatePose = function() {
	  return {
	    position: this.poseSensor_.getPosition(),
	    orientation: this.poseSensor_.getOrientation(),
	    linearVelocity: null,
	    linearAcceleration: null,
	    angularVelocity: null,
	    angularAcceleration: null
	  };
	};

	CardboardVRDisplay.prototype.resetPose = function() {
	  this.poseSensor_.resetPose();
	};

	CardboardVRDisplay.prototype.getEyeParameters = function(whichEye) {
	  var offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0.0, 0.0];
	  var fieldOfView;

	  // TODO: FoV can be a little expensive to compute. Cache when device params change.
	  if (whichEye == Eye.LEFT) {
	    offset[0] *= -1.0;
	    fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
	  } else if (whichEye == Eye.RIGHT) {
	    fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
	  } else {
	    console.error('Invalid eye provided: %s', whichEye);
	    return null;
	  }

	  return {
	    fieldOfView: fieldOfView,
	    offset: offset,
	    // TODO: Should be able to provide better values than these.
	    renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
	    renderHeight: this.deviceInfo_.device.height * this.bufferScale_,
	  };
	};

	CardboardVRDisplay.prototype.onDeviceParamsUpdated_ = function(newParams) {
	  console.log('DPDB reported that device params were updated.');
	  this.deviceInfo_.updateDeviceParams(newParams);

	  if (this.distorter_) {
	    this.distorter_.updateDeviceInfo(this.deviceInfo_);
	  }
	};

	CardboardVRDisplay.prototype.updateBounds_ = function () {
	  if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
	    this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
	  }
	};

	CardboardVRDisplay.prototype.beginPresent_ = function() {
	  var gl = this.layer_.source.getContext('webgl');
	  if (!gl)
	    gl = this.layer_.source.getContext('experimental-webgl');
	  if (!gl)
	    gl = this.layer_.source.getContext('webgl2');

	  if (!gl)
	    return; // Can't do distortion without a WebGL context.

	  // Provides a way to opt out of distortion
	  if (this.layer_.predistorted) {
	    if (!WebVRConfig.CARDBOARD_UI_DISABLED) {
	      gl.canvas.width = Util.getScreenWidth() * this.bufferScale_;
	      gl.canvas.height = Util.getScreenHeight() * this.bufferScale_;
	      this.cardboardUI_ = new CardboardUI(gl);
	    }
	  } else {
	    // Create a new distorter for the target context
	    this.distorter_ = new CardboardDistorter(gl);
	    this.distorter_.updateDeviceInfo(this.deviceInfo_);
	    this.cardboardUI_ = this.distorter_.cardboardUI;
	  }

	  if (this.cardboardUI_) {
	    this.cardboardUI_.listen(function(e) {
	      // Options clicked.
	      this.viewerSelector_.show(this.layer_.source.parentElement);
	      e.stopPropagation();
	      e.preventDefault();
	    }.bind(this), function(e) {
	      // Back clicked.
	      this.exitPresent();
	      e.stopPropagation();
	      e.preventDefault();
	    }.bind(this));
	  }

	  if (this.rotateInstructions_) {
	    if (Util.isLandscapeMode() && Util.isMobile()) {
	      // In landscape mode, temporarily show the "put into Cardboard"
	      // interstitial. Otherwise, do the default thing.
	      this.rotateInstructions_.showTemporarily(3000, this.layer_.source.parentElement);
	    } else {
	      this.rotateInstructions_.update();
	    }
	  }

	  // Listen for orientation change events in order to show interstitial.
	  this.orientationHandler = this.onOrientationChange_.bind(this);
	  window.addEventListener('orientationchange', this.orientationHandler);

	  // Listen for present display change events in order to update distorter dimensions
	  this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
	  window.addEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);

	  // Fire this event initially, to give geometry-distortion clients the chance
	  // to do something custom.
	  this.fireVRDisplayDeviceParamsChange_();
	};

	CardboardVRDisplay.prototype.endPresent_ = function() {
	  if (this.distorter_) {
	    this.distorter_.destroy();
	    this.distorter_ = null;
	  }
	  if (this.cardboardUI_) {
	    this.cardboardUI_.destroy();
	    this.cardboardUI_ = null;
	  }

	  if (this.rotateInstructions_) {
	    this.rotateInstructions_.hide();
	  }
	  this.viewerSelector_.hide();

	  window.removeEventListener('orientationchange', this.orientationHandler);
	  window.removeEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
	};

	CardboardVRDisplay.prototype.submitFrame = function(pose) {
	  if (this.distorter_) {
	    this.distorter_.submitFrame();
	  } else if (this.cardboardUI_ && this.layer_) {
	    // Hack for predistorted: true.
	    var canvas = this.layer_.source.getContext('webgl').canvas;
	    if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
	      this.cardboardUI_.onResize();
	    }
	    this.lastWidth = canvas.width;
	    this.lastHeight = canvas.height;

	    // Render the Cardboard UI.
	    this.cardboardUI_.render();
	  }
	};

	CardboardVRDisplay.prototype.onOrientationChange_ = function(e) {
	  console.log('onOrientationChange_');

	  // Hide the viewer selector.
	  this.viewerSelector_.hide();

	  // Update the rotate instructions.
	  if (this.rotateInstructions_) {
	    this.rotateInstructions_.update();
	  }

	  this.onResize_();
	};

	CardboardVRDisplay.prototype.onResize_ = function(e) {
	  if (this.layer_) {
	    var gl = this.layer_.source.getContext('webgl');
	    // Size the CSS canvas.
	    // Added padding on right and bottom because iPhone 5 will not
	    // hide the URL bar unless content is bigger than the screen.
	    // This will not be visible as long as the container element (e.g. body)
	    // is set to 'overflow: hidden'.
	    var cssProperties = [
	      'position: absolute',
	      'top: 0',
	      'left: 0',
	      'width: ' + Math.max(screen.width, screen.height) + 'px',
	      'height: ' + Math.min(screen.height, screen.width) + 'px',
	      'border: 0',
	      'margin: 0',
	      'padding: 0 10px 10px 0',
	    ];
	    gl.canvas.setAttribute('style', cssProperties.join('; ') + ';');

	    Util.safariCssSizeWorkaround(gl.canvas);
	  }
	};

	CardboardVRDisplay.prototype.onViewerChanged_ = function(viewer) {
	  this.deviceInfo_.setViewer(viewer);

	  if (this.distorter_) {
	    // Update the distortion appropriately.
	    this.distorter_.updateDeviceInfo(this.deviceInfo_);
	  }

	  // Fire a new event containing viewer and device parameters for clients that
	  // want to implement their own geometry-based distortion.
	  this.fireVRDisplayDeviceParamsChange_();
	};

	CardboardVRDisplay.prototype.fireVRDisplayDeviceParamsChange_ = function() {
	  var event = new CustomEvent('vrdisplaydeviceparamschange', {
	    detail: {
	      vrdisplay: this,
	      deviceInfo: this.deviceInfo_,
	    }
	  });
	  window.dispatchEvent(event);
	};

	module.exports = CardboardVRDisplay;

	},{"./base.js":2,"./cardboard-distorter.js":3,"./cardboard-ui.js":4,"./device-info.js":7,"./dpdb/dpdb.js":11,"./rotate-instructions.js":16,"./sensor-fusion/fusion-pose-sensor.js":18,"./util.js":22,"./viewer-selector.js":23}],6:[function(_dereq_,module,exports){
	/*
	Copyright (c) 2016, Brandon Jones.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/

	/*
	Caches specified GL state, runs a callback, and restores the cached state when
	done.

	Example usage:

	var savedState = [
	  gl.ARRAY_BUFFER_BINDING,

	  // TEXTURE_BINDING_2D or _CUBE_MAP must always be followed by the texure unit.
	  gl.TEXTURE_BINDING_2D, gl.TEXTURE0,

	  gl.CLEAR_COLOR,
	];
	// After this call the array buffer, texture unit 0, active texture, and clear
	// color will be restored. The viewport will remain changed, however, because
	// gl.VIEWPORT was not included in the savedState list.
	WGLUPreserveGLState(gl, savedState, function(gl) {
	  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ARRAY_BUFFER, ....);

	  gl.activeTexture(gl.TEXTURE0);
	  gl.bindTexture(gl.TEXTURE_2D, texture);
	  gl.texImage2D(gl.TEXTURE_2D, ...);

	  gl.clearColor(1, 0, 0, 1);
	  gl.clear(gl.COLOR_BUFFER_BIT);
	});

	Note that this is not intended to be fast. Managing state in your own code to
	avoid redundant state setting and querying will always be faster. This function
	is most useful for cases where you may not have full control over the WebGL
	calls being made, such as tooling or effect injectors.
	*/

	function WGLUPreserveGLState(gl, bindings, callback) {
	  if (!bindings) {
	    callback(gl);
	    return;
	  }

	  var boundValues = [];

	  var activeTexture = null;
	  for (var i = 0; i < bindings.length; ++i) {
	    var binding = bindings[i];
	    switch (binding) {
	      case gl.TEXTURE_BINDING_2D:
	      case gl.TEXTURE_BINDING_CUBE_MAP:
	        var textureUnit = bindings[++i];
	        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
	          console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
	          boundValues.push(null, null);
	          break;
	        }
	        if (!activeTexture) {
	          activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
	        }
	        gl.activeTexture(textureUnit);
	        boundValues.push(gl.getParameter(binding), null);
	        break;
	      case gl.ACTIVE_TEXTURE:
	        activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
	        boundValues.push(null);
	        break;
	      default:
	        boundValues.push(gl.getParameter(binding));
	        break;
	    }
	  }

	  callback(gl);

	  for (var i = 0; i < bindings.length; ++i) {
	    var binding = bindings[i];
	    var boundValue = boundValues[i];
	    switch (binding) {
	      case gl.ACTIVE_TEXTURE:
	        break; // Ignore this binding, since we special-case it to happen last.
	      case gl.ARRAY_BUFFER_BINDING:
	        gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
	        break;
	      case gl.COLOR_CLEAR_VALUE:
	        gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
	        break;
	      case gl.COLOR_WRITEMASK:
	        gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
	        break;
	      case gl.CURRENT_PROGRAM:
	        gl.useProgram(boundValue);
	        break;
	      case gl.ELEMENT_ARRAY_BUFFER_BINDING:
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
	        break;
	      case gl.FRAMEBUFFER_BINDING:
	        gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
	        break;
	      case gl.RENDERBUFFER_BINDING:
	        gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
	        break;
	      case gl.TEXTURE_BINDING_2D:
	        var textureUnit = bindings[++i];
	        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
	          break;
	        gl.activeTexture(textureUnit);
	        gl.bindTexture(gl.TEXTURE_2D, boundValue);
	        break;
	      case gl.TEXTURE_BINDING_CUBE_MAP:
	        var textureUnit = bindings[++i];
	        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
	          break;
	        gl.activeTexture(textureUnit);
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
	        break;
	      case gl.VIEWPORT:
	        gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
	        break;
	      case gl.BLEND:
	      case gl.CULL_FACE:
	      case gl.DEPTH_TEST:
	      case gl.SCISSOR_TEST:
	      case gl.STENCIL_TEST:
	        if (boundValue) {
	          gl.enable(binding);
	        } else {
	          gl.disable(binding);
	        }
	        break;
	      default:
	        console.log("No GL restore behavior for 0x" + binding.toString(16));
	        break;
	    }

	    if (activeTexture) {
	      gl.activeTexture(activeTexture);
	    }
	  }
	}

	module.exports = WGLUPreserveGLState;
	},{}],7:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var Distortion = _dereq_('./distortion/distortion.js');
	var MathUtil = _dereq_('./math-util.js');
	var Util = _dereq_('./util.js');

	function Device(params) {
	  this.width = params.width || Util.getScreenWidth();
	  this.height = params.height || Util.getScreenHeight();
	  this.widthMeters = params.widthMeters;
	  this.heightMeters = params.heightMeters;
	  this.bevelMeters = params.bevelMeters;
	}


	// Fallback Android device (based on Nexus 5 measurements) for use when
	// we can't recognize an Android device.
	var DEFAULT_ANDROID = new Device({
	  widthMeters: 0.110,
	  heightMeters: 0.062,
	  bevelMeters: 0.004
	});

	// Fallback iOS device (based on iPhone6) for use when
	// we can't recognize an Android device.
	var DEFAULT_IOS = new Device({
	  widthMeters: 0.1038,
	  heightMeters: 0.0584,
	  bevelMeters: 0.004
	});


	var Viewers = {
	  CardboardV1: new CardboardViewer({
	    id: 'CardboardV1',
	    label: 'Cardboard I/O 2014',
	    fov: 40,
	    interLensDistance: 0.060,
	    baselineLensDistance: 0.035,
	    screenLensDistance: 0.042,
	    distortionCoefficients: [0.441, 0.156],
	    inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139,
	      -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841,
	      0.0651772, -0.01488963, 0.001559834]
	  }),
	  CardboardV2: new CardboardViewer({
	    id: 'CardboardV2',
	    label: 'Cardboard I/O 2015',
	    fov: 60,
	    interLensDistance: 0.064,
	    baselineLensDistance: 0.035,
	    screenLensDistance: 0.039,
	    distortionCoefficients: [0.34, 0.55],
	    inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051,
	      1.0560602, -0.58208317, 0.21609078, -0.05444823, 0.009177956,
	      -9.904169E-4, 6.183535E-5, -1.6981803E-6]
	  })
	};


	var DEFAULT_LEFT_CENTER = {x: 0.5, y: 0.5};
	var DEFAULT_RIGHT_CENTER = {x: 0.5, y: 0.5};

	/**
	 * Manages information about the device and the viewer.
	 *
	 * deviceParams indicates the parameters of the device to use (generally
	 * obtained from dpdb.getDeviceParams()). Can be null to mean no device
	 * params were found.
	 */
	function DeviceInfo(deviceParams) {
	  this.viewer = Viewers.CardboardV2;
	  this.updateDeviceParams(deviceParams);
	  this.distortion = new Distortion(this.viewer.distortionCoefficients);
	}

	DeviceInfo.prototype.updateDeviceParams = function(deviceParams) {
	  this.device = this.determineDevice_(deviceParams) || this.device;
	};

	DeviceInfo.prototype.getDevice = function() {
	  return this.device;
	};

	DeviceInfo.prototype.setViewer = function(viewer) {
	  this.viewer = viewer;
	  this.distortion = new Distortion(this.viewer.distortionCoefficients);
	};

	DeviceInfo.prototype.determineDevice_ = function(deviceParams) {
	  if (!deviceParams) {
	    // No parameters, so use a default.
	    if (Util.isIOS()) {
	      console.warn('Using fallback iOS device measurements.');
	      return DEFAULT_IOS;
	    } else {
	      console.warn('Using fallback Android device measurements.');
	      return DEFAULT_ANDROID;
	    }
	  }

	  // Compute device screen dimensions based on deviceParams.
	  var METERS_PER_INCH = 0.0254;
	  var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
	  var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
	  var width = Util.getScreenWidth();
	  var height = Util.getScreenHeight();
	  return new Device({
	    widthMeters: metersPerPixelX * width,
	    heightMeters: metersPerPixelY * height,
	    bevelMeters: deviceParams.bevelMm * 0.001,
	  });
	};

	/**
	 * Calculates field of view for the left eye.
	 */
	DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function() {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;

	  // Device.height and device.width for device in portrait mode, so transpose.
	  var eyeToScreenDistance = viewer.screenLensDistance;

	  var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
	  var innerDist = viewer.interLensDistance / 2;
	  var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
	  var topDist = device.heightMeters - bottomDist;

	  var outerAngle = MathUtil.radToDeg * Math.atan(
	      distortion.distort(outerDist / eyeToScreenDistance));
	  var innerAngle = MathUtil.radToDeg * Math.atan(
	      distortion.distort(innerDist / eyeToScreenDistance));
	  var bottomAngle = MathUtil.radToDeg * Math.atan(
	      distortion.distort(bottomDist / eyeToScreenDistance));
	  var topAngle = MathUtil.radToDeg * Math.atan(
	      distortion.distort(topDist / eyeToScreenDistance));

	  return {
	    leftDegrees: Math.min(outerAngle, viewer.fov),
	    rightDegrees: Math.min(innerAngle, viewer.fov),
	    downDegrees: Math.min(bottomAngle, viewer.fov),
	    upDegrees: Math.min(topAngle, viewer.fov)
	  };
	};

	/**
	 * Calculates the tan-angles from the maximum FOV for the left eye for the
	 * current device and screen parameters.
	 */
	DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function() {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;

	  // Tan-angles from the max FOV.
	  var fovLeft = Math.tan(-MathUtil.degToRad * viewer.fov);
	  var fovTop = Math.tan(MathUtil.degToRad * viewer.fov);
	  var fovRight = Math.tan(MathUtil.degToRad * viewer.fov);
	  var fovBottom = Math.tan(-MathUtil.degToRad * viewer.fov);
	  // Viewport size.
	  var halfWidth = device.widthMeters / 4;
	  var halfHeight = device.heightMeters / 2;
	  // Viewport center, measured from left lens position.
	  var verticalLensOffset = (viewer.baselineLensDistance - device.bevelMeters - halfHeight);
	  var centerX = viewer.interLensDistance / 2 - halfWidth;
	  var centerY = -verticalLensOffset;
	  var centerZ = viewer.screenLensDistance;
	  // Tan-angles of the viewport edges, as seen through the lens.
	  var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
	  var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
	  var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
	  var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
	  // Compare the two sets of tan-angles and take the value closer to zero on each side.
	  var result = new Float32Array(4);
	  result[0] = Math.max(fovLeft, screenLeft);
	  result[1] = Math.min(fovTop, screenTop);
	  result[2] = Math.min(fovRight, screenRight);
	  result[3] = Math.max(fovBottom, screenBottom);
	  return result;
	};

	/**
	 * Calculates the tan-angles from the maximum FOV for the left eye for the
	 * current device and screen parameters, assuming no lenses.
	 */
	DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function() {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;

	  var result = new Float32Array(4);
	  // Tan-angles from the max FOV.
	  var fovLeft = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
	  var fovTop = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
	  var fovRight = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
	  var fovBottom = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
	  // Viewport size.
	  var halfWidth = device.widthMeters / 4;
	  var halfHeight = device.heightMeters / 2;
	  // Viewport center, measured from left lens position.
	  var verticalLensOffset = (viewer.baselineLensDistance - device.bevelMeters - halfHeight);
	  var centerX = viewer.interLensDistance / 2 - halfWidth;
	  var centerY = -verticalLensOffset;
	  var centerZ = viewer.screenLensDistance;
	  // Tan-angles of the viewport edges, as seen through the lens.
	  var screenLeft = (centerX - halfWidth) / centerZ;
	  var screenTop = (centerY + halfHeight) / centerZ;
	  var screenRight = (centerX + halfWidth) / centerZ;
	  var screenBottom = (centerY - halfHeight) / centerZ;
	  // Compare the two sets of tan-angles and take the value closer to zero on each side.
	  result[0] = Math.max(fovLeft, screenLeft);
	  result[1] = Math.min(fovTop, screenTop);
	  result[2] = Math.min(fovRight, screenRight);
	  result[3] = Math.max(fovBottom, screenBottom);
	  return result;
	};

	/**
	 * Calculates the screen rectangle visible from the left eye for the
	 * current device and screen parameters.
	 */
	DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function(undistortedFrustum) {
	  var viewer = this.viewer;
	  var device = this.device;

	  var dist = viewer.screenLensDistance;
	  var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
	  var eyeY = viewer.baselineLensDistance - device.bevelMeters;
	  var left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters;
	  var top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters;
	  var right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters;
	  var bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
	  return {
	    x: left,
	    y: bottom,
	    width: right - left,
	    height: top - bottom
	  };
	};

	DeviceInfo.prototype.getFieldOfViewLeftEye = function(opt_isUndistorted) {
	  return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() :
	      this.getDistortedFieldOfViewLeftEye();
	};

	DeviceInfo.prototype.getFieldOfViewRightEye = function(opt_isUndistorted) {
	  var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
	  return {
	    leftDegrees: fov.rightDegrees,
	    rightDegrees: fov.leftDegrees,
	    upDegrees: fov.upDegrees,
	    downDegrees: fov.downDegrees
	  };
	};

	/**
	 * Calculates undistorted field of view for the left eye.
	 */
	DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function() {
	  var p = this.getUndistortedParams_();

	  return {
	    leftDegrees: MathUtil.radToDeg * Math.atan(p.outerDist),
	    rightDegrees: MathUtil.radToDeg * Math.atan(p.innerDist),
	    downDegrees: MathUtil.radToDeg * Math.atan(p.bottomDist),
	    upDegrees: MathUtil.radToDeg * Math.atan(p.topDist)
	  };
	};

	DeviceInfo.prototype.getUndistortedViewportLeftEye = function() {
	  var p = this.getUndistortedParams_();
	  var viewer = this.viewer;
	  var device = this.device;

	  // Distances stored in local variables are in tan-angle units unless otherwise
	  // noted.
	  var eyeToScreenDistance = viewer.screenLensDistance;
	  var screenWidth = device.widthMeters / eyeToScreenDistance;
	  var screenHeight = device.heightMeters / eyeToScreenDistance;
	  var xPxPerTanAngle = device.width / screenWidth;
	  var yPxPerTanAngle = device.height / screenHeight;

	  var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
	  var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
	  return {
	    x: x,
	    y: y,
	    width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
	    height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
	  };
	};

	DeviceInfo.prototype.getUndistortedParams_ = function() {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;

	  // Most of these variables in tan-angle units.
	  var eyeToScreenDistance = viewer.screenLensDistance;
	  var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
	  var screenWidth = device.widthMeters / eyeToScreenDistance;
	  var screenHeight = device.heightMeters / eyeToScreenDistance;

	  var eyePosX = screenWidth / 2 - halfLensDistance;
	  var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;

	  var maxFov = viewer.fov;
	  var viewerMax = distortion.distortInverse(Math.tan(MathUtil.degToRad * maxFov));
	  var outerDist = Math.min(eyePosX, viewerMax);
	  var innerDist = Math.min(halfLensDistance, viewerMax);
	  var bottomDist = Math.min(eyePosY, viewerMax);
	  var topDist = Math.min(screenHeight - eyePosY, viewerMax);

	  return {
	    outerDist: outerDist,
	    innerDist: innerDist,
	    topDist: topDist,
	    bottomDist: bottomDist,
	    eyePosX: eyePosX,
	    eyePosY: eyePosY
	  };
	};


	function CardboardViewer(params) {
	  // A machine readable ID.
	  this.id = params.id;
	  // A human readable label.
	  this.label = params.label;

	  // Field of view in degrees (per side).
	  this.fov = params.fov;

	  // Distance between lens centers in meters.
	  this.interLensDistance = params.interLensDistance;
	  // Distance between viewer baseline and lens center in meters.
	  this.baselineLensDistance = params.baselineLensDistance;
	  // Screen-to-lens distance in meters.
	  this.screenLensDistance = params.screenLensDistance;

	  // Distortion coefficients.
	  this.distortionCoefficients = params.distortionCoefficients;
	  // Inverse distortion coefficients.
	  // TODO: Calculate these from distortionCoefficients in the future.
	  this.inverseCoefficients = params.inverseCoefficients;
	}

	// Export viewer information.
	DeviceInfo.Viewers = Viewers;
	module.exports = DeviceInfo;

	},{"./distortion/distortion.js":9,"./math-util.js":14,"./util.js":22}],8:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var VRDisplay = _dereq_('./base.js').VRDisplay;
	var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;
	var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;

	/**
	 * Wraps a VRDisplay and exposes it as a HMDVRDevice
	 */
	function VRDisplayHMDDevice(display) {
	  this.display = display;

	  this.hardwareUnitId = display.displayId;
	  this.deviceId = 'webvr-polyfill:HMD:' + display.displayId;
	  this.deviceName = display.displayName + ' (HMD)';
	}
	VRDisplayHMDDevice.prototype = new HMDVRDevice();

	VRDisplayHMDDevice.prototype.getEyeParameters = function(whichEye) {
	  var eyeParameters = this.display.getEyeParameters(whichEye);

	  return {
	    currentFieldOfView: eyeParameters.fieldOfView,
	    maximumFieldOfView: eyeParameters.fieldOfView,
	    minimumFieldOfView: eyeParameters.fieldOfView,
	    recommendedFieldOfView: eyeParameters.fieldOfView,
	    eyeTranslation: { x: eyeParameters.offset[0], y: eyeParameters.offset[1], z: eyeParameters.offset[2] },
	    renderRect: {
	      x: (whichEye == 'right') ? eyeParameters.renderWidth : 0,
	      y: 0,
	      width: eyeParameters.renderWidth,
	      height: eyeParameters.renderHeight
	    }
	  };
	};

	VRDisplayHMDDevice.prototype.setFieldOfView =
	    function(opt_fovLeft, opt_fovRight, opt_zNear, opt_zFar) {
	  // Not supported. getEyeParameters reports that the min, max, and recommended
	  // FoV is all the same, so no adjustment can be made.
	};

	// TODO: Need to hook requestFullscreen to see if a wrapped VRDisplay was passed
	// in as an option. If so we should prevent the default fullscreen behavior and
	// call VRDisplay.requestPresent instead.

	/**
	 * Wraps a VRDisplay and exposes it as a PositionSensorVRDevice
	 */
	function VRDisplayPositionSensorDevice(display) {
	  this.display = display;

	  this.hardwareUnitId = display.displayId;
	  this.deviceId = 'webvr-polyfill:PositionSensor: ' + display.displayId;
	  this.deviceName = display.displayName + ' (PositionSensor)';
	}
	VRDisplayPositionSensorDevice.prototype = new PositionSensorVRDevice();

	VRDisplayPositionSensorDevice.prototype.getState = function() {
	  var pose = this.display.getPose();
	  return {
	    position: pose.position ? { x: pose.position[0], y: pose.position[1], z: pose.position[2] } : null,
	    orientation: pose.orientation ? { x: pose.orientation[0], y: pose.orientation[1], z: pose.orientation[2], w: pose.orientation[3] } : null,
	    linearVelocity: null,
	    linearAcceleration: null,
	    angularVelocity: null,
	    angularAcceleration: null
	  };
	};

	VRDisplayPositionSensorDevice.prototype.resetState = function() {
	  return this.positionDevice.resetPose();
	};


	module.exports.VRDisplayHMDDevice = VRDisplayHMDDevice;
	module.exports.VRDisplayPositionSensorDevice = VRDisplayPositionSensorDevice;


	},{"./base.js":2}],9:[function(_dereq_,module,exports){
	/**
	 * TODO(smus): Implement coefficient inversion.
	 */
	function Distortion(coefficients) {
	  this.coefficients = coefficients;
	}

	/**
	 * Calculates the inverse distortion for a radius.
	 * </p><p>
	 * Allows to compute the original undistorted radius from a distorted one.
	 * See also getApproximateInverseDistortion() for a faster but potentially
	 * less accurate method.
	 *
	 * @param {Number} radius Distorted radius from the lens center in tan-angle units.
	 * @return {Number} The undistorted radius in tan-angle units.
	 */
	Distortion.prototype.distortInverse = function(radius) {
	  // Secant method.
	  var r0 = 0;
	  var r1 = 1;
	  var dr0 = radius - this.distort(r0);
	  while (Math.abs(r1 - r0) > 0.0001 /** 0.1mm */) {
	    var dr1 = radius - this.distort(r1);
	    var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
	    r0 = r1;
	    r1 = r2;
	    dr0 = dr1;
	  }
	  return r1;
	};

	/**
	 * Distorts a radius by its distortion factor from the center of the lenses.
	 *
	 * @param {Number} radius Radius from the lens center in tan-angle units.
	 * @return {Number} The distorted radius in tan-angle units.
	 */
	Distortion.prototype.distort = function(radius) {
	  var r2 = radius * radius;
	  var ret = 0;
	  for (var i = 0; i < this.coefficients.length; i++) {
	    ret = r2 * (ret + this.coefficients[i]);
	  }
	  return (ret + 1) * radius;
	};

	// Functions below roughly ported from
	// https://github.com/googlesamples/cardboard-unity/blob/master/Cardboard/Scripts/CardboardProfile.cs#L412

	// Solves a small linear equation via destructive gaussian
	// elimination and back substitution.  This isn't generic numeric
	// code, it's just a quick hack to work with the generally
	// well-behaved symmetric matrices for least-squares fitting.
	// Not intended for reuse.
	//
	// @param a Input positive definite symmetrical matrix. Destroyed
	//     during calculation.
	// @param y Input right-hand-side values. Destroyed during calculation.
	// @return Resulting x value vector.
	//
	Distortion.prototype.solveLinear_ = function(a, y) {
	  var n = a.length;

	  // Gaussian elimination (no row exchange) to triangular matrix.
	  // The input matrix is a A^T A product which should be a positive
	  // definite symmetrical matrix, and if I remember my linear
	  // algebra right this implies that the pivots will be nonzero and
	  // calculations sufficiently accurate without needing row
	  // exchange.
	  for (var j = 0; j < n - 1; ++j) {
	    for (var k = j + 1; k < n; ++k) {
	      var p = a[j][k] / a[j][j];
	      for (var i = j + 1; i < n; ++i) {
	        a[i][k] -= p * a[i][j];
	      }
	      y[k] -= p * y[j];
	    }
	  }
	  // From this point on, only the matrix elements a[j][i] with i>=j are
	  // valid. The elimination doesn't fill in eliminated 0 values.

	  var x = new Array(n);

	  // Back substitution.
	  for (var j = n - 1; j >= 0; --j) {
	    var v = y[j];
	    for (var i = j + 1; i < n; ++i) {
	      v -= a[i][j] * x[i];
	    }
	    x[j] = v / a[j][j];
	  }

	  return x;
	};

	// Solves a least-squares matrix equation.  Given the equation A * x = y, calculate the
	// least-square fit x = inverse(A * transpose(A)) * transpose(A) * y.  The way this works
	// is that, while A is typically not a square matrix (and hence not invertible), A * transpose(A)
	// is always square.  That is:
	//   A * x = y
	//   transpose(A) * (A * x) = transpose(A) * y   <- multiply both sides by transpose(A)
	//   (transpose(A) * A) * x = transpose(A) * y   <- associativity
	//   x = inverse(transpose(A) * A) * transpose(A) * y  <- solve for x
	// Matrix A's row count (first index) must match y's value count.  A's column count (second index)
	// determines the length of the result vector x.
	Distortion.prototype.solveLeastSquares_ = function(matA, vecY) {
	  var i, j, k, sum;
	  var numSamples = matA.length;
	  var numCoefficients = matA[0].length;
	  if (numSamples != vecY.Length) {
	    throw new Error("Matrix / vector dimension mismatch");
	  }

	  // Calculate transpose(A) * A
	  var matATA = new Array(numCoefficients);
	  for (k = 0; k < numCoefficients; ++k) {
	    matATA[k] = new Array(numCoefficients);
	    for (j = 0; j < numCoefficients; ++j) {
	      sum = 0;
	      for (i = 0; i < numSamples; ++i) {
	        sum += matA[j][i] * matA[k][i];
	      }
	      matATA[k][j] = sum;
	    }
	  }

	  // Calculate transpose(A) * y
	  var vecATY = new Array(numCoefficients);
	  for (j = 0; j < numCoefficients; ++j) {
	    sum = 0;
	    for (i = 0; i < numSamples; ++i) {
	      sum += matA[j][i] * vecY[i];
	    }
	    vecATY[j] = sum;
	  }

	  // Now solve (A * transpose(A)) * x = transpose(A) * y.
	  return this.solveLinear_(matATA, vecATY);
	};

	/// Calculates an approximate inverse to the given radial distortion parameters.
	Distortion.prototype.approximateInverse = function(maxRadius, numSamples) {
	  maxRadius = maxRadius || 1;
	  numSamples = numSamples || 100;
	  var numCoefficients = 6;
	  var i, j;

	  // R + K1*R^3 + K2*R^5 = r, with R = rp = distort(r)
	  // Repeating for numSamples:
	  //   [ R0^3, R0^5 ] * [ K1 ] = [ r0 - R0 ]
	  //   [ R1^3, R1^5 ]   [ K2 ]   [ r1 - R1 ]
	  //   [ R2^3, R2^5 ]            [ r2 - R2 ]
	  //   [ etc... ]                [ etc... ]
	  // That is:
	  //   matA * [K1, K2] = y
	  // Solve:
	  //   [K1, K2] = inverse(transpose(matA) * matA) * transpose(matA) * y
	  var matA = new Array(numCoefficients);
	  for (j = 0; j < numCoefficients; ++j) {
	    matA[j] = new Array(numSamples);
	  }
	  var vecY = new Array(numSamples);

	  for (i = 0; i < numSamples; ++i) {
	    var r = maxRadius * (i + 1) / numSamples;
	    var rp = this.distort(r);
	    var v = rp;
	    for (j = 0; j < numCoefficients; ++j) {
	      v *= rp * rp;
	      matA[j][i] = v;
	    }
	    vecY[i] = r - rp;
	  }

	  var inverseCoefficients = this.solveLeastSquares_(matA, vecY);

	  return new Distortion(inverseCoefficients);
	};

	module.exports = Distortion;

	},{}],10:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/**
	 * DPDB cache.
	 */
	var DPDB_CACHE = {
	  "format": 1,
	  "last_updated": "2016-01-20T00:18:35Z",
	  "devices": [

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "asus/*/Nexus 7/*" },
	      { "ua": "Nexus 7" }
	    ],
	    "dpi": [ 320.8, 323.0 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "asus/*/ASUS_Z00AD/*" },
	      { "ua": "ASUS_Z00AD" }
	    ],
	    "dpi": [ 403.0, 404.6 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC6435LVW/*" },
	      { "ua": "HTC6435LVW" }
	    ],
	    "dpi": [ 449.7, 443.3 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC One XL/*" },
	      { "ua": "HTC One XL" }
	    ],
	    "dpi": [ 315.3, 314.6 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "htc/*/Nexus 9/*" },
	      { "ua": "Nexus 9" }
	    ],
	    "dpi": 289.0,
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC One M9/*" },
	      { "ua": "HTC One M9" }
	    ],
	    "dpi": [ 442.5, 443.3 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC One_M8/*" },
	      { "ua": "HTC One_M8" }
	    ],
	    "dpi": [ 449.7, 447.4 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC One/*" },
	      { "ua": "HTC One" }
	    ],
	    "dpi": 472.8,
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Huawei/*/Nexus 6P/*" },
	      { "ua": "Nexus 6P" }
	    ],
	    "dpi": [ 515.1, 518.0 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/Nexus 5X/*" },
	      { "ua": "Nexus 5X" }
	    ],
	    "dpi": [ 422.0, 419.9 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LGMS345/*" },
	      { "ua": "LGMS345" }
	    ],
	    "dpi": [ 221.7, 219.1 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LG-D800/*" },
	      { "ua": "LG-D800" }
	    ],
	    "dpi": [ 422.0, 424.1 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LG-D850/*" },
	      { "ua": "LG-D850" }
	    ],
	    "dpi": [ 537.9, 541.9 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/VS985 4G/*" },
	      { "ua": "VS985 4G" }
	    ],
	    "dpi": [ 537.9, 535.6 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/Nexus 5/*" },
	      { "ua": "Nexus 5 " }
	    ],
	    "dpi": [ 442.4, 444.8 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/Nexus 4/*" },
	      { "ua": "Nexus 4" }
	    ],
	    "dpi": [ 319.8, 318.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LG-P769/*" },
	      { "ua": "LG-P769" }
	    ],
	    "dpi": [ 240.6, 247.5 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LGMS323/*" },
	      { "ua": "LGMS323" }
	    ],
	    "dpi": [ 206.6, 204.6 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LGLS996/*" },
	      { "ua": "LGLS996" }
	    ],
	    "dpi": [ 403.4, 401.5 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Micromax/*/4560MMX/*" },
	      { "ua": "4560MMX" }
	    ],
	    "dpi": [ 240.0, 219.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Micromax/*/A250/*" },
	      { "ua": "Micromax A250" }
	    ],
	    "dpi": [ 480.0, 446.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Micromax/*/Micromax AQ4501/*" },
	      { "ua": "Micromax AQ4501" }
	    ],
	    "dpi": 240.0,
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/DROID RAZR/*" },
	      { "ua": "DROID RAZR" }
	    ],
	    "dpi": [ 368.1, 256.7 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT830C/*" },
	      { "ua": "XT830C" }
	    ],
	    "dpi": [ 254.0, 255.9 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1021/*" },
	      { "ua": "XT1021" }
	    ],
	    "dpi": [ 254.0, 256.7 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1023/*" },
	      { "ua": "XT1023" }
	    ],
	    "dpi": [ 254.0, 256.7 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1028/*" },
	      { "ua": "XT1028" }
	    ],
	    "dpi": [ 326.6, 327.6 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1034/*" },
	      { "ua": "XT1034" }
	    ],
	    "dpi": [ 326.6, 328.4 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1053/*" },
	      { "ua": "XT1053" }
	    ],
	    "dpi": [ 315.3, 316.1 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1562/*" },
	      { "ua": "XT1562" }
	    ],
	    "dpi": [ 403.4, 402.7 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/Nexus 6/*" },
	      { "ua": "Nexus 6 " }
	    ],
	    "dpi": [ 494.3, 489.7 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1063/*" },
	      { "ua": "XT1063" }
	    ],
	    "dpi": [ 295.0, 296.6 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1064/*" },
	      { "ua": "XT1064" }
	    ],
	    "dpi": [ 295.0, 295.6 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1092/*" },
	      { "ua": "XT1092" }
	    ],
	    "dpi": [ 422.0, 424.1 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1095/*" },
	      { "ua": "XT1095" }
	    ],
	    "dpi": [ 422.0, 423.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "OnePlus/*/A0001/*" },
	      { "ua": "A0001" }
	    ],
	    "dpi": [ 403.4, 401.0 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "OnePlus/*/ONE E1005/*" },
	      { "ua": "ONE E1005" }
	    ],
	    "dpi": [ 442.4, 441.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "OnePlus/*/ONE A2005/*" },
	      { "ua": "ONE A2005" }
	    ],
	    "dpi": [ 391.9, 405.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "OPPO/*/X909/*" },
	      { "ua": "X909" }
	    ],
	    "dpi": [ 442.4, 444.1 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9082/*" },
	      { "ua": "GT-I9082" }
	    ],
	    "dpi": [ 184.7, 185.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G360P/*" },
	      { "ua": "SM-G360P" }
	    ],
	    "dpi": [ 196.7, 205.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/Nexus S/*" },
	      { "ua": "Nexus S" }
	    ],
	    "dpi": [ 234.5, 229.8 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9300/*" },
	      { "ua": "GT-I9300" }
	    ],
	    "dpi": [ 304.8, 303.9 ],
	    "bw": 5,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-T230NU/*" },
	      { "ua": "SM-T230NU" }
	    ],
	    "dpi": 216.0,
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SGH-T399/*" },
	      { "ua": "SGH-T399" }
	    ],
	    "dpi": [ 217.7, 231.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-N9005/*" },
	      { "ua": "SM-N9005" }
	    ],
	    "dpi": [ 386.4, 387.0 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SAMSUNG-SM-N900A/*" },
	      { "ua": "SAMSUNG-SM-N900A" }
	    ],
	    "dpi": [ 386.4, 387.7 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9500/*" },
	      { "ua": "GT-I9500" }
	    ],
	    "dpi": [ 442.5, 443.3 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9505/*" },
	      { "ua": "GT-I9505" }
	    ],
	    "dpi": 439.4,
	    "bw": 4,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G900F/*" },
	      { "ua": "SM-G900F" }
	    ],
	    "dpi": [ 415.6, 431.6 ],
	    "bw": 5,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G900M/*" },
	      { "ua": "SM-G900M" }
	    ],
	    "dpi": [ 415.6, 431.6 ],
	    "bw": 5,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G800F/*" },
	      { "ua": "SM-G800F" }
	    ],
	    "dpi": 326.8,
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G906S/*" },
	      { "ua": "SM-G906S" }
	    ],
	    "dpi": [ 562.7, 572.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9300/*" },
	      { "ua": "GT-I9300" }
	    ],
	    "dpi": [ 306.7, 304.8 ],
	    "bw": 5,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-T535/*" },
	      { "ua": "SM-T535" }
	    ],
	    "dpi": [ 142.6, 136.4 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-N920C/*" },
	      { "ua": "SM-N920C" }
	    ],
	    "dpi": [ 515.1, 518.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9300I/*" },
	      { "ua": "GT-I9300I" }
	    ],
	    "dpi": [ 304.8, 305.8 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9195/*" },
	      { "ua": "GT-I9195" }
	    ],
	    "dpi": [ 249.4, 256.7 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SPH-L520/*" },
	      { "ua": "SPH-L520" }
	    ],
	    "dpi": [ 249.4, 255.9 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SAMSUNG-SGH-I717/*" },
	      { "ua": "SAMSUNG-SGH-I717" }
	    ],
	    "dpi": 285.8,
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SPH-D710/*" },
	      { "ua": "SPH-D710" }
	    ],
	    "dpi": [ 217.7, 204.2 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-N7100/*" },
	      { "ua": "GT-N7100" }
	    ],
	    "dpi": 265.1,
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SCH-I605/*" },
	      { "ua": "SCH-I605" }
	    ],
	    "dpi": 265.1,
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/Galaxy Nexus/*" },
	      { "ua": "Galaxy Nexus" }
	    ],
	    "dpi": [ 315.3, 314.2 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-N910H/*" },
	      { "ua": "SM-N910H" }
	    ],
	    "dpi": [ 515.1, 518.0 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-N910C/*" },
	      { "ua": "SM-N910C" }
	    ],
	    "dpi": [ 515.2, 520.2 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G130M/*" },
	      { "ua": "SM-G130M" }
	    ],
	    "dpi": [ 165.9, 164.8 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G928I/*" },
	      { "ua": "SM-G928I" }
	    ],
	    "dpi": [ 515.1, 518.4 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G920F/*" },
	      { "ua": "SM-G920F" }
	    ],
	    "dpi": 580.6,
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G920P/*" },
	      { "ua": "SM-G920P" }
	    ],
	    "dpi": [ 522.5, 577.0 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G925F/*" },
	      { "ua": "SM-G925F" }
	    ],
	    "dpi": 580.6,
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G925V/*" },
	      { "ua": "SM-G925V" }
	    ],
	    "dpi": [ 522.5, 576.6 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/C6903/*" },
	      { "ua": "C6903" }
	    ],
	    "dpi": [ 442.5, 443.3 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/D6653/*" },
	      { "ua": "D6653" }
	    ],
	    "dpi": [ 428.6, 427.6 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/E6653/*" },
	      { "ua": "E6653" }
	    ],
	    "dpi": [ 428.6, 425.7 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/E6853/*" },
	      { "ua": "E6853" }
	    ],
	    "dpi": [ 403.4, 401.9 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/SGP321/*" },
	      { "ua": "SGP321" }
	    ],
	    "dpi": [ 224.7, 224.1 ],
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "TCT/*/ALCATEL ONE TOUCH Fierce/*" },
	      { "ua": "ALCATEL ONE TOUCH Fierce" }
	    ],
	    "dpi": [ 240.0, 247.5 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "THL/*/thl 5000/*" },
	      { "ua": "thl 5000" }
	    ],
	    "dpi": [ 480.0, 443.3 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "ZTE/*/ZTE Blade L2/*" },
	      { "ua": "ZTE Blade L2" }
	    ],
	    "dpi": 240.0,
	    "bw": 3,
	    "ac": 500
	  },

	  {
	    "type": "ios",
	    "rules": [ { "res": [ 640, 960 ] } ],
	    "dpi": [ 325.1, 328.4 ],
	    "bw": 4,
	    "ac": 1000
	  },

	  {
	    "type": "ios",
	    "rules": [ { "res": [ 640, 960 ] } ],
	    "dpi": [ 325.1, 328.4 ],
	    "bw": 4,
	    "ac": 1000
	  },

	  {
	    "type": "ios",
	    "rules": [ { "res": [ 640, 1136 ] } ],
	    "dpi": [ 317.1, 320.2 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "ios",
	    "rules": [ { "res": [ 640, 1136 ] } ],
	    "dpi": [ 317.1, 320.2 ],
	    "bw": 3,
	    "ac": 1000
	  },

	  {
	    "type": "ios",
	    "rules": [ { "res": [ 750, 1334 ] } ],
	    "dpi": 326.4,
	    "bw": 4,
	    "ac": 1000
	  },

	  {
	    "type": "ios",
	    "rules": [ { "res": [ 750, 1334 ] } ],
	    "dpi": 326.4,
	    "bw": 4,
	    "ac": 1000
	  },

	  {
	    "type": "ios",
	    "rules": [ { "res": [ 1242, 2208 ] } ],
	    "dpi": [ 453.6, 458.4 ],
	    "bw": 4,
	    "ac": 1000
	  },

	  {
	    "type": "ios",
	    "rules": [ { "res": [ 1242, 2208 ] } ],
	    "dpi": [ 453.6, 458.4 ],
	    "bw": 4,
	    "ac": 1000
	  }
	]};

	module.exports = DPDB_CACHE;

	},{}],11:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	// Offline cache of the DPDB, to be used until we load the online one (and
	// as a fallback in case we can't load the online one).
	var DPDB_CACHE = _dereq_('./dpdb-cache.js');
	var Util = _dereq_('../util.js');

	// Online DPDB URL.
	var ONLINE_DPDB_URL = 'https://storage.googleapis.com/cardboard-dpdb/dpdb.json';

	/**
	 * Calculates device parameters based on the DPDB (Device Parameter Database).
	 * Initially, uses the cached DPDB values.
	 *
	 * If fetchOnline == true, then this object tries to fetch the online version
	 * of the DPDB and updates the device info if a better match is found.
	 * Calls the onDeviceParamsUpdated callback when there is an update to the
	 * device information.
	 */
	function Dpdb(fetchOnline, onDeviceParamsUpdated) {
	  // Start with the offline DPDB cache while we are loading the real one.
	  this.dpdb = DPDB_CACHE;

	  // Calculate device params based on the offline version of the DPDB.
	  this.recalculateDeviceParams_();

	  // XHR to fetch online DPDB file, if requested.
	  if (fetchOnline) {
	    // Set the callback.
	    this.onDeviceParamsUpdated = onDeviceParamsUpdated;

	    console.log('Fetching DPDB...');
	    var xhr = new XMLHttpRequest();
	    var obj = this;
	    xhr.open('GET', ONLINE_DPDB_URL, true);
	    xhr.addEventListener('load', function() {
	      obj.loading = false;
	      if (xhr.status >= 200 && xhr.status <= 299) {
	        // Success.
	        console.log('Successfully loaded online DPDB.');
	        obj.dpdb = JSON.parse(xhr.response);
	        obj.recalculateDeviceParams_();
	      } else {
	        // Error loading the DPDB.
	        console.error('Error loading online DPDB!');
	      }
	    });
	    xhr.send();
	  }
	}

	// Returns the current device parameters.
	Dpdb.prototype.getDeviceParams = function() {
	  return this.deviceParams;
	};

	// Recalculates this device's parameters based on the DPDB.
	Dpdb.prototype.recalculateDeviceParams_ = function() {
	  console.log('Recalculating device params.');
	  var newDeviceParams = this.calcDeviceParams_();
	  console.log('New device parameters:');
	  console.log(newDeviceParams);
	  if (newDeviceParams) {
	    this.deviceParams = newDeviceParams;
	    // Invoke callback, if it is set.
	    if (this.onDeviceParamsUpdated) {
	      this.onDeviceParamsUpdated(this.deviceParams);
	    }
	  } else {
	    console.error('Failed to recalculate device parameters.');
	  }
	};

	// Returns a DeviceParams object that represents the best guess as to this
	// device's parameters. Can return null if the device does not match any
	// known devices.
	Dpdb.prototype.calcDeviceParams_ = function() {
	  var db = this.dpdb; // shorthand
	  if (!db) {
	    console.error('DPDB not available.');
	    return null;
	  }
	  if (db.format != 1) {
	    console.error('DPDB has unexpected format version.');
	    return null;
	  }
	  if (!db.devices || !db.devices.length) {
	    console.error('DPDB does not have a devices section.');
	    return null;
	  }

	  // Get the actual user agent and screen dimensions in pixels.
	  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
	  var width = Util.getScreenWidth();
	  var height = Util.getScreenHeight();
	  console.log('User agent: ' + userAgent);
	  console.log('Pixel width: ' + width);
	  console.log('Pixel height: ' + height);

	  if (!db.devices) {
	    console.error('DPDB has no devices section.');
	    return null;
	  }

	  for (var i = 0; i < db.devices.length; i++) {
	    var device = db.devices[i];
	    if (!device.rules) {
	      console.warn('Device[' + i + '] has no rules section.');
	      continue;
	    }

	    if (device.type != 'ios' && device.type != 'android') {
	      console.warn('Device[' + i + '] has invalid type.');
	      continue;
	    }

	    // See if this device is of the appropriate type.
	    if (Util.isIOS() != (device.type == 'ios')) continue;

	    // See if this device matches any of the rules:
	    var matched = false;
	    for (var j = 0; j < device.rules.length; j++) {
	      var rule = device.rules[j];
	      if (this.matchRule_(rule, userAgent, width, height)) {
	        console.log('Rule matched:');
	        console.log(rule);
	        matched = true;
	        break;
	      }
	    }
	    if (!matched) continue;

	    // device.dpi might be an array of [ xdpi, ydpi] or just a scalar.
	    var xdpi = device.dpi[0] || device.dpi;
	    var ydpi = device.dpi[1] || device.dpi;

	    return new DeviceParams({ xdpi: xdpi, ydpi: ydpi, bevelMm: device.bw });
	  }

	  console.warn('No DPDB device match.');
	  return null;
	};

	Dpdb.prototype.matchRule_ = function(rule, ua, screenWidth, screenHeight) {
	  // We can only match 'ua' and 'res' rules, not other types like 'mdmh'
	  // (which are meant for native platforms).
	  if (!rule.ua && !rule.res) return false;

	  // If our user agent string doesn't contain the indicated user agent string,
	  // the match fails.
	  if (rule.ua && ua.indexOf(rule.ua) < 0) return false;

	  // If the rule specifies screen dimensions that don't correspond to ours,
	  // the match fails.
	  if (rule.res) {
	    if (!rule.res[0] || !rule.res[1]) return false;
	    var resX = rule.res[0];
	    var resY = rule.res[1];
	    // Compare min and max so as to make the order not matter, i.e., it should
	    // be true that 640x480 == 480x640.
	    if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) ||
	        (Math.max(screenWidth, screenHeight) != Math.max(resX, resY))) {
	      return false;
	    }
	  }

	  return true;
	}

	function DeviceParams(params) {
	  this.xdpi = params.xdpi;
	  this.ydpi = params.ydpi;
	  this.bevelMm = params.bevelMm;
	}

	module.exports = Dpdb;
	},{"../util.js":22,"./dpdb-cache.js":10}],12:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	function Emitter() {
	  this.callbacks = {};
	}

	Emitter.prototype.emit = function(eventName) {
	  var callbacks = this.callbacks[eventName];
	  if (!callbacks) {
	    //console.log('No valid callback specified.');
	    return;
	  }
	  var args = [].slice.call(arguments);
	  // Eliminate the first param (the callback).
	  args.shift();
	  for (var i = 0; i < callbacks.length; i++) {
	    callbacks[i].apply(this, args);
	  }
	};

	Emitter.prototype.on = function(eventName, callback) {
	  if (eventName in this.callbacks) {
	    this.callbacks[eventName].push(callback);
	  } else {
	    this.callbacks[eventName] = [callback];
	  }
	};

	module.exports = Emitter;

	},{}],13:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var Util = _dereq_('./util.js');
	var WebVRPolyfill = _dereq_('./webvr-polyfill.js').WebVRPolyfill;

	// Initialize a WebVRConfig just in case.
	window.WebVRConfig = Util.extend({
	  // Forces availability of VR mode, even for non-mobile devices.
	  FORCE_ENABLE_VR: false,

	  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
	  K_FILTER: 0.98,

	  // How far into the future to predict during fast motion (in seconds).
	  PREDICTION_TIME_S: 0.040,

	  // Flag to enable touch panner. In case you have your own touch controls.
	  TOUCH_PANNER_DISABLED: true,

	  // Flag to disabled the UI in VR Mode.
	  CARDBOARD_UI_DISABLED: false, // Default: false

	  // Flag to disable the instructions to rotate your device.
	  ROTATE_INSTRUCTIONS_DISABLED: false, // Default: false.

	  // Enable yaw panning only, disabling roll and pitch. This can be useful
	  // for panoramas with nothing interesting above or below.
	  YAW_ONLY: false,

	  // To disable keyboard and mouse controls, if you want to use your own
	  // implementation.
	  MOUSE_KEYBOARD_CONTROLS_DISABLED: false,

	  // Prevent the polyfill from initializing immediately. Requires the app
	  // to call InitializeWebVRPolyfill() before it can be used.
	  DEFER_INITIALIZATION: false,

	  // Enable the deprecated version of the API (navigator.getVRDevices).
	  ENABLE_DEPRECATED_API: false,

	  // Scales the recommended buffer size reported by WebVR, which can improve
	  // performance.
	  // UPDATE(2016-05-03): Setting this to 0.5 by default since 1.0 does not
	  // perform well on many mobile devices.
	  BUFFER_SCALE: 0.5,

	  // Allow VRDisplay.submitFrame to change gl bindings, which is more
	  // efficient if the application code will re-bind its resources on the
	  // next frame anyway. This has been seen to cause rendering glitches with
	  // THREE.js.
	  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
	  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
	  // and gl.TEXTURE_BINDING_2D for texture unit 0.
	  DIRTY_SUBMIT_FRAME_BINDINGS: false
	}, window.WebVRConfig);

	if (!window.WebVRConfig.DEFER_INITIALIZATION) {
	  new WebVRPolyfill();
	} else {
	  window.InitializeWebVRPolyfill = function() {
	    new WebVRPolyfill();
	  }
	}

	},{"./util.js":22,"./webvr-polyfill.js":25}],14:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var MathUtil = window.MathUtil || {};

	MathUtil.degToRad = Math.PI / 180;
	MathUtil.radToDeg = 180 / Math.PI;

	// Some minimal math functionality borrowed from THREE.Math and stripped down
	// for the purposes of this library.


	MathUtil.Vector2 = function ( x, y ) {
	  this.x = x || 0;
	  this.y = y || 0;
	};

	MathUtil.Vector2.prototype = {
	  constructor: MathUtil.Vector2,

	  set: function ( x, y ) {
	    this.x = x;
	    this.y = y;

	    return this;
	  },

	  copy: function ( v ) {
	    this.x = v.x;
	    this.y = v.y;

	    return this;
	  },

	  subVectors: function ( a, b ) {
	    this.x = a.x - b.x;
	    this.y = a.y - b.y;

	    return this;
	  },
	};

	MathUtil.Vector3 = function ( x, y, z ) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	};

	MathUtil.Vector3.prototype = {
	  constructor: MathUtil.Vector3,

	  set: function ( x, y, z ) {
	    this.x = x;
	    this.y = y;
	    this.z = z;

	    return this;
	  },

	  copy: function ( v ) {
	    this.x = v.x;
	    this.y = v.y;
	    this.z = v.z;

	    return this;
	  },

	  length: function () {
	    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	  },

	  normalize: function () {
	    var scalar = this.length();

	    if ( scalar !== 0 ) {
	      var invScalar = 1 / scalar;

	      this.multiplyScalar(invScalar);
	    } else {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	    }

	    return this;
	  },

	  multiplyScalar: function ( scalar ) {
	    this.x *= scalar;
	    this.y *= scalar;
	    this.z *= scalar;
	  },

	  applyQuaternion: function ( q ) {
	    var x = this.x;
	    var y = this.y;
	    var z = this.z;

	    var qx = q.x;
	    var qy = q.y;
	    var qz = q.z;
	    var qw = q.w;

	    // calculate quat * vector
	    var ix =  qw * x + qy * z - qz * y;
	    var iy =  qw * y + qz * x - qx * z;
	    var iz =  qw * z + qx * y - qy * x;
	    var iw = - qx * x - qy * y - qz * z;

	    // calculate result * inverse quat
	    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
	    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
	    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

	    return this;
	  },

	  dot: function ( v ) {
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	  },

	  crossVectors: function ( a, b ) {
	    var ax = a.x, ay = a.y, az = a.z;
	    var bx = b.x, by = b.y, bz = b.z;

	    this.x = ay * bz - az * by;
	    this.y = az * bx - ax * bz;
	    this.z = ax * by - ay * bx;

	    return this;
	  },
	};

	MathUtil.Quaternion = function ( x, y, z, w ) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	  this.w = ( w !== undefined ) ? w : 1;
	};

	MathUtil.Quaternion.prototype = {
	  constructor: MathUtil.Quaternion,

	  set: function ( x, y, z, w ) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;

	    return this;
	  },

	  copy: function ( quaternion ) {
	    this.x = quaternion.x;
	    this.y = quaternion.y;
	    this.z = quaternion.z;
	    this.w = quaternion.w;

	    return this;
	  },

	  setFromEulerXYZ: function( x, y, z ) {
	    var c1 = Math.cos( x / 2 );
	    var c2 = Math.cos( y / 2 );
	    var c3 = Math.cos( z / 2 );
	    var s1 = Math.sin( x / 2 );
	    var s2 = Math.sin( y / 2 );
	    var s3 = Math.sin( z / 2 );

	    this.x = s1 * c2 * c3 + c1 * s2 * s3;
	    this.y = c1 * s2 * c3 - s1 * c2 * s3;
	    this.z = c1 * c2 * s3 + s1 * s2 * c3;
	    this.w = c1 * c2 * c3 - s1 * s2 * s3;

	    return this;
	  },

	  setFromEulerYXZ: function( x, y, z ) {
	    var c1 = Math.cos( x / 2 );
	    var c2 = Math.cos( y / 2 );
	    var c3 = Math.cos( z / 2 );
	    var s1 = Math.sin( x / 2 );
	    var s2 = Math.sin( y / 2 );
	    var s3 = Math.sin( z / 2 );

	    this.x = s1 * c2 * c3 + c1 * s2 * s3;
	    this.y = c1 * s2 * c3 - s1 * c2 * s3;
	    this.z = c1 * c2 * s3 - s1 * s2 * c3;
	    this.w = c1 * c2 * c3 + s1 * s2 * s3;

	    return this;
	  },

	  setFromAxisAngle: function ( axis, angle ) {
	    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	    // assumes axis is normalized

	    var halfAngle = angle / 2, s = Math.sin( halfAngle );

	    this.x = axis.x * s;
	    this.y = axis.y * s;
	    this.z = axis.z * s;
	    this.w = Math.cos( halfAngle );

	    return this;
	  },

	  multiply: function ( q ) {
	    return this.multiplyQuaternions( this, q );
	  },

	  multiplyQuaternions: function ( a, b ) {
	    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

	    var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
	    var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

	    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

	    return this;
	  },

	  inverse: function () {
	    this.x *= -1;
	    this.y *= -1;
	    this.z *= -1;

	    this.normalize();

	    return this;
	  },

	  normalize: function () {
	    var l = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	    if ( l === 0 ) {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	      this.w = 1;
	    } else {
	      l = 1 / l;

	      this.x = this.x * l;
	      this.y = this.y * l;
	      this.z = this.z * l;
	      this.w = this.w * l;
	    }

	    return this;
	  },

	  slerp: function ( qb, t ) {
	    if ( t === 0 ) return this;
	    if ( t === 1 ) return this.copy( qb );

	    var x = this.x, y = this.y, z = this.z, w = this.w;

	    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

	    var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

	    if ( cosHalfTheta < 0 ) {
	      this.w = - qb.w;
	      this.x = - qb.x;
	      this.y = - qb.y;
	      this.z = - qb.z;

	      cosHalfTheta = - cosHalfTheta;
	    } else {
	      this.copy( qb );
	    }

	    if ( cosHalfTheta >= 1.0 ) {
	      this.w = w;
	      this.x = x;
	      this.y = y;
	      this.z = z;

	      return this;
	    }

	    var halfTheta = Math.acos( cosHalfTheta );
	    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

	    if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	      this.w = 0.5 * ( w + this.w );
	      this.x = 0.5 * ( x + this.x );
	      this.y = 0.5 * ( y + this.y );
	      this.z = 0.5 * ( z + this.z );

	      return this;
	    }

	    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
	    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

	    this.w = ( w * ratioA + this.w * ratioB );
	    this.x = ( x * ratioA + this.x * ratioB );
	    this.y = ( y * ratioA + this.y * ratioB );
	    this.z = ( z * ratioA + this.z * ratioB );

	    return this;
	  },

	  setFromUnitVectors: function () {
	    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	    // assumes direction vectors vFrom and vTo are normalized

	    var v1, r;
	    var EPS = 0.000001;

	    return function ( vFrom, vTo ) {
	      if ( v1 === undefined ) v1 = new MathUtil.Vector3();

	      r = vFrom.dot( vTo ) + 1;

	      if ( r < EPS ) {
	        r = 0;

	        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	          v1.set( - vFrom.y, vFrom.x, 0 );
	        } else {
	          v1.set( 0, - vFrom.z, vFrom.y );
	        }
	      } else {
	        v1.crossVectors( vFrom, vTo );
	      }

	      this.x = v1.x;
	      this.y = v1.y;
	      this.z = v1.z;
	      this.w = r;

	      this.normalize();

	      return this;
	    }
	  }(),
	};

	module.exports = MathUtil;

	},{}],15:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var VRDisplay = _dereq_('./base.js').VRDisplay;
	var MathUtil = _dereq_('./math-util.js');
	var Util = _dereq_('./util.js');

	// How much to rotate per key stroke.
	var KEY_SPEED = 0.15;
	var KEY_ANIMATION_DURATION = 80;

	// How much to rotate for mouse events.
	var MOUSE_SPEED_X = 0.5;
	var MOUSE_SPEED_Y = 0.3;

	/**
	 * VRDisplay based on mouse and keyboard input. Designed for desktops/laptops
	 * where orientation events aren't supported. Cannot present.
	 */
	function MouseKeyboardVRDisplay() {
	  this.displayName = 'Mouse and Keyboard VRDisplay (webvr-polyfill)';

	  this.capabilities.hasOrientation = true;

	  // Attach to mouse and keyboard events.
	  window.addEventListener('keydown', this.onKeyDown_.bind(this));
	  window.addEventListener('mousemove', this.onMouseMove_.bind(this));
	  window.addEventListener('mousedown', this.onMouseDown_.bind(this));
	  window.addEventListener('mouseup', this.onMouseUp_.bind(this));

	  // "Private" members.
	  this.phi_ = 0;
	  this.theta_ = 0;

	  // Variables for keyboard-based rotation animation.
	  this.targetAngle_ = null;
	  this.angleAnimation_ = null;

	  // State variables for calculations.
	  this.orientation_ = new MathUtil.Quaternion();

	  // Variables for mouse-based rotation.
	  this.rotateStart_ = new MathUtil.Vector2();
	  this.rotateEnd_ = new MathUtil.Vector2();
	  this.rotateDelta_ = new MathUtil.Vector2();
	  this.isDragging_ = false;

	  this.orientationOut_ = new Float32Array(4);
	}
	MouseKeyboardVRDisplay.prototype = new VRDisplay();

	MouseKeyboardVRDisplay.prototype.getImmediatePose = function() {
	  this.orientation_.setFromEulerYXZ(this.phi_, this.theta_, 0);

	  this.orientationOut_[0] = this.orientation_.x;
	  this.orientationOut_[1] = this.orientation_.y;
	  this.orientationOut_[2] = this.orientation_.z;
	  this.orientationOut_[3] = this.orientation_.w;

	  return {
	    position: null,
	    orientation: this.orientationOut_,
	    linearVelocity: null,
	    linearAcceleration: null,
	    angularVelocity: null,
	    angularAcceleration: null
	  };
	};

	MouseKeyboardVRDisplay.prototype.onKeyDown_ = function(e) {
	  // Track WASD and arrow keys.
	  if (e.keyCode == 38) { // Up key.
	    this.animatePhi_(this.phi_ + KEY_SPEED);
	  } else if (e.keyCode == 39) { // Right key.
	    this.animateTheta_(this.theta_ - KEY_SPEED);
	  } else if (e.keyCode == 40) { // Down key.
	    this.animatePhi_(this.phi_ - KEY_SPEED);
	  } else if (e.keyCode == 37) { // Left key.
	    this.animateTheta_(this.theta_ + KEY_SPEED);
	  }
	};

	MouseKeyboardVRDisplay.prototype.animateTheta_ = function(targetAngle) {
	  this.animateKeyTransitions_('theta_', targetAngle);
	};

	MouseKeyboardVRDisplay.prototype.animatePhi_ = function(targetAngle) {
	  // Prevent looking too far up or down.
	  targetAngle = Util.clamp(targetAngle, -Math.PI/2, Math.PI/2);
	  this.animateKeyTransitions_('phi_', targetAngle);
	};

	/**
	 * Start an animation to transition an angle from one value to another.
	 */
	MouseKeyboardVRDisplay.prototype.animateKeyTransitions_ = function(angleName, targetAngle) {
	  // If an animation is currently running, cancel it.
	  if (this.angleAnimation_) {
	    cancelAnimationFrame(this.angleAnimation_);
	  }
	  var startAngle = this[angleName];
	  var startTime = new Date();
	  // Set up an interval timer to perform the animation.
	  this.angleAnimation_ = requestAnimationFrame(function animate() {
	    // Once we're finished the animation, we're done.
	    var elapsed = new Date() - startTime;
	    if (elapsed >= KEY_ANIMATION_DURATION) {
	      this[angleName] = targetAngle;
	      cancelAnimationFrame(this.angleAnimation_);
	      return;
	    }
	    // loop with requestAnimationFrame
	    this.angleAnimation_ = requestAnimationFrame(animate.bind(this))
	    // Linearly interpolate the angle some amount.
	    var percent = elapsed / KEY_ANIMATION_DURATION;
	    this[angleName] = startAngle + (targetAngle - startAngle) * percent;
	  }.bind(this));
	};

	MouseKeyboardVRDisplay.prototype.onMouseDown_ = function(e) {
	  this.rotateStart_.set(e.clientX, e.clientY);
	  this.isDragging_ = true;
	};

	// Very similar to https://gist.github.com/mrflix/8351020
	MouseKeyboardVRDisplay.prototype.onMouseMove_ = function(e) {
	  if (!this.isDragging_ && !this.isPointerLocked_()) {
	    return;
	  }
	  // Support pointer lock API.
	  if (this.isPointerLocked_()) {
	    var movementX = e.movementX || e.mozMovementX || 0;
	    var movementY = e.movementY || e.mozMovementY || 0;
	    this.rotateEnd_.set(this.rotateStart_.x - movementX, this.rotateStart_.y - movementY);
	  } else {
	    this.rotateEnd_.set(e.clientX, e.clientY);
	  }
	  // Calculate how much we moved in mouse space.
	  this.rotateDelta_.subVectors(this.rotateEnd_, this.rotateStart_);
	  this.rotateStart_.copy(this.rotateEnd_);

	  // Keep track of the cumulative euler angles.
	  this.phi_ += 2 * Math.PI * this.rotateDelta_.y / screen.height * MOUSE_SPEED_Y;
	  this.theta_ += 2 * Math.PI * this.rotateDelta_.x / screen.width * MOUSE_SPEED_X;

	  // Prevent looking too far up or down.
	  this.phi_ = Util.clamp(this.phi_, -Math.PI/2, Math.PI/2);
	};

	MouseKeyboardVRDisplay.prototype.onMouseUp_ = function(e) {
	  this.isDragging_ = false;
	};

	MouseKeyboardVRDisplay.prototype.isPointerLocked_ = function() {
	  var el = document.pointerLockElement || document.mozPointerLockElement ||
	      document.webkitPointerLockElement;
	  return el !== undefined;
	};

	MouseKeyboardVRDisplay.prototype.resetPose = function() {
	  this.phi_ = 0;
	  this.theta_ = 0;
	};

	module.exports = MouseKeyboardVRDisplay;

	},{"./base.js":2,"./math-util.js":14,"./util.js":22}],16:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var Util = _dereq_('./util.js');

	function RotateInstructions() {
	  this.loadIcon_();

	  var overlay = document.createElement('div');
	  var s = overlay.style;
	  s.position = 'fixed';
	  s.top = 0;
	  s.right = 0;
	  s.bottom = 0;
	  s.left = 0;
	  s.backgroundColor = 'gray';
	  s.fontFamily = 'sans-serif';
	  // Force this to be above the fullscreen canvas, which is at zIndex: 999999.
	  s.zIndex = 1000000;

	  var img = document.createElement('img');
	  img.src = this.icon;
	  var s = img.style;
	  s.marginLeft = '25%';
	  s.marginTop = '25%';
	  s.width = '50%';
	  overlay.appendChild(img);

	  var text = document.createElement('div');
	  var s = text.style;
	  s.textAlign = 'center';
	  s.fontSize = '16px';
	  s.lineHeight = '24px';
	  s.margin = '24px 25%';
	  s.width = '50%';
	  text.innerHTML = 'Place your phone into your Cardboard viewer.';
	  overlay.appendChild(text);

	  var snackbar = document.createElement('div');
	  var s = snackbar.style;
	  s.backgroundColor = '#CFD8DC';
	  s.position = 'fixed';
	  s.bottom = 0;
	  s.width = '100%';
	  s.height = '48px';
	  s.padding = '14px 24px';
	  s.boxSizing = 'border-box';
	  s.color = '#656A6B';
	  overlay.appendChild(snackbar);

	  var snackbarText = document.createElement('div');
	  snackbarText.style.float = 'left';
	  snackbarText.innerHTML = 'No Cardboard viewer?';

	  var snackbarButton = document.createElement('a');
	  snackbarButton.href = 'https://www.google.com/get/cardboard/get-cardboard/';
	  snackbarButton.innerHTML = 'get one';
	  snackbarButton.target = '_blank';
	  var s = snackbarButton.style;
	  s.float = 'right';
	  s.fontWeight = 600;
	  s.textTransform = 'uppercase';
	  s.borderLeft = '1px solid gray';
	  s.paddingLeft = '24px';
	  s.textDecoration = 'none';
	  s.color = '#656A6B';

	  snackbar.appendChild(snackbarText);
	  snackbar.appendChild(snackbarButton);

	  this.overlay = overlay;
	  this.text = text;

	  this.hide();
	}

	RotateInstructions.prototype.show = function(parent) {
	  if (!parent && !this.overlay.parentElement) {
	    document.body.appendChild(this.overlay);
	  } else if (parent) {
	    if (this.overlay.parentElement && this.overlay.parentElement != parent)
	      this.overlay.parentElement.removeChild(this.overlay);

	    parent.appendChild(this.overlay);
	  }

	  this.overlay.style.display = 'block';

	  var img = this.overlay.querySelector('img');
	  var s = img.style;

	  if (Util.isLandscapeMode()) {
	    s.width = '20%';
	    s.marginLeft = '40%';
	    s.marginTop = '3%';
	  } else {
	    s.width = '50%';
	    s.marginLeft = '25%';
	    s.marginTop = '25%';
	  }
	};

	RotateInstructions.prototype.hide = function() {
	  this.overlay.style.display = 'none';
	};

	RotateInstructions.prototype.showTemporarily = function(ms, parent) {
	  this.show(parent);
	  this.timer = setTimeout(this.hide.bind(this), ms);
	};

	RotateInstructions.prototype.disableShowTemporarily = function() {
	  clearTimeout(this.timer);
	};

	RotateInstructions.prototype.update = function() {
	  this.disableShowTemporarily();
	  // In portrait VR mode, tell the user to rotate to landscape. Otherwise, hide
	  // the instructions.
	  if (!Util.isLandscapeMode() && Util.isMobile()) {
	    this.show();
	  } else {
	    this.hide();
	  }
	};

	RotateInstructions.prototype.loadIcon_ = function() {
	  // Encoded asset_src/rotate-instructions.svg
	  this.icon = Util.base64('image/svg+xml', 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5OHB4IiBoZWlnaHQ9IjI0MHB4IiB2aWV3Qm94PSIwIDAgMTk4IDI0MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpza2V0Y2g9Imh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9ucyI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDMuMy4zICgxMjA4MSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dHJhbnNpdGlvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHNrZXRjaDp0eXBlPSJNU1BhZ2UiPgogICAgICAgIDxnIGlkPSJ0cmFuc2l0aW9uIiBza2V0Y2g6dHlwZT0iTVNBcnRib2FyZEdyb3VwIj4KICAgICAgICAgICAgPGcgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTQtKy1JbXBvcnRlZC1MYXllcnMtQ29weS0rLUltcG9ydGVkLUxheWVycy1Db3B5LTItQ29weSIgc2tldGNoOnR5cGU9Ik1TTGF5ZXJHcm91cCI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHktNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwNy4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjYyNSwyLjUyNyBDMTQ5LjYyNSwyLjUyNyAxNTUuODA1LDYuMDk2IDE1Ni4zNjIsNi40MTggTDE1Ni4zNjIsNy4zMDQgQzE1Ni4zNjIsNy40ODEgMTU2LjM3NSw3LjY2NCAxNTYuNCw3Ljg1MyBDMTU2LjQxLDcuOTM0IDE1Ni40Miw4LjAxNSAxNTYuNDI3LDguMDk1IEMxNTYuNTY3LDkuNTEgMTU3LjQwMSwxMS4wOTMgMTU4LjUzMiwxMi4wOTQgTDE2NC4yNTIsMTcuMTU2IEwxNjQuMzMzLDE3LjA2NiBDMTY0LjMzMywxNy4wNjYgMTY4LjcxNSwxNC41MzYgMTY5LjU2OCwxNC4wNDIgQzE3MS4wMjUsMTQuODgzIDE5NS41MzgsMjkuMDM1IDE5NS41MzgsMjkuMDM1IEwxOTUuNTM4LDgzLjAzNiBDMTk1LjUzOCw4My44MDcgMTk1LjE1Miw4NC4yNTMgMTk0LjU5LDg0LjI1MyBDMTk0LjM1Nyw4NC4yNTMgMTk0LjA5NSw4NC4xNzcgMTkzLjgxOCw4NC4wMTcgTDE2OS44NTEsNzAuMTc5IEwxNjkuODM3LDcwLjIwMyBMMTQyLjUxNSw4NS45NzggTDE0MS42NjUsODQuNjU1IEMxMzYuOTM0LDgzLjEyNiAxMzEuOTE3LDgxLjkxNSAxMjYuNzE0LDgxLjA0NSBDMTI2LjcwOSw4MS4wNiAxMjYuNzA3LDgxLjA2OSAxMjYuNzA3LDgxLjA2OSBMMTIxLjY0LDk4LjAzIEwxMTMuNzQ5LDEwMi41ODYgTDExMy43MTIsMTAyLjUyMyBMMTEzLjcxMiwxMzAuMTEzIEMxMTMuNzEyLDEzMC44ODUgMTEzLjMyNiwxMzEuMzMgMTEyLjc2NCwxMzEuMzMgQzExMi41MzIsMTMxLjMzIDExMi4yNjksMTMxLjI1NCAxMTEuOTkyLDEzMS4wOTQgTDY5LjUxOSwxMDYuNTcyIEM2OC41NjksMTA2LjAyMyA2Ny43OTksMTA0LjY5NSA2Ny43OTksMTAzLjYwNSBMNjcuNzk5LDEwMi41NyBMNjcuNzc4LDEwMi42MTcgQzY3LjI3LDEwMi4zOTMgNjYuNjQ4LDEwMi4yNDkgNjUuOTYyLDEwMi4yMTggQzY1Ljg3NSwxMDIuMjE0IDY1Ljc4OCwxMDIuMjEyIDY1LjcwMSwxMDIuMjEyIEM2NS42MDYsMTAyLjIxMiA2NS41MTEsMTAyLjIxNSA2NS40MTYsMTAyLjIxOSBDNjUuMTk1LDEwMi4yMjkgNjQuOTc0LDEwMi4yMzUgNjQuNzU0LDEwMi4yMzUgQzY0LjMzMSwxMDIuMjM1IDYzLjkxMSwxMDIuMjE2IDYzLjQ5OCwxMDIuMTc4IEM2MS44NDMsMTAyLjAyNSA2MC4yOTgsMTAxLjU3OCA1OS4wOTQsMTAwLjg4MiBMMTIuNTE4LDczLjk5MiBMMTIuNTIzLDc0LjAwNCBMMi4yNDUsNTUuMjU0IEMxLjI0NCw1My40MjcgMi4wMDQsNTEuMDM4IDMuOTQzLDQ5LjkxOCBMNTkuOTU0LDE3LjU3MyBDNjAuNjI2LDE3LjE4NSA2MS4zNSwxNy4wMDEgNjIuMDUzLDE3LjAwMSBDNjMuMzc5LDE3LjAwMSA2NC42MjUsMTcuNjYgNjUuMjgsMTguODU0IEw2NS4yODUsMTguODUxIEw2NS41MTIsMTkuMjY0IEw2NS41MDYsMTkuMjY4IEM2NS45MDksMjAuMDAzIDY2LjQwNSwyMC42OCA2Ni45ODMsMjEuMjg2IEw2Ny4yNiwyMS41NTYgQzY5LjE3NCwyMy40MDYgNzEuNzI4LDI0LjM1NyA3NC4zNzMsMjQuMzU3IEM3Ni4zMjIsMjQuMzU3IDc4LjMyMSwyMy44NCA4MC4xNDgsMjIuNzg1IEM4MC4xNjEsMjIuNzg1IDg3LjQ2NywxOC41NjYgODcuNDY3LDE4LjU2NiBDODguMTM5LDE4LjE3OCA4OC44NjMsMTcuOTk0IDg5LjU2NiwxNy45OTQgQzkwLjg5MiwxNy45OTQgOTIuMTM4LDE4LjY1MiA5Mi43OTIsMTkuODQ3IEw5Ni4wNDIsMjUuNzc1IEw5Ni4wNjQsMjUuNzU3IEwxMDIuODQ5LDI5LjY3NCBMMTAyLjc0NCwyOS40OTIgTDE0OS42MjUsMi41MjcgTTE0OS42MjUsMC44OTIgQzE0OS4zNDMsMC44OTIgMTQ5LjA2MiwwLjk2NSAxNDguODEsMS4xMSBMMTAyLjY0MSwyNy42NjYgTDk3LjIzMSwyNC41NDIgTDk0LjIyNiwxOS4wNjEgQzkzLjMxMywxNy4zOTQgOTEuNTI3LDE2LjM1OSA4OS41NjYsMTYuMzU4IEM4OC41NTUsMTYuMzU4IDg3LjU0NiwxNi42MzIgODYuNjQ5LDE3LjE1IEM4My44NzgsMTguNzUgNzkuNjg3LDIxLjE2OSA3OS4zNzQsMjEuMzQ1IEM3OS4zNTksMjEuMzUzIDc5LjM0NSwyMS4zNjEgNzkuMzMsMjEuMzY5IEM3Ny43OTgsMjIuMjU0IDc2LjA4NCwyMi43MjIgNzQuMzczLDIyLjcyMiBDNzIuMDgxLDIyLjcyMiA2OS45NTksMjEuODkgNjguMzk3LDIwLjM4IEw2OC4xNDUsMjAuMTM1IEM2Ny43MDYsMTkuNjcyIDY3LjMyMywxOS4xNTYgNjcuMDA2LDE4LjYwMSBDNjYuOTg4LDE4LjU1OSA2Ni45NjgsMTguNTE5IDY2Ljk0NiwxOC40NzkgTDY2LjcxOSwxOC4wNjUgQzY2LjY5LDE4LjAxMiA2Ni42NTgsMTcuOTYgNjYuNjI0LDE3LjkxMSBDNjUuNjg2LDE2LjMzNyA2My45NTEsMTUuMzY2IDYyLjA1MywxNS4zNjYgQzYxLjA0MiwxNS4zNjYgNjAuMDMzLDE1LjY0IDU5LjEzNiwxNi4xNTggTDMuMTI1LDQ4LjUwMiBDMC40MjYsNTAuMDYxIC0wLjYxMyw1My40NDIgMC44MTEsNTYuMDQgTDExLjA4OSw3NC43OSBDMTEuMjY2LDc1LjExMyAxMS41MzcsNzUuMzUzIDExLjg1LDc1LjQ5NCBMNTguMjc2LDEwMi4yOTggQzU5LjY3OSwxMDMuMTA4IDYxLjQzMywxMDMuNjMgNjMuMzQ4LDEwMy44MDYgQzYzLjgxMiwxMDMuODQ4IDY0LjI4NSwxMDMuODcgNjQuNzU0LDEwMy44NyBDNjUsMTAzLjg3IDY1LjI0OSwxMDMuODY0IDY1LjQ5NCwxMDMuODUyIEM2NS41NjMsMTAzLjg0OSA2NS42MzIsMTAzLjg0NyA2NS43MDEsMTAzLjg0NyBDNjUuNzY0LDEwMy44NDcgNjUuODI4LDEwMy44NDkgNjUuODksMTAzLjg1MiBDNjUuOTg2LDEwMy44NTYgNjYuMDgsMTAzLjg2MyA2Ni4xNzMsMTAzLjg3NCBDNjYuMjgyLDEwNS40NjcgNjcuMzMyLDEwNy4xOTcgNjguNzAyLDEwNy45ODggTDExMS4xNzQsMTMyLjUxIEMxMTEuNjk4LDEzMi44MTIgMTEyLjIzMiwxMzIuOTY1IDExMi43NjQsMTMyLjk2NSBDMTE0LjI2MSwxMzIuOTY1IDExNS4zNDcsMTMxLjc2NSAxMTUuMzQ3LDEzMC4xMTMgTDExNS4zNDcsMTAzLjU1MSBMMTIyLjQ1OCw5OS40NDYgQzEyMi44MTksOTkuMjM3IDEyMy4wODcsOTguODk4IDEyMy4yMDcsOTguNDk4IEwxMjcuODY1LDgyLjkwNSBDMTMyLjI3OSw4My43MDIgMTM2LjU1Nyw4NC43NTMgMTQwLjYwNyw4Ni4wMzMgTDE0MS4xNCw4Ni44NjIgQzE0MS40NTEsODcuMzQ2IDE0MS45NzcsODcuNjEzIDE0Mi41MTYsODcuNjEzIEMxNDIuNzk0LDg3LjYxMyAxNDMuMDc2LDg3LjU0MiAxNDMuMzMzLDg3LjM5MyBMMTY5Ljg2NSw3Mi4wNzYgTDE5Myw4NS40MzMgQzE5My41MjMsODUuNzM1IDE5NC4wNTgsODUuODg4IDE5NC41OSw4NS44ODggQzE5Ni4wODcsODUuODg4IDE5Ny4xNzMsODQuNjg5IDE5Ny4xNzMsODMuMDM2IEwxOTcuMTczLDI5LjAzNSBDMTk3LjE3MywyOC40NTEgMTk2Ljg2MSwyNy45MTEgMTk2LjM1NSwyNy42MTkgQzE5Ni4zNTUsMjcuNjE5IDE3MS44NDMsMTMuNDY3IDE3MC4zODUsMTIuNjI2IEMxNzAuMTMyLDEyLjQ4IDE2OS44NSwxMi40MDcgMTY5LjU2OCwxMi40MDcgQzE2OS4yODUsMTIuNDA3IDE2OS4wMDIsMTIuNDgxIDE2OC43NDksMTIuNjI3IEMxNjguMTQzLDEyLjk3OCAxNjUuNzU2LDE0LjM1NyAxNjQuNDI0LDE1LjEyNSBMMTU5LjYxNSwxMC44NyBDMTU4Ljc5NiwxMC4xNDUgMTU4LjE1NCw4LjkzNyAxNTguMDU0LDcuOTM0IEMxNTguMDQ1LDcuODM3IDE1OC4wMzQsNy43MzkgMTU4LjAyMSw3LjY0IEMxNTguMDA1LDcuNTIzIDE1Ny45OTgsNy40MSAxNTcuOTk4LDcuMzA0IEwxNTcuOTk4LDYuNDE4IEMxNTcuOTk4LDUuODM0IDE1Ny42ODYsNS4yOTUgMTU3LjE4MSw1LjAwMiBDMTU2LjYyNCw0LjY4IDE1MC40NDIsMS4xMTEgMTUwLjQ0MiwxLjExMSBDMTUwLjE4OSwwLjk2NSAxNDkuOTA3LDAuODkyIDE0OS42MjUsMC44OTIiIGlkPSJGaWxsLTEiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTYuMDI3LDI1LjYzNiBMMTQyLjYwMyw1Mi41MjcgQzE0My44MDcsNTMuMjIyIDE0NC41ODIsNTQuMTE0IDE0NC44NDUsNTUuMDY4IEwxNDQuODM1LDU1LjA3NSBMNjMuNDYxLDEwMi4wNTcgTDYzLjQ2LDEwMi4wNTcgQzYxLjgwNiwxMDEuOTA1IDYwLjI2MSwxMDEuNDU3IDU5LjA1NywxMDAuNzYyIEwxMi40ODEsNzMuODcxIEw5Ni4wMjcsMjUuNjM2IiBpZD0iRmlsbC0yIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYzLjQ2MSwxMDIuMTc0IEM2My40NTMsMTAyLjE3NCA2My40NDYsMTAyLjE3NCA2My40MzksMTAyLjE3MiBDNjEuNzQ2LDEwMi4wMTYgNjAuMjExLDEwMS41NjMgNTguOTk4LDEwMC44NjMgTDEyLjQyMiw3My45NzMgQzEyLjM4Niw3My45NTIgMTIuMzY0LDczLjkxNCAxMi4zNjQsNzMuODcxIEMxMi4zNjQsNzMuODMgMTIuMzg2LDczLjc5MSAxMi40MjIsNzMuNzcgTDk1Ljk2OCwyNS41MzUgQzk2LjAwNCwyNS41MTQgOTYuMDQ5LDI1LjUxNCA5Ni4wODUsMjUuNTM1IEwxNDIuNjYxLDUyLjQyNiBDMTQzLjg4OCw1My4xMzQgMTQ0LjY4Miw1NC4wMzggMTQ0Ljk1Nyw1NS4wMzcgQzE0NC45Nyw1NS4wODMgMTQ0Ljk1Myw1NS4xMzMgMTQ0LjkxNSw1NS4xNjEgQzE0NC45MTEsNTUuMTY1IDE0NC44OTgsNTUuMTc0IDE0NC44OTQsNTUuMTc3IEw2My41MTksMTAyLjE1OCBDNjMuNTAxLDEwMi4xNjkgNjMuNDgxLDEwMi4xNzQgNjMuNDYxLDEwMi4xNzQgTDYzLjQ2MSwxMDIuMTc0IFogTTEyLjcxNCw3My44NzEgTDU5LjExNSwxMDAuNjYxIEM2MC4yOTMsMTAxLjM0MSA2MS43ODYsMTAxLjc4MiA2My40MzUsMTAxLjkzNyBMMTQ0LjcwNyw1NS4wMTUgQzE0NC40MjgsNTQuMTA4IDE0My42ODIsNTMuMjg1IDE0Mi41NDQsNTIuNjI4IEw5Ni4wMjcsMjUuNzcxIEwxMi43MTQsNzMuODcxIEwxMi43MTQsNzMuODcxIFoiIGlkPSJGaWxsLTMiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ4LjMyNyw1OC40NzEgQzE0OC4xNDUsNTguNDggMTQ3Ljk2Miw1OC40OCAxNDcuNzgxLDU4LjQ3MiBDMTQ1Ljg4Nyw1OC4zODkgMTQ0LjQ3OSw1Ny40MzQgMTQ0LjYzNiw1Ni4zNCBDMTQ0LjY4OSw1NS45NjcgMTQ0LjY2NCw1NS41OTcgMTQ0LjU2NCw1NS4yMzUgTDYzLjQ2MSwxMDIuMDU3IEM2NC4wODksMTAyLjExNSA2NC43MzMsMTAyLjEzIDY1LjM3OSwxMDIuMDk5IEM2NS41NjEsMTAyLjA5IDY1Ljc0MywxMDIuMDkgNjUuOTI1LDEwMi4wOTggQzY3LjgxOSwxMDIuMTgxIDY5LjIyNywxMDMuMTM2IDY5LjA3LDEwNC4yMyBMMTQ4LjMyNyw1OC40NzEiIGlkPSJGaWxsLTQiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjkuMDcsMTA0LjM0NyBDNjkuMDQ4LDEwNC4zNDcgNjkuMDI1LDEwNC4zNCA2OS4wMDUsMTA0LjMyNyBDNjguOTY4LDEwNC4zMDEgNjguOTQ4LDEwNC4yNTcgNjguOTU1LDEwNC4yMTMgQzY5LDEwMy44OTYgNjguODk4LDEwMy41NzYgNjguNjU4LDEwMy4yODggQzY4LjE1MywxMDIuNjc4IDY3LjEwMywxMDIuMjY2IDY1LjkyLDEwMi4yMTQgQzY1Ljc0MiwxMDIuMjA2IDY1LjU2MywxMDIuMjA3IDY1LjM4NSwxMDIuMjE1IEM2NC43NDIsMTAyLjI0NiA2NC4wODcsMTAyLjIzMiA2My40NSwxMDIuMTc0IEM2My4zOTksMTAyLjE2OSA2My4zNTgsMTAyLjEzMiA2My4zNDcsMTAyLjA4MiBDNjMuMzM2LDEwMi4wMzMgNjMuMzU4LDEwMS45ODEgNjMuNDAyLDEwMS45NTYgTDE0NC41MDYsNTUuMTM0IEMxNDQuNTM3LDU1LjExNiAxNDQuNTc1LDU1LjExMyAxNDQuNjA5LDU1LjEyNyBDMTQ0LjY0Miw1NS4xNDEgMTQ0LjY2OCw1NS4xNyAxNDQuNjc3LDU1LjIwNCBDMTQ0Ljc4MSw1NS41ODUgMTQ0LjgwNiw1NS45NzIgMTQ0Ljc1MSw1Ni4zNTcgQzE0NC43MDYsNTYuNjczIDE0NC44MDgsNTYuOTk0IDE0NS4wNDcsNTcuMjgyIEMxNDUuNTUzLDU3Ljg5MiAxNDYuNjAyLDU4LjMwMyAxNDcuNzg2LDU4LjM1NSBDMTQ3Ljk2NCw1OC4zNjMgMTQ4LjE0Myw1OC4zNjMgMTQ4LjMyMSw1OC4zNTQgQzE0OC4zNzcsNTguMzUyIDE0OC40MjQsNTguMzg3IDE0OC40MzksNTguNDM4IEMxNDguNDU0LDU4LjQ5IDE0OC40MzIsNTguNTQ1IDE0OC4zODUsNTguNTcyIEw2OS4xMjksMTA0LjMzMSBDNjkuMTExLDEwNC4zNDIgNjkuMDksMTA0LjM0NyA2OS4wNywxMDQuMzQ3IEw2OS4wNywxMDQuMzQ3IFogTTY1LjY2NSwxMDEuOTc1IEM2NS43NTQsMTAxLjk3NSA2NS44NDIsMTAxLjk3NyA2NS45MywxMDEuOTgxIEM2Ny4xOTYsMTAyLjAzNyA2OC4yODMsMTAyLjQ2OSA2OC44MzgsMTAzLjEzOSBDNjkuMDY1LDEwMy40MTMgNjkuMTg4LDEwMy43MTQgNjkuMTk4LDEwNC4wMjEgTDE0Ny44ODMsNTguNTkyIEMxNDcuODQ3LDU4LjU5MiAxNDcuODExLDU4LjU5MSAxNDcuNzc2LDU4LjU4OSBDMTQ2LjUwOSw1OC41MzMgMTQ1LjQyMiw1OC4xIDE0NC44NjcsNTcuNDMxIEMxNDQuNTg1LDU3LjA5MSAxNDQuNDY1LDU2LjcwNyAxNDQuNTIsNTYuMzI0IEMxNDQuNTYzLDU2LjAyMSAxNDQuNTUyLDU1LjcxNiAxNDQuNDg4LDU1LjQxNCBMNjMuODQ2LDEwMS45NyBDNjQuMzUzLDEwMi4wMDIgNjQuODY3LDEwMi4wMDYgNjUuMzc0LDEwMS45ODIgQzY1LjQ3MSwxMDEuOTc3IDY1LjU2OCwxMDEuOTc1IDY1LjY2NSwxMDEuOTc1IEw2NS42NjUsMTAxLjk3NSBaIiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIuMjA4LDU1LjEzNCBDMS4yMDcsNTMuMzA3IDEuOTY3LDUwLjkxNyAzLjkwNiw0OS43OTcgTDU5LjkxNywxNy40NTMgQzYxLjg1NiwxNi4zMzMgNjQuMjQxLDE2LjkwNyA2NS4yNDMsMTguNzM0IEw2NS40NzUsMTkuMTQ0IEM2NS44NzIsMTkuODgyIDY2LjM2OCwyMC41NiA2Ni45NDUsMjEuMTY1IEw2Ny4yMjMsMjEuNDM1IEM3MC41NDgsMjQuNjQ5IDc1LjgwNiwyNS4xNTEgODAuMTExLDIyLjY2NSBMODcuNDMsMTguNDQ1IEM4OS4zNywxNy4zMjYgOTEuNzU0LDE3Ljg5OSA5Mi43NTUsMTkuNzI3IEw5Ni4wMDUsMjUuNjU1IEwxMi40ODYsNzMuODg0IEwyLjIwOCw1NS4xMzQgWiIgaWQ9IkZpbGwtNiIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi40ODYsNzQuMDAxIEMxMi40NzYsNzQuMDAxIDEyLjQ2NSw3My45OTkgMTIuNDU1LDczLjk5NiBDMTIuNDI0LDczLjk4OCAxMi4zOTksNzMuOTY3IDEyLjM4NCw3My45NCBMMi4xMDYsNTUuMTkgQzEuMDc1LDUzLjMxIDEuODU3LDUwLjg0NSAzLjg0OCw0OS42OTYgTDU5Ljg1OCwxNy4zNTIgQzYwLjUyNSwxNi45NjcgNjEuMjcxLDE2Ljc2NCA2Mi4wMTYsMTYuNzY0IEM2My40MzEsMTYuNzY0IDY0LjY2NiwxNy40NjYgNjUuMzI3LDE4LjY0NiBDNjUuMzM3LDE4LjY1NCA2NS4zNDUsMTguNjYzIDY1LjM1MSwxOC42NzQgTDY1LjU3OCwxOS4wODggQzY1LjU4NCwxOS4xIDY1LjU4OSwxOS4xMTIgNjUuNTkxLDE5LjEyNiBDNjUuOTg1LDE5LjgzOCA2Ni40NjksMjAuNDk3IDY3LjAzLDIxLjA4NSBMNjcuMzA1LDIxLjM1MSBDNjkuMTUxLDIzLjEzNyA3MS42NDksMjQuMTIgNzQuMzM2LDI0LjEyIEM3Ni4zMTMsMjQuMTIgNzguMjksMjMuNTgyIDgwLjA1MywyMi41NjMgQzgwLjA2NCwyMi41NTcgODAuMDc2LDIyLjU1MyA4MC4wODgsMjIuNTUgTDg3LjM3MiwxOC4zNDQgQzg4LjAzOCwxNy45NTkgODguNzg0LDE3Ljc1NiA4OS41MjksMTcuNzU2IEM5MC45NTYsMTcuNzU2IDkyLjIwMSwxOC40NzIgOTIuODU4LDE5LjY3IEw5Ni4xMDcsMjUuNTk5IEM5Ni4xMzgsMjUuNjU0IDk2LjExOCwyNS43MjQgOTYuMDYzLDI1Ljc1NiBMMTIuNTQ1LDczLjk4NSBDMTIuNTI2LDczLjk5NiAxMi41MDYsNzQuMDAxIDEyLjQ4Niw3NC4wMDEgTDEyLjQ4Niw3NC4wMDEgWiBNNjIuMDE2LDE2Ljk5NyBDNjEuMzEyLDE2Ljk5NyA2MC42MDYsMTcuMTkgNTkuOTc1LDE3LjU1NCBMMy45NjUsNDkuODk5IEMyLjA4Myw1MC45ODUgMS4zNDEsNTMuMzA4IDIuMzEsNTUuMDc4IEwxMi41MzEsNzMuNzIzIEw5NS44NDgsMjUuNjExIEw5Mi42NTMsMTkuNzgyIEM5Mi4wMzgsMTguNjYgOTAuODcsMTcuOTkgODkuNTI5LDE3Ljk5IEM4OC44MjUsMTcuOTkgODguMTE5LDE4LjE4MiA4Ny40ODksMTguNTQ3IEw4MC4xNzIsMjIuNzcyIEM4MC4xNjEsMjIuNzc4IDgwLjE0OSwyMi43ODIgODAuMTM3LDIyLjc4NSBDNzguMzQ2LDIzLjgxMSA3Ni4zNDEsMjQuMzU0IDc0LjMzNiwyNC4zNTQgQzcxLjU4OCwyNC4zNTQgNjkuMDMzLDIzLjM0NyA2Ny4xNDIsMjEuNTE5IEw2Ni44NjQsMjEuMjQ5IEM2Ni4yNzcsMjAuNjM0IDY1Ljc3NCwxOS45NDcgNjUuMzY3LDE5LjIwMyBDNjUuMzYsMTkuMTkyIDY1LjM1NiwxOS4xNzkgNjUuMzU0LDE5LjE2NiBMNjUuMTYzLDE4LjgxOSBDNjUuMTU0LDE4LjgxMSA2NS4xNDYsMTguODAxIDY1LjE0LDE4Ljc5IEM2NC41MjUsMTcuNjY3IDYzLjM1NywxNi45OTcgNjIuMDE2LDE2Ljk5NyBMNjIuMDE2LDE2Ljk5NyBaIiBpZD0iRmlsbC03IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQyLjQzNCw0OC44MDggTDQyLjQzNCw0OC44MDggQzM5LjkyNCw0OC44MDcgMzcuNzM3LDQ3LjU1IDM2LjU4Miw0NS40NDMgQzM0Ljc3MSw0Mi4xMzkgMzYuMTQ0LDM3LjgwOSAzOS42NDEsMzUuNzg5IEw1MS45MzIsMjguNjkxIEM1My4xMDMsMjguMDE1IDU0LjQxMywyNy42NTggNTUuNzIxLDI3LjY1OCBDNTguMjMxLDI3LjY1OCA2MC40MTgsMjguOTE2IDYxLjU3MywzMS4wMjMgQzYzLjM4NCwzNC4zMjcgNjIuMDEyLDM4LjY1NyA1OC41MTQsNDAuNjc3IEw0Ni4yMjMsNDcuNzc1IEM0NS4wNTMsNDguNDUgNDMuNzQyLDQ4LjgwOCA0Mi40MzQsNDguODA4IEw0Mi40MzQsNDguODA4IFogTTU1LjcyMSwyOC4xMjUgQzU0LjQ5NSwyOC4xMjUgNTMuMjY1LDI4LjQ2MSA1Mi4xNjYsMjkuMDk2IEwzOS44NzUsMzYuMTk0IEMzNi41OTYsMzguMDg3IDM1LjMwMiw0Mi4xMzYgMzYuOTkyLDQ1LjIxOCBDMzguMDYzLDQ3LjE3MyA0MC4wOTgsNDguMzQgNDIuNDM0LDQ4LjM0IEM0My42NjEsNDguMzQgNDQuODksNDguMDA1IDQ1Ljk5LDQ3LjM3IEw1OC4yODEsNDAuMjcyIEM2MS41NiwzOC4zNzkgNjIuODUzLDM0LjMzIDYxLjE2NCwzMS4yNDggQzYwLjA5MiwyOS4yOTMgNTguMDU4LDI4LjEyNSA1NS43MjEsMjguMTI1IEw1NS43MjEsMjguMTI1IFoiIGlkPSJGaWxsLTgiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjU4OCwyLjQwNyBDMTQ5LjU4OCwyLjQwNyAxNTUuNzY4LDUuOTc1IDE1Ni4zMjUsNi4yOTcgTDE1Ni4zMjUsNy4xODQgQzE1Ni4zMjUsNy4zNiAxNTYuMzM4LDcuNTQ0IDE1Ni4zNjIsNy43MzMgQzE1Ni4zNzMsNy44MTQgMTU2LjM4Miw3Ljg5NCAxNTYuMzksNy45NzUgQzE1Ni41Myw5LjM5IDE1Ny4zNjMsMTAuOTczIDE1OC40OTUsMTEuOTc0IEwxNjUuODkxLDE4LjUxOSBDMTY2LjA2OCwxOC42NzUgMTY2LjI0OSwxOC44MTQgMTY2LjQzMiwxOC45MzQgQzE2OC4wMTEsMTkuOTc0IDE2OS4zODIsMTkuNCAxNjkuNDk0LDE3LjY1MiBDMTY5LjU0MywxNi44NjggMTY5LjU1MSwxNi4wNTcgMTY5LjUxNywxNS4yMjMgTDE2OS41MTQsMTUuMDYzIEwxNjkuNTE0LDEzLjkxMiBDMTcwLjc4LDE0LjY0MiAxOTUuNTAxLDI4LjkxNSAxOTUuNTAxLDI4LjkxNSBMMTk1LjUwMSw4Mi45MTUgQzE5NS41MDEsODQuMDA1IDE5NC43MzEsODQuNDQ1IDE5My43ODEsODMuODk3IEwxNTEuMzA4LDU5LjM3NCBDMTUwLjM1OCw1OC44MjYgMTQ5LjU4OCw1Ny40OTcgMTQ5LjU4OCw1Ni40MDggTDE0OS41ODgsMjIuMzc1IiBpZD0iRmlsbC05IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE5NC41NTMsODQuMjUgQzE5NC4yOTYsODQuMjUgMTk0LjAxMyw4NC4xNjUgMTkzLjcyMiw4My45OTcgTDE1MS4yNSw1OS40NzYgQzE1MC4yNjksNTguOTA5IDE0OS40NzEsNTcuNTMzIDE0OS40NzEsNTYuNDA4IEwxNDkuNDcxLDIyLjM3NSBMMTQ5LjcwNSwyMi4zNzUgTDE0OS43MDUsNTYuNDA4IEMxNDkuNzA1LDU3LjQ1OSAxNTAuNDUsNTguNzQ0IDE1MS4zNjYsNTkuMjc0IEwxOTMuODM5LDgzLjc5NSBDMTk0LjI2Myw4NC4wNCAxOTQuNjU1LDg0LjA4MyAxOTQuOTQyLDgzLjkxNyBDMTk1LjIyNyw4My43NTMgMTk1LjM4NCw4My4zOTcgMTk1LjM4NCw4Mi45MTUgTDE5NS4zODQsMjguOTgyIEMxOTQuMTAyLDI4LjI0MiAxNzIuMTA0LDE1LjU0MiAxNjkuNjMxLDE0LjExNCBMMTY5LjYzNCwxNS4yMiBDMTY5LjY2OCwxNi4wNTIgMTY5LjY2LDE2Ljg3NCAxNjkuNjEsMTcuNjU5IEMxNjkuNTU2LDE4LjUwMyAxNjkuMjE0LDE5LjEyMyAxNjguNjQ3LDE5LjQwNSBDMTY4LjAyOCwxOS43MTQgMTY3LjE5NywxOS41NzggMTY2LjM2NywxOS4wMzIgQzE2Ni4xODEsMTguOTA5IDE2NS45OTUsMTguNzY2IDE2NS44MTQsMTguNjA2IEwxNTguNDE3LDEyLjA2MiBDMTU3LjI1OSwxMS4wMzYgMTU2LjQxOCw5LjQzNyAxNTYuMjc0LDcuOTg2IEMxNTYuMjY2LDcuOTA3IDE1Ni4yNTcsNy44MjcgMTU2LjI0Nyw3Ljc0OCBDMTU2LjIyMSw3LjU1NSAxNTYuMjA5LDcuMzY1IDE1Ni4yMDksNy4xODQgTDE1Ni4yMDksNi4zNjQgQzE1NS4zNzUsNS44ODMgMTQ5LjUyOSwyLjUwOCAxNDkuNTI5LDIuNTA4IEwxNDkuNjQ2LDIuMzA2IEMxNDkuNjQ2LDIuMzA2IDE1NS44MjcsNS44NzQgMTU2LjM4NCw2LjE5NiBMMTU2LjQ0Miw2LjIzIEwxNTYuNDQyLDcuMTg0IEMxNTYuNDQyLDcuMzU1IDE1Ni40NTQsNy41MzUgMTU2LjQ3OCw3LjcxNyBDMTU2LjQ4OSw3LjggMTU2LjQ5OSw3Ljg4MiAxNTYuNTA3LDcuOTYzIEMxNTYuNjQ1LDkuMzU4IDE1Ny40NTUsMTAuODk4IDE1OC41NzIsMTEuODg2IEwxNjUuOTY5LDE4LjQzMSBDMTY2LjE0MiwxOC41ODQgMTY2LjMxOSwxOC43MiAxNjYuNDk2LDE4LjgzNyBDMTY3LjI1NCwxOS4zMzYgMTY4LDE5LjQ2NyAxNjguNTQzLDE5LjE5NiBDMTY5LjAzMywxOC45NTMgMTY5LjMyOSwxOC40MDEgMTY5LjM3NywxNy42NDUgQzE2OS40MjcsMTYuODY3IDE2OS40MzQsMTYuMDU0IDE2OS40MDEsMTUuMjI4IEwxNjkuMzk3LDE1LjA2NSBMMTY5LjM5NywxMy43MSBMMTY5LjU3MiwxMy44MSBDMTcwLjgzOSwxNC41NDEgMTk1LjU1OSwyOC44MTQgMTk1LjU1OSwyOC44MTQgTDE5NS42MTgsMjguODQ3IEwxOTUuNjE4LDgyLjkxNSBDMTk1LjYxOCw4My40ODQgMTk1LjQyLDgzLjkxMSAxOTUuMDU5LDg0LjExOSBDMTk0LjkwOCw4NC4yMDYgMTk0LjczNyw4NC4yNSAxOTQuNTUzLDg0LjI1IiBpZD0iRmlsbC0xMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDUuNjg1LDU2LjE2MSBMMTY5LjgsNzAuMDgzIEwxNDMuODIyLDg1LjA4MSBMMTQyLjM2LDg0Ljc3NCBDMTM1LjgyNiw4Mi42MDQgMTI4LjczMiw4MS4wNDYgMTIxLjM0MSw4MC4xNTggQzExNi45NzYsNzkuNjM0IDExMi42NzgsODEuMjU0IDExMS43NDMsODMuNzc4IEMxMTEuNTA2LDg0LjQxNCAxMTEuNTAzLDg1LjA3MSAxMTEuNzMyLDg1LjcwNiBDMTEzLjI3LDg5Ljk3MyAxMTUuOTY4LDk0LjA2OSAxMTkuNzI3LDk3Ljg0MSBMMTIwLjI1OSw5OC42ODYgQzEyMC4yNiw5OC42ODUgOTQuMjgyLDExMy42ODMgOTQuMjgyLDExMy42ODMgTDcwLjE2Nyw5OS43NjEgTDE0NS42ODUsNTYuMTYxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05NC4yODIsMTEzLjgxOCBMOTQuMjIzLDExMy43ODUgTDY5LjkzMyw5OS43NjEgTDcwLjEwOCw5OS42NiBMMTQ1LjY4NSw1Ni4wMjYgTDE0NS43NDMsNTYuMDU5IEwxNzAuMDMzLDcwLjA4MyBMMTQzLjg0Miw4NS4yMDUgTDE0My43OTcsODUuMTk1IEMxNDMuNzcyLDg1LjE5IDE0Mi4zMzYsODQuODg4IDE0Mi4zMzYsODQuODg4IEMxMzUuNzg3LDgyLjcxNCAxMjguNzIzLDgxLjE2MyAxMjEuMzI3LDgwLjI3NCBDMTIwLjc4OCw4MC4yMDkgMTIwLjIzNiw4MC4xNzcgMTE5LjY4OSw4MC4xNzcgQzExNS45MzEsODAuMTc3IDExMi42MzUsODEuNzA4IDExMS44NTIsODMuODE5IEMxMTEuNjI0LDg0LjQzMiAxMTEuNjIxLDg1LjA1MyAxMTEuODQyLDg1LjY2NyBDMTEzLjM3Nyw4OS45MjUgMTE2LjA1OCw5My45OTMgMTE5LjgxLDk3Ljc1OCBMMTE5LjgyNiw5Ny43NzkgTDEyMC4zNTIsOTguNjE0IEMxMjAuMzU0LDk4LjYxNyAxMjAuMzU2LDk4LjYyIDEyMC4zNTgsOTguNjI0IEwxMjAuNDIyLDk4LjcyNiBMMTIwLjMxNyw5OC43ODcgQzEyMC4yNjQsOTguODE4IDk0LjU5OSwxMTMuNjM1IDk0LjM0LDExMy43ODUgTDk0LjI4MiwxMTMuODE4IEw5NC4yODIsMTEzLjgxOCBaIE03MC40MDEsOTkuNzYxIEw5NC4yODIsMTEzLjU0OSBMMTE5LjA4NCw5OS4yMjkgQzExOS42Myw5OC45MTQgMTE5LjkzLDk4Ljc0IDEyMC4xMDEsOTguNjU0IEwxMTkuNjM1LDk3LjkxNCBDMTE1Ljg2NCw5NC4xMjcgMTEzLjE2OCw5MC4wMzMgMTExLjYyMiw4NS43NDYgQzExMS4zODIsODUuMDc5IDExMS4zODYsODQuNDA0IDExMS42MzMsODMuNzM4IEMxMTIuNDQ4LDgxLjUzOSAxMTUuODM2LDc5Ljk0MyAxMTkuNjg5LDc5Ljk0MyBDMTIwLjI0Niw3OS45NDMgMTIwLjgwNiw3OS45NzYgMTIxLjM1NSw4MC4wNDIgQzEyOC43NjcsODAuOTMzIDEzNS44NDYsODIuNDg3IDE0Mi4zOTYsODQuNjYzIEMxNDMuMjMyLDg0LjgzOCAxNDMuNjExLDg0LjkxNyAxNDMuNzg2LDg0Ljk2NyBMMTY5LjU2Niw3MC4wODMgTDE0NS42ODUsNTYuMjk1IEw3MC40MDEsOTkuNzYxIEw3MC40MDEsOTkuNzYxIFoiIGlkPSJGaWxsLTEyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2Ny4yMywxOC45NzkgTDE2Ny4yMyw2OS44NSBMMTM5LjkwOSw4NS42MjMgTDEzMy40NDgsNzEuNDU2IEMxMzIuNTM4LDY5LjQ2IDEzMC4wMiw2OS43MTggMTI3LjgyNCw3Mi4wMyBDMTI2Ljc2OSw3My4xNCAxMjUuOTMxLDc0LjU4NSAxMjUuNDk0LDc2LjA0OCBMMTE5LjAzNCw5Ny42NzYgTDkxLjcxMiwxMTMuNDUgTDkxLjcxMiw2Mi41NzkgTDE2Ny4yMywxOC45NzkiIGlkPSJGaWxsLTEzIiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTkxLjcxMiwxMTMuNTY3IEM5MS42OTIsMTEzLjU2NyA5MS42NzIsMTEzLjU2MSA5MS42NTMsMTEzLjU1MSBDOTEuNjE4LDExMy41MyA5MS41OTUsMTEzLjQ5MiA5MS41OTUsMTEzLjQ1IEw5MS41OTUsNjIuNTc5IEM5MS41OTUsNjIuNTM3IDkxLjYxOCw2Mi40OTkgOTEuNjUzLDYyLjQ3OCBMMTY3LjE3MiwxOC44NzggQzE2Ny4yMDgsMTguODU3IDE2Ny4yNTIsMTguODU3IDE2Ny4yODgsMTguODc4IEMxNjcuMzI0LDE4Ljg5OSAxNjcuMzQ3LDE4LjkzNyAxNjcuMzQ3LDE4Ljk3OSBMMTY3LjM0Nyw2OS44NSBDMTY3LjM0Nyw2OS44OTEgMTY3LjMyNCw2OS45MyAxNjcuMjg4LDY5Ljk1IEwxMzkuOTY3LDg1LjcyNSBDMTM5LjkzOSw4NS43NDEgMTM5LjkwNSw4NS43NDUgMTM5Ljg3Myw4NS43MzUgQzEzOS44NDIsODUuNzI1IDEzOS44MTYsODUuNzAyIDEzOS44MDIsODUuNjcyIEwxMzMuMzQyLDcxLjUwNCBDMTMyLjk2Nyw3MC42ODIgMTMyLjI4LDcwLjIyOSAxMzEuNDA4LDcwLjIyOSBDMTMwLjMxOSw3MC4yMjkgMTI5LjA0NCw3MC45MTUgMTI3LjkwOCw3Mi4xMSBDMTI2Ljg3NCw3My4yIDEyNi4wMzQsNzQuNjQ3IDEyNS42MDYsNzYuMDgyIEwxMTkuMTQ2LDk3LjcwOSBDMTE5LjEzNyw5Ny43MzggMTE5LjExOCw5Ny43NjIgMTE5LjA5Miw5Ny43NzcgTDkxLjc3LDExMy41NTEgQzkxLjc1MiwxMTMuNTYxIDkxLjczMiwxMTMuNTY3IDkxLjcxMiwxMTMuNTY3IEw5MS43MTIsMTEzLjU2NyBaIE05MS44MjksNjIuNjQ3IEw5MS44MjksMTEzLjI0OCBMMTE4LjkzNSw5Ny41OTggTDEyNS4zODIsNzYuMDE1IEMxMjUuODI3LDc0LjUyNSAxMjYuNjY0LDczLjA4MSAxMjcuNzM5LDcxLjk1IEMxMjguOTE5LDcwLjcwOCAxMzAuMjU2LDY5Ljk5NiAxMzEuNDA4LDY5Ljk5NiBDMTMyLjM3Nyw2OS45OTYgMTMzLjEzOSw3MC40OTcgMTMzLjU1NCw3MS40MDcgTDEzOS45NjEsODUuNDU4IEwxNjcuMTEzLDY5Ljc4MiBMMTY3LjExMywxOS4xODEgTDkxLjgyOSw2Mi42NDcgTDkxLjgyOSw2Mi42NDcgWiIgaWQ9IkZpbGwtMTQiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTY4LjU0MywxOS4yMTMgTDE2OC41NDMsNzAuMDgzIEwxNDEuMjIxLDg1Ljg1NyBMMTM0Ljc2MSw3MS42ODkgQzEzMy44NTEsNjkuNjk0IDEzMS4zMzMsNjkuOTUxIDEyOS4xMzcsNzIuMjYzIEMxMjguMDgyLDczLjM3NCAxMjcuMjQ0LDc0LjgxOSAxMjYuODA3LDc2LjI4MiBMMTIwLjM0Niw5Ny45MDkgTDkzLjAyNSwxMTMuNjgzIEw5My4wMjUsNjIuODEzIEwxNjguNTQzLDE5LjIxMyIgaWQ9IkZpbGwtMTUiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTMuMDI1LDExMy44IEM5My4wMDUsMTEzLjggOTIuOTg0LDExMy43OTUgOTIuOTY2LDExMy43ODUgQzkyLjkzMSwxMTMuNzY0IDkyLjkwOCwxMTMuNzI1IDkyLjkwOCwxMTMuNjg0IEw5Mi45MDgsNjIuODEzIEM5Mi45MDgsNjIuNzcxIDkyLjkzMSw2Mi43MzMgOTIuOTY2LDYyLjcxMiBMMTY4LjQ4NCwxOS4xMTIgQzE2OC41MiwxOS4wOSAxNjguNTY1LDE5LjA5IDE2OC42MDEsMTkuMTEyIEMxNjguNjM3LDE5LjEzMiAxNjguNjYsMTkuMTcxIDE2OC42NiwxOS4yMTIgTDE2OC42Niw3MC4wODMgQzE2OC42Niw3MC4xMjUgMTY4LjYzNyw3MC4xNjQgMTY4LjYwMSw3MC4xODQgTDE0MS4yOCw4NS45NTggQzE0MS4yNTEsODUuOTc1IDE0MS4yMTcsODUuOTc5IDE0MS4xODYsODUuOTY4IEMxNDEuMTU0LDg1Ljk1OCAxNDEuMTI5LDg1LjkzNiAxNDEuMTE1LDg1LjkwNiBMMTM0LjY1NSw3MS43MzggQzEzNC4yOCw3MC45MTUgMTMzLjU5Myw3MC40NjMgMTMyLjcyLDcwLjQ2MyBDMTMxLjYzMiw3MC40NjMgMTMwLjM1Nyw3MS4xNDggMTI5LjIyMSw3Mi4zNDQgQzEyOC4xODYsNzMuNDMzIDEyNy4zNDcsNzQuODgxIDEyNi45MTksNzYuMzE1IEwxMjAuNDU4LDk3Ljk0MyBDMTIwLjQ1LDk3Ljk3MiAxMjAuNDMxLDk3Ljk5NiAxMjAuNDA1LDk4LjAxIEw5My4wODMsMTEzLjc4NSBDOTMuMDY1LDExMy43OTUgOTMuMDQ1LDExMy44IDkzLjAyNSwxMTMuOCBMOTMuMDI1LDExMy44IFogTTkzLjE0Miw2Mi44ODEgTDkzLjE0MiwxMTMuNDgxIEwxMjAuMjQ4LDk3LjgzMiBMMTI2LjY5NSw3Ni4yNDggQzEyNy4xNCw3NC43NTggMTI3Ljk3Nyw3My4zMTUgMTI5LjA1Miw3Mi4xODMgQzEzMC4yMzEsNzAuOTQyIDEzMS41NjgsNzAuMjI5IDEzMi43Miw3MC4yMjkgQzEzMy42ODksNzAuMjI5IDEzNC40NTIsNzAuNzMxIDEzNC44NjcsNzEuNjQxIEwxNDEuMjc0LDg1LjY5MiBMMTY4LjQyNiw3MC4wMTYgTDE2OC40MjYsMTkuNDE1IEw5My4xNDIsNjIuODgxIEw5My4xNDIsNjIuODgxIFoiIGlkPSJGaWxsLTE2IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS44LDcwLjA4MyBMMTQyLjQ3OCw4NS44NTcgTDEzNi4wMTgsNzEuNjg5IEMxMzUuMTA4LDY5LjY5NCAxMzIuNTksNjkuOTUxIDEzMC4zOTMsNzIuMjYzIEMxMjkuMzM5LDczLjM3NCAxMjguNSw3NC44MTkgMTI4LjA2NCw3Ni4yODIgTDEyMS42MDMsOTcuOTA5IEw5NC4yODIsMTEzLjY4MyBMOTQuMjgyLDYyLjgxMyBMMTY5LjgsMTkuMjEzIEwxNjkuOCw3MC4wODMgWiIgaWQ9IkZpbGwtMTciIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTQuMjgyLDExMy45MTcgQzk0LjI0MSwxMTMuOTE3IDk0LjIwMSwxMTMuOTA3IDk0LjE2NSwxMTMuODg2IEM5NC4wOTMsMTEzLjg0NSA5NC4wNDgsMTEzLjc2NyA5NC4wNDgsMTEzLjY4NCBMOTQuMDQ4LDYyLjgxMyBDOTQuMDQ4LDYyLjczIDk0LjA5Myw2Mi42NTIgOTQuMTY1LDYyLjYxMSBMMTY5LjY4MywxOS4wMSBDMTY5Ljc1NSwxOC45NjkgMTY5Ljg0NCwxOC45NjkgMTY5LjkxNywxOS4wMSBDMTY5Ljk4OSwxOS4wNTIgMTcwLjAzMywxOS4xMjkgMTcwLjAzMywxOS4yMTIgTDE3MC4wMzMsNzAuMDgzIEMxNzAuMDMzLDcwLjE2NiAxNjkuOTg5LDcwLjI0NCAxNjkuOTE3LDcwLjI4NSBMMTQyLjU5NSw4Ni4wNiBDMTQyLjUzOCw4Ni4wOTIgMTQyLjQ2OSw4Ni4xIDE0Mi40MDcsODYuMDggQzE0Mi4zNDQsODYuMDYgMTQyLjI5Myw4Ni4wMTQgMTQyLjI2Niw4NS45NTQgTDEzNS44MDUsNzEuNzg2IEMxMzUuNDQ1LDcwLjk5NyAxMzQuODEzLDcwLjU4IDEzMy45NzcsNzAuNTggQzEzMi45MjEsNzAuNTggMTMxLjY3Niw3MS4yNTIgMTMwLjU2Miw3Mi40MjQgQzEyOS41NCw3My41MDEgMTI4LjcxMSw3NC45MzEgMTI4LjI4Nyw3Ni4zNDggTDEyMS44MjcsOTcuOTc2IEMxMjEuODEsOTguMDM0IDEyMS43NzEsOTguMDgyIDEyMS43Miw5OC4xMTIgTDk0LjM5OCwxMTMuODg2IEM5NC4zNjIsMTEzLjkwNyA5NC4zMjIsMTEzLjkxNyA5NC4yODIsMTEzLjkxNyBMOTQuMjgyLDExMy45MTcgWiBNOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDExMy4yNzkgTDEyMS40MDYsOTcuNzU0IEwxMjcuODQsNzYuMjE1IEMxMjguMjksNzQuNzA4IDEyOS4xMzcsNzMuMjQ3IDEzMC4yMjQsNzIuMTAzIEMxMzEuNDI1LDcwLjgzOCAxMzIuNzkzLDcwLjExMiAxMzMuOTc3LDcwLjExMiBDMTM0Ljk5NSw3MC4xMTIgMTM1Ljc5NSw3MC42MzggMTM2LjIzLDcxLjU5MiBMMTQyLjU4NCw4NS41MjYgTDE2OS41NjYsNjkuOTQ4IEwxNjkuNTY2LDE5LjYxNyBMOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDYyLjk0OCBaIiBpZD0iRmlsbC0xOCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMDkuODk0LDkyLjk0MyBMMTA5Ljg5NCw5Mi45NDMgQzEwOC4xMiw5Mi45NDMgMTA2LjY1Myw5Mi4yMTggMTA1LjY1LDkwLjgyMyBDMTA1LjU4Myw5MC43MzEgMTA1LjU5Myw5MC42MSAxMDUuNjczLDkwLjUyOSBDMTA1Ljc1Myw5MC40NDggMTA1Ljg4LDkwLjQ0IDEwNS45NzQsOTAuNTA2IEMxMDYuNzU0LDkxLjA1MyAxMDcuNjc5LDkxLjMzMyAxMDguNzI0LDkxLjMzMyBDMTEwLjA0Nyw5MS4zMzMgMTExLjQ3OCw5MC44OTQgMTEyLjk4LDkwLjAyNyBDMTE4LjI5MSw4Ni45NiAxMjIuNjExLDc5LjUwOSAxMjIuNjExLDczLjQxNiBDMTIyLjYxMSw3MS40ODkgMTIyLjE2OSw2OS44NTYgMTIxLjMzMyw2OC42OTIgQzEyMS4yNjYsNjguNiAxMjEuMjc2LDY4LjQ3MyAxMjEuMzU2LDY4LjM5MiBDMTIxLjQzNiw2OC4zMTEgMTIxLjU2Myw2OC4yOTkgMTIxLjY1Niw2OC4zNjUgQzEyMy4zMjcsNjkuNTM3IDEyNC4yNDcsNzEuNzQ2IDEyNC4yNDcsNzQuNTg0IEMxMjQuMjQ3LDgwLjgyNiAxMTkuODIxLDg4LjQ0NyAxMTQuMzgyLDkxLjU4NyBDMTEyLjgwOCw5Mi40OTUgMTExLjI5OCw5Mi45NDMgMTA5Ljg5NCw5Mi45NDMgTDEwOS44OTQsOTIuOTQzIFogTTEwNi45MjUsOTEuNDAxIEMxMDcuNzM4LDkyLjA1MiAxMDguNzQ1LDkyLjI3OCAxMDkuODkzLDkyLjI3OCBMMTA5Ljg5NCw5Mi4yNzggQzExMS4yMTUsOTIuMjc4IDExMi42NDcsOTEuOTUxIDExNC4xNDgsOTEuMDg0IEMxMTkuNDU5LDg4LjAxNyAxMjMuNzgsODAuNjIxIDEyMy43OCw3NC41MjggQzEyMy43OCw3Mi41NDkgMTIzLjMxNyw3MC45MjkgMTIyLjQ1NCw2OS43NjcgQzEyMi44NjUsNzAuODAyIDEyMy4wNzksNzIuMDQyIDEyMy4wNzksNzMuNDAyIEMxMjMuMDc5LDc5LjY0NSAxMTguNjUzLDg3LjI4NSAxMTMuMjE0LDkwLjQyNSBDMTExLjY0LDkxLjMzNCAxMTAuMTMsOTEuNzQyIDEwOC43MjQsOTEuNzQyIEMxMDguMDgzLDkxLjc0MiAxMDcuNDgxLDkxLjU5MyAxMDYuOTI1LDkxLjQwMSBMMTA2LjkyNSw5MS40MDEgWiIgaWQ9IkZpbGwtMTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjA5Nyw5MC4yMyBDMTE4LjQ4MSw4Ny4xMjIgMTIyLjg0NSw3OS41OTQgMTIyLjg0NSw3My40MTYgQzEyMi44NDUsNzEuMzY1IDEyMi4zNjIsNjkuNzI0IDEyMS41MjIsNjguNTU2IEMxMTkuNzM4LDY3LjMwNCAxMTcuMTQ4LDY3LjM2MiAxMTQuMjY1LDY5LjAyNiBDMTA4Ljg4MSw3Mi4xMzQgMTA0LjUxNyw3OS42NjIgMTA0LjUxNyw4NS44NCBDMTA0LjUxNyw4Ny44OTEgMTA1LDg5LjUzMiAxMDUuODQsOTAuNyBDMTA3LjYyNCw5MS45NTIgMTEwLjIxNCw5MS44OTQgMTEzLjA5Nyw5MC4yMyIgaWQ9IkZpbGwtMjAiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTA4LjcyNCw5MS42MTQgTDEwOC43MjQsOTEuNjE0IEMxMDcuNTgyLDkxLjYxNCAxMDYuNTY2LDkxLjQwMSAxMDUuNzA1LDkwLjc5NyBDMTA1LjY4NCw5MC43ODMgMTA1LjY2NSw5MC44MTEgMTA1LjY1LDkwLjc5IEMxMDQuNzU2LDg5LjU0NiAxMDQuMjgzLDg3Ljg0MiAxMDQuMjgzLDg1LjgxNyBDMTA0LjI4Myw3OS41NzUgMTA4LjcwOSw3MS45NTMgMTE0LjE0OCw2OC44MTIgQzExNS43MjIsNjcuOTA0IDExNy4yMzIsNjcuNDQ5IDExOC42MzgsNjcuNDQ5IEMxMTkuNzgsNjcuNDQ5IDEyMC43OTYsNjcuNzU4IDEyMS42NTYsNjguMzYyIEMxMjEuNjc4LDY4LjM3NyAxMjEuNjk3LDY4LjM5NyAxMjEuNzEyLDY4LjQxOCBDMTIyLjYwNiw2OS42NjIgMTIzLjA3OSw3MS4zOSAxMjMuMDc5LDczLjQxNSBDMTIzLjA3OSw3OS42NTggMTE4LjY1Myw4Ny4xOTggMTEzLjIxNCw5MC4zMzggQzExMS42NCw5MS4yNDcgMTEwLjEzLDkxLjYxNCAxMDguNzI0LDkxLjYxNCBMMTA4LjcyNCw5MS42MTQgWiBNMTA2LjAwNiw5MC41MDUgQzEwNi43OCw5MS4wMzcgMTA3LjY5NCw5MS4yODEgMTA4LjcyNCw5MS4yODEgQzExMC4wNDcsOTEuMjgxIDExMS40NzgsOTAuODY4IDExMi45OCw5MC4wMDEgQzExOC4yOTEsODYuOTM1IDEyMi42MTEsNzkuNDk2IDEyMi42MTEsNzMuNDAzIEMxMjIuNjExLDcxLjQ5NCAxMjIuMTc3LDY5Ljg4IDEyMS4zNTYsNjguNzE4IEMxMjAuNTgyLDY4LjE4NSAxMTkuNjY4LDY3LjkxOSAxMTguNjM4LDY3LjkxOSBDMTE3LjMxNSw2Ny45MTkgMTE1Ljg4Myw2OC4zNiAxMTQuMzgyLDY5LjIyNyBDMTA5LjA3MSw3Mi4yOTMgMTA0Ljc1MSw3OS43MzMgMTA0Ljc1MSw4NS44MjYgQzEwNC43NTEsODcuNzM1IDEwNS4xODUsODkuMzQzIDEwNi4wMDYsOTAuNTA1IEwxMDYuMDA2LDkwLjUwNSBaIiBpZD0iRmlsbC0yMSIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDkuMzE4LDcuMjYyIEwxMzkuMzM0LDE2LjE0IEwxNTUuMjI3LDI3LjE3MSBMMTYwLjgxNiwyMS4wNTkgTDE0OS4zMTgsNy4yNjIiIGlkPSJGaWxsLTIyIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS42NzYsMTMuODQgTDE1OS45MjgsMTkuNDY3IEMxNTYuMjg2LDIxLjU3IDE1MC40LDIxLjU4IDE0Ni43ODEsMTkuNDkxIEMxNDMuMTYxLDE3LjQwMiAxNDMuMTgsMTQuMDAzIDE0Ni44MjIsMTEuOSBMMTU2LjMxNyw2LjI5MiBMMTQ5LjU4OCwyLjQwNyBMNjcuNzUyLDQ5LjQ3OCBMMTEzLjY3NSw3NS45OTIgTDExNi43NTYsNzQuMjEzIEMxMTcuMzg3LDczLjg0OCAxMTcuNjI1LDczLjMxNSAxMTcuMzc0LDcyLjgyMyBDMTE1LjAxNyw2OC4xOTEgMTE0Ljc4MSw2My4yNzcgMTE2LjY5MSw1OC41NjEgQzEyMi4zMjksNDQuNjQxIDE0MS4yLDMzLjc0NiAxNjUuMzA5LDMwLjQ5MSBDMTczLjQ3OCwyOS4zODggMTgxLjk4OSwyOS41MjQgMTkwLjAxMywzMC44ODUgQzE5MC44NjUsMzEuMDMgMTkxLjc4OSwzMC44OTMgMTkyLjQyLDMwLjUyOCBMMTk1LjUwMSwyOC43NSBMMTY5LjY3NiwxMy44NCIgaWQ9IkZpbGwtMjMiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3Ni40NTkgQzExMy41OTQsNzYuNDU5IDExMy41MTQsNzYuNDM4IDExMy40NDIsNzYuMzk3IEw2Ny41MTgsNDkuODgyIEM2Ny4zNzQsNDkuNzk5IDY3LjI4NCw0OS42NDUgNjcuMjg1LDQ5LjQ3OCBDNjcuMjg1LDQ5LjMxMSA2Ny4zNzQsNDkuMTU3IDY3LjUxOSw0OS4wNzMgTDE0OS4zNTUsMi4wMDIgQzE0OS40OTksMS45MTkgMTQ5LjY3NywxLjkxOSAxNDkuODIxLDIuMDAyIEwxNTYuNTUsNS44ODcgQzE1Ni43NzQsNi4wMTcgMTU2Ljg1LDYuMzAyIDE1Ni43MjIsNi41MjYgQzE1Ni41OTIsNi43NDkgMTU2LjMwNyw2LjgyNiAxNTYuMDgzLDYuNjk2IEwxNDkuNTg3LDIuOTQ2IEw2OC42ODcsNDkuNDc5IEwxMTMuNjc1LDc1LjQ1MiBMMTE2LjUyMyw3My44MDggQzExNi43MTUsNzMuNjk3IDExNy4xNDMsNzMuMzk5IDExNi45NTgsNzMuMDM1IEMxMTQuNTQyLDY4LjI4NyAxMTQuMyw2My4yMjEgMTE2LjI1OCw1OC4zODUgQzExOS4wNjQsNTEuNDU4IDEyNS4xNDMsNDUuMTQzIDEzMy44NCw0MC4xMjIgQzE0Mi40OTcsMzUuMTI0IDE1My4zNTgsMzEuNjMzIDE2NS4yNDcsMzAuMDI4IEMxNzMuNDQ1LDI4LjkyMSAxODIuMDM3LDI5LjA1OCAxOTAuMDkxLDMwLjQyNSBDMTkwLjgzLDMwLjU1IDE5MS42NTIsMzAuNDMyIDE5Mi4xODYsMzAuMTI0IEwxOTQuNTY3LDI4Ljc1IEwxNjkuNDQyLDE0LjI0NCBDMTY5LjIxOSwxNC4xMTUgMTY5LjE0MiwxMy44MjkgMTY5LjI3MSwxMy42MDYgQzE2OS40LDEzLjM4MiAxNjkuNjg1LDEzLjMwNiAxNjkuOTA5LDEzLjQzNSBMMTk1LjczNCwyOC4zNDUgQzE5NS44NzksMjguNDI4IDE5NS45NjgsMjguNTgzIDE5NS45NjgsMjguNzUgQzE5NS45NjgsMjguOTE2IDE5NS44NzksMjkuMDcxIDE5NS43MzQsMjkuMTU0IEwxOTIuNjUzLDMwLjkzMyBDMTkxLjkzMiwzMS4zNSAxOTAuODksMzEuNTA4IDE4OS45MzUsMzEuMzQ2IEMxODEuOTcyLDI5Ljk5NSAxNzMuNDc4LDI5Ljg2IDE2NS4zNzIsMzAuOTU0IEMxNTMuNjAyLDMyLjU0MyAxNDIuODYsMzUuOTkzIDEzNC4zMDcsNDAuOTMxIEMxMjUuNzkzLDQ1Ljg0NyAxMTkuODUxLDUyLjAwNCAxMTcuMTI0LDU4LjczNiBDMTE1LjI3LDYzLjMxNCAxMTUuNTAxLDY4LjExMiAxMTcuNzksNzIuNjExIEMxMTguMTYsNzMuMzM2IDExNy44NDUsNzQuMTI0IDExNi45OSw3NC42MTcgTDExMy45MDksNzYuMzk3IEMxMTMuODM2LDc2LjQzOCAxMTMuNzU2LDc2LjQ1OSAxMTMuNjc1LDc2LjQ1OSIgaWQ9IkZpbGwtMjQiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUzLjMxNiwyMS4yNzkgQzE1MC45MDMsMjEuMjc5IDE0OC40OTUsMjAuNzUxIDE0Ni42NjQsMTkuNjkzIEMxNDQuODQ2LDE4LjY0NCAxNDMuODQ0LDE3LjIzMiAxNDMuODQ0LDE1LjcxOCBDMTQzLjg0NCwxNC4xOTEgMTQ0Ljg2LDEyLjc2MyAxNDYuNzA1LDExLjY5OCBMMTU2LjE5OCw2LjA5MSBDMTU2LjMwOSw2LjAyNSAxNTYuNDUyLDYuMDYyIDE1Ni41MTgsNi4xNzMgQzE1Ni41ODMsNi4yODQgMTU2LjU0Nyw2LjQyNyAxNTYuNDM2LDYuNDkzIEwxNDYuOTQsMTIuMTAyIEMxNDUuMjQ0LDEzLjA4MSAxNDQuMzEyLDE0LjM2NSAxNDQuMzEyLDE1LjcxOCBDMTQ0LjMxMiwxNy4wNTggMTQ1LjIzLDE4LjMyNiAxNDYuODk3LDE5LjI4OSBDMTUwLjQ0NiwyMS4zMzggMTU2LjI0LDIxLjMyNyAxNTkuODExLDE5LjI2NSBMMTY5LjU1OSwxMy42MzcgQzE2OS42NywxMy41NzMgMTY5LjgxMywxMy42MTEgMTY5Ljg3OCwxMy43MjMgQzE2OS45NDMsMTMuODM0IDE2OS45MDQsMTMuOTc3IDE2OS43OTMsMTQuMDQyIEwxNjAuMDQ1LDE5LjY3IEMxNTguMTg3LDIwLjc0MiAxNTUuNzQ5LDIxLjI3OSAxNTMuMzE2LDIxLjI3OSIgaWQ9IkZpbGwtMjUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3NS45OTIgTDY3Ljc2Miw0OS40ODQiIGlkPSJGaWxsLTI2IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMy42NzUsNzYuMzQyIEMxMTMuNjE1LDc2LjM0MiAxMTMuNTU1LDc2LjMyNyAxMTMuNSw3Ni4yOTUgTDY3LjU4Nyw0OS43ODcgQzY3LjQxOSw0OS42OSA2Ny4zNjIsNDkuNDc2IDY3LjQ1OSw0OS4zMDkgQzY3LjU1Niw0OS4xNDEgNjcuNzcsNDkuMDgzIDY3LjkzNyw0OS4xOCBMMTEzLjg1LDc1LjY4OCBDMTE0LjAxOCw3NS43ODUgMTE0LjA3NSw3NiAxMTMuOTc4LDc2LjE2NyBDMTEzLjkxNCw3Ni4yNzkgMTEzLjc5Niw3Ni4zNDIgMTEzLjY3NSw3Ni4zNDIiIGlkPSJGaWxsLTI3IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY3Ljc2Miw0OS40ODQgTDY3Ljc2MiwxMDMuNDg1IEM2Ny43NjIsMTA0LjU3NSA2OC41MzIsMTA1LjkwMyA2OS40ODIsMTA2LjQ1MiBMMTExLjk1NSwxMzAuOTczIEMxMTIuOTA1LDEzMS41MjIgMTEzLjY3NSwxMzEuMDgzIDExMy42NzUsMTI5Ljk5MyBMMTEzLjY3NSw3NS45OTIiIGlkPSJGaWxsLTI4IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMi43MjcsMTMxLjU2MSBDMTEyLjQzLDEzMS41NjEgMTEyLjEwNywxMzEuNDY2IDExMS43OCwxMzEuMjc2IEw2OS4zMDcsMTA2Ljc1NSBDNjguMjQ0LDEwNi4xNDIgNjcuNDEyLDEwNC43MDUgNjcuNDEyLDEwMy40ODUgTDY3LjQxMiw0OS40ODQgQzY3LjQxMiw0OS4yOSA2Ny41NjksNDkuMTM0IDY3Ljc2Miw0OS4xMzQgQzY3Ljk1Niw0OS4xMzQgNjguMTEzLDQ5LjI5IDY4LjExMyw0OS40ODQgTDY4LjExMywxMDMuNDg1IEM2OC4xMTMsMTA0LjQ0NSA2OC44MiwxMDUuNjY1IDY5LjY1NywxMDYuMTQ4IEwxMTIuMTMsMTMwLjY3IEMxMTIuNDc0LDEzMC44NjggMTEyLjc5MSwxMzAuOTEzIDExMywxMzAuNzkyIEMxMTMuMjA2LDEzMC42NzMgMTEzLjMyNSwxMzAuMzgxIDExMy4zMjUsMTI5Ljk5MyBMMTEzLjMyNSw3NS45OTIgQzExMy4zMjUsNzUuNzk4IDExMy40ODIsNzUuNjQxIDExMy42NzUsNzUuNjQxIEMxMTMuODY5LDc1LjY0MSAxMTQuMDI1LDc1Ljc5OCAxMTQuMDI1LDc1Ljk5MiBMMTE0LjAyNSwxMjkuOTkzIEMxMTQuMDI1LDEzMC42NDggMTEzLjc4NiwxMzEuMTQ3IDExMy4zNSwxMzEuMzk5IEMxMTMuMTYyLDEzMS41MDcgMTEyLjk1MiwxMzEuNTYxIDExMi43MjcsMTMxLjU2MSIgaWQ9IkZpbGwtMjkiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEyLjg2LDQwLjUxMiBDMTEyLjg2LDQwLjUxMiAxMTIuODYsNDAuNTEyIDExMi44NTksNDAuNTEyIEMxMTAuNTQxLDQwLjUxMiAxMDguMzYsMzkuOTkgMTA2LjcxNywzOS4wNDEgQzEwNS4wMTIsMzguMDU3IDEwNC4wNzQsMzYuNzI2IDEwNC4wNzQsMzUuMjkyIEMxMDQuMDc0LDMzLjg0NyAxMDUuMDI2LDMyLjUwMSAxMDYuNzU0LDMxLjUwNCBMMTE4Ljc5NSwyNC41NTEgQzEyMC40NjMsMjMuNTg5IDEyMi42NjksMjMuMDU4IDEyNS4wMDcsMjMuMDU4IEMxMjcuMzI1LDIzLjA1OCAxMjkuNTA2LDIzLjU4MSAxMzEuMTUsMjQuNTMgQzEzMi44NTQsMjUuNTE0IDEzMy43OTMsMjYuODQ1IDEzMy43OTMsMjguMjc4IEMxMzMuNzkzLDI5LjcyNCAxMzIuODQxLDMxLjA2OSAxMzEuMTEzLDMyLjA2NyBMMTE5LjA3MSwzOS4wMTkgQzExNy40MDMsMzkuOTgyIDExNS4xOTcsNDAuNTEyIDExMi44Niw0MC41MTIgTDExMi44Niw0MC41MTIgWiBNMTI1LjAwNywyMy43NTkgQzEyMi43OSwyMy43NTkgMTIwLjcwOSwyNC4yNTYgMTE5LjE0NiwyNS4xNTggTDEwNy4xMDQsMzIuMTEgQzEwNS42MDIsMzIuOTc4IDEwNC43NzQsMzQuMTA4IDEwNC43NzQsMzUuMjkyIEMxMDQuNzc0LDM2LjQ2NSAxMDUuNTg5LDM3LjU4MSAxMDcuMDY3LDM4LjQzNCBDMTA4LjYwNSwzOS4zMjMgMTEwLjY2MywzOS44MTIgMTEyLjg1OSwzOS44MTIgTDExMi44NiwzOS44MTIgQzExNS4wNzYsMzkuODEyIDExNy4xNTgsMzkuMzE1IDExOC43MjEsMzguNDEzIEwxMzAuNzYyLDMxLjQ2IEMxMzIuMjY0LDMwLjU5MyAxMzMuMDkyLDI5LjQ2MyAxMzMuMDkyLDI4LjI3OCBDMTMzLjA5MiwyNy4xMDYgMTMyLjI3OCwyNS45OSAxMzAuOCwyNS4xMzYgQzEyOS4yNjEsMjQuMjQ4IDEyNy4yMDQsMjMuNzU5IDEyNS4wMDcsMjMuNzU5IEwxMjUuMDA3LDIzLjc1OSBaIiBpZD0iRmlsbC0zMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNjUuNjMsMTYuMjE5IEwxNTkuODk2LDE5LjUzIEMxNTYuNzI5LDIxLjM1OCAxNTEuNjEsMjEuMzY3IDE0OC40NjMsMTkuNTUgQzE0NS4zMTYsMTcuNzMzIDE0NS4zMzIsMTQuNzc4IDE0OC40OTksMTIuOTQ5IEwxNTQuMjMzLDkuNjM5IEwxNjUuNjMsMTYuMjE5IiBpZD0iRmlsbC0zMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNTQuMjMzLDEwLjQ0OCBMMTY0LjIyOCwxNi4yMTkgTDE1OS41NDYsMTguOTIzIEMxNTguMTEyLDE5Ljc1IDE1Ni4xOTQsMjAuMjA2IDE1NC4xNDcsMjAuMjA2IEMxNTIuMTE4LDIwLjIwNiAxNTAuMjI0LDE5Ljc1NyAxNDguODE0LDE4Ljk0MyBDMTQ3LjUyNCwxOC4xOTkgMTQ2LjgxNCwxNy4yNDkgMTQ2LjgxNCwxNi4yNjkgQzE0Ni44MTQsMTUuMjc4IDE0Ny41MzcsMTQuMzE0IDE0OC44NSwxMy41NTYgTDE1NC4yMzMsMTAuNDQ4IE0xNTQuMjMzLDkuNjM5IEwxNDguNDk5LDEyLjk0OSBDMTQ1LjMzMiwxNC43NzggMTQ1LjMxNiwxNy43MzMgMTQ4LjQ2MywxOS41NSBDMTUwLjAzMSwyMC40NTUgMTUyLjA4NiwyMC45MDcgMTU0LjE0NywyMC45MDcgQzE1Ni4yMjQsMjAuOTA3IDE1OC4zMDYsMjAuNDQ3IDE1OS44OTYsMTkuNTMgTDE2NS42MywxNi4yMTkgTDE1NC4yMzMsOS42MzkiIGlkPSJGaWxsLTMyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NS40NDUsNzIuNjY3IEwxNDUuNDQ1LDcyLjY2NyBDMTQzLjY3Miw3Mi42NjcgMTQyLjIwNCw3MS44MTcgMTQxLjIwMiw3MC40MjIgQzE0MS4xMzUsNzAuMzMgMTQxLjE0NSw3MC4xNDcgMTQxLjIyNSw3MC4wNjYgQzE0MS4zMDUsNjkuOTg1IDE0MS40MzIsNjkuOTQ2IDE0MS41MjUsNzAuMDExIEMxNDIuMzA2LDcwLjU1OSAxNDMuMjMxLDcwLjgyMyAxNDQuMjc2LDcwLjgyMiBDMTQ1LjU5OCw3MC44MjIgMTQ3LjAzLDcwLjM3NiAxNDguNTMyLDY5LjUwOSBDMTUzLjg0Miw2Ni40NDMgMTU4LjE2Myw1OC45ODcgMTU4LjE2Myw1Mi44OTQgQzE1OC4xNjMsNTAuOTY3IDE1Ny43MjEsNDkuMzMyIDE1Ni44ODQsNDguMTY4IEMxNTYuODE4LDQ4LjA3NiAxNTYuODI4LDQ3Ljk0OCAxNTYuOTA4LDQ3Ljg2NyBDMTU2Ljk4OCw0Ny43ODYgMTU3LjExNCw0Ny43NzQgMTU3LjIwOCw0Ny44NCBDMTU4Ljg3OCw0OS4wMTIgMTU5Ljc5OCw1MS4yMiAxNTkuNzk4LDU0LjA1OSBDMTU5Ljc5OCw2MC4zMDEgMTU1LjM3Myw2OC4wNDYgMTQ5LjkzMyw3MS4xODYgQzE0OC4zNiw3Mi4wOTQgMTQ2Ljg1LDcyLjY2NyAxNDUuNDQ1LDcyLjY2NyBMMTQ1LjQ0NSw3Mi42NjcgWiBNMTQyLjQ3Niw3MSBDMTQzLjI5LDcxLjY1MSAxNDQuMjk2LDcyLjAwMiAxNDUuNDQ1LDcyLjAwMiBDMTQ2Ljc2Nyw3Mi4wMDIgMTQ4LjE5OCw3MS41NSAxNDkuNyw3MC42ODIgQzE1NS4wMSw2Ny42MTcgMTU5LjMzMSw2MC4xNTkgMTU5LjMzMSw1NC4wNjUgQzE1OS4zMzEsNTIuMDg1IDE1OC44NjgsNTAuNDM1IDE1OC4wMDYsNDkuMjcyIEMxNTguNDE3LDUwLjMwNyAxNTguNjMsNTEuNTMyIDE1OC42Myw1Mi44OTIgQzE1OC42Myw1OS4xMzQgMTU0LjIwNSw2Ni43NjcgMTQ4Ljc2NSw2OS45MDcgQzE0Ny4xOTIsNzAuODE2IDE0NS42ODEsNzEuMjgzIDE0NC4yNzYsNzEuMjgzIEMxNDMuNjM0LDcxLjI4MyAxNDMuMDMzLDcxLjE5MiAxNDIuNDc2LDcxIEwxNDIuNDc2LDcxIFoiIGlkPSJGaWxsLTMzIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0OC42NDgsNjkuNzA0IEMxNTQuMDMyLDY2LjU5NiAxNTguMzk2LDU5LjA2OCAxNTguMzk2LDUyLjg5MSBDMTU4LjM5Niw1MC44MzkgMTU3LjkxMyw0OS4xOTggMTU3LjA3NCw0OC4wMyBDMTU1LjI4OSw0Ni43NzggMTUyLjY5OSw0Ni44MzYgMTQ5LjgxNiw0OC41MDEgQzE0NC40MzMsNTEuNjA5IDE0MC4wNjgsNTkuMTM3IDE0MC4wNjgsNjUuMzE0IEMxNDAuMDY4LDY3LjM2NSAxNDAuNTUyLDY5LjAwNiAxNDEuMzkxLDcwLjE3NCBDMTQzLjE3Niw3MS40MjcgMTQ1Ljc2NSw3MS4zNjkgMTQ4LjY0OCw2OS43MDQiIGlkPSJGaWxsLTM0IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NC4yNzYsNzEuMjc2IEwxNDQuMjc2LDcxLjI3NiBDMTQzLjEzMyw3MS4yNzYgMTQyLjExOCw3MC45NjkgMTQxLjI1Nyw3MC4zNjUgQzE0MS4yMzYsNzAuMzUxIDE0MS4yMTcsNzAuMzMyIDE0MS4yMDIsNzAuMzExIEMxNDAuMzA3LDY5LjA2NyAxMzkuODM1LDY3LjMzOSAxMzkuODM1LDY1LjMxNCBDMTM5LjgzNSw1OS4wNzMgMTQ0LjI2LDUxLjQzOSAxNDkuNyw0OC4yOTggQzE1MS4yNzMsNDcuMzkgMTUyLjc4NCw0Ni45MjkgMTU0LjE4OSw0Ni45MjkgQzE1NS4zMzIsNDYuOTI5IDE1Ni4zNDcsNDcuMjM2IDE1Ny4yMDgsNDcuODM5IEMxNTcuMjI5LDQ3Ljg1NCAxNTcuMjQ4LDQ3Ljg3MyAxNTcuMjYzLDQ3Ljg5NCBDMTU4LjE1Nyw0OS4xMzggMTU4LjYzLDUwLjg2NSAxNTguNjMsNTIuODkxIEMxNTguNjMsNTkuMTMyIDE1NC4yMDUsNjYuNzY2IDE0OC43NjUsNjkuOTA3IEMxNDcuMTkyLDcwLjgxNSAxNDUuNjgxLDcxLjI3NiAxNDQuMjc2LDcxLjI3NiBMMTQ0LjI3Niw3MS4yNzYgWiBNMTQxLjU1OCw3MC4xMDQgQzE0Mi4zMzEsNzAuNjM3IDE0My4yNDUsNzEuMDA1IDE0NC4yNzYsNzEuMDA1IEMxNDUuNTk4LDcxLjAwNSAxNDcuMDMsNzAuNDY3IDE0OC41MzIsNjkuNiBDMTUzLjg0Miw2Ni41MzQgMTU4LjE2Myw1OS4wMzMgMTU4LjE2Myw1Mi45MzkgQzE1OC4xNjMsNTEuMDMxIDE1Ny43MjksNDkuMzg1IDE1Ni45MDcsNDguMjIzIEMxNTYuMTMzLDQ3LjY5MSAxNTUuMjE5LDQ3LjQwOSAxNTQuMTg5LDQ3LjQwOSBDMTUyLjg2Nyw0Ny40MDkgMTUxLjQzNSw0Ny44NDIgMTQ5LjkzMyw0OC43MDkgQzE0NC42MjMsNTEuNzc1IDE0MC4zMDIsNTkuMjczIDE0MC4zMDIsNjUuMzY2IEMxNDAuMzAyLDY3LjI3NiAxNDAuNzM2LDY4Ljk0MiAxNDEuNTU4LDcwLjEwNCBMMTQxLjU1OCw3MC4xMDQgWiIgaWQ9IkZpbGwtMzUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUwLjcyLDY1LjM2MSBMMTUwLjM1Nyw2NS4wNjYgQzE1MS4xNDcsNjQuMDkyIDE1MS44NjksNjMuMDQgMTUyLjUwNSw2MS45MzggQzE1My4zMTMsNjAuNTM5IDE1My45NzgsNTkuMDY3IDE1NC40ODIsNTcuNTYzIEwxNTQuOTI1LDU3LjcxMiBDMTU0LjQxMiw1OS4yNDUgMTUzLjczMyw2MC43NDUgMTUyLjkxLDYyLjE3MiBDMTUyLjI2Miw2My4yOTUgMTUxLjUyNSw2NC4zNjggMTUwLjcyLDY1LjM2MSIgaWQ9IkZpbGwtMzYiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE1LjkxNyw4NC41MTQgTDExNS41NTQsODQuMjIgQzExNi4zNDQsODMuMjQ1IDExNy4wNjYsODIuMTk0IDExNy43MDIsODEuMDkyIEMxMTguNTEsNzkuNjkyIDExOS4xNzUsNzguMjIgMTE5LjY3OCw3Ni43MTcgTDEyMC4xMjEsNzYuODY1IEMxMTkuNjA4LDc4LjM5OCAxMTguOTMsNzkuODk5IDExOC4xMDYsODEuMzI2IEMxMTcuNDU4LDgyLjQ0OCAxMTYuNzIyLDgzLjUyMSAxMTUuOTE3LDg0LjUxNCIgaWQ9IkZpbGwtMzciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE0LDEzMC40NzYgTDExNCwxMzAuMDA4IEwxMTQsNzYuMDUyIEwxMTQsNzUuNTg0IEwxMTQsNzYuMDUyIEwxMTQsMTMwLjAwOCBMMTE0LDEzMC40NzYiIGlkPSJGaWxsLTM4IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYyLjAwMDAwMCwgMC4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTkuODIyLDM3LjQ3NCBDMTkuODM5LDM3LjMzOSAxOS43NDcsMzcuMTk0IDE5LjU1NSwzNy4wODIgQzE5LjIyOCwzNi44OTQgMTguNzI5LDM2Ljg3MiAxOC40NDYsMzcuMDM3IEwxMi40MzQsNDAuNTA4IEMxMi4zMDMsNDAuNTg0IDEyLjI0LDQwLjY4NiAxMi4yNDMsNDAuNzkzIEMxMi4yNDUsNDAuOTI1IDEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQxLjM3MSBMMTIuMjQ1LDQxLjQxNCBMMTIuMjM4LDQxLjU0MiBDOC4xNDgsNDMuODg3IDUuNjQ3LDQ1LjMyMSA1LjY0Nyw0NS4zMjEgQzUuNjQ2LDQ1LjMyMSAzLjU3LDQ2LjM2NyAyLjg2LDUwLjUxMyBDMi44Niw1MC41MTMgMS45NDgsNTcuNDc0IDEuOTYyLDcwLjI1OCBDMS45NzcsODIuODI4IDIuNTY4LDg3LjMyOCAzLjEyOSw5MS42MDkgQzMuMzQ5LDkzLjI5MyA2LjEzLDkzLjczNCA2LjEzLDkzLjczNCBDNi40NjEsOTMuNzc0IDYuODI4LDkzLjcwNyA3LjIxLDkzLjQ4NiBMODIuNDgzLDQ5LjkzNSBDODQuMjkxLDQ4Ljg2NiA4NS4xNSw0Ni4yMTYgODUuNTM5LDQzLjY1MSBDODYuNzUyLDM1LjY2MSA4Ny4yMTQsMTAuNjczIDg1LjI2NCwzLjc3MyBDODUuMDY4LDMuMDggODQuNzU0LDIuNjkgODQuMzk2LDIuNDkxIEw4Mi4zMSwxLjcwMSBDODEuNTgzLDEuNzI5IDgwLjg5NCwyLjE2OCA4MC43NzYsMi4yMzYgQzgwLjYzNiwyLjMxNyA0MS44MDcsMjQuNTg1IDIwLjAzMiwzNy4wNzIgTDE5LjgyMiwzNy40NzQiIGlkPSJGaWxsLTEiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNODIuMzExLDEuNzAxIEw4NC4zOTYsMi40OTEgQzg0Ljc1NCwyLjY5IDg1LjA2OCwzLjA4IDg1LjI2NCwzLjc3MyBDODcuMjEzLDEwLjY3MyA4Ni43NTEsMzUuNjYgODUuNTM5LDQzLjY1MSBDODUuMTQ5LDQ2LjIxNiA4NC4yOSw0OC44NjYgODIuNDgzLDQ5LjkzNSBMNy4yMSw5My40ODYgQzYuODk3LDkzLjY2NyA2LjU5NSw5My43NDQgNi4zMTQsOTMuNzQ0IEw2LjEzMSw5My43MzMgQzYuMTMxLDkzLjczNCAzLjM0OSw5My4yOTMgMy4xMjgsOTEuNjA5IEMyLjU2OCw4Ny4zMjcgMS45NzcsODIuODI4IDEuOTYzLDcwLjI1OCBDMS45NDgsNTcuNDc0IDIuODYsNTAuNTEzIDIuODYsNTAuNTEzIEMzLjU3LDQ2LjM2NyA1LjY0Nyw0NS4zMjEgNS42NDcsNDUuMzIxIEM1LjY0Nyw0NS4zMjEgOC4xNDgsNDMuODg3IDEyLjIzOCw0MS41NDIgTDEyLjI0NSw0MS40MTQgTDEyLjI0NSw0MS4zNzEgQzEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQwLjkyNSAxMi4yNDMsNDAuNzkzIEMxMi4yNCw0MC42ODYgMTIuMzAyLDQwLjU4MyAxMi40MzQsNDAuNTA4IEwxOC40NDYsMzcuMDM2IEMxOC41NzQsMzYuOTYyIDE4Ljc0NiwzNi45MjYgMTguOTI3LDM2LjkyNiBDMTkuMTQ1LDM2LjkyNiAxOS4zNzYsMzYuOTc5IDE5LjU1NCwzNy4wODIgQzE5Ljc0NywzNy4xOTQgMTkuODM5LDM3LjM0IDE5LjgyMiwzNy40NzQgTDIwLjAzMywzNy4wNzIgQzQxLjgwNiwyNC41ODUgODAuNjM2LDIuMzE4IDgwLjc3NywyLjIzNiBDODAuODk0LDIuMTY4IDgxLjU4MywxLjcyOSA4Mi4zMTEsMS43MDEgTTgyLjMxMSwwLjcwNCBMODIuMjcyLDAuNzA1IEM4MS42NTQsMC43MjggODAuOTg5LDAuOTQ5IDgwLjI5OCwxLjM2MSBMODAuMjc3LDEuMzczIEM4MC4xMjksMS40NTggNTkuNzY4LDEzLjEzNSAxOS43NTgsMzYuMDc5IEMxOS41LDM1Ljk4MSAxOS4yMTQsMzUuOTI5IDE4LjkyNywzNS45MjkgQzE4LjU2MiwzNS45MjkgMTguMjIzLDM2LjAxMyAxNy45NDcsMzYuMTczIEwxMS45MzUsMzkuNjQ0IEMxMS40OTMsMzkuODk5IDExLjIzNiw0MC4zMzQgMTEuMjQ2LDQwLjgxIEwxMS4yNDcsNDAuOTYgTDUuMTY3LDQ0LjQ0NyBDNC43OTQsNDQuNjQ2IDIuNjI1LDQ1Ljk3OCAxLjg3Nyw1MC4zNDUgTDEuODcxLDUwLjM4NCBDMS44NjIsNTAuNDU0IDAuOTUxLDU3LjU1NyAwLjk2NSw3MC4yNTkgQzAuOTc5LDgyLjg3OSAxLjU2OCw4Ny4zNzUgMi4xMzcsOTEuNzI0IEwyLjEzOSw5MS43MzkgQzIuNDQ3LDk0LjA5NCA1LjYxNCw5NC42NjIgNS45NzUsOTQuNzE5IEw2LjAwOSw5NC43MjMgQzYuMTEsOTQuNzM2IDYuMjEzLDk0Ljc0MiA2LjMxNCw5NC43NDIgQzYuNzksOTQuNzQyIDcuMjYsOTQuNjEgNy43MSw5NC4zNSBMODIuOTgzLDUwLjc5OCBDODQuNzk0LDQ5LjcyNyA4NS45ODIsNDcuMzc1IDg2LjUyNSw0My44MDEgQzg3LjcxMSwzNS45ODcgODguMjU5LDEwLjcwNSA4Ni4yMjQsMy41MDIgQzg1Ljk3MSwyLjYwOSA4NS41MiwxLjk3NSA4NC44ODEsMS42MiBMODQuNzQ5LDEuNTU4IEw4Mi42NjQsMC43NjkgQzgyLjU1MSwwLjcyNSA4Mi40MzEsMC43MDQgODIuMzExLDAuNzA0IiBpZD0iRmlsbC0yIiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY2LjI2NywxMS41NjUgTDY3Ljc2MiwxMS45OTkgTDExLjQyMyw0NC4zMjUiIGlkPSJGaWxsLTMiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMjAyLDkwLjU0NSBDMTIuMDI5LDkwLjU0NSAxMS44NjIsOTAuNDU1IDExLjc2OSw5MC4yOTUgQzExLjYzMiw5MC4wNTcgMTEuNzEzLDg5Ljc1MiAxMS45NTIsODkuNjE0IEwzMC4zODksNzguOTY5IEMzMC42MjgsNzguODMxIDMwLjkzMyw3OC45MTMgMzEuMDcxLDc5LjE1MiBDMzEuMjA4LDc5LjM5IDMxLjEyNyw3OS42OTYgMzAuODg4LDc5LjgzMyBMMTIuNDUxLDkwLjQ3OCBMMTIuMjAyLDkwLjU0NSIgaWQ9IkZpbGwtNCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMy43NjQsNDIuNjU0IEwxMy42NTYsNDIuNTkyIEwxMy43MDIsNDIuNDIxIEwxOC44MzcsMzkuNDU3IEwxOS4wMDcsMzkuNTAyIEwxOC45NjIsMzkuNjczIEwxMy44MjcsNDIuNjM3IEwxMy43NjQsNDIuNjU0IiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTguNTIsOTAuMzc1IEw4LjUyLDQ2LjQyMSBMOC41ODMsNDYuMzg1IEw3NS44NCw3LjU1NCBMNzUuODQsNTEuNTA4IEw3NS43NzgsNTEuNTQ0IEw4LjUyLDkwLjM3NSBMOC41Miw5MC4zNzUgWiBNOC43Nyw0Ni41NjQgTDguNzcsODkuOTQ0IEw3NS41OTEsNTEuMzY1IEw3NS41OTEsNy45ODUgTDguNzcsNDYuNTY0IEw4Ljc3LDQ2LjU2NCBaIiBpZD0iRmlsbC02IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI0Ljk4Niw4My4xODIgQzI0Ljc1Niw4My4zMzEgMjQuMzc0LDgzLjU2NiAyNC4xMzcsODMuNzA1IEwxMi42MzIsOTAuNDA2IEMxMi4zOTUsOTAuNTQ1IDEyLjQyNiw5MC42NTggMTIuNyw5MC42NTggTDEzLjI2NSw5MC42NTggQzEzLjU0LDkwLjY1OCAxMy45NTgsOTAuNTQ1IDE0LjE5NSw5MC40MDYgTDI1LjcsODMuNzA1IEMyNS45MzcsODMuNTY2IDI2LjEyOCw4My40NTIgMjYuMTI1LDgzLjQ0OSBDMjYuMTIyLDgzLjQ0NyAyNi4xMTksODMuMjIgMjYuMTE5LDgyLjk0NiBDMjYuMTE5LDgyLjY3MiAyNS45MzEsODIuNTY5IDI1LjcwMSw4Mi43MTkgTDI0Ljk4Niw4My4xODIiIGlkPSJGaWxsLTciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuMjY2LDkwLjc4MiBMMTIuNyw5MC43ODIgQzEyLjUsOTAuNzgyIDEyLjM4NCw5MC43MjYgMTIuMzU0LDkwLjYxNiBDMTIuMzI0LDkwLjUwNiAxMi4zOTcsOTAuMzk5IDEyLjU2OSw5MC4yOTkgTDI0LjA3NCw4My41OTcgQzI0LjMxLDgzLjQ1OSAyNC42ODksODMuMjI2IDI0LjkxOCw4My4wNzggTDI1LjYzMyw4Mi42MTQgQzI1LjcyMyw4Mi41NTUgMjUuODEzLDgyLjUyNSAyNS44OTksODIuNTI1IEMyNi4wNzEsODIuNTI1IDI2LjI0NCw4Mi42NTUgMjYuMjQ0LDgyLjk0NiBDMjYuMjQ0LDgzLjE2IDI2LjI0NSw4My4zMDkgMjYuMjQ3LDgzLjM4MyBMMjYuMjUzLDgzLjM4NyBMMjYuMjQ5LDgzLjQ1NiBDMjYuMjQ2LDgzLjUzMSAyNi4yNDYsODMuNTMxIDI1Ljc2Myw4My44MTIgTDE0LjI1OCw5MC41MTQgQzE0LDkwLjY2NSAxMy41NjQsOTAuNzgyIDEzLjI2Niw5MC43ODIgTDEzLjI2Niw5MC43ODIgWiBNMTIuNjY2LDkwLjUzMiBMMTIuNyw5MC41MzMgTDEzLjI2Niw5MC41MzMgQzEzLjUxOCw5MC41MzMgMTMuOTE1LDkwLjQyNSAxNC4xMzIsOTAuMjk5IEwyNS42MzcsODMuNTk3IEMyNS44MDUsODMuNDk5IDI1LjkzMSw4My40MjQgMjUuOTk4LDgzLjM4MyBDMjUuOTk0LDgzLjI5OSAyNS45OTQsODMuMTY1IDI1Ljk5NCw4Mi45NDYgTDI1Ljg5OSw4Mi43NzUgTDI1Ljc2OCw4Mi44MjQgTDI1LjA1NCw4My4yODcgQzI0LjgyMiw4My40MzcgMjQuNDM4LDgzLjY3MyAyNC4yLDgzLjgxMiBMMTIuNjk1LDkwLjUxNCBMMTIuNjY2LDkwLjUzMiBMMTIuNjY2LDkwLjUzMiBaIiBpZD0iRmlsbC04IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzLjI2Niw4OS44NzEgTDEyLjcsODkuODcxIEMxMi41LDg5Ljg3MSAxMi4zODQsODkuODE1IDEyLjM1NCw4OS43MDUgQzEyLjMyNCw4OS41OTUgMTIuMzk3LDg5LjQ4OCAxMi41NjksODkuMzg4IEwyNC4wNzQsODIuNjg2IEMyNC4zMzIsODIuNTM1IDI0Ljc2OCw4Mi40MTggMjUuMDY3LDgyLjQxOCBMMjUuNjMyLDgyLjQxOCBDMjUuODMyLDgyLjQxOCAyNS45NDgsODIuNDc0IDI1Ljk3OCw4Mi41ODQgQzI2LjAwOCw4Mi42OTQgMjUuOTM1LDgyLjgwMSAyNS43NjMsODIuOTAxIEwxNC4yNTgsODkuNjAzIEMxNCw4OS43NTQgMTMuNTY0LDg5Ljg3MSAxMy4yNjYsODkuODcxIEwxMy4yNjYsODkuODcxIFogTTEyLjY2Niw4OS42MjEgTDEyLjcsODkuNjIyIEwxMy4yNjYsODkuNjIyIEMxMy41MTgsODkuNjIyIDEzLjkxNSw4OS41MTUgMTQuMTMyLDg5LjM4OCBMMjUuNjM3LDgyLjY4NiBMMjUuNjY3LDgyLjY2OCBMMjUuNjMyLDgyLjY2NyBMMjUuMDY3LDgyLjY2NyBDMjQuODE1LDgyLjY2NyAyNC40MTgsODIuNzc1IDI0LjIsODIuOTAxIEwxMi42OTUsODkuNjAzIEwxMi42NjYsODkuNjIxIEwxMi42NjYsODkuNjIxIFoiIGlkPSJGaWxsLTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzcsOTAuODAxIEwxMi4zNyw4OS41NTQgTDEyLjM3LDkwLjgwMSIgaWQ9IkZpbGwtMTAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi4xMyw5My45MDEgQzUuMzc5LDkzLjgwOCA0LjgxNiw5My4xNjQgNC42OTEsOTIuNTI1IEMzLjg2LDg4LjI4NyAzLjU0LDgzLjc0MyAzLjUyNiw3MS4xNzMgQzMuNTExLDU4LjM4OSA0LjQyMyw1MS40MjggNC40MjMsNTEuNDI4IEM1LjEzNCw0Ny4yODIgNy4yMSw0Ni4yMzYgNy4yMSw0Ni4yMzYgQzcuMjEsNDYuMjM2IDgxLjY2NywzLjI1IDgyLjA2OSwzLjAxNyBDODIuMjkyLDIuODg4IDg0LjU1NiwxLjQzMyA4NS4yNjQsMy45NCBDODcuMjE0LDEwLjg0IDg2Ljc1MiwzNS44MjcgODUuNTM5LDQzLjgxOCBDODUuMTUsNDYuMzgzIDg0LjI5MSw0OS4wMzMgODIuNDgzLDUwLjEwMSBMNy4yMSw5My42NTMgQzYuODI4LDkzLjg3NCA2LjQ2MSw5My45NDEgNi4xMyw5My45MDEgQzYuMTMsOTMuOTAxIDMuMzQ5LDkzLjQ2IDMuMTI5LDkxLjc3NiBDMi41NjgsODcuNDk1IDEuOTc3LDgyLjk5NSAxLjk2Miw3MC40MjUgQzEuOTQ4LDU3LjY0MSAyLjg2LDUwLjY4IDIuODYsNTAuNjggQzMuNTcsNDYuNTM0IDUuNjQ3LDQ1LjQ4OSA1LjY0Nyw0NS40ODkgQzUuNjQ2LDQ1LjQ4OSA4LjA2NSw0NC4wOTIgMTIuMjQ1LDQxLjY3OSBMMTMuMTE2LDQxLjU2IEwxOS43MTUsMzcuNzMgTDE5Ljc2MSwzNy4yNjkgTDYuMTMsOTMuOTAxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjMxNyw5NC4xNjEgTDYuMTAyLDk0LjE0OCBMNi4xMDEsOTQuMTQ4IEw1Ljg1Nyw5NC4xMDEgQzUuMTM4LDkzLjk0NSAzLjA4NSw5My4zNjUgMi44ODEsOTEuODA5IEMyLjMxMyw4Ny40NjkgMS43MjcsODIuOTk2IDEuNzEzLDcwLjQyNSBDMS42OTksNTcuNzcxIDIuNjA0LDUwLjcxOCAyLjYxMyw1MC42NDggQzMuMzM4LDQ2LjQxNyA1LjQ0NSw0NS4zMSA1LjUzNSw0NS4yNjYgTDEyLjE2Myw0MS40MzkgTDEzLjAzMyw0MS4zMiBMMTkuNDc5LDM3LjU3OCBMMTkuNTEzLDM3LjI0NCBDMTkuNTI2LDM3LjEwNyAxOS42NDcsMzcuMDA4IDE5Ljc4NiwzNy4wMjEgQzE5LjkyMiwzNy4wMzQgMjAuMDIzLDM3LjE1NiAyMC4wMDksMzcuMjkzIEwxOS45NSwzNy44ODIgTDEzLjE5OCw0MS44MDEgTDEyLjMyOCw0MS45MTkgTDUuNzcyLDQ1LjcwNCBDNS43NDEsNDUuNzIgMy43ODIsNDYuNzcyIDMuMTA2LDUwLjcyMiBDMy4wOTksNTAuNzgyIDIuMTk4LDU3LjgwOCAyLjIxMiw3MC40MjQgQzIuMjI2LDgyLjk2MyAyLjgwOSw4Ny40MiAzLjM3Myw5MS43MjkgQzMuNDY0LDkyLjQyIDQuMDYyLDkyLjg4MyA0LjY4Miw5My4xODEgQzQuNTY2LDkyLjk4NCA0LjQ4Niw5Mi43NzYgNC40NDYsOTIuNTcyIEMzLjY2NSw4OC41ODggMy4yOTEsODQuMzcgMy4yNzYsNzEuMTczIEMzLjI2Miw1OC41MiA0LjE2Nyw1MS40NjYgNC4xNzYsNTEuMzk2IEM0LjkwMSw0Ny4xNjUgNy4wMDgsNDYuMDU5IDcuMDk4LDQ2LjAxNCBDNy4wOTQsNDYuMDE1IDgxLjU0MiwzLjAzNCA4MS45NDQsMi44MDIgTDgxLjk3MiwyLjc4NSBDODIuODc2LDIuMjQ3IDgzLjY5MiwyLjA5NyA4NC4zMzIsMi4zNTIgQzg0Ljg4NywyLjU3MyA4NS4yODEsMy4wODUgODUuNTA0LDMuODcyIEM4Ny41MTgsMTEgODYuOTY0LDM2LjA5MSA4NS43ODUsNDMuODU1IEM4NS4yNzgsNDcuMTk2IDg0LjIxLDQ5LjM3IDgyLjYxLDUwLjMxNyBMNy4zMzUsOTMuODY5IEM2Ljk5OSw5NC4wNjMgNi42NTgsOTQuMTYxIDYuMzE3LDk0LjE2MSBMNi4zMTcsOTQuMTYxIFogTTYuMTcsOTMuNjU0IEM2LjQ2Myw5My42OSA2Ljc3NCw5My42MTcgNy4wODUsOTMuNDM3IEw4Mi4zNTgsNDkuODg2IEM4NC4xODEsNDguODA4IDg0Ljk2LDQ1Ljk3MSA4NS4yOTIsNDMuNzggQzg2LjQ2NiwzNi4wNDkgODcuMDIzLDExLjA4NSA4NS4wMjQsNC4wMDggQzg0Ljg0NiwzLjM3NyA4NC41NTEsMi45NzYgODQuMTQ4LDIuODE2IEM4My42NjQsMi42MjMgODIuOTgyLDIuNzY0IDgyLjIyNywzLjIxMyBMODIuMTkzLDMuMjM0IEM4MS43OTEsMy40NjYgNy4zMzUsNDYuNDUyIDcuMzM1LDQ2LjQ1MiBDNy4zMDQsNDYuNDY5IDUuMzQ2LDQ3LjUyMSA0LjY2OSw1MS40NzEgQzQuNjYyLDUxLjUzIDMuNzYxLDU4LjU1NiAzLjc3NSw3MS4xNzMgQzMuNzksODQuMzI4IDQuMTYxLDg4LjUyNCA0LjkzNiw5Mi40NzYgQzUuMDI2LDkyLjkzNyA1LjQxMiw5My40NTkgNS45NzMsOTMuNjE1IEM2LjA4Nyw5My42NCA2LjE1OCw5My42NTIgNi4xNjksOTMuNjU0IEw2LjE3LDkzLjY1NCBMNi4xNyw5My42NTQgWiIgaWQ9IkZpbGwtMTIiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4zMTcsNjguOTgyIEM3LjgwNiw2OC43MDEgOC4yMDIsNjguOTI2IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNi44MjksNzEuMjk0IDYuNDMzLDcxLjA2OSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIiBpZD0iRmlsbC0xMyIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjkyLDcxLjEzMyBDNi42MzEsNzEuMTMzIDYuNDMzLDcwLjkwNSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIEM3LjQ2LDY4LjkgNy41OTUsNjguODYxIDcuNzE0LDY4Ljg2MSBDOC4wMDMsNjguODYxIDguMjAyLDY5LjA5IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNy4xNzQsNzEuMDk0IDcuMDM5LDcxLjEzMyA2LjkyLDcxLjEzMyBNNy43MTQsNjguNjc0IEM3LjU1Nyw2OC42NzQgNy4zOTIsNjguNzIzIDcuMjI0LDY4LjgyMSBDNi42NzYsNjkuMTM4IDYuMjQ2LDY5Ljg3OSA2LjI0Niw3MC41MDggQzYuMjQ2LDcwLjk5NCA2LjUxNyw3MS4zMiA2LjkyLDcxLjMyIEM3LjA3OCw3MS4zMiA3LjI0Myw3MS4yNzEgNy40MTEsNzEuMTc0IEM3Ljk1OSw3MC44NTcgOC4zODksNzAuMTE3IDguMzg5LDY5LjQ4NyBDOC4zODksNjkuMDAxIDguMTE3LDY4LjY3NCA3LjcxNCw2OC42NzQiIGlkPSJGaWxsLTE0IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYuOTIsNzAuOTQ3IEM2LjY0OSw3MC45NDcgNi42MjEsNzAuNjQgNi42MjEsNzAuNTA4IEM2LjYyMSw3MC4wMTcgNi45ODIsNjkuMzkyIDcuNDExLDY5LjE0NSBDNy41MjEsNjkuMDgyIDcuNjI1LDY5LjA0OSA3LjcxNCw2OS4wNDkgQzcuOTg2LDY5LjA0OSA4LjAxNSw2OS4zNTUgOC4wMTUsNjkuNDg3IEM4LjAxNSw2OS45NzggNy42NTIsNzAuNjAzIDcuMjI0LDcwLjg1MSBDNy4xMTUsNzAuOTE0IDcuMDEsNzAuOTQ3IDYuOTIsNzAuOTQ3IE03LjcxNCw2OC44NjEgQzcuNTk1LDY4Ljg2MSA3LjQ2LDY4LjkgNy4zMTcsNjguOTgyIEM2LjgyOSw2OS4yNjUgNi40MzMsNjkuOTQ4IDYuNDMzLDcwLjUwOCBDNi40MzMsNzAuOTA1IDYuNjMxLDcxLjEzMyA2LjkyLDcxLjEzMyBDNy4wMzksNzEuMTMzIDcuMTc0LDcxLjA5NCA3LjMxNyw3MS4wMTIgQzcuODA2LDcwLjczIDguMjAyLDcwLjA0NyA4LjIwMiw2OS40ODcgQzguMjAyLDY5LjA5IDguMDAzLDY4Ljg2MSA3LjcxNCw2OC44NjEiIGlkPSJGaWxsLTE1IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcuNDQ0LDg1LjM1IEM3LjcwOCw4NS4xOTggNy45MjEsODUuMzE5IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuOTI1IDcuNzA4LDg2LjI5MiA3LjQ0NCw4Ni40NDQgQzcuMTgxLDg2LjU5NyA2Ljk2Nyw4Ni40NzUgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IiBpZD0iRmlsbC0xNiIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik03LjIzLDg2LjUxIEM3LjA3NCw4Ni41MSA2Ljk2Nyw4Ni4zODcgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IEM3LjUyMSw4NS4zMDUgNy41OTQsODUuMjg0IDcuNjU4LDg1LjI4NCBDNy44MTQsODUuMjg0IDcuOTIxLDg1LjQwOCA3LjkyMSw4NS42MjIgQzcuOTIxLDg1LjkyNSA3LjcwOCw4Ni4yOTIgNy40NDQsODYuNDQ0IEM3LjM2Nyw4Ni40ODkgNy4yOTQsODYuNTEgNy4yMyw4Ni41MSBNNy42NTgsODUuMDk4IEM3LjU1OCw4NS4wOTggNy40NTUsODUuMTI3IDcuMzUxLDg1LjE4OCBDNy4wMzEsODUuMzczIDYuNzgxLDg1LjgwNiA2Ljc4MSw4Ni4xNzMgQzYuNzgxLDg2LjQ4MiA2Ljk2Niw4Ni42OTcgNy4yMyw4Ni42OTcgQzcuMzMsODYuNjk3IDcuNDMzLDg2LjY2NiA3LjUzOCw4Ni42MDcgQzcuODU4LDg2LjQyMiA4LjEwOCw4NS45ODkgOC4xMDgsODUuNjIyIEM4LjEwOCw4NS4zMTMgNy45MjMsODUuMDk4IDcuNjU4LDg1LjA5OCIgaWQ9IkZpbGwtMTciIGZpbGw9IiM4MDk3QTIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4yMyw4Ni4zMjIgTDcuMTU0LDg2LjE3MyBDNy4xNTQsODUuOTM4IDcuMzMzLDg1LjYyOSA3LjUzOCw4NS41MTIgTDcuNjU4LDg1LjQ3MSBMNy43MzQsODUuNjIyIEM3LjczNCw4NS44NTYgNy41NTUsODYuMTY0IDcuMzUxLDg2LjI4MiBMNy4yMyw4Ni4zMjIgTTcuNjU4LDg1LjI4NCBDNy41OTQsODUuMjg0IDcuNTIxLDg1LjMwNSA3LjQ0NCw4NS4zNSBDNy4xODEsODUuNTAyIDYuOTY3LDg1Ljg3MSA2Ljk2Nyw4Ni4xNzMgQzYuOTY3LDg2LjM4NyA3LjA3NCw4Ni41MSA3LjIzLDg2LjUxIEM3LjI5NCw4Ni41MSA3LjM2Nyw4Ni40ODkgNy40NDQsODYuNDQ0IEM3LjcwOCw4Ni4yOTIgNy45MjEsODUuOTI1IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuNDA4IDcuODE0LDg1LjI4NCA3LjY1OCw4NS4yODQiIGlkPSJGaWxsLTE4IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTc3LjI3OCw3Ljc2OSBMNzcuMjc4LDUxLjQzNiBMMTAuMjA4LDkwLjE2IEwxMC4yMDgsNDYuNDkzIEw3Ny4yNzgsNy43NjkiIGlkPSJGaWxsLTE5IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwLjA4Myw5MC4zNzUgTDEwLjA4Myw0Ni40MjEgTDEwLjE0Niw0Ni4zODUgTDc3LjQwMyw3LjU1NCBMNzcuNDAzLDUxLjUwOCBMNzcuMzQxLDUxLjU0NCBMMTAuMDgzLDkwLjM3NSBMMTAuMDgzLDkwLjM3NSBaIE0xMC4zMzMsNDYuNTY0IEwxMC4zMzMsODkuOTQ0IEw3Ny4xNTQsNTEuMzY1IEw3Ny4xNTQsNy45ODUgTDEwLjMzMyw0Ni41NjQgTDEwLjMzMyw0Ni41NjQgWiIgaWQ9IkZpbGwtMjAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMjUuNzM3LDg4LjY0NyBMMTE4LjA5OCw5MS45ODEgTDExOC4wOTgsODQgTDEwNi42MzksODguNzEzIEwxMDYuNjM5LDk2Ljk4MiBMOTksMTAwLjMxNSBMMTEyLjM2OSwxMDMuOTYxIEwxMjUuNzM3LDg4LjY0NyIgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTIiIGZpbGw9IiM0NTVBNjQiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+');
	};

	module.exports = RotateInstructions;

	},{"./util.js":22}],17:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var SensorSample = _dereq_('./sensor-sample.js');
	var MathUtil = _dereq_('../math-util.js');
	var Util = _dereq_('../util.js');

	var DEBUG = false;

	/**
	 * An implementation of a simple complementary filter, which fuses gyroscope and
	 * accelerometer data from the 'devicemotion' event.
	 *
	 * Accelerometer data is very noisy, but stable over the long term.
	 * Gyroscope data is smooth, but tends to drift over the long term.
	 *
	 * This fusion is relatively simple:
	 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
	 *    on that data.
	 * 2. Get orientation estimates from gyroscope by integrating over time.
	 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
	 *    short term.
	 */
	function ComplementaryFilter(kFilter) {
	  this.kFilter = kFilter;

	  // Raw sensor measurements.
	  this.currentAccelMeasurement = new SensorSample();
	  this.currentGyroMeasurement = new SensorSample();
	  this.previousGyroMeasurement = new SensorSample();

	  // Set default look direction to be in the correct direction.
	  if (Util.isIOS()) {
	    this.filterQ = new MathUtil.Quaternion(-1, 0, 0, 1);
	  } else {
	    this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1);
	  }
	  this.previousFilterQ = new MathUtil.Quaternion();
	  this.previousFilterQ.copy(this.filterQ);

	  // Orientation based on the accelerometer.
	  this.accelQ = new MathUtil.Quaternion();
	  // Whether or not the orientation has been initialized.
	  this.isOrientationInitialized = false;
	  // Running estimate of gravity based on the current orientation.
	  this.estimatedGravity = new MathUtil.Vector3();
	  // Measured gravity based on accelerometer.
	  this.measuredGravity = new MathUtil.Vector3();

	  // Debug only quaternion of gyro-based orientation.
	  this.gyroIntegralQ = new MathUtil.Quaternion();
	}

	ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
	  this.currentAccelMeasurement.set(vector, timestampS);
	};

	ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
	  this.currentGyroMeasurement.set(vector, timestampS);

	  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
	  if (Util.isTimestampDeltaValid(deltaT)) {
	    this.run_();
	  }

	  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
	};

	ComplementaryFilter.prototype.run_ = function() {

	  if (!this.isOrientationInitialized) {
	    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
	    this.previousFilterQ.copy(this.accelQ);
	    this.isOrientationInitialized = true;
	    return;
	  }

	  var deltaT = this.currentGyroMeasurement.timestampS -
	      this.previousGyroMeasurement.timestampS;

	  // Convert gyro rotation vector to a quaternion delta.
	  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
	  this.gyroIntegralQ.multiply(gyroDeltaQ);

	  // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
	  this.filterQ.copy(this.previousFilterQ);
	  this.filterQ.multiply(gyroDeltaQ);

	  // Calculate the delta between the current estimated gravity and the real
	  // gravity vector from accelerometer.
	  var invFilterQ = new MathUtil.Quaternion();
	  invFilterQ.copy(this.filterQ);
	  invFilterQ.inverse();

	  this.estimatedGravity.set(0, 0, -1);
	  this.estimatedGravity.applyQuaternion(invFilterQ);
	  this.estimatedGravity.normalize();

	  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
	  this.measuredGravity.normalize();

	  // Compare estimated gravity with measured gravity, get the delta quaternion
	  // between the two.
	  var deltaQ = new MathUtil.Quaternion();
	  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
	  deltaQ.inverse();

	  if (DEBUG) {
	    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
	                MathUtil.radToDeg * Util.getQuaternionAngle(deltaQ),
	                (this.estimatedGravity.x).toFixed(1),
	                (this.estimatedGravity.y).toFixed(1),
	                (this.estimatedGravity.z).toFixed(1),
	                (this.measuredGravity.x).toFixed(1),
	                (this.measuredGravity.y).toFixed(1),
	                (this.measuredGravity.z).toFixed(1));
	  }

	  // Calculate the SLERP target: current orientation plus the measured-estimated
	  // quaternion delta.
	  var targetQ = new MathUtil.Quaternion();
	  targetQ.copy(this.filterQ);
	  targetQ.multiply(deltaQ);

	  // SLERP factor: 0 is pure gyro, 1 is pure accel.
	  this.filterQ.slerp(targetQ, 1 - this.kFilter);

	  this.previousFilterQ.copy(this.filterQ);
	};

	ComplementaryFilter.prototype.getOrientation = function() {
	  return this.filterQ;
	};

	ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
	  var normAccel = new MathUtil.Vector3();
	  normAccel.copy(accel);
	  normAccel.normalize();
	  var quat = new MathUtil.Quaternion();
	  quat.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), normAccel);
	  quat.inverse();
	  return quat;
	};

	ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
	  // Extract axis and angle from the gyroscope data.
	  var quat = new MathUtil.Quaternion();
	  var axis = new MathUtil.Vector3();
	  axis.copy(gyro);
	  axis.normalize();
	  quat.setFromAxisAngle(axis, gyro.length() * dt);
	  return quat;
	};


	module.exports = ComplementaryFilter;

	},{"../math-util.js":14,"../util.js":22,"./sensor-sample.js":20}],18:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var ComplementaryFilter = _dereq_('./complementary-filter.js');
	var PosePredictor = _dereq_('./pose-predictor.js');
	var TouchPanner = _dereq_('../touch-panner.js');
	var MathUtil = _dereq_('../math-util.js');
	var Util = _dereq_('../util.js');

	/**
	 * The pose sensor, implemented using DeviceMotion APIs.
	 */
	function FusionPoseSensor() {
	  this.deviceId = 'webvr-polyfill:fused';
	  this.deviceName = 'VR Position Device (webvr-polyfill:fused)';

	  this.accelerometer = new MathUtil.Vector3();
	  this.gyroscope = new MathUtil.Vector3();

	  window.addEventListener('devicemotion', this.onDeviceMotionChange_.bind(this));
	  window.addEventListener('orientationchange', this.onScreenOrientationChange_.bind(this));

	  this.filter = new ComplementaryFilter(WebVRConfig.K_FILTER);
	  this.posePredictor = new PosePredictor(WebVRConfig.PREDICTION_TIME_S);
	  this.touchPanner = new TouchPanner();

	  this.filterToWorldQ = new MathUtil.Quaternion();

	  // Set the filter to world transform, depending on OS.
	  if (Util.isIOS()) {
	    this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), Math.PI / 2);
	  } else {
	    this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), -Math.PI / 2);
	  }

	  this.inverseWorldToScreenQ = new MathUtil.Quaternion();
	  this.worldToScreenQ = new MathUtil.Quaternion();
	  this.originalPoseAdjustQ = new MathUtil.Quaternion();
	  this.originalPoseAdjustQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1),
	                                           -window.orientation * Math.PI / 180);

	  this.setScreenTransform_();
	  // Adjust this filter for being in landscape mode.
	  if (Util.isLandscapeMode()) {
	    this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
	  }

	  // Keep track of a reset transform for resetSensor.
	  this.resetQ = new MathUtil.Quaternion();

	  this.isFirefoxAndroid = Util.isFirefoxAndroid();
	  this.isIOS = Util.isIOS();

	  this.orientationOut_ = new Float32Array(4);
	}

	FusionPoseSensor.prototype.getPosition = function() {
	  // This PoseSensor doesn't support position
	  return null;
	};

	FusionPoseSensor.prototype.getOrientation = function() {
	  // Convert from filter space to the the same system used by the
	  // deviceorientation event.
	  var orientation = this.filter.getOrientation();

	  // Predict orientation.
	  this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);

	  // Convert to THREE coordinate system: -Z forward, Y up, X right.
	  var out = new MathUtil.Quaternion();
	  out.copy(this.filterToWorldQ);
	  out.multiply(this.resetQ);
	  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
	    out.multiply(this.touchPanner.getOrientation());
	  }
	  out.multiply(this.predictedQ);
	  out.multiply(this.worldToScreenQ);

	  // Handle the yaw-only case.
	  if (WebVRConfig.YAW_ONLY) {
	    // Make a quaternion that only turns around the Y-axis.
	    out.x = 0;
	    out.z = 0;
	    out.normalize();
	  }

	  this.orientationOut_[0] = out.x;
	  this.orientationOut_[1] = out.y;
	  this.orientationOut_[2] = out.z;
	  this.orientationOut_[3] = out.w;
	  return this.orientationOut_;
	};

	FusionPoseSensor.prototype.resetPose = function() {
	  // Reduce to inverted yaw-only.
	  this.resetQ.copy(this.filter.getOrientation());
	  this.resetQ.x = 0;
	  this.resetQ.y = 0;
	  this.resetQ.z *= -1;
	  this.resetQ.normalize();

	  // Take into account extra transformations in landscape mode.
	  if (Util.isLandscapeMode()) {
	    this.resetQ.multiply(this.inverseWorldToScreenQ);
	  }

	  // Take into account original pose.
	  this.resetQ.multiply(this.originalPoseAdjustQ);

	  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
	    this.touchPanner.resetSensor();
	  }
	};

	FusionPoseSensor.prototype.onDeviceMotionChange_ = function(deviceMotion) {
	  var accGravity = deviceMotion.accelerationIncludingGravity;
	  var rotRate = deviceMotion.rotationRate;
	  var timestampS = deviceMotion.timeStamp / 1000;

	  // Firefox Android timeStamp returns one thousandth of a millisecond.
	  if (this.isFirefoxAndroid) {
	    timestampS /= 1000;
	  }

	  var deltaS = timestampS - this.previousTimestampS;
	  if (deltaS <= Util.MIN_TIMESTEP || deltaS > Util.MAX_TIMESTEP) {
	    console.warn('Invalid timestamps detected. Time step between successive ' +
	                 'gyroscope sensor samples is very small or not monotonic');
	    this.previousTimestampS = timestampS;
	    return;
	  }
	  this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
	  this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);

	  // With iOS and Firefox Android, rotationRate is reported in degrees,
	  // so we first convert to radians.
	  if (this.isIOS || this.isFirefoxAndroid) {
	    this.gyroscope.multiplyScalar(Math.PI / 180);
	  }

	  this.filter.addAccelMeasurement(this.accelerometer, timestampS);
	  this.filter.addGyroMeasurement(this.gyroscope, timestampS);

	  this.previousTimestampS = timestampS;
	};

	FusionPoseSensor.prototype.onScreenOrientationChange_ =
	    function(screenOrientation) {
	  this.setScreenTransform_();
	};

	FusionPoseSensor.prototype.setScreenTransform_ = function() {
	  this.worldToScreenQ.set(0, 0, 0, 1);
	  switch (window.orientation) {
	    case 0:
	      break;
	    case 90:
	      this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), -Math.PI / 2);
	      break;
	    case -90:
	      this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), Math.PI / 2);
	      break;
	    case 180:
	      // TODO.
	      break;
	  }
	  this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
	  this.inverseWorldToScreenQ.inverse();
	};

	module.exports = FusionPoseSensor;

	},{"../math-util.js":14,"../touch-panner.js":21,"../util.js":22,"./complementary-filter.js":17,"./pose-predictor.js":19}],19:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var MathUtil = _dereq_('../math-util.js');
	var DEBUG = false;

	/**
	 * Given an orientation and the gyroscope data, predicts the future orientation
	 * of the head. This makes rendering appear faster.
	 *
	 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
	 *
	 * @param {Number} predictionTimeS time from head movement to the appearance of
	 * the corresponding image.
	 */
	function PosePredictor(predictionTimeS) {
	  this.predictionTimeS = predictionTimeS;

	  // The quaternion corresponding to the previous state.
	  this.previousQ = new MathUtil.Quaternion();
	  // Previous time a prediction occurred.
	  this.previousTimestampS = null;

	  // The delta quaternion that adjusts the current pose.
	  this.deltaQ = new MathUtil.Quaternion();
	  // The output quaternion.
	  this.outQ = new MathUtil.Quaternion();
	}

	PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
	  if (!this.previousTimestampS) {
	    this.previousQ.copy(currentQ);
	    this.previousTimestampS = timestampS;
	    return currentQ;
	  }

	  // Calculate axis and angle based on gyroscope rotation rate data.
	  var axis = new MathUtil.Vector3();
	  axis.copy(gyro);
	  axis.normalize();

	  var angularSpeed = gyro.length();

	  // If we're rotating slowly, don't do prediction.
	  if (angularSpeed < MathUtil.degToRad * 20) {
	    if (DEBUG) {
	      console.log('Moving slowly, at %s deg/s: no prediction',
	                  (MathUtil.radToDeg * angularSpeed).toFixed(1));
	    }
	    this.outQ.copy(currentQ);
	    this.previousQ.copy(currentQ);
	    return this.outQ;
	  }

	  // Get the predicted angle based on the time delta and latency.
	  var deltaT = timestampS - this.previousTimestampS;
	  var predictAngle = angularSpeed * this.predictionTimeS;

	  this.deltaQ.setFromAxisAngle(axis, predictAngle);
	  this.outQ.copy(this.previousQ);
	  this.outQ.multiply(this.deltaQ);

	  this.previousQ.copy(currentQ);
	  this.previousTimestampS = timestampS;

	  return this.outQ;
	};


	module.exports = PosePredictor;

	},{"../math-util.js":14}],20:[function(_dereq_,module,exports){
	function SensorSample(sample, timestampS) {
	  this.set(sample, timestampS);
	};

	SensorSample.prototype.set = function(sample, timestampS) {
	  this.sample = sample;
	  this.timestampS = timestampS;
	};

	SensorSample.prototype.copy = function(sensorSample) {
	  this.set(sensorSample.sample, sensorSample.timestampS);
	};

	module.exports = SensorSample;

	},{}],21:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var MathUtil = _dereq_('./math-util.js');
	var Util = _dereq_('./util.js');

	var ROTATE_SPEED = 0.5;
	/**
	 * Provides a quaternion responsible for pre-panning the scene before further
	 * transformations due to device sensors.
	 */
	function TouchPanner() {
	  window.addEventListener('touchstart', this.onTouchStart_.bind(this));
	  window.addEventListener('touchmove', this.onTouchMove_.bind(this));
	  window.addEventListener('touchend', this.onTouchEnd_.bind(this));

	  this.isTouching = false;
	  this.rotateStart = new MathUtil.Vector2();
	  this.rotateEnd = new MathUtil.Vector2();
	  this.rotateDelta = new MathUtil.Vector2();

	  this.theta = 0;
	  this.orientation = new MathUtil.Quaternion();
	}

	TouchPanner.prototype.getOrientation = function() {
	  this.orientation.setFromEulerXYZ(0, 0, this.theta);
	  return this.orientation;
	};

	TouchPanner.prototype.resetSensor = function() {
	  this.theta = 0;
	};

	TouchPanner.prototype.onTouchStart_ = function(e) {
	  // Only respond if there is exactly one touch.
	  if (e.touches.length != 1) {
	    return;
	  }
	  this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);
	  this.isTouching = true;
	};

	TouchPanner.prototype.onTouchMove_ = function(e) {
	  if (!this.isTouching) {
	    return;
	  }
	  this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY);
	  this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
	  this.rotateStart.copy(this.rotateEnd);

	  // On iOS, direction is inverted.
	  if (Util.isIOS()) {
	    this.rotateDelta.x *= -1;
	  }

	  var element = document.body;
	  this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * ROTATE_SPEED;
	};

	TouchPanner.prototype.onTouchEnd_ = function(e) {
	  this.isTouching = false;
	};

	module.exports = TouchPanner;

	},{"./math-util.js":14,"./util.js":22}],22:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var objectAssign = _dereq_('object-assign');

	var Util = window.Util || {};

	Util.MIN_TIMESTEP = 0.001;
	Util.MAX_TIMESTEP = 1;

	Util.base64 = function(mimeType, base64) {
	  return 'data:' + mimeType + ';base64,' + base64;
	};

	Util.clamp = function(value, min, max) {
	  return Math.min(Math.max(min, value), max);
	};

	Util.lerp = function(a, b, t) {
	  return a + ((b - a) * t);
	};

	Util.isIOS = (function() {
	  var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
	  return function() {
	    return isIOS;
	  };
	})();

	Util.isSafari = (function() {
	  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	  return function() {
	    return isSafari;
	  };
	})();

	Util.isFirefoxAndroid = (function() {
	  var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 &&
	      navigator.userAgent.indexOf('Android') !== -1;
	  return function() {
	    return isFirefoxAndroid;
	  };
	})();

	Util.isLandscapeMode = function() {
	  return (window.orientation == 90 || window.orientation == -90);
	};

	// Helper method to validate the time steps of sensor timestamps.
	Util.isTimestampDeltaValid = function(timestampDeltaS) {
	  if (isNaN(timestampDeltaS)) {
	    return false;
	  }
	  if (timestampDeltaS <= Util.MIN_TIMESTEP) {
	    return false;
	  }
	  if (timestampDeltaS > Util.MAX_TIMESTEP) {
	    return false;
	  }
	  return true;
	};

	Util.getScreenWidth = function() {
	  return Math.max(window.screen.width, window.screen.height) *
	      window.devicePixelRatio;
	};

	Util.getScreenHeight = function() {
	  return Math.min(window.screen.width, window.screen.height) *
	      window.devicePixelRatio;
	};

	Util.requestFullscreen = function(element) {
	  if (element.requestFullscreen) {
	    element.requestFullscreen();
	  } else if (element.webkitRequestFullscreen) {
	    element.webkitRequestFullscreen();
	  } else if (element.mozRequestFullScreen) {
	    element.mozRequestFullScreen();
	  } else if (element.msRequestFullscreen) {
	    element.msRequestFullscreen();
	  } else {
	    return false;
	  }

	  return true;
	};

	Util.exitFullscreen = function() {
	  if (document.exitFullscreen) {
	    document.exitFullscreen();
	  } else if (document.webkitExitFullscreen) {
	    document.webkitExitFullscreen();
	  } else if (document.mozCancelFullScreen) {
	    document.mozCancelFullScreen();
	  } else if (document.msExitFullscreen) {
	    document.msExitFullscreen();
	  } else {
	    return false;
	  }

	  return true;
	};

	Util.getFullscreenElement = function() {
	  return document.fullscreenElement ||
	      document.webkitFullscreenElement ||
	      document.mozFullScreenElement ||
	      document.msFullscreenElement;
	};

	Util.linkProgram = function(gl, vertexSource, fragmentSource, attribLocationMap) {
	  // No error checking for brevity.
	  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	  gl.shaderSource(vertexShader, vertexSource);
	  gl.compileShader(vertexShader);

	  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	  gl.shaderSource(fragmentShader, fragmentSource);
	  gl.compileShader(fragmentShader);

	  var program = gl.createProgram();
	  gl.attachShader(program, vertexShader);
	  gl.attachShader(program, fragmentShader);

	  for (var attribName in attribLocationMap)
	    gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);

	  gl.linkProgram(program);

	  gl.deleteShader(vertexShader);
	  gl.deleteShader(fragmentShader);

	  return program;
	};

	Util.getProgramUniforms = function(gl, program) {
	  var uniforms = {};
	  var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
	  var uniformName = '';
	  for (var i = 0; i < uniformCount; i++) {
	    var uniformInfo = gl.getActiveUniform(program, i);
	    uniformName = uniformInfo.name.replace('[0]', '');
	    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
	  }
	  return uniforms;
	};

	Util.orthoMatrix = function (out, left, right, bottom, top, near, far) {
	  var lr = 1 / (left - right),
	      bt = 1 / (bottom - top),
	      nf = 1 / (near - far);
	  out[0] = -2 * lr;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = -2 * bt;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 2 * nf;
	  out[11] = 0;
	  out[12] = (left + right) * lr;
	  out[13] = (top + bottom) * bt;
	  out[14] = (far + near) * nf;
	  out[15] = 1;
	  return out;
	};

	Util.isMobile = function() {
	  var check = false;
	  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
	  return check;
	};

	Util.extend = objectAssign;

	Util.safariCssSizeWorkaround = function(canvas) {
	  // TODO(smus): Remove this workaround when Safari for iOS is fixed.
	  // iOS only workaround (for https://bugs.webkit.org/show_bug.cgi?id=152556).
	  //
	  // "To the last I grapple with thee;
	  //  from hell's heart I stab at thee;
	  //  for hate's sake I spit my last breath at thee."
	  // -- Moby Dick, by Herman Melville
	  if (Util.isIOS()) {
	    var width = canvas.style.width;
	    var height = canvas.style.height;
	    canvas.style.width = (parseInt(width) + 1) + 'px';
	    canvas.style.height = (parseInt(height)) + 'px';
	    console.log('Resetting width to...', width);
	    setTimeout(function() {
	      console.log('Done. Width is now', width);
	      canvas.style.width = width;
	      canvas.style.height = height;
	    }, 100);
	  }

	  // Debug only.
	  window.Util = Util;
	  window.canvas = canvas;
	};

	Util.frameDataFromPose = (function() {
	  var piOver180 = Math.PI / 180.0;
	  var rad45 = Math.PI * 0.25;

	  // Borrowed from glMatrix.
	  function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
	    var upTan = Math.tan(fov ? (fov.upDegrees * piOver180) : rad45),
	    downTan = Math.tan(fov ? (fov.downDegrees * piOver180) : rad45),
	    leftTan = Math.tan(fov ? (fov.leftDegrees * piOver180) : rad45),
	    rightTan = Math.tan(fov ? (fov.rightDegrees * piOver180) : rad45),
	    xScale = 2.0 / (leftTan + rightTan),
	    yScale = 2.0 / (upTan + downTan);

	    out[0] = xScale;
	    out[1] = 0.0;
	    out[2] = 0.0;
	    out[3] = 0.0;
	    out[4] = 0.0;
	    out[5] = yScale;
	    out[6] = 0.0;
	    out[7] = 0.0;
	    out[8] = -((leftTan - rightTan) * xScale * 0.5);
	    out[9] = ((upTan - downTan) * yScale * 0.5);
	    out[10] = far / (near - far);
	    out[11] = -1.0;
	    out[12] = 0.0;
	    out[13] = 0.0;
	    out[14] = (far * near) / (near - far);
	    out[15] = 0.0;
	    return out;
	  }

	  function mat4_fromRotationTranslation(out, q, v) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - (yy + zz);
	    out[1] = xy + wz;
	    out[2] = xz - wy;
	    out[3] = 0;
	    out[4] = xy - wz;
	    out[5] = 1 - (xx + zz);
	    out[6] = yz + wx;
	    out[7] = 0;
	    out[8] = xz + wy;
	    out[9] = yz - wx;
	    out[10] = 1 - (xx + yy);
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;

	    return out;
	  };

	  function mat4_translate(out, a, v) {
	    var x = v[0], y = v[1], z = v[2],
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23;

	    if (a === out) {
	      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	      a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	      a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	      a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	      out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
	      out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
	      out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

	      out[12] = a00 * x + a10 * y + a20 * z + a[12];
	      out[13] = a01 * x + a11 * y + a21 * z + a[13];
	      out[14] = a02 * x + a12 * y + a22 * z + a[14];
	      out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }

	    return out;
	  };

	  mat4_invert = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) {
	      return null;
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

	    return out;
	  };

	  var defaultOrientation = new Float32Array([0, 0, 0, 1]);
	  var defaultPosition = new Float32Array([0, 0, 0]);

	  function updateEyeMatrices(projection, view, pose, parameters, vrDisplay) {
	    mat4_perspectiveFromFieldOfView(projection, parameters ? parameters.fieldOfView : null, vrDisplay.depthNear, vrDisplay.depthFar);

	    var orientation = pose.orientation || defaultOrientation;
	    var position = pose.position || defaultPosition;

	    mat4_fromRotationTranslation(view, orientation, position);
	    if (parameters)
	      mat4_translate(view, view, parameters.offset);
	    mat4_invert(view, view);
	  }

	  return function(frameData, pose, vrDisplay) {
	    if (!frameData || !pose)
	      return false;

	    frameData.pose = pose;
	    frameData.timestamp = pose.timestamp;

	    updateEyeMatrices(
	        frameData.leftProjectionMatrix, frameData.leftViewMatrix,
	        pose, vrDisplay.getEyeParameters("left"), vrDisplay);
	    updateEyeMatrices(
	        frameData.rightProjectionMatrix, frameData.rightViewMatrix,
	        pose, vrDisplay.getEyeParameters("right"), vrDisplay);

	    return true;
	  };
	})();

	module.exports = Util;

	},{"object-assign":1}],23:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var Emitter = _dereq_('./emitter.js');
	var Util = _dereq_('./util.js');
	var DeviceInfo = _dereq_('./device-info.js');

	var DEFAULT_VIEWER = 'CardboardV1';
	var VIEWER_KEY = 'WEBVR_CARDBOARD_VIEWER';
	var CLASS_NAME = 'webvr-polyfill-viewer-selector';

	/**
	 * Creates a viewer selector with the options specified. Supports being shown
	 * and hidden. Generates events when viewer parameters change. Also supports
	 * saving the currently selected index in localStorage.
	 */
	function ViewerSelector() {
	  // Try to load the selected key from local storage. If none exists, use the
	  // default key.
	  try {
	    this.selectedKey = localStorage.getItem(VIEWER_KEY) || DEFAULT_VIEWER;
	  } catch (error) {
	    console.error('Failed to load viewer profile: %s', error);
	  }
	  this.dialog = this.createDialog_(DeviceInfo.Viewers);
	  this.root = null;
	}
	ViewerSelector.prototype = new Emitter();

	ViewerSelector.prototype.show = function(root) {
	  this.root = root;

	  root.appendChild(this.dialog);
	  //console.log('ViewerSelector.show');

	  // Ensure the currently selected item is checked.
	  var selected = this.dialog.querySelector('#' + this.selectedKey);
	  selected.checked = true;

	  // Show the UI.
	  this.dialog.style.display = 'block';
	};

	ViewerSelector.prototype.hide = function() {
	  if (this.root && this.root.contains(this.dialog)) {
	    this.root.removeChild(this.dialog);
	  }
	  //console.log('ViewerSelector.hide');
	  this.dialog.style.display = 'none';
	};

	ViewerSelector.prototype.getCurrentViewer = function() {
	  return DeviceInfo.Viewers[this.selectedKey];
	};

	ViewerSelector.prototype.getSelectedKey_ = function() {
	  var input = this.dialog.querySelector('input[name=field]:checked');
	  if (input) {
	    return input.id;
	  }
	  return null;
	};

	ViewerSelector.prototype.onSave_ = function() {
	  this.selectedKey = this.getSelectedKey_();
	  if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
	    console.error('ViewerSelector.onSave_: this should never happen!');
	    return;
	  }

	  this.emit('change', DeviceInfo.Viewers[this.selectedKey]);

	  // Attempt to save the viewer profile, but fails in private mode.
	  try {
	    localStorage.setItem(VIEWER_KEY, this.selectedKey);
	  } catch(error) {
	    console.error('Failed to save viewer profile: %s', error);
	  }
	  this.hide();
	};

	/**
	 * Creates the dialog.
	 */
	ViewerSelector.prototype.createDialog_ = function(options) {
	  var container = document.createElement('div');
	  container.classList.add(CLASS_NAME);
	  container.style.display = 'none';
	  // Create an overlay that dims the background, and which goes away when you
	  // tap it.
	  var overlay = document.createElement('div');
	  var s = overlay.style;
	  s.position = 'fixed';
	  s.left = 0;
	  s.top = 0;
	  s.width = '100%';
	  s.height = '100%';
	  s.background = 'rgba(0, 0, 0, 0.3)';
	  overlay.addEventListener('click', this.hide.bind(this));

	  var width = 280;
	  var dialog = document.createElement('div');
	  var s = dialog.style;
	  s.boxSizing = 'border-box';
	  s.position = 'fixed';
	  s.top = '24px';
	  s.left = '50%';
	  s.marginLeft = (-width/2) + 'px';
	  s.width = width + 'px';
	  s.padding = '24px';
	  s.overflow = 'hidden';
	  s.background = '#fafafa';
	  s.fontFamily = "'Roboto', sans-serif";
	  s.boxShadow = '0px 5px 20px #666';

	  dialog.appendChild(this.createH1_('Select your viewer'));
	  for (var id in options) {
	    dialog.appendChild(this.createChoice_(id, options[id].label));
	  }
	  dialog.appendChild(this.createButton_('Save', this.onSave_.bind(this)));

	  container.appendChild(overlay);
	  container.appendChild(dialog);

	  return container;
	};

	ViewerSelector.prototype.createH1_ = function(name) {
	  var h1 = document.createElement('h1');
	  var s = h1.style;
	  s.color = 'black';
	  s.fontSize = '20px';
	  s.fontWeight = 'bold';
	  s.marginTop = 0;
	  s.marginBottom = '24px';
	  h1.innerHTML = name;
	  return h1;
	};

	ViewerSelector.prototype.createChoice_ = function(id, name) {
	  /*
	  <div class="choice">
	  <input id="v1" type="radio" name="field" value="v1">
	  <label for="v1">Cardboard V1</label>
	  </div>
	  */
	  var div = document.createElement('div');
	  div.style.marginTop = '8px';
	  div.style.color = 'black';

	  var input = document.createElement('input');
	  input.style.fontSize = '30px';
	  input.setAttribute('id', id);
	  input.setAttribute('type', 'radio');
	  input.setAttribute('value', id);
	  input.setAttribute('name', 'field');

	  var label = document.createElement('label');
	  label.style.marginLeft = '4px';
	  label.setAttribute('for', id);
	  label.innerHTML = name;

	  div.appendChild(input);
	  div.appendChild(label);

	  return div;
	};

	ViewerSelector.prototype.createButton_ = function(label, onclick) {
	  var button = document.createElement('button');
	  button.innerHTML = label;
	  var s = button.style;
	  s.float = 'right';
	  s.textTransform = 'uppercase';
	  s.color = '#1094f7';
	  s.fontSize = '14px';
	  s.letterSpacing = 0;
	  s.border = 0;
	  s.background = 'none';
	  s.marginTop = '16px';

	  button.addEventListener('click', onclick);

	  return button;
	};

	module.exports = ViewerSelector;

	},{"./device-info.js":7,"./emitter.js":12,"./util.js":22}],24:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var Util = _dereq_('./util.js');

	/**
	 * Android and iOS compatible wakelock implementation.
	 *
	 * Refactored thanks to dkovalev@.
	 */
	function AndroidWakeLock() {
	  var video = document.createElement('video');

	  video.addEventListener('ended', function() {
	    video.play();
	  });

	  this.request = function() {
	    if (video.paused) {
	      // Base64 version of videos_src/no-sleep-120s.mp4.
	      video.src = Util.base64('video/mp4', 'AAAAGGZ0eXBpc29tAAAAAG1wNDFhdmMxAAAIA21vb3YAAABsbXZoZAAAAADSa9v60mvb+gABX5AAlw/gAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAdkdHJhawAAAFx0a2hkAAAAAdJr2/rSa9v6AAAAAQAAAAAAlw/gAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAQAAAAHAAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAJcP4AAAAAAAAQAAAAAG3G1kaWEAAAAgbWRoZAAAAADSa9v60mvb+gAPQkAGjneAFccAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAABodtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAZHc3RibAAAAJdzdHNkAAAAAAAAAAEAAACHYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAMABwASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAADFhdmNDAWQAC//hABlnZAALrNlfllw4QAAAAwBAAAADAKPFCmWAAQAFaOvssiwAAAAYc3R0cwAAAAAAAAABAAAAbgAPQkAAAAAUc3RzcwAAAAAAAAABAAAAAQAAA4BjdHRzAAAAAAAAAG4AAAABAD0JAAAAAAEAehIAAAAAAQA9CQAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEALcbAAAAAHHN0c2MAAAAAAAAAAQAAAAEAAABuAAAAAQAAAcxzdHN6AAAAAAAAAAAAAABuAAADCQAAABgAAAAOAAAADgAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABMAAAAUc3RjbwAAAAAAAAABAAAIKwAAACt1ZHRhAAAAI6llbmMAFwAAdmxjIDIuMi4xIHN0cmVhbSBvdXRwdXQAAAAId2lkZQAACRRtZGF0AAACrgX//6vcRem95tlIt5Ys2CDZI+7veDI2NCAtIGNvcmUgMTQyIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDEzIG1lPWhleCBzdWJtZT03IHBzeT0xIHBzeV9yZD0xLjAwOjAuMDAgbWl4ZWRfcmVmPTEgbWVfcmFuZ2U9MTYgY2hyb21hX21lPTEgdHJlbGxpcz0xIDh4OGRjdD0xIGNxbT0wIGRlYWR6b25lPTIxLDExIGZhc3RfcHNraXA9MSBjaHJvbWFfcXBfb2Zmc2V0PS0yIHRocmVhZHM9MTIgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTEgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD00MCByYz1hYnIgbWJ0cmVlPTEgYml0cmF0ZT0xMDAgcmF0ZXRvbD0xLjAgcWNvbXA9MC42MCBxcG1pbj0xMCBxcG1heD01MSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAU2WIhAAQ/8ltlOe+cTZuGkKg+aRtuivcDZ0pBsfsEi9p/i1yU9DxS2lq4dXTinViF1URBKXgnzKBd/Uh1bkhHtMrwrRcOJslD01UB+fyaL6ef+DBAAAAFEGaJGxBD5B+v+a+4QqF3MgBXz9MAAAACkGeQniH/+94r6EAAAAKAZ5hdEN/8QytwAAAAAgBnmNqQ3/EgQAAAA5BmmhJqEFomUwIIf/+4QAAAApBnoZFESw//76BAAAACAGepXRDf8SBAAAACAGep2pDf8SAAAAADkGarEmoQWyZTAgh//7gAAAACkGeykUVLD//voEAAAAIAZ7pdEN/xIAAAAAIAZ7rakN/xIAAAAAOQZrwSahBbJlMCCH//uEAAAAKQZ8ORRUsP/++gQAAAAgBny10Q3/EgQAAAAgBny9qQ3/EgAAAAA5BmzRJqEFsmUwIIf/+4AAAAApBn1JFFSw//76BAAAACAGfcXRDf8SAAAAACAGfc2pDf8SAAAAADkGbeEmoQWyZTAgh//7hAAAACkGflkUVLD//voAAAAAIAZ+1dEN/xIEAAAAIAZ+3akN/xIEAAAAOQZu8SahBbJlMCCH//uAAAAAKQZ/aRRUsP/++gQAAAAgBn/l0Q3/EgAAAAAgBn/tqQ3/EgQAAAA5Bm+BJqEFsmUwIIf/+4QAAAApBnh5FFSw//76AAAAACAGePXRDf8SAAAAACAGeP2pDf8SBAAAADkGaJEmoQWyZTAgh//7gAAAACkGeQkUVLD//voEAAAAIAZ5hdEN/xIAAAAAIAZ5jakN/xIEAAAAOQZpoSahBbJlMCCH//uEAAAAKQZ6GRRUsP/++gQAAAAgBnqV0Q3/EgQAAAAgBnqdqQ3/EgAAAAA5BmqxJqEFsmUwIIf/+4AAAAApBnspFFSw//76BAAAACAGe6XRDf8SAAAAACAGe62pDf8SAAAAADkGa8EmoQWyZTAgh//7hAAAACkGfDkUVLD//voEAAAAIAZ8tdEN/xIEAAAAIAZ8vakN/xIAAAAAOQZs0SahBbJlMCCH//uAAAAAKQZ9SRRUsP/++gQAAAAgBn3F0Q3/EgAAAAAgBn3NqQ3/EgAAAAA5Bm3hJqEFsmUwIIf/+4QAAAApBn5ZFFSw//76AAAAACAGftXRDf8SBAAAACAGft2pDf8SBAAAADkGbvEmoQWyZTAgh//7gAAAACkGf2kUVLD//voEAAAAIAZ/5dEN/xIAAAAAIAZ/7akN/xIEAAAAOQZvgSahBbJlMCCH//uEAAAAKQZ4eRRUsP/++gAAAAAgBnj10Q3/EgAAAAAgBnj9qQ3/EgQAAAA5BmiRJqEFsmUwIIf/+4AAAAApBnkJFFSw//76BAAAACAGeYXRDf8SAAAAACAGeY2pDf8SBAAAADkGaaEmoQWyZTAgh//7hAAAACkGehkUVLD//voEAAAAIAZ6ldEN/xIEAAAAIAZ6nakN/xIAAAAAOQZqsSahBbJlMCCH//uAAAAAKQZ7KRRUsP/++gQAAAAgBnul0Q3/EgAAAAAgBnutqQ3/EgAAAAA5BmvBJqEFsmUwIIf/+4QAAAApBnw5FFSw//76BAAAACAGfLXRDf8SBAAAACAGfL2pDf8SAAAAADkGbNEmoQWyZTAgh//7gAAAACkGfUkUVLD//voEAAAAIAZ9xdEN/xIAAAAAIAZ9zakN/xIAAAAAOQZt4SahBbJlMCCH//uEAAAAKQZ+WRRUsP/++gAAAAAgBn7V0Q3/EgQAAAAgBn7dqQ3/EgQAAAA5Bm7xJqEFsmUwIIf/+4AAAAApBn9pFFSw//76BAAAACAGf+XRDf8SAAAAACAGf+2pDf8SBAAAADkGb4EmoQWyZTAgh//7hAAAACkGeHkUVLD//voAAAAAIAZ49dEN/xIAAAAAIAZ4/akN/xIEAAAAOQZokSahBbJlMCCH//uAAAAAKQZ5CRRUsP/++gQAAAAgBnmF0Q3/EgAAAAAgBnmNqQ3/EgQAAAA5BmmhJqEFsmUwIIf/+4QAAAApBnoZFFSw//76BAAAACAGepXRDf8SBAAAACAGep2pDf8SAAAAADkGarEmoQWyZTAgh//7gAAAACkGeykUVLD//voEAAAAIAZ7pdEN/xIAAAAAIAZ7rakN/xIAAAAAPQZruSahBbJlMFEw3//7B');
	      video.play();
	    }
	  };

	  this.release = function() {
	    video.pause();
	    video.src = '';
	  };
	}

	function iOSWakeLock() {
	  var timer = null;

	  this.request = function() {
	    if (!timer) {
	      timer = setInterval(function() {
	        window.location = window.location;
	        setTimeout(window.stop, 0);
	      }, 30000);
	    }
	  }

	  this.release = function() {
	    if (timer) {
	      clearInterval(timer);
	      timer = null;
	    }
	  }
	}


	function getWakeLock() {
	  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
	  if (userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
	    return iOSWakeLock;
	  } else {
	    return AndroidWakeLock;
	  }
	}

	module.exports = getWakeLock();
	},{"./util.js":22}],25:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var Util = _dereq_('./util.js');
	var CardboardVRDisplay = _dereq_('./cardboard-vr-display.js');
	var MouseKeyboardVRDisplay = _dereq_('./mouse-keyboard-vr-display.js');
	// Uncomment to add positional tracking via webcam.
	//var WebcamPositionSensorVRDevice = require('./webcam-position-sensor-vr-device.js');
	var VRDisplay = _dereq_('./base.js').VRDisplay;
	var VRFrameData = _dereq_('./base.js').VRFrameData;
	var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;
	var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;
	var VRDisplayHMDDevice = _dereq_('./display-wrappers.js').VRDisplayHMDDevice;
	var VRDisplayPositionSensorDevice = _dereq_('./display-wrappers.js').VRDisplayPositionSensorDevice;

	function WebVRPolyfill() {
	  this.displays = [];
	  this.devices = []; // For deprecated objects
	  this.devicesPopulated = false;
	  this.nativeWebVRAvailable = this.isWebVRAvailable();
	  this.nativeLegacyWebVRAvailable = this.isDeprecatedWebVRAvailable();

	  if (!this.nativeLegacyWebVRAvailable) {
	    if (!this.nativeWebVRAvailable) {
	      this.enablePolyfill();
	    }
	    if (WebVRConfig.ENABLE_DEPRECATED_API) {
	      this.enableDeprecatedPolyfill();
	    }
	  }

	  // Put a shim in place to update the API to 1.1 if needed.
	  InstallWebVRSpecShim();
	}

	WebVRPolyfill.prototype.isWebVRAvailable = function() {
	  return ('getVRDisplays' in navigator);
	};

	WebVRPolyfill.prototype.isDeprecatedWebVRAvailable = function() {
	  return ('getVRDevices' in navigator) || ('mozGetVRDevices' in navigator);
	};

	WebVRPolyfill.prototype.populateDevices = function() {
	  if (this.devicesPopulated) {
	    return;
	  }

	  // Initialize our virtual VR devices.
	  var vrDisplay = null;

	  // Add a Cardboard VRDisplay on compatible mobile devices
	  if (this.isCardboardCompatible()) {
	    vrDisplay = new CardboardVRDisplay();
	    this.displays.push(vrDisplay);

	    // For backwards compatibility
	    if (WebVRConfig.ENABLE_DEPRECATED_API) {
	      this.devices.push(new VRDisplayHMDDevice(vrDisplay));
	      this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
	    }
	  }

	  // Add a Mouse and Keyboard driven VRDisplay for desktops/laptops
	  if (!this.isMobile() && !WebVRConfig.MOUSE_KEYBOARD_CONTROLS_DISABLED) {
	    vrDisplay = new MouseKeyboardVRDisplay();
	    this.displays.push(vrDisplay);

	    // For backwards compatibility
	    if (WebVRConfig.ENABLE_DEPRECATED_API) {
	      this.devices.push(new VRDisplayHMDDevice(vrDisplay));
	      this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
	    }
	  }

	  // Uncomment to add positional tracking via webcam.
	  //if (!this.isMobile() && WebVRConfig.ENABLE_DEPRECATED_API) {
	  //  positionDevice = new WebcamPositionSensorVRDevice();
	  //  this.devices.push(positionDevice);
	  //}

	  this.devicesPopulated = true;
	};

	WebVRPolyfill.prototype.enablePolyfill = function() {
	  // Provide navigator.getVRDisplays.
	  navigator.getVRDisplays = this.getVRDisplays.bind(this);

	  // Provide the VRDisplay object.
	  window.VRDisplay = VRDisplay;

	  // Provide navigator.vrEnabled.
	  var self = this;
	  Object.defineProperty(navigator, 'vrEnabled', {
	    get: function () {
	      return self.isCardboardCompatible() &&
	        (document.fullscreenEnabled ||
	          document.mozFullScreenEnabled ||
	          document.webkitFullscreenEnabled ||
	          false);
	    }
	  });

	  // Provide the VRFrameData object.
	  window.VRFrameData = VRFrameData;
	};

	WebVRPolyfill.prototype.enableDeprecatedPolyfill = function() {
	  // Provide navigator.getVRDevices.
	  navigator.getVRDevices = this.getVRDevices.bind(this);

	  // Provide the CardboardHMDVRDevice and PositionSensorVRDevice objects.
	  window.HMDVRDevice = HMDVRDevice;
	  window.PositionSensorVRDevice = PositionSensorVRDevice;
	};

	WebVRPolyfill.prototype.getVRDisplays = function() {
	  this.populateDevices();
	  var displays = this.displays;
	  return new Promise(function(resolve, reject) {
	    try {
	      resolve(displays);
	    } catch (e) {
	      reject(e);
	    }
	  });
	};

	WebVRPolyfill.prototype.getVRDevices = function() {
	  console.warn('getVRDevices is deprecated. Please update your code to use getVRDisplays instead.');
	  var self = this;
	  return new Promise(function(resolve, reject) {
	    try {
	      if (!self.devicesPopulated) {
	        if (self.nativeWebVRAvailable) {
	          return navigator.getVRDisplays(function(displays) {
	            for (var i = 0; i < displays.length; ++i) {
	              self.devices.push(new VRDisplayHMDDevice(displays[i]));
	              self.devices.push(new VRDisplayPositionSensorDevice(displays[i]));
	            }
	            self.devicesPopulated = true;
	            resolve(self.devices);
	          }, reject);
	        }

	        if (self.nativeLegacyWebVRAvailable) {
	          return (navigator.getVRDDevices || navigator.mozGetVRDevices)(function(devices) {
	            for (var i = 0; i < devices.length; ++i) {
	              if (devices[i] instanceof HMDVRDevice) {
	                self.devices.push(devices[i]);
	              }
	              if (devices[i] instanceof PositionSensorVRDevice) {
	                self.devices.push(devices[i]);
	              }
	            }
	            self.devicesPopulated = true;
	            resolve(self.devices);
	          }, reject);
	        }
	      }

	      self.populateDevices();
	      resolve(self.devices);
	    } catch (e) {
	      reject(e);
	    }
	  });
	};

	/**
	 * Determine if a device is mobile.
	 */
	WebVRPolyfill.prototype.isMobile = function() {
	  return /Android/i.test(navigator.userAgent) ||
	      /iPhone|iPad|iPod/i.test(navigator.userAgent);
	};

	WebVRPolyfill.prototype.isCardboardCompatible = function() {
	  // For now, support all iOS and Android devices.
	  // Also enable the WebVRConfig.FORCE_VR flag for debugging.
	  return this.isMobile() || WebVRConfig.FORCE_ENABLE_VR;
	};

	// Installs a shim that updates a WebVR 1.0 spec implementation to WebVR 1.1
	function InstallWebVRSpecShim() {
	  if ('VRDisplay' in window && !('VRFrameData' in window)) {
	    // Provide the VRFrameData object.
	    window.VRFrameData = VRFrameData;

	    // A lot of Chrome builds don't have depthNear and depthFar, even
	    // though they're in the WebVR 1.0 spec. Patch them in if they're not present.
	    if(!('depthNear' in window.VRDisplay.prototype)) {
	      window.VRDisplay.prototype.depthNear = 0.01;
	    }

	    if(!('depthFar' in window.VRDisplay.prototype)) {
	      window.VRDisplay.prototype.depthFar = 10000.0;
	    }

	    window.VRDisplay.prototype.getFrameData = function(frameData) {
	      return Util.frameDataFromPose(frameData, this.getPose(), this);
	    }
	  }
	};

	module.exports.WebVRPolyfill = WebVRPolyfill;

	},{"./base.js":2,"./cardboard-vr-display.js":5,"./display-wrappers.js":8,"./mouse-keyboard-vr-display.js":15,"./util.js":22}]},{},[13]);


/***/ },
/* 369 */
/*!*******************************************!*\
  !*** ./src/translators/utils/vrEffect.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 81);

	var _promise2 = _interopRequireDefault(_promise);

	exports.default = VREffect;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	__webpack_require__(/*! webvr-polyfill */ 368);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @author dmarcos / https://github.com/dmarcos
	 * @author mrdoob / http://mrdoob.com
	 *
	 * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html
	 *
	 * Firefox: http://mozvr.com/downloads/
	 * Chromium: https://webvr.info/get-chrome
	 *
	 */

	function VREffect(renderer, vrDisplay, onError) {

		//var vrDisplay, vrDisplays;
		var eyeTranslationL = new THREE.Vector3();
		var eyeTranslationR = new THREE.Vector3();
		var renderRectL, renderRectR;

		var frameData = null;

		if ('VRFrameData' in window) {

			frameData = new window.VRFrameData();
		}

		/*function gotVRDisplays( displays ) {
	 	vrDisplays = displays;
	 	if ( displays.length > 0 ) {
	 		vrDisplay = displays[ 0 ];
	 	} else {
	 		if ( onError ) onError( 'HMD not available' );
	 	}
	 }
	 if ( navigator.getVRDisplays ) {
	 	navigator.getVRDisplays().then( gotVRDisplays ).catch( function() {
	 		console.warn( 'THREE.VREffect: Unable to get VR Displays' );
	 	} );
	 }*/

		//

		this.isPresenting = false;
		this.scale = 1;

		var scope = this;

		var rendererSize = renderer.getSize();
		var rendererUpdateStyle = false;
		var rendererPixelRatio = renderer.getPixelRatio();

		this.getVRDisplay = function () {

			return vrDisplay;
		};

		this.setVRDisplay = function (value) {

			vrDisplay = value;
		};

		this.getVRDisplays = function () {

			console.warn('THREE.VREffect: getVRDisplays() is being deprecated.');
			return vrDisplays;
		};

		this.setSize = function (width, height, updateStyle) {

			rendererSize = { width: width, height: height };
			rendererUpdateStyle = updateStyle;

			if (scope.isPresenting) {

				var eyeParamsL = vrDisplay.getEyeParameters('left');
				renderer.setPixelRatio(1);
				renderer.setSize(eyeParamsL.renderWidth * 2, eyeParamsL.renderHeight, false);
			} else {

				renderer.setPixelRatio(rendererPixelRatio);
				renderer.setSize(width, height, updateStyle);
			}
		};

		// VR presentation

		var canvas = renderer.domElement;
		var defaultLeftBounds = [0.0, 0.0, 0.5, 1.0];
		var defaultRightBounds = [0.5, 0.0, 0.5, 1.0];

		function onVRDisplayPresentChange() {

			var wasPresenting = scope.isPresenting;
			scope.isPresenting = vrDisplay !== undefined && vrDisplay.isPresenting;

			if (scope.isPresenting) {

				var eyeParamsL = vrDisplay.getEyeParameters('left');
				var eyeWidth = eyeParamsL.renderWidth;
				var eyeHeight = eyeParamsL.renderHeight;

				if (!wasPresenting) {

					rendererPixelRatio = renderer.getPixelRatio();
					rendererSize = renderer.getSize();

					renderer.setPixelRatio(1);
					renderer.setSize(eyeWidth * 2, eyeHeight, false);
				}
			} else if (wasPresenting) {

				renderer.setPixelRatio(rendererPixelRatio);
				renderer.setSize(rendererSize.width, rendererSize.height, rendererUpdateStyle);
			}
		}

		window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);

		this.setFullScreen = function (boolean) {

			return new _promise2.default(function (resolve, reject) {

				if (vrDisplay === undefined) {

					reject(new Error('No VR hardware found.'));
					return;
				}

				if (scope.isPresenting === boolean) {

					resolve();
					return;
				}

				if (boolean) {

					resolve(vrDisplay.requestPresent([{ source: canvas }]));
				} else {

					resolve(vrDisplay.exitPresent());
				}
			});
		};

		this.requestPresent = function () {

			return this.setFullScreen(true);
		};

		this.exitPresent = function () {

			return this.setFullScreen(false);
		};

		this.requestAnimationFrame = function (f) {

			if (vrDisplay !== undefined) {

				return vrDisplay.requestAnimationFrame(f);
			} else {

				return window.requestAnimationFrame(f);
			}
		};

		this.cancelAnimationFrame = function (h) {

			if (vrDisplay !== undefined) {

				vrDisplay.cancelAnimationFrame(h);
			} else {

				window.cancelAnimationFrame(h);
			}
		};

		this.submitFrame = function () {

			if (vrDisplay !== undefined && scope.isPresenting) {

				vrDisplay.submitFrame();
			}
		};

		this.autoSubmitFrame = true;

		// render

		var cameraL = new THREE.PerspectiveCamera();
		cameraL.layers.enable(1);

		var cameraR = new THREE.PerspectiveCamera();
		cameraR.layers.enable(2);

		this.render = function (scene, camera, renderTarget, forceClear) {

			if (vrDisplay && scope.isPresenting) {

				var autoUpdate = scene.autoUpdate;

				if (autoUpdate) {

					scene.updateMatrixWorld();
					scene.autoUpdate = false;
				}

				var eyeParamsL = vrDisplay.getEyeParameters('left');
				var eyeParamsR = vrDisplay.getEyeParameters('right');

				eyeTranslationL.fromArray(eyeParamsL.offset);
				eyeTranslationR.fromArray(eyeParamsR.offset);

				if (Array.isArray(scene)) {

					console.warn('THREE.VREffect.render() no longer supports arrays. Use object.layers instead.');
					scene = scene[0];
				}

				// When rendering we don't care what the recommended size is, only what the actual size
				// of the backbuffer is.
				var size = renderer.getSize();
				var layers = vrDisplay.getLayers();
				var leftBounds;
				var rightBounds;

				if (layers.length) {

					var layer = layers[0];

					leftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ? layer.leftBounds : defaultLeftBounds;
					rightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ? layer.rightBounds : defaultRightBounds;
				} else {

					leftBounds = defaultLeftBounds;
					rightBounds = defaultRightBounds;
				}

				renderRectL = {
					x: Math.round(size.width * leftBounds[0]),
					y: Math.round(size.height * leftBounds[1]),
					width: Math.round(size.width * leftBounds[2]),
					height: Math.round(size.height * leftBounds[3])
				};
				renderRectR = {
					x: Math.round(size.width * rightBounds[0]),
					y: Math.round(size.height * rightBounds[1]),
					width: Math.round(size.width * rightBounds[2]),
					height: Math.round(size.height * rightBounds[3])
				};

				if (renderTarget) {

					renderer.setRenderTarget(renderTarget);
					renderTarget.scissorTest = true;
				} else {

					renderer.setRenderTarget(null);
					renderer.setScissorTest(true);
				}

				if (renderer.autoClear || forceClear) renderer.clear();

				if (camera.parent === null) camera.updateMatrixWorld();

				camera.matrixWorld.decompose(cameraL.position, cameraL.quaternion, cameraL.scale);
				camera.matrixWorld.decompose(cameraR.position, cameraR.quaternion, cameraR.scale);

				var scale = this.scale;
				cameraL.translateOnAxis(eyeTranslationL, scale);
				cameraR.translateOnAxis(eyeTranslationR, scale);

				if (vrDisplay.getFrameData) {

					vrDisplay.depthNear = camera.near;
					vrDisplay.depthFar = camera.far;

					vrDisplay.getFrameData(frameData);

					cameraL.projectionMatrix.elements = frameData.leftProjectionMatrix;
					cameraR.projectionMatrix.elements = frameData.rightProjectionMatrix;
				} else {

					cameraL.projectionMatrix = fovToProjection(eyeParamsL.fieldOfView, true, camera.near, camera.far);
					cameraR.projectionMatrix = fovToProjection(eyeParamsR.fieldOfView, true, camera.near, camera.far);
				}

				// render left eye
				if (renderTarget) {

					renderTarget.viewport.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
					renderTarget.scissor.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
				} else {

					renderer.setViewport(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
					renderer.setScissor(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
				}
				renderer.render(scene, cameraL, renderTarget, forceClear);

				// render right eye
				if (renderTarget) {

					renderTarget.viewport.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
					renderTarget.scissor.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
				} else {

					renderer.setViewport(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
					renderer.setScissor(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
				}
				renderer.render(scene, cameraR, renderTarget, forceClear);

				if (renderTarget) {

					renderTarget.viewport.set(0, 0, size.width, size.height);
					renderTarget.scissor.set(0, 0, size.width, size.height);
					renderTarget.scissorTest = false;
					renderer.setRenderTarget(null);
				} else {

					renderer.setViewport(0, 0, size.width, size.height);
					renderer.setScissorTest(false);
				}

				if (autoUpdate) {

					scene.autoUpdate = true;
				}

				if (scope.autoSubmitFrame) {

					scope.submitFrame();
				}

				return;
			}

			// Regular render mode if not HMD

			renderer.render(scene, camera, renderTarget, forceClear);
		};

		this.dispose = function () {

			window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
		};

		//

		function fovToNDCScaleOffset(fov) {

			var pxscale = 2.0 / (fov.leftTan + fov.rightTan);
			var pxoffset = (fov.leftTan - fov.rightTan) * pxscale * 0.5;
			var pyscale = 2.0 / (fov.upTan + fov.downTan);
			var pyoffset = (fov.upTan - fov.downTan) * pyscale * 0.5;
			return { scale: [pxscale, pyscale], offset: [pxoffset, pyoffset] };
		}

		function fovPortToProjection(fov, rightHanded, zNear, zFar) {

			rightHanded = rightHanded === undefined ? true : rightHanded;
			zNear = zNear === undefined ? 0.01 : zNear;
			zFar = zFar === undefined ? 10000.0 : zFar;

			var handednessScale = rightHanded ? -1.0 : 1.0;

			// start with an identity matrix
			var mobj = new THREE.Matrix4();
			var m = mobj.elements;

			// and with scale/offset info for normalized device coords
			var scaleAndOffset = fovToNDCScaleOffset(fov);

			// X result, map clip edges to [-w,+w]
			m[0 * 4 + 0] = scaleAndOffset.scale[0];
			m[0 * 4 + 1] = 0.0;
			m[0 * 4 + 2] = scaleAndOffset.offset[0] * handednessScale;
			m[0 * 4 + 3] = 0.0;

			// Y result, map clip edges to [-w,+w]
			// Y offset is negated because this proj matrix transforms from world coords with Y=up,
			// but the NDC scaling has Y=down (thanks D3D?)
			m[1 * 4 + 0] = 0.0;
			m[1 * 4 + 1] = scaleAndOffset.scale[1];
			m[1 * 4 + 2] = -scaleAndOffset.offset[1] * handednessScale;
			m[1 * 4 + 3] = 0.0;

			// Z result (up to the app)
			m[2 * 4 + 0] = 0.0;
			m[2 * 4 + 1] = 0.0;
			m[2 * 4 + 2] = zFar / (zNear - zFar) * -handednessScale;
			m[2 * 4 + 3] = zFar * zNear / (zNear - zFar);

			// W result (= Z in)
			m[3 * 4 + 0] = 0.0;
			m[3 * 4 + 1] = 0.0;
			m[3 * 4 + 2] = handednessScale;
			m[3 * 4 + 3] = 0.0;

			mobj.transpose();

			return mobj;
		}

		function fovToProjection(fov, rightHanded, zNear, zFar) {

			var DEG2RAD = Math.PI / 180.0;

			var fovPort = {
				upTan: Math.tan(fov.upDegrees * DEG2RAD),
				downTan: Math.tan(fov.downDegrees * DEG2RAD),
				leftTan: Math.tan(fov.leftDegrees * DEG2RAD),
				rightTan: Math.tan(fov.rightDegrees * DEG2RAD)
			};

			return fovPortToProjection(fovPort, rightHanded, zNear, zFar);
		}
	};

/***/ },
/* 370 */
/*!*************************************************!*\
  !*** ./src/translators/utils/viveController.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 188);

	var _create2 = _interopRequireDefault(_create);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @author mrdoob / http://mrdoob.com
	 * @author stewdio / http://stewd.io
	 */

	THREE.ViveController = function (id) {

		THREE.Object3D.call(this);

		var scope = this;
		var gamepad;

		var axes = [0, 0];
		var thumbpadIsPressed = false;
		var triggerIsPressed = false;
		var gripsArePressed = false;
		var menuIsPressed = false;

		function findGamepad(id) {

			// Iterate across gamepads as Vive Controllers may not be
			// in position 0 and 1.

			var gamepads = navigator.getGamepads();

			for (var i = 0, j = 0; i < 4; i++) {

				var gamepad = gamepads[i];

				if (gamepad && gamepad.id === 'OpenVR Gamepad') {

					if (j === id) return gamepad;

					j++;
				}
			}
		}

		this.matrixAutoUpdate = false;
		this.standingMatrix = new THREE.Matrix4();

		this.getGamepad = function () {

			return gamepad;
		};

		this.getButtonState = function (button) {

			if (button === 'thumbpad') return thumbpadIsPressed;
			if (button === 'trigger') return triggerIsPressed;
			if (button === 'grips') return gripsArePressed;
			if (button === 'menu') return menuIsPressed;
		};

		this.update = function () {

			gamepad = findGamepad(id);

			if (gamepad !== undefined && gamepad.pose.position !== null && gamepad.pose.orientation !== null) {

				//  Position and orientation.

				var pose = gamepad.pose;

				scope.position.fromArray(pose.position);
				scope.quaternion.fromArray(pose.orientation);
				scope.matrix.compose(scope.position, scope.quaternion, scope.scale);
				scope.matrix.multiplyMatrices(scope.standingMatrix, scope.matrix);
				scope.matrixWorldNeedsUpdate = true;
				scope.visible = true;

				//  Thumbpad and Buttons.

				if (axes[0] !== gamepad.axes[0] || axes[1] !== gamepad.axes[1]) {

					axes[0] = gamepad.axes[0]; //  X axis: -1 = Left, +1 = Right.
					axes[1] = gamepad.axes[1]; //  Y axis: -1 = Bottom, +1 = Top.
					scope.dispatchEvent({ type: 'axischanged', axes: axes });
				}

				if (thumbpadIsPressed !== gamepad.buttons[0].pressed) {

					thumbpadIsPressed = gamepad.buttons[0].pressed;
					var event = new Event(thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup');
					//window.dispatchEvent( { type: thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup' } );
					window.dispatchEvent(event);
				}

				if (triggerIsPressed !== gamepad.buttons[1].pressed) {

					triggerIsPressed = gamepad.buttons[1].pressed;
					//scope.dispatchEvent( { type: triggerIsPressed ? 'triggerdown' : 'triggerup' } );
					var event = new Event(triggerIsPressed ? 'triggerdown' : 'triggerup');
					window.dispatchEvent(event);
				}

				if (gripsArePressed !== gamepad.buttons[2].pressed) {

					gripsArePressed = gamepad.buttons[2].pressed;
					//scope.dispatchEvent( { type: gripsArePressed ? 'gripsdown' : 'gripsup' } );
					var event = new Event(gripsArePressed ? 'gripsdown' : 'gripsup');
					window.dispatchEvent(event);
				}

				if (menuIsPressed !== gamepad.buttons[3].pressed) {

					menuIsPressed = gamepad.buttons[3].pressed;
					//scope.dispatchEvent( { type: menuIsPressed ? 'menudown' : 'menuup' } );
					var event = new Event(menuIsPressed ? 'menudown' : 'menuup');
					window.dispatchEvent(event);
				}
			} else {

				scope.visible = false;
			}
		};
	};

	THREE.ViveController.prototype = (0, _create2.default)(THREE.Object3D.prototype);
	THREE.ViveController.prototype.constructor = THREE.ViveController;

/***/ },
/* 371 */
/*!********************************************!*\
  !*** ./src/translators/utils/objLoader.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.OBJLoader = function (manager) {

		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;

		this.materials = null;

		this.regexp = {
			// v float float float
			vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
			// vn float float float
			normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
			// vt float float
			uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
			// f vertex vertex vertex
			face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
			// f vertex/uv vertex/uv vertex/uv
			face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
			// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
			face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
			// f vertex//normal vertex//normal vertex//normal
			face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
			// o object_name | g group_name
			object_pattern: /^[og]\s*(.+)?/,
			// s boolean
			smoothing_pattern: /^s\s+(\d+|on|off)/,
			// mtllib file_reference
			material_library_pattern: /^mtllib /,
			// usemtl material_name
			material_use_pattern: /^usemtl /
		};
	};

	THREE.OBJLoader.prototype = {

		constructor: THREE.OBJLoader,

		load: function load(url, onLoad, onProgress, onError) {

			var scope = this;

			var loader = new THREE.XHRLoader(scope.manager);
			loader.setPath(this.path);
			loader.load(url, function (text) {

				onLoad(scope.parse(text));
			}, onProgress, onError);
		},

		setPath: function setPath(value) {

			this.path = value;
		},

		setMaterials: function setMaterials(materials) {

			this.materials = materials;
		},

		_createParserState: function _createParserState() {

			var state = {
				objects: [],
				object: {},

				vertices: [],
				normals: [],
				uvs: [],

				materialLibraries: [],

				startObject: function startObject(name, fromDeclaration) {

					// If the current object (initial from reset) is not from a g/o declaration in the parsed
					// file. We need to use it for the first parsed g/o to keep things in sync.
					if (this.object && this.object.fromDeclaration === false) {

						this.object.name = name;
						this.object.fromDeclaration = fromDeclaration !== false;
						return;
					}

					if (this.object && typeof this.object._finalize === 'function') {

						this.object._finalize();
					}

					var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;

					this.object = {
						name: name || '',
						fromDeclaration: fromDeclaration !== false,

						geometry: {
							vertices: [],
							normals: [],
							uvs: []
						},
						materials: [],
						smooth: true,

						startMaterial: function startMaterial(name, libraries) {

							var previous = this._finalize(false);

							// New usemtl declaration overwrites an inherited material, except if faces were declared
							// after the material, then it must be preserved for proper MultiMaterial continuation.
							if (previous && (previous.inherited || previous.groupCount <= 0)) {

								this.materials.splice(previous.index, 1);
							}

							var material = {
								index: this.materials.length,
								name: name || '',
								mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
								smooth: previous !== undefined ? previous.smooth : this.smooth,
								groupStart: previous !== undefined ? previous.groupEnd : 0,
								groupEnd: -1,
								groupCount: -1,
								inherited: false,

								clone: function clone(index) {
									return {
										index: typeof index === 'number' ? index : this.index,
										name: this.name,
										mtllib: this.mtllib,
										smooth: this.smooth,
										groupStart: this.groupEnd,
										groupEnd: -1,
										groupCount: -1,
										inherited: false
									};
								}
							};

							this.materials.push(material);

							return material;
						},

						currentMaterial: function currentMaterial() {

							if (this.materials.length > 0) {
								return this.materials[this.materials.length - 1];
							}

							return undefined;
						},

						_finalize: function _finalize(end) {

							var lastMultiMaterial = this.currentMaterial();
							if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {

								lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
								lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
								lastMultiMaterial.inherited = false;
							}

							// Guarantee at least one empty material, this makes the creation later more straight forward.
							if (end !== false && this.materials.length === 0) {
								this.materials.push({
									name: '',
									smooth: this.smooth
								});
							}

							return lastMultiMaterial;
						}
					};

					// Inherit previous objects material.
					// Spec tells us that a declared material must be set to all objects until a new material is declared.
					// If a usemtl declaration is encountered while this new object is being parsed, it will
					// overwrite the inherited material. Exception being that there was already face declarations
					// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

					if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {

						var declared = previousMaterial.clone(0);
						declared.inherited = true;
						this.object.materials.push(declared);
					}

					this.objects.push(this.object);
				},

				finalize: function finalize() {

					if (this.object && typeof this.object._finalize === 'function') {

						this.object._finalize();
					}
				},

				parseVertexIndex: function parseVertexIndex(value, len) {

					var index = parseInt(value, 10);
					return (index >= 0 ? index - 1 : index + len / 3) * 3;
				},

				parseNormalIndex: function parseNormalIndex(value, len) {

					var index = parseInt(value, 10);
					return (index >= 0 ? index - 1 : index + len / 3) * 3;
				},

				parseUVIndex: function parseUVIndex(value, len) {

					var index = parseInt(value, 10);
					return (index >= 0 ? index - 1 : index + len / 2) * 2;
				},

				addVertex: function addVertex(a, b, c) {

					var src = this.vertices;
					var dst = this.object.geometry.vertices;

					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[a + 2]);
					dst.push(src[b + 0]);
					dst.push(src[b + 1]);
					dst.push(src[b + 2]);
					dst.push(src[c + 0]);
					dst.push(src[c + 1]);
					dst.push(src[c + 2]);
				},

				addVertexLine: function addVertexLine(a) {

					var src = this.vertices;
					var dst = this.object.geometry.vertices;

					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[a + 2]);
				},

				addNormal: function addNormal(a, b, c) {

					var src = this.normals;
					var dst = this.object.geometry.normals;

					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[a + 2]);
					dst.push(src[b + 0]);
					dst.push(src[b + 1]);
					dst.push(src[b + 2]);
					dst.push(src[c + 0]);
					dst.push(src[c + 1]);
					dst.push(src[c + 2]);
				},

				addUV: function addUV(a, b, c) {

					var src = this.uvs;
					var dst = this.object.geometry.uvs;

					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[b + 0]);
					dst.push(src[b + 1]);
					dst.push(src[c + 0]);
					dst.push(src[c + 1]);
				},

				addUVLine: function addUVLine(a) {

					var src = this.uvs;
					var dst = this.object.geometry.uvs;

					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
				},

				addFace: function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {

					var vLen = this.vertices.length;

					var ia = this.parseVertexIndex(a, vLen);
					var ib = this.parseVertexIndex(b, vLen);
					var ic = this.parseVertexIndex(c, vLen);
					var id;

					if (d === undefined) {

						this.addVertex(ia, ib, ic);
					} else {

						id = this.parseVertexIndex(d, vLen);

						this.addVertex(ia, ib, id);
						this.addVertex(ib, ic, id);
					}

					if (ua !== undefined) {

						var uvLen = this.uvs.length;

						ia = this.parseUVIndex(ua, uvLen);
						ib = this.parseUVIndex(ub, uvLen);
						ic = this.parseUVIndex(uc, uvLen);

						if (d === undefined) {

							this.addUV(ia, ib, ic);
						} else {

							id = this.parseUVIndex(ud, uvLen);

							this.addUV(ia, ib, id);
							this.addUV(ib, ic, id);
						}
					}

					if (na !== undefined) {

						// Normals are many times the same. If so, skip function call and parseInt.
						var nLen = this.normals.length;
						ia = this.parseNormalIndex(na, nLen);

						ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
						ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);

						if (d === undefined) {

							this.addNormal(ia, ib, ic);
						} else {

							id = this.parseNormalIndex(nd, nLen);

							this.addNormal(ia, ib, id);
							this.addNormal(ib, ic, id);
						}
					}
				},

				addLineGeometry: function addLineGeometry(vertices, uvs) {

					this.object.geometry.type = 'Line';

					var vLen = this.vertices.length;
					var uvLen = this.uvs.length;

					for (var vi = 0, l = vertices.length; vi < l; vi++) {

						this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
					}

					for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {

						this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
					}
				}

			};

			state.startObject('', false);

			return state;
		},

		parse: function parse(text) {

			console.time('OBJLoader');

			var state = this._createParserState();

			if (text.indexOf('\r\n') !== -1) {

				// This is faster than String.split with regex that splits on both
				text = text.replace('\r\n', '\n');
			}

			var lines = text.split('\n');
			var line = '',
			    lineFirstChar = '',
			    lineSecondChar = '';
			var lineLength = 0;
			var result = [];

			// Faster to just trim left side of the line. Use if available.
			var trimLeft = typeof ''.trimLeft === 'function';

			for (var i = 0, l = lines.length; i < l; i++) {

				line = lines[i];

				line = trimLeft ? line.trimLeft() : line.trim();

				lineLength = line.length;

				if (lineLength === 0) continue;

				lineFirstChar = line.charAt(0);

				// @todo invoke passed in handler if any
				if (lineFirstChar === '#') continue;

				if (lineFirstChar === 'v') {

					lineSecondChar = line.charAt(1);

					if (lineSecondChar === ' ' && (result = this.regexp.vertex_pattern.exec(line)) !== null) {

						// 0                  1      2      3
						// ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

						state.vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
					} else if (lineSecondChar === 'n' && (result = this.regexp.normal_pattern.exec(line)) !== null) {

						// 0                   1      2      3
						// ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

						state.normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
					} else if (lineSecondChar === 't' && (result = this.regexp.uv_pattern.exec(line)) !== null) {

						// 0               1      2
						// ["vt 0.1 0.2", "0.1", "0.2"]

						state.uvs.push(parseFloat(result[1]), parseFloat(result[2]));
					} else {

						throw new Error("Unexpected vertex/normal/uv line: '" + line + "'");
					}
				} else if (lineFirstChar === "f") {

					if ((result = this.regexp.face_vertex_uv_normal.exec(line)) !== null) {

						// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
						// 0                        1    2    3    4    5    6    7    8    9   10         11         12
						// ["f 1/1/1 2/2/2 3/3/3", "1", "1", "1", "2", "2", "2", "3", "3", "3", undefined, undefined, undefined]

						state.addFace(result[1], result[4], result[7], result[10], result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
					} else if ((result = this.regexp.face_vertex_uv.exec(line)) !== null) {

						// f vertex/uv vertex/uv vertex/uv
						// 0                  1    2    3    4    5    6   7          8
						// ["f 1/1 2/2 3/3", "1", "1", "2", "2", "3", "3", undefined, undefined]

						state.addFace(result[1], result[3], result[5], result[7], result[2], result[4], result[6], result[8]);
					} else if ((result = this.regexp.face_vertex_normal.exec(line)) !== null) {

						// f vertex//normal vertex//normal vertex//normal
						// 0                     1    2    3    4    5    6   7          8
						// ["f 1//1 2//2 3//3", "1", "1", "2", "2", "3", "3", undefined, undefined]

						state.addFace(result[1], result[3], result[5], result[7], undefined, undefined, undefined, undefined, result[2], result[4], result[6], result[8]);
					} else if ((result = this.regexp.face_vertex.exec(line)) !== null) {

						// f vertex vertex vertex
						// 0            1    2    3   4
						// ["f 1 2 3", "1", "2", "3", undefined]

						state.addFace(result[1], result[2], result[3], result[4]);
					} else {

						throw new Error("Unexpected face line: '" + line + "'");
					}
				} else if (lineFirstChar === "l") {

					var lineParts = line.substring(1).trim().split(" ");
					var lineVertices = [],
					    lineUVs = [];

					if (line.indexOf("/") === -1) {

						lineVertices = lineParts;
					} else {

						for (var li = 0, llen = lineParts.length; li < llen; li++) {

							var parts = lineParts[li].split("/");

							if (parts[0] !== "") lineVertices.push(parts[0]);
							if (parts[1] !== "") lineUVs.push(parts[1]);
						}
					}
					state.addLineGeometry(lineVertices, lineUVs);
				} else if ((result = this.regexp.object_pattern.exec(line)) !== null) {

					// o object_name
					// or
					// g group_name

					var name = result[0].substr(1).trim();
					state.startObject(name);
				} else if (this.regexp.material_use_pattern.test(line)) {

					// material

					state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
				} else if (this.regexp.material_library_pattern.test(line)) {

					// mtl file

					state.materialLibraries.push(line.substring(7).trim());
				} else if ((result = this.regexp.smoothing_pattern.exec(line)) !== null) {

					// smooth shading

					// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
					// but does not define a usemtl for each face set.
					// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
					// This requires some care to not create extra material on each smooth value for "normal" obj files.
					// where explicit usemtl defines geometry groups.
					// Example asset: examples/models/obj/cerberus/Cerberus.obj

					var value = result[1].trim().toLowerCase();
					state.object.smooth = value === '1' || value === 'on';

					var material = state.object.currentMaterial();
					if (material) {

						material.smooth = state.object.smooth;
					}
				} else {

					// Handle null terminated files without exception
					if (line === '\0') continue;

					throw new Error("Unexpected line: '" + line + "'");
				}
			}

			state.finalize();

			var container = new THREE.Group();
			container.materialLibraries = [].concat(state.materialLibraries);

			for (var i = 0, l = state.objects.length; i < l; i++) {

				var object = state.objects[i];
				var geometry = object.geometry;
				var materials = object.materials;
				var isLine = geometry.type === 'Line';

				// Skip o/g line declarations that did not follow with any faces
				if (geometry.vertices.length === 0) continue;

				var buffergeometry = new THREE.BufferGeometry();

				buffergeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));

				if (geometry.normals.length > 0) {

					buffergeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));
				} else {

					buffergeometry.computeVertexNormals();
				}

				if (geometry.uvs.length > 0) {

					buffergeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));
				}

				// Create materials

				var createdMaterials = [];

				for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {

					var sourceMaterial = materials[mi];
					var material = undefined;

					if (this.materials !== null) {

						material = this.materials.create(sourceMaterial.name);

						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {

							var materialLine = new THREE.LineBasicMaterial();
							materialLine.copy(material);
							material = materialLine;
						}
					}

					if (!material) {

						material = !isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial();
						material.name = sourceMaterial.name;
					}

					material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;

					createdMaterials.push(material);
				}

				// Create mesh

				var mesh;

				if (createdMaterials.length > 1) {

					for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {

						var sourceMaterial = materials[mi];
						buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
					}

					var multiMaterial = new THREE.MultiMaterial(createdMaterials);
					mesh = !isLine ? new THREE.Mesh(buffergeometry, multiMaterial) : new THREE.LineSegments(buffergeometry, multiMaterial);
				} else {

					mesh = !isLine ? new THREE.Mesh(buffergeometry, createdMaterials[0]) : new THREE.LineSegments(buffergeometry, createdMaterials[0]);
				}

				mesh.name = object.name;

				container.add(mesh);
			}

			console.timeEnd('OBJLoader');

			return container;
		}

	};

/***/ },
/* 372 */
/*!******************************************!*\
  !*** ./src/translators/utils/reticle.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	THREE.Reticle = function (camera) {

	    var reticle = {};

	    reticle.armObject = null;
	    reticle.reticleObject = null;
	    reticle.dot = null;
	    reticle.intersection = null;
	    reticle.colliders = [];

	    var defaultMaterial = new THREE.MeshBasicMaterial({ color: '#a9a9a9', transparent: true, opacity: 0 });
	    var hitMaterial = new THREE.MeshBasicMaterial({ color: '#ff0000', transparent: true, opacity: 0.7 });

	    reticle.createDefaultObject = function (position, length, isDot) {
	        if (isDot) {
	            var defaultGeometry = new THREE.SphereGeometry(0.007, 32, length);
	        } else {
	            var defaultGeometry = new THREE.TorusGeometry(0.2, 0.04, 16, 100);
	        }
	        var defaultObject = new THREE.Mesh(defaultGeometry, defaultMaterial);
	        defaultObject.position.copy(position);
	        defaultObject.rotation.x = -Math.PI * 0.5;
	        return defaultObject;
	    };

	    reticle.init = function (camera) {
	        this.camera = camera;
	        this.armObject = new THREE.Object3D();
	        this.reticleObject = this.createDefaultObject(new THREE.Vector3(0, 0, -0.5), .01, false);
	        this.armObject.add(this.reticleObject);

	        this.dot = this.createDefaultObject(new THREE.Vector3(0, 0, -0.5), .01, true);
	        this.camera.add(this.armObject);
	        this.camera.add(this.dot);
	        this.startClock();
	    };

	    reticle.getReticlePosition = function () {
	        return reticle.reticleObject.position;
	    };

	    reticle.remvoeFromList = function (object_in, list_in) {
	        var index = list_in.indexOf(object_in);
	        if (index > -1) {
	            list_in.splice(index, 1);
	        }
	    };

	    reticle.addCollider = function (threeObject) {
	        this.colliders.push(threeObject);
	    };

	    reticle.removeCollider = function (threeObject) {
	        this.remvoeFromList(threeObject, reticle.colliders);
	    };

	    reticle.update = function (parent) {
	        var camDirection = new THREE.Vector3();
	        this.camera.getWorldDirection(camDirection);
	        var ray = new THREE.Raycaster(this.camera.position, camDirection);

	        var intersects = ray.intersectObjects(this.colliders);
	        if (intersects.length > 0) {
	            //save the new hit object and time
	            this.intersection = intersects[0];
	            this.reticleObject.position.copy(this.intersection.point);
	            if (parent) this.reticleObject.position.sub(parent.position);

	            this.reticleObject.material = hitMaterial;
	            this.dot.material.opacity = 0;
	        } else {
	            this.dot.material.opacity = 1;
	            this.reticleObject.material = defaultMaterial;
	        }
	    };

	    reticle.startClock = function () {
	        this.clock = new THREE.Clock(true);
	    };

	    reticle.init(camera);

	    return reticle;
	};

/***/ },
/* 373 */
/*!*********************************************!*\
  !*** ./src/translators/utils/vrControls.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = VRControls;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * @author dmarcos / https://github.com/dmarcos
	 * @author mrdoob / http://mrdoob.com
	 */

	function VRControls(object, onError) {

		var scope = this;

		var vrDisplay, vrDisplays;

		var standingMatrix = new THREE.Matrix4();

		var frameData = null;

		if ('VRFrameData' in window) {

			frameData = new VRFrameData();
		}

		function gotVRDisplays(displays) {

			vrDisplays = displays;

			for (var i = 0; i < displays.length; i++) {

				if ('VRDisplay' in window && displays[i] instanceof VRDisplay || 'PositionSensorVRDevice' in window && displays[i] instanceof PositionSensorVRDevice) {

					vrDisplay = displays[i];
					break; // We keep the first we encounter
				}
			}

			if (vrDisplay === undefined) {

				if (onError) onError('VR input not available.');
			}
		}

		if (navigator.getVRDisplays) {

			navigator.getVRDisplays().then(gotVRDisplays);
		} else if (navigator.getVRDevices) {

			// Deprecated API.
			navigator.getVRDevices().then(gotVRDisplays);
		}

		// the Rift SDK returns the position in meters
		// this scale factor allows the user to define how meters
		// are converted to scene units.

		this.scale = 1;

		// If true will use "standing space" coordinate system where y=0 is the
		// floor and x=0, z=0 is the center of the room.
		this.standing = false;

		// Distance from the users eyes to the floor in meters. Used when
		// standing=true but the VRDisplay doesn't provide stageParameters.
		this.userHeight = 1.6;

		this.offset = new THREE.Vector3(0, 0, 0);
		this.rotationalOffset = new THREE.Quaternion(0, 0, 0, 1);

		this.getVRDisplay = function () {

			return vrDisplay;
		};

		this.setVRDisplay = function (value) {

			vrDisplay = value;
		};

		this.getVRDisplays = function () {

			return vrDisplays;
		};

		this.getStandingMatrix = function () {

			return standingMatrix;
		};

		this.update = function () {

			if (vrDisplay) {

				var pose;

				if (vrDisplay.getFrameData) {

					vrDisplay.getFrameData(frameData);
					pose = frameData.pose;
				} else if (vrDisplay.getPose) {

					pose = vrDisplay.getPose();
				}

				if (pose.orientation !== null) {

					object.quaternion.fromArray(pose.orientation);
				} else {

					object.quaternion.set(0, 0, 0, 1);
				}

				if (pose.position !== null) {

					object.position.fromArray(pose.position);
				} else {

					object.position.set(0, 0, 0);
				}

				if (this.standing) {

					if (vrDisplay.stageParameters) {

						object.updateMatrix();

						standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
						object.applyMatrix(standingMatrix);
					} else {

						object.position.setY(object.position.y + this.userHeight);
					}
				}

				object.position.multiplyScalar(scope.scale);

				//apply offsets
				object.quaternion.premultiply(this.rotationalOffset);
				object.position.applyQuaternion(this.rotationalOffset);
				object.position.add(this.offset);
			}
		};

		this.resetPose = function () {

			if (vrDisplay) {

				if (vrDisplay.resetPose !== undefined) {

					vrDisplay.resetPose();
				} else if (vrDisplay.resetSensor !== undefined) {

					// Deprecated API.
					vrDisplay.resetSensor();
				} else if (vrDisplay.zeroSensor !== undefined) {

					// Really deprecated API.
					vrDisplay.zeroSensor();
				}
			}
		};

		this.resetSensor = function () {

			console.warn('THREE.VRControls: .resetSensor() is now .resetPose().');
			this.resetPose();
		};

		this.zeroSensor = function () {

			console.warn('THREE.VRControls: .zeroSensor() is now .resetPose().');
			this.resetPose();
		};

		this.dispose = function () {

			vrDisplay = null;
		};

		this.setOffset = function (v) {
			this.offset.copy(v);
		};

		this.setRotationalOffset = function (q) {
			this.rotationalOffset.copy(q);
		};
	};

/***/ },
/* 374 */
/*!**************************************************!*\
  !*** ./src/translators/tools/firstPersonMode.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 97);

	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

	exports.default = firstPersonMode;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _camera = __webpack_require__(/*! ../camera */ 298);

	var _decompose = __webpack_require__(/*! ../utils/decompose */ 302);

	var _decompose2 = _interopRequireDefault(_decompose);

	var _player = __webpack_require__(/*! ../../modules/player */ 295);

	var _scene = __webpack_require__(/*! ../../modules/scene */ 171);

	var _updateCameraLookAtTarget = __webpack_require__(/*! ../utils/updateCameraLookAtTarget */ 296);

	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 299);

	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 144);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var tan = Math.tan,
	    cos = Math.cos,
	    atan = Math.atan,
	    acos = Math.acos,
	    min = Math.min,
	    max = Math.max,
	    pow = Math.pow,
	    PI = Math.PI,
	    sqrt = Math.sqrt;


	var directionKeys = {
	  w: 'FORWARD',
	  a: 'LEFT',
	  s: 'BACKWARD',
	  d: 'RIGHT',
	  ArrowUp: 'FORWARD',
	  ArrowLeft: 'LEFT',
	  ArrowDown: 'BACKWARD',
	  ArrowRight: 'RIGHT'
	};

	var directions = {
	  FORWARD: ['y', 1],
	  BACKWARD: ['y', -1],
	  LEFT: ['x', -1],
	  RIGHT: ['x', 1]
	};

	var SPEED = 0.2;
	function firstPersonMode(store, translator) {
	  var oldOrbitMode = '';
	  var velocity = new THREE.Vector3(0, 0, 0);
	  var axes = { x: 0, y: 0, z: 0 };

	  function setVelocity(axis, factor) {
	    axes[axis] += factor;
	    velocity = new THREE.Vector3(axes.x, axes.y, axes.z).normalize().multiplyScalar(SPEED);
	  }

	  return {
	    name: 'firstPersonMode',
	    active: false,
	    enabled: true,
	    options: {
	      movementMode: 'fly',
	      keyboardEnabled: true
	    },
	    display: {
	      playerTools: false
	    },

	    heldKeys: [],

	    tool: {

	      keydown: function keydown(ev) {
	        var direction = directionKeys[ev.key];
	        if (direction && this.active) {
	          this.heldKeys.push(ev.key);

	          var _directions$direction = (0, _slicedToArray3.default)(directions[direction], 2),
	              axis = _directions$direction[0],
	              factor = _directions$direction[1];

	          setVelocity(axis, factor);
	        }
	      },

	      keyup: function keyup(ev) {
	        var direction = directionKeys[ev.key];
	        if (direction && this.active) {
	          var idx = this.heldKeys.indexOf(ev.key);
	          this.heldKeys.splice(idx, 1);

	          var _directions$direction2 = (0, _slicedToArray3.default)(directions[direction], 2),
	              axis = _directions$direction2[0],
	              factor = _directions$direction2[1];

	          setVelocity(axis, -factor);
	        }
	      },

	      keyheld: function keyheld(ev) {
	        var firstKey = this.heldKeys[0];
	        if (ev.key === firstKey && this.options.keyboardEnabled) {
	          var movement = firstPersonMovement(store, velocity, this.options.movementMode);
	          if (movement && translator.externals.vrControls) {
	            translator.externals.vrControls.offset.add(movement);
	          }
	        }
	      }
	    },

	    activate: function activate() {
	      oldOrbitMode = (0, _scene.get)(store, { scene: true, plug: 'Player', property: 'orbitMode' });
	      store.dispatch((0, _scene.set)({ scene: true, plug: 'Player', property: 'orbitMode' }, 'firstPerson'));
	    },

	    deactivate: function deactivate() {
	      store.dispatch((0, _scene.set)({ scene: true, plug: 'Player', property: 'orbitMode' }, oldOrbitMode));
	    }

	  };
	}

	var UP_POSITION = new THREE.Vector3(0, 1, 0);

	function firstPersonMovement(store, direction, movementMode) {
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var cameraId = (0, _player.getCamera)(store);
	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });

	  if (targetWorldMatrix && cameraWorldMatrix && cameraData.upPosition) {
	    var cameraPosition = new THREE.Vector3();
	    var targetPosition = new THREE.Vector3();
	    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	    targetPosition.setFromMatrixPosition(targetWorldMatrix);

	    var forward = new THREE.Vector3().subVectors(targetPosition, cameraPosition).normalize();
	    if (movementMode === 'plane') forward.projectOnPlane(UP_POSITION).normalize();

	    var right = new THREE.Vector3().crossVectors(forward, UP_POSITION).normalize();

	    var movement = new THREE.Vector3().addScaledVector(forward, direction.y).addScaledVector(right, direction.x);
	    if (movement.y < -cameraPosition.y && playerData.constraintCameraY) movement.y = -cameraPosition.y;

	    cameraPosition.add(movement);
	    targetPosition.add(movement);

	    cameraWorldMatrix.setPosition(cameraPosition);
	    targetWorldMatrix.setPosition(targetPosition);

	    (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);

	    store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
	    if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
	      store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
	    }

	    return movement;
	  }
	}

/***/ },
/* 375 */
/*!**********************************!*\
  !*** ./src/translators/three.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 97);

	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 101);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _values = __webpack_require__(/*! babel-runtime/core-js/object/values */ 306);

	var _values2 = _interopRequireDefault(_values);

	exports.default = threeTranslator;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _translator = __webpack_require__(/*! ./translator */ 376);

	var _bingeom = __webpack_require__(/*! ./bingeom */ 182);

	var _materials = __webpack_require__(/*! ./materials */ 377);

	var _polyMesh = __webpack_require__(/*! ./polyMesh */ 380);

	var _light = __webpack_require__(/*! ./light */ 381);

	var _transform = __webpack_require__(/*! ./transform */ 382);

	var _camera = __webpack_require__(/*! ./camera */ 298);

	var _manipulators = __webpack_require__(/*! ./manipulators */ 383);

	var _setMatrixOnNode = __webpack_require__(/*! ./utils/setMatrixOnNode */ 301);

	var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);

	var _annotation = __webpack_require__(/*! ./annotation */ 385);

	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 283);

	var _sceneGraph = __webpack_require__(/*! ../modules/sceneGraph */ 144);

	var _scene = __webpack_require__(/*! ../modules/scene */ 171);

	var _player = __webpack_require__(/*! ../modules/player */ 295);

	var _commands = __webpack_require__(/*! ../modules/commands */ 305);

	var _selection = __webpack_require__(/*! ../modules/selection */ 312);

	var _outlinePass = __webpack_require__(/*! ./utils/outlinePass */ 386);

	var _outlinePass2 = _interopRequireDefault(_outlinePass);

	var _calculateBoundingBox = __webpack_require__(/*! ./utils/calculateBoundingBox */ 297);

	var _calculateBoundingBox2 = _interopRequireDefault(_calculateBoundingBox);

	var _FXAAShader = __webpack_require__(/*! ./utils/FXAAShader */ 387);

	var _FXAAShader2 = _interopRequireDefault(_FXAAShader);

	var _parallaxBarrierEffect = __webpack_require__(/*! ./utils/parallaxBarrierEffect */ 388);

	var _parallaxBarrierEffect2 = _interopRequireDefault(_parallaxBarrierEffect);

	var _vrControls = __webpack_require__(/*! ./utils/vrControls */ 373);

	var _vrControls2 = _interopRequireDefault(_vrControls);

	var _polyMesh2 = __webpack_require__(/*! ../polyMesh */ 183);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// extend three with StereoEffect
	var BACKGROUND_STYLE_DEFAULT = 0; // FIXME should be OutlinePass.js

	var BACKGROUND_STYLE_COLOR = 1;
	var BACKGROUND_STYLE_IMAGE = 2;
	var BACKGROUND_STYLE_CUBEMAP = 3;
	var BACKGROUND_STYLE_ENVIRONMENT = 4;

	function initTranslator(store, context, translator) {
	  var sceneGraph = store.get('sceneGraph');

	  var scene = new THREE.Scene();
	  //const camera = new THREE.PerspectiveCamera(75, 4 / 3, 0.1, 1000);
	  var camera = new THREE.CombinedCamera(1, 1, 75, 0.1, 1000);

	  var rendererAttrs = {
	    antialias: false,
	    precision: 'highp',
	    alpha: true,
	    preserveDrawingBuffer: true
	  };
	  if (context) {
	    rendererAttrs.canvas = { style: {}, addEventListener: function addEventListener() {} };
	    rendererAttrs.context = context;
	  }

	  var isIOS = false;
	  var isAndroid = false;
	  var isMSPhone = false;
	  var isMobile = false;

	  var renderer = new THREE.WebGLRenderer(rendererAttrs);
	  renderer.setClearColor(0xffffff);
	  renderer.autoResizeTextures = false;
	  renderer.gammaInput = true;
	  renderer.gammaOutput = true;
	  renderer.toneMapping = THREE.ReinhardToneMapping;
	  renderer.physicallyCorrectLights = true;
	  var pixelRatio = 1;
	  if (true) {
	    pixelRatio = window.devicePixelRatio;
	    if (window.navigator) {
	      var userAgent = window.navigator.userAgent;
	      isIOS = /iPad|iPhone|iPod/.test(userAgent);
	      isAndroid = /Android/i.test(userAgent);
	      isMSPhone = /IEMobile|Windows Phone|Lumia/i.test(userAgent);
	      isMobile = isIOS || isAndroid || isMSPhone || /Blackberry|webOS/i.test(userAgent);
	    }
	  }
	  renderer.setPixelRatio(pixelRatio);
	  renderer.isMobile = isMobile;

	  store.dispatch((0, _player.setThreeScene)(scene, camera, renderer));

	  var el = null;
	  var playerEl = null; // This is the parent element that we control (div.claraplayer)

	  var nodes = {};
	  var translated = {
	    // [ nodeId ]: { [PlugName]: _v }
	  };
	  var annotations = {};
	  var rect = new THREE.Vector2(400, 300);
	  var tools = [];
	  var interactionHandler = null;
	  var cameraId = _sceneGraph.virtualCameraId; // The camera we want to move
	  var fromCameraId = _sceneGraph.virtualCameraId; // The camera we want to use to initialize camera position
	  var translatedCameraId = null; // The camera that we initialized from
	  var pivotId = null;
	  var loaded = null;
	  var reflectiveFloorMaterial = null;
	  var reflectiveFloorMesh = null;

	  var vrControls = void 0;

	  var externals = {};

	  var translatorState = {};

	  function getContext() {
	    return renderer.getContext();
	  }

	  var selectedNodes = (0, _selection.getSelectedNodes)(store);

	  // use ssaa on the server
	  var serverRenderingMode = !!context;

	  var composer = new THREE.EffectComposer(renderer);

	  var clearPass = new THREE.ClearPass();
	  clearPass.enabled = true;
	  composer.addPass(clearPass);

	  var texturePass = new THREE.TexturePass();
	  texturePass.clear = false;
	  texturePass.enabled = false;
	  composer.addPass(texturePass);

	  var cubeTexturePass = new THREE.CubeTexturePass(scene, camera);
	  cubeTexturePass.clear = false;
	  cubeTexturePass.enabled = false;
	  composer.addPass(cubeTexturePass);

	  var ssaaRenderPass = new THREE.SSAARenderPass(scene, camera);
	  ssaaRenderPass.clear = false;
	  ssaaRenderPass.sampleLevel = serverRenderingMode ? 2 : 1;
	  ssaaRenderPass.unbiased = true;
	  ssaaRenderPass.enabled = true;
	  composer.addPass(ssaaRenderPass);

	  var renderPass = new THREE.RenderPass(scene, camera); //, null, 0xffffff);
	  //renderPass.clear = false;
	  //renderPass.enabled = false;
	  composer.addPass(renderPass);

	  var fullWidth =  true ? window.innerWidth : 400;
	  var fullHeight =  true ? window.innerHeight : 300;
	  var fullWidthWithPixelRatio = fullWidth * pixelRatio;
	  var fullHeightWithPixelRatio = fullHeight * pixelRatio;

	  var effectFXAA = new THREE.ShaderPass(_FXAAShader2.default);
	  effectFXAA.uniforms['resolution'].value.set(1 / fullWidthWithPixelRatio, 1 / fullHeightWithPixelRatio);
	  composer.addPass(effectFXAA);

	  var saoPass = new THREE.SAOPass(scene, camera);
	  saoPass.downSamplingRatio = serverRenderingMode ? 1 : 1; // fast enough if not full screen (I think.)
	  saoPass.intensity = 3;
	  saoPass.occlusionSphereWorldRadius = 2;
	  saoPass.blurEnabled = true;
	  //saoPass.outputOverride = "default";
	  saoPass.manualCompositing = false;
	  saoPass.blurKernelSize = (saoPass.downSamplingRatio === 1 ? 6 : 6) + (serverRenderingMode ? 2 : 0);
	  saoPass.enabled = true;
	  if (!isMobile) {
	    composer.addPass(saoPass);
	  }

	  var dofPass = new THREE.DofPass(new THREE.Vector2(fullWidthWithPixelRatio, fullHeightWithPixelRatio), scene, camera);
	  composer.addPass(dofPass);

	  var bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(fullWidthWithPixelRatio, fullHeightWithPixelRatio), 1.5, 1, 1);
	  composer.addPass(bloomPass);

	  var outlinePass = new _outlinePass2.default(new THREE.Vector2(fullWidthWithPixelRatio, fullHeightWithPixelRatio), scene, camera);
	  outlinePass.edgeStrength = 10;
	  outlinePass.edgeGlow = 0;
	  outlinePass.edgeThickness = 1;
	  outlinePass.pulsePeriod = 0;
	  outlinePass.visibleEdgeColor = new THREE.Color(0, 1, 0);
	  outlinePass.hiddenEdgeColor = new THREE.Color(0, 1, 0);
	  composer.addPass(outlinePass);

	  var copyPass = new THREE.ShaderPass(THREE.CopyShader);
	  copyPass.renderToScreen = true;
	  composer.addPass(copyPass);

	  var stereoEffect = new _parallaxBarrierEffect2.default(renderer);
	  stereoEffect.setSize(fullWidth, fullHeight);
	  function resize(width, height) {
	    if (el) {
	      var elRect = el.parentNode.getBoundingClientRect();
	      width = elRect.width;
	      height = elRect.height;
	    }

	    if (width < 10 || height < 10) return;

	    rect.set(width, height);

	    (0, _camera.resizeCamera)(store, cameraId, rect);
	    renderer.setSize(rect.width, rect.height);

	    if (reflectiveFloorMaterial !== null) {
	      reflectiveFloorMaterial.setSize(rect.width, rect.height);
	    }
	    var pixelRatio = renderer.getPixelRatio();
	    composer.setSize(rect.width * pixelRatio, rect.height * pixelRatio);

	    /*console.log( 'pixelDeviceRatio', pixelRatio );
	    console.log( 'renderer size', rect.width, rect.height );
	    console.log( 'composer size', rect.width * pixelRatio, rect.height * pixelRatio );
	    console.log( 'pixel size', rect.width * window.devicePixelRatio, rect.height * window.devicePixelRatio );*/

	    if (interactionHandler) interactionHandler.resize(rect);

	    if (height && height !== 0) {
	      camera.aspect = width / height;
	      camera.updateProjectionMatrix();
	    }

	    effectFXAA.uniforms['resolution'].value.set(1 / (rect.width * pixelRatio), 1 / (rect.height * pixelRatio));
	  }

	  /*
	   * Attach the renderer's canvas element to the DOM?.
	   */
	  function attach(element) {
	    el = element;
	    el.insertBefore(renderer.domElement, el.firstChild);
	    renderer.domElement.tabIndex = 1;

	    playerEl = el.parentElement;
	    store.dispatch((0, _player.setPlayerElement)(playerEl, renderer.domElement));
	    resize();
	  }

	  function orientHandle() {
	    console.log('orientHandle', !!vrControls);
	    if (vrControls) vrControls.update();
	    store.dispatch({ type: 'POKE' });
	  }

	  function deviceTrackingTransition(enabled) {
	    vrControls = enabled ? new _vrControls2.default(camera) : null;
	    window[enabled ? 'addEventListener' : 'removeEventListener']('deviceorientation', orientHandle);
	  }

	  function handleStateChanges() {
	    // TODO: only do this if the player has changed. Requires moving the cameraWorldMatrix
	    // out of the player state.
	    //

	    function stateChange(key, handler) {
	      var newState = store.getIn(['player', key]);
	      if (translatorState[key] !== newState) {
	        handler(newState, translatorState[key]);
	        translatorState[key] = newState;
	      }
	    }

	    if (true) stateChange('deviceTracking', deviceTrackingTransition);
	  }

	  function highlightSelection(rootNodeId) {
	    var node = rootNodeId && nodes[rootNodeId];
	    outlinePass.selectedObjects = node ? [node] : [];
	  }

	  /*
	   * After all nodes have been translated.
	   */
	  var renderDisplaySceneTimeout = null;
	  var lastRenderStartTime = -1;
	  var lastRenderDeltaTime = -1;

	  function updateRenderTime() {
	    var currentRenderStartTime = Date.now();
	    if (lastRenderStartTime > 0) {
	      lastRenderDeltaTime = currentRenderStartTime - lastRenderStartTime;
	    } else {
	      lastRenderDeltaTime = -1;
	    }

	    lastRenderStartTime = currentRenderStartTime;
	  }

	  function postTranslate() {
	    var renderingMode = (0, _player.getRenderingMode)(store);

	    if (renderDisplaySceneTimeout) {
	      clearTimeout(renderDisplaySceneTimeout);
	    }

	    updateRenderTime();

	    var playerCameraId = (0, _player.getCamera)(store);

	    // If we are switching the threejs camera, it should already be initialized
	    // (from VR controls, or previous camera, so just directly translate it)
	    if (cameraId !== playerCameraId) {
	      cameraId = playerCameraId;
	      fromCameraId = cameraId;
	      translatedCameraId = cameraId;
	      translate(cameraId, sceneGraph.evaluatedNodes[cameraId], sceneGraph.nodes[cameraId], true);
	    }

	    if (fromCameraId !== translatedCameraId) {
	      // Translate the new camera
	      translate(cameraId, sceneGraph.evaluatedNodes[cameraId], sceneGraph.nodes[cameraId], true);
	    }

	    handleStateChanges();

	    if (interactionHandler) {
	      updateTools();
	      updateWidgets();
	    }

	    selectedNodes = (0, _selection.getSelectedNodes)(store);
	    if ((0, _selection.isHighlighting)(store) && selectedNodes.length) {
	      highlightSelection(selectedNodes[0]);
	    } else {
	      highlightSelection(null);
	    }

	    if (reflectiveFloorMesh && reflectiveFloorMesh.data.reflectiveFloor) {
	      reflectiveFloorMaterial.distanceFade = reflectiveFloorMesh.data.reflectiveFloorFade;
	      reflectiveFloorMaterial.roughness = reflectiveFloorMesh.data.reflectiveFloorRoughness;
	      reflectiveFloorMaterial.metalness = reflectiveFloorMesh.data.reflectiveFloorMetallic;
	      reflectiveFloorMaterial.opacity = reflectiveFloorMesh.data.reflectiveFloorOpacity;
	      reflectiveFloorMaterial.fresnelStrength = reflectiveFloorMesh.data.reflectiveFloorFresnel;
	      reflectiveFloorMaterial.reflectivity = 0.5;

	      renderer.setClearColor(renderPass.clearColor, renderPass.clearAlpha);
	      reflectiveFloorMaterial.render(renderer, scene, camera, rect.width, rect.height);

	      //reflectiveFloorMesh.material = new THREE.MeshStandardMaterial({ emissive: 0xff00ff, emissiveMap: reflectiveFloorMaterial.material.uniforms.tReflection.value });
	    }
	    //renderer.setClearColor(renderPass.clearColor, renderPass.clearAlpha);

	    cubeTexturePass.camera = camera;
	    if (renderingMode === _player.RENDER_MODES.normal) {
	      //renderer.autoClear = true;
	      renderer.setClearColor(0xffffff);
	      renderPass.enabled = false;
	      effectFXAA.enabled = false;
	      ssaaRenderPass.enabled = true;
	      //renderer.setClearAlpha(0.9);
	      composer.render();
	    } else if (renderingMode === _player.RENDER_MODES.vr) {
	      renderPass.enabled = true;
	      effectFXAA.enabled = true;
	      ssaaRenderPass.enabled = false;
	      if (!externals.vrEffect) {
	        throw new Error('Expect vr mode to initialize vrEffect');
	      }

	      externals.vrEffect.render(scene, camera, null, true);
	    } else if (renderingMode === _player.RENDER_MODES.lenticular) {
	      stereoEffect.render(scene, camera);
	    }

	    if (renderingMode === _player.RENDER_MODES.normal) {
	      if (!serverRenderingMode || lastRenderDeltaTime > 0) {
	        renderDisplaySceneTimeout = setTimeout(function () {

	          updateRenderTime();

	          ssaaRenderPass.sampleLevel = 2;
	          composer.render();
	          ssaaRenderPass.sampleLevel = 1;

	          lastRenderStartTime = -1;
	          /*
	           renderDisplaySceneTimeout = setTimeout(function () {
	             updateRenderTime();
	             ssaaRenderPass.sampleLevel = 3;
	            composer.render();
	            ssaaRenderPass.sampleLevel = 1;
	          }, Math.max(lastRenderDeltaTime, 100) * 4);*/
	        }, Math.max(lastRenderDeltaTime, 100) * 4);
	      }
	    }
	  }

	  function updateTools() {
	    var commands = (0, _commands.getCommands)(store);
	    if (tools !== (0, _commands.getTools)(store)) {
	      tools = (0, _commands.getTools)(store);
	      interactionHandler.updateTools(tools.map(function (n) {
	        return commands[n];
	      }).toArray());
	    }
	  }

	  function initWidgets(command, name, rootName) {
	    nodes[rootName] = new THREE.Object3D();
	    nodes[rootName].name = name;
	    nodes.widgets.add(nodes[rootName]);
	    if (command.options.displayGizmo !== false) command.widget.draw.call(command, nodes[rootName]);
	  }

	  function removeWidgets(command, threeObject, name, rootName) {
	    var widget = command.widget;
	    if (widget && widget.remove) {
	      widget.remove.call(command, threeObject);
	    }

	    nodes.widgets.remove(threeObject);
	    delete nodes[rootName];
	  }

	  function updateWidgets() {
	    var commands = (0, _commands.getCommands)(store);
	    var activeCommandsWithWidgets = (0, _commands.getActiveCommandsWithWidgets)(store);

	    nodes.widgets.children.forEach(function (child) {
	      if (!activeCommandsWithWidgets[child.name]) {
	        removeWidgets(commands[child.name], child, child.name, 'widgetsRoot-' + child.name);
	      }
	    });

	    (0, _values2.default)(activeCommandsWithWidgets).forEach(function (command) {
	      var name = command.name,
	          widget = command.widget;

	      var rootName = 'widgetsRoot-' + name;
	      if (!nodes[rootName]) initWidgets(command, name, rootName);
	      if (widget && widget.position) widget.position.call(command, nodes[rootName]);
	    });
	  }

	  /*
	   * Scene is loaded.
	   */
	  function onLoad() {
	    loaded = true;
	    var playerData = sceneGraph.evaluatedNodes[(0, _sceneIO.getSceneId)(store)].Player;

	    if (!playerData.orbitTarget) {
	      var bbCenter = (0, _calculateBoundingBox2.default)(scene).getCenter();
	      if (isNaN(bbCenter.x) || isNaN(bbCenter.y) || isNaN(bbCenter.z)) bbCenter.set(0, 0, 0);
	      (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualTargetId, new THREE.Matrix4().makeTranslation(bbCenter.x, bbCenter.y, bbCenter.z));
	    }

	    if (!context) {
	      interactionHandler = (0, _manipulators.initManipulators)(store, this, renderer.domElement);
	      interactionHandler.resize(rect);
	    }

	    nodes.widgets = new THREE.Object3D();
	    nodes.widgets.name = 'Widgets';
	    scene.add(nodes.widgets);
	  }

	  function getAnnotations() {
	    return annotations;
	  }

	  function addToParent(id, node, obj, skipReplace) {
	    // console.log('Add toParent: ', node && node.get('parent'), obj);
	    var parentId = node && node.parent;
	    var parent = parentId && nodes[parentId] || scene;
	    obj.name = node.name; // eslint-disable-line no-param-reassign
	    obj.nodeId = id;

	    if (nodes[id]) {
	      if (skipReplace) return;

	      var children = [].concat(nodes[id].children);
	      for (var i = 0; i < children.length; i++) {
	        nodes[id].remove(children[i]);
	        obj.add(children[i]);
	      }

	      parent.remove(nodes[id]);
	      if (nodes[id].geometry) nodes[id].geometry.dispose();
	    }

	    nodes[id] = obj;
	    parent.add(nodes[id]);
	  }

	  var plugs = {
	    PolyMesh: function PolyMesh(id, data, node, properties) {
	      var visible = properties.visible;
	      var mesh = data.mesh,
	          previousMesh = data.previousMesh;

	      //const collapseMaps = true;

	      var indexingMode = renderer.extensions.get('OES_element_index_uint') ? _polyMesh2.ThreeExport.CompactIndices : _polyMesh2.ThreeExport.NoIndices;
	      var interleaved = false;
	      var oldMesh = nodes[id];
	      var prevTriangulation = oldMesh && oldMesh.userData.triangulation;
	      var prevIndexing = oldMesh && oldMesh.userData.renderIndexing;
	      var prevValueMap = oldMesh && oldMesh.userData.valueMap;
	      var bufferInfo = mesh && _polyMesh2.ThreeExport.exportBufferGeometry(mesh, indexingMode, interleaved, null, previousMesh, prevTriangulation, prevIndexing, prevValueMap);

	      var geometry = void 0,
	          triangulation = void 0,
	          triangulationChanged = void 0,
	          renderIndexing = void 0,
	          valueMap = void 0;
	      if (bufferInfo) {
	        geometry = bufferInfo.geometry;
	        triangulation = bufferInfo.triangulation;
	        triangulationChanged = bufferInfo.triangulationChanged;
	        renderIndexing = bufferInfo.renderIndexing;
	        valueMap = bufferInfo.valueMap;
	      }

	      var obj = void 0;

	      if (triangulationChanged || !oldMesh) {
	        obj = geometry && new THREE.Mesh(geometry, (0, _materials.primitiveToMaterial)(store));
	      } else {
	        obj = oldMesh;
	        if (geometry) {
	          obj.geometry.dispose();
	          obj.geometry = geometry;
	        }
	        //obj.material.dispose();
	        //obj.material = primitiveToMaterial(store);
	      }

	      if (obj) {
	        obj.visible = visible;
	        obj.userData.triangulation = triangulation;
	        obj.userData.renderIndexing = renderIndexing;
	        obj.userData.valueMap = valueMap;
	      }

	      addToParent(id, node, obj || new THREE.Object3D());
	    },

	    Light: function Light(id, data, node) {
	      var obj = nodes[id];
	      if (!obj) {
	        obj = (0, _light.createLight)(data);
	        if (obj) addToParent(id, node, obj);
	      } else {
	        (0, _light.updateLight)(data, obj);
	      }
	    },

	    Bone: function Bone(id, data, node) {
	      if (!nodes[id]) addToParent(id, node, new THREE.Object3D());
	    },

	    Null: function Null(id, data, node) {
	      if (!nodes[id]) addToParent(id, node, new THREE.Object3D());
	    },

	    PrefetchMaterialNull: function PrefetchMaterialNull(id, data, node, properties) {
	      if (loaded && properties.prefetch && !nodes[id]) {
	        //console.log('Add a node for prefetch of material: ', node.name);
	        addToParent(id, node, new THREE.Object3D());
	      }
	    },

	    Transform: function Transform(id, data, node) {
	      if (!data || !data.transform) return;
	      if (nodes[id]) (0, _transform.setMatrixOn)(nodes[id], data.transform);
	    },

	    Material: function Material(id, data) {
	      if (!nodes[id]) return;
	      nodes[id].material = (0, _materials.primitiveToMaterial)(store, renderer, data, nodes[id].material);
	    },

	    Image: function Image(id, data, node, properties) {
	      if (loaded && properties.prefetch) (0, _materials.getTextureImage)(store, data);
	    },

	    Environment: function Environment(id, data) {
	      var backgroundStyle = data.backgroundStyle;
	      clearPass.enabled = false;
	      cubeTexturePass.enabled = false;

	      switch (backgroundStyle) {

	        case BACKGROUND_STYLE_COLOR:
	          clearPass.enabled = true;
	          clearPass.clearColor = data.backgroundColor;
	          clearPass.clearAlpha = data.backgroundOpacity;
	          break;
	        case BACKGROUND_STYLE_IMAGE:
	          texturePass.enabled = true;
	          texturePass.map = (0, _materials.assignTexture)(store, renderer, data.background);
	          break;
	        case BACKGROUND_STYLE_CUBEMAP:
	        case BACKGROUND_STYLE_ENVIRONMENT:
	          {

	            clearPass.enabled = true;
	            clearPass.clearColor = 0x000000;
	            clearPass.clearAlpha = 0.0;

	            cubeTexturePass.enabled = true;

	            var cubeMapNode = void 0;
	            var cubeMapBlurring = void 0;

	            if (backgroundStyle === BACKGROUND_STYLE_ENVIRONMENT) {
	              cubeMapNode = data.environmentMap;
	              if (cubeMapNode) {
	                cubeMapNode = cubeMapNode.specularCubeMap;
	              }

	              cubeMapBlurring = data.environmentMapBlurring;
	            } else {
	              cubeMapNode = data.cubeMap;
	              cubeMapBlurring = data.cubeMapBlurring;
	            }

	            if (cubeMapNode) {
	              cubeTexturePass.envMap = (0, _materials.getCubeMapTexture)(store, renderer, cubeMapNode, true);
	              cubeTexturePass.envMapIntensity = 1.0;
	              cubeTexturePass.opacity = data.backgroundOpacity;
	              cubeTexturePass.roughness = data.cubeMapBlurring;
	            } else {
	              cubeTexturePass.enabled = false;
	            }
	          }

	          break;

	        default:
	          clearPass.enabled = true;
	          clearPass.clearColor = new THREE.Color(1, 1, 1);
	          clearPass.clearAlpha = 0;
	          break;
	      }
	    },

	    Player: function Player(id, data, node) {
	      if (data.camera && data.camera !== fromCameraId && sceneGraph.nodes[data.camera]) {
	        var fromNode = sceneGraph.nodes[data.camera];
	        var cameraNode = sceneGraph.nodes[cameraId];
	        var copiedNode = (0, _sceneGraph.initNode)(fromNode);
	        var target = copiedNode.plugs.Transform.find(function (op) {
	          return op.target;
	        });
	        if (target) copiedNode.plugs.Camera[0].targeted = true;
	        store.dispatch((0, _sceneGraph.replace)(cameraId, (0, _assign2.default)(cameraNode, { plugs: copiedNode.plugs })));
	        fromCameraId = data.camera;
	      }

	      if (data.orbitTarget && data.orbitTarget !== pivotId) {
	        pivotId = data.orbitTarget;
	        // FIXME: remove scale here?
	        (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualTargetId, (0, _scene.getWorldTransform)(store, pivotId));
	      }

	      var styleToToneMapping = {
	        Linear: THREE.LinearToneMapping,
	        Reinhard: THREE.ReinhardToneMapping,
	        Cineon: THREE.CineonToneMapping,
	        Filmic: THREE.Uncharted2ToneMapping
	      };

	      renderer.toneMapping = styleToToneMapping[data.toneMapStyle];
	      renderer.toneMappingExposure = data.toneMapExposureGain;
	      renderer.toneMappingWhitePoint = data.toneMapWhitePoint;
	      renderer.gammaInput = true;
	      renderer.gammaOutput = true;
	      renderer.autoClear = false;

	      saoPass.enabled = data.saoPass;
	      saoPass.intensity = data.saoIntensity;
	      saoPass.occlusionSphereWorldRadius = data.saoScale;

	      bloomPass.enabled = data.bloomPass;
	      bloomPass.threshold = data.bloomThreshold;
	      //bloomPass.smoothWidth = data.bloomBlendRange;//not exposed in three.js yet

	      dofPass.enabled = data.dofPass;
	      //dofPass.dofMaxBlur = data.dofMaxBlur; //not exposed in three.js yet

	      if (data.reflectiveFloor && (!data.reflectiveFloorExcludeServer || (true))) {

	        if (!reflectiveFloorMaterial) {
	          var mirrorGeo = new THREE.PlaneBufferGeometry(1, 1);
	          reflectiveFloorMaterial = new THREE.GlossyMirror({ clipBias: 0.003, textureWidth: 1024, textureHeight: 1024, color: 0x777777, localMirrorNormal: new THREE.Vector3(0, 1, 0) });
	          reflectiveFloorMesh = new THREE.Mesh(mirrorGeo, reflectiveFloorMaterial.material);
	        }

	        reflectiveFloorMaterial.specularColor = new THREE.Color(0xffffff);

	        reflectiveFloorMesh.scale.x = data.reflectiveFloorWidth;
	        reflectiveFloorMesh.scale.y = data.reflectiveFloorWidth;
	        reflectiveFloorMesh.rotation.x = -Math.PI * 0.5;
	        reflectiveFloorMesh.position.y = data.reflectiveFloorHeight;

	        reflectiveFloorMesh.data = data;

	        if (!reflectiveFloorMesh.parent) {
	          scene.add(reflectiveFloorMesh);
	        }
	      } else {
	        if (reflectiveFloorMesh && reflectiveFloorMesh.parent) {
	          scene.remove(reflectiveFloorMesh);
	        }
	      }
	    },

	    Camera: function Camera(id, data, node) {
	      if (id === cameraId && loaded) {

	        camera.fov = data.fieldOfView;
	        camera.aspect = data.aspectRatio;
	        camera.near = data.nearClip;
	        camera.far = data.farClip;
	        camera.focus;

	        if (data.projection === 'Orthographic') {
	          //disable passes and mirror at this point
	          saoPass.enabled = false;
	          ssaaRenderPass.enabled = true;
	          dofPass.enabled = false;
	          scene.remove(reflectiveFloorMesh);

	          camera.zoom = 1 / data.orthoZoom;
	          camera.hyperfocusOffset = 1;
	          camera.hyperfocusScale = 0;
	          camera.inPerspectiveMode = false;
	          camera.inOrthographicMode = true;

	          // Set flags for ThreeJS camera type recognition
	          camera.isOrthographicCamera = true;
	          camera.isPerspectiveCamera = false;
	        } else {
	          // Set flags for ThreeJS camera type recognition
	          camera.isOrthographicCamera = false;
	          camera.isPerspectiveCamera = true;

	          camera.inPerspectiveMode = true;
	          camera.inOrthographicMode = false;
	          dofPass.focalDepth = data.focalDepthEnabled ? data.focalDepth : data.targetDistance;
	        }

	        camera.updateProjectionMatrix();
	      }

	      if (data.newRadiusConstraint) (0, _camera.initCameraRadiusConstraint)(store, id, data, data.newRadiusConstraint);
	    },

	    CameraTransform: function CameraTransform(id, data, node, Properties, nodeData) {
	      if (id === cameraId && loaded) {
	        if (translatedCameraId !== fromCameraId || !nodeData.Camera.upPosition) {
	          (0, _camera.initCamera)(store, true, fromCameraId, id, rect);

	          translatedCameraId = fromCameraId;
	        }

	        var cameraData = nodeData.Camera;
	        var renderingMode = (0, _player.getRenderingMode)(store);
	        var matrix = data.target && cameraData.targeted && cameraData.upPosition && renderingMode !== _player.RENDER_MODES.vr && !translatorState['deviceTracking'] ? (0, _camera.updateLookatTarget)(store, id, data, cameraData) : data.transform;
	        (0, _transform.setMatrixOn)(camera, matrix);
	      }
	    },

	    Annotation: function Annotation(id, data, node, properties) {
	      var calcDirection = data.directionMode === 'awayFromOrigin';
	      annotations[id] = {
	        id: id,
	        annotation: data,
	        position: (0, _annotation.getScreenPositionNormalAlpha)(id, calcDirection, data.directionAxis, data.directionTarget),
	        visible: properties.visible
	      };
	    }
	  };

	  plugs.BinMesh = plugs.PolyMesh;

	  var order = {
	    Scene: ['Player', 'Environment'],
	    BinMesh: ['BinMesh', 'Transform', 'Material'],
	    PolyMesh: ['PolyMesh', 'Transform', 'Material'],
	    Light: ['Light', 'Transform'],
	    Camera: [['Transform', 'CameraTransform'], 'Camera'],
	    Null: ['Null', 'Transform'],
	    Model: ['Null', 'Transform'],
	    Objects: ['Null'],
	    MaterialLibrary: ['Null'],
	    Material: ['PrefetchMaterialNull', 'Material'], // for prefetch of material
	    Image: ['Image'], // for prefetch of image
	    Renderers: [],
	    Passes: [],
	    Pass: [],
	    Renderer: [],
	    Bone: ['Bone', 'Transform'],
	    Annotation: ['Annotation']
	  };

	  var forceDeps = {
	    // When the mesh has changed, we need to run material translator again
	    PolyMesh: { Material: true, Transform: true },
	    BinMesh: { Material: true, Transform: true }
	  };

	  /*
	   * Translate a node, either create or update
	   */
	  function translate(id, data, node, force) {
	    var type = node.type;
	    var processPlugs = order[type] || [];
	    if (!translated[id]) translated[id] = {};
	    var translateAnyway = {};
	    var plug = void 0;
	    var plugFunction = void 0;

	    //console.log('translate: ', type, node.name, translated[id]);
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = (0, _getIterator3.default)(processPlugs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var nextPlug = _step.value;

	        var _ref = Array.isArray(nextPlug) ? nextPlug : [nextPlug, nextPlug];

	        var _ref2 = (0, _slicedToArray3.default)(_ref, 2);

	        plug = _ref2[0];
	        plugFunction = _ref2[1];


	        var plugData = data[plug];
	        if (force || !plugData || plugData._v !== translated[id][plug] || translateAnyway[plug]) {
	          if (forceDeps[plug]) translateAnyway = forceDeps[plug];
	          //console.log(' - ', plug);
	          if (plugs[plugFunction]) {
	            plugs[plugFunction](id, plugData, node, data.Properties, data);
	            translated[id][plug] = plugData && plugData._v;
	          } else {
	            console.warn('Unknown plug translator for: ', plug, node.name);
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }

	  /*
	   * Delete a node
	   */
	  function deleteNode(id) {
	    var obj = nodes[id];
	    var annoObj = annotations[id];

	    if (obj || annoObj) delete translated[id];

	    if (obj) {
	      delete nodes[id];
	      obj.parent.remove(obj);
	    } else if (annoObj) {
	      delete annotations[id];
	    }
	  }

	  function getNodeBoundingBox(id) {
	    return (0, _calculateBoundingBox2.default)(nodes[id]);
	  }

	  function getThreeObject(id) {
	    return nodes[id];
	  }

	  function getCameraMouseRay(ndc) {
	    var ray = new THREE.Raycaster();
	    ray.setFromCamera(ndc, camera); // camera.inOrthographicMode ? camera.cameraO : camera.cameraP);
	    return ray;
	  }

	  function raycastSelect(mousePosition) {
	    var rootNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Objects';

	    var hits = [];
	    var selectedObjects = [];
	    var ray = getCameraMouseRay(mousePosition);
	    var objectsRoot = scene;
	    scene.children.forEach(function (child) {
	      if (child.type === 'Object3D' && child.name === rootNode) objectsRoot = child;
	    });

	    objectsRoot.traverse(function (node) {
	      if (!node.visible) return;
	      if (!node.geometry) return;

	      if (node.geometry.boundingBox === null) {
	        node.geometry.computeBoundingBox();
	      }

	      var geometry = node.geometry;

	      if (geometry.boundingBox.isEmpty() === false) {
	        node.matrix.compose(node.position, node.quaternion, node.scale);
	        node.updateMatrixWorld(true);
	        var inter = ray.intersectObject(node);
	        if (inter.length > 0) {
	          hits.push({ id: node.nodeId, node: node, data: inter });
	        }
	      }
	    });
	    hits.sort(function (a, b) {
	      return a.data[0].distance - b.data[0].distance;
	    });

	    return hits;
	  }

	  function getObjectRoot(nodeId) {
	    var id = null;

	    if (nodeId !== null) {
	      var rootNode = nodes[nodeId];
	      rootNode.traverse(function (node) {
	        if (node.name === 'Fbx_Root') {
	          //Need to find the first child node of Import_Null
	          id = node.nodeId;
	        }
	      });
	    }

	    return id;
	  }

	  function toScreenPosition(rootNodeId) {
	    if (rootNodeId) {
	      var obj = nodes[rootNodeId];
	      if (obj) {
	        var vector = new THREE.Vector3();

	        var widthHalf = 0.5 * renderer.context.canvas.width;
	        var heightHalf = 0.5 * renderer.context.canvas.height;

	        obj.updateMatrixWorld();
	        var bbox = (0, _calculateBoundingBox2.default)(obj);
	        var height = bbox.max.y - bbox.min.y;
	        obj.updateMatrixWorld();
	        vector.setFromMatrixPosition(obj.matrixWorld);
	        vector.y += height;
	        vector.project(camera);

	        vector.x = vector.x * widthHalf + widthHalf;
	        vector.y = -(vector.y * heightHalf) + heightHalf;

	        return {
	          x: vector.x,
	          y: vector.y
	        };
	      }
	    }
	  };

	  function reset() {
	    loaded = null;
	    cameraId = _sceneGraph.virtualCameraId;
	    fromCameraId = _sceneGraph.virtualCameraId;
	    translatedCameraId = null;
	    pivotId = null;
	    translated = {};
	  }

	  return {
	    attach: attach,
	    resize: resize,
	    translate: translate,
	    deleteNode: deleteNode,
	    raycastSelect: raycastSelect,
	    getCameraMouseRay: getCameraMouseRay,
	    getNodeBoundingBox: getNodeBoundingBox,
	    getThreeObject: getThreeObject,
	    toScreenPosition: toScreenPosition,
	    getObjectRoot: getObjectRoot,
	    postTranslate: postTranslate,
	    onLoad: onLoad,
	    getAnnotations: getAnnotations,
	    getContext: getContext,
	    reset: reset,
	    scene: scene,
	    camera: camera,
	    renderer: renderer,
	    externals: externals
	  };
	}

	function threeTranslator(store, context) {
	  return (0, _translator.createTranslator)(store, initTranslator, context);
	}

/***/ },
/* 376 */
/*!***************************************!*\
  !*** ./src/translators/translator.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 101);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	exports.createTranslator = createTranslator;

	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 283);

	var _sceneGraph = __webpack_require__(/*! ../modules/sceneGraph */ 144);

	var _animation = __webpack_require__(/*! ../modules/animation */ 134);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var defaultNodeFilter = function defaultNodeFilter(n) {
	  return true;
	};

	var defaultFns = {
	  onLoad: function onLoad() {},
	  postTranslate: function postTranslate() {},
	  handleStateChanges: function handleStateChanges() {}
	};

	function createTranslator(store, initTranslator, context) {
	  var api = {};
	  var translator = initTranslator(store, context, api);
	  var nodeFilter = defaultNodeFilter;

	  var view = null;
	  var player = store.get('player');

	  var translatedSceneId = void 0;

	  var translatedVersion = null;
	  var translatedNodes = {};
	  var renderingMode = store.getIn(['player', 'renderingMode']);
	  var vrDisplay = void 0;

	  function translateNodes(sceneId) {
	    var sceneGraph = (0, _sceneGraph.getEvalSceneGraph)(store);

	    if (translatedVersion === sceneGraph._ev) return 0;

	    var newTranslatedNodes = {};

	    //console.log('translate from', translatedVersion, 'to', sceneGraph._ev); //, translatedNodes);

	    var numUpdated = 0;

	    function translateNode(id) {
	      var node = sceneGraph.nodes[id];
	      if (!node) return;
	      var result = sceneGraph.evaluatedNodes[id];
	      var translated = translatedNodes[id];

	      if (!translated || translated._v !== result._v || translated._ev !== result._ev) {
	        //console.log('translate: ', translatedNodes[id], {_v: result._v, _ev: result._ev}, node.name);
	        translator.translate(id, result, node);
	        numUpdated += 1;
	      }

	      newTranslatedNodes[id] = { _v: result._v, _ev: result._ev };

	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = (0, _getIterator3.default)(node.children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var childId = _step.value;

	          translateNode(childId);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }

	    translateNode(sceneId);

	    if (sceneGraph.nodes[_sceneGraph.virtualCameraId]) translateNode(_sceneGraph.virtualCameraId);
	    if (sceneGraph.nodes[_sceneGraph.vrCameraId]) translateNode(_sceneGraph.vrCameraId);

	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;

	    try {
	      for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(translatedNodes)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var id = _step2.value;

	        if (!newTranslatedNodes[id]) {
	          translator.deleteNode(id);
	        }
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }

	    translatedNodes = newTranslatedNodes;
	    translatedVersion = sceneGraph._ev;

	    return numUpdated;
	  }

	  function doUpdate() {}

	  function reset() {
	    translator.reset();
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;

	    try {
	      for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(translatedNodes)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var id = _step3.value;

	        translator.deleteNode(id);
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	          _iterator3.return();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }

	    translatedVersion = null;
	    translatedNodes = {};
	  }

	  return (0, _assign2.default)({}, defaultFns, translator, {
	    update: function update() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      var sceneId = (0, _sceneIO.getSceneId)(store);
	      var scenePhase = (0, _sceneIO.getScenePhase)(store);
	      if (!sceneId) {
	        translatedSceneId = null;
	        return;
	      }

	      if (sceneId !== translatedSceneId || scenePhase < _sceneIO.SCENE_PHASES.RENDERING) {
	        reset();
	        translatedSceneId = sceneId;
	      }

	      // console.log('translator do update');
	      var numUpdated = translateNodes(sceneId);
	      //console.log('numUpdated: ', numUpdated);
	      var rendering = scenePhase >= _sceneIO.SCENE_PHASES.RENDERING;
	      var preloaded = scenePhase >= _sceneIO.SCENE_PHASES.PRELOADING;
	      var loaded = scenePhase >= _sceneIO.SCENE_PHASES.LOADED;
	      var rendered = scenePhase >= _sceneIO.SCENE_PHASES.RENDERED;

	      //console.log('numUpdated', numUpdated, 'assetsLoaded', areAssetsLoaded(store), 'rendering', rendering, 'preloaded', preloaded, 'loaded', loaded);

	      if (!rendering && numUpdated) {
	        store.dispatch((0, _sceneIO.markRenderingScene)());
	      }

	      if (loaded && !rendered) {
	        store.dispatch((0, _sceneIO.markRenderedScene)());
	      }

	      if (!loaded && preloaded && (0, _sceneIO.areAssetsLoaded)(store)) {
	        translator.onLoad();
	        store.dispatch((0, _sceneIO.markLoaded)());
	      }

	      if (!preloaded && (0, _sceneIO.areAssetsPreloaded)(store)) {
	        store.dispatch((0, _sceneIO.markPreloaded)());
	      }

	      if (preloaded) translator.postTranslate();

	      store.dispatch((0, _animation.incrementTime)());
	    }
	  });
	};

/***/ },
/* 377 */
/*!**************************************!*\
  !*** ./src/translators/materials.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 101);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.getCubeMapTexture = getCubeMapTexture;
	exports.getTextureImage = getTextureImage;
	exports.assignTexture = assignTexture;
	exports.primitiveToMaterial = primitiveToMaterial;

	var _detectBrowser = __webpack_require__(/*! detect-browser */ 378);

	var _detectBrowser2 = _interopRequireDefault(_detectBrowser);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _asset = __webpack_require__(/*! ./asset */ 228);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// headless-gl and IE cause color quantization in our hdr.png's, so use original HDR instead
	var preferHDRSource = !(true) || (true) && _detectBrowser2.default && _detectBrowser2.default.name === 'ie';

	var textures = {};
	function checkTextureCache(id, image) {
	  var cachedImage = textures[id] && textures[id].image;

	  if (cachedImage && cachedImage._v === image._v) {
	    return textures[id].value;
	  }
	  return null;
	}

	function cacheTexture(id, image, value) {
	  if (textures[id]) {
	    textures[id].value.dispose();
	  }
	  textures[id] = { image: image, value: value };
	  return value;
	}

	function getCubeMapTexture(store, renderer, image, textureCubeOnly, allowHDR) {
	  var maps = image.maps,
	      nodeId = image.nodeId;


	  var texture = checkTextureCache(nodeId, image);
	  if (texture) return texture;

	  var useHDR = false;
	  var useHDRSource = false;
	  if (allowHDR && maps[0].preferHDR) useHDR = true;
	  if (useHDR && preferHDRSource && maps[0].hdrSource) useHDRSource = true;

	  var images = maps.map(function (imgPrimitive) {
	    var fetchImage = useHDRSource ? _asset.fetchHDRSourceData : _asset.fetchTextureImage;
	    var img = fetchImage(store, imgPrimitive, true);

	    // if hdr data, need to construct DataTexture in place of normal Image
	    if (img && useHDRSource) {
	      var dataTexture = new THREE.DataTexture(img.data, img.width, img.height);
	      dataTexture.encoding = THREE.RGBEEncoding;
	      dataTexture.generateMipmaps = false;
	      dataTexture.type = THREE.UnsignedByteType;
	      dataTexture.minFilter = THREE.NearestFilter;
	      dataTexture.magFilter = THREE.NearestFilter;
	      dataTexture.format = THREE.RGBEFormat;
	      img = dataTexture;
	    }

	    return img;
	  });

	  if (!(0, _ramda.all)(function (img) {
	    return !!img;
	  }, images)) {
	    // console.log( "getCubeMapTexture early exit, as all images are not available.");
	    return null;
	  }

	  var textureCube = new THREE.CubeTexture();

	  // CubeTexure supports images as either instances of HTMLImageElement (for url-accessible image
	  // elements) or THREE.DataTexture (for raw image data, such as our hdr source)
	  textureCube.images = images;

	  textureCube.flipY = false;
	  textureCube.needsUpdate = true;
	  if (useHDR) {
	    textureCube.encoding = useHDRSource ? THREE.RGBEEncoding : maps[0].hdrEncoding;
	    textureCube.generateMipmaps = false;
	  }

	  if (textureCubeOnly) return cacheTexture(nodeId, image, textureCube);

	  var pmremFilter = useHDRSource ? THREE.NearestFilter : THREE.LinearFilter;

	  // console.log( "Creating PMREMGenerator()");
	  var pmremGenerator = new THREE.PMREMGenerator(textureCube, renderer.isMobile ? 20 : 64);
	  pmremGenerator.update(renderer);

	  pmremGenerator.cubeLods[0].texture.magFilter = pmremFilter;
	  pmremGenerator.cubeLods[0].texture.minFilter = pmremFilter;

	  // console.log( "Creating PMREMCubeUVPacker()");
	  var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker(pmremGenerator.cubeLods);
	  pmremCubeUVPacker.update(renderer);

	  pmremCubeUVPacker.CubeUVRenderTarget.texture.magFilter = pmremFilter;
	  pmremCubeUVPacker.CubeUVRenderTarget.texture.minFilter = pmremFilter;

	  // console.log( "PMREM Creation Done.");

	  return cacheTexture(nodeId, image, pmremCubeUVPacker.CubeUVRenderTarget.texture);
	}

	function getTextureImage(store, image) {
	  if (!image) return;
	  var nodeId = image.nodeId;

	  if (!checkTextureCache(nodeId, image)) {
	    if (image.maps) {
	      (0, _ramda.map)((0, _ramda.curry)(_asset.fetchTextureImage)(store), image.maps);
	    } else {
	      (0, _asset.fetchTextureImage)(store, image);
	    }
	  }
	}

	/*
	 * Modifies the map being passed in.
	 */
	function assignTexture(store, renderer, image, optionalThreemap, slot) {
	  if (!image) {
	    if (optionalThreemap) optionalThreemap.texture = null;
	    return null;
	  }

	  // Only use hdr for maps that represent light sources. Not others, since we don't want to
	  // *reflect* more than 1 light intensity. Note: Apparently hdr 'lightMap' not yet supported in
	  // ThreeJS, so don't include it here (yet).
	  var allowHDR = slot === 'envMap' || slot === 'emissiveMap';

	  if (image.maps) {
	    return getCubeMapTexture(store, renderer, image, false, allowHDR);
	  }

	  var useHDR = false;
	  var useHDRSource = false;
	  if (allowHDR && image.preferHDR) useHDR = true;
	  if (useHDR && preferHDRSource && image.hdrSource) useHDRSource = true;

	  var uvOptions = (0, _assign2.default)({}, image);
	  var nodeId = image.nodeId;
	  var texture = checkTextureCache(nodeId, image);

	  if (!texture) {
	    texture = useHDRSource ? new THREE.DataTexture() : new THREE.Texture();
	    texture.meta = { nodeId: nodeId };
	    if (image.canvasOperations) {
	      (function () {
	        texture.meta.source = 'canvas operator';
	        var ops = image.canvasOperations;

	        var canvas = document.createElement('canvas');
	        canvas.width = image.width;
	        canvas.height = image.height;
	        var context = canvas.getContext('2d');

	        var ok = ops.reduce(function (ok, op) {
	          context.save();
	          var ret = ok && op(context, store);
	          context.restore();
	          return ret;
	        }, true);

	        if (ok) texture.image = canvas;
	      })();
	    } else {
	      texture.meta.source = 'image fetch';
	      var fetchImage = useHDRSource ? _asset.fetchHDRSourceData : _asset.fetchTextureImage;
	      texture.image = fetchImage(store, image);
	    }

	    if (!texture.image) {
	      if (optionalThreemap) optionalThreemap.texture = null;
	      return null;
	    }

	    texture.transparent = true;

	    var textureWraps = {
	      0: THREE.ClampToEdgeWrapping,
	      1: THREE.RepeatWrapping,
	      2: THREE.MirroredRepeatWrapping
	    };

	    texture.wrapS = textureWraps[uvOptions.wrapU];
	    texture.wrapT = textureWraps[uvOptions.wrapV];

	    texture.generateMipmaps = useHDR ? false : uvOptions.generateMipMaps;
	    texture.anisotropy = texture.generateMipmaps ? 16 : 1;
	    texture.magFilter = useHDRSource ? THREE.NearestFilter : uvOptions.magFilter;
	    texture.minFilter = useHDRSource ? THREE.NearestFilter : uvOptions.minFilter;
	    texture.encoding = useHDR ? userHDRSource ? THREE.RGBEEncoding : uvOptions.hdrEncoding : THREE.sRGBEncoding;

	    if (THREE.Math.nearestPowerOfTwo(texture.image.width) !== texture.image.width || THREE.Math.nearestPowerOfTwo(texture.image.height) !== texture.image.height) {
	      texture.wrapS = THREE.ClampToEdgeWrapping;
	      texture.wrapT = THREE.ClampToEdgeWrapping;
	      texture.generateMipmaps = false;
	      texture.anisotropy = 1;
	      texture.anisotropy = 1;
	      texture.magFilter = useHDRSource ? THREE.NearestFilter : THREE.LinearFilter;
	      texture.minFilter = useHDRSource ? THREE.NearestFilter : THREE.LinearFilter;
	    }

	    texture.needsUpdate = true;

	    cacheTexture(nodeId, image, texture);
	  }

	  if (!optionalThreemap) {
	    return texture;
	  }

	  optionalThreemap.texture = texture;

	  optionalThreemap.uvTransform = true;
	  optionalThreemap.uvOffset = new THREE.Vector2(uvOptions.uOffset, uvOptions.vOffset);
	  optionalThreemap.uvRepeat = new THREE.Vector2(uvOptions.uTile, uvOptions.vTile);

	  optionalThreemap.texelTransform = true;
	  optionalThreemap.texelInvert = uvOptions.invert;
	  optionalThreemap.texelScale = uvOptions.gain;
	  optionalThreemap.texelOffset = uvOptions.brightness;
	  //texture.gainPivot = uvOptions.gainPivot;
	  //texture.gain = uvOptions.gain;
	  //texture.brightness = uvOptions.brightness;

	  //console.log('texture with image', texture);
	  //textures[id] = texture;
	  return optionalThreemap;
	};

	var initialStandardDefaults = {
	  side: 2,
	  emissive: { r: 0, g: 0, b: 0 },
	  ambient: { r: 0, g: 0, b: 0 },
	  vertexColors: 0,
	  opacity: 1,
	  transparent: false,
	  specular: { r: 1, g: 1, b: 1 },
	  normalScale: { x: 1, y: 1 },
	  envMap: null,
	  combine: 0,
	  color: { r: 0.1803921568627451, g: 0.4, b: 0.8274509803921568 },
	  metal: false,
	  gloss: false,
	  reflectivity: 1,
	  refractionRatio: 0.98,
	  shininess: 50
	};

	function primitiveToMaterial(store, renderer, data, previousMaterial) {
	  var material = previousMaterial && previousMaterial instanceof THREE.MeshPhysicalMaterial ? previousMaterial : new THREE.MeshPhysicalMaterial({});

	  if (!data) return material;

	  if (data.type === 'MultiID') {
	    var mats = [];
	    for (var i = 0; i < 30; i++) {
	      if (data['material' + i]) {
	        mats.push(primitiveToMaterial(store, renderer, data['material' + i]));
	      } else {
	        var defaultColor = { defaultColor: data.defaultColor };
	        mats.push(primitiveToMaterial(store, renderer, defaultColor));
	      }
	    }
	    material = new THREE.MultiMaterial(mats);
	    return material;
	  }
	  // TODO: vertexColors, blend/combine?
	  // FIXME: envMapScale??
	  if (data.defaultColor) {
	    material.color = data.defaultColor;
	    return material;
	  }

	  if (!data.baseColor) {
	    //console.log('Expected physical material, received: ', data.toJS());
	    if (data.diffuseColor) material.color = data.diffuseColor;
	    return material;
	  }

	  //side?
	  //
	  //name mapping
	  //three.js: clara.io
	  var propertyMap = {
	    color: 'baseColor',
	    //ambient: 'ambientColor2',
	    bumpScale: 'bumpFactor',
	    emissive: 'emissiveColor',
	    falloff: 'baseFalloff',
	    falloffColor: 'baseFalloffColor',
	    metalness: 'metallic',
	    roughness: 'roughness',
	    clearCoat: 'clearCoat',
	    clearCoatRoughness: 'clearCoatRoughness',
	    opacity: 'opacityFactor', // opacityMap and opacityColor are not supported in Three.js
	    falloffOpacity: 'opacityFalloffFactor',
	    //specular: 'specularColor',
	    //translucency: 'translucencyColor',
	    transparent: 'baseMapTransparent'
	  };

	  var keys = ['depthTest', 'depthWrite'];

	  // 'anisotropyMap','anisotropyRotationMap','--diffuseEnvMap','falloffMap', '+-metallicMap','+-opacityMap','reflectivityMap','specularMap','translucencyMap',
	  // '--ambient','falloff','falloffColor','specular','translucency'
	  //  'anisotropy','anisotropyRotation', 'clearCoat','clearCoatRoughness','+-metallic', 'translucencyNormalAlpha','translucencyNormalPower', 'translucencyViewAlpha','translucencyViewPower'

	  //name mapping
	  //three.js: clara.io
	  var imageMaps = {
	    map: 'baseMap',
	    bumpMap: 'bumpMap',
	    emissiveMap: 'emissiveMap',
	    lightMap: 'lightMap',
	    metalnessMap: 'metallicMap',
	    normalMap: 'normalMap',
	    alphaMap: 'opacityMap',
	    roughnessMap: 'roughnessMap',
	    falloffMap: 'baseFalloffMap',
	    falloffAlphaMap: 'opacityFalloffMap'
	  };

	  function updateTexture(image, slot) {
	    var mapTex = assignTexture(store, renderer, image, material[slot] || new THREE.MaterialMap(), slot);
	    if (mapTex && !material[slot]) material[slot] = mapTex;
	  };

	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(imageMaps)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var image = _step.value;

	      updateTexture(data[imageMaps[image]], image + 'Slot');
	    }

	    //must be after updateTexture
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;

	  try {
	    for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(propertyMap)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var to = _step2.value;

	      material[to] = data[propertyMap[to]];
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }

	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;

	  try {
	    for (var _iterator3 = (0, _getIterator3.default)(keys), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var key = _step3.value;

	      material[key] = data[key];
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }

	  if (data.emissiveScale) {
	    material.emissive = material.emissive.clone();
	    material.emissive.multiplyScalar(data.emissiveScale);
	  }

	  material.transparent = material.opacity < 1.0 || !!data.opacityMap || data.baseMapTransparent || data.opacityFalloffFactor < 1.0 || !!data.opacityFalloffMap;

	  var specular = data.specularColor;
	  material.reflectivity = (specular.r + specular.g + specular.b) * 0.33333;
	  material.clearCoat *= 0.25;
	  material.normalScale.x = (data.normalRedFlip ? -1 : 1) * data.normalFactor;
	  material.normalScale.y = (data.normalGreenFlip ? -1 : 1) * data.normalFactor;

	  material.blending = THREE.NormalBlending;
	  material.premultipliedAlpha = true;
	  material.side = THREE.DoubleSide; //( material.transparent ) ? THREE.DoubleSide : THREE.FrontSide; //temporary fix for steelcase

	  var envMap = data.environment && data.environment.environmentMap;
	  if (envMap) {
	    updateTexture(envMap.specularCubeMap, 'envMap');
	    material.envMapIntensity = envMap.intensity !== undefined ? envMap.intensity : 1.0;
	  }

	  //updateTexture(data.getIn(['envMap', 'specularCubeMap']), 'envMap');
	  material.needsUpdate = true;

	  //mat.envMapIntensity = 10;
	  //mat.diffuseEnvMap = getTexture(store,  data.getIn(['envMap', 'irradianceCubeMap']));
	  //console.log( 'mat', mat );
	  //const standardMaterial =  new THREE.MeshStandardMaterial(mat);
	  ////console.log( 'standardMaterial', standardMaterial );
	  //return standardMaterial;
	  return material;
	}

	//function multiIDMaterial(store, renderer, data, previousMaterial) {
	//  const materials = reduce((list, i) => {
	//    const mat = data.material${i};
	//    if (mat) list.push(primitiveToMaterial(store, renderer, mat));
	//    return list;
	//  }, [], [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]);

	//  return new THREE.MultiMaterial(materials);
	//};

/***/ },
/* 378 */
/*!*************************************!*\
  !*** ./~/detect-browser/browser.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var detectBrowser = __webpack_require__(/*! ./lib/detectBrowser */ 379);

	module.exports = detectBrowser(navigator.userAgent);


/***/ },
/* 379 */
/*!***********************************************!*\
  !*** ./~/detect-browser/lib/detectBrowser.js ***!
  \***********************************************/
/***/ function(module, exports) {

	module.exports = function detectBrowser(userAgentString) {
	  var browsers = [
	    [ 'edge', /Edge\/([0-9\._]+)/ ],
	    [ 'yandexbrowser', /YaBrowser\/([0-9\._]+)/ ],
	    [ 'chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/ ],
	    [ 'crios', /CriOS\/([0-9\.]+)(:?\s|$)/ ],
	    [ 'firefox', /Firefox\/([0-9\.]+)(?:\s|$)/ ],
	    [ 'opera', /Opera\/([0-9\.]+)(?:\s|$)/ ],
	    [ 'opera', /OPR\/([0-9\.]+)(:?\s|$)$/ ],
	    [ 'ie', /Trident\/7\.0.*rv\:([0-9\.]+)\).*Gecko$/ ],
	    [ 'ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/ ],
	    [ 'ie', /MSIE\s(7\.0)/ ],
	    [ 'bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/ ],
	    [ 'android', /Android\s([0-9\.]+)/ ],
	    [ 'ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/ ],
	    [ 'safari', /Version\/([0-9\._]+).*Safari/ ]
	  ];

	  return browsers.map(function (rule) {
	      if (rule[1].test(userAgentString)) {
	          var match = rule[1].exec(userAgentString);
	          var version = match && match[1].split(/[._]/).slice(0,3);

	          if (version && version.length < 3) {
	              Array.prototype.push.apply(version, (version.length == 1) ? [0, 0] : [0]);
	          }

	          return {
	              name: rule[0],
	              version: version.join('.')
	          };
	      }
	  }).filter(Boolean).shift();
	};


/***/ },
/* 380 */
/*!*************************************!*\
  !*** ./src/translators/polyMesh.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	exports.polyMeshToBufferGeometry = polyMeshToBufferGeometry;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function flattenBuffer(klass, elementBuffer, numElementsPerValue, indicesBuffer) {
	  var flattenedBuffer = new klass(indicesBuffer.length * numElementsPerValue);

	  var sourceIndex, destIndex;
	  for (var v = 0; v < indicesBuffer.length; v++) {
	    sourceIndex = indicesBuffer[v] * numElementsPerValue;
	    destIndex = v * numElementsPerValue;
	    for (var e = 0; e < numElementsPerValue; e++) {
	      flattenedBuffer[destIndex + e] = elementBuffer[sourceIndex + e];
	    }
	  }

	  return new THREE.BufferAttribute(flattenedBuffer, numElementsPerValue);
	}

	function polyMeshToBufferGeometry(_ref) {
	  var faces = _ref.faces,
	      positions = _ref.positions,
	      normalMap = _ref.normalMap,
	      uvs = _ref.uvs;

	  var geom = new THREE.BufferGeometry();

	  geom.addAttribute('position', flattenBuffer(Float32Array, positions, 3, faces));

	  if (normalMap) {
	    geom.addAttribute('normal', flattenBuffer(Float32Array, normalMap.values, 3, normalMap.faces)); //normalMap.faces.length));
	  }

	  if (uvs) {
	    var uvNames = (0, _keys2.default)(uvs);
	    uvNames.sort();

	    // uv
	    if (uvNames.length >= 1) {
	      var uvMap = uvs[uvNames[0]];
	      geom.addAttribute('uv', flattenBuffer(Float32Array, uvMap.values, 2, uvMap.faces)); // uvMap.faces.length));
	    }

	    // uv2
	    if (uvNames.length >= 2) {
	      var uvMap = uvs[uvNames[1]];
	      geom.addAttribute('uv2', flattenBuffer(Float32Array, uvMap.values, 2, uvMap.faces)); //uvMap.faces.length));
	    }
	  }

	  return geom;
	}

/***/ },
/* 381 */
/*!**********************************!*\
  !*** ./src/translators/light.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createLight = createLight;
	exports.updateLight = updateLight;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var initialLightDefaults = {
	  castShadow: true,
	  color: { r: 1, g: 1, b: 1 },
	  intensity: 0.85,
	  lightType: 'DirectionalLight',
	  radius: 0,
	  shadowBias: 0,
	  shadowCameraSize: 1.7321,
	  shadowDarkness: 0.1,
	  shadowFarClip: 40,
	  shadowFrustumColor: { r: 1, g: 1, b: 1 },
	  shadowNearClip: 10,
	  shadowSize: 1024,
	  showShadowCamera: false
	};

	function createLight(data, light) {
	  var type = data.lightType;
	  // Skip AreaLight without crashing for now
	  if (type === 'AreaLight') return;
	  if (!THREE[type]) throw new Error('Unknown light type: ' + type);
	  if (type === 'HemisphereLight') {
	    return new THREE[type](data.color.getHex(), data.gndColor.getHex(), data.intensity);
	  }

	  return new THREE[type](data.color.getHex(), data.intensity);
	}

	function updateLight(data, light) {
	  light.intensity = data.intensity;
	}

/***/ },
/* 382 */
/*!**************************************!*\
  !*** ./src/translators/transform.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setMatrixOn = setMatrixOn;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var rotationFactor = 3.14 / 180;

	// Set transalation, rotation, scale on Object3D
	function setTRS(object3d, t, r, s) {
	  object3d.position.set(t.x, t.y, t.z);
	  object3d.rotation.set(r.x, r.y, r.z, 'ZYX');
	  object3d.scale.set(s.x, s.y, s.z);
	};

	function setTRSDegrees(object3d, t, r, s) {
	  object3d.position.set(t.x, t.y, t.z);
	  object3d.rotation.set(r.x * rotationFactor, r.y * rotationFactor, r.z * rotationFactor, 'ZYX');
	  object3d.scale.set(s.x, s.y, s.z);
	};

	/* Apply matrix4 to threejs node.
	 */
	function setMatrixOn(object3d, matrix4) {
	  var translation = new THREE.Vector3();
	  var rotQuat = new THREE.Quaternion();
	  var scale = new THREE.Vector3();
	  matrix4.decompose(translation, rotQuat, scale);
	  var rotation = new THREE.Vector3().copy(new THREE.Euler().setFromQuaternion(rotQuat, 'ZYX'));
	  setTRS(object3d, translation, rotation, scale);
	}

/***/ },
/* 383 */
/*!*****************************************!*\
  !*** ./src/translators/manipulators.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 135);

	var _keys2 = _interopRequireDefault(_keys);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.initManipulators = initManipulators;

	var _flyd = __webpack_require__(/*! ../../vendor/flyd */ 384);

	var _flyd2 = _interopRequireDefault(_flyd);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function mapStream(el, eventName, fn) {
	  var stream = _flyd2.default.stream();
	  el.addEventListener(eventName, stream);
	  return fn ? _flyd2.default.map(fn, stream) : stream;
	};

	function transduceStream(el, eventName, fn) {
	  var stream = _flyd2.default.stream();
	  el.addEventListener(eventName, stream);
	  return _flyd2.default.transduce(fn, stream);
	};

	function isSingleTouch(e) {
	  return e.touches && e.touches.length === 1;
	};

	function isDoubleTouch(e) {
	  return e.touches && e.touches.length === 2;
	};

	function addMomentum(toStream, endStream) {
	  var momentumStream = _flyd2.default.stream()(0);

	  var result = _flyd2.default.combine(function (to, momentum) {
	    return to.end() ? momentum() : to();
	  }, [toStream, momentumStream]);

	  var decay = 1;

	  _flyd2.default.on(function () {
	    var timer = every(1000 / 60);
	    var momentumStart = new Date();
	    var momentumDecay = 0.2;
	    if (!toStream()) {
	      return momentumStream.end(true);
	    }

	    var _toStream = toStream(),
	        deltaX = _toStream.deltaX,
	        deltaY = _toStream.deltaY;

	    _flyd2.default.map(function (i) {
	      if (decay <= 0.005) {
	        momentumStream.end(true);
	        timer.end(true);
	      } else {
	        decay = Math.exp(-(1 - momentumDecay) * 10 * (Date.now() - momentumStart) / 1000);
	        //console.log('decay: ', decay, deltaX, deltaY);
	        momentumStream({ deltaX: deltaX * decay, deltaY: deltaY * decay });
	      }
	    }, timer);
	  }, toStream.end);

	  return result;
	};

	function initManipulators(store, translator, el) {
	  var playerEl = el.parentNode.parentNode;
	  var offset = { x: 0, y: 0 };
	  var rect = { width: 0, height: 0 };
	  var commands = [];
	  var hasEvents = {};

	  var dragging = false;
	  var lastMousedown = false;

	  function resize(newRect) {
	    var playerRect = playerEl.getBoundingClientRect();
	    offset = {
	      x: playerRect.left,
	      y: playerRect.top
	    };
	    rect = newRect;
	  }

	  function touchLastMove(ev) {
	    if (dragging) dragging.lastMove = new Date();
	    return ev;
	  }

	  function callTool(which) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    return function (ev) {
	      if (!hasEvents[which]) return;

	      var command, tool, result;

	      for (var i = commands.length - 1; i >= 0; i--) {
	        command = commands[i];
	        tool = command.tool;
	        if (!command.enabled || !tool[which]) continue;

	        result = tool[which].call(command, ev);

	        if (options.findFirst) {
	          if (result !== false) break;
	        } else if (!options.doAll) {
	          if (result === false) break;
	        }
	      }

	      return result;
	    };
	  };

	  function toCoords(ev) {
	    // Calling preventDefault on 'mousedown' prevents the 'mouseup' event from firing when inside
	    // an iframe. No reason to call preventDefault on these events, so don't.

	    return {
	      rect: rect,
	      clientX: ev.clientX - offset.x,
	      clientY: ev.clientY - offset.y,
	      deltaX: ev.movementX,
	      deltaY: ev.movementY,
	      originalEvent: ev,
	      which: ev.which,
	      altKey: ev.altKey,
	      ctrlKey: ev.ctrlKey,
	      metaKey: ev.metaKey,
	      shiftKey: ev.shiftKey
	    };
	  };

	  function toMouseEvent(e) {
	    if (!e.touches || !e.touches.length) return e;
	    e.preventDefault();
	    var elRect = e.srcElement.getBoundingClientRect();
	    return {
	      which: 1,
	      rect: rect,
	      clientX: e.touches[0].clientX - elRect.left,
	      clientY: e.touches[0].clientY - elRect.top,
	      originalEvent: e
	    };
	  };

	  _flyd2.default.on(callTool('dragenter'), mapStream(el, 'dragenter'));
	  _flyd2.default.on(callTool('dragover'), mapStream(el, 'dragover'));
	  _flyd2.default.on(callTool('dragleave'), mapStream(el, 'dragleave'));
	  _flyd2.default.on(callTool('dblclick'), mapStream(el, 'dblclick'));

	  var keysdown = {};
	  _flyd2.default.on(function (kd) {
	    if (!keysdown[kd.key]) {
	      callTool('keydown')(kd);
	      keysdown[kd.key] = setInterval(function () {
	        return callTool('keyheld')(kd);
	      }, 17);
	    }
	  }, mapStream(el, 'keydown'));

	  _flyd2.default.on(function (ku) {
	    if (keysdown[ku.key]) {
	      clearInterval(keysdown[ku.key]);
	      delete keysdown[ku.key];
	    }

	    callTool('keyup')(ku);
	  }, mapStream(el, 'keyup'));

	  var clickStream = mapStream(el, 'click', toCoords);
	  var mousedownStream = mapStream(el, 'mousedown', toCoords);
	  var mousemoveStream = mapStream(el, 'mousemove', toCoords);
	  var mouseupStream = mapStream(window, 'mouseup', toCoords);
	  var moveStream = _flyd2.default.stream();
	  var dragStream = _flyd2.default.stream();

	  var touchstartStream = transduceStream(el, 'touchstart', (0, _ramda.compose)((0, _ramda.filter)(isSingleTouch), (0, _ramda.map)(toMouseEvent)));
	  var touchendStream = mapStream(el, 'touchend', toMouseEvent);

	  _flyd2.default.on(function (md) {
	    md.originalEvent.target.focus();
	    callTool('mousedown')(md);
	    lastMousedown = { start: new Date(), event: md };

	    var tool = callTool('drag', { findFirst: true })(md);
	    if (!tool) return;

	    dragging = { lastMove: new Date() };

	    var clientX = null;
	    var clientY = null;

	    function toDeltaCoords(ev) {
	      ev.preventDefault();
	      var newEv = {
	        rect: rect,
	        clientX: ev.clientX - offset.x,
	        clientY: ev.clientY - offset.y,
	        originalEvent: ev,
	        which: ev.which,
	        altKey: ev.altKey,
	        ctrlKey: ev.ctrlKey,
	        metaKey: ev.metaKey,
	        shiftKey: ev.shiftKey
	      };
	      if (ev.movementX === undefined) {
	        newEv.deltaX = clientX === null ? 0 : ev.clientX - clientX;
	        newEv.deltaY = clientX === null ? 0 : ev.clientY - clientY;
	      } else {
	        newEv.deltaX = ev.movementX;
	        newEv.deltaY = ev.movementY;
	      }
	      clientX = ev.clientX;
	      clientY = ev.clientY;
	      return newEv;
	    }

	    moveStream = transduceStream(window, 'mousemove', (0, _ramda.compose)((0, _ramda.map)(touchLastMove), (0, _ramda.map)(toDeltaCoords)));

	    dragStream.end(true);
	    dragStream = tool.momentum ? addMomentum(moveStream, mouseupStream) : moveStream;
	    dragStream.map(tool.handle);
	  }, mousedownStream);

	  _flyd2.default.on(function (ts) {
	    callTool('mousedown')(ts);
	    lastMousedown = { start: new Date(), event: ts };

	    var tool = callTool('drag', { findFirst: true })(ts);
	    if (!tool) return;

	    dragging = { lastMove: new Date() };

	    var clientX = ts.clientX,
	        clientY = ts.clientY;


	    function toDelta(e) {
	      var newE = (0, _assign2.default)(e, {
	        deltaX: e.clientX - clientX,
	        deltaY: e.clientY - clientY
	      });
	      clientX = e.clientX;
	      clientY = e.clientY;
	      return newE;
	    };

	    moveStream = transduceStream(el, 'touchmove', (0, _ramda.compose)((0, _ramda.filter)(isSingleTouch), (0, _ramda.map)(touchLastMove), (0, _ramda.map)(toMouseEvent), (0, _ramda.map)(toDelta)));

	    dragStream.end(true);
	    dragStream = tool.momentum ? addMomentum(moveStream, touchendStream) : moveStream;
	    dragStream.map(tool.handle);
	  }, touchstartStream);

	  var endingStream = _flyd2.default.merge(touchendStream, mouseupStream);

	  _flyd2.default.on(function (mu) {
	    if (dragging) {
	      moveStream.end(true);
	      // End momentum if last mousemove event is gt 200ms from mouseup.
	      if (new Date() - dragging.lastMove > 200) {
	        dragStream.end(true);
	      }
	    }

	    //console.log('mu', new Date() - lastMousedown.start, lastMousedown.event, mu, muX, muY);

	    callTool('mouseup')(mu);

	    if (lastMousedown && new Date() - lastMousedown.start < 300) {
	      var muX = Math.abs(mu.clientX - lastMousedown.event.clientX);
	      var muY = Math.abs(mu.clientY - lastMousedown.event.clientY);

	      if (isNaN(muX)) {
	        callTool('click')(lastMousedown.event);
	      } else if (muX <= 5 && muY <= 5) {
	        callTool('click')(mu);
	      }
	    }

	    dragging = false;
	    lastMousedown = false;
	  }, endingStream);

	  _flyd2.default.on(callTool('hover'), _flyd2.default.transduce((0, _ramda.filter)(function () {
	    return !dragging && hasEvents['hover'];
	  }), mousemoveStream));

	  //flyd.map((scroll) => {
	  //  console.log('scroll?', scroll);
	  var scrollHandler = callTool('scroll');
	  mapStream(el, 'wheel', function (ev) {
	    if (hasEvents['scroll']) {
	      ev.preventDefault();
	      scrollHandler({
	        delta: -ev.deltaY / (ev.wheelDelta ? 200 : 10),
	        originalEvent: ev
	      });
	    }
	  });

	  function extractTouches(e) {
	    e.preventDefault();
	    return {
	      a: { x: e.touches[0].clientX, y: e.touches[0].clientY },
	      b: { x: e.touches[1].clientX, y: e.touches[1].clientY }
	    };
	  };

	  var zoom = flatMap(function (ts) {
	    var f = ts;
	    var moveStream = transduceStream(el, 'touchmove', (0, _ramda.compose)((0, _ramda.filter)(isDoubleTouch), (0, _ramda.map)(extractTouches), (0, _ramda.map)(function (g) {
	      var result = {
	        pinchX: g.b.x - f.b.x - (g.a.x - f.a.x),
	        pinchY: f.a.y - g.a.y - (f.b.y - g.b.y),
	        dragX: (g.a.x - f.a.x + (g.b.x - f.b.x)) / 2,
	        dragY: (g.a.y - f.a.y + (g.b.y - f.b.y)) / 2,
	        a: g.a, b: g.b
	      };
	      f = g;
	      return result;
	    })));
	    _flyd2.default.endsOn(touchendStream, moveStream);
	    return moveStream;
	  }, transduceStream(el, 'touchstart', (0, _ramda.compose)((0, _ramda.filter)(isDoubleTouch), (0, _ramda.map)(extractTouches))));

	  _flyd2.default.on(function (z) {
	    var pinchX = z.pinchX,
	        pinchY = z.pinchY,
	        dragX = z.dragX,
	        dragY = z.dragY,
	        a = z.a,
	        b = z.b;

	    if (Math.abs(pinchX) + Math.abs(pinchY) > Math.abs(dragX) + Math.abs(dragY)) {
	      // pinch
	      callTool('pinch')({
	        deltaX: a.x > b.x ? -pinchX : pinchX,
	        deltaY: a.y > b.y ? pinchY : -pinchY
	      });
	    } else {
	      // swipe
	      callTool('swipe')({ deltaX: dragX, deltaY: dragY });
	    }
	  }, zoom);

	  return {
	    resize: resize,

	    updateTools: function updateTools(newCommands) {
	      commands = newCommands;
	      hasEvents = {};

	      (0, _ramda.forEach)(function (command) {
	        (0, _keys2.default)(command.tool).forEach(function (k) {
	          return hasEvents[k] = true;
	        });
	      }, commands);
	    }
	  };
	}

	function every(dur) {
	  var s = _flyd2.default.stream();
	  var target = Date.now();
	  function timer() {
	    if (s.end()) return;
	    var now = Date.now();
	    target += dur;
	    s(now);
	    setTimeout(timer, target - now);
	  }

	  timer();
	  return s;
	};

	function flatMap(f, s) {
	  return _flyd2.default.combine(function (s, own) {
	    _flyd2.default.map(own, f(s()));
	  }, [s]);
	};

/***/ },
/* 384 */
/*!************************!*\
  !*** ./vendor/flyd.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var curryN = __webpack_require__(/*! ramda */ 78).curryN;

	'use strict';

	function isFunction(obj) {
	  return !!(obj && obj.constructor && obj.call && obj.apply);
	}

	// Globals
	var toUpdate = [];
	var inStream;

	// Library functions use self callback to accept (null, undefined) update triggers.
	function map(f, s) {
	  return combine(function(s, self) { self(f(s.val)); }, [s]);
	}

	function on(f, s) {
	  return combine(function(s) { f(s.val); }, [s]);
	}

	function boundMap(f) { return map(f, this); }

	var scan = curryN(3, function(f, acc, s) {
	  var ns = combine(function(s, self) {
	    self(acc = f(acc, s.val));
	  }, [s]);
	  if (!ns.hasVal) ns(acc);
	  return ns;
	});

	var merge = curryN(2, function(s1, s2) {
	  var s = immediate(combine(function(s1, s2, self, changed) {
	    if (changed[0]) {
	      self(changed[0]());
	    } else if (s1.hasVal) {
	      self(s1.val);
	    } else if (s2.hasVal) {
	      self(s2.val);
	    }
	  }, [s1, s2]));
	  endsOn(combine(function() {
	    return true;
	  }, [s1.end, s2.end]), s);
	  return s;
	});

	function ap(s2) {
	  var s1 = this;
	  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);
	}

	function initialDepsNotMet(stream) {
	  stream.depsMet = stream.deps.every(function(s) {
	    return s.hasVal;
	  });
	  return !stream.depsMet;
	}

	function updateStream(s) {
	  if ((s.depsMet !== true && initialDepsNotMet(s)) ||
	      (s.end !== undefined && s.end.val === true)) return;
	  if (inStream !== undefined) {
	    toUpdate.push(s);
	    return;
	  }
	  inStream = s;
	  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;
	  var returnVal = s.fn.apply(s.fn, s.fnArgs);
	  if (returnVal !== undefined) {
	    s(returnVal);
	  }
	  inStream = undefined;
	  if (s.depsChanged !== undefined) s.depsChanged = [];
	  s.shouldUpdate = false;
	  if (flushing === false) flushUpdate();
	}

	var order = [];
	var orderNextIdx = -1;

	function findDeps(s) {
	  var i, listeners = s.listeners;
	  if (s.queued === false) {
	    s.queued = true;
	    for (i = 0; i < listeners.length; ++i) {
	      findDeps(listeners[i]);
	    }
	    order[++orderNextIdx] = s;
	  }
	}

	function updateDeps(s) {
	  var i, o, list, listeners = s.listeners;
	  for (i = 0; i < listeners.length; ++i) {
	    list = listeners[i];
	    if (list.end === s) {
	      endStream(list);
	    } else {
	      if (list.depsChanged !== undefined) list.depsChanged.push(s);
	      list.shouldUpdate = true;
	      findDeps(list);
	    }
	  }
	  for (; orderNextIdx >= 0; --orderNextIdx) {
	    o = order[orderNextIdx];
	    if (o.shouldUpdate === true) updateStream(o);
	    o.queued = false;
	  }
	}

	var flushing = false;

	function flushUpdate() {
	  flushing = true;
	  while (toUpdate.length > 0) {
	    var s = toUpdate.shift();
	    if (s.vals.length > 0) s.val = s.vals.shift();
	    updateDeps(s);
	  }
	  flushing = false;
	}

	function isStream(stream) {
	  return isFunction(stream) && 'hasVal' in stream;
	}

	function streamToString() {
	  return 'stream(' + this.val + ')';
	}

	function updateStreamValue(s, n) {
	  if (n !== undefined && n !== null && isFunction(n.then)) {
	    n.then(s);
	    return;
	  }
	  s.val = n;
	  s.hasVal = true;
	  if (inStream === undefined) {
	    flushing = true;
	    updateDeps(s);
	    if (toUpdate.length > 0) flushUpdate(); else flushing = false;
	  } else if (inStream === s) {
	    markListeners(s, s.listeners);
	  } else {
	    s.vals.push(n);
	    toUpdate.push(s);
	  }
	}

	function markListeners(s, lists) {
	  var i, list;
	  for (i = 0; i < lists.length; ++i) {
	    list = lists[i];
	    if (list.end !== s) {
	      if (list.depsChanged !== undefined) {
	        list.depsChanged.push(s);
	      }
	      list.shouldUpdate = true;
	    } else {
	      endStream(list);
	    }
	  }
	}

	function createStream() {
	  function s(n) {
	    return arguments.length > 0 ? (updateStreamValue(s, n), s)
	                                : s.val;
	  }
	  s.hasVal = false;
	  s.val = undefined;
	  s.vals = [];
	  s.listeners = [];
	  s.queued = false;
	  s.end = undefined;

	  s.map = boundMap;
	  s.ap = ap;
	  s.of = stream;
	  s.toString = streamToString;

	  return s;
	}

	function addListeners(deps, s) {
	  for (var i = 0; i < deps.length; ++i) {
	    deps[i].listeners.push(s);
	  }
	}

	function createDependentStream(deps, fn) {
	  var s = createStream();
	  s.fn = fn;
	  s.deps = deps;
	  s.depsMet = false;
	  s.depsChanged = deps.length > 0 ? [] : undefined;
	  s.shouldUpdate = false;
	  addListeners(deps, s);
	  return s;
	}

	function immediate(s) {
	  if (s.depsMet === false) {
	    s.depsMet = true;
	    updateStream(s);
	  }
	  return s;
	}

	function removeListener(s, listeners) {
	  var idx = listeners.indexOf(s);
	  listeners[idx] = listeners[listeners.length - 1];
	  listeners.length--;
	}

	function detachDeps(s) {
	  for (var i = 0; i < s.deps.length; ++i) {
	    removeListener(s, s.deps[i].listeners);
	  }
	  s.deps.length = 0;
	}

	function endStream(s) {
	  if (s.deps !== undefined) detachDeps(s);
	  if (s.end !== undefined) detachDeps(s.end);
	}

	function endsOn(endS, s) {
	  detachDeps(s.end);
	  endS.listeners.push(s.end);
	  s.end.deps.push(endS);
	  return s;
	}

	function trueFn() { return true; }

	function stream(initialValue) {
	  var endStream = createDependentStream([], trueFn);
	  var s = createStream();
	  s.end = endStream;
	  s.fnArgs = [];
	  endStream.listeners.push(s);
	  if (arguments.length > 0) s(initialValue);
	  return s;
	}

	function combine(fn, streams) {
	  var i, s, deps, depEndStreams;
	  var endStream = createDependentStream([], trueFn);
	  deps = []; depEndStreams = [];
	  for (i = 0; i < streams.length; ++i) {
	    if (streams[i] !== undefined) {
	      deps.push(streams[i]);
	      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);
	    }
	  }
	  s = createDependentStream(deps, fn);
	  s.depsChanged = [];
	  s.fnArgs = s.deps.concat([s, s.depsChanged]);
	  s.end = endStream;
	  endStream.listeners.push(s);
	  addListeners(depEndStreams, endStream);
	  endStream.deps = depEndStreams;
	  updateStream(s);
	  return s;
	}

	var transduce = curryN(2, function(xform, source) {
	  xform = xform(new StreamTransformer());
	  return combine(function(source, self) {
	    var res = xform['@@transducer/step'](undefined, source.val);
	    if (res && res['@@transducer/reduced'] === true) {
	      self.end(true);
	      return res['@@transducer/value'];
	    } else {
	      return res;
	    }
	  }, [source]);
	});

	function StreamTransformer() { }
	StreamTransformer.prototype['@@transducer/init'] = function() { };
	StreamTransformer.prototype['@@transducer/result'] = function() { };
	StreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };

	module.exports = {
	  stream: stream,
	  combine: curryN(2, combine),
	  isStream: isStream,
	  transduce: transduce,
	  merge: merge,
	  scan: scan,
	  endsOn: endsOn,
	  map: curryN(2, map),
	  on: curryN(2, on),
	  curryN: curryN,
	  immediate: immediate,
	};


/***/ },
/* 385 */
/*!***************************************!*\
  !*** ./src/translators/annotation.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.getScreenPositionNormalAlpha = getScreenPositionNormalAlpha;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _scene = __webpack_require__(/*! ../modules/scene */ 171);

	var _player = __webpack_require__(/*! ../modules/player */ 295);

	var _getProjectionMatrix = __webpack_require__(/*! ./utils/getProjectionMatrix */ 357);

	var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function getScreenPositionNormal(nodeWorldMatrix, cameraWorldMatrix, cameraProjection, localDirection) {

	  var cameraInverseWorldMatrix = new THREE.Matrix4().getInverse(cameraWorldMatrix);

	  var combinedCameraSpaceMatrix = new THREE.Matrix4().multiply(cameraInverseWorldMatrix).multiply(nodeWorldMatrix);
	  var combinedProjectionMatrix = new THREE.Matrix4().multiply(cameraProjection).multiply(cameraInverseWorldMatrix).multiply(nodeWorldMatrix);

	  var nodeLocalPosition = new THREE.Vector3(0, 0, 0);
	  var nodeLocalDirectionOffset = localDirection;

	  var nodeCameraPosition = nodeLocalPosition.clone().applyMatrix4(combinedCameraSpaceMatrix);
	  var nodeCameraDirectionOffset = nodeLocalDirectionOffset.clone().applyMatrix4(combinedCameraSpaceMatrix);

	  var nodeCameraNormal = new THREE.Vector3().subVectors(nodeCameraDirectionOffset, nodeCameraPosition).normalize();

	  var nodeScreenPosition = nodeLocalPosition.clone().applyMatrix4(combinedProjectionMatrix);
	  nodeScreenPosition.addScalar(1.0).multiplyScalar(0.5);

	  return {
	    position: nodeScreenPosition,
	    normal: nodeCameraNormal
	  };
	}

	function getScreenPositionNormalAlpha(id, calcDirection, directionAxis, directionTarget) {
	  return function (store) {
	    var nodeWorldTransform = (0, _scene.getWorldTransform)(store, id);
	    var cameraId = (0, _player.getCamera)(store);
	    var cameraPlug = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });

	    var cameraWorldTransform = (0, _scene.getWorldTransform)(store, cameraId);
	    if (!cameraWorldTransform) return {};

	    var cameraProjection = (0, _getProjectionMatrix2.default)(cameraPlug);
	    var positionNormal = getScreenPositionNormal(nodeWorldTransform, cameraWorldTransform, cameraProjection, getDirection(store, id, calcDirection, directionAxis, directionTarget));

	    var annotation = (0, _scene.get)(store, { id: id, evalPlug: 'Annotation' });

	    var alpha = 1.0;

	    // mis-spelled visibility property.
	    if (annotation.limitVisilibility) {
	      var visibilityAngle = Math.min(annotation.visibilityAngle * 0.5, 180);
	      var cameraWorldDirection = new THREE.Vector3(0, 0, -1);
	      var dotResult = cameraWorldDirection.dot(positionNormal.normal);

	      var theta = THREE.Math.radToDeg(Math.acos(cameraWorldDirection.dot(positionNormal.normal)));

	      if (theta > visibilityAngle) {
	        alpha = 0.0;
	      } else if (theta > visibilityAngle * 0.75) {
	        alpha = (visibilityAngle - theta) / (visibilityAngle * 0.25);
	      }
	    }

	    return (0, _assign2.default)({ alpha: alpha }, positionNormal);
	  };
	}

	function getDirection(store, id, calcDirection, directionAxis, directionTarget) {
	  var direction = null;
	  if (calcDirection) {
	    var targetPosition = new THREE.Vector3(0, 0, 0);
	    if (directionTarget) {
	      targetPosition = new THREE.Vector3().setFromMatrixPosition((0, _scene.getWorldTransform)(store, directionTarget));
	    }
	    var currentTransform = (0, _scene.getWorldTransform)(store, id);
	    var currentPosition = new THREE.Vector3().setFromMatrixPosition(currentTransform);
	    direction = targetPosition.clone().sub(currentPosition).normalize();
	    var inverseWorldMatrix = new THREE.Matrix4();
	    inverseWorldMatrix.getInverse(currentTransform);
	    direction.applyMatrix4(inverseWorldMatrix).normalize();
	  } else {
	    direction = new THREE.Vector3();
	    direction[directionAxis] = -1;
	  }

	  return direction;
	}

/***/ },
/* 386 */
/*!**********************************************!*\
  !*** ./src/translators/utils/outlinePass.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 188);

	var _create2 = _interopRequireDefault(_create);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.default = OutlinePass;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @author spidersharma / http://eduperiment.com/
	 */

	function OutlinePass(resolution, scene, camera, selectedObjects) {

		this.renderScene = scene;
		this.renderCamera = camera;
		this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];
		this.visibleEdgeColor = new THREE.Color(1, 1, 1);
		this.hiddenEdgeColor = new THREE.Color(0.1, 0.04, 0.02);
		this.edgeGlow = 0.0;
		this.usePatternTexture = false;
		this.edgeThickness = 1.0;
		this.edgeStrength = 3.0;
		this.downSampleRatio = 2;
		this.pulsePeriod = 0;

		this.BlurDirectionX = new THREE.Vector2(1.0, 0.0);
		this.BlurDirectionY = new THREE.Vector2(0.0, 1.0);

		THREE.Pass.call(this);

		this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);

		var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

		var resx = Math.round(this.resolution.x / this.downSampleRatio);
		var resy = Math.round(this.resolution.y / this.downSampleRatio);

		this.maskBufferMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
		this.maskBufferMaterial.side = THREE.DoubleSide;
		this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);
		this.renderTargetMaskBuffer.texture.generateMipmaps = false;

		this.depthMaterial = new THREE.MeshDepthMaterial();
		this.depthMaterial.side = THREE.DoubleSide;
		this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
		this.depthMaterial.blending = THREE.NoBlending;

		this.prepareMaskMaterial = this.getPrepareMaskMaterial();
		this.prepareMaskMaterial.side = THREE.DoubleSide;

		this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);
		this.renderTargetDepthBuffer.texture.generateMipmaps = false;

		this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(resx, resy, pars);
		this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;

		this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);
		this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
		this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
		this.renderTargetBlurBuffer2.texture.generateMipmaps = false;

		this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
		this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);
		this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
		this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
		this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;

		var MAX_EDGE_THICKNESS = 4;
		var MAX_EDGE_GLOW = 4;

		this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);
		this.separableBlurMaterial1.uniforms["texSize"].value = new THREE.Vector2(resx, resy);
		this.separableBlurMaterial1.uniforms["kernelRadius"].value = 1;
		this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);
		this.separableBlurMaterial2.uniforms["texSize"].value = new THREE.Vector2(Math.round(resx / 2), Math.round(resy / 2));
		this.separableBlurMaterial2.uniforms["kernelRadius"].value = MAX_EDGE_GLOW;

		// Overlay material
		this.overlayMaterial = this.getOverlayMaterial();

		// copy material
		if (THREE.CopyShader === undefined) console.error("THREE.OutlinePass relies on THREE.CopyShader");

		var copyShader = THREE.CopyShader;

		this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);
		this.copyUniforms["opacity"].value = 1.0;

		this.materialCopy = new THREE.ShaderMaterial({
			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: THREE.NoBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		});

		this.enabled = true;
		this.needsSwap = false;

		this.oldClearColor = new THREE.Color();
		this.oldClearAlpha = 1;

		this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
		this.scene = new THREE.Scene();

		this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
		this.scene.add(this.quad);

		this.tempPulseColor1 = new THREE.Color();
		this.tempPulseColor2 = new THREE.Color();
		this.textureMatrix = new THREE.Matrix4();
	};

	OutlinePass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

		constructor: OutlinePass,

		dispose: function dispose() {
			this.renderTargetMaskBuffer.dispose();
			this.renderTargetDepthBuffer.dispose();
			this.renderTargetMaskDownSampleBuffer.dispose();
			this.renderTargetBlurBuffer1.dispose();
			this.renderTargetBlurBuffer2.dispose();
			this.renderTargetEdgeBuffer1.dispose();
			this.renderTargetEdgeBuffer2.dispose();
		},

		setSize: function setSize(width, height) {

			this.renderTargetMaskBuffer.setSize(width, height);

			var resx = Math.round(width / this.downSampleRatio);
			var resy = Math.round(height / this.downSampleRatio);
			this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);
			this.renderTargetBlurBuffer1.setSize(resx, resy);
			this.renderTargetEdgeBuffer1.setSize(resx, resy);
			this.separableBlurMaterial1.uniforms["texSize"].value = new THREE.Vector2(resx, resy);

			resx = Math.round(resx / 2);
			resy = Math.round(resy / 2);

			this.renderTargetBlurBuffer2.setSize(resx, resy);
			this.renderTargetEdgeBuffer2.setSize(resx, resy);

			this.separableBlurMaterial2.uniforms["texSize"].value = new THREE.Vector2(resx, resy);
		},

		changeVisibilityOfSelectedObjects: function changeVisibilityOfSelectedObjects(bVisible) {

			var gatherSelectedMeshesCallBack = function gatherSelectedMeshesCallBack(object) {

				if (object instanceof THREE.Mesh) {
					var visibility = object.visible;
					if (!bVisible || object.bVisible) object.visible = bVisible;
					object.bVisible = visibility;
				}
			};

			for (var i = 0; i < this.selectedObjects.length; i++) {

				var selectedObject = this.selectedObjects[i];

				selectedObject.traverse(gatherSelectedMeshesCallBack);
			}
		},

		changeVisibilityOfNonSelectedObjects: function changeVisibilityOfNonSelectedObjects(bVisible) {

			var selectedMeshes = [];

			var gatherSelectedMeshesCallBack = function gatherSelectedMeshesCallBack(object) {

				if (object instanceof THREE.Mesh) {

					selectedMeshes.push(object);
				}
			};

			for (var i = 0; i < this.selectedObjects.length; i++) {

				var selectedObject = this.selectedObjects[i];

				selectedObject.traverse(gatherSelectedMeshesCallBack);
			}

			var VisibilityChangeCallBack = function VisibilityChangeCallBack(object) {

				if (object instanceof THREE.Mesh) {

					var bFound = false;

					for (var i = 0; i < selectedMeshes.length; i++) {

						var selectedObjectId = selectedMeshes[i].id;

						if (selectedObjectId === object.id) {
							bFound = true;
							break;
						}
					}
					if (!bFound) {
						var visibility = object.visible;
						if (!bVisible || object.bVisible) object.visible = bVisible;
						object.bVisible = visibility;
					}
				}
			};
			this.renderScene.traverse(VisibilityChangeCallBack);
		},

		updateTextureMatrix: function updateTextureMatrix() {

			this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
			this.textureMatrix.multiply(this.renderCamera.projectionMatrix);
			this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
		},

		render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

			if (this.selectedObjects.length === 0) return;

			this.oldClearColor.copy(renderer.getClearColor());
			this.oldClearAlpha = renderer.getClearAlpha();
			var oldAutoClear = renderer.autoClear;

			renderer.autoClear = false;

			if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);

			renderer.setClearColor(0xffffff, 1);

			// Make selected objects invisible
			this.changeVisibilityOfSelectedObjects(false);

			// 1. Draw Non Selected objects in the depth buffer
			this.renderScene.overrideMaterial = this.depthMaterial;
			renderer.render(this.renderScene, this.renderCamera, this.renderTargetDepthBuffer, true);

			// Make selected objects visible
			this.changeVisibilityOfSelectedObjects(true);

			// Update Texture Matrix for Depth compare
			this.updateTextureMatrix();

			// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
			this.changeVisibilityOfNonSelectedObjects(false);
			this.renderScene.overrideMaterial = this.prepareMaskMaterial;
			this.prepareMaskMaterial.uniforms["cameraNearFar"].value = new THREE.Vector2(this.renderCamera.near, this.renderCamera.far);
			this.prepareMaskMaterial.uniforms["depthTexture"].value = this.renderTargetDepthBuffer.texture;
			this.prepareMaskMaterial.uniforms["textureMatrix"].value = this.textureMatrix;
			renderer.render(this.renderScene, this.renderCamera, this.renderTargetMaskBuffer, true);
			this.renderScene.overrideMaterial = null;
			this.changeVisibilityOfNonSelectedObjects(true);

			// 2. Downsample to Half resolution
			this.quad.material = this.materialCopy;
			this.copyUniforms["tDiffuse"].value = this.renderTargetMaskBuffer.texture;
			renderer.render(this.scene, this.camera, this.renderTargetMaskDownSampleBuffer, true);

			this.tempPulseColor1.copy(this.visibleEdgeColor);
			this.tempPulseColor2.copy(this.hiddenEdgeColor);
			if (this.pulsePeriod > 0) {
				var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;
				this.tempPulseColor1.multiplyScalar(scalar);
				this.tempPulseColor2.multiplyScalar(scalar);
			}

			// 3. Apply Edge Detection Pass
			this.quad.material = this.edgeDetectionMaterial;
			this.edgeDetectionMaterial.uniforms["maskTexture"].value = this.renderTargetMaskDownSampleBuffer.texture;
			this.edgeDetectionMaterial.uniforms["texSize"].value = new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
			this.edgeDetectionMaterial.uniforms["visibleEdgeColor"].value = this.tempPulseColor1;
			this.edgeDetectionMaterial.uniforms["hiddenEdgeColor"].value = this.tempPulseColor2;
			renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, true);

			// 4. Apply Blur on Half res
			this.quad.material = this.separableBlurMaterial1;
			this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial1.uniforms["direction"].value = this.BlurDirectionX;
			this.separableBlurMaterial1.uniforms["kernelRadius"].value = this.edgeThickness;
			renderer.render(this.scene, this.camera, this.renderTargetBlurBuffer1, true);
			this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetBlurBuffer1.texture;
			this.separableBlurMaterial1.uniforms["direction"].value = this.BlurDirectionY;
			//renderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer1, false );

			// Apply Blur on quarter res
			this.quad.material = this.separableBlurMaterial2;
			this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial2.uniforms["direction"].value = this.BlurDirectionX;
			renderer.render(this.scene, this.camera, this.renderTargetBlurBuffer2, true);
			this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetBlurBuffer2.texture;
			this.separableBlurMaterial2.uniforms["direction"].value = this.BlurDirectionY;
			renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer2, true);

			// Blend it additively over the input texture
			this.quad.material = this.overlayMaterial;
			this.overlayMaterial.uniforms["maskTexture"].value = this.renderTargetMaskBuffer.texture;
			this.overlayMaterial.uniforms["edgeTexture1"].value = this.renderTargetEdgeBuffer1.texture;
			this.overlayMaterial.uniforms["edgeTexture2"].value = this.renderTargetEdgeBuffer2.texture;
			this.overlayMaterial.uniforms["patternTexture"].value = this.patternTexture;
			this.overlayMaterial.uniforms["edgeStrength"].value = this.edgeStrength;
			this.overlayMaterial.uniforms["edgeGlow"].value = this.edgeGlow;
			this.overlayMaterial.uniforms["usePatternTexture"].value = this.usePatternTexture;

			if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);

			renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, false);

			renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
			renderer.autoClear = oldAutoClear;
		},

		getPrepareMaskMaterial: function getPrepareMaskMaterial() {

			return new THREE.ShaderMaterial({

				uniforms: {
					"depthTexture": { value: null },
					"cameraNearFar": { value: new THREE.Vector2(0.5, 0.5) },
					"textureMatrix": { value: new THREE.Matrix4() }
				},

				vertexShader: "varying vec2 vUv;\
					varying vec4 projTexCoord;\
					varying vec4 vPosition;\
					uniform mat4 textureMatrix;\
					void main() {\
						vUv = uv;\
						vPosition = modelViewMatrix * vec4( position, 1.0 );\
						vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\
						projTexCoord = textureMatrix * worldPosition;\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader: "#include <packing>\
					varying vec2 vUv;\
					varying vec4 vPosition;\
					varying vec4 projTexCoord;\
					uniform sampler2D depthTexture;\
					uniform vec2 cameraNearFar;\
					\
					void main() {\
						float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\
						float viewZ = -perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );\
						float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\
						gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\
					}"
			});
		},

		getEdgeDetectionMaterial: function getEdgeDetectionMaterial() {

			return new THREE.ShaderMaterial({

				uniforms: {
					"maskTexture": { value: null },
					"texSize": { value: new THREE.Vector2(0.5, 0.5) },
					"visibleEdgeColor": { value: new THREE.Vector3(1.0, 1.0, 1.0) },
					"hiddenEdgeColor": { value: new THREE.Vector3(1.0, 1.0, 1.0) }
				},

				vertexShader: "varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader: "varying vec2 vUv;\
					uniform sampler2D maskTexture;\
					uniform vec2 texSize;\
					uniform vec3 visibleEdgeColor;\
					uniform vec3 hiddenEdgeColor;\
					\
					void main() {\n\
						vec2 invSize = 1.0 / texSize;\
						vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\
						vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\
						vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\
						vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\
						vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\
						float diff1 = (c1.r - c2.r)*0.5;\
						float diff2 = (c3.r - c4.r)*0.5;\
						float d = length( vec2(diff1, diff2) );\
						float a1 = min(c1.g, c2.g);\
						float a2 = min(c3.g, c4.g);\
						float visibilityFactor = min(a1, a2);\
						vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\
						gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\
					}"
			});
		},

		getSeperableBlurMaterial: function getSeperableBlurMaterial(maxRadius) {

			return new THREE.ShaderMaterial({

				defines: {
					"MAX_RADIUS": maxRadius
				},

				uniforms: {
					"colorTexture": { value: null },
					"texSize": { value: new THREE.Vector2(0.5, 0.5) },
					"direction": { value: new THREE.Vector2(0.5, 0.5) },
					"kernelRadius": { value: 1.0 }
				},

				vertexShader: "varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader: "#include <common>\
					varying vec2 vUv;\
					uniform sampler2D colorTexture;\
					uniform vec2 texSize;\
					uniform vec2 direction;\
					uniform float kernelRadius;\
					\
					float gaussianPdf2(in float x, in float sigma) {\
						return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
					}\
					void main() {\
						vec2 invSize = 1.0 / texSize;\
						float weightSum = gaussianPdf2(0.0, kernelRadius);\
						vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
						vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\
						vec2 uvOffset = delta;\
						for( int i = 1; i <= MAX_RADIUS; i ++ ) {\
							float w = gaussianPdf2(uvOffset.x, kernelRadius);\
							vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
							vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
							diffuseSum += ((sample1 + sample2) * w);\
							weightSum += (2.0 * w);\
							uvOffset += delta;\
						}\
						gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\
					}"
			});
		},

		getOverlayMaterial: function getOverlayMaterial() {

			return new THREE.ShaderMaterial({

				uniforms: {
					"maskTexture": { value: null },
					"edgeTexture1": { value: null },
					"edgeTexture2": { value: null },
					"patternTexture": { value: null },
					"edgeStrength": { value: 1.0 },
					"edgeGlow": { value: 1.0 },
					"usePatternTexture": { value: 0.0 }
				},

				vertexShader: "varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",

				fragmentShader: "varying vec2 vUv;\
					uniform sampler2D maskTexture;\
					uniform sampler2D edgeTexture1;\
					uniform sampler2D edgeTexture2;\
					uniform sampler2D patternTexture;\
					uniform float edgeStrength;\
					uniform float edgeGlow;\
					uniform bool usePatternTexture;\
					\
					void main() {\
						vec4 edgeValue1 = texture2D(edgeTexture1, vUv);\
						vec4 edgeValue2 = texture2D(edgeTexture2, vUv);\
						vec4 maskColor = texture2D(maskTexture, vUv);\
						vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\
						float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\
						vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\
						vec4 finalColor = edgeStrength * maskColor.r * edgeValue;\
						if(usePatternTexture)\
							finalColor += visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\
						gl_FragColor = finalColor;\
					}",

				blending: THREE.AdditiveBlending,
				depthTest: false,
				depthWrite: false,
				transparent: true
			});
		}

	});

/***/ },
/* 387 */
/*!*********************************************!*\
  !*** ./src/translators/utils/FXAAShader.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author davidedc / http://www.sketchpatch.net/
	 *
	 * NVIDIA FXAA by Timothy Lottes
	 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
	 * - WebGL port by @supereggbert
	 * http://www.glge.org/demos/fxaa/
	 */

	var FXAAShader = {

		uniforms: {

			"tDiffuse": { value: null },
			"resolution": { value: new THREE.Vector2(1 / 1024, 1 / 512) }

		},

		vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

		fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "#define FXAA_REDUCE_MIN   (1.0/128.0)", "#define FXAA_REDUCE_MUL   (1.0/8.0)", "#define FXAA_SPAN_MAX     8.0", "void main() {", "vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;", "vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;", "vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );", "vec3 rgbM  = rgbaM.xyz;", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float lumaNW = dot( rgbNW, luma );", "float lumaNE = dot( rgbNE, luma );", "float lumaSW = dot( rgbSW, luma );", "float lumaSE = dot( rgbSE, luma );", "float lumaM  = dot( rgbM,  luma );", "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );", "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );", "vec2 dir;", "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));", "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));", "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );", "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );", "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),", "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),", "dir * rcpDirMin)) * resolution;", "vec4 rgbA = (1.0/2.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));", "vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));", "float lumaB = dot(rgbB, vec4(luma, 0.0));", "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {", "gl_FragColor = rgbA;", "} else {", "gl_FragColor = rgbB;", "}", "}"].join("\n")

	};

	exports.default = FXAAShader;

/***/ },
/* 388 */
/*!********************************************************!*\
  !*** ./src/translators/utils/parallaxBarrierEffect.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ParallaxBarrierEffect;

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author marklundin / http://mark-lundin.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function ParallaxBarrierEffect(renderer) {

	  var _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

	  var _scene = new THREE.Scene();

	  var _stereo = new THREE.StereoCamera();

	  var _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };

	  var _renderTargetL = new THREE.WebGLRenderTarget(512, 512, _params);
	  var _renderTargetR = new THREE.WebGLRenderTarget(512, 512, _params);

	  var _material = new THREE.ShaderMaterial({

	    uniforms: {

	      'mapLeft': { value: _renderTargetL.texture },
	      'mapRight': { value: _renderTargetR.texture },
	      'resolution': { value: new THREE.Vector2(512, 512) }

	    },

	    vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = vec2( uv.x, uv.y );', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),

	    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', ' vec2 uv = vUv;', ' if ( ( mod( gl_FragCoord.x + 1.0, 2.0 ) ) > 1.00 ) {', '   gl_FragColor = texture2D( mapLeft, uv );', ' } else {', '   gl_FragColor = texture2D( mapRight, uv - vec2( resolution.x, 0 ) );', ' }', '}'].join('\n')

	  });

	  var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _material);
	  _scene.add(mesh);

	  this.setSize = function (width, height) {

	    renderer.setSize(width, height);

	    var pixelRatio = renderer.getPixelRatio();

	    _material.uniforms['resolution'].value.set(1.0 / width, 1.0 / height);

	    _renderTargetL.setSize(width * pixelRatio / 2 + 1, height * pixelRatio);
	    _renderTargetR.setSize(width * pixelRatio / 2 + 1, height * pixelRatio);
	  };

	  this.render = function (scene, camera) {

	    scene.updateMatrixWorld();

	    if (camera.parent === null) camera.updateMatrixWorld();

	    _stereo.update(camera);

	    renderer.render(scene, _stereo.cameraL, _renderTargetL, true);
	    renderer.render(scene, _stereo.cameraR, _renderTargetR, true);
	    renderer.render(_scene, _camera);
	  };
	};

/***/ },
/* 389 */
/*!***************************!*\
  !*** ./src/autoRotate.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.startAutoRotate = startAutoRotate;
	exports.stopAutoRotate = stopAutoRotate;
	exports.autoRotateTool = autoRotateTool;

	var _scene = __webpack_require__(/*! ./modules/scene */ 171);

	var _animation = __webpack_require__(/*! ./modules/animation */ 134);

	function startAutoRotate(store) {
	  var player = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var id = player && player.autoRotateNode;

	  if (!player || !player.autoRotate || !id) return false;

	  var increment = player.autoRotateDirection === '+' ? 360 : -360;
	  var path = (0, _scene.find)(store, { id: id, plug: 'Transform', property: 'rotation' });
	  var rotation = (0, _scene.get)(store, { id: id, plug: 'Transform', property: 'rotation' });

	  if (path && rotation) {
	    store.dispatch((0, _animation.queueAnimation)({
	      name: 'autoRotate',
	      autoplay: true,
	      iterations: Infinity,
	      easingDuration: 3000,
	      tracks: [{
	        path: path,
	        start: 0,
	        duration: player.autoRotateSpeed * 1000,
	        value: { x: rotation.x, y: rotation.y + increment, z: rotation.z }
	      }]
	    }));
	  }
	};

	function stopAutoRotate(store) {
	  store.dispatch((0, _animation.removeAnimation)('autoRotate'));
	};

	function autoRotateTool(store) {
	  var startingTimeout = void 0;

	  var tool = {
	    start: function start() {
	      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5000;

	      startingTimeout = setTimeout(function () {
	        startAutoRotate(store);
	      }, timeout);
	    },

	    stop: function stop() {
	      stopAutoRotate(store);
	      clearTimeout(startingTimeout);
	    },

	    mousedown: function mousedown() {
	      return tool.stop();
	    },
	    mouseup: function mouseup() {
	      return tool.start();
	    }
	  };

	  return {
	    enabled: true,
	    tool: tool
	  };
	};

/***/ },
/* 390 */
/*!***********************!*\
  !*** ./src/player.js ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ 2);

	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	var _three = __webpack_require__(/*! three */ 64);

	var THREE = _interopRequireWildcard(_three);

	var _rollbarBrowser = __webpack_require__(/*! rollbar-browser */ 66);

	var _rollbarBrowser2 = _interopRequireDefault(_rollbarBrowser);

	var _immutable = __webpack_require__(/*! immutable */ 67);

	var _immutable2 = _interopRequireDefault(_immutable);

	__webpack_require__(/*! jspolyfill-array.prototype.find */ 391);

	__webpack_require__(/*! es6-promise/auto */ 392);

	var _snabbdom = __webpack_require__(/*! snabbdom */ 68);

	var _snabbdom2 = _interopRequireDefault(_snabbdom);

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	var _class = __webpack_require__(/*! snabbdom/modules/class */ 72);

	var _class2 = _interopRequireDefault(_class);

	var _props = __webpack_require__(/*! snabbdom/modules/props */ 73);

	var _props2 = _interopRequireDefault(_props);

	var _attributes = __webpack_require__(/*! snabbdom/modules/attributes */ 74);

	var _attributes2 = _interopRequireDefault(_attributes);

	var _style = __webpack_require__(/*! snabbdom/modules/style */ 75);

	var _style2 = _interopRequireDefault(_style);

	var _eventlisteners = __webpack_require__(/*! snabbdom/modules/eventlisteners */ 76);

	var _eventlisteners2 = _interopRequireDefault(_eventlisteners);

	var _eventEmitter = __webpack_require__(/*! ./utils/eventEmitter */ 77);

	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

	var _ramda = __webpack_require__(/*! ramda */ 78);

	var _ramda2 = _interopRequireDefault(_ramda);

	var _api = __webpack_require__(/*! ./store/api */ 79);

	var _api2 = _interopRequireDefault(_api);

	var _clientMiddleware = __webpack_require__(/*! ./store/clientMiddleware */ 110);

	var _clientMiddleware2 = _interopRequireDefault(_clientMiddleware);

	var _animation = __webpack_require__(/*! ./modules/animation */ 134);

	var _animation2 = _interopRequireDefault(_animation);

	var _annotations = __webpack_require__(/*! ./modules/annotations */ 294);

	var _annotations2 = _interopRequireDefault(_annotations);

	var _sceneGraph = __webpack_require__(/*! ./modules/sceneGraph */ 144);

	var _sceneGraph2 = _interopRequireDefault(_sceneGraph);

	var _sceneIO = __webpack_require__(/*! ./modules/sceneIO */ 283);

	var _sceneIO2 = _interopRequireDefault(_sceneIO);

	var _assets = __webpack_require__(/*! ./modules/assets */ 168);

	var _assets2 = _interopRequireDefault(_assets);

	var _player = __webpack_require__(/*! ./modules/player */ 295);

	var _player2 = _interopRequireDefault(_player);

	var _scene = __webpack_require__(/*! ./modules/scene */ 171);

	var _scene2 = _interopRequireDefault(_scene);

	var _plugins = __webpack_require__(/*! ./modules/plugins */ 310);

	var _plugins2 = _interopRequireDefault(_plugins);

	var _configuration = __webpack_require__(/*! ./modules/configuration */ 311);

	var _configuration2 = _interopRequireDefault(_configuration);

	var _selection = __webpack_require__(/*! ./modules/selection */ 312);

	var _selection2 = _interopRequireDefault(_selection);

	var _commands = __webpack_require__(/*! ./modules/commands */ 305);

	var _commands2 = _interopRequireDefault(_commands);

	var _operators = __webpack_require__(/*! ./operators */ 313);

	var _operators2 = _interopRequireDefault(_operators);

	var _primitives = __webpack_require__(/*! ./operators/primitives */ 328);

	var _primitives2 = _interopRequireDefault(_primitives);

	var _store = __webpack_require__(/*! ./store */ 329);

	var _store2 = _interopRequireDefault(_store);

	var _bindActionCreatorsAndSelectors = __webpack_require__(/*! ./store/bindActionCreatorsAndSelectors */ 332);

	var _bindActionCreatorsAndSelectors2 = _interopRequireDefault(_bindActionCreatorsAndSelectors);

	var _player3 = __webpack_require__(/*! ./components/player */ 395);

	var _player4 = _interopRequireDefault(_player3);

	var _tools = __webpack_require__(/*! ./translators/tools */ 355);

	var _tools2 = _interopRequireDefault(_tools);

	var _three2 = __webpack_require__(/*! ./translators/three */ 375);

	var _three3 = _interopRequireDefault(_three2);

	var _autoRotate = __webpack_require__(/*! ./autoRotate */ 389);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// attaches event listeners
	// makes it easy to toggle classes
	var mapObjIndexed = _ramda2.default.mapObjIndexed; // handles styling on elements with support for animations
	// for setting properties on DOM elements

	// import createLogger from 'redux-logger';

	if (true) {
	  window.WebVRConfig.CARDBOARD_UI_DISABLED = true;
	  window.WebVRConfig.ROTATE_INSTRUCTIONS_DISABLED = true;
	  window.WebVRConfig.BUFFER_SCALE = 1.0;
	}

	var reducers = {
	  animation: _animation2.default.reducer,
	  annotations: _annotations2.default.reducer,
	  assets: _assets2.default.reducer,
	  commands: _commands2.default.reducer,
	  sceneGraph: _sceneGraph2.default.reducer(_operators2.default),
	  sceneIO: _sceneIO2.default.reducer,
	  player: _player2.default.reducer,
	  plugins: _plugins2.default.reducer,
	  selection: _selection2.default.reducer
	};

	var patch = _snabbdom2.default.init([_class2.default, _props2.default, _attributes2.default, _style2.default, _eventlisteners2.default]);

	// const middleware = [logger()];
	// const loggerMiddleware = createLogger({
	//   timestamp: true, duration: true, transformer: (state) => state.toJS()
	// });
	var middleware = [_clientMiddleware2.default];
	// if (false) middleware.push(loggerMiddleware);

	var deps = {
	  immutable: _immutable2.default,
	  patch: patch,
	  h: _h2.default,
	  ramda: _ramda2.default,
	  THREE: THREE
	};

	/**
	 * The main function. This function initializes the player for a given DOM Node.
	 *
	 * @param {(String|DOMNode)} elOrId - the DOM Node or String id of a DOM Node.
	 * @param {Object} options
	 * @param {Function} options.callback - an optional initialization function that will be called (with api as argument) before the first render.
	 * @returns {API} The clara playera API.
	 * @public
	 */
	function claraplayer(elOrId, opts) {
	  var initializationFn = void 0;
	  var options = void 0;
	  if (typeof opts === 'function') {
	    initializationFn = opts;
	    options = {};
	    console.warn('DEPRECATED: second argument to `claraplayer` should be an options object');
	  } else {
	    options = opts || {};
	    initializationFn = options.callback;
	  }

	  var Rollbar = ("74f3517e176d41cfa5e9c41f446b5531") && _rollbarBrowser2.default.init({
	    accessToken: ("74f3517e176d41cfa5e9c41f446b5531"),
	    verbose: false,
	    captureUncaught: !options.devMode,
	    payload: {
	      environment: ("freevination"),
	      context: 'playerv2'
	    }
	  });

	  var parentEl = typeof elOrId === 'string' ? document.getElementById(elOrId) : elOrId;
	  parentEl.appendChild(document.createElement('div'));
	  var rect = parentEl.getBoundingClientRect();
	  if (!rect.height) {
	    throw new Error('Player element must have a height');
	  }

	  var store = (0, _store2.default)(reducers, _operators2.default, _primitives2.default, middleware);
	  if (Rollbar) store.useRollbar(Rollbar);
	  var dispatch = store.dispatch.bind(store);
	  var translator = (0, _three3.default)(store);
	  store.setTranslator(translator);
	  store.setApi(_api2.default);

	  var actions = (0, _bindActionCreatorsAndSelectors2.default)(store, {
	    animation: _animation2.default, annotations: _annotations2.default, assets: _assets2.default, commands: _commands2.default, configuration: _configuration2.default, scene: _scene2.default, sceneIO: _sceneIO2.default, sceneGraph: _sceneGraph2.default, player: _player2.default, plugins: _plugins2.default, selection: _selection2.default
	  });

	  var api = (0, _assign2.default)({}, (0, _eventEmitter2.default)(), {
	    deps: deps,
	    three: {
	      scene: translator.scene,
	      camera: translator.camera
	    },
	    _store: store
	  }, actions);
	  api.version = ("2.2.27");

	  if (initializationFn) initializationFn(api);

	  var el = parentEl.children[0];
	  var parentStyle = window.getComputedStyle(parentEl, null);
	  var isFlex = parentStyle.display === 'flex';
	  var isRelative = parentStyle.position === 'relative';
	  var vnode = patch(el, (0, _player4.default)(store, { isFlex: isFlex, isRelative: isRelative, parentEl: parentEl }));

	  store.subscribe(function (events) {
	    //try {
	    vnode = patch(vnode, (0, _player4.default)(store, { isFlex: isFlex, isRelative: isRelative, parentEl: parentEl }));
	    if (events.length) events.forEach(function (e) {
	      api.emit.apply(api, [e.type].concat((0, _toConsumableArray3.default)(e.args)));
	    });
	    api.emit('change');
	    //} catch (e) {
	    //  store.error(e);
	    //}
	  });

	  dispatch((0, _plugins.setApi)(api));

	  mapObjIndexed(function (tool, toolName) {
	    dispatch((0, _commands.addCommand)(typeof tool === 'function' ? tool(store, translator) : tool, toolName));
	  }, _tools2.default);

	  var autoRotateToolObj = (0, _autoRotate.autoRotateTool)(store);
	  dispatch((0, _commands.addCommand)(autoRotateToolObj, 'autoRotate'));

	  api.on('loaded', function () {
	    // TODO: zoom camera
	    autoRotateToolObj.tool.start(1000);
	  });

	  return api;
	};

	claraplayer.deps = deps;

	claraplayer.hasWebGL = function () {
	  var canvas = document.createElement('canvas');
	  return !!canvas.getContext('webgl') || !!canvas.getContext('experimental-webgl');
	};

	module.exports = claraplayer;

/***/ },
/* 391 */
/*!***************************************************!*\
  !*** ./~/jspolyfill-array.prototype.find/find.js ***!
  \***************************************************/
/***/ function(module, exports) {

	'use strict';

	Array.prototype.find = Array.prototype.find || function(callback) {
	  if (this === null) {
	    throw new TypeError('Array.prototype.find called on null or undefined');
	  } else if (typeof callback !== 'function') {
	    throw new TypeError('callback must be a function');
	  }
	  var list = Object(this);
	  // Makes sures is always has an positive integer as length.
	  var length = list.length >>> 0;
	  var thisArg = arguments[1];
	  for (var i = 0; i < length; i++) {
	    var element = list[i];
	    if ( callback.call(thisArg, element, i, list) ) {
	      return element;
	    }
	  }
	};


/***/ },
/* 392 */
/*!*******************************!*\
  !*** ./~/es6-promise/auto.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	// This file can be required in Browserify and Node.js for automatic polyfill
	// To use it:  require('es6-promise/auto');
	'use strict';
	module.exports = __webpack_require__(/*! ./ */ 393).polyfill();


/***/ },
/* 393 */
/*!*******************************************!*\
  !*** ./~/es6-promise/dist/es6-promise.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */

	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';

	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}

	function isFunction(x) {
	  return typeof x === 'function';
	}

	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}

	var isArray = _isArray;

	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;

	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};

	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}

	function setAsap(asapFn) {
	  asap = asapFn;
	}

	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}

	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }

	  return useSetTimeout();
	}

	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });

	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}

	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}

	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}

	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];

	    callback(arg);

	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }

	  len = 0;
	}

	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(/*! vertx */ 394);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}

	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}

	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;

	  var parent = this;

	  var child = new this.constructor(noop);

	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }

	  var _state = parent._state;

	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }

	  return child;
	}

	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.resolve(1);

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }

	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}

	var PROMISE_ID = Math.random().toString(36).substring(16);

	function noop() {}

	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;

	var GET_THEN_ERROR = new ErrorObject();

	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}

	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}

	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}

	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}

	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;

	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));

	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}

	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}

	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}

	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}

	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }

	  publish(promise);
	}

	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }

	  promise._result = value;
	  promise._state = FULFILLED;

	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}

	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;

	  asap(publishRejection, promise);
	}

	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;

	  parent._onerror = null;

	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;

	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}

	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;

	  if (subscribers.length === 0) {
	    return;
	  }

	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;

	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];

	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }

	  promise._subscribers.length = 0;
	}

	function ErrorObject() {
	  this.error = null;
	}

	var TRY_CATCH_ERROR = new ErrorObject();

	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}

	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;

	  if (hasCallback) {
	    value = tryCatch(callback, detail);

	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }

	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }

	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}

	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}

	var id = 0;
	function nextId() {
	  return id++;
	}

	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}

	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);

	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }

	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;

	    this._result = new Array(this.length);

	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}

	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};

	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;

	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};

	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;

	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);

	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};

	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;

	  if (promise._state === PENDING) {
	    this._remaining--;

	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }

	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};

	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;

	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};

	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```

	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```

	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}

	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.

	  Example:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```

	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```

	  An example real-world use case is implementing timeouts:

	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```

	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}

	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}

	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}

	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}

	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.

	  Terminology
	  -----------

	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.

	  A promise can be in one of three states: pending, fulfilled, or rejected.

	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.

	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.


	  Basic Usage:
	  ------------

	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);

	    // on failure
	    reject(reason);
	  });

	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Advanced Usage:
	  ---------------

	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.

	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();

	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();

	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }

	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Unlike callbacks, promises are great composable primitives.

	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON

	    return values;
	  });
	  ```

	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];

	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}

	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;

	Promise.prototype = {
	  constructor: Promise,

	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.

	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```

	    Chaining
	    --------

	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.

	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });

	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```

	    Assimilation
	    ------------

	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.

	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```

	    If the assimliated promise rejects, then the downstream promise will also reject.

	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```

	    Simple Example
	    --------------

	    Synchronous Example

	    ```javascript
	    let result;

	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```

	    Errback Example

	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```

	    Promise Example;

	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```

	    Advanced Example
	    --------------

	    Synchronous Example

	    ```javascript
	    let author, books;

	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```

	    Errback Example

	    ```js

	    function foundBooks(books) {

	    }

	    function failure(reason) {

	    }

	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```

	    Promise Example;

	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```

	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,

	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.

	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }

	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }

	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```

	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};

	function polyfill() {
	    var local = undefined;

	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }

	    var P = local.Promise;

	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }

	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }

	    local.Promise = Promise;
	}

	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;

	return Promise;

	})));
	//# sourceMappingURL=es6-promise.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/process/browser.js */ 107), (function() { return this; }())))

/***/ },
/* 394 */
/*!***********************!*\
  !*** vertx (ignored) ***!
  \***********************/
109,
/* 395 */
/*!**********************************!*\
  !*** ./src/components/player.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);

	var _assign2 = _interopRequireDefault(_assign);

	exports.default = player;

	var _h = __webpack_require__(/*! snabbdom/h */ 71);

	var _h2 = _interopRequireDefault(_h);

	var _canvas = __webpack_require__(/*! ./canvas */ 347);

	var _canvas2 = _interopRequireDefault(_canvas);

	var _styles = __webpack_require__(/*! ./styles */ 334);

	var _styles2 = _interopRequireDefault(_styles);

	var _error = __webpack_require__(/*! ./error */ 344);

	var _error2 = _interopRequireDefault(_error);

	var _manipulatorTools = __webpack_require__(/*! ./manipulatorTools */ 349);

	var _manipulatorTools2 = _interopRequireDefault(_manipulatorTools);

	var _progress = __webpack_require__(/*! ./progress */ 345);

	var _progress2 = _interopRequireDefault(_progress);

	var _player = __webpack_require__(/*! ../modules/player */ 295);

	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 283);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var brokenThumbnails = {};

	function player(store, _ref) {
	  var isFlex = _ref.isFlex,
	      isRelative = _ref.isRelative,
	      parentEl = _ref.parentEl;

	  var rendered = (0, _sceneIO.isSceneRendered)(store);

	  var sceneId = store.getIn(['sceneIO', 'id']);
	  var hideThumbnail = rendered || !sceneId || !(0, _player.shouldDisplayThumbnail)(store);

	  var cssStyle = '\n  div.claraplayer canvas {\n    box-sizing: content-box;\n    -webkit-box-sizing: content-box;\n  }\n  div.claraplayer canvas:focus {\n    outline: none;\n  }\n';
	  var children = [(0, _h2.default)('style', { props: { innerHTML: cssStyle } })];

	  var fullscreenBackgroundColor = store.getIn(['player', 'fullscreenBackgroundColor']);
	  var playerStyles = (0, _assign2.default)({}, _styles2.default.player, {
	    backgroundImage: hideThumbnail ? '' : 'url(' + ("https://editor.vimarket.io") + '/api/scenes/' + sceneId + '/v2thumbnail)',
	    backgroundRepeat: 'no-repeat',
	    backgroundSize: 'auto 100%',
	    backgroundPosition: 'center',
	    position: isFlex || isRelative ? 'absolute' : 'relative',
	    boxSizing: 'border-box',
	    backgroundColor: (0, _player.isFullscreen)(store) ? fullscreenBackgroundColor : 'transparent',
	    overflow: 'hidden'
	  });

	  if ((0, _sceneIO.numErrors)(store)) {
	    children.push((0, _error2.default)(store));
	  } else {
	    children.push((0, _canvas2.default)(store, 'player'));
	    if (rendered) children.push((0, _manipulatorTools2.default)(store));else children.push((0, _progress2.default)(store));
	  }

	  return (0, _h2.default)('div.claraplayer', { style: playerStyles, hook: {
	      insert: attachFullscreenHandlers(store)
	    } }, children);
	}

	function attachFullscreenHandlers(store) {
	  return function () {
	    [// ['fullscreenChange', 'fullscreenElement'],
	    ['webkitfullscreenchange', 'webkitIsFullScreen'], ['mozfullscreenchange', 'mozFullScreen'], ['MSFullscreenChange', 'msFullscreenElement']].forEach(function (info) {
	      document.addEventListener(info[0], function () {
	        //console.log('FULLSCREEN', info[0], !!document[info[1]]);
	        store.dispatch((0, _player.setFullscreen)(!!document[info[1]]));
	      });
	    });
	  };
	}

	/*function statsReporter() {
	  var pageLoadTime, toRenderedTime;
	  if (typeof performace === 'undefined') return function() {};

	  return function(store, pct) {
	    if (pageLoadTime && toRenderedTime) return;
	    if (!pageLoadTime) pageLoadTime = new Date().getTime() - performance.timing.navigationStart;
	    if (pct < 1) return;
	    toRenderedTime = new Date().getTime() - performance.timing.navigationStart;
	    console.log(`Page loaded in ${pageLoadTime}ms and rendered in ${toRenderedTime}ms`);
	  };
	};

	//
	//
	var circleDiv = {
	  flex: '0 0 25%'
	};

	var r = 90;
	var PIR2 = Math.PI * r * 2;

	var outer = {
	  r, cx: 100, cy: 100,
	  fill: 'transparent',
	  'stroke-dasharray': PIR2,
	  'stroke-dashoffset': 0,
	  'stroke-width': '1em',
	  stroke: '#eee'
	};
	var inner = {
	  r, cx: 100, cy: 100,
	  fill: 'transparent',
	  stroke: colour,
	  transition: 'stroke-dashoffset 1s linear',
	  'stroke-width': '1em',
	  'stroke-dashoffset': PIR2,
	  'stroke-dasharray': PIR2
	};
	var svg = {
	  height: '100%',
	  width: '100%',
	  viewport: '0 0 100 100',
	  viewBox: '0 0 200 200',
	};

	function progress(store, pct) {
	  var r = 90;
	  var degrees = PIR2*(1-pct);

	  return h('div', {style: {...styles.absoluteMaxCentered, backgroundColor: 'transparent', boxSizing: 'border-box' }}, [
	    h('div', {style: circleDiv}, [
	      h('svg', {attrs: svg}, [
	        h('circle', {attrs: outer}),
	        h('circle', {props: {id: 'bar'}, attrs: {...inner, 'stroke-dashoffset': degrees}}),
	      ])
	    ])
	  ]);
	};*/

/***/ }
/******/ ])))
});
;
//# sourceMappingURL=claraplayer-2.2.27.js.map
