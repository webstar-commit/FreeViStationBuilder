(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["claraplayer"] = factory();
	else
		root["claraplayer"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*************************!*\
  !*** multi claraplayer ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./src/player */356);


/***/ },
/* 1 */,
/* 2 */
/*!******************************************************!*\
  !*** ./~/babel-runtime/helpers/toConsumableArray.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(/*! babel-runtime/core-js/array/from */ 3);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 3 */
/*!***********************************************!*\
  !*** ./~/babel-runtime/core-js/array/from.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/array/from */ 4), __esModule: true };

/***/ },
/* 4 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/array/from.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.string.iterator */ 5);
	__webpack_require__(/*! ../../modules/es6.array.from */ 49);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Array.from;

/***/ },
/* 5 */
/*!**************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.string.iterator.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(/*! ./_string-at */ 6)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(/*! ./_iter-define */ 9)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 6 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_string-at.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(/*! ./_to-integer */ 7)
	  , defined   = __webpack_require__(/*! ./_defined */ 8);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 7 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-integer.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 8 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_defined.js ***!
  \***************************************************************/
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 9 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-define.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(/*! ./_library */ 10)
	  , $export        = __webpack_require__(/*! ./_export */ 11)
	  , redefine       = __webpack_require__(/*! ./_redefine */ 26)
	  , hide           = __webpack_require__(/*! ./_hide */ 16)
	  , has            = __webpack_require__(/*! ./_has */ 27)
	  , Iterators      = __webpack_require__(/*! ./_iterators */ 28)
	  , $iterCreate    = __webpack_require__(/*! ./_iter-create */ 29)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 45)
	  , getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ 47)
	  , ITERATOR       = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 10 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_library.js ***!
  \***************************************************************/
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 11 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_export.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(/*! ./_global */ 12)
	  , core      = __webpack_require__(/*! ./_core */ 13)
	  , ctx       = __webpack_require__(/*! ./_ctx */ 14)
	  , hide      = __webpack_require__(/*! ./_hide */ 16)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 12 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_global.js ***!
  \**************************************************************/
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 13 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_core.js ***!
  \************************************************************/
/***/ function(module, exports) {

	var core = module.exports = {version: '2.2.2'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 14 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_ctx.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(/*! ./_a-function */ 15);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 15 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_a-function.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 16 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_hide.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(/*! ./_object-dp */ 17)
	  , createDesc = __webpack_require__(/*! ./_property-desc */ 25);
	module.exports = __webpack_require__(/*! ./_descriptors */ 21) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 17 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-dp.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(/*! ./_an-object */ 18)
	  , IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ 20)
	  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ 24)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(/*! ./_descriptors */ 21) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 18 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_an-object.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./_is-object */ 19);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 19 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_is-object.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 20 */
/*!**********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_ie8-dom-define.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(/*! ./_descriptors */ 21) && !__webpack_require__(/*! ./_fails */ 22)(function(){
	  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ 23)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 21 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_descriptors.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(/*! ./_fails */ 22)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 22 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_fails.js ***!
  \*************************************************************/
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 23 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_dom-create.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , document = __webpack_require__(/*! ./_global */ 12).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 24 */
/*!********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-primitive.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(/*! ./_is-object */ 19);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 25 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_property-desc.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 26 */
/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_redefine.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./_hide */ 16);

/***/ },
/* 27 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_has.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 28 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iterators.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 29 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-create.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(/*! ./_object-create */ 30)
	  , descriptor     = __webpack_require__(/*! ./_property-desc */ 25)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 45)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(/*! ./_hide */ 16)(IteratorPrototype, __webpack_require__(/*! ./_wks */ 46)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 30 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-create.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(/*! ./_an-object */ 18)
	  , dPs         = __webpack_require__(/*! ./_object-dps */ 31)
	  , enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ 43)
	  , IE_PROTO    = __webpack_require__(/*! ./_shared-key */ 40)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(/*! ./_dom-create */ 23)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(/*! ./_html */ 44).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 31 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-dps.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(/*! ./_object-dp */ 17)
	  , anObject = __webpack_require__(/*! ./_an-object */ 18)
	  , getKeys  = __webpack_require__(/*! ./_object-keys */ 32);
	
	module.exports = __webpack_require__(/*! ./_descriptors */ 21) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 32 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-keys.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(/*! ./_object-keys-internal */ 33)
	  , enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ 43);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 33 */
/*!****************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-keys-internal.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(/*! ./_has */ 27)
	  , toIObject    = __webpack_require__(/*! ./_to-iobject */ 34)
	  , arrayIndexOf = __webpack_require__(/*! ./_array-includes */ 37)(false)
	  , IE_PROTO     = __webpack_require__(/*! ./_shared-key */ 40)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 34 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-iobject.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(/*! ./_iobject */ 35)
	  , defined = __webpack_require__(/*! ./_defined */ 8);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 35 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iobject.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(/*! ./_cof */ 36);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 36 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_cof.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 37 */
/*!**********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_array-includes.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(/*! ./_to-iobject */ 34)
	  , toLength  = __webpack_require__(/*! ./_to-length */ 38)
	  , toIndex   = __webpack_require__(/*! ./_to-index */ 39);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 38 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-length.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(/*! ./_to-integer */ 7)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 39 */
/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-index.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(/*! ./_to-integer */ 7)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 40 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_shared-key.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(/*! ./_shared */ 41)('keys')
	  , uid    = __webpack_require__(/*! ./_uid */ 42);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 41 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_shared.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(/*! ./_global */ 12)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 42 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_uid.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 43 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_enum-bug-keys.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 44 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_html.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./_global */ 12).document && document.documentElement;

/***/ },
/* 45 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_set-to-string-tag.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(/*! ./_object-dp */ 17).f
	  , has = __webpack_require__(/*! ./_has */ 27)
	  , TAG = __webpack_require__(/*! ./_wks */ 46)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 46 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_wks.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(/*! ./_shared */ 41)('wks')
	  , uid        = __webpack_require__(/*! ./_uid */ 42)
	  , Symbol     = __webpack_require__(/*! ./_global */ 12).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

/***/ },
/* 47 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gpo.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(/*! ./_has */ 27)
	  , toObject    = __webpack_require__(/*! ./_to-object */ 48)
	  , IE_PROTO    = __webpack_require__(/*! ./_shared-key */ 40)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 48 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_to-object.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(/*! ./_defined */ 8);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 49 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.array.from.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(/*! ./_ctx */ 14)
	  , $export        = __webpack_require__(/*! ./_export */ 11)
	  , toObject       = __webpack_require__(/*! ./_to-object */ 48)
	  , call           = __webpack_require__(/*! ./_iter-call */ 50)
	  , isArrayIter    = __webpack_require__(/*! ./_is-array-iter */ 51)
	  , toLength       = __webpack_require__(/*! ./_to-length */ 38)
	  , createProperty = __webpack_require__(/*! ./_create-property */ 52)
	  , getIterFn      = __webpack_require__(/*! ./core.get-iterator-method */ 53);
	
	$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ 55)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 50 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-call.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(/*! ./_an-object */ 18);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 51 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_is-array-iter.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(/*! ./_iterators */ 28)
	  , ITERATOR   = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 52 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_create-property.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(/*! ./_object-dp */ 17)
	  , createDesc      = __webpack_require__(/*! ./_property-desc */ 25);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 53 */
/*!*******************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/core.get-iterator-method.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(/*! ./_classof */ 54)
	  , ITERATOR  = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , Iterators = __webpack_require__(/*! ./_iterators */ 28);
	module.exports = __webpack_require__(/*! ./_core */ 13).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 54 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_classof.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(/*! ./_cof */ 36)
	  , TAG = __webpack_require__(/*! ./_wks */ 46)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 55 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-detect.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 56 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/object/assign.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/assign */ 57), __esModule: true };

/***/ },
/* 57 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/assign.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.assign */ 58);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.assign;

/***/ },
/* 58 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.assign.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(/*! ./_export */ 11);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(/*! ./_object-assign */ 59)});

/***/ },
/* 59 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-assign.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(/*! ./_object-keys */ 32)
	  , gOPS     = __webpack_require__(/*! ./_object-gops */ 60)
	  , pIE      = __webpack_require__(/*! ./_object-pie */ 61)
	  , toObject = __webpack_require__(/*! ./_to-object */ 48)
	  , IObject  = __webpack_require__(/*! ./_iobject */ 35)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(/*! ./_fails */ 22)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 60 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gops.js ***!
  \*******************************************************************/
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 61 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-pie.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 62 */,
/* 63 */,
/* 64 */
/*!*************************!*\
  !*** ./vendor/three.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// File:src/Three.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var THREE = { REVISION: '79' };
	
	//
	
	if ( true ) {
	
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {
	
		module.exports = THREE;
	
	}
	
	// Polyfills
	
	if ( Number.EPSILON === undefined ) {
	
		Number.EPSILON = Math.pow( 2, - 52 );
	
	}
	
	//
	
	if ( Math.sign === undefined ) {
	
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
		Math.sign = function ( x ) {
	
			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	
		};
	
	}
	
	if ( Function.prototype.name === undefined ) {
	
		// Missing in IE9-11.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	
		Object.defineProperty( Function.prototype, 'name', {
	
			get: function () {
	
				return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];
	
			}
	
		} );
	
	}
	
	if ( Object.assign === undefined ) {
	
		// Missing in IE.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
		( function () {
	
			Object.assign = function ( target ) {
	
				'use strict';
	
				if ( target === undefined || target === null ) {
	
					throw new TypeError( 'Cannot convert undefined or null to object' );
	
				}
	
				var output = Object( target );
	
				for ( var index = 1; index < arguments.length; index ++ ) {
	
					var source = arguments[ index ];
	
					if ( source !== undefined && source !== null ) {
	
						for ( var nextKey in source ) {
	
							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {
	
								output[ nextKey ] = source[ nextKey ];
	
							}
	
						}
	
					}
	
				}
	
				return output;
	
			};
	
		} )();
	
	}
	
	//
	
	Object.assign( THREE, {
	
		// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
	
		MOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },
	
		// GL STATE CONSTANTS
	
		CullFaceNone: 0,
		CullFaceBack: 1,
		CullFaceFront: 2,
		CullFaceFrontBack: 3,
	
		FrontFaceDirectionCW: 0,
		FrontFaceDirectionCCW: 1,
	
		// SHADOWING TYPES
	
		BasicShadowMap: 0,
		PCFShadowMap: 1,
		PCFSoftShadowMap: 2,
		PCSSSoftShadowMap: 3,
	
		// MATERIAL CONSTANTS
	
		// side
	
		FrontSide: 0,
		BackSide: 1,
		DoubleSide: 2,
	
		// shading
	
		FlatShading: 1,
		SmoothShading: 2,
	
		// colors
	
		NoColors: 0,
		FaceColors: 1,
		VertexColors: 2,
	
		// blending modes
	
		NoBlending: 0,
		NormalBlending: 1,
		AdditiveBlending: 2,
		SubtractiveBlending: 3,
		MultiplyBlending: 4,
		CustomBlending: 5,
	
		// custom blending equations
		// (numbers start from 100 not to clash with other
		// mappings to OpenGL constants defined in Texture.js)
	
		AddEquation: 100,
		SubtractEquation: 101,
		ReverseSubtractEquation: 102,
		MinEquation: 103,
		MaxEquation: 104,
	
		// custom blending destination factors
	
		ZeroFactor: 200,
		OneFactor: 201,
		SrcColorFactor: 202,
		OneMinusSrcColorFactor: 203,
		SrcAlphaFactor: 204,
		OneMinusSrcAlphaFactor: 205,
		DstAlphaFactor: 206,
		OneMinusDstAlphaFactor: 207,
	
		// custom blending source factors
	
		//ZeroFactor: 200,
		//OneFactor: 201,
		//SrcAlphaFactor: 204,
		//OneMinusSrcAlphaFactor: 205,
		//DstAlphaFactor: 206,
		//OneMinusDstAlphaFactor: 207,
		DstColorFactor: 208,
		OneMinusDstColorFactor: 209,
		SrcAlphaSaturateFactor: 210,
	
		// depth modes
	
		NeverDepth: 0,
		AlwaysDepth: 1,
		LessDepth: 2,
		LessEqualDepth: 3,
		EqualDepth: 4,
		GreaterEqualDepth: 5,
		GreaterDepth: 6,
		NotEqualDepth: 7,
	
	
		// TEXTURE CONSTANTS
	
		MultiplyOperation: 0,
		MixOperation: 1,
		AddOperation: 2,
	
		// Tone Mapping modes
	
		NoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)
		LinearToneMapping: 1, // only apply exposure.
		ReinhardToneMapping: 2,
		Uncharted2ToneMapping: 3, // John Hable
		CineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	
		// Mapping modes
	
		UVMapping: 300,
	
		CubeReflectionMapping: 301,
		CubeRefractionMapping: 302,
	
		EquirectangularReflectionMapping: 303,
		EquirectangularRefractionMapping: 304,
	
		SphericalReflectionMapping: 305,
		CubeUVReflectionMapping: 306,
		CubeUVRefractionMapping: 307,
	
		// Wrapping modes
	
		RepeatWrapping: 1000,
		ClampToEdgeWrapping: 1001,
		MirroredRepeatWrapping: 1002,
	
		// Filters
	
		NearestFilter: 1003,
		NearestMipMapNearestFilter: 1004,
		NearestMipMapLinearFilter: 1005,
		LinearFilter: 1006,
		LinearMipMapNearestFilter: 1007,
		LinearMipMapLinearFilter: 1008,
	
		// Data types
	
		UnsignedByteType: 1009,
		ByteType: 1010,
		ShortType: 1011,
		UnsignedShortType: 1012,
		IntType: 1013,
		UnsignedIntType: 1014,
		FloatType: 1015,
		HalfFloatType: 1025,
	
		// Pixel types
	
		//UnsignedByteType: 1009,
		UnsignedShort4444Type: 1016,
		UnsignedShort5551Type: 1017,
		UnsignedShort565Type: 1018,
	
		// Pixel formats
	
		AlphaFormat: 1019,
		RGBFormat: 1020,
		RGBAFormat: 1021,
		LuminanceFormat: 1022,
		LuminanceAlphaFormat: 1023,
		// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
		RGBEFormat: THREE.RGBAFormat, //1024;
		DepthFormat: 1026,
	
		// DDS / ST3C Compressed texture formats
	
		RGB_S3TC_DXT1_Format: 2001,
		RGBA_S3TC_DXT1_Format: 2002,
		RGBA_S3TC_DXT3_Format: 2003,
		RGBA_S3TC_DXT5_Format: 2004,
	
		// PVRTC compressed texture formats
	
		RGB_PVRTC_4BPPV1_Format: 2100,
		RGB_PVRTC_2BPPV1_Format: 2101,
		RGBA_PVRTC_4BPPV1_Format: 2102,
		RGBA_PVRTC_2BPPV1_Format: 2103,
	
		// ETC compressed texture formats
	
		RGB_ETC1_Format: 2151,
	
		// Loop styles for AnimationAction
	
		LoopOnce: 2200,
		LoopRepeat: 2201,
		LoopPingPong: 2202,
	
		// Interpolation
	
		InterpolateDiscrete: 2300,
		InterpolateLinear: 2301,
		InterpolateSmooth: 2302,
	
		// Interpolant ending modes
	
		ZeroCurvatureEnding: 2400,
		ZeroSlopeEnding: 2401,
		WrapAroundEnding: 2402,
	
		// Triangle Draw modes
	
		TrianglesDrawMode: 0,
		TriangleStripDrawMode: 1,
		TriangleFanDrawMode: 2,
	
		// Texture Encodings
	
		LinearEncoding: 3000, // No encoding at all.
		sRGBEncoding: 3001,
		GammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput
	
		// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.
		// These encodings should not specified as output encodings except in rare situations.
		RGBEEncoding: 3002, // AKA Radiance.
		LogLuvEncoding: 3003,
		RGBM7Encoding: 3004,
		RGBM16Encoding: 3005,
		RGBDEncoding: 3006, // MaxRange is 256.
	
		// Depth packing strategies
	
		BasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers
		RGBADepthPacking: 3201 // for packing into RGBA buffers.
	
	} );
	
	// File:src/math/Color.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Color = function ( r, g, b ) {
	
		if ( g === undefined && b === undefined ) {
	
			// r is THREE.Color, hex or string
			return this.set( r );
	
		}
	
		return this.setRGB( r, g, b );
	
	};
	
	THREE.Color.prototype = {
	
		constructor: THREE.Color,
	
		r: 1, g: 1, b: 1,
	
		set: function ( value ) {
	
			if ( value instanceof THREE.Color ) {
	
				this.copy( value );
	
			} else if ( typeof value === 'number' ) {
	
				this.setHex( value );
	
			} else if ( typeof value === 'string' ) {
	
				this.setStyle( value );
	
			}
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
	
		},
	
		setHex: function ( hex ) {
	
			hex = Math.floor( hex );
	
			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;
	
			return this;
	
		},
	
		setRGB: function ( r, g, b ) {
	
			this.r = r;
			this.g = g;
			this.b = b;
	
			return this;
	
		},
	
		setHSL: function () {
	
			function hue2rgb( p, q, t ) {
	
				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;
	
			}
	
			return function setHSL( h, s, l ) {
	
				// h,s,l ranges are in 0.0 - 1.0
				h = THREE.Math.euclideanModulo( h, 1 );
				s = THREE.Math.clamp( s, 0, 1 );
				l = THREE.Math.clamp( l, 0, 1 );
	
				if ( s === 0 ) {
	
					this.r = this.g = this.b = l;
	
				} else {
	
					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;
	
					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );
	
				}
	
				return this;
	
			};
	
		}(),
	
		setStyle: function ( style ) {
	
			function handleAlpha( string ) {
	
				if ( string === undefined ) return;
	
				if ( parseFloat( string ) < 1 ) {
	
					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
	
				}
	
			}
	
	
			var m;
	
			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	
				// rgb / hsl
	
				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];
	
				switch ( name ) {
	
					case 'rgb':
					case 'rgba':
	
						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						break;
	
					case 'hsl':
					case 'hsla':
	
						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this.setHSL( h, s, l );
	
						}
	
						break;
	
				}
	
			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	
				// hex color
	
				var hex = m[ 1 ];
				var size = hex.length;
	
				if ( size === 3 ) {
	
					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
	
					return this;
	
				} else if ( size === 6 ) {
	
					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
	
					return this;
	
				}
	
			}
	
			if ( style && style.length > 0 ) {
	
				// color keywords
				var hex = THREE.ColorKeywords[ style ];
	
				if ( hex !== undefined ) {
	
					// red
					this.setHex( hex );
	
				} else {
	
					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );
	
				}
	
			}
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this.r, this.g, this.b );
	
		},
	
		copy: function ( color ) {
	
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
	
			return this;
	
		},
	
		copyGammaToLinear: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );
	
			return this;
	
		},
	
		copyLinearToGamma: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );
	
			return this;
	
		},
	
		convertGammaToLinear: function () {
	
			var r = this.r, g = this.g, b = this.b;
	
			this.r = r * r;
			this.g = g * g;
			this.b = b * b;
	
			return this;
	
		},
	
		convertLinearToGamma: function () {
	
			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );
	
			return this;
	
		},
	
		getHex: function () {
	
			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
		},
	
		getHexString: function () {
	
			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
		},
	
		getHSL: function ( optionalTarget ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
			var r = this.r, g = this.g, b = this.b;
	
			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );
	
			var hue, saturation;
			var lightness = ( min + max ) / 2.0;
	
			if ( min === max ) {
	
				hue = 0;
				saturation = 0;
	
			} else {
	
				var delta = max - min;
	
				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
				switch ( max ) {
	
					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;
	
				}
	
				hue /= 6;
	
			}
	
			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;
	
			return hsl;
	
		},
	
		getStyle: function () {
	
			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
		},
	
		offsetHSL: function ( h, s, l ) {
	
			var hsl = this.getHSL();
	
			hsl.h += h; hsl.s += s; hsl.l += l;
	
			this.setHSL( hsl.h, hsl.s, hsl.l );
	
			return this;
	
		},
	
		add: function ( color ) {
	
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
	
			return this;
	
		},
	
		addColors: function ( color1, color2 ) {
	
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.r += s;
			this.g += s;
			this.b += s;
	
			return this;
	
		},
	
		sub: function( color ) {
	
			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );
	
			return this;
	
		},
	
		multiply: function ( color ) {
	
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.r *= s;
			this.g *= s;
			this.b *= s;
	
			return this;
	
		},
	
		lerp: function ( color, alpha ) {
	
			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;
	
			return this;
	
		},
	
		equals: function ( c ) {
	
			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;
	
			return array;
	
		}
	
	};
	
	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
	// File:src/math/Quaternion.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Quaternion = function ( x, y, z, w ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Quaternion.prototype = {
	
		constructor: THREE.Quaternion,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get w () {
	
			return this._w;
	
		},
	
		set w ( value ) {
	
			this._w = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, w ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._w );
	
		},
	
		copy: function ( quaternion ) {
	
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromEuler: function ( euler, update ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );
	
			var order = euler.order;
	
			if ( order === 'XYZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'YXZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'ZXY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'ZYX' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'YZX' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'XZY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
			// assumes axis is normalized
	
			var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromUnitVectors: function () {
	
			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	
			// assumes direction vectors vFrom and vTo are normalized
	
			var v1, r;
	
			var EPS = 0.000001;
	
			return function setFromUnitVectors( vFrom, vTo ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				r = vFrom.dot( vTo ) + 1;
	
				if ( r < EPS ) {
	
					r = 0;
	
					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
						v1.set( - vFrom.y, vFrom.x, 0 );
	
					} else {
	
						v1.set( 0, - vFrom.z, vFrom.y );
	
					}
	
				} else {
	
					v1.crossVectors( vFrom, vTo );
	
				}
	
				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;
	
				return this.normalize();
	
			};
	
		}(),
	
		inverse: function () {
	
			return this.conjugate().normalize();
	
		},
	
		conjugate: function () {
	
			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
		},
	
		lengthSq: function () {
	
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
	
			} else {
	
				l = 1 / l;
	
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		premultiply: function ( q ) {
	
			return this.multiplyQuaternions( q, this );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		slerp: function ( qb, t ) {
	
			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );
	
			var x = this._x, y = this._y, z = this._z, w = this._w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
			if ( cosHalfTheta < 0 ) {
	
				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;
	
				cosHalfTheta = - cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
	
				return this;
	
			}
	
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
			if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );
	
				return this;
	
			}
	
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		equals: function ( quaternion ) {
	
			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;
	
			return array;
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	};
	
	Object.assign( THREE.Quaternion, {
	
		slerp: function( qa, qb, qm, t ) {
	
			return qm.copy( qa ).slerp( qb, t );
	
		},
	
		slerpFlat: function(
				dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
	
			// fuzz-free, array-based Quaternion SLERP operation
	
			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],
	
				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];
	
			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
	
				var s = 1 - t,
	
					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;
	
				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {
	
					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );
	
					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;
	
				}
	
				var tDir = t * dir;
	
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;
	
				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {
	
					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
	
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
	
				}
	
			}
	
			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
	
		}
	
	} );
	
	// File:src/math/Vector2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.Vector2 = function ( x, y ) {
	
		this.x = x || 0;
		this.y = y || 0;
	
	};
	
	THREE.Vector2.prototype = {
	
		constructor: THREE.Vector2,
	
		get width() {
	
			return this.x;
	
		},
	
		set width( value ) {
	
			this.x = value;
	
		},
	
		get height() {
	
			return this.y;
	
		},
	
		set height( value ) {
	
			this.y = value;
	
		},
	
		//
	
		set: function ( x, y ) {
	
			this.x = x;
			this.y = y;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
	
			return this;
	
		},
	
		multiply: function ( v ) {
	
			this.x *= v.x;
			this.y *= v.y;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
	
				this.x *= scalar;
				this.y *= scalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
	
			}
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector2();
					max = new THREE.Vector2();
	
				}
	
				min.set( minVal, minVal );
				max.set( maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y );
	
		},
	
		lengthManhattan: function() {
	
			return Math.abs( this.x ) + Math.abs( this.y );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		angle: function () {
	
			// computes the angle in radians with respect to the positive x-axis
	
			var angle = Math.atan2( this.y, this.x );
	
			if ( angle < 0 ) angle += 2 * Math.PI;
	
			return angle;
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
	
		},
	
		distanceToManhattan: function ( v ) {
	
			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
	
			return this;
	
		},
	
		rotateAround: function ( center, angle ) {
	
			var c = Math.cos( angle ), s = Math.sin( angle );
	
			var x = this.x - center.x;
			var y = this.y - center.y;
	
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
	
			return this;
	
		}
	
	};
	
	// File:src/math/Vector3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector3 = function ( x, y, z ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	
	};
	
	THREE.Vector3.prototype = {
	
		constructor: THREE.Vector3,
	
		set: function ( x, y, z ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
	
			return this;
	
		},
	
		multiply: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
	
			}
	
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
	
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
	
			}
	
			return this;
	
		},
	
		multiplyVectors: function ( a, b ) {
	
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
	
			return this;
	
		},
	
		applyEuler: function () {
	
			var quaternion;
	
			return function applyEuler( euler ) {
	
				if ( euler instanceof THREE.Euler === false ) {
	
					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
				}
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				return this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
			};
	
		}(),
	
		applyAxisAngle: function () {
	
			var quaternion;
	
			return function applyAxisAngle( axis, angle ) {
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
			};
	
		}(),
	
		applyMatrix3: function ( m ) {
	
			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
	
			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
	
			return this;
	
		},
	
		applyProjection: function ( m ) {
	
			// input: THREE.Matrix4 projection matrix
	
			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide
	
			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;
	
			return this;
	
		},
	
		applyQuaternion: function ( q ) {
	
			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	
			// calculate quat * vector
	
			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;
	
			// calculate result * inverse quat
	
			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
			return this;
	
		},
	
		project: function () {
	
			var matrix;
	
			return function project( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		unproject: function () {
	
			var matrix;
	
			return function unproject( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		transformDirection: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
	
			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
			return this.normalize();
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector3();
					max = new THREE.Vector3();
	
				}
	
				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
		},
	
		cross: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
	
			}
	
			var x = this.x, y = this.y, z = this.z;
	
			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;
	
			return this;
	
		},
	
		crossVectors: function ( a, b ) {
	
			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;
	
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
	
			return this;
	
		},
	
		projectOnVector: function ( vector ) {
	
			var scalar = vector.dot( this ) / vector.lengthSq();
	
			return this.copy( vector ).multiplyScalar( scalar );
	
		},
	
		projectOnPlane: function () {
	
			var v1;
	
			return function projectOnPlane( planeNormal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( this ).projectOnVector( planeNormal );
	
				return this.sub( v1 );
	
			};
	
		}(),
	
		reflect: function () {
	
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
	
			var v1;
	
			return function reflect( normal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
			};
	
		}(),
	
		angleTo: function ( v ) {
	
			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
	
			// clamp, to handle numerical problems
	
			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	
			return dx * dx + dy * dy + dz * dz;
	
		},
	
		distanceToManhattan: function ( v ) {
	
			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
	
		},
	
		setFromSpherical: function( s ) {
	
			var sinPhiRadius = Math.sin( s.phi ) * s.radius;
	
			this.x = sinPhiRadius * Math.sin( s.theta );
			this.y = Math.cos( s.phi ) * s.radius;
			this.z = sinPhiRadius * Math.cos( s.theta );
	
			return this;
	
		},
	
		setFromMatrixPosition: function ( m ) {
	
			return this.setFromMatrixColumn( m, 3 );
	
		},
	
		setFromMatrixScale: function ( m ) {
	
			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();
	
			this.x = sx;
			this.y = sy;
			this.z = sz;
	
			return this;
	
		},
	
		setFromMatrixColumn: function ( m, index ) {
	
			if ( typeof m === 'number' ) {
	
				console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
				var temp = m
				m = index;
				index = temp;
	
			}
	
			return this.fromArray( m.elements, index * 4 );
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
	
			return this;
	
		}
	
	};
	
	// File:src/math/Vector4.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector4 = function ( x, y, z, w ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Vector4.prototype = {
	
		constructor: THREE.Vector4,
	
		set: function ( x, y, z, w ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setW: function ( w ) {
	
			this.w = w;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z, this.w );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
	
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 0;
	
			}
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		setAxisAngleFromQuaternion: function ( q ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
			// q is assumed to be normalized
	
			this.w = 2 * Math.acos( q.w );
	
			var s = Math.sqrt( 1 - q.w * q.w );
	
			if ( s < 0.0001 ) {
	
				 this.x = 1;
				 this.y = 0;
				 this.z = 0;
	
			} else {
	
				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
				te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
	
				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
					// this singularity is identity matrix so angle = 0
	
					this.set( 1, 0, 0, 0 );
	
					return this; // zero angle, arbitrary axis
	
				}
	
				// otherwise this singularity is angle = 180
	
				angle = Math.PI;
	
				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;
	
				if ( ( xx > yy ) && ( xx > zz ) ) {
	
					// m11 is the largest diagonal term
	
					if ( xx < epsilon ) {
	
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
	
					} else {
	
						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;
	
					}
	
				} else if ( yy > zz ) {
	
					// m22 is the largest diagonal term
	
					if ( yy < epsilon ) {
	
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
	
					} else {
	
						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;
	
					}
	
				} else {
	
					// m33 is the largest diagonal term so base result on this
	
					if ( zz < epsilon ) {
	
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
	
					} else {
	
						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;
	
					}
	
				}
	
				this.set( x, y, z, angle );
	
				return this; // return 180 deg rotation
	
			}
	
			// as we have reached here there are no singularities so we can handle normally
	
			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
			if ( Math.abs( s ) < 0.001 ) s = 1;
	
			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
	
			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
			return this;
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector4();
					max = new THREE.Vector4();
	
				}
	
				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];
	
			return this;
	
		}
	
	};
	
	// File:src/math/Euler.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Euler = function ( x, y, z, order ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;
	
	};
	
	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
	THREE.Euler.DefaultOrder = 'XYZ';
	
	THREE.Euler.prototype = {
	
		constructor: THREE.Euler,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get order () {
	
			return this._order;
	
		},
	
		set order ( value ) {
	
			this._order = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, order ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._order );
	
		},
	
		copy: function ( euler ) {
	
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m, order, update ) {
	
			var clamp = THREE.Math.clamp;
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
	
				} else {
	
					this._x = Math.atan2( m32, m22 );
					this._z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
	
				} else {
	
					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
	
				} else {
	
					this._y = 0;
					this._z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
	
				} else {
	
					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
	
				} else {
	
					this._x = 0;
					this._y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
	
				} else {
	
					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
	
				}
	
			} else {
	
				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
	
			}
	
			this._order = order;
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromQuaternion: function () {
	
			var matrix;
	
			return function setFromQuaternion( q, order, update ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.makeRotationFromQuaternion( q );
	
				return this.setFromRotationMatrix( matrix, order, update );
	
			};
	
		}(),
	
		setFromVector3: function ( v, order ) {
	
			return this.set( v.x, v.y, v.z, order || this._order );
	
		},
	
		reorder: function () {
	
			// WARNING: this discards revolution information -bhouston
	
			var q = new THREE.Quaternion();
	
			return function reorder( newOrder ) {
	
				q.setFromEuler( this );
	
				return this.setFromQuaternion( q, newOrder );
	
			};
	
		}(),
	
		equals: function ( euler ) {
	
			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
		},
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;
	
			return array;
	
		},
	
		toVector3: function ( optionalResult ) {
	
			if ( optionalResult ) {
	
				return optionalResult.set( this._x, this._y, this._z );
	
			} else {
	
				return new THREE.Vector3( this._x, this._y, this._z );
	
			}
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	};
	
	// File:src/math/Line3.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Line3 = function ( start, end ) {
	
		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();
	
	};
	
	THREE.Line3.prototype = {
	
		constructor: THREE.Line3,
	
		set: function ( start, end ) {
	
			this.start.copy( start );
			this.end.copy( end );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( line ) {
	
			this.start.copy( line.start );
			this.end.copy( line.end );
	
			return this;
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
		},
	
		delta: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );
	
		},
	
		distanceSq: function () {
	
			return this.start.distanceToSquared( this.end );
	
		},
	
		distance: function () {
	
			return this.start.distanceTo( this.end );
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		closestPointToPointParameter: function () {
	
			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();
	
			return function closestPointToPointParameter( point, clampToLine ) {
	
				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );
	
				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );
	
				var t = startEnd_startP / startEnd2;
	
				if ( clampToLine ) {
	
					t = THREE.Math.clamp( t, 0, 1 );
	
				}
	
				return t;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
			var t = this.closestPointToPointParameter( point, clampToLine );
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );
	
			return this;
	
		},
	
		equals: function ( line ) {
	
			return line.start.equals( this.start ) && line.end.equals( this.end );
	
		}
	
	};
	
	// File:src/math/Box2.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Box2 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );
	
	};
	
	THREE.Box2.prototype = {
	
		constructor: THREE.Box2,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector2();
	
			return function setFromCenterAndSize( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;
	
			return this;
	
		},
	
		isEmpty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector2();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);
	
		},
	
		intersectsBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector2();
	
			return function distanceToPoint( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	};
	
	// File:src/math/Box3.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Box3 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );
	
	};
	
	THREE.Box3.prototype = {
	
		constructor: THREE.Box3,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromArray: function ( array ) {
	
			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;
	
			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;
	
			for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];
	
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;
	
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;
	
			}
	
			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector3();
	
			return function setFromCenterAndSize( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		setFromObject: function () {
	
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
	
			var v1 = new THREE.Vector3();
	
			return function setFromObject( object ) {
	
				var scope = this;
	
				object.updateMatrixWorld( true );
	
				this.makeEmpty();
	
				object.traverse( function ( node ) {
	
					var geometry = node.geometry;
	
					if ( geometry !== undefined ) {
	
						if ( geometry instanceof THREE.Geometry ) {
	
							var vertices = geometry.vertices;
	
							for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
								v1.copy( vertices[ i ] );
								v1.applyMatrix4( node.matrixWorld );
	
								scope.expandByPoint( v1 );
	
							}
	
						} else if ( geometry instanceof THREE.BufferGeometry ) {
	
							var attribute = geometry.attributes.position;
	
							if ( attribute !== undefined ) {
	
								var array, offset, stride;
	
								if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
									array = attribute.data.array;
									offset = attribute.offset;
									stride = attribute.data.stride;
	
								} else {
	
									array = attribute.array;
									offset = 0;
									stride = 3;
	
								}
	
								for ( var i = offset, il = array.length; i < il; i += stride ) {
	
									v1.fromArray( array, i );
									v1.applyMatrix4( node.matrixWorld );
	
									scope.expandByPoint( v1 );
	
								}
	
							}
	
						}
	
					}
	
				} );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;
	
			return this;
	
		},
	
		isEmpty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
					 point.y < this.min.y || point.y > this.max.y ||
					 point.z < this.min.z || point.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);
	
		},
	
		intersectsBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
					 box.max.y < this.min.y || box.min.y > this.max.y ||
					 box.max.z < this.min.z || box.min.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		intersectsSphere: ( function () {
	
			var closestPoint;
	
			return function intersectsSphere( sphere ) {
	
				if ( closestPoint === undefined ) closestPoint = new THREE.Vector3();
	
				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );
	
				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
	
			};
	
		} )(),
	
		intersectsPlane: function ( plane ) {
	
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
	
			var min, max;
	
			if ( plane.normal.x > 0 ) {
	
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
	
			} else {
	
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
	
			}
	
			if ( plane.normal.y > 0 ) {
	
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
	
			} else {
	
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
	
			}
	
			if ( plane.normal.z > 0 ) {
	
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
	
			} else {
	
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
	
			}
	
			return ( min <= plane.constant && max >= plane.constant );
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function distanceToPoint( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		getBoundingSphere: function () {
	
			var v1 = new THREE.Vector3();
	
			return function getBoundingSphere( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Sphere();
	
				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;
	
				return result;
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if( this.isEmpty() ) this.makeEmpty();
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		applyMatrix4: function () {
	
			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];
	
			return function applyMatrix4( matrix ) {
	
				// transform of empty box is an empty box.
				if( this.isEmpty() ) return this;
	
				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111
	
				this.setFromPoints( points );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	};
	
	// File:src/math/Matrix3.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */
	
	THREE.Matrix3 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0,
			0, 1, 0,
			0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix3.prototype = {
	
		constructor: THREE.Matrix3,
	
		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]
	
			);
	
			return this;
	
		},
	
		setFromMatrix4: function( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[ 0 ], me[ 4 ], me[  8 ],
				me[ 1 ], me[ 5 ], me[  9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]
	
			);
	
			return this;
	
		},
	
		applyToVector3Array: function () {
	
			var v1;
	
			return function applyToVector3Array( array, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.fromArray( array, j );
					v1.applyMatrix3( this );
					v1.toArray( array, j );
	
				}
	
				return array;
	
			};
	
		}(),
	
		applyToBuffer: function () {
	
			var v1;
	
			return function applyToBuffer( buffer, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );
	
					v1.applyMatrix3( this );
	
					buffer.setXYZ( v1.x, v1.y, v1.z );
	
				}
	
				return buffer;
	
			};
	
		}(),
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
			return this;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
		},
	
		getInverse: function ( matrix, throwOnDegenerate ) {
	
			if ( matrix instanceof THREE.Matrix4 ) {
	
				console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );
	
			}
	
			var me = matrix.elements,
				te = this.elements,
	
				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
	
				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,
	
				det = n11 * t11 + n21 * t12 + n31 * t13;
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnDegenerate || false ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				return this.identity();
			}
	
			var detInv = 1 / det;
	
			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
	
			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
	
			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
	
			return this;
	
		},
	
		transpose: function () {
	
			var tmp, m = this.elements;
	
			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
					"- just use .toArray instead." );
	
			return this.toArray( array, offset );
	
		},
	
		getNormalMatrix: function ( matrix4 ) {
	
			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
	
		},
	
		transposeIntoArray: function ( r ) {
	
			var m = this.elements;
	
			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
	
			return this;
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			for( var i = 0; i < 9; i ++ ) {
	
				this.elements[ i ] = array[ i + offset ];
	
			}
	
	 		return this;
	
	
	 	},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
	
			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
	
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];
	
			return array;
	
		}
	
	};
	
	// File:src/math/Matrix4.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Matrix4 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix4.prototype = {
	
		constructor: THREE.Matrix4,
	
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new THREE.Matrix4().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			this.elements.set( m.elements );
	
			return this;
	
		},
	
		copyPosition: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];
	
			return this;
	
		},
	
		extractBasis: function ( xAxis, yAxis, zAxis ) {
	
			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );
	
			return this;
	
		},
	
		makeBasis: function ( xAxis, yAxis, zAxis ) {
	
			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);
	
			return this;
	
		},
	
		extractRotation: function () {
	
			var v1;
	
			return function extractRotation( m ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				var te = this.elements;
				var me = m.elements;
	
				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();
	
				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
	
				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
	
				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
	
				return this;
	
			};
	
		}(),
	
		makeRotationFromEuler: function ( euler ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			var te = this.elements;
	
			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
	
			if ( euler.order === 'XYZ' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;
	
				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;
	
				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YXZ' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;
	
				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;
	
				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZXY' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;
	
				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;
	
				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZYX' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;
	
				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;
	
				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YZX' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;
	
				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;
	
				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;
	
			} else if ( euler.order === 'XZY' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;
	
				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;
	
				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;
	
			}
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		makeRotationFromQuaternion: function ( q ) {
	
			var te = this.elements;
	
			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
	
			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;
	
			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;
	
			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		lookAt: function () {
	
			var x, y, z;
	
			return function lookAt( eye, target, up ) {
	
				if ( x === undefined ) {
	
					x = new THREE.Vector3();
					y = new THREE.Vector3();
					z = new THREE.Vector3();
	
				}
	
				var te = this.elements;
	
				z.subVectors( eye, target ).normalize();
	
				if ( z.lengthSq() === 0 ) {
	
					z.z = 1;
	
				}
	
				x.crossVectors( up, z ).normalize();
	
				if ( x.lengthSq() === 0 ) {
	
					z.z += 0.0001;
					x.crossVectors( up, z ).normalize();
	
				}
	
				y.crossVectors( z, x );
	
	
				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
				return this;
	
			};
	
		}(),
	
		multiply: function ( m, n ) {
	
			if ( n !== undefined ) {
	
				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
	
			}
	
			return this.multiplyMatrices( this, m );
	
		},
	
		premultiply: function ( m ) {
	
			return this.multiplyMatrices( m, this );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return this;
	
		},
	
		multiplyList: function ( listOfMatrices ) {
	
			for (var i = 0, il = listOfMatrices.length; i < il ; i++) {
			  this.multiplyMatrices( this, listOfMatrices[ i ] );
			}
	
			return this;
	
		},
	
		multiplyMatricesList: function ( listOfMatrices ) {
	
			if( listOfMatrices.length > 0 ) {
	
				this.copy( listOfMatrices[0] );
	
				this.multiplyList( listOfMatrices.slice( 1 ) );
	
			}
			else {
	
				this.identity();
	
			}
	
			return this;
	
		},
	
		multiplyToArray: function ( a, b, r ) {
	
			var te = this.elements;
	
			this.multiplyMatrices( a, b );
	
			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
			return this;
	
		},
	
		applyToVector3Array: function () {
	
			var v1;
	
			return function applyToVector3Array( array, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.fromArray( array, j );
					v1.applyMatrix4( this );
					v1.toArray( array, j );
	
				}
	
				return array;
	
			};
	
		}(),
	
		applyToBuffer: function () {
	
			var v1;
	
			return function applyToBuffer( buffer, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );
	
					v1.applyMatrix4( this );
	
					buffer.setXYZ( v1.x, v1.y, v1.z );
	
				}
	
				return buffer;
	
			};
	
		}(),
	
		determinant: function () {
	
			var te = this.elements;
	
			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)
	
			);
	
		},
	
		transpose: function () {
	
			var te = this.elements;
			var tmp;
	
			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
					"- just use .toArray instead." );
	
			return this.toArray( array, offset );
	
		},
	
		getPosition: function () {
	
			var v1;
	
			return function getPosition() {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	
				return v1.setFromMatrixColumn( this, 3 );
	
			};
	
		}(),
	
		setPosition: function ( v ) {
	
			var te = this.elements;
	
			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;
	
			return this;
	
		},
	
		getInverse: function ( m, throwOnDegenerate ) {
	
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,
	
				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
	
				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	
			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnDegenerate || false ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				return this.identity();
	
			}
	
			var detInv = 1 / det;
	
			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
	
			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
	
			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
	
			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
	
			return this;
	
		},
	
		scale: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
			return this;
	
		},
	
		getMaxScaleOnAxis: function () {
	
			var te = this.elements;
	
			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
		},
	
		makeTranslation: function ( x, y, z ) {
	
			this.set(
	
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationX: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationY: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationZ: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationAxis: function ( axis, angle ) {
	
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
	
			this.set(
	
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
	
			);
	
			 return this;
	
		},
	
		makeScale: function ( x, y, z ) {
	
			this.set(
	
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		compose: function ( position, quaternion, scale ) {
	
			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );
	
			return this;
	
		},
	
		decompose: function () {
	
			var vector, matrix;
	
			return function decompose( position, quaternion, scale ) {
	
				if ( vector === undefined ) {
	
					vector = new THREE.Vector3();
					matrix = new THREE.Matrix4();
	
				}
	
				var te = this.elements;
	
				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {
	
					sx = - sx;
	
				}
	
				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];
	
				// scale the rotation part
	
				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()
	
				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;
	
				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;
	
				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;
	
				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;
	
				quaternion.setFromRotationMatrix( matrix );
	
				scale.x = sx;
				scale.y = sy;
				scale.z = sz;
	
				return this;
	
			};
	
		}(),
	
		makeFrustum: function ( left, right, bottom, top, near, far ) {
	
			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
	
			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
	
			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
			return this;
	
		},
	
		makePerspective: function ( fov, aspect, near, far ) {
	
			var ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;
	
			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );
	
		},
	
		makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );
	
			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;
	
			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
			return this;
	
		},
	
		equals: function ( matrix ) {
	
			var te = this.elements;
			var me = matrix.elements;
	
			for ( var i = 0; i < 16; i ++ ) {
	
				if ( te[ i ] !== me[ i ] ) return false;
	
			}
	
			return true;
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			for( var i = 0; i < 16; i ++ ) {
	
				this.elements[ i ] = array[ i + offset ];
	
			}
	
	 		return this;
	
	 	},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];
	
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
	
			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];
	
			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];
	
			return array;
	
		}
	
	};
	
	// File:src/math/Ray.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Ray = function ( origin, direction ) {
	
		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();
	
	};
	
	THREE.Ray.prototype = {
	
		constructor: THREE.Ray,
	
		set: function ( origin, direction ) {
	
			this.origin.copy( origin );
			this.direction.copy( direction );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( ray ) {
	
			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );
	
			return this;
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
		},
	
		lookAt: function ( v ) {
	
			this.direction.copy( v ).sub( this.origin ).normalize();
	
			return this;
	
		},
	
		recast: function () {
	
			var v1 = new THREE.Vector3();
	
			return function recast( t ) {
	
				this.origin.copy( this.at( t, v1 ) );
	
				return this;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );
	
			if ( directionDistance < 0 ) {
	
				return result.copy( this.origin );
	
			}
	
			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return Math.sqrt( this.distanceSqToPoint( point ) );
	
		},
	
		distanceSqToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function distanceSqToPoint( point ) {
	
				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
				// point behind the ray
	
				if ( directionDistance < 0 ) {
	
					return this.origin.distanceToSquared( point );
	
				}
	
				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
				return v1.distanceToSquared( point );
	
			};
	
		}(),
	
		distanceSqToSegment: function () {
	
			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();
	
			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment
	
				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );
	
				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;
	
				if ( det > 0 ) {
	
					// The ray and segment are not parallel.
	
					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;
	
					if ( s0 >= 0 ) {
	
						if ( s1 >= - extDet ) {
	
							if ( s1 <= extDet ) {
	
								// region 0
								// Minimum at interior points of ray and segment.
	
								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 1
	
								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							// region 5
	
							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					} else {
	
						if ( s1 <= - extDet ) {
	
							// region 4
	
							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						} else if ( s1 <= extDet ) {
	
							// region 3
	
							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
						} else {
	
							// region 2
	
							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					}
	
				} else {
	
					// Ray and segment are parallel.
	
					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
				}
	
				if ( optionalPointOnRay ) {
	
					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
				}
	
				if ( optionalPointOnSegment ) {
	
					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
				}
	
				return sqrDist;
	
			};
	
		}(),
	
		intersectSphere: function () {
	
			var v1 = new THREE.Vector3();
	
			return function intersectSphere( sphere, optionalTarget ) {
	
				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;
	
				if ( d2 > radius2 ) return null;
	
				var thc = Math.sqrt( radius2 - d2 );
	
				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;
	
				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;
	
				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;
	
				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );
	
				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, optionalTarget );
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
		},
	
		distanceToPlane: function ( plane ) {
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator === 0 ) {
	
				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {
	
					return 0;
	
				}
	
				// Null is preferable to undefined since undefined means.... it is undefined
	
				return null;
	
			}
	
			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
			// Return if the ray never intersects the plane
	
			return t >= 0 ? t :  null;
	
		},
	
		intersectPlane: function ( plane, optionalTarget ) {
	
			var t = this.distanceToPlane( plane );
	
			if ( t === null ) {
	
				return null;
	
			}
	
			return this.at( t, optionalTarget );
	
		},
	
	
	
		intersectsPlane: function ( plane ) {
	
			// check if the ray lies on the plane first
	
			var distToPoint = plane.distanceToPoint( this.origin );
	
			if ( distToPoint === 0 ) {
	
				return true;
	
			}
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator * distToPoint < 0 ) {
	
				return true;
	
			}
	
			// ray origin is behind the plane (and is pointing behind it)
	
			return false;
	
		},
	
		intersectBox: function ( box, optionalTarget ) {
	
			var tmin, tmax, tymin, tymax, tzmin, tzmax;
	
			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;
	
			var origin = this.origin;
	
			if ( invdirx >= 0 ) {
	
				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;
	
			} else {
	
				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
	
			}
	
			if ( invdiry >= 0 ) {
	
				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;
	
			} else {
	
				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
	
			}
	
			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN
	
			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
			if ( invdirz >= 0 ) {
	
				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;
	
			} else {
	
				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
	
			}
	
			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
			//return point closest to the ray (positive side)
	
			if ( tmax < 0 ) return null;
	
			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
		},
	
		intersectsBox: ( function () {
	
			var v = new THREE.Vector3();
	
			return function intersectsBox( box ) {
	
				return this.intersectBox( box, v ) !== null;
	
			};
	
		} )(),
	
		intersectTriangle: function () {
	
			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();
	
			return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {
	
				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	
				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );
	
				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;
	
				if ( DdN > 0 ) {
	
					if ( backfaceCulling ) return null;
					sign = 1;
	
				} else if ( DdN < 0 ) {
	
					sign = - 1;
					DdN = - DdN;
	
				} else {
	
					return null;
	
				}
	
				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {
	
					return null;
	
				}
	
				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {
	
					return null;
	
				}
	
				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {
	
					return null;
	
				}
	
				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );
	
				// t < 0, no intersection
				if ( QdN < 0 ) {
	
					return null;
	
				}
	
				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );
	
			};
	
		}(),
	
		applyMatrix4: function ( matrix4 ) {
	
			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();
	
			return this;
	
		},
	
		equals: function ( ray ) {
	
			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
		}
	
	};
	
	// File:src/math/Sphere.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Sphere = function ( center, radius ) {
	
		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;
	
	};
	
	THREE.Sphere.prototype = {
	
		constructor: THREE.Sphere,
	
		set: function ( center, radius ) {
	
			this.center.copy( center );
			this.radius = radius;
	
			return this;
	
		},
	
		setFromPoints: function () {
	
			var box = new THREE.Box3();
	
			return function setFromPoints( points, optionalCenter ) {
	
				var center = this.center;
	
				if ( optionalCenter !== undefined ) {
	
					center.copy( optionalCenter );
	
				} else {
	
					box.setFromPoints( points ).center( center );
	
				}
	
				var maxRadiusSq = 0;
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
				}
	
				this.radius = Math.sqrt( maxRadiusSq );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( sphere ) {
	
			this.center.copy( sphere.center );
			this.radius = sphere.radius;
	
			return this;
	
		},
	
		empty: function () {
	
			return ( this.radius <= 0 );
	
		},
	
		containsPoint: function ( point ) {
	
			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return ( point.distanceTo( this.center ) - this.radius );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			var radiusSum = this.radius + sphere.radius;
	
			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
		},
	
		intersectsBox: function ( box ) {
	
			return box.intersectsSphere( this );
	
		},
	
		intersectsPlane: function ( plane ) {
	
			// We use the following equation to compute the signed distance from
			// the center of the sphere to the plane.
			//
			// distance = q * n - d
			//
			// If this distance is greater than the radius of the sphere,
			// then there is no intersection.
	
			return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var deltaLengthSq = this.center.distanceToSquared( point );
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.copy( point );
	
			if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );
	
			}
	
			return result;
	
		},
	
		getBoundingBox: function ( optionalTarget ) {
	
			var box = optionalTarget || new THREE.Box3();
	
			box.set( this.center, this.center );
			box.expandByScalar( this.radius );
	
			return box;
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.center.add( offset );
	
			return this;
	
		},
	
		equals: function ( sphere ) {
	
			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
		}
	
	};
	
	// File:src/math/Frustum.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {
	
		this.planes = [
	
			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()
	
		];
	
	};
	
	THREE.Frustum.prototype = {
	
		constructor: THREE.Frustum,
	
		set: function ( p0, p1, p2, p3, p4, p5 ) {
	
			var planes = this.planes;
	
			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( frustum ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				planes[ i ].copy( frustum.planes[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromMatrix: function ( m ) {
	
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
			return this;
	
		},
	
		intersectsObject: function () {
	
			var sphere = new THREE.Sphere();
	
			return function intersectsObject( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere )
					.applyMatrix4( object.matrixWorld );
	
				return this.intersectsSphere( sphere );
	
			};
	
		}(),
	
		intersectsSprite: function () {
	
			var sphere = new THREE.Sphere();
	
			return function intersectsSprite( sprite ) {
	
				sphere.center.set( 0, 0, 0 );
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4( sprite.matrixWorld );
	
				return this.intersectsSphere( sphere );
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				var distance = planes[ i ].distanceToPoint( center );
	
				if ( distance < negRadius ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		intersectsBox: function () {
	
			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();
	
			return function intersectsBox( box ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6 ; i ++ ) {
	
					var plane = planes[ i ];
	
					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );
	
					// if both outside plane, no intersection
	
					if ( d1 < 0 && d2 < 0 ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			};
	
		}(),
	
	
		containsPoint: function ( point ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		}
	
	};
	
	// File:src/math/Plane.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Plane = function ( normal, constant ) {
	
		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;
	
	};
	
	THREE.Plane.prototype = {
	
		constructor: THREE.Plane,
	
		set: function ( normal, constant ) {
	
			this.normal.copy( normal );
			this.constant = constant;
	
			return this;
	
		},
	
		setComponents: function ( x, y, z, w ) {
	
			this.normal.set( x, y, z );
			this.constant = w;
	
			return this;
	
		},
	
		setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
			return this;
	
		},
	
		setFromCoplanarPoints: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
	
			return function setFromCoplanarPoints( a, b, c ) {
	
				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
				this.setFromNormalAndCoplanarPoint( normal, a );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( plane ) {
	
			this.normal.copy( plane.normal );
			this.constant = plane.constant;
	
			return this;
	
		},
	
		normalize: function () {
	
			// Note: will lead to a divide by zero if the plane is invalid.
	
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;
	
			return this;
	
		},
	
		negate: function () {
	
			this.constant *= - 1;
			this.normal.negate();
	
			return this;
	
		},
	
		distanceToPoint: function ( point ) {
	
			return this.normal.dot( point ) + this.constant;
	
		},
	
		distanceToSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) - sphere.radius;
	
		},
	
		projectPoint: function ( point, optionalTarget ) {
	
			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
		},
	
		orthoPoint: function ( point, optionalTarget ) {
	
			var perpendicularMagnitude = this.distanceToPoint( point );
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
		},
	
		intersectLine: function () {
	
			var v1 = new THREE.Vector3();
	
			return function intersectLine( line, optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				var direction = line.delta( v1 );
	
				var denominator = this.normal.dot( direction );
	
				if ( denominator === 0 ) {
	
					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {
	
						return result.copy( line.start );
	
					}
	
					// Unsure if this is the correct method to handle this case.
					return undefined;
	
				}
	
				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
				if ( t < 0 || t > 1 ) {
	
					return undefined;
	
				}
	
				return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
			};
	
		}(),
	
		intersectsLine: function ( line ) {
	
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );
	
			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
		},
	
		intersectsBox: function ( box ) {
	
			return box.intersectsPlane( this );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			return sphere.intersectsPlane( this );
	
		},
	
		coplanarPoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );
	
		},
	
		applyMatrix4: function () {
	
			var v1 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();
	
			return function applyMatrix4( matrix, optionalNormalMatrix ) {
	
				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );
	
				// transform normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
	
				// recalculate constant (like in setFromNormalAndCoplanarPoint)
				this.constant = - referencePoint.dot( normal );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.constant = this.constant - offset.dot( this.normal );
	
			return this;
	
		},
	
		equals: function ( plane ) {
	
			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	
		}
	
	};
	
	// File:src/math/Spherical.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The poles (phi) are at the positive and negative y axis.
	 * The equator starts at positive z.
	 */
	
	THREE.Spherical = function ( radius, phi, theta ) {
	
		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
		this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere
	
		return this;
	
	};
	
	THREE.Spherical.prototype = {
	
		constructor: THREE.Spherical,
	
		set: function ( radius, phi, theta ) {
	
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( other ) {
	
			this.radius.copy( other.radius );
			this.phi.copy( other.phi );
			this.theta.copy( other.theta );
	
			return this;
	
		},
	
		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function() {
	
			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
	
			return this;
	
		},
	
		setFromVector3: function( vec3 ) {
	
			this.radius = vec3.length();
	
			if ( this.radius === 0 ) {
	
				this.theta = 0;
				this.phi = 0;
	
			} else {
	
				this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
				this.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle
	
			}
	
			return this;
	
		},
	
	};
	
	// File:src/math/Math.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Math = {
	
		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,
	
		generateUUID: function () {
	
			// http://www.broofa.com/Tools/Math.uuid.htm
	
			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;
	
			return function generateUUID() {
	
				for ( var i = 0; i < 36; i ++ ) {
	
					if ( i === 8 || i === 13 || i === 18 || i === 23 ) {
	
						uuid[ i ] = '-';
	
					} else if ( i === 14 ) {
	
						uuid[ i ] = '4';
	
					} else {
	
						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
					}
	
				}
	
				return uuid.join( '' );
	
			};
	
		}(),
	
		clamp: function ( value, min, max ) {
	
			return Math.max( min, Math.min( max, value ) );
	
		},
	
		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation
	
		euclideanModulo: function ( n, m ) {
	
			return ( ( n % m ) + m ) % m;
	
		},
	
		// Linear mapping from range <a1, a2> to range <b1, b2>
	
		mapLinear: function ( x, a1, a2, b1, b2 ) {
	
			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
		},
	
		// http://en.wikipedia.org/wiki/Smoothstep
	
		smoothstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * ( 3 - 2 * x );
	
		},
	
		smootherstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
		},
	
		random16: function () {
	
			console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();
	
		},
	
		// Random integer from <low, high> interval
	
		randInt: function ( low, high ) {
	
			return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
		},
	
		// Random float from <low, high> interval
	
		randFloat: function ( low, high ) {
	
			return low + Math.random() * ( high - low );
	
		},
	
		// Random float from <-range/2, range/2> interval
	
		randFloatSpread: function ( range ) {
	
			return range * ( 0.5 - Math.random() );
	
		},
	
		degToRad: function ( degrees ) {
	
			return degrees * THREE.Math.DEG2RAD;
	
		},
	
		radToDeg: function ( radians ) {
	
			return radians * THREE.Math.RAD2DEG;
	
		},
	
		isPowerOfTwo: function ( value ) {
	
			return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
		},
	
		nearestPowerOfTwo: function ( value ) {
	
			return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );
	
		},
	
		nextPowerOfTwo: function ( value ) {
	
			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;
	
			return value;
	
		}
	
	};
	
	// File:src/math/Spline.js
	
	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Spline = function ( points ) {
	
		this.points = points;
	
		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		this.initFromArray = function ( a ) {
	
			this.points = [];
	
			for ( var i = 0; i < a.length; i ++ ) {
	
				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };
	
			}
	
		};
	
		this.getPoint = function ( k ) {
	
			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;
	
			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
	
			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];
	
			w2 = weight * weight;
			w3 = weight * w2;
	
			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );
	
			return v3;
	
		};
	
		this.getControlPointsArray = function () {
	
			var i, p, l = this.points.length,
				coords = [];
	
			for ( i = 0; i < l; i ++ ) {
	
				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];
	
			}
	
			return coords;
	
		};
	
		// approximate length by summing linear segments
	
		this.getLength = function ( nSubDivisions ) {
	
			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;
	
			// first point has 0 length
	
			chunkLengths[ 0 ] = 0;
	
			if ( ! nSubDivisions ) nSubDivisions = 100;
	
			nSamples = this.points.length * nSubDivisions;
	
			oldPosition.copy( this.points[ 0 ] );
	
			for ( i = 1; i < nSamples; i ++ ) {
	
				index = i / nSamples;
	
				position = this.getPoint( index );
				tmpVec.copy( position );
	
				totalLength += tmpVec.distanceTo( oldPosition );
	
				oldPosition.copy( position );
	
				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );
	
				if ( intPoint !== oldIntPoint ) {
	
					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;
	
				}
	
			}
	
			// last point ends with total length
	
			chunkLengths[ chunkLengths.length ] = totalLength;
	
			return { chunks: chunkLengths, total: totalLength };
	
		};
	
		this.reparametrizeByArcLength = function ( samplingCoef ) {
	
			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();
	
			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );
	
			for ( i = 1; i < this.points.length; i ++ ) {
	
				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );
	
				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];
	
				sampling = Math.ceil( samplingCoef * realDistance / sl.total );
	
				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );
	
				for ( j = 1; j < sampling - 1; j ++ ) {
	
					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );
	
					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );
	
				}
	
				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );
	
			}
	
			this.points = newpoints;
	
		};
	
		// Catmull-Rom
	
		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;
	
			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	// File:src/math/Triangle.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Triangle = function ( a, b, c ) {
	
		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();
	
	};
	
	THREE.Triangle.normal = function () {
	
		var v0 = new THREE.Vector3();
	
		return function normal( a, b, c, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );
	
			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {
	
				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
			}
	
			return result.set( 0, 0, 0 );
	
		};
	
	}();
	
	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {
	
		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function barycoordFromPoint( point, a, b, c, optionalTarget ) {
	
			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );
	
			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );
	
			var denom = ( dot00 * dot11 - dot01 * dot01 );
	
			var result = optionalTarget || new THREE.Vector3();
	
			// collinear or singular triangle
			if ( denom === 0 ) {
	
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );
	
			}
	
			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
			// barycentric coordinates must always sum to 1
			return result.set( 1 - u - v, v, u );
	
		};
	
	}();
	
	THREE.Triangle.containsPoint = function () {
	
		var v1 = new THREE.Vector3();
	
		return function containsPoint( point, a, b, c ) {
	
			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
		};
	
	}();
	
	THREE.Triangle.prototype = {
	
		constructor: THREE.Triangle,
	
		set: function ( a, b, c ) {
	
			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );
	
			return this;
	
		},
	
		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( triangle ) {
	
			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );
	
			return this;
	
		},
	
		area: function () {
	
			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();
	
			return function area() {
	
				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );
	
				return v0.cross( v1 ).length() * 0.5;
	
			};
	
		}(),
	
		midpoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
		},
	
		normal: function ( optionalTarget ) {
	
			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
		},
	
		plane: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Plane();
	
			return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
		},
	
		barycoordFromPoint: function ( point, optionalTarget ) {
	
			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
		},
	
		containsPoint: function ( point ) {
	
			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );
	
		},
	
		closestPointToPoint: function () {
	
			var plane, edgeList, projectedPoint, closestPoint;
	
			return function closestPointToPoint( point, optionalTarget ) {
	
				if ( plane === undefined ) {
	
					plane = new THREE.Plane();
					edgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];
					projectedPoint = new THREE.Vector3();
					closestPoint = new THREE.Vector3();
	
				}
	
				var result = optionalTarget || new THREE.Vector3();
				var minDistance = Infinity;
	
				// project the point onto the plane of the triangle
	
				plane.setFromCoplanarPoints( this.a, this.b, this.c );
				plane.projectPoint( point, projectedPoint );
	
				// check if the projection lies within the triangle
	
				if( this.containsPoint( projectedPoint ) === true ) {
	
					// if so, this is the closest point
	
					result.copy( projectedPoint );
	
				} else {
	
					// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
	
					edgeList[ 0 ].set( this.a, this.b );
					edgeList[ 1 ].set( this.b, this.c );
					edgeList[ 2 ].set( this.c, this.a );
	
					for( var i = 0; i < edgeList.length; i ++ ) {
	
						edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );
	
						var distance = projectedPoint.distanceToSquared( closestPoint );
	
						if( distance < minDistance ) {
	
							minDistance = distance;
	
							result.copy( closestPoint );
	
						}
	
					}
	
				}
	
				return result;
	
			};
	
		}(),
	
		equals: function ( triangle ) {
	
			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
		}
	
	};
	
	// File:src/math/Interpolant.js
	
	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */
	
	THREE.Interpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;
	
		this.resultBuffer = resultBuffer !== undefined ?
				resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;
	
	};
	
	THREE.Interpolant.prototype = {
	
		constructor: THREE.Interpolant,
	
		evaluate: function( t ) {
	
			var pp = this.parameterPositions,
				i1 = this._cachedIndex,
	
				t1 = pp[   i1   ],
				t0 = pp[ i1 - 1 ];
	
			validate_interval: {
	
				seek: {
	
					var right;
	
					linear_scan: {
	//- See http://jsperf.com/comparison-to-undefined/3
	//- slower code:
	//-
	//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {
	
							for ( var giveUpAt = i1 + 2; ;) {
	
								if ( t1 === undefined ) {
	
									if ( t < t0 ) break forward_scan;
	
									// after end
	
									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );
	
								}
	
								if ( i1 === giveUpAt ) break; // this loop
	
								t0 = t1;
								t1 = pp[ ++ i1 ];
	
								if ( t < t1 ) {
	
									// we have arrived at the sought interval
									break seek;
	
								}
	
							}
	
							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;
	
						}
	
	//- slower code:
	//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {
	
							// looping?
	
							var t1global = pp[ 1 ];
	
							if ( t < t1global ) {
	
								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;
	
							}
	
							// linear reverse scan
	
							for ( var giveUpAt = i1 - 2; ;) {
	
								if ( t0 === undefined ) {
	
									// before start
	
									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );
	
								}
	
								if ( i1 === giveUpAt ) break; // this loop
	
								t1 = t0;
								t0 = pp[ -- i1 - 1 ];
	
								if ( t >= t0 ) {
	
									// we have arrived at the sought interval
									break seek;
	
								}
	
							}
	
							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;
	
						}
	
						// the interval is valid
	
						break validate_interval;
	
					} // linear scan
	
					// binary search
	
					while ( i1 < right ) {
	
						var mid = ( i1 + right ) >>> 1;
	
						if ( t < pp[ mid ] ) {
	
							right = mid;
	
						} else {
	
							i1 = mid + 1;
	
						}
	
					}
	
					t1 = pp[   i1   ];
					t0 = pp[ i1 - 1 ];
	
					// check boundary cases, again
	
					if ( t0 === undefined ) {
	
						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );
	
					}
	
					if ( t1 === undefined ) {
	
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );
	
					}
	
				} // seek
	
				this._cachedIndex = i1;
	
				this.intervalChanged_( i1, t0, t1 );
	
			} // validate_interval
	
			return this.interpolate_( i1, t0, t, t1 );
	
		},
	
		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.
	
		// --- Protected interface
	
		DefaultSettings_: {},
	
		getSettings_: function() {
	
			return this.settings || this.DefaultSettings_;
	
		},
	
		copySampleValue_: function( index ) {
	
			// copies a sample value to the result buffer
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] = values[ offset + i ];
	
			}
	
			return result;
	
		},
	
		// Template methods for derived classes:
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			throw new Error( "call to abstract method" );
			// implementations shall return this.resultBuffer
	
		},
	
		intervalChanged_: function( i1, t0, t1 ) {
	
			// empty
	
		}
	
	};
	
	Object.assign( THREE.Interpolant.prototype, {
	
		beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
			THREE.Interpolant.prototype.copySampleValue_,
	
		afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
			THREE.Interpolant.prototype.copySampleValue_
	
	} );
	
	// File:src/math/interpolants/CubicInterpolant.js
	
	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */
	
	THREE.CubicInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		this._weightPrev = -0;
		this._offsetPrev = -0;
		this._weightNext = -0;
		this._offsetNext = -0;
	
	};
	
	THREE.CubicInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.CubicInterpolant,
	
		DefaultSettings_: {
	
			endingStart: 	THREE.ZeroCurvatureEnding,
			endingEnd:		THREE.ZeroCurvatureEnding
	
		},
	
		intervalChanged_: function( i1, t0, t1 ) {
	
			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,
	
				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];
	
			if ( tPrev === undefined ) {
	
				switch ( this.getSettings_().endingStart ) {
	
					case THREE.ZeroSlopeEnding:
	
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
	
						break;
	
					case THREE.WrapAroundEnding:
	
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
	
						break;
	
					default: // ZeroCurvatureEnding
	
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
	
				}
	
			}
	
			if ( tNext === undefined ) {
	
				switch ( this.getSettings_().endingEnd ) {
	
					case THREE.ZeroSlopeEnding:
	
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
	
						break;
	
					case THREE.WrapAroundEnding:
	
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];
	
						break;
	
					default: // ZeroCurvatureEnding
	
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
	
				}
	
			}
	
			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;
	
			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
	
		},
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,
	
				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;
	
			// evaluate polynomials
	
			var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
			var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
			var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
			var sN =       wN   * ppp   -           wN      * pp;
	
			// combine data linearly
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];
	
			}
	
			return result;
	
		}
	
	} );
	
	// File:src/math/interpolants/DiscreteInterpolant.js
	
	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */
	
	THREE.DiscreteInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	};
	
	THREE.DiscreteInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.DiscreteInterpolant,
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			return this.copySampleValue_( i1 - 1 );
	
		}
	
	} );
	
	// File:src/math/interpolants/LinearInterpolant.js
	
	/**
	 * @author tschw
	 */
	
	THREE.LinearInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	};
	
	THREE.LinearInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.LinearInterpolant,
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				offset1 = i1 * stride,
				offset0 = offset1 - stride,
	
				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;
	
			}
	
			return result;
	
		}
	
	} );
	
	// File:src/math/interpolants/QuaternionLinearInterpolant.js
	
	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */
	
	THREE.QuaternionLinearInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	};
	
	THREE.QuaternionLinearInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.QuaternionLinearInterpolant,
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				offset = i1 * stride,
	
				alpha = ( t - t0 ) / ( t1 - t0 );
	
			for ( var end = offset + stride; offset !== end; offset += 4 ) {
	
				THREE.Quaternion.slerpFlat( result, 0,
						values, offset - stride, values, offset, alpha );
	
			}
	
			return result;
	
		}
	
	} );
	
	// File:src/core/Clock.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Clock = function ( autoStart ) {
	
		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
	
		this.running = false;
	
	};
	
	THREE.Clock.prototype = {
	
		constructor: THREE.Clock,
	
		start: function () {
	
			this.startTime = ( performance || Date ).now();
	
			this.oldTime = this.startTime;
			this.running = true;
	
		},
	
		stop: function () {
	
			this.getElapsedTime();
			this.running = false;
	
		},
	
		getElapsedTime: function () {
	
			this.getDelta();
			return this.elapsedTime;
	
		},
	
		getDelta: function () {
	
			var diff = 0;
	
			if ( this.autoStart && ! this.running ) {
	
				this.start();
	
			}
	
			if ( this.running ) {
	
				var newTime = ( performance || Date ).now();
	
				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;
	
				this.elapsedTime += diff;
	
			}
	
			return diff;
	
		}
	
	};
	
	// File:src/core/EventDispatcher.js
	
	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	
	THREE.EventDispatcher = function () {};
	
	Object.assign( THREE.EventDispatcher.prototype, {
	
		addEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) this._listeners = {};
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] === undefined ) {
	
				listeners[ type ] = [];
	
			}
	
			if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
				listeners[ type ].push( listener );
	
			}
	
		},
	
		hasEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return false;
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		removeEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ type ];
	
			if ( listenerArray !== undefined ) {
	
				var index = listenerArray.indexOf( listener );
	
				if ( index !== - 1 ) {
	
					listenerArray.splice( index, 1 );
	
				}
	
			}
	
		},
	
		dispatchEvent: function ( event ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];
	
			if ( listenerArray !== undefined ) {
	
				event.target = this;
	
				var array = [], i = 0;
				var length = listenerArray.length;
	
				for ( i = 0; i < length; i ++ ) {
	
					array[ i ] = listenerArray[ i ];
	
				}
	
				for ( i = 0; i < length; i ++ ) {
	
					array[ i ].call( this, event );
	
				}
	
			}
	
		}
	
	} );
	
	// File:src/core/Layers.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Layers = function () {
	
		this.mask = 1;
	
	};
	
	THREE.Layers.prototype = {
	
		constructor: THREE.Layers,
	
		set: function ( channel ) {
	
			this.mask = 1 << channel;
	
		},
	
		enable: function ( channel ) {
	
			this.mask |= 1 << channel;
	
		},
	
		toggle: function ( channel ) {
	
			this.mask ^= 1 << channel;
	
		},
	
		disable: function ( channel ) {
	
			this.mask &= ~ ( 1 << channel );
	
		},
	
		test: function ( layers ) {
	
			return ( this.mask & layers.mask ) !== 0;
	
		}
	
	};
	
	// File:src/core/Raycaster.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */
	
	( function ( THREE ) {
	
		THREE.Raycaster = function ( origin, direction, near, far ) {
	
			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};
	
			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );
	
		};
	
		function ascSort( a, b ) {
	
			return a.distance - b.distance;
	
		}
	
		function intersectObject( object, raycaster, intersects, recursive ) {
	
			if ( object.visible === false ) return;
	
			object.raycast( raycaster, intersects );
	
			if ( recursive === true ) {
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					intersectObject( children[ i ], raycaster, intersects, true );
	
				}
	
			}
	
		}
	
		//
	
		THREE.Raycaster.prototype = {
	
			constructor: THREE.Raycaster,
	
			linePrecision: 1,
	
			set: function ( origin, direction ) {
	
				// direction is assumed to be normalized (for accurate distance calculations)
	
				this.ray.set( origin, direction );
	
			},
	
			setFromCamera: function ( coords, camera ) {
	
				if ( camera instanceof THREE.PerspectiveCamera ) {
	
					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
	
				} else if ( camera instanceof THREE.OrthographicCamera ) {
	
					this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
				} else {
	
					console.error( 'THREE.Raycaster: Unsupported camera type.' );
	
				}
	
			},
	
			intersectObject: function ( object, recursive ) {
	
				var intersects = [];
	
				intersectObject( object, this, intersects, recursive );
	
				intersects.sort( ascSort );
	
				return intersects;
	
			},
	
			intersectObjects: function ( objects, recursive ) {
	
				var intersects = [];
	
				if ( Array.isArray( objects ) === false ) {
	
					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;
	
				}
	
				for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
					intersectObject( objects[ i ], this, intersects, recursive );
	
				}
	
				intersects.sort( ascSort );
	
				return intersects;
	
			}
	
		};
	
	}( THREE ) );
	
	// File:src/core/Object3D.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */
	
	THREE.Object3D = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Object3D';
	
		this.parent = null;
		this.children = [];
	
		this.up = THREE.Object3D.DefaultUp.clone();
	
		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );
	
		function onRotationChange() {
	
			quaternion.setFromEuler( rotation, false );
	
		}
	
		function onQuaternionChange() {
	
			rotation.setFromQuaternion( quaternion, undefined, false );
	
		}
	
		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );
	
		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new THREE.Matrix4()
			},
			normalMatrix: {
				value: new THREE.Matrix3()
			}
		} );
	
		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();
	
		this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;
	
		this.layers = new THREE.Layers();
		this.visible = true;
	
		this.castShadow = false;
		this.receiveShadow = false;
	
		this.frustumCulled = true;
		this.renderOrder = 0;
	
		this.userData = {};
	
	};
	
	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
	THREE.Object3D.DefaultMatrixAutoUpdate = true;
	
	Object.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {
	
		applyMatrix: function ( matrix ) {
	
			this.matrix.multiplyMatrices( matrix, this.matrix );
	
			this.matrix.decompose( this.position, this.quaternion, this.scale );
	
		},
	
		setRotationFromAxisAngle: function ( axis, angle ) {
	
			// assumes axis is normalized
	
			this.quaternion.setFromAxisAngle( axis, angle );
	
		},
	
		setRotationFromEuler: function ( euler ) {
	
			this.quaternion.setFromEuler( euler, true );
	
		},
	
		setRotationFromMatrix: function ( m ) {
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			this.quaternion.setFromRotationMatrix( m );
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			// assumes q is normalized
	
			this.quaternion.copy( q );
	
		},
	
		rotateOnAxis: function () {
	
			// rotate object on axis in object space
			// axis is assumed to be normalized
	
			var q1 = new THREE.Quaternion();
	
			return function rotateOnAxis( axis, angle ) {
	
				q1.setFromAxisAngle( axis, angle );
	
				this.quaternion.multiply( q1 );
	
				return this;
	
			};
	
		}(),
	
		rotateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function rotateX( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function rotateY( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function rotateZ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		translateOnAxis: function () {
	
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
	
			var v1 = new THREE.Vector3();
	
			return function translateOnAxis( axis, distance ) {
	
				v1.copy( axis ).applyQuaternion( this.quaternion );
	
				this.position.add( v1.multiplyScalar( distance ) );
	
				return this;
	
			};
	
		}(),
	
		translateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function translateX( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function translateY( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function translateZ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		localToWorld: function ( vector ) {
	
			return vector.applyMatrix4( this.matrixWorld );
	
		},
	
		worldToLocal: function () {
	
			var m1 = new THREE.Matrix4();
	
			return function worldToLocal( vector ) {
	
				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
			};
	
		}(),
	
		lookAt: function () {
	
			// This routine does not support objects with rotated and/or translated parent(s)
	
			var m1 = new THREE.Matrix4();
	
			return function lookAt( vector ) {
	
				m1.lookAt( vector, this.position, this.up );
	
				this.quaternion.setFromRotationMatrix( m1 );
	
			};
	
		}(),
	
		add: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.add( arguments[ i ] );
	
				}
	
				return this;
	
			}
	
			if ( object === this ) {
	
				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;
	
			}
	
			if ( object instanceof THREE.Object3D ) {
	
				if ( object.parent !== null ) {
	
					object.parent.remove( object );
	
				}
	
				object.parent = this;
				object.dispatchEvent( { type: 'added' } );
	
				this.children.push( object );
	
			} else {
	
				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
			}
	
			return this;
	
		},
	
		remove: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.remove( arguments[ i ] );
	
				}
	
			}
	
			var index = this.children.indexOf( object );
	
			if ( index !== - 1 ) {
	
				object.parent = null;
	
				object.dispatchEvent( { type: 'removed' } );
	
				this.children.splice( index, 1 );
	
			}
	
		},
	
		getObjectById: function ( id ) {
	
			return this.getObjectByProperty( 'id', id );
	
		},
	
		getObjectByName: function ( name ) {
	
			return this.getObjectByProperty( 'name', name );
	
		},
	
		getObjectByProperty: function ( name, value ) {
	
			if ( this[ name ] === value ) return this;
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );
	
				if ( object !== undefined ) {
	
					return object;
	
				}
	
			}
	
			return undefined;
	
		},
	
		getWorldPosition: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.updateMatrixWorld( true );
	
			return result.setFromMatrixPosition( this.matrixWorld );
	
		},
	
		getWorldQuaternion: function () {
	
			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();
	
			return function getWorldQuaternion( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Quaternion();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, result, scale );
	
				return result;
	
			};
	
		}(),
	
		getWorldRotation: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function getWorldRotation( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Euler();
	
				this.getWorldQuaternion( quaternion );
	
				return result.setFromQuaternion( quaternion, this.rotation.order, false );
	
			};
	
		}(),
	
		getWorldScale: function () {
	
			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();
	
			return function getWorldScale( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, quaternion, result );
	
				return result;
	
			};
	
		}(),
	
		getWorldDirection: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function getWorldDirection( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.getWorldQuaternion( quaternion );
	
				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
			};
	
		}(),
	
		raycast: function () {},
	
		traverse: function ( callback ) {
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverse( callback );
	
			}
	
		},
	
		traverseVisible: function ( callback ) {
	
			if ( this.visible === false ) return;
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverseVisible( callback );
	
			}
	
		},
	
		traverseAncestors: function ( callback ) {
	
			var parent = this.parent;
	
			if ( parent !== null ) {
	
				callback( parent );
	
				parent.traverseAncestors( callback );
	
			}
	
		},
	
		updateMatrix: function () {
	
			this.matrix.compose( this.position, this.quaternion, this.scale );
	
			this.matrixWorldNeedsUpdate = true;
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
			if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
				if ( this.parent === null ) {
	
					this.matrixWorld.copy( this.matrix );
	
				} else {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				}
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].updateMatrixWorld( force );
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			// meta is '' when called from JSON.stringify
			var isRootObject = ( meta === undefined || meta === '' );
	
			var output = {};
	
			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {
	
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {}
				};
	
				output.metadata = {
					version: 4.4,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
	
			}
	
			// standard Object3D serialization
	
			var object = {};
	
			object.uuid = this.uuid;
			object.type = this.type;
	
			if ( this.name !== '' ) object.name = this.name;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
	
			object.matrix = this.matrix.toArray();
	
			//
	
			if ( this.geometry !== undefined ) {
	
				if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
	
					meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );
	
				}
	
				object.geometry = this.geometry.uuid;
	
			}
	
			if ( this.material !== undefined ) {
	
				if ( meta.materials[ this.material.uuid ] === undefined ) {
	
					meta.materials[ this.material.uuid ] = this.material.toJSON( meta );
	
				}
	
				object.material = this.material.uuid;
	
			}
	
			//
	
			if ( this.children.length > 0 ) {
	
				object.children = [];
	
				for ( var i = 0; i < this.children.length; i ++ ) {
	
					object.children.push( this.children[ i ].toJSON( meta ).object );
	
				}
	
			}
	
			if ( isRootObject ) {
	
				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
	
				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
	
			}
	
			output.object = object;
	
			return output;
	
			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache ( cache ) {
	
				var values = [];
				for ( var key in cache ) {
	
					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
	
				}
				return values;
	
			}
	
		},
	
		clone: function ( recursive ) {
	
			return new this.constructor().copy( this, recursive );
	
		},
	
		copy: function ( source, recursive ) {
	
			if ( recursive === undefined ) recursive = true;
	
			this.name = source.name;
	
			this.up.copy( source.up );
	
			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );
	
			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );
	
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	
			this.visible = source.visible;
	
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
	
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
	
			this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
			if ( recursive === true ) {
	
				for ( var i = 0; i < source.children.length; i ++ ) {
	
					var child = source.children[ i ];
					this.add( child.clone() );
	
				}
	
			}
	
			return this;
	
		}
	
	} );
	
	THREE.Object3DIdCount = 0;
	
	// File:src/core/Face3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {
	
		this.a = a;
		this.b = b;
		this.c = c;
	
		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];
	
		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = Array.isArray( color ) ? color : [];
	
		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
	};
	
	THREE.Face3.prototype = {
	
		constructor: THREE.Face3,
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.a = source.a;
			this.b = source.b;
			this.c = source.c;
	
			this.normal.copy( source.normal );
			this.color.copy( source.color );
	
			this.materialIndex = source.materialIndex;
	
			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
	
				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
	
			}
	
			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
	
				this.vertexColors[ i ] = source.vertexColors[ i ].clone();
	
			}
	
			return this;
	
		}
	
	};
	
	// File:src/core/BufferAttribute.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferAttribute = function ( array, itemSize, normalized ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.array = array;
		this.itemSize = itemSize;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
		this.normalized = normalized === true;
	
	};
	
	THREE.BufferAttribute.prototype = {
	
		constructor: THREE.BufferAttribute,
	
		get count() {
	
			return this.array.length / this.itemSize;
	
		},
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
	
			this.dynamic = source.dynamic;
	
			return this;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;
	
			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		copyArray: function ( array ) {
	
			this.array.set( array );
	
			return this;
	
		},
	
		copyColorsArray: function ( colors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = colors.length; i < l; i ++ ) {
	
				var color = colors[ i ];
	
				if ( color === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new THREE.Color();
	
				}
	
				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;
	
			}
	
			return this;
	
		},
	
		copyIndicesArray: function ( indices ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
				var index = indices[ i ];
	
				array[ offset ++ ] = index.a;
				array[ offset ++ ] = index.b;
				array[ offset ++ ] = index.c;
	
			}
	
			return this;
	
		},
	
		copyVector2sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new THREE.Vector2();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
	
			}
	
			return this;
	
		},
	
		copyVector3sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new THREE.Vector3();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
	
			}
	
			return this;
	
		},
	
		copyVector4sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new THREE.Vector4();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.array[ index * this.itemSize ];
	
		},
	
		setX: function ( index, x ) {
	
			this.array[ index * this.itemSize ] = x;
	
			return this;
	
		},
	
		getY: function ( index ) {
	
			return this.array[ index * this.itemSize + 1 ];
	
		},
	
		setY: function ( index, y ) {
	
			this.array[ index * this.itemSize + 1 ] = y;
	
			return this;
	
		},
	
		getZ: function ( index ) {
	
			return this.array[ index * this.itemSize + 2 ];
	
		},
	
		setZ: function ( index, z ) {
	
			this.array[ index * this.itemSize + 2 ] = z;
	
			return this;
	
		},
	
		getW: function ( index ) {
	
			return this.array[ index * this.itemSize + 3 ];
	
		},
	
		setW: function ( index, w ) {
	
			this.array[ index * this.itemSize + 3 ] = w;
	
			return this;
	
		},
	
		setXY: function ( index, x, y ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	//
	
	THREE.Int8Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int8Array( array ), itemSize );
	
	};
	
	THREE.Uint8Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );
	
	};
	
	THREE.Uint8ClampedAttribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );
	
	};
	
	THREE.Int16Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int16Array( array ), itemSize );
	
	};
	
	THREE.Uint16Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );
	
	};
	
	THREE.Int32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int32Array( array ), itemSize );
	
	};
	
	THREE.Uint32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );
	
	};
	
	THREE.Float32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Float32Array( array ), itemSize );
	
	};
	
	THREE.Float64Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Float64Array( array ), itemSize );
	
	};
	
	
	// Deprecated
	
	THREE.DynamicBufferAttribute = function ( array, itemSize ) {
	
		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );
	
	};
	
	// File:src/core/InstancedBufferAttribute.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {
	
		THREE.BufferAttribute.call( this, array, itemSize );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	};
	
	THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
	
	THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {
	
		THREE.BufferAttribute.prototype.copy.call( this, source );
	
		this.meshPerAttribute = source.meshPerAttribute;
	
		return this;
	
	};
	
	// File:src/core/InterleavedBuffer.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InterleavedBuffer = function ( array, stride ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.array = array;
		this.stride = stride;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
	
	};
	
	THREE.InterleavedBuffer.prototype = {
	
		constructor: THREE.InterleavedBuffer,
	
		get length () {
	
			return this.array.length;
	
		},
	
		get count () {
	
			return this.array.length / this.stride;
	
		},
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.array = new source.array.constructor( source.array );
			this.stride = source.stride;
			this.dynamic = source.dynamic;
	
			return this;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.stride;
			index2 *= attribute.stride;
	
			for ( var i = 0, l = this.stride; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	// File:src/core/InstancedInterleavedBuffer.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {
	
		THREE.InterleavedBuffer.call( this, array, stride );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	};
	
	THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
	THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
	
	THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {
	
		THREE.InterleavedBuffer.prototype.copy.call( this, source );
	
		this.meshPerAttribute = source.meshPerAttribute;
	
		return this;
	
	};
	
	// File:src/core/InterleavedBufferAttribute.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset, normalized ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;
	
		this.normalized = normalized === true;
	
	};
	
	
	THREE.InterleavedBufferAttribute.prototype = {
	
		constructor: THREE.InterleavedBufferAttribute,
	
		get length() {
	
			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;
	
		},
	
		get count() {
	
			return this.data.count;
	
		},
	
		get array() {
	
			return this.data.array;
	
		},
	
		setX: function ( index, x ) {
	
			this.data.array[ index * this.data.stride + this.offset ] = x;
	
			return this;
	
		},
	
		setY: function ( index, y ) {
	
			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
	
			return this;
	
		},
	
		setZ: function ( index, z ) {
	
			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
	
			return this;
	
		},
	
		setW: function ( index, w ) {
	
			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset ];
	
		},
	
		getY: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 1 ];
	
		},
	
		getZ: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 2 ];
	
		},
	
		getW: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 3 ];
	
		},
	
		setXY: function ( index, x, y ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;
	
			return this;
	
		}
	
	};
	
	// File:src/core/Geometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Geometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Geometry';
	
		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];
	
		this.morphTargets = [];
		this.morphNormals = [];
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	};
	
	Object.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {
	
		applyMatrix: function ( matrix ) {
	
			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );
	
			}
	
			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
				}
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;
	
			return this;
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1;
	
			return function rotateX( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1;
	
			return function rotateY( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1;
	
			return function rotateZ( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1;
	
			return function translate( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1;
	
			return function scale( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj;
	
			return function lookAt( vector ) {
	
				if ( obj === undefined ) obj = new THREE.Object3D();
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		fromBufferGeometry: function ( geometry ) {
	
			var scope = this;
	
			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;
	
			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	
			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
	
			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];
	
			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {
	
				scope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );
	
				if ( normals !== undefined ) {
	
					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
	
				}
	
				if ( colors !== undefined ) {
	
					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
	
				}
	
				if ( uvs !== undefined ) {
	
					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );
	
				}
	
				if ( uvs2 !== undefined ) {
	
					tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
	
				}
	
			}
	
			function addFace( a, b, c, materialIndex ) {
	
				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
	
				var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );
	
				scope.faces.push( face );
	
				if ( uvs !== undefined ) {
	
					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
	
				}
	
				if ( uvs2 !== undefined ) {
	
					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
	
				}
	
			}
	
			if ( indices !== undefined ) {
	
				var groups = geometry.groups;
	
				if ( groups.length > 0 ) {
	
					for ( var i = 0; i < groups.length; i ++ ) {
	
						var group = groups[ i ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );
	
						}
	
					}
	
				} else {
	
					for ( var i = 0; i < indices.length; i += 3 ) {
	
						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
					}
	
				}
	
			} else {
	
				for ( var i = 0; i < positions.length / 3; i += 3 ) {
	
					addFace( i, i + 1, i + 2 );
	
				}
	
			}
	
			this.computeFaceNormals();
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			return this;
	
		},
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.translate( offset.x, offset.y, offset.z );
	
			return offset;
	
		},
	
		normalize: function () {
	
			this.computeBoundingSphere();
	
			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;
	
			var s = radius === 0 ? 1 : 1.0 / radius;
	
			var matrix = new THREE.Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);
	
			this.applyMatrix( matrix );
	
			return this;
	
		},
	
		computeFaceNormals: function () {
	
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				var face = this.faces[ f ];
	
				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];
	
				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
	
				cb.normalize();
	
				face.normal.copy( cb );
	
			}
	
		},
	
		computeVertexNormals: function ( areaWeighted ) {
	
			if ( areaWeighted === undefined ) areaWeighted = true;
	
			var v, vl, f, fl, face, vertices;
	
			vertices = new Array( this.vertices.length );
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ] = new THREE.Vector3();
	
			}
	
			if ( areaWeighted ) {
	
				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm
	
				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );
	
				}
	
			} else {
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );
	
				}
	
			}
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ].normalize();
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
				} else {
	
					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
				}
	
			}
	
			if ( this.faces.length > 0 ) {
	
				this.normalsNeedUpdate = true;
	
			}
	
		},
	
		computeMorphNormals: function () {
	
			var i, il, f, fl, face;
	
			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				if ( ! face.__originalFaceNormal ) {
	
					face.__originalFaceNormal = face.normal.clone();
	
				} else {
	
					face.__originalFaceNormal.copy( face.normal );
	
				}
	
				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
					if ( ! face.__originalVertexNormals[ i ] ) {
	
						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
					} else {
	
						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
					}
	
				}
	
			}
	
			// use temp geometry to compute face and vertex normals for each morph
	
			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;
	
			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
				// create on first access
	
				if ( ! this.morphNormals[ i ] ) {
	
					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];
	
					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };
	
						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );
	
					}
	
				}
	
				var morphNormals = this.morphNormals[ i ];
	
				// set vertices to morph target
	
				tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
				// compute morph normals
	
				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();
	
				// store morph normals
	
				var faceNormal, vertexNormals;
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];
	
					faceNormal.copy( face.normal );
	
					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
				}
	
			}
	
			// restore original normals
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
	
			}
	
		},
	
		computeTangents: function () {
	
			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );
	
		},
	
		computeLineDistances: function () {
	
			var d = 0;
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				if ( i > 0 ) {
	
					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
				}
	
				this.lineDistances[ i ] = d;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			this.boundingBox.setFromPoints( this.vertices );
	
		},
	
		computeBoundingSphere: function () {
	
			if ( this.boundingSphere === null ) {
	
				this.boundingSphere = new THREE.Sphere();
	
			}
	
			this.boundingSphere.setFromPoints( this.vertices );
	
		},
	
		merge: function ( geometry, matrix, materialIndexOffset ) {
	
			if ( geometry instanceof THREE.Geometry === false ) {
	
				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;
	
			}
	
			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];
	
			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
			if ( matrix !== undefined ) {
	
				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			}
	
			// vertices
	
			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
				var vertex = vertices2[ i ];
	
				var vertexCopy = vertex.clone();
	
				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
				vertices1.push( vertexCopy );
	
			}
	
			// faces
	
			for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;
	
				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );
	
				if ( normalMatrix !== undefined ) {
	
					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
				}
	
				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
					normal = faceVertexNormals[ j ].clone();
	
					if ( normalMatrix !== undefined ) {
	
						normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					faceCopy.vertexNormals.push( normal );
	
				}
	
				faceCopy.color.copy( face.color );
	
				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );
	
				}
	
				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
				faces1.push( faceCopy );
	
			}
	
			// uvs
	
			for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
				var uv = uvs2[ i ], uvCopy = [];
	
				if ( uv === undefined ) {
	
					continue;
	
				}
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( uv[ j ].clone() );
	
				}
	
				uvs1.push( uvCopy );
	
			}
	
		},
	
		mergeMesh: function ( mesh ) {
	
			if ( mesh instanceof THREE.Mesh === false ) {
	
				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;
	
			}
	
			mesh.matrixAutoUpdate && mesh.updateMatrix();
	
			this.merge( mesh.geometry, mesh.matrix );
	
		},
	
		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */
	
		mergeVertices: function () {
	
			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];
	
			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;
	
			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
				if ( verticesMap[ key ] === undefined ) {
	
					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;
	
				} else {
	
					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];
	
				}
	
			}
	
	
			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];
	
			for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
				face = this.faces[ i ];
	
				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
	
				indices = [ face.a, face.b, face.c ];
	
				var dupIndex = - 1;
	
				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
	
					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
	
						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;
	
					}
	
				}
	
			}
	
			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
				var idx = faceIndicesToRemove[ i ];
	
				this.faces.splice( idx, 1 );
	
				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
					this.faceVertexUvs[ j ].splice( idx, 1 );
	
				}
	
			}
	
			// Use unique set of vertices
	
			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
	
		},
	
		sortFacesByMaterialIndex: function () {
	
			var faces = this.faces;
			var length = faces.length;
	
			// tag faces
	
			for ( var i = 0; i < length; i ++ ) {
	
				faces[ i ]._id = i;
	
			}
	
			// sort faces
	
			function materialIndexSort( a, b ) {
	
				return a.materialIndex - b.materialIndex;
	
			}
	
			faces.sort( materialIndexSort );
	
			// sort uvs
	
			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];
	
			var newUvs1, newUvs2;
	
			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];
	
			for ( var i = 0; i < length; i ++ ) {
	
				var id = faces[ i ]._id;
	
				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
	
			}
	
			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};
	
			// standard Geometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			var vertices = [];
	
			for ( var i = 0; i < this.vertices.length; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};
	
			for ( var i = 0; i < this.faces.length; i ++ ) {
	
				var face = this.faces[ i ];
	
				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;
	
				var faceType = 0;
	
				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );
	
				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );
	
				if ( hasFaceVertexUv ) {
	
					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);
	
				}
	
				if ( hasFaceNormal ) {
	
					faces.push( getNormalIndex( face.normal ) );
	
				}
	
				if ( hasFaceVertexNormal ) {
	
					var vertexNormals = face.vertexNormals;
	
					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);
	
				}
	
				if ( hasFaceColor ) {
	
					faces.push( getColorIndex( face.color ) );
	
				}
	
				if ( hasFaceVertexColor ) {
	
					var vertexColors = face.vertexColors;
	
					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);
	
				}
	
			}
	
			function setBit( value, position, enabled ) {
	
				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
	
			}
	
			function getNormalIndex( normal ) {
	
				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
				if ( normalsHash[ hash ] !== undefined ) {
	
					return normalsHash[ hash ];
	
				}
	
				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );
	
				return normalsHash[ hash ];
	
			}
	
			function getColorIndex( color ) {
	
				var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
				if ( colorsHash[ hash ] !== undefined ) {
	
					return colorsHash[ hash ];
	
				}
	
				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );
	
				return colorsHash[ hash ];
	
			}
	
			function getUvIndex( uv ) {
	
				var hash = uv.x.toString() + uv.y.toString();
	
				if ( uvsHash[ hash ] !== undefined ) {
	
					return uvsHash[ hash ];
	
				}
	
				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );
	
				return uvsHash[ hash ];
	
			}
	
			data.data = {};
	
			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;
	
			return data;
	
		},
	
		clone: function () {
	
			/*
			// Handle primitives
	
			var parameters = this.parameters;
	
			if ( parameters !== undefined ) {
	
				var values = [];
	
				for ( var key in parameters ) {
	
					values.push( parameters[ key ] );
	
				}
	
				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;
	
			}
	
			return new this.constructor().copy( this );
			*/
	
			return new THREE.Geometry().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.vertices = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];
	
			var vertices = source.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				this.vertices.push( vertices[ i ].clone() );
	
			}
	
			var faces = source.faces;
	
			for ( var i = 0, il = faces.length; i < il; i ++ ) {
	
				this.faces.push( faces[ i ].clone() );
	
			}
	
			for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
	
				var faceVertexUvs = source.faceVertexUvs[ i ];
	
				if ( this.faceVertexUvs[ i ] === undefined ) {
	
					this.faceVertexUvs[ i ] = [];
	
				}
	
				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
					var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {
	
						var uv = uvs[ k ];
	
						uvsCopy.push( uv.clone() );
	
					}
	
					this.faceVertexUvs[ i ].push( uvsCopy );
	
				}
	
			}
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	} );
	
	THREE.GeometryIdCount = 0;
	
	// File:src/core/DirectGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.DirectGeometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'DirectGeometry';
	
		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];
	
		this.groups = [];
	
		this.morphTargets = {};
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		// this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	};
	
	Object.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {
	
		computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
		computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
	
		computeFaceNormals: function () {
	
			console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );
	
		},
	
		computeVertexNormals: function () {
	
			console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );
	
		},
	
		computeGroups: function ( geometry ) {
	
			var group;
			var groups = [];
			var materialIndex;
	
			var faces = geometry.faces;
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				// materials
	
				if ( face.materialIndex !== materialIndex ) {
	
					materialIndex = face.materialIndex;
	
					if ( group !== undefined ) {
	
						group.count = ( i * 3 ) - group.start;
						groups.push( group );
	
					}
	
					group = {
						start: i * 3,
						materialIndex: materialIndex
					};
	
				}
	
			}
	
			if ( group !== undefined ) {
	
				group.count = ( i * 3 ) - group.start;
				groups.push( group );
	
			}
	
			this.groups = groups;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;
	
			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
	
			// morphs
	
			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;
	
			var morphTargetsPosition;
	
			if ( morphTargetsLength > 0 ) {
	
				morphTargetsPosition = [];
	
				for ( var i = 0; i < morphTargetsLength; i ++ ) {
	
					morphTargetsPosition[ i ] = [];
	
				}
	
				this.morphTargets.position = morphTargetsPosition;
	
			}
	
			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;
	
			var morphTargetsNormal;
	
			if ( morphNormalsLength > 0 ) {
	
				morphTargetsNormal = [];
	
				for ( var i = 0; i < morphNormalsLength; i ++ ) {
	
					morphTargetsNormal[ i ] = [];
	
				}
	
				this.morphTargets.normal = morphTargetsNormal;
	
			}
	
			// skins
	
			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;
	
			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;
	
			//
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
	
				} else {
	
					var normal = face.normal;
	
					this.normals.push( normal, normal, normal );
	
				}
	
				var vertexColors = face.vertexColors;
	
				if ( vertexColors.length === 3 ) {
	
					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
	
				} else {
	
					var color = face.color;
	
					this.colors.push( color, color, color );
	
				}
	
				if ( hasFaceVertexUv === true ) {
	
					var vertexUvs = faceVertexUvs[ 0 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
	
						this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );
	
					}
	
				}
	
				if ( hasFaceVertexUv2 === true ) {
	
					var vertexUvs = faceVertexUvs[ 1 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
	
						this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );
	
					}
	
				}
	
				// morphs
	
				for ( var j = 0; j < morphTargetsLength; j ++ ) {
	
					var morphTarget = morphTargets[ j ].vertices;
	
					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
	
				}
	
				for ( var j = 0; j < morphNormalsLength; j ++ ) {
	
					var morphNormal = morphNormals[ j ].vertexNormals[ i ];
	
					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );
	
				}
	
				// skins
	
				if ( hasSkinIndices ) {
	
					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
	
				}
	
				if ( hasSkinWeights ) {
	
					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
	
				}
	
			}
	
			this.computeGroups( geometry );
	
			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	} );
	
	// File:src/core/BufferGeometry.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'BufferGeometry';
	
		this.index = null;
		this.attributes = {};
	
		this.morphAttributes = {};
	
		this.groups = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.drawRange = { start: 0, count: Infinity };
	
	};
	
	Object.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {
	
		getIndex: function () {
	
			return this.index;
	
		},
	
		setIndex: function ( index ) {
	
			this.index = index;
	
		},
	
		addAttribute: function ( name, attribute ) {
	
			if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {
	
				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
				this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
	
				return;
	
			}
	
			if ( name === 'index' ) {
	
				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );
	
				return;
	
			}
	
			this.attributes[ name ] = attribute;
	
			return this;
	
		},
	
		getAttribute: function ( name ) {
	
			return this.attributes[ name ];
	
		},
	
		removeAttribute: function ( name ) {
	
			delete this.attributes[ name ];
	
			return this;
	
		},
	
		addGroup: function ( start, count, materialIndex ) {
	
			this.groups.push( {
	
				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0
	
			} );
	
		},
	
		clearGroups: function () {
	
			this.groups = [];
	
		},
	
		setDrawRange: function ( start, count ) {
	
			this.drawRange.start = start;
			this.drawRange.count = count;
	
		},
	
		applyMatrix: function ( matrix ) {
	
			var position = this.attributes.position;
	
			if ( position !== undefined ) {
	
				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;
	
			}
	
			var normal = this.attributes.normal;
	
			if ( normal !== undefined ) {
	
				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
			return this;
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1;
	
			return function rotateX( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1;
	
			return function rotateY( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1;
	
			return function rotateZ( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1;
	
			return function translate( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1;
	
			return function scale( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj;
	
			return function lookAt( vector ) {
	
				if ( obj === undefined ) obj = new THREE.Object3D();
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.translate( offset.x, offset.y, offset.z );
	
			return offset;
	
		},
	
		setFromObject: function ( object ) {
	
			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	
			var geometry = object.geometry;
	
			if ( object instanceof THREE.Points || object instanceof THREE.Line ) {
	
				var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
				var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );
	
				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
	
				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
	
					var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );
	
					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
	
				}
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
			} else if ( object instanceof THREE.Mesh ) {
	
				if ( geometry instanceof THREE.Geometry ) {
	
					this.fromGeometry( geometry );
	
				}
	
			}
	
			return this;
	
		},
	
		updateFromObject: function ( object ) {
	
			var geometry = object.geometry;
	
			if ( object instanceof THREE.Mesh ) {
	
				var direct = geometry.__directGeometry;
	
				if ( direct === undefined || geometry.elementsNeedUpdate === true ) {
	
					return this.fromGeometry( geometry );
	
				}
	
				direct.verticesNeedUpdate = geometry.verticesNeedUpdate || geometry.elementsNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate || geometry.elementsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate || geometry.elementsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate || geometry.elementsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate || geometry.elementsNeedUpdate;
	
				geometry.elementsNeedUpdate = false;
				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;
	
				geometry = direct;
	
			}
	
			var attribute;
	
			if ( geometry.verticesNeedUpdate === true ) {
	
				attribute = this.attributes.position;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;
	
				}
	
				geometry.verticesNeedUpdate = false;
	
			}
	
			if ( geometry.normalsNeedUpdate === true ) {
	
				attribute = this.attributes.normal;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;
	
				}
	
				geometry.normalsNeedUpdate = false;
	
			}
	
			if ( geometry.colorsNeedUpdate === true ) {
	
				attribute = this.attributes.color;
	
				if ( attribute !== undefined ) {
	
					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;
	
				}
	
				geometry.colorsNeedUpdate = false;
	
			}
	
			if ( geometry.uvsNeedUpdate ) {
	
				attribute = this.attributes.uv;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;
	
				}
	
				geometry.uvsNeedUpdate = false;
	
			}
	
			if ( geometry.lineDistancesNeedUpdate ) {
	
				attribute = this.attributes.lineDistance;
	
				if ( attribute !== undefined ) {
	
					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;
	
				}
	
				geometry.lineDistancesNeedUpdate = false;
	
			}
	
			if ( geometry.groupsNeedUpdate ) {
	
				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;
	
				geometry.groupsNeedUpdate = false;
	
			}
	
			return this;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );
	
			return this.fromDirectGeometry( geometry.__directGeometry );
	
		},
	
		fromDirectGeometry: function ( geometry ) {
	
			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
	
			if ( geometry.normals.length > 0 ) {
	
				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
	
			}
	
			if ( geometry.colors.length > 0 ) {
	
				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
	
			}
	
			if ( geometry.uvs.length > 0 ) {
	
				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
	
			}
	
			if ( geometry.uvs2.length > 0 ) {
	
				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
	
			}
	
			if ( geometry.indices.length > 0 ) {
	
				var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray( geometry.indices.length * 3 );
				this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );
	
			}
	
			// groups
	
			this.groups = geometry.groups;
	
			// morphs
	
			for ( var name in geometry.morphTargets ) {
	
				var array = [];
				var morphTargets = geometry.morphTargets[ name ];
	
				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
	
					var morphTarget = morphTargets[ i ];
	
					var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );
	
					array.push( attribute.copyVector3sArray( morphTarget ) );
	
				}
	
				this.morphAttributes[ name ] = array;
	
			}
	
			// skinning
	
			if ( geometry.skinIndices.length > 0 ) {
	
				var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
	
			}
	
			if ( geometry.skinWeights.length > 0 ) {
	
				var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
	
			}
	
			//
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			return this;
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			var positions = this.attributes.position.array;
	
			if ( positions !== undefined ) {
	
				this.boundingBox.setFromArray( positions );
	
			} else {
	
				this.boundingBox.makeEmpty();
	
			}
	
			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
	
			}
	
		},
	
		computeBoundingSphere: function () {
	
			var box = new THREE.Box3();
			var vector = new THREE.Vector3();
	
			return function computeBoundingSphere() {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new THREE.Sphere();
	
				}
	
				var positions = this.attributes.position;
	
				if ( positions ) {
	
					var array = positions.array;
					var center = this.boundingSphere.center;
	
					box.setFromArray( array );
					box.center( center );
	
					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = array.length; i < il; i += 3 ) {
	
						vector.fromArray( array, i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
					}
	
					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
					if ( isNaN( this.boundingSphere.radius ) ) {
	
						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
	
					}
	
				}
	
			};
	
		}(),
	
		computeFaceNormals: function () {
	
			// backwards compatibility
	
		},
	
		computeVertexNormals: function () {
	
			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;
	
			if ( attributes.position ) {
	
				var positions = attributes.position.array;
	
				if ( attributes.normal === undefined ) {
	
					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
				} else {
	
					// reset existing normals to zero
	
					var array = attributes.normal.array;
	
					for ( var i = 0, il = array.length; i < il; i ++ ) {
	
						array[ i ] = 0;
	
					}
	
				}
	
				var normals = attributes.normal.array;
	
				var vA, vB, vC,
	
				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),
	
				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();
	
				// indexed elements
	
				if ( index ) {
	
					var indices = index.array;
	
					if ( groups.length === 0 ) {
	
						this.addGroup( 0, indices.length );
	
					}
	
					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {
	
						var group = groups[ j ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var i = start, il = start + count; i < il; i += 3 ) {
	
							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;
	
							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;
	
							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;
	
							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;
	
						}
	
					}
	
				} else {
	
					// non-indexed elements (unconnected triangle soup)
	
					for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );
	
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
	
						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;
	
						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;
	
						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;
	
					}
	
				}
	
				this.normalizeNormals();
	
				attributes.normal.needsUpdate = true;
	
			}
	
		},
	
		merge: function ( geometry, offset ) {
	
			if ( geometry instanceof THREE.BufferGeometry === false ) {
	
				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;
	
			}
	
			if ( offset === undefined ) offset = 0;
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				if ( geometry.attributes[ key ] === undefined ) continue;
	
				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;
	
				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;
	
				var attributeSize = attribute2.itemSize;
	
				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
					attributeArray1[ j ] = attributeArray2[ i ];
	
				}
	
			}
	
			return this;
	
		},
	
		normalizeNormals: function () {
	
			var normals = this.attributes.normal.array;
	
			var x, y, z, n;
	
			for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];
	
				n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
				normals[ i ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;
	
			}
	
		},
	
		toNonIndexed: function () {
	
			if ( this.index === null ) {
	
				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;
	
			}
	
			var geometry2 = new THREE.BufferGeometry();
	
			var indices = this.index.array;
			var attributes = this.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
	
				var array = attribute.array;
				var itemSize = attribute.itemSize;
	
				var array2 = new array.constructor( indices.length * itemSize );
	
				var index = 0, index2 = 0;
	
				for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
					index = indices[ i ] * itemSize;
	
					for ( var j = 0; j < itemSize; j ++ ) {
	
						array2[ index2 ++ ] = array[ index ++ ];
	
					}
	
				}
	
				geometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );
	
			}
	
			return geometry2;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};
	
			// standard BufferGeometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			data.data = { attributes: {} };
	
			var index = this.index;
	
			if ( index !== null ) {
	
				var array = Array.prototype.slice.call( index.array );
	
				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};
	
			}
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
	
				var array = Array.prototype.slice.call( attribute.array );
	
				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array,
					normalized: attribute.normalized
				};
	
			}
	
			var groups = this.groups;
	
			if ( groups.length > 0 ) {
	
				data.data.groups = JSON.parse( JSON.stringify( groups ) );
	
			}
	
			var boundingSphere = this.boundingSphere;
	
			if ( boundingSphere !== null ) {
	
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
	
			}
	
			return data;
	
		},
	
		clone: function () {
	
			/*
			// Handle primitives
	
			var parameters = this.parameters;
	
			if ( parameters !== undefined ) {
	
				var values = [];
	
				for ( var key in parameters ) {
	
					values.push( parameters[ key ] );
	
				}
	
				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;
	
			}
	
			return new this.constructor().copy( this );
			*/
	
			return new THREE.BufferGeometry().copy( this );
	
		},
	
		copy: function ( source ) {
	
			var index = source.index;
	
			if ( index !== null ) {
	
				this.setIndex( index.clone() );
	
			}
	
			var attributes = source.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );
	
			}
	
			var groups = source.groups;
	
			for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );
	
			}
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	} );
	
	THREE.BufferGeometry.MaxIndex = 65535;
	
	// File:src/core/InstancedBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedBufferGeometry = function () {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;
	
	};
	
	THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
	
	THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {
	
		this.groups.push( {
	
			start: start,
			count: count,
			instances: instances
	
		} );
	
	};
	
	THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {
	
		var index = source.index;
	
		if ( index !== null ) {
	
			this.setIndex( index.clone() );
	
		}
	
		var attributes = source.attributes;
	
		for ( var name in attributes ) {
	
			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );
	
		}
	
		var groups = source.groups;
	
		for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.instances );
	
		}
	
		return this;
	
	};
	
	// File:src/core/Uniform.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Uniform = function ( value ) {
	
		if ( typeof value === 'string' ) {
	
			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];
	
		}
	
		this.value = value;
	
		this.dynamic = false;
	
	};
	
	THREE.Uniform.prototype = {
	
		constructor: THREE.Uniform,
	
		onUpdate: function ( callback ) {
	
			this.dynamic = true;
			this.onUpdateCallback = callback;
	
			return this;
	
		}
	
	};
	
	// File:src/animation/AnimationAction.js
	
	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */
	
	THREE.AnimationAction = function() {
	
		throw new Error( "THREE.AnimationAction: " +
				"Use mixer.clipAction for construction." );
	
	};
	
	THREE.AnimationAction._new =
			function AnimationAction( mixer, clip, localRoot ) {
	
		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;
	
		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );
	
		var interpolantSettings = {
				endingStart: 	THREE.ZeroCurvatureEnding,
				endingEnd:		THREE.ZeroCurvatureEnding
		};
	
		for ( var i = 0; i !== nTracks; ++ i ) {
	
			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;
	
		}
	
		this._interpolantSettings = interpolantSettings;
	
		this._interpolants = interpolants;	// bound by the mixer
	
		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );
	
		this._cacheIndex = null;			// for the memory manager
		this._byClipCacheIndex = null;		// for the memory manager
	
		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;
	
		this.loop = THREE.LoopRepeat;
		this._loopCount = -1;
	
		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;
	
		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;
	
		this.timeScale = 1;
		this._effectiveTimeScale = 1;
	
		this.weight = 1;
		this._effectiveWeight = 1;
	
		this.repetitions = Infinity; 		// no. of repetitions when looping
	
		this.paused = false;				// false -> zero effective time scale
		this.enabled = true;				// true -> zero effective weight
	
		this.clampWhenFinished 	= false;	// keep feeding the last frame?
	
		this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd		= true;		// clips for start, loop and end
	
	};
	
	THREE.AnimationAction._new.prototype = {
	
		constructor: THREE.AnimationAction._new,
	
		// State & Scheduling
	
		play: function() {
	
			this._mixer._activateAction( this );
	
			return this;
	
		},
	
		stop: function() {
	
			this._mixer._deactivateAction( this );
	
			return this.reset();
	
		},
	
		reset: function() {
	
			this.paused = false;
			this.enabled = true;
	
			this.time = 0;			// restart clip
			this._loopCount = -1;	// forget previous loops
			this._startTime = null;	// forget scheduling
	
			return this.stopFading().stopWarping();
	
		},
	
		isRunning: function() {
	
			var start = this._startTime;
	
			return this.enabled && ! this.paused && this.timeScale !== 0 &&
					this._startTime === null && this._mixer._isActiveAction( this );
	
		},
	
		// return true when play has been called
		isScheduled: function() {
	
			return this._mixer._isActiveAction( this );
	
		},
	
		startAt: function( time ) {
	
			this._startTime = time;
	
			return this;
	
		},
	
		setLoop: function( mode, repetitions ) {
	
			this.loop = mode;
			this.repetitions = repetitions;
	
			return this;
	
		},
	
		// Weight
	
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function( weight ) {
	
			this.weight = weight;
	
			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;
	
			return this.stopFading();
	
		},
	
		// return the weight considering fading and .enabled
		getEffectiveWeight: function() {
	
			return this._effectiveWeight;
	
		},
	
		fadeIn: function( duration ) {
	
			return this._scheduleFading( duration, 0, 1 );
	
		},
	
		fadeOut: function( duration ) {
	
			return this._scheduleFading( duration, 1, 0 );
	
		},
	
		crossFadeFrom: function( fadeOutAction, duration, warp ) {
	
			var mixer = this._mixer;
	
			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );
	
			if( warp ) {
	
				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,
	
					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;
	
				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );
	
			}
	
			return this;
	
		},
	
		crossFadeTo: function( fadeInAction, duration, warp ) {
	
			return fadeInAction.crossFadeFrom( this, duration, warp );
	
		},
	
		stopFading: function() {
	
			var weightInterpolant = this._weightInterpolant;
	
			if ( weightInterpolant !== null ) {
	
				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );
	
			}
	
			return this;
	
		},
	
		// Time Scale Control
	
		// set the weight stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function( timeScale ) {
	
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 :timeScale;
	
			return this.stopWarping();
	
		},
	
		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function() {
	
			return this._effectiveTimeScale;
	
		},
	
		setDuration: function( duration ) {
	
			this.timeScale = this._clip.duration / duration;
	
			return this.stopWarping();
	
		},
	
		syncWith: function( action ) {
	
			this.time = action.time;
			this.timeScale = action.timeScale;
	
			return this.stopWarping();
	
		},
	
		halt: function( duration ) {
	
			return this.warp( this._effectiveTimeScale, 0, duration );
	
		},
	
		warp: function( startTimeScale, endTimeScale, duration ) {
	
			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,
	
				timeScale = this.timeScale;
	
			if ( interpolant === null ) {
	
				interpolant = mixer._lendControlInterpolant(),
				this._timeScaleInterpolant = interpolant;
	
			}
	
			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
	
			times[ 0 ] = now;
			times[ 1 ] = now + duration;
	
			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;
	
			return this;
	
		},
	
		stopWarping: function() {
	
			var timeScaleInterpolant = this._timeScaleInterpolant;
	
			if ( timeScaleInterpolant !== null ) {
	
				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
	
			}
	
			return this;
	
		},
	
		// Object Accessors
	
		getMixer: function() {
	
			return this._mixer;
	
		},
	
		getClip: function() {
	
			return this._clip;
	
		},
	
		getRoot: function() {
	
			return this._localRoot || this._mixer._root;
	
		},
	
		// Interna
	
		_update: function( time, deltaTime, timeDirection, accuIndex ) {
			// called by the mixer
	
			var startTime = this._startTime;
	
			if ( startTime !== null ) {
	
				// check for scheduled start of action
	
				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {
	
					return; // yet to come / don't decide when delta = 0
	
				}
	
				// start
	
				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;
	
			}
	
			// apply time scale and advance time
	
			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );
	
			// note: _updateTime may disable the action resulting in
			// an effective weight of 0
	
			var weight = this._updateWeight( time );
	
			if ( weight > 0 ) {
	
				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;
	
				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
	
					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );
	
				}
	
			}
	
		},
	
		_updateWeight: function( time ) {
	
			var weight = 0;
	
			if ( this.enabled ) {
	
				weight = this.weight;
				var interpolant = this._weightInterpolant;
	
				if ( interpolant !== null ) {
	
					var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
					weight *= interpolantValue;
	
					if ( time > interpolant.parameterPositions[ 1 ] ) {
	
						this.stopFading();
	
						if ( interpolantValue === 0 ) {
	
							// faded out, disable
							this.enabled = false;
	
						}
	
					}
	
				}
	
			}
	
			this._effectiveWeight = weight;
			return weight;
	
		},
	
		_updateTimeScale: function( time ) {
	
			var timeScale = 0;
	
			if ( ! this.paused ) {
	
				timeScale = this.timeScale;
	
				var interpolant = this._timeScaleInterpolant;
	
				if ( interpolant !== null ) {
	
					var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
					timeScale *= interpolantValue;
	
					if ( time > interpolant.parameterPositions[ 1 ] ) {
	
						this.stopWarping();
	
						if ( timeScale === 0 ) {
	
							// motion has halted, pause
							this.paused = true;
	
						} else {
	
							// warp done - apply final time scale
							this.timeScale = timeScale;
	
						}
	
					}
	
				}
	
			}
	
			this._effectiveTimeScale = timeScale;
			return timeScale;
	
		},
	
		_updateTime: function( deltaTime ) {
	
			var time = this.time + deltaTime;
	
			if ( deltaTime === 0 ) return time;
	
			var duration = this._clip.duration,
	
				loop = this.loop,
				loopCount = this._loopCount;
	
			if ( loop === THREE.LoopOnce ) {
	
				if ( loopCount === -1 ) {
					// just started
	
					this.loopCount = 0;
					this._setEndings( true, true, false );
	
				}
	
				handle_stop: {
	
					if ( time >= duration ) {
	
						time = duration;
	
					} else if ( time < 0 ) {
	
						time = 0;
	
					} else break handle_stop;
	
					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;
	
					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? -1 : 1
					} );
	
				}
	
			} else { // repetitive Repeat or PingPong
	
				var pingPong = ( loop === THREE.LoopPingPong );
	
				if ( loopCount === -1 ) {
					// just started
	
					if ( deltaTime >= 0 ) {
	
						loopCount = 0;
	
						this._setEndings(
								true, this.repetitions === 0, pingPong );
	
					} else {
	
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
	
						this._setEndings(
								this.repetitions === 0, true, pingPong );
	
					}
	
				}
	
				if ( time >= duration || time < 0 ) {
					// wrap around
	
					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;
	
					loopCount += Math.abs( loopDelta );
	
					var pending = this.repetitions - loopCount;
	
					if ( pending < 0 ) {
						// have to stop (switch state, clamp time, fire event)
	
						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;
	
						time = deltaTime > 0 ? duration : 0;
	
						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : -1
						} );
	
					} else {
						// keep running
	
						if ( pending === 0 ) {
							// entering the last round
	
							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );
	
						} else {
	
							this._setEndings( false, false, pingPong );
	
						}
	
						this._loopCount = loopCount;
	
						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );
	
					}
	
				}
	
				if ( pingPong && ( loopCount & 1 ) === 1 ) {
					// invert time for the "pong round"
	
					this.time = time;
					return duration - time;
	
				}
	
			}
	
			this.time = time;
			return time;
	
		},
	
		_setEndings: function( atStart, atEnd, pingPong ) {
	
			var settings = this._interpolantSettings;
	
			if ( pingPong ) {
	
				settings.endingStart 	= THREE.ZeroSlopeEnding;
				settings.endingEnd		= THREE.ZeroSlopeEnding;
	
			} else {
	
				// assuming for LoopOnce atStart == atEnd == true
	
				if ( atStart ) {
	
					settings.endingStart = this.zeroSlopeAtStart ?
							THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
	
				} else {
	
					settings.endingStart = THREE.WrapAroundEnding;
	
				}
	
				if ( atEnd ) {
	
					settings.endingEnd = this.zeroSlopeAtEnd ?
							THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
	
				} else {
	
					settings.endingEnd 	 = THREE.WrapAroundEnding;
	
				}
	
			}
	
		},
	
		_scheduleFading: function( duration, weightNow, weightThen ) {
	
			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;
	
			if ( interpolant === null ) {
	
				interpolant = mixer._lendControlInterpolant(),
				this._weightInterpolant = interpolant;
	
			}
	
			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
	
			times[ 0 ] = now; 				values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;	values[ 1 ] = weightThen;
	
			return this;
	
		}
	
	};
	
	
	// File:src/animation/AnimationClip.js
	
	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationClip = function ( name, duration, tracks ) {
	
		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : -1;
	
		this.uuid = THREE.Math.generateUUID();
	
		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {
	
			this.resetDuration();
	
		}
	
		// maybe only do these on demand, as doing them here could potentially slow down loading
		// but leaving these here during development as this ensures a lot of testing of these functions
		this.trim();
		this.optimize();
	
	};
	
	THREE.AnimationClip.prototype = {
	
		constructor: THREE.AnimationClip,
	
		resetDuration: function() {
	
			var tracks = this.tracks,
				duration = 0;
	
			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
	
				var track = this.tracks[ i ];
	
				duration = Math.max(
						duration, track.times[ track.times.length - 1 ] );
	
			}
	
			this.duration = duration;
	
		},
	
		trim: function() {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].trim( 0, this.duration );
	
			}
	
			return this;
	
		},
	
		optimize: function() {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].optimize();
	
			}
	
			return this;
	
		}
	
	};
	
	// Static methods:
	
	Object.assign( THREE.AnimationClip, {
	
		parse: function( json ) {
	
			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );
	
			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
	
				tracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );
	
			}
	
			return new THREE.AnimationClip( json.name, json.duration, tracks );
	
		},
	
	
		toJSON: function( clip ) {
	
			var tracks = [],
				clipTracks = clip.tracks;
	
			var json = {
	
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks
	
			};
	
			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
	
				tracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );
	
			}
	
			return json;
	
		},
	
	
		CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {
	
			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];
	
			for ( var i = 0; i < numMorphTargets; i ++ ) {
	
				var times = [];
				var values = [];
	
				times.push(
						( i + numMorphTargets - 1 ) % numMorphTargets,
						i,
						( i + 1 ) % numMorphTargets );
	
				values.push( 0, 1, 0 );
	
				var order = THREE.AnimationUtils.getKeyframeOrder( times );
				times = THREE.AnimationUtils.sortedArray( times, 1, order );
				values = THREE.AnimationUtils.sortedArray( values, 1, order );
	
				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {
	
					times.push( numMorphTargets );
					values.push( values[ 0 ] );
	
				}
	
				tracks.push(
						new THREE.NumberKeyframeTrack(
							'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
							times, values
						).scale( 1.0 / fps ) );
			}
	
			return new THREE.AnimationClip( name, -1, tracks );
	
		},
	
		findByName: function( objectOrClipArray, name ) {
	
			var clipArray = objectOrClipArray;
	
			if ( ! Array.isArray( objectOrClipArray ) ) {
	
				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
	
			}
	
			for ( var i = 0; i < clipArray.length; i ++ ) {
	
				if ( clipArray[ i ].name === name ) {
	
					return clipArray[ i ];
	
				}
			}
	
			return null;
	
		},
	
		CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {
	
			var animationToMorphTargets = {};
	
			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;
	
			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
	
				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );
	
				if ( parts && parts.length > 1 ) {
	
					var name = parts[ 1 ];
	
					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {
	
						animationToMorphTargets[ name ] = animationMorphTargets = [];
	
					}
	
					animationMorphTargets.push( morphTarget );
	
				}
	
			}
	
			var clips = [];
	
			for ( var name in animationToMorphTargets ) {
	
				clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );
	
			}
	
			return clips;
	
		},
	
		// parse the animation.hierarchy format
		parseAnimation: function( animation, bones, nodeName ) {
	
			if ( ! animation ) {
	
				console.error( "  no animation in JSONLoader data" );
				return null;
	
			}
	
			var addNonemptyTrack = function(
					trackType, trackName, animationKeys, propertyName, destTracks ) {
	
				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {
	
					var times = [];
					var values = [];
	
					THREE.AnimationUtils.flattenJSON(
							animationKeys, times, values, propertyName );
	
					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {
	
						destTracks.push( new trackType( trackName, times, values ) );
	
					}
	
				}
	
			};
	
			var tracks = [];
	
			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || -1;
			var fps = animation.fps || 30;
	
			var hierarchyTracks = animation.hierarchy || [];
	
			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
	
				var animationKeys = hierarchyTracks[ h ].keys;
	
				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;
	
				// process morph targets in a way exactly compatible
				// with AnimationHandler.init( animation )
				if ( animationKeys[0].morphTargets ) {
	
					// figure out all morph targets used in this track
					var morphTargetNames = {};
					for ( var k = 0; k < animationKeys.length; k ++ ) {
	
						if ( animationKeys[k].morphTargets ) {
	
							for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {
	
								morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
							}
	
						}
	
					}
	
					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {
	
						var times = [];
						var values = [];
	
						for ( var m = 0;
								m !== animationKeys[k].morphTargets.length; ++ m ) {
	
							var animationKey = animationKeys[k];
	
							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );
	
						}
	
						tracks.push( new THREE.NumberKeyframeTrack(
								'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
	
					}
	
					duration = morphTargetNames.length * ( fps || 1.0 );
	
				} else {
					// ...assume skeletal animation
	
					var boneName = '.bones[' + bones[ h ].name + ']';
	
					addNonemptyTrack(
							THREE.VectorKeyframeTrack, boneName + '.position',
							animationKeys, 'pos', tracks );
	
					addNonemptyTrack(
							THREE.QuaternionKeyframeTrack, boneName + '.quaternion',
							animationKeys, 'rot', tracks );
	
					addNonemptyTrack(
							THREE.VectorKeyframeTrack, boneName + '.scale',
							animationKeys, 'scl', tracks );
	
				}
	
			}
	
			if ( tracks.length === 0 ) {
	
				return null;
	
			}
	
			var clip = new THREE.AnimationClip( clipName, duration, tracks );
	
			return clip;
	
		}
	
	} );
	
	// File:src/animation/AnimationMixer.js
	
	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.AnimationMixer = function( root ) {
	
		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
	
		this.time = 0;
	
		this.timeScale = 1.0;
	
	};
	
	Object.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {
	
		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function( clip, optionalRoot ) {
	
			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
	
				clipObject = typeof clip === 'string' ?
						THREE.AnimationClip.findByName( root, clip ) : clip,
	
				clipUuid = clipObject !== null ? clipObject.uuid : clip,
	
				actionsForClip = this._actionsByClip[ clipUuid ],
				prototypeAction = null;
	
			if ( actionsForClip !== undefined ) {
	
				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];
	
				if ( existingAction !== undefined ) {
	
					return existingAction;
	
				}
	
				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];
	
				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;
	
			}
	
			// clip must be known when specified via string
			if ( clipObject === null ) return null;
	
			// allocate all resources required to run it
			var newAction = new THREE.
					AnimationMixer._Action( this, clipObject, optionalRoot );
	
			this._bindAction( newAction, prototypeAction );
	
			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );
	
			return newAction;
	
		},
	
		// get an existing action
		existingAction: function( clip, optionalRoot ) {
	
			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
	
				clipObject = typeof clip === 'string' ?
						THREE.AnimationClip.findByName( root, clip ) : clip,
	
				clipUuid = clipObject ? clipObject.uuid : clip,
	
				actionsForClip = this._actionsByClip[ clipUuid ];
	
			if ( actionsForClip !== undefined ) {
	
				return actionsForClip.actionByRoot[ rootUuid ] || null;
	
			}
	
			return null;
	
		},
	
		// deactivates all previously scheduled actions
		stopAllAction: function() {
	
			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;
	
			this._nActiveActions = 0;
			this._nActiveBindings = 0;
	
			for ( var i = 0; i !== nActions; ++ i ) {
	
				actions[ i ].reset();
	
			}
	
			for ( var i = 0; i !== nBindings; ++ i ) {
	
				bindings[ i ].useCount = 0;
	
			}
	
			return this;
	
		},
	
		// advance the time and update apply the animation
		update: function( deltaTime ) {
	
			deltaTime *= this.timeScale;
	
			var actions = this._actions,
				nActions = this._nActiveActions,
	
				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),
	
				accuIndex = this._accuIndex ^= 1;
	
			// run active actions
	
			for ( var i = 0; i !== nActions; ++ i ) {
	
				var action = actions[ i ];
	
				if ( action.enabled ) {
	
					action._update( time, deltaTime, timeDirection, accuIndex );
	
				}
	
			}
	
			// update scene graph
	
			var bindings = this._bindings,
				nBindings = this._nActiveBindings;
	
			for ( var i = 0; i !== nBindings; ++ i ) {
	
				bindings[ i ].apply( accuIndex );
	
			}
	
			return this;
	
		},
	
		// return this mixer's root target object
		getRoot: function() {
	
			return this._root;
	
		},
	
		// free all resources specific to a particular clip
		uncacheClip: function( clip ) {
	
			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];
	
			if ( actionsForClip !== undefined ) {
	
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
	
				var actionsToRemove = actionsForClip.knownActions;
	
				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
	
					var action = actionsToRemove[ i ];
	
					this._deactivateAction( action );
	
					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];
	
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
	
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();
	
					this._removeInactiveBindingsForAction( action );
	
				}
	
				delete actionsByClip[ clipUuid ];
	
			}
	
		},
	
		// free all resources specific to a particular root target object
		uncacheRoot: function( root ) {
	
			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;
	
			for ( var clipUuid in actionsByClip ) {
	
				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];
	
				if ( action !== undefined ) {
	
					this._deactivateAction( action );
					this._removeInactiveAction( action );
	
				}
	
			}
	
			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];
	
			if ( bindingByName !== undefined ) {
	
				for ( var trackName in bindingByName ) {
	
					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );
	
				}
	
			}
	
		},
	
		// remove a targeted clip from the cache
		uncacheAction: function( clip, optionalRoot ) {
	
			var action = this.existingAction( clip, optionalRoot );
	
			if ( action !== null ) {
	
				this._deactivateAction( action );
				this._removeInactiveAction( action );
	
			}
	
		}
	
	} );
	
	THREE.AnimationMixer._Action = THREE.AnimationAction._new;
	
	// Implementation details:
	
	Object.assign( THREE.AnimationMixer.prototype, {
	
		_bindAction: function( action, prototypeAction ) {
	
			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];
	
			if ( bindingsByName === undefined ) {
	
				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;
	
			}
	
			for ( var i = 0; i !== nTracks; ++ i ) {
	
				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];
	
				if ( binding !== undefined ) {
	
					bindings[ i ] = binding;
	
				} else {
	
					binding = bindings[ i ];
	
					if ( binding !== undefined ) {
	
						// existing binding, make sure the cache knows
	
						if ( binding._cacheIndex === null ) {
	
							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );
	
						}
	
						continue;
	
					}
	
					var path = prototypeAction && prototypeAction.
							_propertyBindings[ i ].binding.parsedPath;
	
					binding = new THREE.PropertyMixer(
							THREE.PropertyBinding.create( root, trackName, path ),
							track.ValueTypeName, track.getValueSize() );
	
					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );
	
					bindings[ i ] = binding;
	
				}
	
				interpolants[ i ].resultBuffer = binding.buffer;
	
			}
	
		},
	
		_activateAction: function( action ) {
	
			if ( ! this._isActiveAction( action ) ) {
	
				if ( action._cacheIndex === null ) {
	
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
	
					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];
	
					this._bindAction( action,
							actionsForClip && actionsForClip.knownActions[ 0 ] );
	
					this._addInactiveAction( action, clipUuid, rootUuid );
	
				}
	
				var bindings = action._propertyBindings;
	
				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( binding.useCount ++ === 0 ) {
	
						this._lendBinding( binding );
						binding.saveOriginalState();
	
					}
	
				}
	
				this._lendAction( action );
	
			}
	
		},
	
		_deactivateAction: function( action ) {
	
			if ( this._isActiveAction( action ) ) {
	
				var bindings = action._propertyBindings;
	
				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( -- binding.useCount === 0 ) {
	
						binding.restoreOriginalState();
						this._takeBackBinding( binding );
	
					}
	
				}
	
				this._takeBackAction( action );
	
			}
	
		},
	
		// Memory manager
	
		_initMemoryManager: function() {
	
			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;
	
			this._actionsByClip = {};
			// inside:
			// {
			// 		knownActions: Array< _Action >	- used as prototypes
			// 		actionByRoot: _Action			- lookup
			// }
	
	
			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;
	
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
	
	
			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;
	
			var scope = this;
	
			this.stats = {
	
				actions: {
					get total() { return scope._actions.length; },
					get inUse() { return scope._nActiveActions; }
				},
				bindings: {
					get total() { return scope._bindings.length; },
					get inUse() { return scope._nActiveBindings; }
				},
				controlInterpolants: {
					get total() { return scope._controlInterpolants.length; },
					get inUse() { return scope._nActiveControlInterpolants; }
				}
	
			};
	
		},
	
		// Memory management for _Action objects
	
		_isActiveAction: function( action ) {
	
			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
	
		},
	
		_addInactiveAction: function( action, clipUuid, rootUuid ) {
	
			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];
	
			if ( actionsForClip === undefined ) {
	
				actionsForClip = {
	
					knownActions: [ action ],
					actionByRoot: {}
	
				};
	
				action._byClipCacheIndex = 0;
	
				actionsByClip[ clipUuid ] = actionsForClip;
	
			} else {
	
				var knownActions = actionsForClip.knownActions;
	
				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );
	
			}
	
			action._cacheIndex = actions.length;
			actions.push( action );
	
			actionsForClip.actionByRoot[ rootUuid ] = action;
	
		},
	
		_removeInactiveAction: function( action ) {
	
			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;
	
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();
	
			action._cacheIndex = null;
	
	
			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,
	
				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],
	
				byClipCacheIndex = action._byClipCacheIndex;
	
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();
	
			action._byClipCacheIndex = null;
	
	
			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( actions._localRoot || this._root ).uuid;
	
			delete actionByRoot[ rootUuid ];
	
			if ( knownActionsForClip.length === 0 ) {
	
				delete actionsByClip[ clipUuid ];
	
			}
	
			this._removeInactiveBindingsForAction( action );
	
		},
	
		_removeInactiveBindingsForAction: function( action ) {
	
			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
				var binding = bindings[ i ];
	
				if ( -- binding.referenceCount === 0 ) {
	
					this._removeInactiveBinding( binding );
	
				}
	
			}
	
		},
	
		_lendAction: function( action ) {
	
			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s
	
			var actions = this._actions,
				prevIndex = action._cacheIndex,
	
				lastActiveIndex = this._nActiveActions ++,
	
				firstInactiveAction = actions[ lastActiveIndex ];
	
			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;
	
			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;
	
		},
	
		_takeBackAction: function( action ) {
	
			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a
	
			var actions = this._actions,
				prevIndex = action._cacheIndex,
	
				firstInactiveIndex = -- this._nActiveActions,
	
				lastActiveAction = actions[ firstInactiveIndex ];
	
			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;
	
			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;
	
		},
	
		// Memory management for PropertyMixer objects
	
		_addInactiveBinding: function( binding, rootUuid, trackName ) {
	
			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
	
				bindings = this._bindings;
	
			if ( bindingByName === undefined ) {
	
				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;
	
			}
	
			bindingByName[ trackName ] = binding;
	
			binding._cacheIndex = bindings.length;
			bindings.push( binding );
	
		},
	
		_removeInactiveBinding: function( binding ) {
	
			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
	
				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;
	
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();
	
			delete bindingByName[ trackName ];
	
			remove_empty_map: {
	
				for ( var _ in bindingByName ) break remove_empty_map;
	
				delete bindingsByRoot[ rootUuid ];
	
			}
	
		},
	
		_lendBinding: function( binding ) {
	
			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
	
				lastActiveIndex = this._nActiveBindings ++,
	
				firstInactiveBinding = bindings[ lastActiveIndex ];
	
			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;
	
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;
	
		},
	
		_takeBackBinding: function( binding ) {
	
			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
	
				firstInactiveIndex = -- this._nActiveBindings,
	
				lastActiveBinding = bindings[ firstInactiveIndex ];
	
			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;
	
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;
	
		},
	
	
		// Memory management of Interpolants for weight and time scale
	
		_lendControlInterpolant: function() {
	
			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];
	
			if ( interpolant === undefined ) {
	
				interpolant = new THREE.LinearInterpolant(
						new Float32Array( 2 ), new Float32Array( 2 ),
							1, this._controlInterpolantsResultBuffer );
	
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;
	
			}
	
			return interpolant;
	
		},
	
		_takeBackControlInterpolant: function( interpolant ) {
	
			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,
	
				firstInactiveIndex = -- this._nActiveControlInterpolants,
	
				lastActiveInterpolant = interpolants[ firstInactiveIndex ];
	
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;
	
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;
	
		},
	
		_controlInterpolantsResultBuffer: new Float32Array( 1 )
	
	} );
	
	// File:src/animation/AnimationObjectGroup.js
	
	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */
	
	THREE.AnimationObjectGroup = function( var_args ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );
	
		this.nCachedObjects_ = 0;			// threshold
		// note: read by PropertyBinding.Composite
	
		var indices = {};
		this._indicesByUUID = indices;		// for bookkeeping
	
		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
			indices[ arguments[ i ].uuid ] = i;
	
		}
	
		this._paths = [];					// inside: string
		this._parsedPaths = [];				// inside: { we don't care, here }
		this._bindings = []; 				// inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays
	
		var scope = this;
	
		this.stats = {
	
			objects: {
				get total() { return scope._objects.length; },
				get inUse() { return this.total - scope.nCachedObjects_;  }
			},
	
			get bindingsPerObject() { return scope._bindings.length; }
	
		};
	
	};
	
	THREE.AnimationObjectGroup.prototype = {
	
		constructor: THREE.AnimationObjectGroup,
	
		add: function( var_args ) {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index === undefined ) {
	
					// unknown object -> add it to the ACTIVE region
	
					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						bindings[ j ].push(
								new THREE.PropertyBinding(
									object, paths[ j ], parsedPaths[ j ] ) );
	
					}
	
				} else if ( index < nCachedObjects ) {
	
					var knownObject = objects[ index ];
	
					// move existing object to the ACTIVE region
	
					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];
	
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;
	
					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];
	
						bindingsForPath[ index ] = lastCached;
	
						if ( binding === undefined ) {
	
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
	
							binding = new THREE.PropertyBinding(
									object, paths[ j ], parsedPaths[ j ] );
	
						}
	
						bindingsForPath[ firstActiveIndex ] = binding;
	
					}
	
				} else if ( objects[ index ] !== knownObject) {
	
					console.error( "Different objects with the same UUID " +
							"detected. Clean the caches or recreate your " +
							"infrastructure when reloading scenes..." );
	
				} // else the object is already where we want it to be
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		remove: function( var_args ) {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index !== undefined && index >= nCachedObjects ) {
	
					// move existing object into the CACHED region
	
					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];
	
					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;
	
					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];
	
						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;
	
					}
	
				}
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		// remove & forget
		uncache: function( var_args ) {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index !== undefined ) {
	
					delete indicesByUUID[ uuid ];
	
					if ( index < nCachedObjects ) {
	
						// object is cached, shrink the CACHED region
	
						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
	
						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;
	
						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];
	
							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();
	
						}
	
					} else {
	
						// object is active, just swap with the last and pop
	
						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
	
						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ];
	
							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();
	
						}
	
					} // cached or active
	
				} // if object is known
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		// Internal interface used by befriended PropertyBinding.Composite:
	
		subscribe_: function( path, parsedPath ) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
	
			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;
	
			if ( index !== undefined ) return bindings[ index ];
	
			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );
	
			index = bindings.length;
	
			indicesByPath[ path ] = index;
	
			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );
	
			for ( var i = nCachedObjects,
					n = objects.length; i !== n; ++ i ) {
	
				var object = objects[ i ];
	
				bindingsForPath[ i ] =
						new THREE.PropertyBinding( object, path, parsedPath );
	
			}
	
			return bindingsForPath;
	
		},
	
		unsubscribe_: function( path ) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
	
			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];
	
			if ( index !== undefined ) {
	
				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];
	
				indicesByPath[ lastBindingsPath ] = index;
	
				bindings[ index ] = lastBindings;
				bindings.pop();
	
				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();
	
				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();
	
			}
	
		}
	
	};
	
	
	// File:src/animation/AnimationUtils.js
	
	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationUtils = {
	
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function( array, from, to ) {
	
			if ( THREE.AnimationUtils.isTypedArray( array ) ) {
	
				return new array.constructor( array.subarray( from, to ) );
	
			}
	
			return array.slice( from, to );
	
		},
	
		// converts an array to a specific type
		convertArray: function( array, type, forceClone ) {
	
			if ( ! array || // let 'undefined' and 'null' pass
					! forceClone && array.constructor === type ) return array;
	
			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
	
				return new type( array ); // create typed array
	
			}
	
			return Array.prototype.slice.call( array ); // create Array
	
		},
	
		isTypedArray: function( object ) {
	
			return ArrayBuffer.isView( object ) &&
					! ( object instanceof DataView );
	
		},
	
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function( times ) {
	
			function compareTime( i, j ) {
	
				return times[ i ] - times[ j ];
	
			}
	
			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
	
			result.sort( compareTime );
	
			return result;
	
		},
	
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function( values, stride, order ) {
	
			var nValues = values.length;
			var result = new values.constructor( nValues );
	
			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
	
				var srcOffset = order[ i ] * stride;
	
				for ( var j = 0; j !== stride; ++ j ) {
	
					result[ dstOffset ++ ] = values[ srcOffset + j ];
	
				}
	
			}
	
			return result;
	
		},
	
		// function for parsing AOS keyframe formats
		flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {
	
			var i = 1, key = jsonKeys[ 0 ];
	
			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
	
				key = jsonKeys[ i ++ ];
	
			}
	
			if ( key === undefined ) return; // no data
	
			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data
	
			if ( Array.isArray( value ) ) {
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						values.push.apply( values, value ); // push all elements
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			} else if ( value.toArray !== undefined ) {
				// ...assume THREE.Math-ish
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						value.toArray( values, values.length );
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			} else {
				// otherwise push as-is
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						values.push( value );
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			}
	
		}
	
	};
	
	// File:src/animation/KeyframeTrack.js
	
	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.KeyframeTrack = function ( name, times, values, interpolation ) {
	
		if( name === undefined ) throw new Error( "track name is undefined" );
	
		if( times === undefined || times.length === 0 ) {
	
			throw new Error( "no keyframes in track named " + name );
	
		}
	
		this.name = name;
	
		this.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );
	
		this.setInterpolation( interpolation || this.DefaultInterpolation );
	
		this.validate();
		this.optimize();
	
	};
	
	THREE.KeyframeTrack.prototype = {
	
		constructor: THREE.KeyframeTrack,
	
		TimeBufferType: Float32Array,
		ValueBufferType: Float32Array,
	
		DefaultInterpolation: THREE.InterpolateLinear,
	
		InterpolantFactoryMethodDiscrete: function( result ) {
	
			return new THREE.DiscreteInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodLinear: function( result ) {
	
			return new THREE.LinearInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodSmooth: function( result ) {
	
			return new THREE.CubicInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		setInterpolation: function( interpolation ) {
	
			var factoryMethod;
	
			switch ( interpolation ) {
	
				case THREE.InterpolateDiscrete:
	
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
	
					break;
	
				case THREE.InterpolateLinear:
	
					factoryMethod = this.InterpolantFactoryMethodLinear;
	
					break;
	
				case THREE.InterpolateSmooth:
	
					factoryMethod = this.InterpolantFactoryMethodSmooth;
	
					break;
	
			}
	
			if ( factoryMethod === undefined ) {
	
				var message = "unsupported interpolation for " +
						this.ValueTypeName + " keyframe track named " + this.name;
	
				if ( this.createInterpolant === undefined ) {
	
					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {
	
						this.setInterpolation( this.DefaultInterpolation );
	
					} else {
	
						throw new Error( message ); // fatal, in this case
	
					}
	
				}
	
				console.warn( message );
				return;
	
			}
	
			this.createInterpolant = factoryMethod;
	
		},
	
		getInterpolation: function() {
	
			switch ( this.createInterpolant ) {
	
				case this.InterpolantFactoryMethodDiscrete:
	
					return THREE.InterpolateDiscrete;
	
				case this.InterpolantFactoryMethodLinear:
	
					return THREE.InterpolateLinear;
	
				case this.InterpolantFactoryMethodSmooth:
	
					return THREE.InterpolateSmooth;
	
			}
	
		},
	
		getValueSize: function() {
	
			return this.values.length / this.times.length;
	
		},
	
		// move all keyframes either forwards or backwards in time
		shift: function( timeOffset ) {
	
			if( timeOffset !== 0.0 ) {
	
				var times = this.times;
	
				for( var i = 0, n = times.length; i !== n; ++ i ) {
	
					times[ i ] += timeOffset;
	
				}
	
			}
	
			return this;
	
		},
	
		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function( timeScale ) {
	
			if( timeScale !== 1.0 ) {
	
				var times = this.times;
	
				for( var i = 0, n = times.length; i !== n; ++ i ) {
	
					times[ i ] *= timeScale;
	
				}
	
			}
	
			return this;
	
		},
	
		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function( startTime, endTime ) {
	
			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;
	
			while ( from !== nKeys && times[ from ] < startTime ) ++ from;
			while ( to !== -1 && times[ to ] > endTime ) -- to;
	
			++ to; // inclusive -> exclusive bound
	
			if( from !== 0 || to !== nKeys ) {
	
				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;
	
				var stride = this.getValueSize();
				this.times = THREE.AnimationUtils.arraySlice( times, from, to );
				this.values = THREE.AnimationUtils.
						arraySlice( this.values, from * stride, to * stride );
	
			}
	
			return this;
	
		},
	
		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function() {
	
			var valid = true;
	
			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {
	
				console.error( "invalid value size in track", this );
				valid = false;
	
			}
	
			var times = this.times,
				values = this.values,
	
				nKeys = times.length;
	
			if( nKeys === 0 ) {
	
				console.error( "track is empty", this );
				valid = false;
	
			}
	
			var prevTime = null;
	
			for( var i = 0; i !== nKeys; i ++ ) {
	
				var currTime = times[ i ];
	
				if ( typeof currTime === 'number' && isNaN( currTime ) ) {
	
					console.error( "time is not a valid number", this, i, currTime );
					valid = false;
					break;
	
				}
	
				if( prevTime !== null && prevTime > currTime ) {
	
					console.error( "out of order keys", this, i, currTime, prevTime );
					valid = false;
					break;
	
				}
	
				prevTime = currTime;
	
			}
	
			if ( values !== undefined ) {
	
				if ( THREE.AnimationUtils.isTypedArray( values ) ) {
	
					for ( var i = 0, n = values.length; i !== n; ++ i ) {
	
						var value = values[ i ];
	
						if ( isNaN( value ) ) {
	
							console.error( "value is not a valid number", this, i, value );
							valid = false;
							break;
	
						}
	
					}
	
				}
	
			}
	
			return valid;
	
		},
	
		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function() {
	
			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),
	
				writeIndex = 1;
	
			for( var i = 1, n = times.length - 1; i <= n; ++ i ) {
	
				var keep = false;
	
				var time = times[ i ];
				var timeNext = times[ i + 1 ];
	
				// remove adjacent keyframes scheduled at the same time
	
				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
	
					// remove unnecessary keyframes same as their neighbors
					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;
	
					for ( var j = 0; j !== stride; ++ j ) {
	
						var value = values[ offset + j ];
	
						if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {
	
							keep = true;
							break;
	
						}
	
					}
	
				}
	
				// in-place compaction
	
				if ( keep ) {
	
					if ( i !== writeIndex ) {
	
						times[ writeIndex ] = times[ i ];
	
						var readOffset = i * stride,
							writeOffset = writeIndex * stride;
	
						for ( var j = 0; j !== stride; ++ j ) {
	
							values[ writeOffset + j ] = values[ readOffset + j ];
	
						}
	
	
					}
	
					++ writeIndex;
	
				}
	
			}
	
			if ( writeIndex !== times.length ) {
	
				this.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );
	
			}
	
			return this;
	
		}
	
	};
	
	// Static methods:
	
	Object.assign( THREE.KeyframeTrack, {
	
		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):
	
		parse: function( json ) {
	
			if( json.type === undefined ) {
	
				throw new Error( "track type undefined, can not parse" );
	
			}
	
			var trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );
	
			if ( json.times === undefined ) {
	
				var times = [], values = [];
	
				THREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
	
				json.times = times;
				json.values = values;
	
			}
	
			// derived classes can define a static parse method
			if ( trackType.parse !== undefined ) {
	
				return trackType.parse( json );
	
			} else {
	
				// by default, we asssume a constructor compatible with the base
				return new trackType(
						json.name, json.times, json.values, json.interpolation );
	
			}
	
		},
	
		toJSON: function( track ) {
	
			var trackType = track.constructor;
	
			var json;
	
			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {
	
				json = trackType.toJSON( track );
	
			} else {
	
				// by default, we assume the data can be serialized as-is
				json = {
	
					'name': track.name,
					'times': THREE.AnimationUtils.convertArray( track.times, Array ),
					'values': THREE.AnimationUtils.convertArray( track.values, Array )
	
				};
	
				var interpolation = track.getInterpolation();
	
				if ( interpolation !== track.DefaultInterpolation ) {
	
					json.interpolation = interpolation;
	
				}
	
			}
	
			json.type = track.ValueTypeName; // mandatory
	
			return json;
	
		},
	
		_getTrackTypeForValueTypeName: function( typeName ) {
	
			switch( typeName.toLowerCase() ) {
	
				case "scalar":
				case "double":
				case "float":
				case "number":
				case "integer":
	
					return THREE.NumberKeyframeTrack;
	
				case "vector":
				case "vector2":
				case "vector3":
				case "vector4":
	
					return THREE.VectorKeyframeTrack;
	
				case "color":
	
					return THREE.ColorKeyframeTrack;
	
				case "quaternion":
	
					return THREE.QuaternionKeyframeTrack;
	
				case "bool":
				case "boolean":
	
					return THREE.BooleanKeyframeTrack;
	
				case "string":
	
					return THREE.StringKeyframeTrack;
	
			}
	
			throw new Error( "Unsupported typeName: " + typeName );
	
		}
	
	} );
	
	// File:src/animation/PropertyBinding.js
	
	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.PropertyBinding = function ( rootNode, path, parsedPath ) {
	
		this.path = path;
		this.parsedPath = parsedPath ||
				THREE.PropertyBinding.parseTrackName( path );
	
		this.node = THREE.PropertyBinding.findNode(
				rootNode, this.parsedPath.nodeName ) || rootNode;
	
		this.rootNode = rootNode;
	
	};
	
	THREE.PropertyBinding.prototype = {
	
		constructor: THREE.PropertyBinding,
	
		getValue: function getValue_unbound( targetArray, offset ) {
	
			this.bind();
			this.getValue( targetArray, offset );
	
			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.
	
		},
	
		setValue: function getValue_unbound( sourceArray, offset ) {
	
			this.bind();
			this.setValue( sourceArray, offset );
	
		},
	
		// create getter / setter pair for a property in the scene graph
		bind: function() {
	
			var targetObject = this.node,
				parsedPath = this.parsedPath,
	
				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;
	
			if ( ! targetObject ) {
	
				targetObject = THREE.PropertyBinding.findNode(
						this.rootNode, parsedPath.nodeName ) || this.rootNode;
	
				this.node = targetObject;
	
			}
	
			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;
	
	 		// ensure there is a value node
			if ( ! targetObject ) {
	
				console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
				return;
	
			}
	
			if ( objectName ) {
	
				var objectIndex = parsedPath.objectIndex;
	
				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {
	
					case 'materials':
	
						if ( ! targetObject.material ) {
	
							console.error( '  can not bind to material as node does not have a material', this );
							return;
	
						}
	
						if ( ! targetObject.material.materials ) {
	
							console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
							return;
	
						}
	
						targetObject = targetObject.material.materials;
	
						break;
	
					case 'bones':
	
						if ( ! targetObject.skeleton ) {
	
							console.error( '  can not bind to bones as node does not have a skeleton', this );
							return;
	
						}
	
						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.
	
						targetObject = targetObject.skeleton.bones;
	
						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {
	
							if ( targetObject[ i ].name === objectIndex ) {
	
								objectIndex = i;
								break;
	
							}
	
						}
	
						break;
	
					default:
	
						if ( targetObject[ objectName ] === undefined ) {
	
							console.error( '  can not bind to objectName of node, undefined', this );
							return;
	
						}
	
						targetObject = targetObject[ objectName ];
	
				}
	
	
				if ( objectIndex !== undefined ) {
	
					if ( targetObject[ objectIndex ] === undefined ) {
	
						console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
						return;
	
					}
	
					targetObject = targetObject[ objectIndex ];
	
				}
	
			}
	
			// resolve property
			var nodeProperty = targetObject[ propertyName ];
	
			if ( nodeProperty === undefined ) {
	
				var nodeName = parsedPath.nodeName;
	
				console.error( "  trying to update property for track: " + nodeName +
						'.' + propertyName + " but it wasn't found.", targetObject );
				return;
	
			}
	
			// determine versioning scheme
			var versioning = this.Versioning.None;
	
			if ( targetObject.needsUpdate !== undefined ) { // material
	
				versioning = this.Versioning.NeedsUpdate;
				this.targetObject = targetObject;
	
			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
	
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
				this.targetObject = targetObject;
	
			}
	
			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;
	
			if ( propertyIndex !== undefined ) {
				// access a sub element of the property array (only primitives are supported right now)
	
				if ( propertyName === "morphTargetInfluences" ) {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {
	
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
						return;
	
					}
	
					if ( ! targetObject.geometry.morphTargets ) {
	
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
						return;
	
					}
	
					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
	
						if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {
	
							propertyIndex = i;
							break;
	
						}
	
					}
	
				}
	
				bindingType = this.BindingType.ArrayElement;
	
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
	
			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
				// must use copy for Object3D.Euler/Quaternion
	
				bindingType = this.BindingType.HasFromToArray;
	
				this.resolvedProperty = nodeProperty;
	
			} else if ( nodeProperty.length !== undefined ) {
	
				bindingType = this.BindingType.EntireArray;
	
				this.resolvedProperty = nodeProperty;
	
			} else {
	
				this.propertyName = propertyName;
	
			}
	
			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
	
		},
	
		unbind: function() {
	
			this.node = null;
	
			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
	
		}
	
	};
	
	Object.assign( THREE.PropertyBinding.prototype, { // prototype, continued
	
		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function() {},
		_setValue_unavailable: function() {},
	
		// initial state of these methods that calls 'bind'
		_getValue_unbound: THREE.PropertyBinding.prototype.getValue,
		_setValue_unbound: THREE.PropertyBinding.prototype.setValue,
	
		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},
	
		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},
	
		GetterByBindingType: [
	
			function getValue_direct( buffer, offset ) {
	
				buffer[ offset ] = this.node[ this.propertyName ];
	
			},
	
			function getValue_array( buffer, offset ) {
	
				var source = this.resolvedProperty;
	
				for ( var i = 0, n = source.length; i !== n; ++ i ) {
	
					buffer[ offset ++ ] = source[ i ];
	
				}
	
			},
	
			function getValue_arrayElement( buffer, offset ) {
	
				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
	
			},
	
			function getValue_toArray( buffer, offset ) {
	
				this.resolvedProperty.toArray( buffer, offset );
	
			}
	
		],
	
		SetterByBindingTypeAndVersioning: [
	
			[
				// Direct
	
				function setValue_direct( buffer, offset ) {
	
					this.node[ this.propertyName ] = buffer[ offset ];
	
				},
	
				function setValue_direct_setNeedsUpdate( buffer, offset ) {
	
					this.node[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.node[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// EntireArray
	
				function setValue_array( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
				},
	
				function setValue_array_setNeedsUpdate( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// ArrayElement
	
				function setValue_arrayElement( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
	
				},
	
				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// HasToFromArray
	
				function setValue_fromArray( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
	
				},
	
				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			]
	
		]
	
	} );
	
	THREE.PropertyBinding.Composite =
			function( targetGroup, path, optionalParsedPath ) {
	
		var parsedPath = optionalParsedPath ||
				THREE.PropertyBinding.parseTrackName( path );
	
		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );
	
	};
	
	THREE.PropertyBinding.Composite.prototype = {
	
		constructor: THREE.PropertyBinding.Composite,
	
		getValue: function( array, offset ) {
	
			this.bind(); // bind all binding
	
			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];
	
			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );
	
		},
	
		setValue: function( array, offset ) {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_,
					n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].setValue( array, offset );
	
			}
	
		},
	
		bind: function() {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_,
					n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].bind();
	
			}
	
		},
	
		unbind: function() {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_,
					n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].unbind();
	
			}
	
		}
	
	};
	
	THREE.PropertyBinding.create = function( root, path, parsedPath ) {
	
		if ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {
	
			return new THREE.PropertyBinding( root, path, parsedPath );
	
		} else {
	
			return new THREE.PropertyBinding.Composite( root, path, parsedPath );
	
		}
	
	};
	
	THREE.PropertyBinding.parseTrackName = function( trackName ) {
	
		// matches strings in the form of:
		//    nodeName.property
		//    nodeName.property[accessor]
		//    nodeName.material.property[accessor]
		//    uuid.property[accessor]
		//    uuid.objectName[objectIndex].propertyName[propertyIndex]
		//    parentName/nodeName.property
		//    parentName/parentName/nodeName.property[index]
		//	  .bone[Armature.DEF_cog].position
		// created and tested via https://regex101.com/#javascript
	
		var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
		var matches = re.exec( trackName );
	
		if ( ! matches ) {
	
			throw new Error( "cannot parse trackName at all: " + trackName );
	
		}
	
		if ( matches.index === re.lastIndex ) {
	
			re.lastIndex++;
	
		}
	
		var results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 3 ], 	// allowed to be null, specified root node.
			objectName: matches[ 5 ],
			objectIndex: matches[ 7 ],
			propertyName: matches[ 9 ],
			propertyIndex: matches[ 11 ]	// allowed to be null, specifies that the whole property is set.
		};
	
		if ( results.propertyName === null || results.propertyName.length === 0 ) {
	
			throw new Error( "can not parse propertyName from trackName: " + trackName );
	
		}
	
		return results;
	
	};
	
	THREE.PropertyBinding.findNode = function( root, nodeName ) {
	
		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {
	
			return root;
	
		}
	
		// search into skeleton bones.
		if ( root.skeleton ) {
	
			var searchSkeleton = function( skeleton ) {
	
				for( var i = 0; i < skeleton.bones.length; i ++ ) {
	
					var bone = skeleton.bones[ i ];
	
					if ( bone.name === nodeName ) {
	
						return bone;
	
					}
				}
	
				return null;
	
			};
	
			var bone = searchSkeleton( root.skeleton );
	
			if ( bone ) {
	
				return bone;
	
			}
		}
	
		// search into node subtree.
		if ( root.children ) {
	
			var searchNodeSubtree = function( children ) {
	
				for( var i = 0; i < children.length; i ++ ) {
	
					var childNode = children[ i ];
	
					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
	
						return childNode;
	
					}
	
					var result = searchNodeSubtree( childNode.children );
	
					if ( result ) return result;
	
				}
	
				return null;
	
			};
	
			var subTreeNode = searchNodeSubtree( root.children );
	
			if ( subTreeNode ) {
	
				return subTreeNode;
	
			}
	
		}
	
		return null;
	
	};
	
	// File:src/animation/PropertyMixer.js
	
	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.PropertyMixer = function ( binding, typeName, valueSize ) {
	
		this.binding = binding;
		this.valueSize = valueSize;
	
		var bufferType = Float64Array,
			mixFunction;
	
		switch ( typeName ) {
	
			case 'quaternion':			mixFunction = this._slerp;		break;
	
			case 'string':
			case 'bool':
	
				bufferType = Array,		mixFunction = this._select;		break;
	
			default:					mixFunction = this._lerp;
	
		}
	
		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
	
		this._mixBufferRegion = mixFunction;
	
		this.cumulativeWeight = 0;
	
		this.useCount = 0;
		this.referenceCount = 0;
	
	};
	
	THREE.PropertyMixer.prototype = {
	
		constructor: THREE.PropertyMixer,
	
		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function( accuIndex, weight ) {
	
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
	
			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,
	
				currentWeight = this.cumulativeWeight;
	
			if ( currentWeight === 0 ) {
	
				// accuN := incoming * weight
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					buffer[ offset + i ] = buffer[ i ];
	
				}
	
				currentWeight = weight;
	
			} else {
	
				// accuN := accuN + incoming * weight
	
				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );
	
			}
	
			this.cumulativeWeight = currentWeight;
	
		},
	
		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function( accuIndex ) {
	
			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,
	
				weight = this.cumulativeWeight,
	
				binding = this.binding;
	
			this.cumulativeWeight = 0;
	
			if ( weight < 1 ) {
	
				// accuN := accuN + original * ( 1 - cumulativeWeight )
	
				var originalValueOffset = stride * 3;
	
				this._mixBufferRegion(
						buffer, offset, originalValueOffset, 1 - weight, stride );
	
			}
	
			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
	
				if ( buffer[ i ] !== buffer[ i + stride ] ) {
	
					// value has changed -> update scene graph
	
					binding.setValue( buffer, offset );
					break;
	
				}
	
			}
	
		},
	
		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function() {
	
			var binding = this.binding;
	
			var buffer = this.buffer,
				stride = this.valueSize,
	
				originalValueOffset = stride * 3;
	
			binding.getValue( buffer, originalValueOffset );
	
			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
	
				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
	
			}
	
			this.cumulativeWeight = 0;
	
		},
	
		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function() {
	
			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );
	
		},
	
	
		// mix functions
	
		_select: function( buffer, dstOffset, srcOffset, t, stride ) {
	
			if ( t >= 0.5 ) {
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
	
				}
	
			}
	
		},
	
		_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
			THREE.Quaternion.slerpFlat( buffer, dstOffset,
					buffer, dstOffset, buffer, srcOffset, t );
	
		},
	
		_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
			var s = 1 - t;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				var j = dstOffset + i;
	
				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
	
			}
	
		}
	
	};
	
	// File:src/animation/tracks/BooleanKeyframeTrack.js
	
	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.BooleanKeyframeTrack = function ( name, times, values ) {
	
		THREE.KeyframeTrack.call( this, name, times, values );
	
	};
	
	THREE.BooleanKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.BooleanKeyframeTrack,
	
		ValueTypeName: 'bool',
		ValueBufferType: Array,
	
		DefaultInterpolation: THREE.InterpolateDiscrete,
	
		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined
	
		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".
	
	} );
	
	// File:src/animation/tracks/ColorKeyframeTrack.js
	
	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.ColorKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.ColorKeyframeTrack,
	
		ValueTypeName: 'color'
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
	
		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.
	
	} );
	
	// File:src/animation/tracks/NumberKeyframeTrack.js
	
	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.NumberKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.NumberKeyframeTrack,
	
		ValueTypeName: 'number',
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
	} );
	
	// File:src/animation/tracks/QuaternionKeyframeTrack.js
	
	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.QuaternionKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.QuaternionKeyframeTrack,
	
		ValueTypeName: 'quaternion',
	
		// ValueBufferType is inherited
	
		DefaultInterpolation: THREE.InterpolateLinear,
	
		InterpolantFactoryMethodLinear: function( result ) {
	
			return new THREE.QuaternionLinearInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodSmooth: undefined // not yet implemented
	
	} );
	
	// File:src/animation/tracks/StringKeyframeTrack.js
	
	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.StringKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.StringKeyframeTrack,
	
		ValueTypeName: 'string',
		ValueBufferType: Array,
	
		DefaultInterpolation: THREE.InterpolateDiscrete,
	
		InterpolantFactoryMethodLinear: undefined,
	
		InterpolantFactoryMethodSmooth: undefined
	
	} );
	
	// File:src/animation/tracks/VectorKeyframeTrack.js
	
	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.VectorKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.VectorKeyframeTrack,
	
		ValueTypeName: 'vector'
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
	} );
	
	// File:src/audio/Audio.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */
	
	THREE.Audio = function ( listener ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Audio';
	
		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind( this );
	
		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );
	
		this.autoplay = false;
	
		this.startTime = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';
	
		this.filters = [];
	
	};
	
	THREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.Audio,
	
		getOutput: function () {
	
			return this.gain;
	
		},
	
		setNodeSource: function ( audioNode ) {
	
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
	
			return this;
	
		},
	
		setBuffer: function ( audioBuffer ) {
	
			this.source.buffer = audioBuffer;
			this.sourceType = 'buffer';
	
			if ( this.autoplay ) this.play();
	
			return this;
	
		},
	
		play: function () {
	
			if ( this.isPlaying === true ) {
	
				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;
	
			}
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			var source = this.context.createBufferSource();
	
			source.buffer = this.source.buffer;
			source.loop = this.source.loop;
			source.onended = this.source.onended;
			source.start( 0, this.startTime );
			source.playbackRate.value = this.playbackRate;
	
			this.isPlaying = true;
	
			this.source = source;
	
			return this.connect();
	
		},
	
		pause: function () {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			this.source.stop();
			this.startTime = this.context.currentTime;
			this.isPlaying = false;
	
			return this;
	
		},
	
		stop: function () {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			this.source.stop();
			this.startTime = 0;
			this.isPlaying = false;
	
			return this;
	
		},
	
		connect: function () {
	
			if ( this.filters.length > 0 ) {
	
				this.source.connect( this.filters[ 0 ] );
	
				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
					this.filters[ i - 1 ].connect( this.filters[ i ] );
	
				}
	
				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );
	
			} else {
	
				this.source.connect( this.getOutput() );
	
			}
	
			return this;
	
		},
	
		disconnect: function () {
	
			if ( this.filters.length > 0 ) {
	
				this.source.disconnect( this.filters[ 0 ] );
	
				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
					this.filters[ i - 1 ].disconnect( this.filters[ i ] );
	
				}
	
				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );
	
			} else {
	
				this.source.disconnect( this.getOutput() );
	
			}
	
			return this;
	
		},
	
		getFilters: function () {
	
			return this.filters;
	
		},
	
		setFilters: function ( value ) {
	
			if ( ! value ) value = [];
	
			if ( this.isPlaying === true ) {
	
				this.disconnect();
				this.filters = value;
				this.connect();
	
			} else {
	
				this.filters = value;
	
			}
	
			return this;
	
		},
	
		getFilter: function () {
	
			return this.getFilters()[ 0 ];
	
		},
	
		setFilter: function ( filter ) {
	
			return this.setFilters( filter ? [ filter ] : [] );
	
		},
	
		setPlaybackRate: function ( value ) {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			this.playbackRate = value;
	
			if ( this.isPlaying === true ) {
	
				this.source.playbackRate.value = this.playbackRate;
	
			}
	
			return this;
	
		},
	
		getPlaybackRate: function () {
	
			return this.playbackRate;
	
		},
	
		onEnded: function () {
	
			this.isPlaying = false;
	
		},
	
		getLoop: function () {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;
	
			}
	
			return this.source.loop;
	
		},
	
		setLoop: function ( value ) {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			this.source.loop = value;
	
		},
	
		getVolume: function () {
	
			return this.gain.gain.value;
	
		},
	
	
		setVolume: function ( value ) {
	
			this.gain.gain.value = value;
	
			return this;
	
		}
	
	} );
	
	// File:src/audio/AudioAnalyser.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioAnalyser = function ( audio, fftSize ) {
	
		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	
		this.data = new Uint8Array( this.analyser.frequencyBinCount );
	
		audio.getOutput().connect( this.analyser );
	
	};
	
	Object.assign( THREE.AudioAnalyser.prototype, {
	
		getFrequencyData: function () {
	
			this.analyser.getByteFrequencyData( this.data );
	
			return this.data;
	
		},
	
		getAverageFrequency: function () {
	
			var value = 0, data = this.getFrequencyData();
	
			for ( var i = 0; i < data.length; i ++ ) {
	
				value += data[ i ];
	
			}
	
			return value / data.length;
	
		}
	
	} );
	
	// File:src/audio/AudioContext.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	Object.defineProperty( THREE, 'AudioContext', {
	
		get: ( function () {
	
			var context;
	
			return function get() {
	
				if ( context === undefined ) {
	
					context = new ( window.AudioContext || window.webkitAudioContext )();
	
				}
	
				return context;
	
			};
	
		} )()
	
	} );
	
	// File:src/audio/PositionalAudio.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PositionalAudio = function ( listener ) {
	
		THREE.Audio.call( this, listener );
	
		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );
	
	};
	
	THREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {
	
		constructor: THREE.PositionalAudio,
	
		getOutput: function () {
	
			return this.panner;
	
		},
	
		getRefDistance: function () {
	
			return this.panner.refDistance;
	
		},
	
		setRefDistance: function ( value ) {
	
			this.panner.refDistance = value;
	
		},
	
		getRolloffFactor: function () {
	
			return this.panner.rolloffFactor;
	
		},
	
		setRolloffFactor: function ( value ) {
	
			this.panner.rolloffFactor = value;
	
		},
	
		getDistanceModel: function () {
	
			return this.panner.distanceModel;
	
		},
	
		setDistanceModel: function ( value ) {
	
			this.panner.distanceModel = value;
	
		},
	
		getMaxDistance: function () {
	
			return this.panner.maxDistance;
	
		},
	
		setMaxDistance: function ( value ) {
	
			this.panner.maxDistance = value;
	
		},
	
		updateMatrixWorld: ( function () {
	
			var position = new THREE.Vector3();
	
			return function updateMatrixWorld( force ) {
	
				THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
				position.setFromMatrixPosition( this.matrixWorld );
	
				this.panner.setPosition( position.x, position.y, position.z );
	
			};
	
		} )()
	
	
	} );
	
	// File:src/audio/AudioListener.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioListener = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'AudioListener';
	
		this.context = THREE.AudioContext;
	
		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );
	
		this.filter = null;
	
	};
	
	THREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.AudioListener,
	
		getInput: function () {
	
			return this.gain;
	
		},
	
		removeFilter: function ( ) {
	
			if ( this.filter !== null ) {
	
				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;
	
			}
	
		},
	
		getFilter: function () {
	
			return this.filter;
	
		},
	
		setFilter: function ( value ) {
	
			if ( this.filter !== null ) {
	
				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
	
			} else {
	
				this.gain.disconnect( this.context.destination );
	
			}
	
			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );
	
		},
	
		getMasterVolume: function () {
	
			return this.gain.gain.value;
	
		},
	
		setMasterVolume: function ( value ) {
	
			this.gain.gain.value = value;
	
		},
	
		updateMatrixWorld: ( function () {
	
			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();
	
			var orientation = new THREE.Vector3();
	
			return function updateMatrixWorld( force ) {
	
				THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
				var listener = this.context.listener;
				var up = this.up;
	
				this.matrixWorld.decompose( position, quaternion, scale );
	
				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
				listener.setPosition( position.x, position.y, position.z );
				listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	
			};
	
		} )()
	
	} );
	
	// File:src/cameras/Camera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.Camera = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Camera';
	
		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();
	
	};
	
	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;
	
	THREE.Camera.prototype.getWorldDirection = function () {
	
		var quaternion = new THREE.Quaternion();
	
		return function getWorldDirection( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.getWorldQuaternion( quaternion );
	
			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
		};
	
	}();
	
	THREE.Camera.prototype.lookAt = function () {
	
		// This routine does not support cameras with rotated and/or translated parent(s)
	
		var m1 = new THREE.Matrix4();
	
		return function lookAt( vector ) {
	
			m1.lookAt( this.position, vector, this.up );
	
			this.quaternion.setFromRotationMatrix( m1 );
	
		};
	
	}();
	
	THREE.Camera.prototype.clone = function () {
	
		return new this.constructor().copy( this );
	
	};
	
	THREE.Camera.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.matrixWorldInverse.copy( source.matrixWorldInverse );
		this.projectionMatrix.copy( source.projectionMatrix );
	
		return this;
	
	};
	
	// File:src/cameras/CubeCamera.js
	
	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CubeCamera = function ( near, far, cubeResolution ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'CubeCamera';
	
		var fov = 90, aspect = 1;
	
		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );
	
		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );
	
		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );
	
		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );
	
		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );
	
		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );
	
		var options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
	
		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
	
		this.updateCubeMap = function ( renderer, scene ) {
	
			if ( this.parent === null ) this.updateMatrixWorld();
	
			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;
	
			renderTarget.texture.generateMipmaps = false;
	
			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );
	
			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );
	
			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );
	
			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );
	
			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );
	
			renderTarget.texture.generateMipmaps = generateMipmaps;
	
			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );
	
			renderer.setRenderTarget( null );
	
		};
	
	};
	
	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
	
	// File:src/cameras/OrthographicCamera.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */
	
	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'OrthographicCamera';
	
		this.zoom = 1;
		this.view = null;
	
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
	
		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {
	
		constructor: THREE.OrthographicCamera,
	
		copy: function ( source ) {
	
			THREE.Camera.prototype.copy.call( this, source );
	
			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
	
			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );
	
			return this;
	
		},
	
		setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {
	
			this.view = {
				fullWidth: fullWidth,
				fullHeight: fullHeight,
				offsetX: x,
				offsetY: y,
				width: width,
				height: height
			};
	
			this.updateProjectionMatrix();
	
		},
	
		clearViewOffset: function() {
	
			this.view = null;
			this.updateProjectionMatrix();
	
		},
	
		updateProjectionMatrix: function () {
	
			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;
	
			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;
	
			if ( this.view !== null ) {
	
				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
				var scaleW = ( this.right - this.left ) / this.view.width;
				var scaleH = ( this.top - this.bottom ) / this.view.height;
	
				left += scaleW * ( this.view.offsetX / zoomW );
				right = left + scaleW * ( this.view.width / zoomW );
				top -= scaleH * ( this.view.offsetY / zoomH );
				bottom = top - scaleH * ( this.view.height / zoomH );
	
			}
	
			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
	
		},
	
		toJSON: function ( meta ) {
	
			var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
	
			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
			return data;
	
		}
	
	} );
	
	// File:src/cameras/PerspectiveCamera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */
	
	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'PerspectiveCamera';
	
		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;
	
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;
	
		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;
	
		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {
	
		constructor: THREE.PerspectiveCamera,
	
		copy: function ( source ) {
	
			THREE.Camera.prototype.copy.call( this, source );
	
			this.fov = source.fov;
			this.zoom = source.zoom;
	
			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
	
			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );
	
			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
	
			return this;
	
		},
	
		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {
	
			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
	
			this.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();
	
		},
	
		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {
	
			var vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );
	
			return 0.5 * this.getFilmHeight() / vExtentSlope;
	
		},
	
		getEffectiveFOV: function () {
	
			return THREE.Math.RAD2DEG * 2 * Math.atan(
					Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );
	
		},
	
		getFilmWidth: function () {
	
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );
	
		},
	
		getFilmHeight: function () {
	
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );
	
		},
	
		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
	
			if( ! fullWidth ) {
				this.view = null;
				return;
			}
	
			this.aspect = fullWidth / fullHeight;
	
			this.view = {
				fullWidth: fullWidth,
				fullHeight: fullHeight,
				offsetX: x,
				offsetY: y,
				width: width,
				height: height
			};
	
			this.updateProjectionMatrix();
	
		},
	
		clearViewOffset: function() {
	
			this.view = null;
			this.updateProjectionMatrix();
	
		},
	
		updateProjectionMatrix: function () {
	
			var near = this.near,
				top = near * Math.tan(
						THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;
	
			if ( view !== null ) {
	
				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;
	
				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
	
			}
	
			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
	
			this.projectionMatrix.makeFrustum(
					left, left + width, top - height, top, near, this.far );
	
		},
	
		toJSON: function ( meta ) {
	
			var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
	
			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
	
			data.object.aspect = this.aspect;
	
			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
	
			return data;
	
		}
	
	} );
	
	// File:src/cameras/StereoCamera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.StereoCamera = function () {
	
		this.type = 'StereoCamera';
	
		this.aspect = 1;
	
		this.cameraL = new THREE.PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;
	
		this.cameraR = new THREE.PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;
	
	};
	
	Object.assign( THREE.StereoCamera.prototype, {
	
		update: ( function () {
	
			var focus, fov, aspect, near, far;
	
			var eyeRight = new THREE.Matrix4();
			var eyeLeft = new THREE.Matrix4();
	
			return function update( camera ) {
	
				var needsUpdate = focus !== camera.focus || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far;
	
				if ( needsUpdate ) {
	
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
	
					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/
	
					var projectionMatrix = camera.projectionMatrix.clone();
					var eyeSep = 0.064 / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );
					var xmin, xmax;
	
					// translate xOffset
	
					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;
	
					// for left eye
	
					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;
	
					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
					this.cameraL.projectionMatrix.copy( projectionMatrix );
	
					// for right eye
	
					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;
	
					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
					this.cameraR.projectionMatrix.copy( projectionMatrix );
	
				}
	
				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
	
			};
	
		} )()
	
	} );
	
	// File:src/lights/Light.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Light = function ( color, intensity ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Light';
	
		this.color = new THREE.Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;
	
		this.receiveShadow = undefined;
	
	};
	
	THREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.Light,
	
		copy: function ( source ) {
	
			THREE.Object3D.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.intensity = source.intensity;
	
			return this;
	
		},
	
		toJSON: function ( meta ) {
	
			var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
	
			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
	
			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
	
			return data;
	
		}
	
	} );
	
	// File:src/lights/LightShadow.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LightShadow = function ( camera ) {
	
		this.camera = camera;
	
		this.bias = 0;
		this.radius = 1;
	
		this.mapSize = new THREE.Vector2( 512, 512 );
	
		this.map = null;
		this.matrix = new THREE.Matrix4();
	
		this.cameraFovNearFar = new THREE.Vector3( 2 * THREE.Math.DEG2RAD, 0.5, 500 );
	
	};
	
	Object.assign( THREE.LightShadow.prototype, {
	
		copy: function ( source ) {
	
			this.camera = source.camera.clone();
	
			this.bias = source.bias;
			this.radius = source.radius;
	
			this.mapSize.copy( source.mapSize );
	
			this.cameraFovNearFar.copy( source.cameraFovNearFar );
	
			return this;
	
		},
	
	
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	} );
	
	// File:src/lights/AmbientLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AmbientLight = function ( color, intensity ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'AmbientLight';
	
		this.castShadow = undefined;
	
	};
	
	THREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {
	
		constructor: THREE.AmbientLight
	
	} );
	
	// File:src/lights/DirectionalLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DirectionalLight = function ( color, intensity ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'DirectionalLight';
	
		this.position.copy( THREE.Object3D.DefaultUp );
		this.updateMatrix();
	
		this.target = new THREE.Object3D();
	
		this.shadow = new THREE.DirectionalLightShadow();
	
	};
	
	THREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {
	
		constructor: THREE.DirectionalLight,
	
		copy: function ( source ) {
	
			THREE.Light.prototype.copy.call( this, source );
	
			this.target = source.target.clone();
	
			this.shadow = source.shadow.clone();
	
			return this;
	
		}
	
	} );
	
	// File:src/lights/DirectionalLightShadow.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.DirectionalLightShadow = function ( light ) {
		var frustrumWidth = 300;
		this.spreadAngle = 0.0;
		this.cameraParams = new THREE.Vector3( 2*frustrumWidth, 0.5, 1000 );
		THREE.LightShadow.call( this, new THREE.OrthographicCamera( - frustrumWidth, frustrumWidth, frustrumWidth, - frustrumWidth, this.cameraParams.y, this.cameraParams.z ) );
	};
	
	
	THREE.DirectionalLightShadow.prototype = Object.create( THREE.LightShadow.prototype );
	THREE.DirectionalLightShadow.prototype.constructor = THREE.DirectionalLightShadow;
	
	THREE.DirectionalLightShadow.prototype.update = function ( light ) {
	
		var camera = this.camera;
		var frustrumWidth = Math.abs(camera.left - camera.right);
		if ( this.cameraParams.x !== frustrumWidth || this.cameraParams.y !== camera.near || this.cameraParams.z !== camera.far ) {
	
			this.cameraParams.x = frustrumWidth;
			this.cameraParams.y = camera.near;
			this.cameraParams.z = camera.far;
		}
	
	};
	
	// File:src/lights/HemisphereLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {
	
		THREE.Light.call( this, skyColor, intensity );
	
		this.type = 'HemisphereLight';
	
		this.castShadow = undefined;
	
		this.position.copy( THREE.Object3D.DefaultUp );
		this.updateMatrix();
	
		this.groundColor = new THREE.Color( groundColor );
	
	};
	
	THREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {
	
		constructor: THREE.HemisphereLight,
	
		copy: function ( source ) {
	
			THREE.Light.prototype.copy.call( this, source );
	
			this.groundColor.copy( source.groundColor );
	
			return this;
	
		}
	
	} );
	
	// File:src/lights/PointLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	THREE.PointLight = function ( color, intensity, distance, decay ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'PointLight';
	
		Object.defineProperty( this, 'power', {
			get: function () {
				// intensity = power per solid angle.
				// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				return this.intensity * 4 * Math.PI;
	
			},
			set: function ( power ) {
				// intensity = power per solid angle.
				// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				this.intensity = power / ( 4 * Math.PI );
			}
		} );
	
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
	};
	
	THREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {
	
		constructor: THREE.PointLight,
	
		copy: function ( source ) {
	
			THREE.Light.prototype.copy.call( this, source );
	
			this.distance = source.distance;
			this.decay = source.decay;
	
			this.shadow = source.shadow.clone();
	
			return this;
	
		}
	
	} );
	
	// File:src/lights/SpotLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'SpotLight';
	
		this.position.copy( THREE.Object3D.DefaultUp );
		this.updateMatrix();
	
		this.target = new THREE.Object3D();
	
		Object.defineProperty( this, 'power', {
			get: function () {
				// intensity = power per solid angle.
				// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				return this.intensity * Math.PI;
			},
			set: function ( power ) {
				// intensity = power per solid angle.
				// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				this.intensity = power / Math.PI;
			}
		} );
	
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new THREE.SpotLightShadow();
	
	};
	
	THREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {
	
		constructor: THREE.SpotLight,
	
		copy: function ( source ) {
	
			THREE.Light.prototype.copy.call( this, source );
	
			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
	
			this.target = source.target.clone();
	
			this.shadow = source.shadow.clone();
	
			return this;
	
		}
	
	} );
	
	// File:src/lights/SpotLightShadow.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.SpotLightShadow = function () {
		var fov = 50;
		this.cameraParams = new THREE.Vector3( fov, 10.5, 1000 );
		THREE.LightShadow.call( this, new THREE.PerspectiveCamera( this.cameraParams.x, 1, this.cameraParams.y, this.cameraParams.z ) );
	
	};
	
	THREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {
	
		constructor: THREE.SpotLightShadow,
	
		update: function ( light ) {
	
			var fov = THREE.Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || 500;
	
			var camera = this.camera;
	
			this.cameraParams.x = fov * THREE.Math.DEG2RAD;
			this.cameraParams.y = light.shadow.camera.near;
			this.cameraParams.z = far;
	
			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();
	
		}
	
	} );
	
	// File:src/loaders/AudioLoader.js
	
	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */
	
	THREE.AudioLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	Object.assign( THREE.AudioLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.load( url, function ( buffer ) {
	
				var context = THREE.AudioContext;
	
				context.decodeAudioData( buffer, function ( audioBuffer ) {
	
					onLoad( audioBuffer );
	
				} );
	
			}, onProgress, onError );
	
		}
	
	} );
	
	// File:src/loaders/Cache.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Cache = {
	
		enabled: false,
	
		files: {},
	
		add: function ( key, file ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Adding key:', key );
	
			this.files[ key ] = file;
	
		},
	
		get: function ( key ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Checking key:', key );
	
			return this.files[ key ];
	
		},
	
		remove: function ( key ) {
	
			delete this.files[ key ];
	
		},
	
		clear: function () {
	
			this.files = {};
	
		}
	
	};
	
	// File:src/loaders/Loader.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Loader = function () {
	
		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};
	
	};
	
	THREE.Loader.prototype = {
	
		constructor: THREE.Loader,
	
		crossOrigin: undefined,
	
		extractUrlBase: function ( url ) {
	
			var parts = url.split( '/' );
	
			if ( parts.length === 1 ) return './';
	
			parts.pop();
	
			return parts.join( '/' ) + '/';
	
		},
	
		initMaterials: function ( materials, texturePath, crossOrigin ) {
	
			var array = [];
	
			for ( var i = 0; i < materials.length; ++ i ) {
	
				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
	
			}
	
			return array;
	
		},
	
		createMaterial: ( function () {
	
			var color, textureLoader, materialLoader;
	
			return function createMaterial( m, texturePath, crossOrigin ) {
	
				if ( color === undefined ) color = new THREE.Color();
				if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
				if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();
	
				// convert from old material format
	
				var textures = {};
	
				function loadTexture( path, repeat, offset, wrap, anisotropy ) {
	
					var fullPath = texturePath + path;
					var loader = THREE.Loader.Handlers.get( fullPath );
	
					var texture;
	
					if ( loader !== null ) {
	
						texture = loader.load( fullPath );
	
					} else {
	
						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );
	
					}
	
					if ( repeat !== undefined ) {
	
						texture.repeat.fromArray( repeat );
	
						if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;
	
					}
	
					if ( offset !== undefined ) {
	
						texture.offset.fromArray( offset );
	
					}
	
					if ( wrap !== undefined ) {
	
						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;
	
						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;
	
					}
	
					if ( anisotropy !== undefined ) {
	
						texture.anisotropy = anisotropy;
	
					}
	
					var uuid = THREE.Math.generateUUID();
	
					textures[ uuid ] = texture;
	
					return uuid;
	
				}
	
				//
	
				var json = {
					uuid: THREE.Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};
	
				for ( var name in m ) {
	
					var value = m[ name ];
	
					switch ( name ) {
						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = THREE[ value ];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = [ value, value ];
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = THREE.BackSide;
							break;
						case 'doubleSided':
							json.side = THREE.DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = THREE.VertexColors;
							if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;
					}
	
				}
	
				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
	
				if ( json.opacity < 1 ) json.transparent = true;
	
				materialLoader.setTextures( textures );
	
				return materialLoader.parse( json );
	
			};
	
		} )()
	
	};
	
	THREE.Loader.Handlers = {
	
		handlers: [],
	
		add: function ( regex, loader ) {
	
			this.handlers.push( regex, loader );
	
		},
	
		get: function ( file ) {
	
			var handlers = this.handlers;
	
			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
	
				var regex = handlers[ i ];
				var loader  = handlers[ i + 1 ];
	
				if ( regex.test( file ) ) {
	
					return loader;
	
				}
	
			}
	
			return null;
	
		}
	
	};
	
	// File:src/loaders/XHRLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.XHRLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	Object.assign( THREE.XHRLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.path !== undefined ) url = this.path + url;
	
			var scope = this;
	
			var cached = THREE.Cache.get( url );
	
			if ( cached !== undefined ) {
	
				scope.manager.itemStart( url );
	
				setTimeout( function () {
	
					if ( onLoad ) onLoad( cached );
	
					scope.manager.itemEnd( url );
	
				}, 0 );
	
				return cached;
	
			}
	
			var request = new XMLHttpRequest();
			request.overrideMimeType( 'text/plain' );
			request.open( 'GET', url, true );
	
			request.addEventListener( 'load', function ( event ) {
	
				var response = event.target.response;
	
				THREE.Cache.add( url, response );
	
				if ( this.status === 200 ) {
	
					if ( onLoad ) onLoad( response );
	
					scope.manager.itemEnd( url );
	
				} else if ( this.status === 0 ) {
	
					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.
	
					console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );
	
					if ( onLoad ) onLoad( response );
	
					scope.manager.itemEnd( url );
	
				} else {
	
					if ( onError ) onError( event );
	
					scope.manager.itemError( url );
	
				}
	
			}, false );
	
			if ( onProgress !== undefined ) {
	
				request.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			request.addEventListener( 'error', function ( event ) {
	
				if ( onError ) onError( event );
	
				scope.manager.itemError( url );
	
			}, false );
	
			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
	
			request.send( null );
	
			scope.manager.itemStart( url );
	
			return request;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		},
	
		setResponseType: function ( value ) {
	
			this.responseType = value;
			return this;
	
		},
	
		setWithCredentials: function ( value ) {
	
			this.withCredentials = value;
			return this;
	
		}
	
	} );
	
	// File:src/loaders/FontLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.FontLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	Object.assign( THREE.FontLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.load( url, function ( text ) {
	
				var json;
	
				try {
	
					json = JSON.parse( text );
	
				} catch ( e ) {
	
					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse( text.substring( 65, text.length - 2 ) );
	
				}
	
				var font = scope.parse( json );
	
				if ( onLoad ) onLoad( font );
	
			}, onProgress, onError );
	
		},
	
		parse: function ( json ) {
	
			return new THREE.Font( json );
	
		}
	
	} );
	
	// File:src/loaders/ImageLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ImageLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	Object.assign( THREE.ImageLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
			image.onload = function () {
	
				URL.revokeObjectURL( image.src );
	
				if ( onLoad ) onLoad( image );
	
				scope.manager.itemEnd( url );
	
			};
	
			if ( url.indexOf( 'data:' ) === 0 ) {
	
				image.src = url;
	
			} else {
	
				var loader = new THREE.XHRLoader();
				loader.setPath( this.path );
				loader.setResponseType( 'blob' );
				loader.load( url, function ( blob ) {
	
					image.src = URL.createObjectURL( blob );
	
				}, onProgress, onError );
	
			}
	
			scope.manager.itemStart( url );
	
			return image;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
			return this;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	// File:src/loaders/JSONLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.JSONLoader = function ( manager ) {
	
		if ( typeof manager === 'boolean' ) {
	
			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;
	
		}
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		this.withCredentials = false;
	
	};
	
	Object.assign( THREE.JSONLoader.prototype, {
	
		load: function( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {
	
				var json = JSON.parse( text );
				var metadata = json.metadata;
	
				if ( metadata !== undefined ) {
	
					var type = metadata.type;
	
					if ( type !== undefined ) {
	
						if ( type.toLowerCase() === 'object' ) {
	
							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
							return;
	
						}
	
						if ( type.toLowerCase() === 'scene' ) {
	
							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
							return;
	
						}
	
					}
	
				}
	
				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );
	
			}, onProgress, onError );
	
		},
	
		setTexturePath: function ( value ) {
	
			this.texturePath = value;
	
		},
	
		parse: function ( json, texturePath ) {
	
			var geometry = new THREE.Geometry(),
			scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
			parseModel( scale );
	
			parseSkin();
			parseMorphing( scale );
			parseAnimations();
	
			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();
	
			function parseModel( scale ) {
	
				function isBitSet( value, position ) {
	
					return value & ( 1 << position );
	
				}
	
				var i, j, fi,
	
				offset, zLength,
	
			colorIndex, normalIndex, uvIndex, materialIndex,
	
				type,
				isQuad,
				hasMaterial,
				hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,
	
			vertex, face, faceA, faceB, hex, normal,
	
				uvLayer, uv, u, v,
	
				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,
				colors = json.colors,
	
				nUvLayers = 0;
	
				if ( json.uvs !== undefined ) {
	
					// disregard empty arrays
	
					for ( i = 0; i < json.uvs.length; i ++ ) {
	
						if ( json.uvs[ i ].length ) nUvLayers ++;
	
					}
	
					for ( i = 0; i < nUvLayers; i ++ ) {
	
						geometry.faceVertexUvs[ i ] = [];
	
					}
	
				}
	
				offset = 0;
				zLength = vertices.length;
	
				while ( offset < zLength ) {
	
					vertex = new THREE.Vector3();
	
					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;
	
					geometry.vertices.push( vertex );
	
				}
	
				offset = 0;
				zLength = faces.length;
	
				while ( offset < zLength ) {
	
					type = faces[ offset ++ ];
	
	
					isQuad              = isBitSet( type, 0 );
					hasMaterial         = isBitSet( type, 1 );
					hasFaceVertexUv     = isBitSet( type, 3 );
					hasFaceNormal       = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor	     = isBitSet( type, 6 );
					hasFaceVertexColor  = isBitSet( type, 7 );
	
					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
					if ( isQuad ) {
	
						faceA = new THREE.Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];
	
						faceB = new THREE.Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];
	
						offset += 4;
	
						if ( hasMaterial ) {
	
							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;
	
						}
	
						// to get face <=> uv index correspondence
	
						fi = geometry.faces.length;
	
						if ( hasFaceVertexUv ) {
	
							for ( i = 0; i < nUvLayers; i ++ ) {
	
								uvLayer = json.uvs[ i ];
	
								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
	
								for ( j = 0; j < 4; j ++ ) {
	
									uvIndex = faces[ offset ++ ];
	
									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
	
									uv = new THREE.Vector2( u, v );
	
									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
								}
	
							}
	
						}
	
						if ( hasFaceNormal ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
							faceB.normal.copy( faceA.normal );
	
						}
	
						if ( hasFaceVertexNormal ) {
	
							for ( i = 0; i < 4; i ++ ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
	
								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
							}
	
						}
	
	
						if ( hasFaceColor ) {
	
							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];
	
							faceA.color.setHex( hex );
							faceB.color.setHex( hex );
	
						}
	
	
						if ( hasFaceVertexColor ) {
	
							for ( i = 0; i < 4; i ++ ) {
	
								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];
	
								if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );
	
							}
	
						}
	
						geometry.faces.push( faceA );
						geometry.faces.push( faceB );
	
					} else {
	
						face = new THREE.Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];
	
						if ( hasMaterial ) {
	
							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;
	
						}
	
						// to get face <=> uv index correspondence
	
						fi = geometry.faces.length;
	
						if ( hasFaceVertexUv ) {
	
							for ( i = 0; i < nUvLayers; i ++ ) {
	
								uvLayer = json.uvs[ i ];
	
								geometry.faceVertexUvs[ i ][ fi ] = [];
	
								for ( j = 0; j < 3; j ++ ) {
	
									uvIndex = faces[ offset ++ ];
	
									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
	
									uv = new THREE.Vector2( u, v );
	
									geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
								}
	
							}
	
						}
	
						if ( hasFaceNormal ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
						}
	
						if ( hasFaceVertexNormal ) {
	
							for ( i = 0; i < 3; i ++ ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
								face.vertexNormals.push( normal );
	
							}
	
						}
	
	
						if ( hasFaceColor ) {
	
							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );
	
						}
	
	
						if ( hasFaceVertexColor ) {
	
							for ( i = 0; i < 3; i ++ ) {
	
								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );
	
							}
	
						}
	
						geometry.faces.push( face );
	
					}
	
				}
	
			}
	
			function parseSkin() {
	
				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
	
				if ( json.skinWeights ) {
	
					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
	
						var x =                               json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
	
						geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );
	
					}
	
				}
	
				if ( json.skinIndices ) {
	
					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
	
						var a =                               json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
	
						geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );
	
					}
	
				}
	
				geometry.bones = json.bones;
	
				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
	
					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
	
				}
	
			}
	
			function parseMorphing( scale ) {
	
				if ( json.morphTargets !== undefined ) {
	
					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];
	
						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;
	
						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
							var vertex = new THREE.Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;
	
							dstVertices.push( vertex );
	
						}
	
					}
	
				}
	
				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {
	
					console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );
	
					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;
	
					for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
						faces[ i ].color.fromArray( morphColors, i * 3 );
	
					}
	
				}
	
			}
	
			function parseAnimations() {
	
				var outputAnimations = [];
	
				// parse old style Bone/Hierarchy animations
				var animations = [];
	
				if ( json.animation !== undefined ) {
	
					animations.push( json.animation );
	
				}
	
				if ( json.animations !== undefined ) {
	
					if ( json.animations.length ) {
	
						animations = animations.concat( json.animations );
	
					} else {
	
						animations.push( json.animations );
	
					}
	
				}
	
				for ( var i = 0; i < animations.length; i ++ ) {
	
					var clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );
					if ( clip ) outputAnimations.push( clip );
	
				}
	
				// parse implicit morph animations
				if ( geometry.morphTargets ) {
	
					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );
	
				}
	
				if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;
	
			}
	
			if ( json.materials === undefined || json.materials.length === 0 ) {
	
				return { geometry: geometry };
	
			} else {
	
				var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );
	
				return { geometry: geometry, materials: materials };
	
			}
	
		}
	
	} );
	
	// File:src/loaders/LoadingManager.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {
	
		var scope = this;
	
		var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
	
		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
	
		this.itemStart = function ( url ) {
	
			itemsTotal ++;
	
			if ( isLoading === false ) {
	
				if ( scope.onStart !== undefined ) {
	
					scope.onStart( url, itemsLoaded, itemsTotal );
	
				}
	
			}
	
			isLoading = true;
	
		};
	
		this.itemEnd = function ( url ) {
	
			itemsLoaded ++;
	
			if ( scope.onProgress !== undefined ) {
	
				scope.onProgress( url, itemsLoaded, itemsTotal );
	
			}
	
			if ( itemsLoaded === itemsTotal ) {
	
				isLoading = false;
	
				if ( scope.onLoad !== undefined ) {
	
					scope.onLoad();
	
				}
	
			}
	
		};
	
		this.itemError = function ( url ) {
	
			if ( scope.onError !== undefined ) {
	
				scope.onError( url );
	
			}
	
		};
	
	};
	
	THREE.DefaultLoadingManager = new THREE.LoadingManager();
	
	// File:src/loaders/BufferGeometryLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometryLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	Object.assign( THREE.BufferGeometryLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		parse: function ( json ) {
	
			var geometry = new THREE.BufferGeometry();
	
			var index = json.data.index;
	
			var TYPED_ARRAYS = {
				'Int8Array': Int8Array,
				'Uint8Array': Uint8Array,
				'Uint8ClampedArray': Uint8ClampedArray,
				'Int16Array': Int16Array,
				'Uint16Array': Uint16Array,
				'Int32Array': Int32Array,
				'Uint32Array': Uint32Array,
				'Float32Array': Float32Array,
				'Float64Array': Float64Array
			};
	
			if ( index !== undefined ) {
	
				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );
	
			}
	
			var attributes = json.data.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
	
				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );
	
			}
	
			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	
			if ( groups !== undefined ) {
	
				for ( var i = 0, n = groups.length; i !== n; ++ i ) {
	
					var group = groups[ i ];
	
					geometry.addGroup( group.start, group.count, group.materialIndex );
	
				}
	
			}
	
			var boundingSphere = json.data.boundingSphere;
	
			if ( boundingSphere !== undefined ) {
	
				var center = new THREE.Vector3();
	
				if ( boundingSphere.center !== undefined ) {
	
					center.fromArray( boundingSphere.center );
	
				}
	
				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );
	
			}
	
			return geometry;
	
		}
	
	} );
	
	// File:src/loaders/MaterialLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MaterialLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.textures = {};
	
	};
	
	Object.assign( THREE.MaterialLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		setTextures: function ( value ) {
	
			this.textures = value;
	
		},
	
		getTexture: function ( name ) {
	
			var textures = this.textures;
	
			if ( textures[ name ] === undefined ) {
	
				console.warn( 'THREE.MaterialLoader: Undefined texture', name );
	
			}
	
			return textures[ name ];
	
		},
	
		parse: function ( json ) {
	
			var material = new THREE[ json.type ];
	
			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
	
			// for PointsMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
			// maps
	
			if ( json.map !== undefined ) material.map = this.getTexture( json.map );
	
			if ( json.alphaMap !== undefined ) {
	
				material.alphaMap = this.getTexture( json.alphaMap );
				material.transparent = true;
	
			}
	
			if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
	
			if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
			if ( json.normalScale !== undefined ) {
	
				var normalScale = json.normalScale;
	
				if ( Array.isArray( normalScale ) === false ) {
	
					// Blender exporter used to export a scalar. See #7459
	
					normalScale = [ normalScale, normalScale ];
	
				}
	
				material.normalScale = new THREE.Vector2().fromArray( normalScale );
	
			}
	
			if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
	
			if ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );
	
			if ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
	
			if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );
	
			if ( json.envMap !== undefined ) {
	
				material.envMap = this.getTexture( json.envMap );
				material.combine = THREE.MultiplyOperation;
	
			}
	
			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
	
			if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
	
			if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
	
			// MultiMaterial
	
			if ( json.materials !== undefined ) {
	
				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {
	
					material.materials.push( this.parse( json.materials[ i ] ) );
	
				}
	
			}
	
			return material;
	
		}
	
	} );
	
	// File:src/loaders/ObjectLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ObjectLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';
	
	};
	
	Object.assign( THREE.ObjectLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.texturePath === '' ) {
	
				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
	
			}
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.load( url, function ( text ) {
	
				scope.parse( JSON.parse( text ), onLoad );
	
			}, onProgress, onError );
	
		},
	
		setTexturePath: function ( value ) {
	
			this.texturePath = value;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json, onLoad ) {
	
			var geometries = this.parseGeometries( json.geometries );
	
			var images = this.parseImages( json.images, function () {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			} );
	
			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
	
			var object = this.parseObject( json.object, geometries, materials );
	
			if ( json.animations ) {
	
				object.animations = this.parseAnimations( json.animations );
	
			}
	
			if ( json.images === undefined || json.images.length === 0 ) {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			}
	
			return object;
	
		},
	
		parseGeometries: function ( json ) {
	
			var geometries = {};
	
			if ( json !== undefined ) {
	
				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var geometry;
					var data = json[ i ];
	
					switch ( data.type ) {
	
						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);
	
							break;
	
						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible
	
							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);
	
							break;
	
						case 'CircleGeometry':
						case 'CircleBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'ConeGeometry':
						case 'ConeBufferGeometry':
	
							geometry = new THREE [ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'SphereGeometry':
						case 'SphereBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'DodecahedronGeometry':
						case 'IcosahedronGeometry':
						case 'OctahedronGeometry':
						case 'TetrahedronGeometry':
	
							geometry = new THREE[ data.type ](
								data.radius,
								data.detail
							);
	
							break;
	
						case 'RingGeometry':
						case 'RingBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'TorusGeometry':
						case 'TorusBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);
	
							break;
	
						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);
	
							break;
	
						case 'LatheGeometry':
						case 'LatheBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);
	
							break;
	
						case 'BufferGeometry':
	
							geometry = bufferGeometryLoader.parse( data );
	
							break;
	
						case 'Geometry':
	
							geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;
	
							break;
	
						default:
	
							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
	
							continue;
	
					}
	
					geometry.uuid = data.uuid;
	
					if ( data.name !== undefined ) geometry.name = data.name;
	
					geometries[ data.uuid ] = geometry;
	
				}
	
			}
	
			return geometries;
	
		},
	
		parseMaterials: function ( json, textures ) {
	
			var materials = {};
	
			if ( json !== undefined ) {
	
				var loader = new THREE.MaterialLoader();
				loader.setTextures( textures );
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var material = loader.parse( json[ i ] );
					materials[ material.uuid ] = material;
	
				}
	
			}
	
			return materials;
	
		},
	
		parseAnimations: function ( json ) {
	
			var animations = [];
	
			for ( var i = 0; i < json.length; i ++ ) {
	
				var clip = THREE.AnimationClip.parse( json[ i ] );
	
				animations.push( clip );
	
			}
	
			return animations;
	
		},
	
		parseImages: function ( json, onLoad ) {
	
			var scope = this;
			var images = {};
	
			function loadImage( url ) {
	
				scope.manager.itemStart( url );
	
				return loader.load( url, function () {
	
					scope.manager.itemEnd( url );
	
				} );
	
			}
	
			if ( json !== undefined && json.length > 0 ) {
	
				var manager = new THREE.LoadingManager( onLoad );
	
				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
	
					images[ image.uuid ] = loadImage( path );
	
				}
	
			}
	
			return images;
	
		},
	
		parseTextures: function ( json, images ) {
	
			function parseConstant( value ) {
	
				if ( typeof( value ) === 'number' ) return value;
	
				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
	
				return THREE[ value ];
	
			}
	
			var textures = {};
	
			if ( json !== undefined ) {
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var data = json[ i ];
	
					if ( data.image === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
	
					}
	
					if ( images[ data.image ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
					}
	
					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;
	
					texture.uuid = data.uuid;
	
					if ( data.name !== undefined ) texture.name = data.name;
	
					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
	
					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.wrap !== undefined ) {
	
						texture.wrapS = parseConstant( data.wrap[ 0 ] );
						texture.wrapT = parseConstant( data.wrap[ 1 ] );
	
					}
	
					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
	
					if ( data.flipY !== undefined ) texture.flipY = data.flipY;
	
					textures[ data.uuid ] = texture;
	
				}
	
			}
	
			return textures;
	
		},
	
		parseObject: function () {
	
			var matrix = new THREE.Matrix4();
	
			return function parseObject( data, geometries, materials ) {
	
				var object;
	
				function getGeometry( name ) {
	
					if ( geometries[ name ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
					}
	
					return geometries[ name ];
	
				}
	
				function getMaterial( name ) {
	
					if ( name === undefined ) return undefined;
	
					if ( materials[ name ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined material', name );
	
					}
	
					return materials[ name ];
	
				}
	
				switch ( data.type ) {
	
					case 'Scene':
	
						object = new THREE.Scene();
	
						break;
	
					case 'PerspectiveCamera':
	
						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
						if ( data.focus !== undefined ) object.focus = data.focus;
						if ( data.zoom !== undefined ) object.zoom = data.zoom;
						if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
						if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
						if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
	
						break;
	
					case 'OrthographicCamera':
	
						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
						break;
	
					case 'AmbientLight':
	
						object = new THREE.AmbientLight( data.color, data.intensity );
	
						break;
	
					case 'DirectionalLight':
	
						object = new THREE.DirectionalLight( data.color, data.intensity );
	
						break;
	
					case 'PointLight':
	
						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );
	
						break;
	
					case 'SpotLight':
	
						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
	
						break;
	
					case 'HemisphereLight':
	
						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );
	
						break;
	
					case 'Mesh':
	
						var geometry = getGeometry( data.geometry );
						var material = getMaterial( data.material );
	
						if ( geometry.bones && geometry.bones.length > 0 ) {
	
							object = new THREE.SkinnedMesh( geometry, material );
	
						} else {
	
							object = new THREE.Mesh( geometry, material );
	
						}
	
						break;
	
					case 'LOD':
	
						object = new THREE.LOD();
	
						break;
	
					case 'Line':
	
						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
						break;
	
					case 'LineSegments':
	
						object = new THREE.LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );
	
						break;
	
					case 'PointCloud':
					case 'Points':
	
						object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );
	
						break;
	
					case 'Sprite':
	
						object = new THREE.Sprite( getMaterial( data.material ) );
	
						break;
	
					case 'Group':
	
						object = new THREE.Group();
	
						break;
	
					default:
	
						object = new THREE.Object3D();
	
				}
	
				object.uuid = data.uuid;
	
				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {
	
					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );
	
				} else {
	
					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
				}
	
				if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
				if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
	
				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;
	
				if ( data.children !== undefined ) {
	
					for ( var child in data.children ) {
	
						object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
					}
	
				}
	
				if ( data.type === 'LOD' ) {
	
					var levels = data.levels;
	
					for ( var l = 0; l < levels.length; l ++ ) {
	
						var level = levels[ l ];
						var child = object.getObjectByProperty( 'uuid', level.object );
	
						if ( child !== undefined ) {
	
							object.addLevel( child, level.distance );
	
						}
	
					}
	
				}
	
				return object;
	
			};
	
		}()
	
	} );
	
	// File:src/loaders/TextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.TextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	Object.assign( THREE.TextureLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var texture = new THREE.Texture();
	
			var loader = new THREE.ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
			loader.load( url, function ( image ) {
	
				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
	
				texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
				texture.image = image;
				texture.needsUpdate = true;
	
				if ( onLoad !== undefined ) {
	
					onLoad( texture );
	
				}
	
			}, onProgress, onError );
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
			return this;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	// File:src/loaders/CubeTextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CubeTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	Object.assign( THREE.CubeTextureLoader.prototype, {
	
		load: function ( urls, onLoad, onProgress, onError ) {
	
			var texture = new THREE.CubeTexture();
	
			var loader = new THREE.ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
	
			var loaded = 0;
	
			function loadTexture( i ) {
	
				loader.load( urls[ i ], function ( image ) {
	
					texture.images[ i ] = image;
	
					loaded ++;
	
					if ( loaded === 6 ) {
	
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, undefined, onError );
	
			}
	
			for ( var i = 0; i < urls.length; ++ i ) {
	
				loadTexture( i );
	
			}
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
			return this;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	// File:src/loaders/BinaryTextureLoader.js
	
	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */
	
	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	};
	
	Object.assign( THREE.BinaryTextureLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texture = new THREE.DataTexture();
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
	
			loader.load( url, function ( buffer ) {
	
				var texData = scope._parser( buffer );
	
				if ( ! texData ) return;
	
				if ( undefined !== texData.image ) {
	
					texture.image = texData.image;
	
				} else if ( undefined !== texData.data ) {
	
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
	
				}
	
				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
	
				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
	
				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	
				if ( undefined !== texData.format ) {
	
					texture.format = texData.format;
	
				}
				if ( undefined !== texData.type ) {
	
					texture.type = texData.type;
	
				}
	
				if ( undefined !== texData.mipmaps ) {
	
					texture.mipmaps = texData.mipmaps;
	
				}
	
				if ( 1 === texData.mipmapCount ) {
	
					texture.minFilter = THREE.LinearFilter;
	
				}
	
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture, texData );
	
			}, onProgress, onError );
	
	
			return texture;
	
		}
	
	} );
	
	// File:src/loaders/CompressedTextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */
	
	THREE.CompressedTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	};
	
	Object.assign( THREE.CompressedTextureLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var images = [];
	
			var texture = new THREE.CompressedTexture();
			texture.image = images;
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
	
			function loadTexture( i ) {
	
				loader.load( url[ i ], function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
	
					loaded += 1;
	
					if ( loaded === 6 ) {
	
						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = THREE.LinearFilter;
	
						texture.format = texDatas.format;
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, onProgress, onError );
	
			}
	
			if ( Array.isArray( url ) ) {
	
				var loaded = 0;
	
				for ( var i = 0, il = url.length; i < il; ++ i ) {
	
					loadTexture( i );
	
				}
	
			} else {
	
				// compressed cubemap texture stored in a single DDS file
	
				loader.load( url, function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					if ( texDatas.isCubemap ) {
	
						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
						for ( var f = 0; f < faces; f ++ ) {
	
							images[ f ] = { mipmaps : [] };
	
							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;
	
							}
	
						}
	
					} else {
	
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
	
					}
	
					if ( texDatas.mipmapCount === 1 ) {
	
						texture.minFilter = THREE.LinearFilter;
	
					}
	
					texture.format = texDatas.format;
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture );
	
				}, onProgress, onError );
	
			}
	
			return texture;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	// File:src/materials/Map.js
	
	/**
	 * @author Ben Houston / bhouston / http://clara.io
	 *
	 */
	
	THREE.Map = function ( name, uvChannel, uvTransform, texelTransform ) {
	
	  this.name = name || "unnamed";
	
	  this.texture = null;
	
	  this.uvChannel = uvChannel || 0;
	
	  this.uvTransform = uvTransform || false;
	  this.uvOffset = new THREE.Vector2( 0, 0 );
	  this.uvRepeat = new THREE.Vector2( 1.0, 1.0 );
	  //this.uvRotation = 0;  - not implemented because offset/repeat fix in a vec4 uniform, rotation doesn't.
	
	  this.texelTransform = uvTransform || false;
	  this.texelScale = 1.0;
	  this.texelOffset = 0.0;
	  this.texelInvert = false;
	
	};
	
	THREE.Map.prototype = {
	
	  constructor: THREE.Map,
	
	  copy: function ( source ) {
	
	    this.name = source.name;
	
	  	this.texture = source.texture;
	
	    this.uvChannel = source.uvChannel;
	
	    this.uvTransform = source.uvTransform;
	    this.uvOffset = source.uvOffset;
	    this.uvRepeat = source.uvRepeat;
	    //this.uvRotation = source.uvRotation;
	
	    this.texelTransform = source.texelTransform;
	    this.texelScale = source.texelScale;
	    this.texelOffset = source.texelOffset;
	    this.texelInvert = source.texelInvert;
	
	  	return this;
	
	  },
	
	  // bakes all the input texel parameters into just two.
	  getFlattenedTexelTransform: function( optionalTexelTransform ) {
	      var texelTransform = optionalTexelTransform || {};
	      if( this.texelInvert ) {
	        texelTransform.texelScale = -this.texelScale;
	        texelTransform.texelOffset = this.texelScale + this.texelOffset;
	      }
	      else {
	        texelTransform.texelScale = this.texelScale;
	        texelTransform.texelOffset = this.texelOffset;
	      }
	      return texelTransform;
	  }
	
	};
	
	THREE.Map.SupportedMapNames = [
		'map', 'lightMap', 'aoMap', 'emissiveMap', 'specularMap', 'bumpMap', 'normalMap', 'roughnessMap', 'metalnessMap', 'alphaMap', 'displacementMap', 'falloffMap', 'falloffAlphaMap'
	];
	THREE.Map.SupportedMapSlotNames = [];
	THREE.Map.SupportedMapUVNames = [];
	THREE.Map.SupportedMapTexelNames = [];
	
	for( var i = 0; i < THREE.Map.SupportedMapNames.length; i ++ ) {
	  var name = THREE.Map.SupportedMapNames [i];
	  THREE.Map.SupportedMapSlotNames.push( name + 'Slot' );
	  THREE.Map.SupportedMapUVNames.push( name + 'UVTransformParams' );
	  THREE.Map.SupportedMapTexelNames.push( name + 'TexelTransformParams' );
	}
	// File:src/materials/Material.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Material = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Material';
	
		this.fog = true;
		this.lights = true;
	
		this.blending = THREE.NormalBlending;
		this.side = THREE.FrontSide;
		this.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading
		this.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
	
		this.opacity = 1;
		this.transparent = false;
	
		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
	
		this.depthFunc = THREE.LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
	
		this.clippingPlanes = null;
		this.clipShadows = false;
	
		this.colorWrite = true;
	
		this.precision = null; // override the renderer's default precision for this material
	
		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
	
		this.alphaTest = 0;
		this.premultipliedAlpha = false;
	
		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
		this.visible = true;
	
		this._needsUpdate = true;
	
		this.version = 0;
	
	};
	
	THREE.Material.prototype = {
	
		constructor: THREE.Material,
	
		get needsUpdate() {
	
			return this._needsUpdate;
	
		},
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.update();
			this._needsUpdate = value;
			this.version ++;
	
		},
	
		setValues: function ( values ) {
	
			if ( values === undefined ) return;
	
			for ( var key in values ) {
	
				var newValue = values[ key ];
	
				if ( newValue === undefined ) {
	
					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;
	
				}
	
				var currentValue = this[ key ];
	
				if ( currentValue === undefined ) {
	
					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;
	
				}
	
				if ( currentValue instanceof THREE.Color ) {
	
					currentValue.set( newValue );
	
				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {
	
					currentValue.copy( newValue );
	
				} else if ( key === 'overdraw' ) {
	
					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );
	
				} else {
	
					this[ key ] = newValue;
	
				}
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			var isRoot = meta === undefined;
	
			if ( isRoot ) {
	
				meta = {
					textures: {},
					images: {}
				};
	
			}
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};
	
			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
	
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
	
			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;
	
			if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
			if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
	
			if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
			if ( this.bumpMap instanceof THREE.Texture ) {
	
				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;
	
			}
			if ( this.normalMap instanceof THREE.Texture ) {
	
				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalScale = this.normalScale.toArray();
	
			}
			if ( this.displacementMap instanceof THREE.Texture ) {
	
				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
	
			}
			if ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
	
			if ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
	
			if ( this.envMap instanceof THREE.Texture ) {
	
				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap
	
			}
	
			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
	
			if ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;
			if ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;
			if ( this.side !== THREE.FrontSide ) data.side = this.side;
			if ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
	
			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;
			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
	
			// TODO: Copied from Object3D.toJSON
	
			function extractFromCache ( cache ) {
	
				var values = [];
	
				for ( var key in cache ) {
	
					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
	
				}
	
				return values;
	
			}
	
			if ( isRoot ) {
	
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
	
				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;
	
			}
	
			return data;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.name = source.name;
	
			this.fog = source.fog;
			this.lights = source.lights;
	
			this.blending = source.blending;
			this.side = source.side;
			this.shading = source.shading;
			this.vertexColors = source.vertexColors;
	
			this.opacity = source.opacity;
			this.transparent = source.transparent;
	
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
	
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
	
			this.colorWrite = source.colorWrite;
	
			this.precision = source.precision;
	
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
	
			this.alphaTest = source.alphaTest;
	
			this.premultipliedAlpha = source.premultipliedAlpha;
	
			this.overdraw = source.overdraw;
	
			this.visible = source.visible;
			this.clipShadows = source.clipShadows;
	
			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;
	
			if ( srcPlanes !== null ) {
	
				var n = srcPlanes.length;
				dstPlanes = new Array( n );
	
				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();
	
			}
	
			this.clippingPlanes = dstPlanes;
	
			return this;
	
		},
	
		update: function () {
	
			this.dispatchEvent( { type: 'update' } );
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	Object.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );
	
	THREE.MaterialIdCount = 0;
	
	// File:src/materials/LineBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */
	
	THREE.LineBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
	
		this.lights = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
	
	THREE.LineBasicMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
	
		return this;
	
	};
	
	// File:src/materials/LineDashedMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */
	
	THREE.LineDashedMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineDashedMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
	
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
	
		this.lights = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
	
	THREE.LineDashedMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.linewidth = source.linewidth;
	
		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
	
		return this;
	
	};
	
	// File:src/materials/MeshBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */
	
	THREE.MeshBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // emissive
	
		this.map = null;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.lights = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
	
	THREE.MeshBasicMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
	
		return this;
	
	};
	
	// File:src/materials/MeshDepthMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshDepthMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshDepthMaterial';
	
		this.depthPacking = THREE.BasicDepthPacking;
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.map = null;
	
		this.alphaMap = null;
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false;
		this.lights = false;
	
		// far clipping plane in both RGBA and Basic encoding
		this.clearColor = new THREE.Color( 1.0, 1.0, 1.0 );
		this.clearAlpha = 1.0;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
	
	THREE.MeshDepthMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.depthPacking = source.depthPacking;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
	
		this.map = source.map;
	
		this.alphaMap = source.alphaMap;
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		this.clearColor = source.clearColor;
		this.clearAlpha = source.clearAlpha;
	
		return this;
	
	};
	
	// File:src/materials/MeshLambertMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	THREE.MeshLambertMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshLambertMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
	
	THREE.MeshLambertMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshCubeMaterial.js
	
	/**
	 * @author bhouston / http://clara.io/
	 *
	 */
	
	THREE.MeshCubeMaterial = function ( parameters ) {
	
		THREE.Material.call( this, parameters );
	
		this.type = 'MeshCubeMaterial';
	
		this.envMap = null;
		this.envMapIntensity = 1.0;
	
		this.roughness = 0.0;
	
		this.depthTest = false;
		this.depthWrite = false;
		this.side = THREE.BackSide;
	
		this.lights = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshCubeMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshCubeMaterial.prototype.constructor = THREE.MeshCubeMaterial;
	
	THREE.MeshCubeMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;
	
		this.roughness = source.roughness;
	
		return this;
	
	};
	
	// File:src/materials/MeshNormalMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshNormalMaterial = function ( parameters ) {
	
		THREE.Material.call( this, parameters );
	
		this.type = 'MeshNormalMaterial';
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false;
		this.lights = false;
		this.morphTargets = false;
	
		// default normal is facing the camera.
		this.clearColor = new THREE.Color( 0.5, 0.5, 1.0 );
		this.clearAlpha = 1.0;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
	
	THREE.MeshNormalMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		this.clearColor = source.clearColor;
		this.clearAlpha = source.clearAlpha;
	
		return this;
	
	};
	
	// File:src/materials/MeshPhongMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	THREE.MeshPhongMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshPhongMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
	
	THREE.MeshPhongMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshStandardMaterial.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Ben Houston / bhouston / http://clara.io
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	THREE.MeshStandardMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.defines = { 'STANDARD': '' };
	
		this.type = 'MeshStandardMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		//this.map = null;
		this.mapSlot = new THREE.Map( "map", 0, false, false );
	
		this.reflectivity = 0.5;
	
		this.roughness = 0.5;
		//this.roughnessMap = null;
		this.roughnessMapSlot = new THREE.Map( "roughnessMap", 0, false, false );
	
		this.metalness = 0.5;
		//this.metalnessMap = null;
		this.metalnessMapSlot = new THREE.Map( "metalnessMap", 0, false, false );
	
		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		//this.emissiveMap = null;
		this.emissiveMapSlot = new THREE.Map( "emissiveMap", 0, false, false );
	
		//this.bumpMap = null;
		//this.bumpScale = 1;
		this.bumpMapSlot = new THREE.Map( "bumpMap", 0, false, true );
	
		//this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
		this.normalMapSlot = new THREE.Map( "normalMap", 0, false, false );
	
		//this.displacementMap = null;
		//this.displacementScale = 1;
		//this.displacementBias = 0;
		this.displacementMapSlot = new THREE.Map( "displacementMap", 0, false, true );
	
		//this.lightMap = null;
		//this.lightMapIntensity = 1.0;
		this.lightMapSlot = new THREE.Map( "lightMap", 1, false, true );
	
		//this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.aoMapSlot = new THREE.Map( "aoMap", 1, false, true );
	
		//this.alphaMap = null;
		this.alphaMapSlot = new THREE.Map( "alphaMap", 0, false, false );
	
		this.envMap = null;
		this.envMapIntensity = 1.0;
	
		this.refractionRatio = 0.98;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;
	
	var closure = function () {
		var propertyMappings = {
			"map": {
			  get: function() {
					return this.mapSlot.texture;
			  },
				set: function( value ) {
					this.mapSlot.texture = value;
				}
			},
			"lightMap": {
			  get: function() {
					return this.lightMapSlot.texture;
			  },
				set: function( value ) {
					this.lightMapSlot.texture = value;
				}
			},
			"lightMapIntensity": {
			  get: function() {
					return this.lightMapSlot.texelScale;
			  },
				set: function( value ) {
					this.lightMapSlot.texelTransform = true;
					this.lightMapSlot.texelScale = value;
				}
			},
			"aoMap": {
			  get: function() {
					return this.aoMapSlot.texture;
			  },
				set: function( value ) {
					this.aoMapSlot.texture = value;
				}
			},
			"emissiveMap": {
			  get: function() {
					return this.emissiveMapSlot.texture;
			  },
				set: function( value ) {
					this.emissiveMapSlot.texture = value;
				}
			},
			"bumpMap": {
			  get: function() {
					return this.bumpMapSlot.texture;
			  },
				set: function( value ) {
					this.bumpMapSlot.texture = value;
				}
			},
			"bumpScale": {
			  get: function() {
					return this.bumpMapSlot.texelScale;
			  },
				set: function( value ) {
					this.bumpMapSlot.texelTransform = true;
					this.bumpMapSlot.texelScale = value;
				}
			},
			"normalMap": {
			  get: function() {
					return this.normalMapSlot.texture;
			  },
				set: function( value ) {
					this.normalMapSlot.texture = value;
				}
			},
			"displacementMap": {
			  get: function() {
					return this.displacementMapSlot.texture;
			  },
				set: function( value ) {
					this.displacementMapSlot.texture = value;
				}
			},
			"displacementScale": {
			  get: function() {
					return this.displacementMapSlot.texelScale;
			  },
				set: function( value ) {
					this.displacementMapSlot.texelTransform = true;
					this.displacementMapSlot.texelScale = value;
				}
			},
			"displacementBias": {
			  get: function() {
					return this.displacementMapSlot.texelOffset;
			  },
				set: function( value ) {
					this.displacementMapSlot.texelTransform = true;
					this.displacementMapSlot.texelOffset = value;
				}
			},
			"roughnessMap": {
			  get: function() {
					return this.roughnessMapSlot.texture;
			  },
				set: function( value ) {
					this.roughnessMapSlot.texture = value;
				}
			},
			"metalnessMap": {
			  get: function() {
					return this.metalnessMapSlot.texture;
			  },
				set: function( value ) {
					this.metalnessMapSlot.texture = value;
				}
			},
			"alphaMap": {
			  get: function() {
					return this.alphaMapSlot.texture;
			  },
				set: function( value ) {
					this.alphaMapSlot.texture = value;
				}
			}
		};
		for( var propertyName in propertyMappings ) {
			Object.defineProperty(THREE.MeshStandardMaterial.prototype, propertyName, propertyMappings[ propertyName ] );
		}
	}();
	
	THREE.MeshStandardMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.defines = { 'STANDARD': '' };
	
		this.color.copy( source.color );
		this.mapSlot.copy( source.mapSlot );
	
		this.reflectivity = source.reflectivity;
	
		this.roughness = source.roughness;
		this.roughnessMapSlot.copy( source.roughnessMapSlot );
	
		this.metalness = source.metalness;
		this.metalnessMapSlot.copy( source.metalnessMapSlot );
	
		this.lightMapSlot.copy( source.lightMapSlot );
	
		this.aoMapIntensity = source.aoMapIntensity;
		this.aoMapSlot.copy( source.aoMapSlot );
	
		this.emissive.copy( source.emissive );
		this.emissiveIntensity = source.emissiveIntensity;
		this.emissiveMapSlot.copy( source.emissiveMapSlot );
	
		this.bumpMapSlot.copy( source.bumpMapSlot );
	
		this.normalScale.copy( source.normalScale );
		this.normalMapSlot.copy( source.normalMapSlot );
	
		this.displacementMapSlot.copy( source.displacementMapSlot );
	
		this.alphaMapSlot.copy( source.alphaMapSlot );
	
		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;
	
		this.refractionRatio = source.refractionRatio;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshPhysicalMaterial.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 * }
	 */
	
	THREE.MeshPhysicalMaterial = function ( parameters ) {
	
		THREE.MeshStandardMaterial.call( this );
	
		this.defines = { 'PHYSICAL': '' };
	
		this.type = 'MeshPhysicalMaterial';
	
		this.reflectivity = 0.5; // maps to F0 = 0.04
	
		this.falloff = false;
		this.falloffColor = new THREE.Color( 0xffffff );
		this.falloffMapSlot = new THREE.Map( "falloffMap", 0, false, false );
		this.falloffOpacity = 1.0;
		this.falloffAlphaMapSlot = new THREE.Map( "falloffAlphaMap", 0, false, false );
	
		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );
	THREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;
	
	
	var closure = function () {
		var propertyMappings = {
			"falloffMap": {
			  get: function() {
					return this.falloffMapSlot.texture;
			  },
				set: function( value ) {
					this.falloffMapSlot.texture = value;
				}
			},
			"falloffAlphaMap": {
			  get: function() {
					return this.falloffAlphaMapSlot.texture;
			  },
				set: function( value ) {
					this.falloffAlphaMapSlot.texture = value;
				}
			}
		};
		for( var propertyName in propertyMappings ) {
			Object.defineProperty(THREE.MeshPhysicalMaterial.prototype, propertyName, propertyMappings[ propertyName ] );
		}
	}();
	
	THREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {
	
		THREE.MeshStandardMaterial.prototype.copy.call( this, source );
	
		this.defines = { 'PHYSICAL': '' };
	
		this.reflectivity = source.reflectivity;
	
		this.falloff = source.falloff;
		this.falloffColor.copy( source.falloffColor );
		this.falloffMapSlot.copy( source.falloffMapSlot );
		this.falloffOpacity = source.falloffOpacity;
		this.falloffAlphaMapSlot.copy( source.falloffAlphaMapSlot );
	
		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;
	
		return this;
	
	};
	
	// File:src/materials/MultiMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MultiMaterial = function ( materials ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.type = 'MultiMaterial';
	
		this.materials = materials instanceof Array ? materials : [];
	
		this.visible = true;
	
	};
	
	THREE.MultiMaterial.prototype = {
	
		constructor: THREE.MultiMaterial,
	
		toJSON: function ( meta ) {
	
			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};
	
			var materials = this.materials;
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				var material = materials[ i ].toJSON( meta );
				delete material.metadata;
	
				output.materials.push( material );
	
			}
	
			output.visible = this.visible;
	
			return output;
	
		},
	
		clone: function () {
	
			var material = new this.constructor();
	
			for ( var i = 0; i < this.materials.length; i ++ ) {
	
				material.materials.push( this.materials[ i ].clone() );
	
			}
	
			material.visible = this.visible;
	
			return material;
	
		}
	
	};
	
	// File:src/materials/PointsMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */
	
	THREE.PointsMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'PointsMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.map = null;
	
		this.size = 1;
		this.sizeAttenuation = true;
	
		this.lights = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
	
	THREE.PointsMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
	
		return this;
	
	};
	
	// File:src/materials/ShaderMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	THREE.ShaderMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'ShaderMaterial';
	
		this.defines = {};
		this.uniforms = {};
	
		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
		this.linewidth = 1;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes
	
		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals
	
		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};
	
		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};
	
		this.index0AttributeName = undefined;
	
		if ( parameters !== undefined ) {
	
			if ( parameters.attributes !== undefined ) {
	
				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
	
			}
	
			this.setValues( parameters );
	
		}
	
	};
	
	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
	
	THREE.ShaderMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
	
		this.uniforms = THREE.UniformsUtils.clone( source.uniforms );
	
		this.defines = source.defines;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		this.lights = source.lights;
		this.clipping = source.clipping;
	
		this.skinning = source.skinning;
	
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		this.extensions = source.extensions;
	
		return this;
	
	};
	
	THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Material.prototype.toJSON.call( this, meta );
	
		data.uniforms = this.uniforms;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
	
		return data;
	
	};
	
	// File:src/materials/RawShaderMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RawShaderMaterial = function ( parameters ) {
	
		THREE.ShaderMaterial.call( this, parameters );
	
		this.type = 'RawShaderMaterial';
	
	};
	
	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
	
	// File:src/materials/SpriteMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2()
	 * }
	 */
	
	THREE.SpriteMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'SpriteMaterial';
	
		this.color = new THREE.Color( 0xffffff );
		this.map = null;
	
		this.rotation = 0;
	
		this.fog = false;
		this.lights = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
	
	THREE.SpriteMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.map = source.map;
	
		this.rotation = source.rotation;
	
		return this;
	
	};
	
	// File:src/materials/ShadowMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ShadowMaterial = function () {
	
		THREE.ShaderMaterial.call( this, {
			uniforms: THREE.UniformsUtils.merge( [
				THREE.UniformsLib[ "lights" ],
				{
					opacity: { value: 1.0 }
				}
			] ),
			vertexShader: THREE.ShaderChunk[ 'shadow_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]
		} );
	
		this.lights = true;
		this.transparent = true;
	
		Object.defineProperties( this, {
			opacity: {
				enumerable: true,
				get: function () {
					return this.uniforms.opacity.value;
				},
				set: function ( value ) {
					this.uniforms.opacity.value = value;
				}
			}
		} );
	
	};
	
	THREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;
	
	// File:src/textures/Texture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.sourceFile = '';
	
		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];
	
		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
	
		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
	
		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;
	
		this.version = 0;
		this.onUpdate = null;
	
	};
	
	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
	
	THREE.Texture.prototype = {
	
		constructor: THREE.Texture,
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );
	
			this.mapping = source.mapping;
	
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
	
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
	
			this.anisotropy = source.anisotropy;
	
			this.format = source.format;
			this.type = source.type;
	
			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
	
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
	
			return this;
	
		},
	
		toJSON: function ( meta ) {
	
			if ( meta.textures[ this.uuid ] !== undefined ) {
	
				return meta.textures[ this.uuid ];
	
			}
	
			function getDataURL( image ) {
	
				var canvas;
	
				if ( image.toDataURL !== undefined ) {
	
					canvas = image;
	
				} else {
	
					canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;
	
					canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );
	
				}
	
				if ( canvas.width > 2048 || canvas.height > 2048 ) {
	
					return canvas.toDataURL( 'image/jpeg', 0.6 );
	
				} else {
	
					return canvas.toDataURL( 'image/png' );
	
				}
	
			}
	
			var output = {
				metadata: {
					version: 4.4,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
	
				uuid: this.uuid,
				name: this.name,
	
				mapping: this.mapping,
	
				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				wrap: [ this.wrapS, this.wrapT ],
	
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
	
				flipY: this.flipY
			};
	
			if ( this.image !== undefined ) {
	
				// TODO: Move to THREE.Image
	
				var image = this.image;
	
				if ( image.uuid === undefined ) {
	
					image.uuid = THREE.Math.generateUUID(); // UGH
	
				}
	
				if ( meta.images[ image.uuid ] === undefined ) {
	
					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: getDataURL( image )
					};
	
				}
	
				output.image = image.uuid;
	
			}
	
			meta.textures[ this.uuid ] = output;
	
			return output;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		},
	
		transformUv: function ( uv ) {
	
			if ( this.mapping !== THREE.UVMapping )  return;
	
			uv.multiply( this.repeat );
			uv.add( this.offset );
	
			if ( uv.x < 0 || uv.x > 1 ) {
	
				switch ( this.wrapS ) {
	
					case THREE.RepeatWrapping:
	
						uv.x = uv.x - Math.floor( uv.x );
						break;
	
					case THREE.ClampToEdgeWrapping:
	
						uv.x = uv.x < 0 ? 0 : 1;
						break;
	
					case THREE.MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
	
							uv.x = Math.ceil( uv.x ) - uv.x;
	
						} else {
	
							uv.x = uv.x - Math.floor( uv.x );
	
						}
						break;
	
				}
	
			}
	
			if ( uv.y < 0 || uv.y > 1 ) {
	
				switch ( this.wrapT ) {
	
					case THREE.RepeatWrapping:
	
						uv.y = uv.y - Math.floor( uv.y );
						break;
	
					case THREE.ClampToEdgeWrapping:
	
						uv.y = uv.y < 0 ? 0 : 1;
						break;
	
					case THREE.MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
	
							uv.y = Math.ceil( uv.y ) - uv.y;
	
						} else {
	
							uv.y = uv.y - Math.floor( uv.y );
	
						}
						break;
	
				}
	
			}
	
			if ( this.flipY ) {
	
				uv.y = 1 - uv.y;
	
			}
	
		}
	
	};
	
	Object.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );
	
	THREE.TextureIdCount = 0;
	
	// File:src/textures/DepthTexture.js
	
	/**
	 * @author Matt DesLauriers / @mattdesl
	 */
	
	THREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
	  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );
	
	  this.image = { width: width, height: height };
	
	  this.type = type !== undefined ? type : THREE.UnsignedShortType;
	
	  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
	  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
	
	  this.flipY = false;
	  this.generateMipmaps  = false;
	
	};
	
	THREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DepthTexture.prototype.constructor = THREE.DepthTexture;
	
	// File:src/textures/CanvasTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.needsUpdate = true;
	
	};
	
	THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
	
	// File:src/textures/CubeTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
	
		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
		this.flipY = false;
	
	};
	
	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
	
	Object.defineProperty( THREE.CubeTexture.prototype, 'images', {
	
		get: function () {
	
			return this.image;
	
		},
	
		set: function ( value ) {
	
			this.image = value;
	
		}
	
	} );
	
	// File:src/textures/CompressedTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;
	
		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )
	
		this.flipY = false;
	
		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files
	
		this.generateMipmaps = false;
	
	};
	
	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
	
	// File:src/textures/DataTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
		this.image = { data: data, width: width, height: height };
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
	
		this.flipY = false;
		this.generateMipmaps  = false;
	
	};
	
	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;
	
	// File:src/textures/VideoTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.generateMipmaps = false;
	
		var scope = this;
	
		function update() {
	
			requestAnimationFrame( update );
	
			if ( video.readyState >= video.HAVE_CURRENT_DATA ) {
	
				scope.needsUpdate = true;
	
			}
	
		}
	
		update();
	
	};
	
	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
	
	// File:src/objects/Group.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Group = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Group';
	
	};
	
	THREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.Group
	
	} );
	
	// File:src/objects/Points.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Points = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Points';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
		this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );
	
	};
	
	THREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.Points,
	
		raycast: ( function () {
	
			var inverseMatrix = new THREE.Matrix4();
			var ray = new THREE.Ray();
			var sphere = new THREE.Sphere();
	
			return function raycast( raycaster, intersects ) {
	
				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;
	
				// Checking boundingSphere distance to ray
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
	
				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
				//
	
				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;
				var position = new THREE.Vector3();
	
				function testPoint( point, index ) {
	
					var rayPointDistanceSq = ray.distanceSqToPoint( point );
	
					if ( rayPointDistanceSq < localThresholdSq ) {
	
						var intersectPoint = ray.closestPointToPoint( point );
						intersectPoint.applyMatrix4( matrixWorld );
	
						var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
						if ( distance < raycaster.near || distance > raycaster.far ) return;
	
						intersects.push( {
	
							distance: distance,
							distanceToRay: Math.sqrt( rayPointDistanceSq ),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object
	
						} );
	
					}
	
				}
	
				if ( geometry instanceof THREE.BufferGeometry ) {
	
					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;
	
					if ( index !== null ) {
	
						var indices = index.array;
	
						for ( var i = 0, il = indices.length; i < il; i ++ ) {
	
							var a = indices[ i ];
	
							position.fromArray( positions, a * 3 );
	
							testPoint( position, a );
	
						}
	
					} else {
	
						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
	
							position.fromArray( positions, i * 3 );
	
							testPoint( position, i );
	
						}
	
					}
	
				} else {
	
					var vertices = geometry.vertices;
	
					for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
						testPoint( vertices[ i ], i );
	
					}
	
				}
	
			};
	
		}() ),
	
		clone: function () {
	
			return new this.constructor( this.geometry, this.material ).copy( this );
	
		}
	
	} );
	
	// File:src/objects/Line.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Line = function ( geometry, material, mode ) {
	
		if ( mode === 1 ) {
	
			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new THREE.LineSegments( geometry, material );
	
		}
	
		THREE.Object3D.call( this );
	
		this.type = 'Line';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
	};
	
	THREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.Line,
	
		raycast: ( function () {
	
			var inverseMatrix = new THREE.Matrix4();
			var ray = new THREE.Ray();
			var sphere = new THREE.Sphere();
	
			return function raycast( raycaster, intersects ) {
	
				var precision = raycaster.linePrecision;
				var precisionSq = precision * precision;
	
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
	
				// Checking boundingSphere distance to ray
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
	
				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
				//
	
				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
				var vStart = new THREE.Vector3();
				var vEnd = new THREE.Vector3();
				var interSegment = new THREE.Vector3();
				var interRay = new THREE.Vector3();
				var step = this instanceof THREE.LineSegments ? 2 : 1;
	
				if ( geometry instanceof THREE.BufferGeometry ) {
	
					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;
	
					if ( index !== null ) {
	
						var indices = index.array;
	
						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
	
							var a = indices[ i ];
							var b = indices[ i + 1 ];
	
							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );
	
							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
							if ( distSq > precisionSq ) continue;
	
							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
							var distance = raycaster.ray.origin.distanceTo( interRay );
	
							if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					} else {
	
						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
	
							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );
	
							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
							if ( distSq > precisionSq ) continue;
	
							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
							var distance = raycaster.ray.origin.distanceTo( interRay );
	
							if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					}
	
				} else if ( geometry instanceof THREE.Geometry ) {
	
					var vertices = geometry.vertices;
					var nbVertices = vertices.length;
	
					for ( var i = 0; i < nbVertices - 1; i += step ) {
	
						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
						if ( distSq > precisionSq ) continue;
	
						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
						var distance = raycaster.ray.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				}
	
			};
	
		}() ),
	
		clone: function () {
	
			return new this.constructor( this.geometry, this.material ).copy( this );
	
		}
	
	} );
	
	// File:src/objects/LineSegments.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LineSegments = function ( geometry, material ) {
	
		THREE.Line.call( this, geometry, material );
	
		this.type = 'LineSegments';
	
	};
	
	THREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {
	
		constructor: THREE.LineSegments
	
	} );
	
	// File:src/objects/Mesh.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */
	
	THREE.Mesh = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Mesh';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.drawMode = THREE.TrianglesDrawMode;
	
		this.updateMorphTargets();
	
	};
	
	THREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.Mesh,
	
		setDrawMode: function ( value ) {
	
			this.drawMode = value;
	
		},
	
		copy: function ( source ) {
	
			THREE.Object3D.prototype.copy.call( this, source );
	
			this.drawMode = source.drawMode;
	
			return this;
	
		},
	
		updateMorphTargets: function () {
	
			if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {
	
				this.morphTargetBase = - 1;
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};
	
				for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {
	
					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;
	
				}
	
			}
	
		},
	
		getMorphTargetIndexByName: function ( name ) {
	
			if ( this.morphTargetDictionary[ name ] !== undefined ) {
	
				return this.morphTargetDictionary[ name ];
	
			}
	
			console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );
	
			return 0;
	
		},
	
		raycast: ( function () {
	
			var inverseMatrix = new THREE.Matrix4();
			var ray = new THREE.Ray();
			var sphere = new THREE.Sphere();
	
			var vA = new THREE.Vector3();
			var vB = new THREE.Vector3();
			var vC = new THREE.Vector3();
	
			var tempA = new THREE.Vector3();
			var tempB = new THREE.Vector3();
			var tempC = new THREE.Vector3();
	
			var uvA = new THREE.Vector2();
			var uvB = new THREE.Vector2();
			var uvC = new THREE.Vector2();
	
			var barycoord = new THREE.Vector3();
	
			var intersectionPoint = new THREE.Vector3();
			var intersectionPointWorld = new THREE.Vector3();
	
			function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
	
				THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
	
				uv1.multiplyScalar( barycoord.x );
				uv2.multiplyScalar( barycoord.y );
				uv3.multiplyScalar( barycoord.z );
	
				uv1.add( uv2 ).add( uv3 );
	
				return uv1.clone();
	
			}
	
			function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {
	
				var intersect;
				var material = object.material;
	
				if ( material.side === THREE.BackSide ) {
	
					intersect = ray.intersectTriangle( pC, pB, pA, true, point );
	
				} else {
	
					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );
	
				}
	
				if ( intersect === null ) return null;
	
				intersectionPointWorld.copy( point );
				intersectionPointWorld.applyMatrix4( object.matrixWorld );
	
				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
	
				if ( distance < raycaster.near || distance > raycaster.far ) return null;
	
				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};
	
			}
	
			function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {
	
				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );
	
				var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
	
				if ( intersection ) {
	
					if ( uvs ) {
	
						uvA.fromArray( uvs, a * 2 );
						uvB.fromArray( uvs, b * 2 );
						uvC.fromArray( uvs, c * 2 );
	
						intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );
	
					}
	
					intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
					intersection.faceIndex = a;
	
				}
	
				return intersection;
	
			}
	
			return function raycast( raycaster, intersects ) {
	
				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;
	
				if ( material === undefined ) return;
	
				// Checking boundingSphere distance to ray
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
	
				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
				//
	
				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
				// Check boundingBox before continuing
	
				if ( geometry.boundingBox !== null ) {
	
					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
	
				}
	
				var uvs, intersection;
	
				if ( geometry instanceof THREE.BufferGeometry ) {
	
					var a, b, c;
					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;
	
					if ( attributes.uv !== undefined ) {
	
						uvs = attributes.uv.array;
	
					}
	
					if ( index !== null ) {
	
						var indices = index.array;
	
						for ( var i = 0, l = indices.length; i < l; i += 3 ) {
	
							a = indices[ i ];
							b = indices[ i + 1 ];
							c = indices[ i + 2 ];
	
							intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
							if ( intersection ) {
	
								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
								intersects.push( intersection );
	
							}
	
						}
	
					} else {
	
	
						for ( var i = 0, l = positions.length; i < l; i += 9 ) {
	
							a = i / 3;
							b = a + 1;
							c = a + 2;
	
							intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
							if ( intersection ) {
	
								intersection.index = a; // triangle number in positions buffer semantics
								intersects.push( intersection );
	
							}
	
						}
	
					}
	
				} else if ( geometry instanceof THREE.Geometry ) {
	
					var fvA, fvB, fvC;
					var isFaceMaterial = material instanceof THREE.MultiMaterial;
					var materials = isFaceMaterial === true ? material.materials : null;
	
					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
	
					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
						var face = faces[ f ];
						var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;
	
						if ( faceMaterial === undefined ) continue;
	
						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];
	
						if ( faceMaterial.morphTargets === true ) {
	
							var morphTargets = geometry.morphTargets;
							var morphInfluences = this.morphTargetInfluences;
	
							vA.set( 0, 0, 0 );
							vB.set( 0, 0, 0 );
							vC.set( 0, 0, 0 );
	
							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
								var influence = morphInfluences[ t ];
	
								if ( influence === 0 ) continue;
	
								var targets = morphTargets[ t ].vertices;
	
								vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
								vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
								vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
	
							}
	
							vA.add( fvA );
							vB.add( fvB );
							vC.add( fvC );
	
							fvA = vA;
							fvB = vB;
							fvC = vC;
	
						}
	
						intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
	
						if ( intersection ) {
	
							if ( uvs ) {
	
								var uvs_f = uvs[ f ];
								uvA.copy( uvs_f[ 0 ] );
								uvB.copy( uvs_f[ 1 ] );
								uvC.copy( uvs_f[ 2 ] );
	
								intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
	
							}
	
							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );
	
						}
	
					}
	
				}
	
			};
	
		}() ),
	
		clone: function () {
	
			return new this.constructor( this.geometry, this.material ).copy( this );
	
		}
	
	} );
	
	// File:src/objects/Bone.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Bone = function ( skin ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Bone';
	
		this.skin = skin;
	
	};
	
	THREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.Bone,
	
		copy: function ( source ) {
	
			THREE.Object3D.prototype.copy.call( this, source );
	
			this.skin = source.skin;
	
			return this;
	
		}
	
	} );
	
	// File:src/objects/Skeleton.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {
	
		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
		this.identityMatrix = new THREE.Matrix4();
	
		// copy the bone array
	
		bones = bones || [];
	
		this.bones = bones.slice( 0 );
	
		// create a bone texture or an array of floats
	
		if ( this.useVertexTexture ) {
	
			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	
	
			var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
			size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
			size = Math.max( size, 4 );
	
			this.boneTextureWidth = size;
			this.boneTextureHeight = size;
	
			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
	
		} else {
	
			this.boneMatrices = new Float32Array( 16 * this.bones.length );
	
		}
	
		// use the supplied bone inverses or calculate the inverses
	
		if ( boneInverses === undefined ) {
	
			this.calculateInverses();
	
		} else {
	
			if ( this.bones.length === boneInverses.length ) {
	
				this.boneInverses = boneInverses.slice( 0 );
	
			} else {
	
				console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );
	
				this.boneInverses = [];
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					this.boneInverses.push( new THREE.Matrix4() );
	
				}
	
			}
	
		}
	
	};
	
	Object.assign( THREE.Skeleton.prototype, {
	
		calculateInverses: function () {
	
			this.boneInverses = [];
	
			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
				var inverse = new THREE.Matrix4();
	
				if ( this.bones[ b ] ) {
	
					inverse.getInverse( this.bones[ b ].matrixWorld );
	
				}
	
				this.boneInverses.push( inverse );
	
			}
	
		},
	
		pose: function () {
	
			var bone;
	
			// recover the bind-time world matrices
	
			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
				bone = this.bones[ b ];
	
				if ( bone ) {
	
					bone.matrixWorld.getInverse( this.boneInverses[ b ] );
	
				}
	
			}
	
			// compute the local matrices, positions, rotations and scales
	
			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
				bone = this.bones[ b ];
	
				if ( bone ) {
	
					if ( bone.parent instanceof THREE.Bone ) {
	
						bone.matrix.getInverse( bone.parent.matrixWorld );
						bone.matrix.multiply( bone.matrixWorld );
	
					} else {
	
						bone.matrix.copy( bone.matrixWorld );
	
					}
	
					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
				}
	
			}
	
		},
	
		update: ( function () {
	
			var offsetMatrix = new THREE.Matrix4();
	
			return function update() {
	
				// flatten bone matrices to array
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					// compute the offset between the current and the original transform
	
					var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;
	
					offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
					offsetMatrix.toArray( this.boneMatrices, b * 16 );
	
				}
	
				if ( this.useVertexTexture ) {
	
					this.boneTexture.needsUpdate = true;
	
				}
	
			};
	
		} )(),
	
		clone: function () {
	
			return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );
	
		}
	
	} );
	
	// File:src/objects/SkinnedMesh.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.type = 'SkinnedMesh';
	
		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();
	
		// init bones
	
		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.
	
		var bones = [];
	
		if ( this.geometry && this.geometry.bones !== undefined ) {
	
			var bone, gbone;
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				bone = new THREE.Bone( this );
				bones.push( bone );
	
				bone.name = gbone.name;
				bone.position.fromArray( gbone.pos );
				bone.quaternion.fromArray( gbone.rotq );
				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
	
			}
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				if ( gbone.parent !== - 1 && gbone.parent !== null &&
						bones[ gbone.parent ] !== undefined ) {
	
					bones[ gbone.parent ].add( bones[ b ] );
	
				} else {
	
					this.add( bones[ b ] );
	
				}
	
			}
	
		}
	
		this.normalizeSkinWeights();
	
		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );
	
	};
	
	
	THREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {
	
		constructor: THREE.SkinnedMesh,
	
		bind: function( skeleton, bindMatrix ) {
	
			this.skeleton = skeleton;
	
			if ( bindMatrix === undefined ) {
	
				this.updateMatrixWorld( true );
	
				this.skeleton.calculateInverses();
	
				bindMatrix = this.matrixWorld;
	
			}
	
			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.getInverse( bindMatrix );
	
		},
	
		pose: function () {
	
			this.skeleton.pose();
	
		},
	
		normalizeSkinWeights: function () {
	
			if ( this.geometry instanceof THREE.Geometry ) {
	
				for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {
	
					var sw = this.geometry.skinWeights[ i ];
	
					var scale = 1.0 / sw.lengthManhattan();
	
					if ( scale !== Infinity ) {
	
						sw.multiplyScalar( scale );
	
					} else {
	
						sw.set( 1, 0, 0, 0 ); // do something reasonable
	
					}
	
				}
	
			} else if ( this.geometry instanceof THREE.BufferGeometry ) {
	
				var vec = new THREE.Vector4();
	
				var skinWeight = this.geometry.attributes.skinWeight;
	
				for ( var i = 0; i < skinWeight.count; i ++ ) {
	
					vec.x = skinWeight.getX( i );
					vec.y = skinWeight.getY( i );
					vec.z = skinWeight.getZ( i );
					vec.w = skinWeight.getW( i );
	
					var scale = 1.0 / vec.lengthManhattan();
	
					if ( scale !== Infinity ) {
	
						vec.multiplyScalar( scale );
	
					} else {
	
						vec.set( 1, 0, 0, 0 ); // do something reasonable
	
					}
	
					skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );
	
				}
	
			}
	
		},
	
		updateMatrixWorld: function( force ) {
	
			THREE.Mesh.prototype.updateMatrixWorld.call( this, true );
	
			if ( this.bindMode === "attached" ) {
	
				this.bindMatrixInverse.getInverse( this.matrixWorld );
	
			} else if ( this.bindMode === "detached" ) {
	
				this.bindMatrixInverse.getInverse( this.bindMatrix );
	
			} else {
	
				console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );
	
			}
	
		},
	
		clone: function() {
	
			return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );
	
		}
	
	} );
	
	// File:src/objects/LOD.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LOD = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'LOD';
	
		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );
	
	};
	
	
	THREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.LOD,
	
		copy: function ( source ) {
	
			THREE.Object3D.prototype.copy.call( this, source, false );
	
			var levels = source.levels;
	
			for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
				var level = levels[ i ];
	
				this.addLevel( level.object.clone(), level.distance );
	
			}
	
			return this;
	
		},
	
		addLevel: function ( object, distance ) {
	
			if ( distance === undefined ) distance = 0;
	
			distance = Math.abs( distance );
	
			var levels = this.levels;
	
			for ( var l = 0; l < levels.length; l ++ ) {
	
				if ( distance < levels[ l ].distance ) {
	
					break;
	
				}
	
			}
	
			levels.splice( l, 0, { distance: distance, object: object } );
	
			this.add( object );
	
		},
	
		getObjectForDistance: function ( distance ) {
	
			var levels = this.levels;
	
			for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
				if ( distance < levels[ i ].distance ) {
	
					break;
	
				}
	
			}
	
			return levels[ i - 1 ].object;
	
		},
	
		raycast: ( function () {
	
			var matrixPosition = new THREE.Vector3();
	
			return function raycast( raycaster, intersects ) {
	
				matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
				var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
				this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
			};
	
		}() ),
	
		update: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
	
			return function update( camera ) {
	
				var levels = this.levels;
	
				if ( levels.length > 1 ) {
	
					v1.setFromMatrixPosition( camera.matrixWorld );
					v2.setFromMatrixPosition( this.matrixWorld );
	
					var distance = v1.distanceTo( v2 );
	
					levels[ 0 ].object.visible = true;
	
					for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
						if ( distance >= levels[ i ].distance ) {
	
							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;
	
						} else {
	
							break;
	
						}
	
					}
	
					for ( ; i < l; i ++ ) {
	
						levels[ i ].object.visible = false;
	
					}
	
				}
	
			};
	
		}(),
	
		toJSON: function ( meta ) {
	
			var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
			data.object.levels = [];
	
			var levels = this.levels;
	
			for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
				var level = levels[ i ];
	
				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );
	
			}
	
			return data;
	
		}
	
	} );
	
	// File:src/objects/Sprite.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Sprite = function ( material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Sprite';
	
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();
	
	};
	
	THREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.Sprite,
	
		raycast: ( function () {
	
			var matrixPosition = new THREE.Vector3();
	
			return function raycast( raycaster, intersects ) {
	
				matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
				var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
				var guessSizeSq = this.scale.x * this.scale.y / 4;
	
				if ( distanceSq > guessSizeSq ) {
	
					return;
	
				}
	
				intersects.push( {
	
					distance: Math.sqrt( distanceSq ),
					point: this.position,
					face: null,
					object: this
	
				} );
	
			};
	
		}() ),
	
		clone: function () {
	
			return new this.constructor( this.material ).copy( this );
	
		}
	
	} );
	
	// File:src/objects/LensFlare.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlare = function ( texture, size, distance, blending, color ) {
	
		THREE.Object3D.call( this );
	
		this.lensFlares = [];
	
		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;
	
		if ( texture !== undefined ) {
	
			this.add( texture, size, distance, blending, color );
	
		}
	
	};
	
	THREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.LensFlare,
	
		copy: function ( source ) {
	
			THREE.Object3D.prototype.copy.call( this, source );
	
			this.positionScreen.copy( source.positionScreen );
			this.customUpdateCallback = source.customUpdateCallback;
	
			for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {
	
				this.lensFlares.push( source.lensFlares[ i ] );
	
			}
	
			return this;
	
		},
	
		add: function ( texture, size, distance, blending, color, opacity ) {
	
			if ( size === undefined ) size = - 1;
			if ( distance === undefined ) distance = 0;
			if ( opacity === undefined ) opacity = 1;
			if ( color === undefined ) color = new THREE.Color( 0xffffff );
			if ( blending === undefined ) blending = THREE.NormalBlending;
	
			distance = Math.min( distance, Math.max( 0, distance ) );
	
			this.lensFlares.push( {
				texture: texture,	// THREE.Texture
				size: size, 		// size in pixels (-1 = use texture.width)
				distance: distance, 	// distance (0-1) from light source (0=at light source)
				x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
				scale: 1, 		// scale
				rotation: 0, 		// rotation
				opacity: opacity,	// opacity
				color: color,		// color
				blending: blending	// blending
			} );
	
		},
	
		/*
		 * Update lens flares update positions on all flares based on the screen position
		 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
		 */
	
		updateLensFlares: function () {
	
			var f, fl = this.lensFlares.length;
			var flare;
			var vecX = - this.positionScreen.x * 2;
			var vecY = - this.positionScreen.y * 2;
	
			for ( f = 0; f < fl; f ++ ) {
	
				flare = this.lensFlares[ f ];
	
				flare.x = this.positionScreen.x + vecX * flare.distance;
				flare.y = this.positionScreen.y + vecY * flare.distance;
	
				flare.wantedRotation = flare.x * Math.PI * 0.25;
				flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
			}
	
		}
	
	} );
	
	// File:src/scenes/Scene.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Scene = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Scene';
	
		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;
	
		this.autoUpdate = true; // checked by the renderer
	
	};
	
	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;
	
	THREE.Scene.prototype.copy = function ( source, recursive ) {
	
		THREE.Object3D.prototype.copy.call( this, source, recursive );
	
		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();
		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
	
		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;
	
		return this;
	
	};
	
	// File:src/scenes/Fog.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Fog = function ( color, near, far ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
	
		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;
	
	};
	
	THREE.Fog.prototype.clone = function () {
	
		return new THREE.Fog( this.color.getHex(), this.near, this.far );
	
	};
	
	// File:src/scenes/FogExp2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.FogExp2 = function ( color, density ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;
	
	};
	
	THREE.FogExp2.prototype.clone = function () {
	
		return new THREE.FogExp2( this.color.getHex(), this.density );
	
	};
	
	// File:src/renderers/shaders/ShaderChunk.js
	
	THREE.ShaderChunk = {};
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_fragment' ] ="#ifdef USE_ALPHAMAP\n\n#if defined( TEXTURE_SLOTS )\n\tvec2 alphaUv = alphaMapUV();\n#else\n\tvec2 alphaUv = vUv;\n#endif\n\n\tdiffuseColor.a *= alphaMapTexelTransform( texture2D( alphaMap, alphaUv ) ).g;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_pars_fragment' ] ="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_ALPHAMAP\n\n\t\tuniform sampler2D alphaMap;\n\n\t#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl
	
	THREE.ShaderChunk[ 'alphatest_fragment' ] ="#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl
	
	THREE.ShaderChunk[ 'aomap_fragment' ] ="#ifdef USE_AOMAP\n\n#if defined( TEXTURE_SLOTS )\n\tvec2 aoUv = aoMapUV();\n#else\n\tvec2 aoUv = vUv2;\n#endif\n\n\tfloat ambientOcclusion = ( aoMapTexelTransform( texture2D( aoMap, aoUv ) ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'aomap_pars_fragment' ] ="#ifdef USE_AOMAP\n\n#if ! defined( TEXTURE_SLOTS )\n\tuniform sampler2D aoMap;\n#endif\n\n\tuniform float aoMapIntensity;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl
	
	THREE.ShaderChunk[ 'begin_vertex' ] ="\nvec3 transformed = vec3( position );\n";
	
	// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'beginnormal_vertex' ] ="\nvec3 objectNormal = vec3( normal );\n";
	
	// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl
	
	THREE.ShaderChunk[ 'bsdfs' ] ="bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n\n}\n\n/*float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t\tif( decayExponent > 0.0 ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t\t// page 32, equation 26: E[window1]\n\t\t\t// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\n\t\t\t// this is intended to be used on spot and point lights who are represented as luminous intensity\n\t\t\t// but who must be converted to luminous irradiance for surface lighting calculation\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n\n#else\n\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n#endif\n\n\t\t}\n\n\t\treturn 1.0;\n}*/\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\tif ( decayExponent > 0.0 && cutoffDistance > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\telse if ( decayExponent < 0.0 ) {\n\t\t// this is based upon UE4 light fall as described on page 11 of:\n\t\t//  https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\t\tfloat maxDistanceCutoffFactor = 1.0;\n\t\tif( cutoffDistance > 0.0 ) {\n\t\t\tmaxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\tfloat distanceFalloff = 1.0 / ( pow2( lightDistance ) + 1.0 );\n\n\t\treturn maxDistanceCutoffFactor * distanceFalloff;\n\t}\n\telse {\n\t\treturn 1.0;\n\t}\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\n\nfloat F_Schlick( const in float specular, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t//;float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specular ) * fresnel + specular;\n\n} // validated\n\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t//;float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\t// geometry term = G(l)G(v) / 4(nl)(nv)\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n\treturn 1.0 / ( gl * gv );\n\n} // validated\n\n// from page 12, listing 2 of http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n \n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = clamp( dot( geometry.normal, incidentLight.direction ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\n\tfloat dotNV = clamp( dot( geometry.normal, geometry.viewDir ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\n\tfloat dotNH = clamp( dot( geometry.normal, halfDir ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\nfloat BRDF_ClearCoat_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in float specular, const in float roughness, out float layerAttenuation ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = clamp( dot( geometry.normal, incidentLight.direction ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\n\tfloat dotNV = clamp( dot( geometry.normal, geometry.viewDir ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\n\tfloat dotNH = clamp( dot( geometry.normal, halfDir ), EPSILON, 1.0 ); // avoid artifacts from divides by zero\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tfloat F = F_Schlick( specular, dotLH );\n\n\tlayerAttenuation = F;\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n}\n\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n\treturn specularColor * AB.x + AB.y;\n\n} // validated\n\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nfloat BRDF_ClearCoat_GGX_Environment( const in GeometricContext geometry, const in float specular, const in float roughness, out float layerAttention ) {\n\n\tvec3 incidentLightDirection = reflect( geometry.viewDir, geometry.normal );\n\tvec3 halfDir = normalize( incidentLightDirection + geometry.viewDir );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotLH = saturate( dot( incidentLightDirection, halfDir ) );\n\n\tlayerAttention = F_Schlick( specular, dotLH );\n\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n\treturn specular * AB.x + AB.y;\n\n} // validated\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'bumpmap_pars_fragment' ] ="#ifdef USE_BUMPMAP\n\n#if ! defined( TEXTURE_SLOTS )\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n#endif\n\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n#if defined( TEXTURE_SLOTS )\n\t\tvec2 bumpUv = bumpMapUV();\n#else\n\t\tvec2 bumpUv = vUv;\n#endif\n\n\t\tvec2 dSTdx = dFdx( bumpUv );\n\t\tvec2 dSTdy = dFdy( bumpUv );\n\n\t\tfloat Hll = bumpMapTexelTransform( texture2D( bumpMap, bumpUv ) ).x;\n\t\tfloat dBx = bumpMapTexelTransform( texture2D( bumpMap, bumpUv + dSTdx ) ).x - Hll;\n\t\tfloat dBy = bumpMapTexelTransform( texture2D( bumpMap, bumpUv + dSTdy ) ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl
	
	THREE.ShaderChunk[ 'clipping_planes_fragment' ] ="#if NUM_CLIPPING_PLANES > 0\n\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] ="#if NUM_CLIPPING_PLANES > 0\n\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] ="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl
	
	THREE.ShaderChunk[ 'clipping_planes_vertex' ] ="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl
	
	THREE.ShaderChunk[ 'color_fragment' ] ="#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'color_pars_fragment' ] ="#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'color_pars_vertex' ] ="#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl
	
	THREE.ShaderChunk[ 'color_vertex' ] ="#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/common.glsl
	
	THREE.ShaderChunk[ 'common' ] ="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 0.00001 // required for mediump\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\n\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat gaussianPdf(in float x, in float sigma) {\n\n\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl
	
	THREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] ="#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction); \n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\t// Clamp the value to the max mip level counts. hard coded to 6 mips\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\t// float powScale = exp2(roughnessLevel + mipLevel);\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\t// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\t// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\n\tfloat rcpPowScale = 1.0 / powScale;\n\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\n\t// round to nearest mipmap if we are not interpolating.\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\n\t// Tri linear interpolation.\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n\tvec4 result = mix(color10, color20, t);\n\n\treturn vec4(result.rgb, 1.0);\n}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'defaultnormal_vertex' ] ="#ifdef FLIP_SIDED\n\n\tobjectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
	
	// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl
	
	THREE.ShaderChunk[ 'displacementmap_vertex' ] ="#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'displacementmap_pars_vertex' ] ="#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl
	
	THREE.ShaderChunk[ 'emissivemap_fragment' ] ="#ifdef USE_EMISSIVEMAP\n\n#if defined( TEXTURE_SLOTS )\n\tvec2 emissiveUv = emissiveMapUV();\n#else\n\tvec2 emissiveUv = vUv;\n#endif\n\n\tvec4 emissiveColor = texture2D( emissiveMap, emissiveUv );\n\n\temissiveColor.rgb = emissiveMapTexelTransform( emissiveMapTexelToLinear( emissiveColor ) ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'emissivemap_pars_fragment' ] ="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_EMISSIVEMAP\n\n\t\tuniform sampler2D emissiveMap;\n\n\t#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'encodings_pars_fragment' ] ="// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl
	
	THREE.ShaderChunk[ 'encodings_fragment' ] ="  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_fragment' ] ="#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n\t#endif\n\n\tenvColor = envMapTexelToLinear( envColor );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_fragment' ] ="#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n\n#ifdef USE_ENVMAP\n\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_vertex' ] ="#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_vertex' ] ="#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/falloffalphamap_fragment.glsl
	
	THREE.ShaderChunk[ 'falloffalphamap_fragment' ] ="#ifdef USE_FALLOFFALPHAMAP\n\n#if defined( TEXTURE_SLOTS )\n\tvec2 falloffAlphaUv = falloffAlphaMapUV();\n#else\n\tvec2 falloffAlphaUv = vUv;\n#endif\n\n\tfalloffDiffuseColor.a *= falloffAlphaMapTexelTransform( texture2D( falloffAlphaMap, falloffAlphaUv ) ).g;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/falloffmap_fragment.glsl
	
	THREE.ShaderChunk[ 'falloffmap_fragment' ] ="#ifdef USE_FALLOFFMAP\n\n#if defined( TEXTURE_SLOTS )\n\tvec2 falloffMapUv = falloffMapUV();\n#else\n\tvec2 falloffMapUv = vUv;\n#endif\n\n\tvec4 falloffTexelColor = texture2D( falloffMap, falloffMapUv );\n\n\tfalloffTexelColor = falloffMapTexelTransform( falloffMapTexelToLinear( falloffTexelColor ) );\n\tfalloffDiffuseColor *= falloffTexelColor;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/falloff_fragment.glsl
	
	THREE.ShaderChunk[ 'falloff_fragment' ] ="#ifdef FALLOFF\n\nfloat falloffModulator = abs( dot( normal, normalize( vViewPosition ) ) );\n\n// smoothstep: this is a hack, it needs to be fixed.\nfalloffModulator = ( falloffModulator * falloffModulator * ( 3.0 - 2.0 * falloffModulator ) );\n\ndiffuseColor = mix( falloffDiffuseColor, diffuseColor, falloffModulator );\n\n#endif // FALLOFF";
	
	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_fragment' ] ="#ifdef USE_FOG\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t#else\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t#endif\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_pars_fragment' ] ="#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_fragment' ] ="#ifdef USE_LIGHTMAP\n\n#if defined( TEXTURE_SLOTS )\n\tvec2 lightUv = lightMapUV();\n#else\n\tvec2 lightUv = vUv2;\n#endif\n\n\treflectedLight.indirectDiffuse += PI * emissiveMapTexelTransform( texture2D( lightMap, lightUv ) ).xyz; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_pars_fragment' ] ="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_LIGHTMAP\n\n\t\tuniform sampler2D lightMap;\n\t\tuniform float lightMapIntensity;\n\n\t#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_lambert_vertex' ] ="vec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if NUM_POINT_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\n#endif\n\n#if NUM_DIR_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t#endif\n\n\t}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl
	
	THREE.ShaderChunk[ 'lights_pars' ] ="uniform vec3 ambientLightColor;\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI;\n\n\t#endif\n\n\treturn irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat spreadAngle;\n\t\tvec2 shadowMapSize;\n\t\tvec3 shadowCameraParams;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.direction = lVector / lightDistance;\n\n\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tvec3 shadowCameraParams;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.direction = lVector / lightDistance;\n\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tirradiance *= PI;\n\n\t\t#endif\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n\n\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n\t\t#include <normal_flip>\n\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#else\n\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\n\t\t#else\n\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t\t#endif\n\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t}\n\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\t// clamp to allowable LOD ranges.\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n\t\t#endif\n\n\t\t#include <normal_flip>\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent) );\n\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_fragment' ] ="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_pars_fragment' ] ="varying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_physical_fragment' ] ="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_physical_pars_fragment' ] ="struct PhysicalMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\tvec3 specularRadiance = irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\tvec3 diffuseRadiance = irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#ifndef STANDARD\n\n\t\tfloat layerAttention;\n\t\tvec3 clearCoatSpecularRadiance = irradiance * BRDF_ClearCoat_GGX( directLight, geometry, material.clearCoat, material.clearCoatRoughness, layerAttention );\n\n\t\tspecularRadiance = mix( specularRadiance, clearCoatSpecularRadiance, material.clearCoat );\n\t\tdiffuseRadiance = mix( diffuseRadiance, vec3( 0.0 ), material.clearCoat );\n\n\t#endif\n\n\treflectedLight.directSpecular += specularRadiance;\n\treflectedLight.directDiffuse += diffuseRadiance;\n\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tvec3 diffuseRadiance = irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#ifndef STANDARD\n\n\t\tdiffuseRadiance = mix( diffuseRadiance, vec3( 0.0 ), material.clearCoat );\n\n\t#endif\n\n\treflectedLight.indirectDiffuse += diffuseRadiance;\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tvec3 specularRadiance = radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n\t#ifndef STANDARD\n\n\t\tfloat layerAttention;\n\t\tvec3 clearCoatSpecularRadiance = clearCoatRadiance * BRDF_ClearCoat_GGX_Environment( geometry, material.clearCoat, material.clearCoatRoughness, layerAttention );\n\n\t\tspecularRadiance = mix( specularRadiance, clearCoatSpecularRadiance, material.clearCoat );\n\n\t#endif\n\n\treflectedLight.indirectSpecular += specularRadiance;\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_template.glsl
	
	THREE.ShaderChunk[ 'lights_template' ] ="//\n// This is a template that can be used to light a material, it uses pluggable RenderEquations (RE)\n//   for specific lighting scenarios.\n//\n// Instructions for use:\n//  - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n//  - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n//  - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n//\n// TODO:\n//  - Add area light support.\n//  - Add sphere light support.\n//  - Add diffuse light probe (irradiance cubemap) support.\n//\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\nIncidentLight directLight;\n\n#ifdef USE_SHADOWMAP\n\tinitShadows();\n#endif\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, 0.0, spotLight.shadowCameraParams, vSpotShadowCoord[ i ], 1 ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, 0.0, directionalLight.spreadAngle, directionalLight.shadowCameraParams, vDirectionalShadowCoord[ i ], 0 ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#ifdef USE_LIGHTMAP\n\n\t\t#if defined( TEXTURE_SLOTS )\n\t\t\tvec2 lightUv = lightMapUV();\n\t\t\tvec3 lightMapIrradiance = lightMapTexelTransform( texture2D( lightMap, vUv2 ) ).xyz;\n\t\t#else\n\t\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#endif\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t// TODO, replace 8 with the real maxMIPLevel\n\t \tirradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, 8 );\n\n\t#endif\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\t// TODO, replace 8 with the real maxMIPLevel\n\tvec3 radiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), 8 );\n\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_fragment' ] ="#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] ="#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] ="#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n\tuniform float logDepthBufFC;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_vertex' ] ="#ifdef USE_LOGDEPTHBUF\n\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n\t#else\n\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl
	
	THREE.ShaderChunk[ 'map_fragment' ] ="#ifdef USE_MAP\n\n#if defined( TEXTURE_SLOTS )\n\tvec2 mapUv = mapUV();\n#else\n\tvec2 mapUv = vUv;\n#endif\n\n\tvec4 texelColor = texture2D( map, mapUv );\n\n\ttexelColor = mapTexelTransform( mapTexelToLinear( texelColor ) );\n\tdiffuseColor *= texelColor;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_pars_fragment' ] ="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_MAP\n\n\t\tuniform sampler2D map;\n\n\t#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_fragment' ] ="#ifdef USE_MAP\n\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_pars_fragment' ] ="#ifdef USE_MAP\n\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl
	
	THREE.ShaderChunk[ 'metalnessmap_fragment' ] ="float metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\t#if defined( TEXTURE_SLOTS )\n\t\tvec2 metalnessUv = metalnessMapUV();\n\t#else\n\t\tvec2 metalnessUv = vUv;\n\t#endif\n\n\tvec4 texelMetalness = metalnessMapTexelTransform( texture2D( metalnessMap, metalnessUv ) );\n\tmetalnessFactor *= texelMetalness.r;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] ="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_METALNESSMAP\n\n\t\tuniform sampler2D metalnessMap;\n\n\t#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'morphnormal_vertex' ] ="#ifdef USE_MORPHNORMALS\n\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] ="#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_vertex' ] ="#ifdef USE_MORPHTARGETS\n\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl
	
	THREE.ShaderChunk[ 'normal_flip' ] ="#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl
	
	THREE.ShaderChunk[ 'normal_fragment' ] ="#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'normalmap_pars_fragment' ] ="#ifdef USE_NORMALMAP\n\n\t#if ! defined( TEXTURE_SLOTS )\n\t\tuniform sampler2D normalMap;\n\t#endif\n\t\tuniform vec2 normalScale;\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\t#if defined( TEXTURE_SLOTS )\n\t\t\tvec2 normalUv = normalMapUV();\n\t\t#else\n\t\t\tvec2 normalUv = vUv;\n\t\t#endif\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( normalUv.st );\n\t\tvec2 st1 = dFdy( normalUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, normalUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/packing.glsl
	
	THREE.ShaderChunk[ 'packing' ] ="vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\n\n/*const highp float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst highp float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst highp vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst highp vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst highp float ShiftRight8 = 1. / 256.;\n*/\n\nvec4 packDepthToRGBA( const in highp float v ) {\n\n  const highp vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const highp vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n  highp vec4 res = mod( v * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 ); // vec4 res = fract( depth * bit_shift );\",\n  res -= res.xxyz * bit_mask;\n  return res;\n  \n/* \tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;*/\n  \n\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\n  const highp vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\treturn dot( v, bit_shift );\n\n  //return dot( v, UnpackFactors );\n\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl
	
	THREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] ="#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl
	
	THREE.ShaderChunk[ 'project_vertex' ] ="#ifdef USE_SKINNING\n\n\tvec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
	
	// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl
	
	THREE.ShaderChunk[ 'roughnessmap_fragment' ] ="float roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\t#if defined( TEXTURE_SLOTS )\n\t\tvec2 roughnessUv = roughnessMapUV();\n\t#else\n\t\tvec2 roughnessUv = vUv;\n\t#endif\n\n\tvec4 texelRoughness = roughnessMapTexelTransform( texture2D( roughnessMap, roughnessUv ) );\n\troughnessFactor *= texelRoughness.r;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] ="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_ROUGHNESSMAP\n\n\t\tuniform sampler2D roughnessMap;\n\n\t#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_fragment' ] ="#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\t/* PCSS implementation inspired from http://developer.download.nvidia.com/whitepapers/2008/PCSS_Integration.pdf\n\t   Spot light and directional lights are treated differently. For directional light, there is no clear Physical\n     meaning of shadow radius. Instead, a more intuitive parameter \"spreadAngle\" is used for directional lights,\n\t\t to calculate the searchRadius to find blocker depth, and to find the filter radius for PCF.\n\t*/\n\n\t#if defined( SHADOWMAP_TYPE_PCSS )\n\t\t#define PCSS_QUALITY_LEVEL 5\n\t\t#define PCSS_NUM_POISSON_SAMPLES 16\n\t\t#define PCSS_ROTATE_POISSON_SAMPLES 1\n\n\t\tvec2 poissonDisk[PCSS_NUM_POISSON_SAMPLES];\n\n\t\tvoid initPercentCloserSoftShadow( const in vec2 randomSeed )\t{\n\n\t\t\tpoissonDisk[0] = vec2(-0.94201624, -0.39906216 );\n\t\t\tpoissonDisk[1] = vec2( 0.94558609, -0.76890725 );\n\t\t\tpoissonDisk[2] = vec2( -0.094184101, -0.92938870 );\n\t\t\tpoissonDisk[3] = vec2( 0.34495938, 0.29387760 );\n\t\t\tpoissonDisk[4] = vec2( -0.91588581, 0.45771432 );\n\t\t\tpoissonDisk[5] = vec2( -0.81544232, -0.87912464 );\n\t\t\tpoissonDisk[6] = vec2( -0.38277543, 0.27676845 );\n\t\t\tpoissonDisk[7] = vec2( 0.97484398, 0.75648379 );\n\t\t\tpoissonDisk[8] = vec2( 0.44323325, -0.97511554 );\n\t\t\tpoissonDisk[9] = vec2( 0.53742981, -0.47373420 );\n\t\t\tpoissonDisk[10] = vec2( -0.26496911, -0.41893023 );\n\t\t\tpoissonDisk[11] = vec2( 0.79197514, 0.19090188 );\n\t\t\tpoissonDisk[12] = vec2( -0.24188840, 0.99706507 );\n\t\t\tpoissonDisk[13] = vec2( -0.81409955, 0.91437590 );\n\t\t\tpoissonDisk[14] = vec2( 0.19984126, 0.78641367 );\n\t\t\tpoissonDisk[15] = vec2( 0.14383161, -0.14100790 );\n\t\t}\n\n\t\tmat2 createRotationMatrix( const in vec2 randomSeed ) {\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\n\t\t\tfloat c = cos( angle ), s = sin( angle );\n\t\t\treturn mat2( c, s, -s, c );\n\t\t}\n\n\t\tfloat penumbraSize( const in float zReceiverLightSpace, const in float zBlockerLightSpace ) { // Parallel plane estimation\n\t\t\treturn (zReceiverLightSpace - zBlockerLightSpace) / zBlockerLightSpace;\n\t\t}\n\n\t\tfloat findBlockerLightZ( sampler2D shadowMap, const in vec2 uv, const in float zReceiverClipSpace, const in float zReceiverLightSpace, const in float shadowRadius, const in float spreadAngle, const in vec3 shadowCameraParams, const in vec2 randomSeed, const int lightType ) {\n\t\t\t// This uses similar triangles to compute what\n\t\t\t// area of the shadow map we should search\n\t\t\tfloat lightFrustrumWidth = 2.0 * shadowCameraParams.y * tan(shadowCameraParams.x * 0.5);\n\t\t\tfloat searchRadius = 0.0;\n\t\t\tsearchRadius = ( lightType == 0) ? zReceiverLightSpace * spreadAngle/shadowCameraParams.x : ( shadowRadius / lightFrustrumWidth ) * ( zReceiverLightSpace - shadowCameraParams.y ) / zReceiverLightSpace;\n\t\t\tfloat blockerLightZSum = 0.0;\n\t\t\tint numBlockers = 0;\n\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\tfor( int i = 0; i < PCSS_NUM_POISSON_SAMPLES; i++ ) {\n\t\t\t#if PCSS_ROTATE_POISSON_SAMPLES == 1\n\t\t\t\tvec2 poissonSample = vec2(poissonDisk[i].y * c + poissonDisk[i].x * s, poissonDisk[i].y * -s + poissonDisk[i].x * c);\n\t\t\t#else\n\t\t\t\tvec2 poissonSample = poissonDisk[i];\n\t\t\t#endif\n\t\t\t\tfloat shadowMapDepth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonSample * searchRadius ) );\n\t\t\t\tif ( shadowMapDepth < zReceiverClipSpace ) {\n\t\t\t\t\tblockerLightZSum += shadowMapDepth;\n\t\t\t\t\tnumBlockers ++;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif( numBlockers == 0 ) return -1.0;\n\n\t\t\treturn blockerLightZSum / float( numBlockers );\n\t\t}\n\n\t\tfloat percentCloserFilter( sampler2D shadowMap, vec2 uv, float receiverClipZ, float filterRadius, const in vec2 randomSeed ) {\n\t\t\tint numBlockers = 0;\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\n\t\t\tfor( int i = 0; i < PCSS_NUM_POISSON_SAMPLES; i ++ ) {\n\t\t\t#if PCSS_ROTATE_POISSON_SAMPLES == 1\n\t\t\t\tvec2 poissonSample = vec2(poissonDisk[i].y * c + poissonDisk[i].x * s, poissonDisk[i].y * -s + poissonDisk[i].x * c);\n\t\t\t#else\n\t\t\t\tvec2 poissonSample = poissonDisk[i];\n\t\t\t#endif\n\t\t\t\tvec2 uvOffset = poissonSample * filterRadius;\n\n\t\t\t\tfloat blockerClipZ = unpackRGBAToDepth( texture2D( shadowMap, uv + uvOffset ) );\n\t\t\t\tif( receiverClipZ <= blockerClipZ ) numBlockers ++;\n\n\t\t\t\tblockerClipZ = unpackRGBAToDepth( texture2D( shadowMap, uv - uvOffset ) );\n\t\t\t\tif( receiverClipZ <= blockerClipZ ) numBlockers ++;\n\n\t\t\t}\n\n\t\t\treturn float( numBlockers ) / ( 2.0 * float( PCSS_NUM_POISSON_SAMPLES ) );\n\t\t}\n\n\t\tfloat percentCloserSoftShadow( sampler2D shadowMap, const in float shadowRadius, const in float spreadAngle, const in vec3 shadowCameraParams, const in vec4 coords, const int lightType ) {\n\n\t\t\tvec2 uv = coords.xy;\n\t\t\tfloat receiverLightZ = coords.z;\n\t\t\tfloat cameraNear = shadowCameraParams.y, cameraFar = shadowCameraParams.z;\n\t\t\tfloat zReceiverLightSpace;\n\t\t\tif(lightType == 0)\n\t\t\t\tzReceiverLightSpace = -orthographicDepthToViewZ( receiverLightZ, cameraNear, cameraFar );\n\t\t\telse\n\t\t\t\tzReceiverLightSpace = -perspectiveDepthToViewZ( receiverLightZ, cameraNear, cameraFar );\n\n\t\t\t// STEP 1: blocker search\n\t\t\tfloat blockerLightZ = findBlockerLightZ( shadowMap, uv, receiverLightZ, zReceiverLightSpace, shadowRadius, spreadAngle, shadowCameraParams, uv, lightType );\n\t\t\n\t\t\t//There are no occluders so early out (this saves filtering)\n\t\t\tif( blockerLightZ == -1.0 ) return 1.0;\n\n\t\t\tfloat avgBlockerDepthLightSpace;\n\t\t\tfloat filterRadius = 0.0;\n\n\t\t\t// STEP 2: penumbra size\n\t\t\tif(lightType == 0) {\n\t\t\t\tavgBlockerDepthLightSpace = -orthographicDepthToViewZ( blockerLightZ, cameraNear, cameraFar );\n\t\t\t\tfilterRadius = (zReceiverLightSpace - avgBlockerDepthLightSpace) * spreadAngle/shadowCameraParams.x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tavgBlockerDepthLightSpace = -perspectiveDepthToViewZ( blockerLightZ, cameraNear, cameraFar );\n\t\t\t\tfloat penumbraRatio = penumbraSize( zReceiverLightSpace, avgBlockerDepthLightSpace );\n\t\t\t\tfloat lightFrustrumWidth = 2.0 * cameraNear * tan(shadowCameraParams.x * 0.5);\n\t\t\t\tfilterRadius = penumbraRatio * ( shadowRadius/lightFrustrumWidth ) * cameraNear / zReceiverLightSpace;\n\t\t\t}\n\t\t\t// STEP 3: filtering\n\t\t\treturn percentCloserFilter( shadowMap, uv, receiverLightZ, filterRadius, uv );\n\t\t}\n\n\t#endif\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n\t\tvec2 f = fract( uv * size + 0.5 );\n\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\n\t\treturn c;\n\n\t}\n\n\tvoid initShadows() {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCSS )\n\n\t\t  initPercentCloserSoftShadow( vViewPosition.xy );\n\n\t\t#endif\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, float spreadAngle, vec3 shadowCameraParams, vec4 shadowCoord, const int lightType ) {\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCSS )\n\n\t\t  return percentCloserSoftShadow( shadowMap, shadowRadius, spreadAngle, shadowCameraParams, shadowCoord, lightType );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn 1.0;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the distance from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t// dp = distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_vertex' ] ="#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_vertex' ] ="#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmask_pars_fragment' ] ="float getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\tDirectionalLight directionalLight;\n\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\tSpotLight spotLight;\n\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\tPointLight pointLight;\n\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#endif\n\n\treturn shadow;\n\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl
	
	THREE.ShaderChunk[ 'skinbase_vertex' ] ="#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_pars_vertex' ] ="#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_vertex' ] ="#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'skinnormal_vertex' ] ="#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_fragment' ] ="float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\t#if defined( TEXTURE_SLOTS )\n\t\tvec2 specularUv = specularMapUV();\n\t#else\n\t\tvec2 specularUv = vUv;\n\t#endif\n\n\tvec4 texelSpecular = specularMapTexelTransform( texture2D( specularMap, specularUv ) );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_pars_fragment' ] ="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_SPECULARMAP\n\n\t\tuniform sampler2D specularMap;\n\n\t#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/slot_texel_transform_template.glsl
	
	THREE.ShaderChunk[ 'slot_texel_transform_template' ] ="uniform vec2 $SLOT_NAME$TexelTransformParams;\n\nvec4 $SLOT_NAME$TexelTransform( vec4 value ) {\n    value.rgb *= $SLOT_NAME$TexelTransformParams.x;\n    value.rgb += vec3( $SLOT_NAME$TexelTransformParams.y );\n    return value;\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/slot_uv_transform_template.glsl
	
	THREE.ShaderChunk[ 'slot_uv_transform_template' ] ="uniform vec4 $SLOT_NAME$UVTransformParams;\n\nvec2 $SLOT_NAME$UV() {\n  vec2 value = $UV_VAR_NAME$;\n  value.xy *= $SLOT_NAME$UVTransformParams.xy;\n  value.xy += $SLOT_NAME$UVTransformParams.zw;\n  return value;\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl
	
	THREE.ShaderChunk[ 'tonemapping_fragment' ] ="#if defined( TONE_MAPPING )\n\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] ="#define saturate(a) clamp( a, 0.0, 1.0 )\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n  return toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n  // John Hable's filmic operator from Uncharted 2 video game\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'uv2_pars_fragment' ] ="#if ! defined( TEXTURE_SLOTS )\n\t#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\t\tvarying vec2 vUv2;\n\n\t#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'uv2_pars_vertex' ] ="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl
	
	THREE.ShaderChunk[ 'uv2_vertex' ] ="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = uv2;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'uv_pars_fragment' ] ="#if ! defined( TEXTURE_SLOTS )\n\n\t#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_FALLOFFALPHAMAP )\n\n\t\tvarying vec2 vUv;\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'uv_pars_vertex' ] ="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )  || defined( USE_FALLOFFMAP ) || defined( USE_FALLOFFALPHAMAP )\n\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl
	
	THREE.ShaderChunk[ 'uv_vertex' ] ="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_FALLOFFALPHAMAP )\n\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl
	
	THREE.ShaderChunk[ 'worldpos_vertex' ] ="#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n\t#ifdef USE_SKINNING\n\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\n\t#else\n\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/UniformsUtils.js
	
	/**
	 * Uniform Utilities
	 */
	
	THREE.UniformsUtils = {
	
		merge: function ( uniforms ) {
	
			var merged = {};
	
			for ( var u = 0; u < uniforms.length; u ++ ) {
	
				var tmp = this.clone( uniforms[ u ] );
	
				for ( var p in tmp ) {
	
					merged[ p ] = tmp[ p ];
	
				}
	
			}
	
			return merged;
	
		},
	
		cloneDefines: function ( defines_src ) {
	
			var defines_dst = {};
	
			for ( var u in defines_src ) {
	
				defines_dst[ u ] = this.cloneValue( defines_src[ u ] );
	
			}
	
			return defines_dst;
	
		},
	
	
		clone: function ( uniforms_src ) {
	
			var uniforms_dst = {};
	
			for ( var u in uniforms_src ) {
	
				uniforms_dst[ u ] = {};
	
				for ( var p in uniforms_src[ u ] ) {
	
					uniforms_dst[ u ][ p ] = THREE.UniformsUtils.cloneValue( uniforms_src[ u ][ p ] );
	
				}
	
			}
	
			return uniforms_dst;
	
		},
	
		cloneValue: function( parameter_src ) {
	
			if ( parameter_src instanceof THREE.Color ||
				 parameter_src instanceof THREE.Vector2 ||
				 parameter_src instanceof THREE.Vector3 ||
				 parameter_src instanceof THREE.Vector4 ||
				 parameter_src instanceof THREE.Matrix3 ||
				 parameter_src instanceof THREE.Matrix4 ||
				 parameter_src instanceof THREE.Texture ) {
	
				return parameter_src.clone();
	
			} else if ( Array.isArray( parameter_src ) ) {
	
				return parameter_src.slice();
	
			} else {
	
				return parameter_src;
	
			}
		}
	
	};
	
	// File:src/renderers/shaders/UniformsLib.js
	
	/**
	 * Uniforms library for shared webgl shaders
	 */
	
	THREE.UniformsLib = {
	
		common: {
	
			"diffuse": { value: new THREE.Color( 0xeeeeee ) },
			"opacity": { value: 1.0 },
	
			"map": { value: null },
			"mapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"mapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) },
			"offsetRepeat": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
	
			"specularMap": { value: null },
			"specularMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"specularMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) },
	
			"alphaMap": { value: null },
			"alphaMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"alphaMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) },
	
			"envMap": { value: null },
			"flipEnvMap": { value: - 1 },
			"reflectivity": { value: 1.0 },
			"refractionRatio": { value: 0.98 }
	
		},
	
		aomap: {
	
			"aoMap": { value: null },
			"aoMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"aoMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) },
			"aoMapIntensity": { value: 1 }
	
		},
	
		lightmap: {
	
			"lightMap": { value: null },
			"lightMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"lightMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) },
			"lightMapIntensity": { value: 1 }
	
		},
	
		emissivemap: {
	
			"emissiveMap": { value: null },
			"emissiveMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"emissiveMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) }
	
		},
	
		bumpmap: {
	
			"bumpMap": { value: null },
			"bumpScale": { value: 1 },
			"bumpMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"bumpMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) }
	
		},
	
		normalmap: {
	
			"normalMap": { value: null },
			"normalScale": { value: new THREE.Vector2( 1, 1 ) }, // for backwards compatibility
			"normalMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"normalMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) }
	
		},
	
		displacementmap: {
	
			"displacementMap": { value: null },
			"displacementScale": { value: 1 }, // for backwards compatibility
			"displacementBias": { value: 0 }, // for backwards compatibility
			"displacementMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"displacementMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) }
	
		},
	
	
		falloffmap: {
	
			"falloffMap": { value: null },
			"falloffMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"falloffMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) }
	
		},
	
		falloffalphamap: {
	
			"falloffAlphaMap": { value: null },
			"falloffAlphaMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"falloffAlphaMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) }
	
		},
	
		roughnessmap: {
	
			"roughnessMap": { value: null },
			"roughnessMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"roughnessMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) }
	
		},
	
		metalnessmap: {
	
			"metalnessMap": { value: null },
			"metalnessMapUVTransformParams": { value: new THREE.Vector4( 0, 0, 1, 1 ) },
			"metalnessMapTexelTransformParams": { value: new THREE.Vector2( 1, 0 ) }
	
		},
	
		fog: {
	
			"fogDensity": { value: 0.00025 },
			"fogNear": { value: 1 },
			"fogFar": { value: 2000 },
			"fogColor": { value: new THREE.Color( 0xffffff ) }
	
		},
	
		lights: {
	
			"ambientLightColor": { value: [] },
	
			"directionalLights": { value: [], properties: {
				"direction": {},
				"color": {},
				"shadow": { type: "1i" },
				"shadowBias": { type: "1f" },
				"spreadAngle": { type: "1f" },
				"shadowMapSize": { type: "v2" },
				"shadowCameraParams": { type: "v3" }
			} },
	
			"directionalShadowMap": { type: "tv", value: [] },
			"directionalShadowMatrix": { type: "m4v", value: [] },
	
			"spotLights": { type: "sa", value: [], properties: {
				"color": { type: "c" },
				"position": { type: "v3" },
				"direction": { type: "v3" },
				"distance": { type: "1f" },
				"coneCos": { type: "1f" },
				"penumbraCos": { type: "1f" },
				"decay": { type: "1f" },
	
				"shadow": { type: "1i" },
				"shadowBias": { type: "1f" },
				"shadowRadius": { type: "1f" },
				"shadowMapSize": { type: "v2" },
				"shadowCameraParams": { type: "v3" }
			} },
	
			"spotShadowMap": { value: [] },
			"spotShadowMatrix": { value: [] },
	
			"pointLights": { value: [], properties: {
				"color": {},
				"position": {},
				"decay": {},
				"distance": {},
	
				"shadow": {},
				"shadowBias": {},
				"shadowRadius": {},
				"shadowMapSize": {}
			} },
	
			"pointShadowMap": { value: [] },
			"pointShadowMatrix": { value: [] },
	
			"hemisphereLights": { value: [], properties: {
				"direction": {},
				"skyColor": {},
				"groundColor": {}
			} }
	
		},
	
		points: {
	
			"diffuse": { value: new THREE.Color( 0xeeeeee ) },
			"opacity": { value: 1.0 },
			"size": { value: 1.0 },
			"scale": { value: 1.0 },
			"map": { value: null },
			"offsetRepeat": { value: new THREE.Vector4( 0, 0, 1, 1 ) }
	
		}
	
	};
	
	// File:src/renderers/shaders/ShaderLib/cube_frag.glsl
	
	THREE.ShaderChunk[ 'cube_frag' ] ="uniform float envMapIntensity;\nuniform float tFlip;\nuniform float opacity;\nuniform float roughness;\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 queryReflectVec = vec3( tFlip * vWorldPosition.x, vWorldPosition.yz );\n\n\tvec4 envMapColor = vec4( 0.0 );\n\n\t#if defined( ENVMAP_TYPE_CUBE )\n\n\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\tenvMapColor = textureCubeLodEXT( envMap, queryReflectVec, roughness * 8.0 );\n\n\t\t#else\n\n\t\t\tenvMapColor = textureCube( envMap, queryReflectVec, roughness * 8.0 );\n\n\t\t#endif\n\n\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tenvMapColor = textureCubeUV( queryReflectVec, roughness );\n\n\t#endif\n\n\tgl_FragColor = envMapColor;\n\tgl_FragColor.rgb *= envMapIntensity;\n\tgl_FragColor.a = opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <logdepthbuf_fragment>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/cube_vert.glsl
	
	THREE.ShaderChunk[ 'cube_vert' ] ="varying vec3 vWorldPosition;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/depth_frag.glsl
	
	THREE.ShaderChunk[ 'depth_frag' ] ="precision highp float;\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\n\t#endif\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/depth_vert.glsl
	
	THREE.ShaderChunk[ 'depth_vert' ] ="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl
	
	THREE.ShaderChunk[ 'distanceRGBA_frag' ] ="uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl
	
	THREE.ShaderChunk[ 'distanceRGBA_vert' ] ="varying vec4 vWorldPosition;\n\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition;\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl
	
	THREE.ShaderChunk[ 'equirect_frag' ] ="uniform sampler2D tEquirect;\nuniform float tFlip;\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n\nvoid main() {\n\n\t// \tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl
	
	THREE.ShaderChunk[ 'equirect_vert' ] ="varying vec3 vWorldPosition;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl
	
	THREE.ShaderChunk[ 'linedashed_frag' ] ="uniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl
	
	THREE.ShaderChunk[ 'linedashed_vert' ] ="uniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\n\tvLineDistance = scale * lineDistance;\n\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl
	
	THREE.ShaderChunk[ 'meshbasic_frag' ] ="uniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl
	
	THREE.ShaderChunk[ 'meshbasic_vert' ] ="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_ENVMAP\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl
	
	THREE.ShaderChunk[ 'meshlambert_frag' ] ="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\n\n#ifdef DOUBLE_SIDED\n\n\tvarying vec3 vLightBack;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl
	
	THREE.ShaderChunk[ 'meshlambert_vert' ] ="#define LAMBERT\n\nvarying vec3 vLightFront;\n\n#ifdef DOUBLE_SIDED\n\n\tvarying vec3 vLightBack;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl
	
	THREE.ShaderChunk[ 'meshphong_frag' ] ="#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl
	
	THREE.ShaderChunk[ 'meshphong_vert' ] ="#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl
	
	THREE.ShaderChunk[ 'meshphysical_frag' ] ="precision highp float;\n#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n\n\t#ifdef FALLOFF\n\t\tuniform vec3 falloffDiffuse;\n\t\tuniform float falloffOpacity;\n\t#endif\n\n#endif\n\n\nuniform float envMapIntensity; // temporary\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#ifdef FALLOFF\n\t\tvec4 falloffDiffuseColor = vec4( falloffDiffuse, falloffOpacity );\n\t#endif\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\n\t#include <falloffmap_fragment>\n\t#include <falloffalphamap_fragment>\n\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\n\t#include <falloff_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl
	
	THREE.ShaderChunk[ 'meshphysical_vert' ] ="#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/normal_frag.glsl
	
	THREE.ShaderChunk[ 'normal_frag' ] ="uniform float opacity;\nvarying vec3 vNormal;\n\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\n\t#include <logdepthbuf_fragment>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/normal_vert.glsl
	
	THREE.ShaderChunk[ 'normal_vert' ] ="varying vec3 vNormal;\n\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\tvNormal = normalize( normalMatrix * normal );\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/points_frag.glsl
	
	THREE.ShaderChunk[ 'points_frag' ] ="uniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/points_vert.glsl
	
	THREE.ShaderChunk[ 'points_vert' ] ="uniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl
	
	THREE.ShaderChunk[ 'shadow_frag' ] ="uniform float opacity;\n\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl
	
	THREE.ShaderChunk[ 'shadow_vert' ] ="#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\n}\n";
	
	// File:src/renderers/shaders/ShaderLib.js
	
	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	
	THREE.ShaderLib = {
	
		'basic': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ 'common' ],
				THREE.UniformsLib[ 'aomap' ],
				THREE.UniformsLib[ 'fog' ]
	
			] ),
	
			vertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]
	
		},
	
		'lambert': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ 'common' ],
				THREE.UniformsLib[ 'aomap' ],
				THREE.UniformsLib[ 'lightmap' ],
				THREE.UniformsLib[ 'emissivemap' ],
				THREE.UniformsLib[ 'fog' ],
				THREE.UniformsLib[ 'lights' ],
	
				{
					"emissive" : { value: new THREE.Color( 0x000000 ) }
				}
	
			] ),
	
			vertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]
	
		},
	
		'phong': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ 'common' ],
				THREE.UniformsLib[ 'aomap' ],
				THREE.UniformsLib[ 'lightmap' ],
				THREE.UniformsLib[ 'emissivemap' ],
				THREE.UniformsLib[ 'bumpmap' ],
				THREE.UniformsLib[ 'normalmap' ],
				THREE.UniformsLib[ 'displacementmap' ],
				THREE.UniformsLib[ 'fog' ],
				THREE.UniformsLib[ 'lights' ],
	
				{
					"emissive" : { value: new THREE.Color( 0x000000 ) },
					"specular" : { value: new THREE.Color( 0x111111 ) },
					"shininess": { value: 30 }
				}
	
			] ),
	
			vertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]
	
		},
	
		'standard': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ 'common' ],
				THREE.UniformsLib[ 'aomap' ],
				THREE.UniformsLib[ 'lightmap' ],
				THREE.UniformsLib[ 'emissivemap' ],
				THREE.UniformsLib[ 'bumpmap' ],
				THREE.UniformsLib[ 'normalmap' ],
				THREE.UniformsLib[ 'displacementmap' ],
				THREE.UniformsLib[ 'roughnessmap' ],
				THREE.UniformsLib[ 'metalnessmap' ],
				THREE.UniformsLib[ 'fog' ],
				THREE.UniformsLib[ 'lights' ],
	
				{
					"emissive" : { value: new THREE.Color( 0x000000 ) },
					"roughness": { value: 0.5 },
					"metalness": { value: 0 },
					"envMapIntensity" : { value: 1 }, // temporary
				}
	
			] ),
	
			vertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]
	
		},
	
		'points': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ 'points' ],
				THREE.UniformsLib[ 'fog' ]
	
			] ),
	
			vertexShader: THREE.ShaderChunk[ 'points_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'points_frag' ]
	
		},
	
		'dashed': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ 'common' ],
				THREE.UniformsLib[ 'fog' ],
	
				{
					"scale"    : { value: 1 },
					"dashSize" : { value: 1 },
					"totalSize": { value: 2 }
				}
	
			] ),
	
			vertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]
	
		},
	
		'depth': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ 'common' ],
				THREE.UniformsLib[ 'displacementmap' ]
	
			] ),
	
			vertexShader: THREE.ShaderChunk[ 'depth_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'depth_frag' ]
	
		},
	
		'normal': {
	
			uniforms: {
	
				"opacity" : { value: 1.0 }
	
			},
	
			vertexShader: THREE.ShaderChunk[ 'normal_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'normal_frag' ]
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'cube': {
	
			uniforms: THREE.UniformsUtils.merge( [
				THREE.UniformsLib[ 'common' ],
	
				{
					"envMap": { value: null },
					"envMapIntensity": { value: 1.0 },
					"tFlip": { value: - 1 },
					"opacity": { value: 1.0 },
					"roughness": { value: 0.0 },
				}
			]),
	
			vertexShader: THREE.ShaderChunk[ 'cube_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'cube_frag' ]
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'equirect': {
	
			uniforms: {
				"tEquirect": { value: null },
				"tFlip": { value: - 1 }
			},
	
			vertexShader: THREE.ShaderChunk[ 'equirect_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]
	
		},
	
		'distanceRGBA': {
	
			uniforms: {
	
				"lightPos": { value: new THREE.Vector3() }
	
			},
	
			vertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],
			fragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]
	
		}
	
	};
	
	THREE.ShaderLib[ 'physical' ] = {
	
		uniforms: THREE.UniformsUtils.merge( [
	
			THREE.ShaderLib[ 'standard' ].uniforms,
			THREE.UniformsLib[ 'falloffmap' ],
			THREE.UniformsLib[ 'falloffalphamap' ],
	
			{
				"falloffDiffuse": { value: new THREE.Color( 0xffffff ) },
				"falloffOpacity": { value: 0 },
	
				"clearCoat": { value: 0 },
				"clearCoatRoughness": { value: 0 }
			}
	
		] ),
	
		vertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]
	
	};
	
	// File:src/renderers/WebGLRenderer.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */
	
	THREE.WebGLRenderer = function ( parameters ) {
	
		console.log( 'THREE.WebGLRenderer', THREE.REVISION );
	
		parameters = parameters || {};
	
		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,
	
		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
	
		var lights = [];
	
		var opaqueObjects = [];
		var opaqueObjectsLastIndex = - 1;
		var transparentObjects = [];
		var transparentObjectsLastIndex = - 1;
	
		var morphInfluences = new Float32Array( 8 );
	
		var sprites = [];
		var lensFlares = [];
	
		var passScene = null, passCamera = null, passQuad = null;
	
		// public properties
	
		this.domElement = _canvas;
		this.context = null;
	
		// clearing
	
		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
	
		// scene graph
	
		this.sortObjects = true;
	
		// user-defined clipping
	
		this.clippingPlanes = [];
		this.localClippingEnabled = false;
	
		// physically based shading
	
		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;
	
		// physical lights
	
		this.physicallyCorrectLights = false;
	
		// tone mapping
	
		this.toneMapping = THREE.LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;
	
		// morphs
	
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
	
		// flags
	
		this.autoScaleCubemaps = true;
		this.autoResizeTextures = false;
	
		// internal properties
	
		var _this = this,
	
		// internal state cache
	
		_currentProgram = null,
		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,
	
		_currentScissor = new THREE.Vector4(),
		_currentScissorTest = null,
	
		_currentViewport = new THREE.Vector4(),
	
		//
	
		_usedTextureUnits = 0,
	
		//
	
		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0,
	
		_width = _canvas.width,
		_height = _canvas.height,
	
		_pixelRatio = 1,
	
		_scissor = new THREE.Vector4( 0, 0, _width, _height ),
		_scissorTest = false,
	
		_viewport = new THREE.Vector4( 0, 0, _width, _height ),
	
		// frustum
	
		_frustum = new THREE.Frustum(),
	
		// clipping
	
		_clipping = new THREE.WebGLClipping(),
		_clippingEnabled = false,
		_localClippingEnabled = false,
	
		_sphere = new THREE.Sphere(),
	
		// camera matrices cache
	
		_projScreenMatrix = new THREE.Matrix4(),
	
		_vector3 = new THREE.Vector3(),
	
		// light arrays cache
	
		_lights = {
	
			hash: '',
	
			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
	
			shadows: []
	
		},
	
		// info
	
		_infoRender = {
	
			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0
	
		};
	
		this.info = {
	
			render: _infoRender,
			memory: {
	
				geometries: 0,
				textures: 0
	
			},
			programs: null
	
		};
	
	
		// initialize
	
		var _gl;
	
		try {
	
			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};
	
			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );
	
			if ( _gl === null ) {
	
				if ( _canvas.getContext( 'webgl' ) !== null ) {
	
					throw 'Error creating WebGL context with your selected attributes.';
	
				} else {
	
					throw 'Error creating WebGL context.';
	
				}
	
			}
	
			// Some experimental-webgl implementations do not have getShaderPrecisionFormat
	
			if ( _gl.getShaderPrecisionFormat === undefined ) {
	
				_gl.getShaderPrecisionFormat = function () {
	
					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
	
				};
	
			}
	
			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
	
		} catch ( error ) {
	
			console.error( 'THREE.WebGLRenderer: ' + error );
	
		}
	
		var extensions = new THREE.WebGLExtensions( _gl );
	
		extensions.get( 'WEBGL_depth_texture' );
		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );
		extensions.get( 'ANGLE_instanced_arrays' );
	
		if ( extensions.get( 'OES_element_index_uint' ) ) {
	
			THREE.BufferGeometry.MaxIndex = 4294967296;
	
		}
	
		var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );
	
		var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
		var properties = new THREE.WebGLProperties();
		var textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
		var objects = new THREE.WebGLObjects( _gl, properties, this.info );
		var programCache = new THREE.WebGLPrograms( this, capabilities );
		var lightCache = new THREE.WebGLLights();
	
		this.info.programs = programCache.programs;
	
		var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
		var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );
	
		//
	
		var backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		var backgroundCamera2 = new THREE.PerspectiveCamera();
		var backgroundPlaneMesh = new THREE.Mesh(
			new THREE.PlaneBufferGeometry( 2, 2 ),
			new THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
		);
		var backgroundBoxShader = THREE.ShaderLib[ 'cube' ];
		var backgroundBoxMesh = new THREE.Mesh(
			new THREE.BoxBufferGeometry( 5, 5, 5 ),
			new THREE.ShaderMaterial( {
				uniforms: backgroundBoxShader.uniforms,
				vertexShader: backgroundBoxShader.vertexShader,
				fragmentShader: backgroundBoxShader.fragmentShader,
				side: THREE.BackSide,
				depthTest: false,
				depthWrite: false,
				fog: false
			} )
		);
	
		//
	
		function getTargetPixelRatio() {
	
			return _currentRenderTarget === null ? _pixelRatio : 1;
	
		}
	
		function glClearColor( r, g, b, a ) {
	
			if ( _premultipliedAlpha === true ) {
	
				r *= a; g *= a; b *= a;
	
			}
	
			state.clearColor( r, g, b, a );
	
		}
	
		function setDefaultGLState() {
	
			state.init();
	
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		}
	
		function resetGLState() {
	
			_currentProgram = null;
			_currentCamera = null;
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
	
			state.reset();
	
		}
	
		setDefaultGLState();
	
		this.context = _gl;
		this.capabilities = capabilities;
		this.extensions = extensions;
		this.properties = properties;
		this.state = state;
	
		// shadow map
	
		var shadowMap = new THREE.WebGLShadowMap( this, _lights, objects, capabilities );
	
		this.shadowMap = shadowMap;
	
	
		// Plugins
	
		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );
	
		// API
	
		this.getContext = function () {
	
			return _gl;
	
		};
	
		this.getContextAttributes = function () {
	
			return _gl.getContextAttributes();
	
		};
	
		this.forceContextLoss = function () {
	
			extensions.get( 'WEBGL_lose_context' ).loseContext();
	
		};
	
		this.getMaxAnisotropy = function () {
	
			return capabilities.getMaxAnisotropy();
	
		};
	
		this.getPrecision = function () {
	
			return capabilities.precision;
	
		};
	
		this.getPixelRatio = function () {
	
			return _pixelRatio;
	
		};
	
		this.setPixelRatio = function ( value ) {
	
			if ( value === undefined ) return;
	
			_pixelRatio = value;
	
			this.setSize( _viewport.z, _viewport.w, false );
	
		};
	
		this.getSize = function () {
	
			return {
				width: _width,
				height: _height
			};
	
		};
	
		this.setSize = function ( width, height, updateStyle ) {
	
			_width = width;
			_height = height;
	
			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;
	
			if ( updateStyle !== false ) {
	
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
	
			}
	
			this.setViewport( 0, 0, width, height );
	
		};
	
		this.setViewport = function ( x, y, width, height ) {
	
			state.viewport( _viewport.set( x, y, width, height ) );
	
		};
	
		this.setScissor = function ( x, y, width, height ) {
	
			state.scissor( _scissor.set( x, y, width, height ) );
	
		};
	
		this.setScissorTest = function ( boolean ) {
	
			state.setScissorTest( _scissorTest = boolean );
	
		};
	
		// Clearing
	
		this.getClearColor = function () {
	
			return _clearColor;
	
		};
	
		this.setClearColor = function ( color, alpha ) {
	
			_clearColor.set( color );
	
			_clearAlpha = alpha !== undefined ? alpha : 1;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.getClearAlpha = function () {
	
			return _clearAlpha;
	
		};
	
		this.setClearAlpha = function ( alpha ) {
	
			_clearAlpha = alpha;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.clear = function ( color, depth, stencil ) {
	
			var bits = 0;
	
			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
			_gl.clear( bits );
	
		};
	
		this.clearColor = function () {
	
			this.clear( true, false, false );
	
		};
	
		this.clearDepth = function () {
	
			this.clear( false, true, false );
	
		};
	
		this.clearStencil = function () {
	
			this.clear( false, false, true );
	
		};
	
		this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );
	
		};
	
		// Reset
	
		this.resetGLState = resetGLState;
	
		this.dispose = function() {
	
			transparentObjects = [];
			transparentObjectsLastIndex = -1;
			opaqueObjects = [];
			opaqueObjectsLastIndex = -1;
	
			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
	
		};
	
		// Events
	
		function onContextLost( event ) {
	
			event.preventDefault();
	
			resetGLState();
			setDefaultGLState();
	
			properties.clear();
	
		}
	
		function onMaterialDispose( event ) {
	
			var material = event.target;
	
			material.removeEventListener( 'dispose', onMaterialDispose );
	
			deallocateMaterial( material );
	
		}
	
		// Buffer deallocation
	
		function deallocateMaterial( material ) {
	
			releaseMaterialProgramReference( material );
	
			properties.delete( material );
	
		}
	
	
		function releaseMaterialProgramReference( material ) {
	
			var programInfo = properties.get( material ).program;
	
			material.program = undefined;
	
			if ( programInfo !== undefined ) {
	
				programCache.releaseProgram( programInfo );
	
			}
	
		}
	
		// Buffer rendering
	
		this.renderBufferImmediate = function ( object, program, material ) {
	
			state.initAttributes();
	
			var buffers = properties.get( object );
	
			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
	
			var attributes = program.getAttributes();
	
			if ( object.hasPositions ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasNormals ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
	
				if ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {
	
					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {
	
						var array = object.normalArray;
	
						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;
	
						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;
	
						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;
	
						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;
	
					}
	
				}
	
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.normal );
	
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasUvs && material.map ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.uv );
	
				_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.color );
	
				_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			state.disableUnusedAttributes();
	
			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
			object.count = 0;
	
		};
	
		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
	
			setMaterial( material );
	
			var program = setProgram( camera, fog, material, object );
	
			var updateBuffers = false;
			var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
	
			if ( geometryProgram !== _currentGeometryProgram ) {
	
				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;
	
			}
	
			// morph targets
	
			var morphTargetInfluences = object.morphTargetInfluences;
	
			if ( morphTargetInfluences !== undefined ) {
	
				var activeInfluences = [];
	
				for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {
	
					var influence = morphTargetInfluences[ i ];
					activeInfluences.push( [ influence, i ] );
	
				}
	
				activeInfluences.sort( absNumericalSort );
	
				if ( activeInfluences.length > 8 ) {
	
					activeInfluences.length = 8;
	
				}
	
				var morphAttributes = geometry.morphAttributes;
	
				for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {
	
					var influence = activeInfluences[ i ];
					morphInfluences[ i ] = influence[ 0 ];
	
					if ( influence[ 0 ] !== 0 ) {
	
						var index = influence[ 1 ];
	
						if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
						if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );
	
					} else {
	
						if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
						if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );
	
					}
	
				}
	
				program.getUniforms().setValue(
						_gl, 'morphTargetInfluences', morphInfluences );
	
				updateBuffers = true;
	
			}
	
			//
	
			var index = geometry.index;
			var position = geometry.attributes.position;
	
			if ( material.wireframe === true ) {
	
				index = objects.getWireframeAttribute( geometry );
	
			}
	
			var renderer;
	
			if ( index !== null ) {
	
				renderer = indexedBufferRenderer;
				renderer.setIndex( index );
	
			} else {
	
				renderer = bufferRenderer;
	
			}
	
			if ( updateBuffers ) {
	
				setupVertexAttributes( material, program, geometry );
	
				if ( index !== null ) {
	
					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );
	
				}
	
			}
	
			//
	
			var dataStart = 0;
			var dataCount = Infinity;
	
			if ( index !== null ) {
	
				dataCount = index.count;
	
			} else if ( position !== undefined ) {
	
				dataCount = position.count;
	
			}
	
			var rangeStart = geometry.drawRange.start;
			var rangeCount = geometry.drawRange.count;
	
			var groupStart = group !== null ? group.start : 0;
			var groupCount = group !== null ? group.count : Infinity;
	
			var drawStart = Math.max( dataStart, rangeStart, groupStart );
			var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
	
			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
	
			//
	
			if ( object instanceof THREE.Mesh ) {
	
				if ( material.wireframe === true ) {
	
					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );
	
				} else {
	
					switch ( object.drawMode ) {
	
						case THREE.TrianglesDrawMode:
							renderer.setMode( _gl.TRIANGLES );
							break;
	
						case THREE.TriangleStripDrawMode:
							renderer.setMode( _gl.TRIANGLE_STRIP );
							break;
	
						case THREE.TriangleFanDrawMode:
							renderer.setMode( _gl.TRIANGLE_FAN );
							break;
	
					}
	
				}
	
	
			} else if ( object instanceof THREE.Line ) {
	
				var lineWidth = material.linewidth;
	
				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
	
				state.setLineWidth( lineWidth * getTargetPixelRatio() );
	
				if ( object instanceof THREE.LineSegments ) {
	
					renderer.setMode( _gl.LINES );
	
				} else {
	
					renderer.setMode( _gl.LINE_STRIP );
	
				}
	
			} else if ( object instanceof THREE.Points ) {
	
				renderer.setMode( _gl.POINTS );
	
			}
	
			if ( geometry instanceof THREE.InstancedBufferGeometry ) {
	
				if ( geometry.maxInstancedCount > 0 ) {
	
					renderer.renderInstances( geometry, drawStart, drawCount );
	
				}
	
			} else {
	
				renderer.render( drawStart, drawCount );
	
			}
	
		};
	
		function setupVertexAttributes( material, program, geometry, startIndex ) {
	
			var extension;
	
			if ( geometry instanceof THREE.InstancedBufferGeometry ) {
	
				extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
			}
	
			if ( startIndex === undefined ) startIndex = 0;
	
			state.initAttributes();
	
			var geometryAttributes = geometry.attributes;
	
			var programAttributes = program.getAttributes();
	
			var materialDefaultAttributeValues = material.defaultAttributeValues;
	
			for ( var name in programAttributes ) {
	
				var programAttribute = programAttributes[ name ];
	
				if ( programAttribute >= 0 ) {
	
					var geometryAttribute = geometryAttributes[ name ];
	
					if ( geometryAttribute !== undefined ) {
	
						var type = _gl.FLOAT;
						var array = geometryAttribute.array;
						var normalized = geometryAttribute.normalized;
	
						if ( array instanceof Float32Array ) {
	
							type = _gl.FLOAT;
	
						} else if ( array instanceof Float64Array ) {
	
							console.warn("Unsupported data buffer format: Float64Array");
	
						} else if ( array instanceof Uint16Array ) {
	
							type = _gl.UNSIGNED_SHORT;
	
						} else if ( array instanceof Int16Array ) {
	
							type = _gl.SHORT;
	
						} else if ( array instanceof Uint32Array ) {
	
							type = _gl.UNSIGNED_INT;
	
						} else if ( array instanceof Int32Array ) {
	
							type = _gl.INT;
	
						} else if ( array instanceof Int8Array ) {
	
							type = _gl.BYTE;
	
						} else if ( array instanceof Uint8Array ) {
	
							type = _gl.UNSIGNED_BYTE;
	
						}
	
						var size = geometryAttribute.itemSize;
						var buffer = objects.getAttributeBuffer( geometryAttribute );
	
						if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {
	
							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;
	
							if ( data instanceof THREE.InstancedInterleavedBuffer ) {
	
								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );
	
						} else {
	
							if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {
	
								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );
	
						}
	
					} else if ( materialDefaultAttributeValues !== undefined ) {
	
						var value = materialDefaultAttributeValues[ name ];
	
						if ( value !== undefined ) {
	
							switch ( value.length ) {
	
								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;
	
								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;
	
								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;
	
								default:
									_gl.vertexAttrib1fv( programAttribute, value );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			state.disableUnusedAttributes();
	
		}
	
		// Sorting
	
		function absNumericalSort( a, b ) {
	
			return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );
	
		}
	
		function painterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {
	
				return a.material.program.id - b.material.program.id;
	
			} else if ( a.material.id !== b.material.id ) {
	
				return a.material.id - b.material.id;
	
			} else if ( a.z !== b.z ) {
	
				return a.z - b.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		function reversePainterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		// Rendering
	
		this.renderOverride = function ( overrideMaterial, scene, camera, renderTarget, forceClear ) {
	
			scene.overrideMaterial = overrideMaterial;
			this.render( scene, camera, renderTarget, forceClear );
			scene.overrideMaterial = null;
	
		};
	
		this.renderPass = function ( passMaterial, renderTarget, forceClear ) {
	
			if( passScene === null ) {
				passCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
				passQuad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
				passScene = new THREE.Scene();
				passScene.add( passQuad );
			}
	
			passQuad.material = passMaterial;
			this.render( passScene, passCamera, renderTarget, forceClear );
			passQuad.material = null;
	
		};
	
	
		this.render = function ( scene, camera, renderTarget, forceClear ) {
	
			if ( camera instanceof THREE.Camera === false ) {
	
				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			var fog = scene.fog;
	
			// reset caching for this frame
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
	
			// update scene graph
	
			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			if ( camera.parent === null ) camera.updateMatrixWorld();
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			lights.length = 0;
	
			opaqueObjectsLastIndex = - 1;
			transparentObjectsLastIndex = - 1;
	
			sprites.length = 0;
			lensFlares.length = 0;
	
			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
	
			projectObject( scene, camera );
	
			opaqueObjects.length = opaqueObjectsLastIndex + 1;
			transparentObjects.length = transparentObjectsLastIndex + 1;
	
			if ( _this.sortObjects === true ) {
	
				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );
	
			}
	
			//
	
			if ( _clippingEnabled ) _clipping.beginShadows();
	
			setupShadows( lights );
	
			shadowMap.render( scene, camera );
	
			setupLights( lights, camera );
	
			if ( _clippingEnabled ) _clipping.endShadows();
	
			//
	
			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;
	
			if ( renderTarget === undefined ) {
	
				renderTarget = null;
	
			}
	
			//console.log( "render() renderTarget: ", renderTarget );
	
			this.setRenderTarget( renderTarget );
	
			//
	
			var background = scene.background;
			background = null;
	
			if ( background === null ) {
	
				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
			} else if ( background instanceof THREE.Color ) {
	
				glClearColor( background.r, background.g, background.b, 1 );
	
			}
	
			if ( this.autoClear || forceClear ) {
	
				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
			}
	
			if ( background instanceof THREE.CubeTexture ) {
	
				backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );
	
				backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
				backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );
	
				backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
				backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );
	
				objects.update( backgroundBoxMesh );
	
				_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );
	
			} else if ( background instanceof THREE.Texture ) {
	
				backgroundPlaneMesh.material.map = background;
	
				objects.update( backgroundPlaneMesh );
	
				_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );
	
			}
	
			//
	
			if ( scene.overrideMaterial ) {
	
				var overrideMaterial = scene.overrideMaterial;
	
				renderObjects( opaqueObjects, camera, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, fog, overrideMaterial );
	
			} else {
	
				// opaque pass (front-to-back order)
	
				state.setBlending( THREE.NoBlending );
				renderObjects( opaqueObjects, camera, fog );
	
				// transparent pass (back-to-front order)
	
				renderObjects( transparentObjects, camera, fog );
	
			}
	
			// custom render plugins (post pass)
	
			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentViewport );
	
			// Generate mipmap if we're using any kind of mipmap filtering
	
			if ( renderTarget ) {
	
				textures.updateRenderTargetMipmap( renderTarget );
	
			}
	
			// Ensure depth buffer writing is enabled so it can be cleared on next render
	
			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );
	
			// _gl.finish();
	
		};
	
		function pushRenderItem( object, geometry, material, z, group ) {
	
			var array, index;
	
			// allocate the next position in the appropriate array
	
			if ( material.transparent ) {
	
				array = transparentObjects;
				index = ++ transparentObjectsLastIndex;
	
			} else {
	
				array = opaqueObjects;
				index = ++ opaqueObjectsLastIndex;
	
			}
	
			// recycle existing render item or grow the array
	
			var renderItem = array[ index ];
	
			if ( renderItem !== undefined ) {
	
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.z = _vector3.z;
				renderItem.group = group;
	
			} else {
	
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					z: _vector3.z,
					group: group
				};
	
				// assert( index === array.length );
				array.push( renderItem );
	
			}
	
		}
	
		// TODO Duplicated code (Frustum)
	
		function isObjectViewable( object ) {
	
			var geometry = object.geometry;
	
			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();
	
			_sphere.copy( geometry.boundingSphere ).
				applyMatrix4( object.matrixWorld );
	
			return isSphereViewable( _sphere );
	
		}
	
		function isSpriteViewable( sprite ) {
	
			_sphere.center.set( 0, 0, 0 );
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4( sprite.matrixWorld );
	
			return isSphereViewable( _sphere );
	
		}
	
		function isSphereViewable( sphere ) {
	
			if ( ! _frustum.intersectsSphere( sphere ) ) return false;
	
			var numPlanes = _clipping.numPlanes;
	
			if ( numPlanes === 0 ) return true;
	
			var planes = _this.clippingPlanes,
	
				center = sphere.center,
				negRad = - sphere.radius,
				i = 0;
	
			do {
	
				// out when deeper than radius in the negative halfspace
				if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
	
			} while ( ++ i !== numPlanes );
	
			return true;
	
		}
	
		function projectObject( object, camera ) {
	
			if ( object.visible === false ) return;
	
			if ( object.layers.test( camera.layers ) ) {
	
				if ( object instanceof THREE.Light ) {
	
					lights.push( object );
	
				} else if ( object instanceof THREE.Sprite ) {
	
					if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {
	
						sprites.push( object );
	
					}
	
				} else if ( object instanceof THREE.LensFlare ) {
	
					lensFlares.push( object );
	
				} else if ( object instanceof THREE.ImmediateRenderObject ) {
	
					if ( _this.sortObjects === true ) {
	
						_vector3.setFromMatrixPosition( object.matrixWorld );
						_vector3.applyProjection( _projScreenMatrix );
	
					}
	
					pushRenderItem( object, null, object.material, _vector3.z, null );
	
				} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {
	
					if ( object instanceof THREE.SkinnedMesh ) {
	
						object.skeleton.update();
	
					}
	
					if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {
	
						var material = object.material;
	
						if ( material.visible === true ) {
	
							if ( _this.sortObjects === true ) {
	
								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );
	
							}
	
							var geometry = objects.update( object );
	
							if ( material instanceof THREE.MultiMaterial ) {
	
								var groups = geometry.groups;
								var materials = material.materials;
	
								for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
									var group = groups[ i ];
									var groupMaterial = materials[ group.materialIndex ];
	
									if ( groupMaterial.visible === true ) {
	
										pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );
	
									}
	
								}
	
							} else {
	
								pushRenderItem( object, geometry, material, _vector3.z, null );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				projectObject( children[ i ], camera );
	
			}
	
		}
	
		function renderObjects( renderList, camera, fog, overrideMaterial ) {
	
			for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
				var renderItem = renderList[ i ];
	
				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;
	
				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
	
				if ( object instanceof THREE.ImmediateRenderObject ) {
	
					setMaterial( material );
	
					var program = setProgram( camera, fog, material, object );
	
					_currentGeometryProgram = '';
	
					object.render( function ( object ) {
	
						_this.renderBufferImmediate( object, program, material );
	
					} );
	
				} else {
	
					_this.renderBufferDirect( camera, fog, geometry, material, object, group );
	
				}
	
			}
	
		}
	
		function initMaterial( material, fog, object ) {
	
			var materialProperties = properties.get( material );
	
			var parameters = programCache.getParameters(
					material, _lights, fog, _clipping.numPlanes, object );
	
			var code = programCache.getProgramCode( material, parameters );
	
			var program = materialProperties.program;
			var programChange = true;
	
			if ( program === undefined ) {
	
				// new material
				material.addEventListener( 'dispose', onMaterialDispose );
	
			} else if ( program.code !== code ) {
	
				// changed glsl or parameters
				releaseMaterialProgramReference( material );
	
			} else if ( parameters.shaderID !== undefined ) {
	
				// same glsl and uniform list
				return;
	
			} else {
	
				// only rebuild uniform list
				programChange = false;
	
			}
	
			if ( programChange ) {
	
				if ( parameters.shaderID ) {
	
					var shader = THREE.ShaderLib[ parameters.shaderID ];
	
					materialProperties.__webglShader = {
						name: material.type,
						uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};
	
				} else {
	
					materialProperties.__webglShader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};
	
				}
	
				material.__webglShader = materialProperties.__webglShader;
	
				program = programCache.acquireProgram( material, parameters, code );
	
				materialProperties.program = program;
				material.program = program;
	
			}
	
			var attributes = program.getAttributes();
	
			if ( material.morphTargets ) {
	
				material.numSupportedMorphTargets = 0;
	
				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
					if ( attributes[ 'morphTarget' + i ] >= 0 ) {
	
						material.numSupportedMorphTargets ++;
	
					}
	
				}
	
			}
	
			if ( material.morphNormals ) {
	
				material.numSupportedMorphNormals = 0;
	
				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
	
					if ( attributes[ 'morphNormal' + i ] >= 0 ) {
	
						material.numSupportedMorphNormals ++;
	
					}
	
				}
	
			}
	
			var uniforms = materialProperties.__webglShader.uniforms;
	
			if ( ! ( material instanceof THREE.ShaderMaterial ) &&
					! ( material instanceof THREE.RawShaderMaterial ) ||
					material.clipping === true ) {
	
				materialProperties.numClippingPlanes = _clipping.numPlanes;
				uniforms.clippingPlanes = _clipping.uniform;
	
			}
	
			if ( material.lights ) {
	
				// store the light setup it was created for
	
				materialProperties.lightsHash = _lights.hash;
	
				// wire up the material to this renderer's lighting state
	
				uniforms.ambientLightColor.value = _lights.ambient;
				uniforms.directionalLights.value = _lights.directional;
				uniforms.spotLights.value = _lights.spot;
				uniforms.pointLights.value = _lights.point;
				uniforms.hemisphereLights.value = _lights.hemi;
	
				uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
				uniforms.spotShadowMap.value = _lights.spotShadowMap;
				uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
				uniforms.pointShadowMap.value = _lights.pointShadowMap;
				uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
	
			}
	
			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
						THREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
	
			materialProperties.uniformsList = uniformsList;
			materialProperties.dynamicUniforms =
					THREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );
	
		}
	
		function setMaterial( material ) {
	
			if ( material.side !== THREE.DoubleSide )
				state.enable( _gl.CULL_FACE );
			else
				state.disable( _gl.CULL_FACE );
	
			state.setFlipSided( material.side === THREE.BackSide );
	
			if ( material.transparent === true ) {
	
				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
	
			} else {
	
				state.setBlending( THREE.NoBlending );
	
			}
	
			state.setDepthFunc( material.depthFunc );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
		}
	
		function setProgram( camera, fog, material, object ) {
	
			_usedTextureUnits = 0;
	
			var materialProperties = properties.get( material );
	
			if ( _clippingEnabled ) {
	
				if ( _localClippingEnabled || camera !== _currentCamera ) {
	
					var useCache =
							camera === _currentCamera &&
							material.id === _currentMaterialId;
	
					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
							material.clippingPlanes, material.clipShadows,
							camera, materialProperties, useCache );
	
				}
	
				if ( materialProperties.numClippingPlanes !== undefined &&
					materialProperties.numClippingPlanes !== _clipping.numPlanes ) {
	
					material.needsUpdate = true;
	
				}
	
			}
	
			if ( materialProperties.program === undefined ) {
	
				material.needsUpdate = true;
	
			}
	
			if ( materialProperties.lightsHash !== undefined &&
				materialProperties.lightsHash !== _lights.hash ) {
	
				material.needsUpdate = true;
	
			}
	
			if ( material.needsUpdate ) {
	
				initMaterial( material, fog, object );
				material.needsUpdate = false;
	
			}
	
			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;
	
			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.__webglShader.uniforms;
	
			if ( program.id !== _currentProgram ) {
	
				_gl.useProgram( program.program );
				_currentProgram = program.id;
	
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
	
			}
	
			if ( material.id !== _currentMaterialId ) {
	
				_currentMaterialId = material.id;
	
				refreshMaterial = true;
	
			}
	
			if ( refreshProgram || camera !== _currentCamera ) {
	
				p_uniforms.set( _gl, camera, 'projectionMatrix' );
	
				if ( capabilities.logarithmicDepthBuffer ) {
	
					p_uniforms.setValue( _gl, 'logDepthBufFC',
							2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
				}
	
	
				if ( camera !== _currentCamera ) {
	
					_currentCamera = camera;
	
					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:
	
					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done
	
				}
	
				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
	
				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshStandardMaterial ||
					 material.envMap ) {
	
					var uCamPos = p_uniforms.map.cameraPosition;
	
					if ( uCamPos !== undefined ) {
	
						uCamPos.setValue( _gl,
								_vector3.setFromMatrixPosition( camera.matrixWorld ) );
	
					}
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshStandardMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {
	
					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
	
				}
	
				p_uniforms.set( _gl, _this, 'toneMappingExposure' );
				p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );
	
			}
	
			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen
	
			if ( material.skinning ) {
	
				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
	
				var skeleton = object.skeleton;
	
				if ( skeleton ) {
	
					if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {
	
						p_uniforms.set( _gl, skeleton, 'boneTexture' );
						p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
						p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );
	
					} else {
	
						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
	
					}
	
				}
	
			}
	
			if ( refreshMaterial ) {
	
				if ( material.lights ) {
	
					// the current material requires lighting info
	
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
	
					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
	
				}
	
				// refresh uniforms common to several materials
	
				if ( fog && material.fog ) {
	
					refreshUniformsFog( m_uniforms, fog );
	
				}
	
				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshStandardMaterial ||
					 material instanceof THREE.MeshDepthMaterial ||
					 material instanceof THREE.MeshCubeMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
				}
	
				// refresh single material specific uniforms
	
				if ( material instanceof THREE.LineBasicMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
	
				} else if ( material instanceof THREE.LineDashedMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );
	
				} else if ( material instanceof THREE.PointsMaterial ) {
	
					refreshUniformsPoints( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshCubeMaterial ) {
	
					refreshUniformsCube( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshLambertMaterial ) {
	
					refreshUniformsLambert( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsPhong( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshPhysicalMaterial ) {
	
					refreshUniformsPhysical( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshStandardMaterial ) {
	
					refreshUniformsStandard( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
					if ( material.displacementMap ) {
	
						m_uniforms.displacementMap.value = material.displacementMap;
						m_uniforms.displacementScale.value = material.displacementScale;
						m_uniforms.displacementBias.value = material.displacementBias;
	
					}
	
				} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
					m_uniforms.opacity.value = material.opacity;
	
				}
	
				THREE.WebGLUniforms.upload(
						_gl, materialProperties.uniformsList, m_uniforms, _this );
	
			}
	
	
			// common matrices
	
			p_uniforms.set( _gl, object, 'modelViewMatrix' );
			p_uniforms.set( _gl, object, 'normalMatrix' );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
	
	
			// dynamic uniforms
	
			var dynUniforms = materialProperties.dynamicUniforms;
	
			if ( dynUniforms !== null ) {
	
				THREE.WebGLUniforms.evalDynamic(
						dynUniforms, m_uniforms, object, camera );
	
				THREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );
	
			}
	
			return program;
	
		}
	
		// Uniforms (refresh uniforms objects)
	
		var texelTransform = { texelScale: 0, texelOffset: 0 };
	
		function refreshUniformsCommon ( uniforms, material ) {
	
			uniforms.opacity.value = material.opacity;
	
			uniforms.diffuse.value = material.color;
	
			if ( material.emissive ) {
	
				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
	
			}
	
			var supportedMapNames = THREE.Map.SupportedMapNames;
			var supportedMapSlotNames = THREE.Map.SupportedMapSlotNames;
			var supportedMapUVNames = THREE.Map.SupportedMapUVNames;
			var supportedMapTexelNames = THREE.Map.SupportedMapTexelNames;
	
			if( ! material.usedSlots || material.usedSlotsVersion != material.version ) {
				material.usedSlots = [];
				for( var i = 0, il = supportedMapNames.length; i < il; i ++ ) {
					var mapName = supportedMapNames[i];
					var mapSlotName = supportedMapSlotNames[i];
	
					var map = material[ mapSlotName ];
	
					material.usedSlots.push( {
						index: i,
						mapUniform: uniforms[mapName],
						uvUniform: uniforms[ supportedMapUVNames[i] ],
						texelUniform: uniforms[ supportedMapTexelNames[i] ]
					} );
				}
				material.usedSlotsVersion = material.version;
			}
	
			for( var j = 0, jl = material.usedSlots.length; j < jl; j ++ ) {
				var usedSlots = material.usedSlots[j];
				var i = usedSlots.index;
	
				var mapName = supportedMapNames[i];
				var mapSlotName = supportedMapSlotNames[i];
	
				var map = material[ mapSlotName ];
				if( map ) {
					usedSlots.mapUniform.value = map.texture;
					if( map.texture ) {
						if( map.uvTransform ) {
							var value = usedSlots.uvUniform.value;
							value.set(
								map.uvRepeat.x,
								map.uvRepeat.y,
								map.uvOffset.x,
								map.uvOffset.y );
						}
						if( map.texelTransform ) {
							texelTransform = map.getFlattenedTexelTransform( texelTransform );
							usedSlots.texelUniform.value.set( texelTransform.texelScale, texelTransform.texelOffset );
						}
					}
				}
				else if( material[ mapName ] ) {
					uniforms[mapName].value = material[mapName];
				}
			}
			//uniforms.map.value = material.map;
			//uniforms.specularMap.value = material.specularMap;
			//uniforms.alphaMap.value = material.alphaMap;
	
			if ( material.aoMap ) {
	
				//uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
	
			}
	
			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map
	
			var uvScaleMap;
	
			if ( material.map ) {
	
				uvScaleMap = material.map;
	
			} else if ( material.specularMap ) {
	
				uvScaleMap = material.specularMap;
	
			} else if ( material.displacementMap ) {
	
				uvScaleMap = material.displacementMap;
	
			} else if ( material.normalMap ) {
	
				uvScaleMap = material.normalMap;
	
			} else if ( material.bumpMap ) {
	
				uvScaleMap = material.bumpMap;
	
			} else if ( material.roughnessMap ) {
	
				uvScaleMap = material.roughnessMap;
	
			} else if ( material.metalnessMap ) {
	
				uvScaleMap = material.metalnessMap;
	
			} else if ( material.alphaMap ) {
	
				uvScaleMap = material.alphaMap;
	
			} else if ( material.emissiveMap ) {
	
				uvScaleMap = material.emissiveMap;
	
			}
	
			if ( uvScaleMap !== undefined ) {
	
				// backwards compatibility
				if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {
	
					uvScaleMap = uvScaleMap.texture;
	
				}
	
				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
			uniforms.envMap.value = material.envMap;
	
			// don't flip CubeTexture envMaps, flip everything else:
			//  WebGLRenderTargetCube will be flipped for backwards compatibility
			//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
			// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
			uniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;
	
			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;
	
		}
	
		function refreshUniformsCube ( uniforms, material ) {
	
			uniforms.roughness.value = material.roughness;
			uniforms.opacity.value = material.opacity;
			uniforms.envMapIntensity.value = material.envMapIntensity;
	
		}
	
		function refreshUniformsLine ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
	
		}
	
		function refreshUniformsDash ( uniforms, material ) {
	
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
	
		}
	
		function refreshUniformsPoints ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _canvas.clientHeight * 0.5;
	
			uniforms.map.value = material.map;
	
			if ( material.map !== null ) {
	
				var offset = material.map.offset;
				var repeat = material.map.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
		}
	
		function refreshUniformsFog ( uniforms, fog ) {
	
			uniforms.fogColor.value = fog.color;
	
			if ( fog instanceof THREE.Fog ) {
	
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
	
			} else if ( fog instanceof THREE.FogExp2 ) {
	
				uniforms.fogDensity.value = fog.density;
	
			}
	
		}
	
		function refreshUniformsLambert ( uniforms, material ) {
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
		}
	
		function refreshUniformsPhong ( uniforms, material ) {
	
			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
		}
	
		function refreshUniformsStandard ( uniforms, material ) {
	
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;
	
			if ( material.roughnessMap ) {
	
				uniforms.roughnessMap.value = material.roughnessMap;
	
			}
	
			if ( material.metalnessMap ) {
	
				uniforms.metalnessMap.value = material.metalnessMap;
	
			}
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
			if ( material.envMap ) {
	
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
	
			}
	
		}
	
		function refreshUniformsPhysical ( uniforms, material ) {
	
			uniforms.falloffDiffuse.value = material.falloffColor;
			if ( material.falloffMap ) {
				uniforms.falloffMap.value = material.falloffMap;
			}
	
			uniforms.falloffOpacity.value = material.falloffOpacity;
			if ( material.falloffAlphaMap ) {
				uniforms.falloffAlphaMap.value = material.falloffAlphaMap;
			}
	
			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
	
			refreshUniformsStandard( uniforms, material );
	
		}
	
		// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
		function markUniformsLightsNeedsUpdate ( uniforms, value ) {
	
			uniforms.ambientLightColor.needsUpdate = value;
	
			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
	
		}
	
		// Lighting
	
		function setupShadows ( lights ) {
	
			var lightShadowsLength = 0;
	
			for ( var i = 0, l = lights.length; i < l; i ++ ) {
	
				var light = lights[ i ];
	
				if ( light.castShadow ) {
	
					_lights.shadows[ lightShadowsLength ++ ] = light;
	
				}
	
			}
	
			_lights.shadows.length = lightShadowsLength;
	
		}
	
		function setupLights ( lights, camera ) {
	
			var l, ll, light,
			r = 0, g = 0, b = 0,
			color,
			intensity,
			distance,
			shadowMap,
	
			viewMatrix = camera.matrixWorldInverse,
	
			directionalLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0;
	
			for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
				light = lights[ l ];
	
				color = light.color;
				intensity = light.intensity;
				distance = light.distance;
	
				shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;
	
				if ( light instanceof THREE.AmbientLight ) {
	
					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
	
				} else if ( light instanceof THREE.DirectionalLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( _vector3 );
					uniforms.direction.transformDirection( viewMatrix );
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						uniforms.shadowBias = light.shadow.bias;
						uniforms.spreadAngle = light.shadow.spreadAngle;
						uniforms.shadowMapSize = light.shadow.mapSize;
						uniforms.shadowCameraParams = light.shadow.cameraParams;
	
					}
	
					_lights.directionalShadowMap[ directionalLength ] = shadowMap;
					_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					_lights.directional[ directionalLength ++ ] = uniforms;
	
				} else if ( light instanceof THREE.SpotLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
	
					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;
	
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( _vector3 );
					uniforms.direction.transformDirection( viewMatrix );
	
					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;
						uniforms.shadowCameraParams = light.shadow.cameraParams;
	
					}
	
					_lights.spotShadowMap[ spotLength ] = shadowMap;
					_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					_lights.spot[ spotLength ++ ] = uniforms;
	
				} else if ( light instanceof THREE.PointLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
	
					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;
	
					}
	
					_lights.pointShadowMap[ pointLength ] = shadowMap;
	
					if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {
	
						_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();
	
					}
	
					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position
					_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
					_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );
	
					_lights.point[ pointLength ++ ] = uniforms;
	
				} else if ( light instanceof THREE.HemisphereLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();
	
					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
	
					_lights.hemi[ hemiLength ++ ] = uniforms;
	
				}
	
			}
	
			_lights.ambient[ 0 ] = r;
			_lights.ambient[ 1 ] = g;
			_lights.ambient[ 2 ] = b;
	
			_lights.directional.length = directionalLength;
			_lights.spot.length = spotLength;
			_lights.point.length = pointLength;
			_lights.hemi.length = hemiLength;
	
			_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;
	
		}
	
		// GL state setting
	
		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
			state.setCullFace( cullFace );
			state.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );
	
		};
	
		// Textures
	
		function allocTextureUnit() {
	
			var textureUnit = _usedTextureUnits;
	
			if ( textureUnit >= capabilities.maxTextures ) {
	
				console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
	
			}
	
			_usedTextureUnits += 1;
	
			return textureUnit;
	
		}
	
		this.allocTextureUnit = allocTextureUnit;
	
		// this.setTexture2D = setTexture2D;
		this.setTexture2D = ( function() {
	
			var warned = false;
	
			// backwards compatibility: peel texture.texture
			return function setTexture2D( texture, slot ) {
	
				if ( texture instanceof THREE.WebGLRenderTarget ) {
	
					if ( ! warned ) {
	
						console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
						warned = true;
	
					}
	
					texture = texture.texture;
	
				}
	
				textures.setTexture2D( texture, slot );
	
			};
	
		}() );
	
		this.setTexture = ( function() {
	
			var warned = false;
	
			return function setTexture( texture, slot ) {
	
				if ( ! warned ) {
	
					console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
					warned = true;
	
				}
	
				textures.setTexture2D( texture, slot );
	
			};
	
		}() );
	
		this.setTextureCube = ( function() {
	
			var warned = false;
	
			return function setTextureCube( texture, slot ) {
	
				// backwards compatibility: peel texture.texture
				if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
					if ( ! warned ) {
	
						console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
						warned = true;
	
					}
	
					texture = texture.texture;
	
				}
	
				// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if ( texture instanceof THREE.CubeTexture ||
					 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
	
					// CompressedTexture can have Array in image :/
	
					// this function alone should take care of cube textures
					textures.setTextureCube( texture, slot );
	
				} else {
	
					// assumed: texture property of THREE.WebGLRenderTargetCube
	
					textures.setTextureCubeDynamic( texture, slot );
	
				}
	
			};
	
		}() );
	
		this.getCurrentRenderTarget = function() {
	
			return _currentRenderTarget;
	
		};
	
		this.setRenderTarget = function ( renderTarget ) {
	
			_currentRenderTarget = renderTarget;
	
			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
	
				textures.setupRenderTarget( renderTarget );
	
			}
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
			var framebuffer;
	
			if ( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
	
				if ( isCube ) {
	
					framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
				} else {
	
					framebuffer = renderTargetProperties.__webglFramebuffer;
	
				}
	
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;
	
				_currentViewport.copy( renderTarget.viewport );
	
			} else {
	
				framebuffer = null;
	
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;
	
				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
	
			}
	
			if ( _currentFramebuffer !== framebuffer ) {
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;
	
			}
	
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );
	
			state.viewport( _currentViewport );
	
			if ( isCube ) {
	
				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );
	
			}
	
		};
	
		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
	
			if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {
	
				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;
	
			}
	
			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
			if ( framebuffer ) {
	
				var restore = false;
	
				if ( framebuffer !== _currentFramebuffer ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
					restore = true;
	
				}
	
				try {
	
					var texture = renderTarget.texture;
	
					if ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;
	
					}
	
					if ( texture.type !== THREE.UnsignedByteType &&
					     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&
					     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&
					     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;
	
					}
	
					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
	
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	
						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {
	
							_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );
	
						}
	
					} else {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
					}
	
				} finally {
	
					if ( restore ) {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
	
					}
	
				}
	
			}
	
		};
	
		// Map three.js constants to WebGL constants
	
		function paramThreeToGL ( p ) {
	
			var extension;
	
			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;
	
			extension = extensions.get( 'OES_texture_half_float' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;
	
			}
	
			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
			if ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;
	
			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
			}
	
			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
			}
	
			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
	
			}
	
			extension = extensions.get( 'EXT_blend_minmax' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;
	
			}
	
			return 0;
	
		}
	
	};
	
	// File:src/renderers/WebGLRenderTarget.js
	
	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */
	
	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	THREE.WebGLRenderTarget = function ( width, height, options ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.width = width;
		this.height = height;
	
		this.scissor = new THREE.Vector4( 0, 0, width, height );
		this.scissorTest = false;
	
		this.viewport = new THREE.Vector4( 0, 0, width, height );
	
		options = options || {};
	
		if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;
	
		this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
	
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = null;
	
	};
	
	Object.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {
	
		setSize: function ( width, height ) {
	
			if ( this.width !== width || this.height !== height ) {
	
				this.width = width;
				this.height = height;
	
				this.dispose();
	
			}
	
			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.width = source.width;
			this.height = source.height;
	
			this.viewport.copy( source.viewport );
	
			this.texture = source.texture.clone();
	
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	} );
	
	// File:src/renderers/WebGLRenderTargetCube.js
	
	/**
	 * @author alteredq / http://alteredqualia.com
	 */
	
	THREE.WebGLRenderTargetCube = function ( width, height, options ) {
	
		THREE.WebGLRenderTarget.call( this, width, height, options );
	
		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
		this.activeMipMapLevel = 0;
	
	};
	
	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
	
	// File:src/renderers/webgl/WebGLBufferRenderer.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		function render( start, count ) {
	
			_gl.drawArrays( mode, start, count );
	
			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;
	
		}
	
		function renderInstances( geometry ) {
	
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extension === null ) {
	
				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;
	
			}
	
			var position = geometry.attributes.position;
	
			var count = 0;
	
			if ( position instanceof THREE.InterleavedBufferAttribute ) {
	
				count = position.data.count;
	
				extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
			} else {
	
				count = position.count;
	
				extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
			}
	
			_infoRender.calls ++;
			_infoRender.vertices += count * geometry.maxInstancedCount;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;
	
		}
	
		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	
	};
	
	// File:src/renderers/webgl/WebGLClipping.js
	
	THREE.WebGLClipping = function() {
	
		var scope = this,
	
			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,
	
			plane = new THREE.Plane(),
			viewNormalMatrix = new THREE.Matrix3(),
	
			uniform = { value: null, needsUpdate: false };
	
		this.uniform = uniform;
		this.numPlanes = 0;
	
		this.init = function( planes, enableLocalClipping, camera ) {
	
			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;
	
			localClippingEnabled = enableLocalClipping;
	
			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;
	
			return enabled;
	
		};
	
		this.beginShadows = function() {
	
			renderingShadows = true;
			projectPlanes( null );
	
		};
	
		this.endShadows = function() {
	
			renderingShadows = false;
			resetGlobalState();
	
		};
	
		this.setState = function( planes, clipShadows, camera, cache, fromCache ) {
	
			if ( ! localClippingEnabled ||
					planes === null || planes.length === 0 ||
					renderingShadows && ! clipShadows ) {
				// there's no local clipping
	
				if ( renderingShadows ) {
					// there's no global clipping
	
					projectPlanes( null );
	
				} else {
	
					resetGlobalState();
				}
	
			} else {
	
				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,
	
					dstArray = cache.clippingState || null;
	
				uniform.value = dstArray; // ensure unique state
	
				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );
	
				for ( var i = 0; i !== lGlobal; ++ i ) {
	
					dstArray[ i ] = globalState[ i ];
	
				}
	
				cache.clippingState = dstArray;
				this.numPlanes += nGlobal;
	
			}
	
	
		};
	
		function resetGlobalState() {
	
			if ( uniform.value !== globalState ) {
	
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
	
			}
	
			scope.numPlanes = numGlobalPlanes;
	
		}
	
		function projectPlanes( planes, camera, dstOffset, skipTransform ) {
	
			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;
	
			if ( nPlanes !== 0 ) {
	
				dstArray = uniform.value;
	
				if ( skipTransform !== true || dstArray === null ) {
	
					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;
	
					viewNormalMatrix.getNormalMatrix( viewMatrix );
	
					if ( dstArray === null || dstArray.length < flatSize ) {
	
						dstArray = new Float32Array( flatSize );
	
					}
	
					for ( var i = 0, i4 = dstOffset;
										i !== nPlanes; ++ i, i4 += 4 ) {
	
						plane.copy( planes[ i ] ).
								applyMatrix4( viewMatrix, viewNormalMatrix );
	
						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;
	
					}
	
				}
	
				uniform.value = dstArray;
				uniform.needsUpdate = true;
	
			}
	
			scope.numPlanes = nPlanes;
			return dstArray;
	
		}
	
	};
	
	
	// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		var type, size;
	
		function setIndex( index ) {
	
			if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {
	
				type = _gl.UNSIGNED_INT;
				size = 4;
	
			} else {
	
				type = _gl.UNSIGNED_SHORT;
				size = 2;
	
			}
	
		}
	
		function render( start, count ) {
	
			_gl.drawElements( mode, count, type, start * size );
	
			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;
	
		}
	
		function renderInstances( geometry, start, count ) {
	
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extension === null ) {
	
				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;
	
			}
	
			extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );
	
			_infoRender.calls ++;
			_infoRender.vertices += count * geometry.maxInstancedCount;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;
		}
	
		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	
	};
	
	// File:src/renderers/webgl/WebGLExtensions.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLExtensions = function ( gl ) {
	
		var extensions = {};
	
		this.get = function ( name ) {
	
			if ( extensions[ name ] !== undefined ) {
	
				return extensions[ name ];
	
			}
	
			var extension;
	
			switch ( name ) {
	
				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;
	
				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;
	
				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;
	
				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;
	
				case 'WEBGL_compressed_texture_etc1':
					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
					break;
	
				default:
					extension = gl.getExtension( name );
	
			}
	
			if ( extension === null ) {
	
				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
			}
	
			extensions[ name ] = extension;
	
			return extension;
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLCapabilities.js
	
	THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {
	
		var maxAnisotropy;
	
		function getMaxAnisotropy() {
	
			if ( maxAnisotropy !== undefined ) return maxAnisotropy;
	
			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
			if ( extension !== null ) {
	
				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	
			} else {
	
				maxAnisotropy = 0;
	
			}
	
			return maxAnisotropy;
	
		}
	
		function getMaxPrecision( precision ) {
	
			if ( precision === 'highp' ) {
	
				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {
	
					return 'highp';
	
				}
	
				precision = 'mediump';
	
			}
	
			if ( precision === 'mediump' ) {
	
				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {
	
					return 'mediump';
	
				}
	
			}
	
			return 'lowp';
	
		}
	
		this.getMaxAnisotropy = getMaxAnisotropy;
		this.getMaxPrecision = getMaxPrecision;
	
		this.precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;
	
		this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
		this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
	
		this.vertexTextures = this.maxVertexTextures > 0;
		this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
	
		var _maxPrecision = getMaxPrecision( this.precision );
	
		if ( _maxPrecision !== this.precision ) {
	
			console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
			this.precision = _maxPrecision;
	
		}
	
		if ( this.logarithmicDepthBuffer ) {
	
			this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );
	
		}
	
	};
	
	// File:src/renderers/webgl/WebGLGeometries.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLGeometries = function ( gl, properties, info ) {
	
		var geometries = {};
	
		function get( object ) {
	
			var geometry = object.geometry;
	
			if ( geometries[ geometry.id ] !== undefined ) {
	
				return geometries[ geometry.id ];
	
			}
	
			geometry.addEventListener( 'dispose', onGeometryDispose );
	
			var buffergeometry;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				buffergeometry = geometry;
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				if ( geometry._bufferGeometry === undefined ) {
	
					geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );
	
				}
	
				buffergeometry = geometry._bufferGeometry;
	
			}
	
			geometries[ geometry.id ] = buffergeometry;
	
			info.memory.geometries ++;
	
			return buffergeometry;
	
		}
	
		function onGeometryDispose( event ) {
	
			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];
	
			if ( buffergeometry.index !== null ) {
	
				deleteAttribute( buffergeometry.index );
	
			}
	
			deleteAttributes( buffergeometry.attributes );
	
			geometry.removeEventListener( 'dispose', onGeometryDispose );
	
			delete geometries[ geometry.id ];
	
			// TODO
	
			var property = properties.get( geometry );
	
			if ( property.wireframe ) {
	
				deleteAttribute( property.wireframe );
	
			}
	
			properties.delete( geometry );
	
			var bufferproperty = properties.get( buffergeometry );
	
			if ( bufferproperty.wireframe ) {
	
				deleteAttribute( bufferproperty.wireframe );
	
			}
	
			properties.delete( buffergeometry );
	
			//
	
			info.memory.geometries --;
	
		}
	
		function getAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				return properties.get( attribute.data ).__webglBuffer;
	
			}
	
			return properties.get( attribute ).__webglBuffer;
	
		}
	
		function deleteAttribute( attribute ) {
	
			var buffer = getAttributeBuffer( attribute );
	
			if ( buffer !== undefined ) {
	
				gl.deleteBuffer( buffer );
				removeAttributeBuffer( attribute );
	
			}
	
		}
	
		function deleteAttributes( attributes ) {
	
			for ( var name in attributes ) {
	
				deleteAttribute( attributes[ name ] );
	
			}
	
		}
	
		function removeAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				properties.delete( attribute.data );
	
			} else {
	
				properties.delete( attribute );
	
			}
	
		}
	
		this.get = get;
	
	};
	
	// File:src/renderers/webgl/WebGLLights.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLLights = function () {
	
		var lights = {};
	
		this.get = function ( light ) {
	
			if ( lights[ light.id ] !== undefined ) {
	
				return lights[ light.id ];
	
			}
	
			var uniforms;
	
			switch ( light.type ) {
	
				case 'DirectionalLight':
					uniforms = {
						direction: new THREE.Vector3(),
						color: new THREE.Color(),
	
						shadow: false,
						shadowBias: 0,
						spreadAngle: 0,
						shadowMapSize: new THREE.Vector2(),
						shadowCameraParams: new THREE.Vector3()
					};
					break;
	
				case 'SpotLight':
					uniforms = {
						position: new THREE.Vector3(),
						direction: new THREE.Vector3(),
						color: new THREE.Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0,
	
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2(),
						shadowCameraFovNearFar: new THREE.Vector3(),
						shadowCameraParams: new THREE.Vector3()
					};
					break;
	
				case 'PointLight':
					uniforms = {
						position: new THREE.Vector3(),
						color: new THREE.Color(),
						distance: 0,
						decay: 0,
	
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;
	
				case 'HemisphereLight':
					uniforms = {
						direction: new THREE.Vector3(),
						skyColor: new THREE.Color(),
						groundColor: new THREE.Color()
					};
					break;
	
			}
	
			lights[ light.id ] = uniforms;
	
			return uniforms;
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLObjects.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLObjects = function ( gl, properties, info ) {
	
		var geometries = new THREE.WebGLGeometries( gl, properties, info );
	
		//
	
		function update( object ) {
	
			// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
	
			var geometry = geometries.get( object );
	
			if ( object.geometry instanceof THREE.Geometry ) {
	
				geometry.updateFromObject( object );
	
			}
	
			var index = geometry.index;
			var attributes = geometry.attributes;
	
			if ( index !== null ) {
	
				updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );
	
			}
	
			for ( var name in attributes ) {
	
				updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );
	
			}
	
			// morph targets
	
			var morphAttributes = geometry.morphAttributes;
	
			for ( var name in morphAttributes ) {
	
				var array = morphAttributes[ name ];
	
				for ( var i = 0, l = array.length; i < l; i ++ ) {
	
					updateAttribute( array[ i ], gl.ARRAY_BUFFER );
	
				}
	
			}
	
			return geometry;
	
		}
	
		function updateAttribute( attribute, bufferType ) {
	
			var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;
	
			var attributeProperties = properties.get( data );
	
			if ( attributeProperties.__webglBuffer === undefined ) {
	
				createBuffer( attributeProperties, data, bufferType );
	
			} else if ( attributeProperties.version !== data.version ) {
	
				updateBuffer( attributeProperties, data, bufferType );
	
			}
	
		}
	
		function createBuffer( attributeProperties, data, bufferType ) {
	
			attributeProperties.__webglBuffer = gl.createBuffer();
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
			var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	
			gl.bufferData( bufferType, data.array, usage );
	
			attributeProperties.version = data.version;
	
		}
	
		function updateBuffer( attributeProperties, data, bufferType ) {
	
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
			if ( data.dynamic === false || data.updateRange.count === - 1 ) {
	
				// Not using update ranges
	
				gl.bufferSubData( bufferType, 0, data.array );
	
			} else if ( data.updateRange.count === 0 ) {
	
				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
	
			} else {
	
				gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
								  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );
	
				data.updateRange.count = 0; // reset range
	
			}
	
			attributeProperties.version = data.version;
	
		}
	
		function getAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				return properties.get( attribute.data ).__webglBuffer;
	
			}
	
			return properties.get( attribute ).__webglBuffer;
	
		}
	
		function getWireframeAttribute( geometry ) {
	
			var property = properties.get( geometry );
	
			if ( property.wireframe !== undefined ) {
	
				return property.wireframe;
	
			}
	
			var indices = [];
	
			var index = geometry.index;
			var attributes = geometry.attributes;
			var position = attributes.position;
	
			// console.time( 'wireframe' );
	
			if ( index !== null ) {
	
				var edges = {};
				var array = index.array;
	
				for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];
	
					if ( checkEdge( edges, a, b ) ) indices.push( a, b );
					if ( checkEdge( edges, b, c ) ) indices.push( b, c );
					if ( checkEdge( edges, c, a ) ) indices.push( c, a );
	
				}
	
			} else {
	
				var array = attributes.position.array;
	
				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
	
					var a = i + 0;
					var b = i + 1;
					var c = i + 2;
	
					indices.push( a, b, b, c, c, a );
	
				}
	
			}
	
			// console.timeEnd( 'wireframe' );
	
			var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
			var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );
	
			updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );
	
			property.wireframe = attribute;
	
			return attribute;
	
		}
	
		function checkEdge( edges, a, b ) {
	
			if ( a > b ) {
	
				var tmp = a;
				a = b;
				b = tmp;
	
			}
	
			var list = edges[ a ];
	
			if ( list === undefined ) {
	
				edges[ a ] = [ b ];
				return true;
	
			} else if ( list.indexOf( b ) === -1 ) {
	
				list.push( b );
				return true;
	
			}
	
			return false;
	
		}
	
		this.getAttributeBuffer = getAttributeBuffer;
		this.getWireframeAttribute = getWireframeAttribute;
	
		this.update = update;
	
	};
	
	// File:src/renderers/webgl/WebGLProgram.js
	
	THREE.WebGLProgram = ( function () {
	
		var programIdCount = 0;
	
		function getEncodingComponents( encoding ) {
	
			switch ( encoding ) {
	
				case THREE.LinearEncoding:
					return [ 'Linear','( value )' ];
				case THREE.sRGBEncoding:
					return [ 'sRGB','( value )' ];
				case THREE.RGBEEncoding:
					return [ 'RGBE','( value )' ];
				case THREE.RGBM7Encoding:
					return [ 'RGBM','( value, 7.0 )' ];
				case THREE.RGBM16Encoding:
					return [ 'RGBM','( value, 16.0 )' ];
				case THREE.RGBDEncoding:
					return [ 'RGBD','( value, 256.0 )' ];
				case THREE.GammaEncoding:
					return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
				default:
					throw new Error( 'unsupported encoding: ' + encoding );
	
			}
	
		}
	
		function getTexelDecodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";
	
		}
	
		function getTexelEncodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";
	
		}
	
		function getTexelTransformFunction( mapName, map ) {
	
			if( ! map || ! map.texelTransform ) {
				return "vec4 " + mapName + "TexelTransform( vec4 value ) { return value; }\n";
			}
	
			var transform = map.getFlattenedTexelTransform();
			var template = THREE.ShaderChunk[ 'slot_texel_transform_template' ];
			var result = template.replace( /\$SLOT_NAME\$/g, mapName );
			return result;
	
		}
	
		function getUVFunction( mapName, map, isVertexShader ) {
	
			var uvVariableName = ( isVertexShader ) ? "uv" : "vUv";
			if( map && map.uvChannel > 0 ) {
				uvVariableName += ( map.uvChannel + 1 );
			}
	
			if( ! map || ! map.uvTransform ) {
				return "vec2 " + mapName + "UV() { return " + uvVariableName + "; }\n";
			}
	
			var transform = map.getFlattenedTexelTransform();
			var template = THREE.ShaderChunk[ 'slot_uv_transform_template' ];
			var result = template.replace( /\$SLOT_NAME\$/g, mapName );
			result = result.replace( /\$UV_VAR_NAME\$/g, uvVariableName );
			return result;
	
		}
	
		function getToneMappingFunction( functionName, toneMapping ) {
	
			var toneMappingName;
	
			switch ( toneMapping ) {
	
				case THREE.LinearToneMapping:
					toneMappingName = "Linear";
					break;
	
				case THREE.ReinhardToneMapping:
					toneMappingName = "Reinhard";
					break;
	
				case THREE.Uncharted2ToneMapping:
					toneMappingName = "Uncharted2";
					break;
	
				case THREE.CineonToneMapping:
					toneMappingName = "OptimizedCineon";
					break;
	
				default:
					throw new Error( 'unsupported toneMapping: ' + toneMapping );
	
			}
	
			return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
	
		}
	
		function generateExtensions( extensions, parameters, rendererExtensions ) {
	
			extensions = extensions || {};
	
			var chunks = [
				( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
			];
	
			return chunks.filter( filterEmptyLine ).join( '\n' );
	
		}
	
		function generateDefines( defines ) {
	
			var chunks = [];
	
			for ( var name in defines ) {
	
				var value = defines[ name ];
	
				if ( value === false ) continue;
	
				chunks.push( '#define ' + name + ' ' + value );
	
			}
	
			return chunks.join( '\n' );
	
		}
	
		function fetchAttributeLocations( gl, program, identifiers ) {
	
			var attributes = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveAttrib( program, i );
				var name = info.name;
	
				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
	
				attributes[ name ] = gl.getAttribLocation( program, name );
	
			}
	
			return attributes;
	
		}
	
		function filterEmptyLine( string ) {
	
			return string !== '';
	
		}
	
		function replaceLightNums( string, parameters ) {
	
			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
	
		}
	
		function parseIncludes( string ) {
	
			var pattern = /#include +<([\w\d.]+)>/g;
	
			function replace( match, include ) {
	
				var replace = THREE.ShaderChunk[ include ];
	
				if ( replace === undefined ) {
	
					throw new Error( 'Can not resolve #include <' + include + '>' );
	
				}
	
				return parseIncludes( replace );
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		function unrollLoops( string ) {
	
			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	
			function replace( match, start, end, snippet ) {
	
				var unroll = '';
	
				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
	
					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
	
				}
	
				return unroll;
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		return function WebGLProgram( renderer, code, material, parameters ) {
	
			var gl = renderer.context;
	
			var extensions = material.extensions;
			var defines = material.defines;
	
			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;
	
			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
			} else if ( parameters.shadowMapType === THREE.PCSSSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCSS';
	
			}
	
			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
			if ( parameters.envMap ) {
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;
	
					case THREE.CubeUVReflectionMapping:
					case THREE.CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;
	
					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;
	
					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;
	
				}
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;
	
				}
	
				switch ( material.combine ) {
	
					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;
	
					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;
	
					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;
	
				}
	
			}
	
			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
			// console.log( 'building new program ' );
	
			//
	
			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );
	
			var customDefines = generateDefines( defines );
	
			//
	
			var program = gl.createProgram();
	
			var prefixVertex, prefixFragment;
	
			if ( material instanceof THREE.RawShaderMaterial ) {
	
				prefixVertex = [
	
					customDefines
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customDefines
	
				].filter( filterEmptyLine ).join( '\n' );
	
			} else {
	
				prefixVertex = [
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					'#define MAX_BONES ' + parameters.maxBones,
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
					parameters.falloffMap && parameters.falloff ? '#define USE_FALLOFFMAP' : '',
					parameters.falloffAlphaMap && parameters.falloff ? '#define USE_FALLOFFALPHAMAP' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
	
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
	
					'#ifdef USE_COLOR',
	
					'	attribute vec3 color;',
	
					'#endif',
	
					'#ifdef USE_MORPHTARGETS',
	
					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',
	
					'	#ifdef USE_MORPHNORMALS',
	
					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',
	
					'	#else',
	
					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',
	
					'	#endif',
	
					'#endif',
	
					'#ifdef USE_SKINNING',
	
					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',
	
					'#endif',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customExtensions,
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.falloff ? '#define FALLOFF' : '',
					parameters.falloffMap && parameters.falloff ? '#define USE_FALLOFFMAP' : '',
					parameters.falloffAlphaMap && parameters.falloff ? '#define USE_FALLOFFALPHAMAP' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',
	
					parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',
	
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
	
					( parameters.toneMapping !== THREE.NoToneMapping ) ? "#define TONE_MAPPING" : '',
					( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
					( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',
	
					( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.falloffMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
					parameters.falloffMapEncoding ? getTexelDecodingFunction( 'falloffMapTexelToLinear', parameters.falloffMapEncoding ) : '',
					parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',
	
					parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
			}
	
	
			var supportedMapNames = THREE.Map.SupportedMapNames;
	
			var mapUVChannelsCode = "";
			var mapTexelTransformCode = "";
			var mapUvChannels = {};
			for( var i = 0; i < supportedMapNames.length; i ++ ) {
				var mapName = supportedMapNames[i];
				var map = material[ mapName + 'Slot' ];
				if( material[ mapName ] || ( map && map.texture ) ) {
					if( map && ! mapUvChannels[ map.uvChannel ]) mapUvChannels[ map.uvChannel ] = true;
					mapTexelTransformCode += getTexelTransformFunction( mapName, map );
					mapUVChannelsCode += "uniform sampler2D " + mapName + ";\n";
					mapUVChannelsCode += getUVFunction( mapName, map, false );
				}
			}
			if( Object.keys( mapUvChannels ).length > 0 ) {
				var mapUVPrefix = "";
				mapUVPrefix += "#define TEXTURE_SLOTS\n";
				for( var uvChannel in mapUvChannels ) {
					uvChannel = parseInt( uvChannel );
					var uvChannelName = "vUv";
					if( uvChannel > 0 ) uvChannelName += '' + ( uvChannel + 1 );
					mapUVPrefix += "varying vec2 " + uvChannelName + ";\n";
				}
				prefixFragment += mapUVPrefix + mapUVChannelsCode;
			}
			prefixFragment += mapTexelTransformCode;
	
			vertexShader = parseIncludes( vertexShader, parameters );
			vertexShader = replaceLightNums( vertexShader, parameters );
	
			fragmentShader = parseIncludes( fragmentShader, parameters );
			fragmentShader = replaceLightNums( fragmentShader, parameters );
	
			if ( material instanceof THREE.ShaderMaterial === false ) {
	
				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );
	
			}
	
			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;
	
			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );
	
			var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
	
			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );
	
			// Force a particular attribute to index 0.
	
			if ( material.index0AttributeName !== undefined ) {
	
				gl.bindAttribLocation( program, 0, material.index0AttributeName );
	
			} else if ( parameters.morphTargets === true ) {
	
				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );
	
			}
	
			gl.linkProgram( program );
	
			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );
	
			var runnable = true;
			var haveDiagnostics = true;
	
			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	
			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
	
				runnable = false;
	
				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	
			} else if ( programLog !== '' ) {
	
				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	
			} else if ( vertexLog === '' || fragmentLog === '' ) {
	
				haveDiagnostics = false;
	
			}
	
			if ( haveDiagnostics ) {
	
				this.diagnostics = {
	
					runnable: runnable,
					material: material,
	
					programLog: programLog,
	
					vertexShader: {
	
						log: vertexLog,
						prefix: prefixVertex
	
					},
	
					fragmentShader: {
	
						log: fragmentLog,
						prefix: prefixFragment
	
					}
	
				};
	
			}
	
			// clean up
	
			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );
	
			// set up caching for uniform locations
	
			var cachedUniforms;
	
			this.getUniforms = function() {
	
				if ( cachedUniforms === undefined ) {
	
					cachedUniforms =
							new THREE.WebGLUniforms( gl, program, renderer );
	
				}
	
				return cachedUniforms;
	
			};
	
			// set up caching for attribute locations
	
			var cachedAttributes;
	
			this.getAttributes = function() {
	
				if ( cachedAttributes === undefined ) {
	
					cachedAttributes = fetchAttributeLocations( gl, program );
	
				}
	
				return cachedAttributes;
	
			};
	
			// free resource
	
			this.destroy = function() {
	
				gl.deleteProgram( program );
				this.program = undefined;
	
			};
	
			// DEPRECATED
	
			Object.defineProperties( this, {
	
				uniforms: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();
	
					}
				},
	
				attributes: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();
	
					}
				}
	
			} );
	
	
			//
	
			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;
	
			return this;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLPrograms.js
	
	THREE.WebGLPrograms = function ( renderer, capabilities ) {
	
		var programs = [];
	
		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshCubeMaterial: 'cube',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points'
		};
	
		var parameterNames = [
			"precision", "supportsVertexTextures", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
			"emissiveMapEncoding",
			"combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking", 'falloff', 'falloffMap', 'falloffAlphaMap'
		];
	
		var supportedMaps = THREE.Map.SupportedMapNames;
		for( var i = 0; i < supportedMaps.length; i ++ ) {
			var name = supportedMaps[i];
			parameterNames.push( name );
			parameterNames.push( name + 'UVChannel' );
			parameterNames.push( name + 'UVTransform' );
			parameterNames.push( name + 'TexelTransform' );
		}
	
		function allocateBones ( object ) {
	
			if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {
	
				return 1024;
	
			} else {
	
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)
	
				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
				var maxBones = nVertexMatrices;
	
				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {
	
					maxBones = Math.min( object.skeleton.bones.length, maxBones );
	
					if ( maxBones < object.skeleton.bones.length ) {
	
						console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );
	
					}
	
				}
	
				return maxBones;
	
			}
	
		}
	
		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {
	
			var encoding;
	
			if ( ! map ) {
	
				encoding = THREE.LinearEncoding;
	
			} else if ( map instanceof THREE.Texture ) {
	
				encoding = map.encoding;
	
			} else if ( map instanceof THREE.WebGLRenderTarget ) {
	
				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;
	
			}
	
			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {
	
				encoding = THREE.GammaEncoding;
	
			}
	
			return encoding;
	
		}
	
		this.getParameters = function ( material, lights, fog, nClipPlanes, object ) {
	
			var shaderID = shaderIDs[ material.type ];
	
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
	
			var maxBones = allocateBones( object );
			var precision = renderer.getPrecision();
	
			if ( material.precision !== null ) {
	
				precision = capabilities.getMaxPrecision( material.precision );
	
				if ( precision !== material.precision ) {
	
					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
	
				}
	
			}
	
			var currentRenderTarget = renderer.getCurrentRenderTarget();
	
			var parameters = {
	
				shaderID: shaderID,
	
				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
				envMap: !!material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
				envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
	
				falloff: material.falloff,
				falloffMap: material.falloffMap,
				falloffMapEncoding: getTextureEncodingFromMap( material.falloffMap, renderer.gammaInput ),
				falloffAlphaMap: material.falloffAlphaMap,
	
				combine: material.combine,
	
				vertexColors: material.vertexColors,
	
				fog: !! fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,
	
				flatShading: material.shading === THREE.FlatShading,
	
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	
				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
	
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,
	
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numHemiLights: lights.hemi.length,
	
				numClippingPlanes: nClipPlanes,
	
				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
	
				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,
	
				premultipliedAlpha: material.premultipliedAlpha,
	
				alphaTest: material.alphaTest,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide,
	
				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false
	
			};
	
			var supportedMapNames = THREE.Map.SupportedMapNames;
	
			for( var i = 0; i < supportedMapNames.length; i ++ ) {
				var mapName = supportedMapNames[i];
				var mapSlotName = THREE.Map.SupportedMapSlotNames[i];
				// backwards compatibility
				parameters[mapName] = !! material[ mapName ];
	
				// new functional for slot-based maps
				var map = material[ mapSlotName ];
				parameters[mapName + "UVChannel" ] = ( map !== undefined ) ? map.uvChannel : 0;
				parameters[mapName + "UVTransform" ] = ( map !== undefined ) ? map.uvTransform : false;
				parameters[mapName + "TexelTransform" ] = ( map !== undefined ) ? map.texelTransform : false;
			}
	
			return parameters;
	
		};
	
		this.getProgramCode = function ( material, parameters ) {
	
			var array = [];
	
			if ( parameters.shaderID ) {
	
				array.push( parameters.shaderID );
	
			} else {
	
				array.push( material.fragmentShader );
				array.push( material.vertexShader );
	
			}
	
			if ( material.defines !== undefined ) {
	
				for ( var name in material.defines ) {
	
					array.push( name );
					array.push( material.defines[ name ] );
	
				}
	
			}
	
			for ( var i = 0; i < parameterNames.length; i ++ ) {
	
				array.push( parameters[ parameterNames[ i ] ] );
	
			}
	
			return array.join();
	
		};
	
		this.acquireProgram = function ( material, parameters, code ) {
	
			var program;
	
			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
	
				var programInfo = programs[ p ];
	
				if ( programInfo.code === code ) {
	
					program = programInfo;
					++ program.usedTimes;
	
					break;
	
				}
	
			}
	
			if ( program === undefined ) {
	
				program = new THREE.WebGLProgram( renderer, code, material, parameters );
				programs.push( program );
	
			}
	
			return program;
	
		};
	
		this.releaseProgram = function( program ) {
	
			if ( -- program.usedTimes === 0 ) {
	
				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();
	
				// Free WebGL resources
				program.destroy();
	
			}
	
		};
	
		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;
	
	};
	
	// File:src/renderers/webgl/WebGLProperties.js
	
	/**
	* @author fordacious / fordacious.github.io
	*/
	
	THREE.WebGLProperties = function () {
	
		var properties = {};
	
		this.get = function ( object ) {
	
			var uuid = object.uuid;
			var map = properties[ uuid ];
	
			if ( map === undefined ) {
	
				map = {};
				properties[ uuid ] = map;
	
			}
	
			return map;
	
		};
	
		this.delete = function ( object ) {
	
			delete properties[ object.uuid ];
	
		};
	
		this.clear = function () {
	
			properties = {};
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLShader.js
	
	THREE.WebGLShader = ( function () {
	
		function addLineNumbers( string ) {
	
			var lines = string.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
			}
	
			return lines.join( '\n' );
	
		}
	
		return function WebGLShader( gl, type, string ) {
	
			var shader = gl.createShader( type );
	
			gl.shaderSource( shader, string );
			gl.compileShader( shader );
	
			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
	
				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
			return shader;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLShadowMap.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WebGLShadowMap = function ( _renderer, _lights, _objects, capabilities ) {
	
		var _gl = _renderer.context,
		_state = _renderer.state,
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),
	
		_lightShadows = _lights.shadows,
	
		_shadowMapSize = new THREE.Vector2(),
		_maxShadowMapSize = new THREE.Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),
	
		_lookTarget = new THREE.Vector3(),
		_lightPositionWorld = new THREE.Vector3(),
	
		_renderList = [],
	
		_MorphingFlag = 1,
		_SkinningFlag = 2,
	
		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
	
		_depthMaterials = new Array( _NumberOfMaterialVariants ),
		_distanceMaterials = new Array( _NumberOfMaterialVariants ),
	
		_materialCache = {};
	
		var cubeDirections = [
			new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
			new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
		];
	
		var cubeUps = [
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
		];
	
		var cube2DViewPorts = [
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
		];
	
		// init
	
		var depthMaterialTemplate = new THREE.MeshDepthMaterial();
		depthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;
		depthMaterialTemplate.clipping = true;
	
		var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
		var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );
	
		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
	
			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;
	
			var depthMaterial = depthMaterialTemplate.clone();
			depthMaterial.morphTargets = useMorphing;
			depthMaterial.skinning = useSkinning;
	
			_depthMaterials[ i ] = depthMaterial;
	
			var distanceMaterial = new THREE.ShaderMaterial( {
				defines: {
					'USE_SHADOWMAP': ''
				},
				uniforms: distanceUniforms,
				vertexShader: distanceShader.vertexShader,
				fragmentShader: distanceShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning,
				clipping: true
			} );
	
			_distanceMaterials[ i ] = distanceMaterial;
	
		}
	
		//
	
		var scope = this;
	
		this.enabled = false;
	
		this.autoUpdate = true;
		this.needsUpdate = false;
	
		this.type = THREE.PCFShadowMap;
	
		this.renderReverseSided = true;
		this.renderSingleSided = true;
	
		this.render = function ( scene, camera ) {
	
			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
	
			if ( _lightShadows.length === 0 ) return;
	
			// Set GL state for depth map.
			_state.clearColor( 1, 1, 1, 1 );
			_state.disable( _gl.BLEND );
			_state.setDepthTest( true );
			_state.setScissorTest( false );
	
			// render depth map
	
			var faceCount, isPointLight;
	
			for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {
	
				var light = _lightShadows[ i ];
				var shadow = light.shadow;
	
				if ( shadow === undefined ) {
	
					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;
	
				}
	
				var shadowCamera = shadow.camera;
	
				_shadowMapSize.copy( shadow.mapSize );
				_shadowMapSize.min( _maxShadowMapSize );
	
				if ( light instanceof THREE.PointLight ) {
	
					faceCount = 6;
					isPointLight = true;
	
					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;
	
					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction
	
					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
	
					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;
	
				} else {
	
					faceCount = 1;
					isPointLight = false;
	
				}
	
				if ( shadow.map === null ) {
	
					var pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };
	
					shadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
	
					shadowCamera.updateProjectionMatrix();
	
				}
	
				if ( shadow instanceof THREE.SpotLightShadow || shadow instanceof THREE.DirectionalLightShadow ) {
	
					shadow.update( light );
	
				}
	
				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;
	
				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );
	
				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();
	
				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not
	
				for ( var face = 0; face < faceCount; face ++ ) {
	
					if ( isPointLight ) {
	
						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
	
						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );
	
					} else {
	
						_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
						shadowCamera.lookAt( _lookTarget );
	
					}
	
					shadowCamera.updateMatrixWorld();
					shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
					// compute shadow matrix
	
					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);
	
					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
					// update camera matrices and frustum
	
					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );
	
					// set object matrices & frustum culling
	
					_renderList.length = 0;
	
					projectObject( scene, camera, shadowCamera );
	
					// render shadow map
					// render regular objects
	
					for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {
	
						var object = _renderList[ j ];
						var geometry = _objects.update( object );
						var material = object.material;
	
						if ( material instanceof THREE.MultiMaterial ) {
	
							var groups = geometry.groups;
							var materials = material.materials;
	
							for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
	
								var group = groups[ k ];
								var groupMaterial = materials[ group.materialIndex ];
	
								if ( groupMaterial.visible === true ) {
	
									var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
									_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
	
								}
	
							}
	
						} else {
	
							var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
	
						}
	
					}
	
				}
	
			}
	
			// Restore GL state.
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
			_renderer.setClearColor( clearColor, clearAlpha );
	
			scope.needsUpdate = false;
	
		};
	
		function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {
	
			var geometry = object.geometry;
	
			var result = null;
	
			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;
	
			if ( isPointLight ) {
	
				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;
	
			}
	
			if ( ! customMaterial ) {
	
				var useMorphing = false;
	
				if ( material.morphTargets ) {
	
					if ( geometry instanceof THREE.BufferGeometry ) {
	
						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
	
					} else if ( geometry instanceof THREE.Geometry ) {
	
						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
	
					}
	
				}
	
				var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;
	
				var variantIndex = 0;
	
				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;
	
				result = materialVariants[ variantIndex ];
	
			} else {
	
				result = customMaterial;
	
			}
	
			if ( _renderer.localClippingEnabled &&
				 material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {
	
				// in this case we need a unique material instance reflecting the
				// appropriate state
	
				var keyA = result.uuid, keyB = material.uuid;
	
				var materialsForVariant = _materialCache[ keyA ];
	
				if ( materialsForVariant === undefined ) {
	
					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;
	
				}
	
				var cachedMaterial = materialsForVariant[ keyB ];
	
				if ( cachedMaterial === undefined ) {
	
					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;
	
				}
	
				result = cachedMaterial;
	
			}
	
			result.visible = material.visible;
			result.wireframe = material.wireframe;
	
			var side = material.side;
	
			if ( scope.renderSingleSided && side == THREE.DoubleSide ) {
	
				side = THREE.FrontSide;
	
			}
	
			if ( scope.renderReverseSided ) {
	
				if ( side === THREE.FrontSide ) side = THREE.BackSide;
				else if ( side === THREE.BackSide ) side = THREE.FrontSide;
	
			}
	
			result.side = side;
	
			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
	
			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;
	
			if ( isPointLight && result.uniforms.lightPos !== undefined ) {
	
				result.uniforms.lightPos.value.copy( lightPositionWorld );
	
			}
	
			return result;
	
		}
	
		function projectObject( object, camera, shadowCamera ) {
	
			if ( object.visible === false ) return;
	
			if ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {
	
				if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {
	
					var material = object.material;
	
					if ( material.visible === true ) {
	
						object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( object );
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				projectObject( children[ i ], camera, shadowCamera );
	
			}
	
		}
	
	};
	
	// File:src/renderers/webgl/WebGLState.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {
	
		var _this = this;
	
		this.buffers = {
			color: new THREE.WebGLColorBuffer( gl, this ),
			depth: new THREE.WebGLDepthBuffer( gl, this ),
			stencil: new THREE.WebGLStencilBuffer( gl, this )
		};
	
		var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );
	
		var capabilities = {};
	
		var compressedTextureFormats = null;
	
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;
	
		var currentFlipSided = null;
		var currentCullFace = null;
	
		var currentLineWidth = null;
	
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;
	
		var currentScissorTest = null;
	
		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	
		var currentTextureSlot = null;
		var currentBoundTextures = {};
	
		var currentScissor = new THREE.Vector4();
		var currentViewport = new THREE.Vector4();
	
		function createTexture( type, target, count ) {
	
			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();
	
			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
	
			for ( var i = 0; i < count; i ++ ) {
	
				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );
	
			}
	
			return texture;
	
		}
	
		var emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
	
		//
	
		this.init = function () {
	
			this.clearColor( 0, 0, 0, 1 );
			this.clearDepth( 1 );
			this.clearStencil( 0 );
	
			this.enable( gl.DEPTH_TEST );
			this.setDepthFunc( THREE.LessEqualDepth );
	
			this.setFlipSided( false );
			this.setCullFace( THREE.CullFaceBack );
			this.enable( gl.CULL_FACE );
	
			this.enable( gl.BLEND );
			this.setBlending( THREE.NormalBlending );
	
		};
	
		this.initAttributes = function () {
	
			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
				newAttributes[ i ] = 0;
	
			}
	
		};
	
		this.enableAttribute = function ( attribute ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
			if ( attributeDivisors[ attribute ] !== 0 ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				extension.vertexAttribDivisorANGLE( attribute, 0 );
				attributeDivisors[ attribute ] = 0;
	
			}
	
		};
	
		this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
	
				extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;
	
			}
	
		};
	
		this.disableUnusedAttributes = function () {
	
			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {
	
				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
		};
	
		this.enable = function ( id ) {
	
			if ( capabilities[ id ] !== true ) {
	
				gl.enable( id );
				capabilities[ id ] = true;
	
			}
	
		};
	
		this.disable = function ( id ) {
	
			if ( capabilities[ id ] !== false ) {
	
				gl.disable( id );
				capabilities[ id ] = false;
	
			}
	
		};
	
		this.getCompressedTextureFormats = function () {
	
			if ( compressedTextureFormats === null ) {
	
				compressedTextureFormats = [];
	
				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {
	
					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
	
					for ( var i = 0; i < formats.length; i ++ ) {
	
						compressedTextureFormats.push( formats[ i ] );
	
					}
	
				}
	
			}
	
			return compressedTextureFormats;
	
		};
	
		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
	
			if ( blending !== THREE.NoBlending ) {
	
				this.enable( gl.BLEND );
	
			} else {
	
				this.disable( gl.BLEND );
				currentBlending = blending; // no blending, that is
				return;
	
			}
	
			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {
	
				if ( blending === THREE.AdditiveBlending ) {
	
					if ( premultipliedAlpha ) {
	
						gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
						gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );
	
					} else {
	
						gl.blendEquation( gl.FUNC_ADD );
						gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
	
					}
	
				} else if ( blending === THREE.SubtractiveBlending ) {
	
					if ( premultipliedAlpha ) {
	
						gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
						gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
	
					} else {
	
						gl.blendEquation( gl.FUNC_ADD );
						gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
	
					}
	
				} else if ( blending === THREE.MultiplyBlending ) {
	
					if ( premultipliedAlpha ) {
	
						gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
						gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
	
					} else {
	
						gl.blendEquation( gl.FUNC_ADD );
						gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
	
					}
	
				} else {
	
					if ( premultipliedAlpha ) {
	
						gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
						gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
					} else {
	
						gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
						gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
					}
	
				}
	
				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;
	
			}
	
			if ( blending === THREE.CustomBlending ) {
	
				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;
	
				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );
	
					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;
					console.log("setting custom blend state", blendEquation, blendEquationAlpha );
				}
	
				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
					console.log("setting custom blend state", blendSrc, blendDst, blendSrcAlpha, blendDstAlpha );
	
					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;
	
				}
	
			} else {
	
				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
	
			}
	
		};
	
		// TODO Deprecate
	
		this.setColorWrite = function ( colorWrite ) {
	
			this.buffers.color.setMask( colorWrite );
	
		};
	
		this.setDepthTest = function ( depthTest ) {
	
			this.buffers.depth.setTest( depthTest );
	
		};
	
		this.setDepthWrite = function ( depthWrite ) {
	
			this.buffers.depth.setMask( depthWrite );
	
		};
	
		this.setDepthFunc = function ( depthFunc ) {
	
			this.buffers.depth.setFunc( depthFunc );
	
		};
	
		this.setStencilTest = function ( stencilTest ) {
	
			this.buffers.stencil.setTest( stencilTest );
	
		};
	
		this.setStencilWrite = function ( stencilWrite ) {
	
			this.buffers.stencil.setMask( stencilWrite );
	
		};
	
		this.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {
	
			this.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );
	
		};
	
		this.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {
	
			this.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );
	
		};
	
		//
	
		this.setFlipSided = function ( flipSided ) {
	
			if ( currentFlipSided !== flipSided ) {
	
				if ( flipSided ) {
	
					gl.frontFace( gl.CW );
	
				} else {
	
					gl.frontFace( gl.CCW );
	
				}
	
				currentFlipSided = flipSided;
	
			}
	
		};
	
		this.setCullFace = function ( cullFace ) {
	
			if ( cullFace !== THREE.CullFaceNone ) {
	
				this.enable( gl.CULL_FACE );
	
				if ( cullFace !== currentCullFace ) {
	
					if ( cullFace === THREE.CullFaceBack ) {
	
						gl.cullFace( gl.BACK );
	
					} else if ( cullFace === THREE.CullFaceFront ) {
	
						gl.cullFace( gl.FRONT );
	
					} else {
	
						gl.cullFace( gl.FRONT_AND_BACK );
	
					}
	
				}
	
			} else {
	
				this.disable( gl.CULL_FACE );
	
			}
	
			currentCullFace = cullFace;
	
		};
	
		this.setLineWidth = function ( width ) {
	
			if ( width !== currentLineWidth ) {
	
				gl.lineWidth( width );
	
				currentLineWidth = width;
	
			}
	
		};
	
		this.setPolygonOffset = function ( polygonOffset, factor, units ) {
	
			if ( polygonOffset ) {
	
				this.enable( gl.POLYGON_OFFSET_FILL );
	
				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
	
					gl.polygonOffset( factor, units );
	
					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
	
				}
	
			} else {
	
				this.disable( gl.POLYGON_OFFSET_FILL );
	
			}
	
		};
	
		this.getScissorTest = function () {
	
			return currentScissorTest;
	
		};
	
		this.setScissorTest = function ( scissorTest ) {
	
			currentScissorTest = scissorTest;
	
			if ( scissorTest ) {
	
				this.enable( gl.SCISSOR_TEST );
	
			} else {
	
				this.disable( gl.SCISSOR_TEST );
	
			}
	
		};
	
		// texture
	
		this.activeTexture = function ( webglSlot ) {
	
			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
	
			if ( currentTextureSlot !== webglSlot ) {
	
				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;
	
			}
	
		};
	
		this.bindTexture = function ( webglType, webglTexture ) {
	
			if ( currentTextureSlot === null ) {
	
				_this.activeTexture();
	
			}
	
			var boundTexture = currentBoundTextures[ currentTextureSlot ];
	
			if ( boundTexture === undefined ) {
	
				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;
	
			}
	
			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
	
				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
	
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
	
			}
	
		};
	
		this.compressedTexImage2D = function () {
	
			try {
	
				gl.compressedTexImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
		};
	
		this.texImage2D = function () {
	
			try {
	
				gl.texImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
		};
	
		// TODO Deprecate
	
		this.clearColor = function ( r, g, b, a ) {
	
			this.buffers.color.setClear( r, g, b, a );
	
		};
	
		this.clearDepth = function ( depth ) {
	
			this.buffers.depth.setClear( depth );
	
		};
	
		this.clearStencil = function ( stencil ) {
	
			this.buffers.stencil.setClear( stencil );
	
		};
	
		//
	
		this.scissor = function ( scissor ) {
	
			if ( currentScissor.equals( scissor ) === false ) {
	
				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );
	
			}
	
		};
	
		this.viewport = function ( viewport ) {
	
			if ( currentViewport.equals( viewport ) === false ) {
	
				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );
	
			}
	
		};
	
		//
	
		this.reset = function () {
	
			for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
				if ( enabledAttributes[ i ] === 1 ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
			capabilities = {};
	
			compressedTextureFormats = null;
	
			currentTextureSlot = null;
			currentBoundTextures = {};
	
			currentBlending = null;
	
			currentFlipSided = null;
			currentCullFace = null;
	
			this.buffers.color.reset();
			this.buffers.depth.reset();
			this.buffers.stencil.reset();
	
		};
	
	};
	
	THREE.WebGLColorBuffer = function ( gl, state ) {
	
		var locked = false;
	
		var color = new THREE.Vector4();
		var currentColorMask = null;
		var currentColorClear = new THREE.Vector4();
	
		this.setMask = function ( colorMask ) {
	
			if ( currentColorMask !== colorMask && ! locked ) {
	
				gl.colorMask( colorMask, colorMask, colorMask, colorMask );
				currentColorMask = colorMask;
	
			}
	
		};
	
		this.setLocked = function ( lock ) {
	
			locked = lock;
	
		};
	
		this.setClear = function ( r, g, b, a ) {
	
			color.set( r, g, b, a );
	
			if ( currentColorClear.equals( color ) === false ) {
	
				gl.clearColor( r, g, b, a );
				currentColorClear.copy( color );
	
			}
	
		};
	
		this.reset = function () {
	
			locked = false;
	
			currentColorMask = null;
			currentColorClear = new THREE.Vector4();
	
		};
	
	};
	
	THREE.WebGLDepthBuffer = function( gl, state ) {
	
		var locked = false;
	
		var currentDepthMask = null;
		var currentDepthFunc = null;
		var currentDepthClear = null;
	
		this.setTest = function ( depthTest ) {
	
			if ( depthTest ) {
	
				state.enable( gl.DEPTH_TEST );
	
			} else {
	
				state.disable( gl.DEPTH_TEST );
	
			}
	
		};
	
		this.setMask = function( depthMask ){
	
			if ( currentDepthMask !== depthMask && ! locked ) {
	
				gl.depthMask( depthMask );
				currentDepthMask = depthMask;
	
			}
	
		};
	
		this.setFunc = function ( depthFunc ) {
	
			if ( currentDepthFunc !== depthFunc ) {
	
				if ( depthFunc ) {
	
					switch ( depthFunc ) {
	
						case THREE.NeverDepth:
	
							gl.depthFunc( gl.NEVER );
							break;
	
						case THREE.AlwaysDepth:
	
							gl.depthFunc( gl.ALWAYS );
							break;
	
						case THREE.LessDepth:
	
							gl.depthFunc( gl.LESS );
							break;
	
						case THREE.LessEqualDepth:
	
							gl.depthFunc( gl.LEQUAL );
							break;
	
						case THREE.EqualDepth:
	
							gl.depthFunc( gl.EQUAL );
							break;
	
						case THREE.GreaterEqualDepth:
	
							gl.depthFunc( gl.GEQUAL );
							break;
	
						case THREE.GreaterDepth:
	
							gl.depthFunc( gl.GREATER );
							break;
	
						case THREE.NotEqualDepth:
	
							gl.depthFunc( gl.NOTEQUAL );
							break;
	
						default:
	
							gl.depthFunc( gl.LEQUAL );
	
					}
	
				} else {
	
					gl.depthFunc( gl.LEQUAL );
	
				}
	
				currentDepthFunc = depthFunc;
	
			}
	
		};
	
		this.setLocked = function ( lock ) {
	
			locked = lock;
	
		};
	
		this.setClear = function ( depth ) {
	
			if ( currentDepthClear !== depth ) {
	
				gl.clearDepth( depth );
				currentDepthClear = depth;
	
			}
	
		};
	
		this.reset = function () {
	
			locked = false;
	
			currentDepthMask = null;
			currentDepthFunc = null;
			currentDepthClear = null;
	
		};
	
	};
	
	THREE.WebGLStencilBuffer = function ( gl, state ) {
	
		var locked = false;
	
		var currentStencilMask = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilFuncMask = null;
		var currentStencilFail  = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
		var currentStencilClear = null;
	
		this.setTest = function ( stencilTest ) {
	
			if ( stencilTest ) {
	
				state.enable( gl.STENCIL_TEST );
	
			} else {
	
				state.disable( gl.STENCIL_TEST );
	
			}
	
		};
	
		this.setMask = function ( stencilMask ) {
	
			if ( currentStencilMask !== stencilMask && ! locked ) {
	
				gl.stencilMask( stencilMask );
				currentStencilMask = stencilMask;
	
			}
	
		};
	
		this.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {
	
			if ( currentStencilFunc !== stencilFunc ||
			     currentStencilRef 	!== stencilRef 	||
			     currentStencilFuncMask !== stencilMask ) {
	
				gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );
	
				currentStencilFunc = stencilFunc;
				currentStencilRef  = stencilRef;
				currentStencilFuncMask = stencilMask;
	
			}
	
		};
	
		this.setOp	 = function ( stencilFail, stencilZFail, stencilZPass ) {
	
			if ( currentStencilFail	 !== stencilFail 	||
			     currentStencilZFail !== stencilZFail ||
			     currentStencilZPass !== stencilZPass ) {
	
				gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );
	
				currentStencilFail  = stencilFail;
				currentStencilZFail = stencilZFail;
				currentStencilZPass = stencilZPass;
	
			}
	
		};
	
		this.setLocked = function ( lock ) {
	
			locked = lock;
	
		};
	
		this.setClear = function ( stencil ) {
	
			if ( currentStencilClear !== stencil ) {
	
				gl.clearStencil( stencil );
				currentStencilClear = stencil;
	
			}
	
		};
	
		this.reset = function () {
	
			locked = false;
	
			currentStencilMask = null;
			currentStencilFunc = null;
			currentStencilRef = null;
			currentStencilFuncMask = null;
			currentStencilFail = null;
			currentStencilZFail = null;
			currentStencilZPass = null;
			currentStencilClear = null;
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLTextures.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {
	
		var _infoMemory = info.memory;
		var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );
	
		//
	
		function clampToMaxSize ( image, maxSize ) {
	
			if ( image.width > maxSize || image.height > maxSize ) {
	
				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.
	
				var scale = maxSize / Math.max( image.width, image.height );
	
				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );
	
				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
	
				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
				return canvas;
	
			}
	
			return image;
	
		}
	
		function isPowerOfTwo( image ) {
	
			return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );
	
		}
	
		function makePowerOfTwo( image ) {
	
			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {
	
				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
				canvas.height = THREE.Math.nearestPowerOfTwo( image.height );
	
				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, canvas.width, canvas.height );
	
				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
				return canvas;
	
			}
	
			return image;
	
		}
	
		function textureNeedsPowerOfTwo( texture ) {
	
			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;
	
			return false;
	
		}
	
		// Fallback filters for non-power-of-2 textures
	
		function filterFallback ( f ) {
	
			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {
	
				return _gl.NEAREST;
	
			}
	
			return _gl.LINEAR;
	
		}
	
		//
	
		function onTextureDispose( event ) {
	
			var texture = event.target;
	
			texture.removeEventListener( 'dispose', onTextureDispose );
	
			deallocateTexture( texture );
	
			_infoMemory.textures --;
	
	
		}
	
		function onRenderTargetDispose( event ) {
	
			var renderTarget = event.target;
	
			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
			deallocateRenderTarget( renderTarget );
	
			_infoMemory.textures --;
	
		}
	
		//
	
		function deallocateTexture( texture ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image && textureProperties.__image__webglTextureCube ) {
	
				// cube texture
	
				_gl.deleteTexture( textureProperties.__image__webglTextureCube );
	
			} else {
	
				// 2D texture
	
				if ( textureProperties.__webglInit === undefined ) return;
	
				_gl.deleteTexture( textureProperties.__webglTexture );
	
			}
	
			// remove all webgl properties
			properties.delete( texture );
	
		}
	
		function deallocateRenderTarget( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
	
			if ( ! renderTarget ) return;
	
			if ( textureProperties.__webglTexture !== undefined ) {
	
				_gl.deleteTexture( textureProperties.__webglTexture );
	
			}
	
			if ( renderTarget.depthTexture ) {
	
				renderTarget.depthTexture.dispose();
	
			}
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
	
				}
	
			} else {
	
				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
	
			}
	
			properties.delete( renderTarget.texture );
			properties.delete( renderTarget );
	
		}
	
		//
	
	
		 var textureUpdateUndefinedWarning = false;
		 var textureUpdateIncompleteWarning = false;
	
		function setTexture2D( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
				var image = texture.image;
	
				if ( image === undefined ) {
	
					if( ! textureUpdateUndefinedWarning ) {
						console.trace( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
						textureUpdateUndefinedWarning = true;
					}
	
				} else if ( image.complete === false ) {
	
					if( ! textureUpdateIncompleteWarning ) {
						console.trace( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
						textureUpdateIncompleteWarning = true;
					}
	
				} else {
	
					uploadTexture( textureProperties, texture, slot );
					return;
	
				}
	
			}
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
		}
	
		function setTextureCube ( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image.length === 6 ) {
	
				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
					if ( ! textureProperties.__image__webglTextureCube ) {
	
						texture.addEventListener( 'dispose', onTextureDispose );
	
						textureProperties.__image__webglTextureCube = _gl.createTexture();
	
						_infoMemory.textures ++;
	
					}
	
					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;
	
					var cubeImage = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( ! isCompressed && ! isDataTexture ) {
	
							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
	
						} else {
	
							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
						}
	
					}
	
					var image = cubeImage[ 0 ],
					isPowerOfTwoImage = isPowerOfTwo( image ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );
	
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( ! isCompressed ) {
	
							if ( isDataTexture ) {
	
								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
							} else {
	
								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
							}
	
						} else {
	
							var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
								mipmap = mipmaps[ j ];
	
								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
									} else {
	
										console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );
	
									}
	
								} else {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
								}
	
							}
	
						}
	
					}
	
					if ( texture.generateMipmaps && isPowerOfTwoImage ) {
	
						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
					}
	
					textureProperties.__version = texture.version;
	
					if ( texture.onUpdate ) texture.onUpdate( texture );
	
				} else {
	
					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
				}
	
			}
	
		}
	
		function setTextureCubeDynamic ( texture, slot ) {
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
	
		}
	
		function setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {
	
			var extension;
	
			if ( isPowerOfTwoImage ) {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
			} else {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );
	
				}
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );
	
				}
	
			}
	
			extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
			if ( extension ) {
	
				if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;
	
				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
	
					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;
	
				}
	
			}
	
		}
	
		function uploadTexture( textureProperties, texture, slot ) {
	
			if ( textureProperties.__webglInit === undefined ) {
	
				textureProperties.__webglInit = true;
	
				texture.addEventListener( 'dispose', onTextureDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				_infoMemory.textures ++;
	
			}
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
			var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
	
			if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {
	
				image = makePowerOfTwo( image );
	
			}
	
			var isPowerOfTwoImage = isPowerOfTwo( image ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );
	
			setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );
	
			var mipmap, mipmaps = texture.mipmaps;
	
			if ( texture instanceof THREE.DepthTexture ) {
	
				// populate depth texture with dummy data
	
				var internalFormat = _gl.DEPTH_COMPONENT;
	
				if ( texture.type === THREE.FloatType ) {
	
					if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
					internalFormat = _gl.DEPTH_COMPONENT32F;
	
				} else if ( _isWebGL2 ) {
	
					// WebGL 2.0 requires signed internalformat for glTexImage2D
					internalFormat = _gl.DEPTH_COMPONENT16;
	
				}
	
				state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );
	
			} else if ( texture instanceof THREE.DataTexture ) {
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
				}
	
			} else if ( texture instanceof THREE.CompressedTexture ) {
	
				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
					mipmap = mipmaps[ i ];
	
					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
						} else {
	
							console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );
	
						}
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
				}
	
			} else {
	
				// regular Texture (image, video, canvas)
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );
	
				}
	
			}
	
			if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
			textureProperties.__version = texture.version;
	
			if ( texture.onUpdate ) texture.onUpdate( texture );
	
		}
	
		// Render targets
	
		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {
	
			var glFormat = paramThreeToGL( renderTarget.texture.format );
			var glType = paramThreeToGL( renderTarget.texture.type );
			state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
		}
	
		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage ( renderbuffer, renderTarget ) {
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else {
	
				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
			}
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
	
		}
	
		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture ( framebuffer, renderTarget ) {
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
			if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');
	
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
			if ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {
	
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
	
			}
	
			// upload an empty depth texture with framebuffer size
			if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}
	
			setTexture2D( renderTarget.depthTexture, 0 );
	
			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
	
		}
	
		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
	
			if ( renderTarget.depthTexture ) {
	
				if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');
	
				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
	
			} else {
	
				if ( isCube ) {
	
					renderTargetProperties.__webglDepthbuffer = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
	
					}
	
				} else {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
	
				}
	
			}
	
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
		}
	
		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
	
			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
			textureProperties.__webglTexture = _gl.createTexture();
	
			_infoMemory.textures ++;
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
	
			// Setup framebuffer
	
			if ( isCube ) {
	
				renderTargetProperties.__webglFramebuffer = [];
	
				for ( var i = 0; i < 6; i ++ ) {
	
					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
	
				}
	
			} else {
	
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	
			}
	
			// Setup color buffer
	
			if ( isCube ) {
	
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
	
				for ( var i = 0; i < 6; i ++ ) {
	
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
	
				}
	
				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
			} else {
	
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );
	
				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
				state.bindTexture( _gl.TEXTURE_2D, null );
	
			}
	
			// Setup depth and stencil buffers
	
			if ( renderTarget.depthBuffer ) {
	
				setupDepthRenderbuffer( renderTarget );
	
			}
	
		}
	
		function updateRenderTargetMipmap( renderTarget ) {
	
			var texture = renderTarget.texture;
	
			if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
					texture.minFilter !== THREE.NearestFilter &&
					texture.minFilter !== THREE.LinearFilter ) {
	
				var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				var webglTexture = properties.get( texture ).__webglTexture;
	
				state.bindTexture( target, webglTexture );
				_gl.generateMipmap( target );
				state.bindTexture( target, null );
	
			}
	
		}
	
		this.setTexture2D = setTexture2D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	
	};
	
	// File:src/renderers/webgl/WebGLUniforms.js
	
	/**
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 * .splitDynamic( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with dynamic entry and removes them from 'seq'
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 *
	 * @author tschw
	 *
	 */
	
	THREE.WebGLUniforms = ( function() { // scope
	
		var emptyTexture = new THREE.Texture();
		var emptyCubeTexture = new THREE.CubeTexture();
	
		// --- Base for inner nodes (including the root) ---
	
		var UniformContainer = function() {
	
				this.seq = [];
				this.map = {};
	
			},
	
		// --- Utilities ---
	
		// Array Caches (provide typed arrays for temporary by size)
	
			arrayCacheF32 = [],
			arrayCacheI32 = [],
	
			uncacheTemporaryArrays = function() {
	
				arrayCacheF32.length = 0;
				arrayCacheI32.length = 0;
	
			},
	
		// Flattening for arrays of vectors and matrices
	
			flatten = function( array, nBlocks, blockSize ) {
	
				var firstElem = array[ 0 ];
	
				if ( firstElem <= 0 || firstElem > 0 ) return array;
				// unoptimized: ! isNaN( firstElem )
				// see http://jacksondunstan.com/articles/983
	
				var n = nBlocks * blockSize,
					r = arrayCacheF32[ n ];
	
				if ( r === undefined ) {
	
					r = new Float32Array( n );
					arrayCacheF32[ n ] = r;
	
				}
	
				if ( nBlocks !== 0 ) {
	
					firstElem.toArray( r, 0 );
	
					for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {
	
						offset += blockSize;
						array[ i ].toArray( r, offset );
	
					}
	
				}
	
				return r;
	
			},
	
		// Texture unit allocation
	
			allocTexUnits = function( renderer, n ) {
	
				var r = arrayCacheI32[ n ];
	
				if ( r === undefined ) {
	
					r = new Int32Array( n );
					arrayCacheI32[ n ] = r;
	
				}
	
				for ( var i = 0; i !== n; ++ i )
					r[ i ] = renderer.allocTextureUnit();
	
				return r;
	
			},
	
		// --- Setters ---
	
		// Note: Defining these methods externally, because they come in a bunch
		// and this way their names minify.
	
			// Single scalar
	
			setValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },
			setValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },
	
			// Single float vector (from flat array or THREE.VectorN)
	
			setValue2fv = function( gl, v ) {
	
				if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
				else gl.uniform2f( this.addr, v.x, v.y );
	
			},
	
			setValue3fv = function( gl, v ) {
	
				if ( v.x !== undefined )
					gl.uniform3f( this.addr, v.x, v.y, v.z );
				else if ( v.r !== undefined )
					gl.uniform3f( this.addr, v.r, v.g, v.b );
				else
					gl.uniform3fv( this.addr, v );
	
			},
	
			setValue4fv = function( gl, v ) {
	
				if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
				else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
	
			},
	
			// Single matrix (from flat array or MatrixN)
	
			setValue2fm = function( gl, v ) {
	
				gl.uniformMatrix2fv( this.addr, false, v.elements || v );
	
			},
	
			setValue3fm = function( gl, v ) {
	
				gl.uniformMatrix3fv( this.addr, false, v.elements || v );
	
			},
	
			setValue4fm = function( gl, v ) {
	
				gl.uniformMatrix4fv( this.addr, false, v.elements || v );
	
			},
	
			// Single texture (2D / Cube)
	
			setValueT1 = function( gl, v, renderer ) {
	
				var unit = renderer.allocTextureUnit();
				gl.uniform1i( this.addr, unit );
				renderer.setTexture2D( v || emptyTexture, unit );
	
			},
	
			setValueT6 = function( gl, v, renderer ) {
	
				var unit = renderer.allocTextureUnit();
				gl.uniform1i( this.addr, unit );
				renderer.setTextureCube( v || emptyCubeTexture, unit );
	
			},
	
			// Integer / Boolean vectors or arrays thereof (always flat arrays)
	
			setValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },
			setValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },
			setValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },
	
			// Helper to pick the right setter for the singular case
	
			getSingularSetter = function( type ) {
	
				switch ( type ) {
	
					case 0x1406: return setValue1f; // FLOAT
					case 0x8b50: return setValue2fv; // _VEC2
					case 0x8b51: return setValue3fv; // _VEC3
					case 0x8b52: return setValue4fv; // _VEC4
	
					case 0x8b5a: return setValue2fm; // _MAT2
					case 0x8b5b: return setValue3fm; // _MAT3
					case 0x8b5c: return setValue4fm; // _MAT4
	
					case 0x8b5e: return setValueT1; // SAMPLER_2D
					case 0x8b60: return setValueT6; // SAMPLER_CUBE
	
					case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
					case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
					case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
					case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
				}
	
			},
	
			// Array of scalars
	
			setValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },
			setValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },
	
			// Array of vectors (flat or from THREE classes)
	
			setValueV2a = function( gl, v ) {
	
				gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );
	
			},
	
			setValueV3a = function( gl, v ) {
	
				gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );
	
			},
	
			setValueV4a = function( gl, v ) {
	
				gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );
	
			},
	
			// Array of matrices (flat or from THREE clases)
	
			setValueM2a = function( gl, v ) {
	
				gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );
	
			},
	
			setValueM3a = function( gl, v ) {
	
				gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );
	
			},
	
			setValueM4a = function( gl, v ) {
	
				gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );
	
			},
	
			// Array of textures (2D / Cube)
	
			setValueT1a = function( gl, v, renderer ) {
	
				var n = v.length,
					units = allocTexUnits( renderer, n );
	
				gl.uniform1iv( this.addr, units );
	
				for ( var i = 0; i !== n; ++ i ) {
	
					renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );
	
				}
	
			},
	
			setValueT6a = function( gl, v, renderer ) {
	
				var n = v.length,
					units = allocTexUnits( renderer, n );
	
				gl.uniform1iv( this.addr, units );
	
				for ( var i = 0; i !== n; ++ i ) {
	
					renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );
	
				}
	
			},
	
	
			// Helper to pick the right setter for a pure (bottom-level) array
	
			getPureArraySetter = function( type ) {
	
				switch ( type ) {
	
					case 0x1406: return setValue1fv; // FLOAT
					case 0x8b50: return setValueV2a; // _VEC2
					case 0x8b51: return setValueV3a; // _VEC3
					case 0x8b52: return setValueV4a; // _VEC4
	
					case 0x8b5a: return setValueM2a; // _MAT2
					case 0x8b5b: return setValueM3a; // _MAT3
					case 0x8b5c: return setValueM4a; // _MAT4
	
					case 0x8b5e: return setValueT1a; // SAMPLER_2D
					case 0x8b60: return setValueT6a; // SAMPLER_CUBE
	
					case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
					case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
					case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
					case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
				}
	
			},
	
		// --- Uniform Classes ---
	
			SingleUniform = function SingleUniform( id, activeInfo, addr ) {
	
				this.id = id;
				this.addr = addr;
				this.setValue = getSingularSetter( activeInfo.type );
	
				// this.path = activeInfo.name; // DEBUG
	
			},
	
			PureArrayUniform = function( id, activeInfo, addr ) {
	
				this.id = id;
				this.addr = addr;
				this.size = activeInfo.size;
				this.setValue = getPureArraySetter( activeInfo.type );
	
				// this.path = activeInfo.name; // DEBUG
	
			},
	
			StructuredUniform = function( id ) {
	
				this.id = id;
	
				UniformContainer.call( this ); // mix-in
	
			};
	
		StructuredUniform.prototype.setValue = function( gl, value ) {
	
			// Note: Don't need an extra 'renderer' parameter, since samplers
			// are not allowed in structured uniforms.
	
			var seq = this.seq;
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				u.setValue( gl, value[ u.id ] );
	
			}
	
		};
	
		// --- Top-level ---
	
		// Parser - builds up the property tree from the path strings
	
		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g,
			// extracts
			// 	- the identifier (member name or array index)
			//  - followed by an optional right bracket (found when array index)
			//  - followed by an optional left bracket or dot (type of subscript)
			//
			// Note: These portions can be read in a non-overlapping fashion and
			// allow straightforward parsing of the hierarchy that WebGL encodes
			// in the uniform names.
	
			addUniform = function( container, uniformObject ) {
	
				container.seq.push( uniformObject );
				container.map[ uniformObject.id ] = uniformObject;
	
			},
	
			parseUniform = function( activeInfo, addr, container ) {
	
				var path = activeInfo.name,
					pathLength = path.length;
	
				// reset RegExp object, because of the early exit of a previous run
				RePathPart.lastIndex = 0;
	
				for (; ;) {
	
					var match = RePathPart.exec( path ),
						matchEnd = RePathPart.lastIndex,
	
						id = match[ 1 ],
						idIsIndex = match[ 2 ] === ']',
						subscript = match[ 3 ];
	
					if ( idIsIndex ) id = id | 0; // convert to integer
	
					if ( subscript === undefined ||
							subscript === '[' && matchEnd + 2 === pathLength ) {
						// bare name or "pure" bottom-level array "[0]" suffix
	
						addUniform( container, subscript === undefined ?
								new SingleUniform( id, activeInfo, addr ) :
								new PureArrayUniform( id, activeInfo, addr ) );
	
						break;
	
					} else {
						// step into inner node / create it in case it doesn't exist
	
						var map = container.map,
							next = map[ id ];
	
						if ( next === undefined ) {
	
							next = new StructuredUniform( id );
							addUniform( container, next );
	
						}
	
						container = next;
	
					}
	
				}
	
			},
	
		// Root Container
	
			WebGLUniforms = function WebGLUniforms( gl, program, renderer ) {
	
				UniformContainer.call( this );
	
				this.renderer = renderer;
	
				var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
	
				for ( var i = 0; i !== n; ++ i ) {
	
					var info = gl.getActiveUniform( program, i ),
						path = info.name,
						addr = gl.getUniformLocation( program, path );
	
					parseUniform( info, addr, this );
	
				}
	
			};
	
	
		WebGLUniforms.prototype.setValue = function( gl, name, value ) {
	
			var u = this.map[ name ];
	
			if ( u !== undefined ) u.setValue( gl, value, this.renderer );
	
		};
	
		WebGLUniforms.prototype.set = function( gl, object, name ) {
	
			var u = this.map[ name ];
	
			if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );
	
		};
	
		WebGLUniforms.prototype.setOptional = function( gl, object, name ) {
	
			var v = object[ name ];
	
			if ( v !== undefined ) this.setValue( gl, name, v );
	
		};
	
	
		// Static interface
	
		WebGLUniforms.upload = function( gl, seq, values, renderer ) {
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ],
					v = values[ u.id ];
	
				if ( v.needsUpdate !== false ) {
					// note: always updating when .needsUpdate is undefined
	
					u.setValue( gl, v.value, renderer );
	
				}
	
			}
	
		};
	
		WebGLUniforms.seqWithValue = function( seq, values ) {
	
			var r = [];
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				if ( u.id in values ) r.push( u );
	
			}
	
			return r;
	
		};
	
		WebGLUniforms.splitDynamic = function( seq, values ) {
	
			var r = null,
				n = seq.length,
				w = 0;
	
			for ( var i = 0; i !== n; ++ i ) {
	
				var u = seq[ i ],
					v = values[ u.id ];
	
				if ( v && v.dynamic === true ) {
	
					if ( r === null ) r = [];
					r.push( u );
	
				} else {
	
					// in-place compact 'seq', removing the matches
					if ( w < i ) seq[ w ] = u;
					++ w;
	
				}
	
			}
	
			if ( w < n ) seq.length = w;
	
			return r;
	
		};
	
		WebGLUniforms.evalDynamic = function( seq, values, object, camera ) {
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var v = values[ seq[ i ].id ],
					f = v.onUpdateCallback;
	
				if ( f !== undefined ) f.call( v, object, camera );
	
			}
	
		};
	
		return WebGLUniforms;
	
	} )();
	
	// File:src/renderers/webgl/plugins/LensFlarePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlarePlugin = function ( renderer, flares ) {
	
		var gl = renderer.context;
		var state = renderer.state;
	
		var vertexBuffer, elementBuffer;
		var shader, program, attributes, uniforms;
	
		var tempTexture, occlusionTexture;
	
		function init() {
	
			var vertices = new Float32Array( [
				- 1, - 1,  0, 0,
				 1, - 1,  1, 0,
				 1,  1,  1, 1,
				- 1,  1,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			// buffers
	
			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			// textures
	
			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();
	
			state.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			shader = {
	
				vertexShader: [
	
					"uniform lowp int renderType;",
	
					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",
	
					"uniform sampler2D occlusionMap;",
	
					"attribute vec2 position;",
					"attribute vec2 uv;",
	
					"varying vec2 vUV;",
					"varying float vVisibility;",
	
					"void main() {",
	
						"vUV = uv;",
	
						"vec2 pos = position;",
	
						"if ( renderType == 2 ) {",
	
							"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
							"vVisibility =        visibility.r / 9.0;",
							"vVisibility *= 1.0 - visibility.g / 9.0;",
							"vVisibility *=       visibility.b / 9.0;",
							"vVisibility *= 1.0 - visibility.a / 9.0;",
	
							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
						"}",
	
						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
					"}"
	
				].join( "\n" ),
	
				fragmentShader: [
	
					"uniform lowp int renderType;",
	
					"uniform sampler2D map;",
					"uniform float opacity;",
					"uniform vec3 color;",
	
					"varying vec2 vUV;",
					"varying float vVisibility;",
	
					"void main() {",
	
						// pink square
	
						"if ( renderType == 0 ) {",
	
							"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
						// restore
	
						"} else if ( renderType == 1 ) {",
	
							"gl_FragColor = texture2D( map, vUV );",
	
						// flare
	
						"} else {",
	
							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * vVisibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",
	
						"}",
	
					"}"
	
				].join( "\n" )
	
			};
	
			program = createProgram( shader );
	
			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			};
	
			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};
	
		}
	
		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */
	
		this.render = function ( scene, camera, viewport ) {
	
			if ( flares.length === 0 ) return;
	
			var tempPosition = new THREE.Vector3();
	
			var invAspect = viewport.w / viewport.z,
				halfViewportWidth = viewport.z * 0.5,
				halfViewportHeight = viewport.w * 0.5;
	
			var size = 16 / viewport.w,
				scale = new THREE.Vector2( size * invAspect, size );
	
			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );
	
			var validArea = new THREE.Box2();
	
			validArea.min.set( 0, 0 );
			validArea.max.set( viewport.z - 16, viewport.w - 16 );
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			state.initAttributes();
			state.enableAttribute( attributes.vertex );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();
	
			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/uniforms
	
			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			state.disable( gl.CULL_FACE );
			state.setDepthWrite( false );
	
			for ( var i = 0, l = flares.length; i < l; i ++ ) {
	
				size = 16 / viewport.w;
				scale.set( size * invAspect, size );
	
				// calc object screen position
	
				var flare = flares[ i ];
	
				tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );
	
				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );
	
				// setup arrays for gl programs
	
				screenPosition.copy( tempPosition );
	
				// horizontal and vertical coordinate of the lower left corner of the pixels to copy
	
				screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
				screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;
	
				// screen cull
	
				if ( validArea.containsPoint( screenPositionPixels ) === true ) {
	
					// save current RGB to temp texture
	
					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, null );
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
					// render pink quad
	
					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
					state.disable( gl.BLEND );
					state.enable( gl.DEPTH_TEST );
	
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// copy result to occlusionMap
	
					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
					// restore graphics
	
					gl.uniform1i( uniforms.renderType, 1 );
					state.disable( gl.DEPTH_TEST );
	
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// update object positions
	
					flare.positionScreen.copy( screenPosition );
	
					if ( flare.customUpdateCallback ) {
	
						flare.customUpdateCallback( flare );
	
					} else {
	
						flare.updateLensFlares();
	
					}
	
					// render flares
	
					gl.uniform1i( uniforms.renderType, 2 );
					state.enable( gl.BLEND );
	
					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
						var sprite = flare.lensFlares[ j ];
	
						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;
	
							size = sprite.size * sprite.scale / viewport.w;
	
							scale.x = size * invAspect;
							scale.y = size;
	
							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );
	
							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
							state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture2D( sprite.texture, 1 );
	
							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
						}
	
					}
	
				}
	
			}
	
			// restore gl
	
			state.enable( gl.CULL_FACE );
			state.enable( gl.DEPTH_TEST );
			state.setDepthWrite( true );
	
			renderer.resetGLState();
	
		};
	
		function createProgram ( shader ) {
	
			var program = gl.createProgram();
	
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
	
			var prefix = "precision " + renderer.getPrecision() + " float;\n";
	
			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );
	
			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );
	
			gl.linkProgram( program );
	
			return program;
	
		}
	
	};
	
	// File:src/renderers/webgl/plugins/SpritePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpritePlugin = function ( renderer, sprites ) {
	
		var gl = renderer.context;
		var state = renderer.state;
	
		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
	
		var texture;
	
		// decompose matrixWorld
	
		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();
	
		function init() {
	
			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			program = createProgram();
	
			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};
	
			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),
	
				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),
	
				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),
	
				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),
	
				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),
	
				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};
	
			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = 8;
			canvas.height = 8;
	
			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );
	
			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;
	
		}
	
		this.render = function ( scene, camera ) {
	
			if ( sprites.length === 0 ) return;
	
			// setup gl
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();
	
			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );
	
			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;
	
			if ( fog ) {
	
				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
				if ( fog instanceof THREE.Fog ) {
	
					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );
	
					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;
	
				} else if ( fog instanceof THREE.FogExp2 ) {
	
					gl.uniform1f( uniforms.fogDensity, fog.density );
	
					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;
	
				}
	
			} else {
	
				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;
	
			}
	
	
			// update positions and sort
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
	
				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];
	
			}
	
			sprites.sort( painterSortStable );
	
			// render all sprites
	
			var scale = [];
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
				var material = sprite.material;
	
				if ( material.visible === false ) continue;
	
				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );
	
				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
	
				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;
	
				var fogType = 0;
	
				if ( scene.fog && material.fog ) {
	
					fogType = sceneFogType;
	
				}
	
				if ( oldFogType !== fogType ) {
	
					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;
	
				}
	
				if ( material.map !== null ) {
	
					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
				} else {
	
					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );
	
				}
	
				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );
	
				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
	
				if ( material.map ) {
	
					renderer.setTexture2D( material.map, 0 );
	
				} else {
	
					renderer.setTexture2D( texture, 0 );
	
				}
	
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
			}
	
			// restore gl
	
			state.enable( gl.CULL_FACE );
	
			renderer.resetGLState();
	
		};
	
		function createProgram () {
	
			var program = gl.createProgram();
	
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
	
			gl.shaderSource( vertexShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',
	
				'attribute vec2 position;',
				'attribute vec2 uv;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vUV = uvOffset + uv * uvScale;',
	
					'vec2 alignedPosition = position * scale;',
	
					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
					'vec4 finalPosition;',
	
					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',
	
					'gl_Position = finalPosition;',
	
				'}'
	
			].join( '\n' ) );
	
			gl.shaderSource( fragmentShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',
	
				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vec4 texture = texture2D( map, vUV );',
	
					'if ( texture.a < alphaTest ) discard;',
	
					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
					'if ( fogType > 0 ) {',
	
						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',
	
						'if ( fogType == 1 ) {',
	
							'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
						'} else {',
	
							'const float LOG2 = 1.442695;',
							'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
						'}',
	
						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
					'}',
	
				'}'
	
			].join( '\n' ) );
	
			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );
	
			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );
	
			gl.linkProgram( program );
	
			return program;
	
		}
	
		function painterSortStable ( a, b ) {
	
			if ( a.renderOrder !== b.renderOrder ) {
	
				return a.renderOrder - b.renderOrder;
	
			} else if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return b.id - a.id;
	
			}
	
		}
	
	};
	
	// File:src/Three.Legacy.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	Object.assign( THREE, {
		Face4: function ( a, b, c, d, normal, color, materialIndex ) {
			console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new THREE.Face3( a, b, c, normal, color, materialIndex );
		},
		LineStrip: 0,
		LinePieces: 1,
		MeshFaceMaterial: THREE.MultiMaterial,
		PointCloud: function ( geometry, material ) {
			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new THREE.Points( geometry, material );
		},
		Particle: THREE.Sprite,
		ParticleSystem: function ( geometry, material ) {
			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new THREE.Points( geometry, material );
		},
		PointCloudMaterial: function ( parameters ) {
			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new THREE.PointsMaterial( parameters );
		},
		ParticleBasicMaterial: function ( parameters ) {
			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new THREE.PointsMaterial( parameters );
		},
		ParticleSystemMaterial: function ( parameters ) {
			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new THREE.PointsMaterial( parameters );
		},
		Vertex: function ( x, y, z ) {
			console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new THREE.Vector3( x, y, z );
		}
	} );
	
	//
	
	Object.assign( THREE.Box2.prototype, {
		empty: function () {
			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
		},
		isIntersectionBox: function ( box ) {
			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
		}
	} );
	
	Object.assign( THREE.Box3.prototype, {
		empty: function () {
			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
		},
		isIntersectionBox: function ( box ) {
			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
		},
		isIntersectionSphere: function ( sphere ) {
			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );
		}
	} );
	
	Object.assign( THREE.Matrix3.prototype, {
		multiplyVector3: function ( vector ) {
			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );
		},
		multiplyVector3Array: function ( a ) {
			console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );
		}
	} );
	
	Object.assign( THREE.Matrix4.prototype, {
		extractPosition: function ( m ) {
			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );
		},
		setRotationFromQuaternion: function ( q ) {
			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );
		},
		multiplyVector3: function ( vector ) {
			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );
		},
		multiplyVector4: function ( vector ) {
			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
		},
		multiplyVector3Array: function ( a ) {
			console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );
		},
		rotateAxis: function ( v ) {
			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );
		},
		crossVector: function ( vector ) {
			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
		},
		translate: function ( v ) {
			console.error( 'THREE.Matrix4: .translate() has been removed.' );
		},
		rotateX: function ( angle ) {
			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
		},
		rotateY: function ( angle ) {
			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
		},
		rotateZ: function ( angle ) {
			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
		},
		rotateByAxis: function ( axis, angle ) {
			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
		}
	} );
	
	Object.assign( THREE.Plane.prototype, {
		isIntersectionLine: function ( line ) {
			console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
			return this.intersectsLine( line );
		}
	} );
	
	Object.assign( THREE.Quaternion.prototype, {
		multiplyVector3: function ( vector ) {
			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
		}
	} );
	
	Object.assign( THREE.Ray.prototype, {
		isIntersectionBox: function ( box ) {
			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
		},
		isIntersectionPlane: function ( plane ) {
			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );
		},
		isIntersectionSphere: function ( sphere ) {
			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );
		}
	} );
	
	Object.assign( THREE.Vector3.prototype, {
		setEulerFromRotationMatrix: function () {
			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
		},
		setEulerFromQuaternion: function () {
			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
		},
		getPositionFromMatrix: function ( m ) {
			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );
		},
		getScaleFromMatrix: function ( m ) {
			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );
		},
		getColumnFromMatrix: function ( index, matrix ) {
			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );
		}
	} );
	
	//
	
	Object.assign( THREE.Object3D.prototype, {
		getChildByName: function ( name ) {
			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );
		},
		renderDepth: function ( value ) {
			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
		},
		translate: function ( distance, axis ) {
			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );
		}
	} );
	
	Object.defineProperties( THREE.Object3D.prototype, {
		eulerOrder: {
			get: function () {
				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;
			},
			set: function ( value ) {
				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;
			}
		},
		useQuaternion: {
			get: function () {
				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
			},
			set: function ( value ) {
				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
			}
		}
	} );
	
	Object.defineProperties( THREE.LOD.prototype, {
		objects: {
			get: function () {
				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;
			}
		}
	} );
	
	//
	
	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {
	
		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
				"Use .setFocalLength and .filmGauge for a photographic setup." );
	
		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );
	
	};
	
	//
	
	Object.defineProperties( THREE.Light.prototype, {
		onlyShadow: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .onlyShadow has been removed.' );
			}
		},
		shadowCameraFov: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
			}
		},
		shadowBias: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
			}
		},
		shadowMapWidth: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.BufferAttribute.prototype, {
		length: {
			get: function () {
				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
				return this.array.length;
			}
		}
	} );
	
	Object.assign( THREE.BufferGeometry.prototype, {
		addIndex: function ( index ) {
			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );
		},
		addDrawCall: function ( start, count, indexOffset ) {
			if ( indexOffset !== undefined ) {
				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );
		},
		clearDrawCalls: function () {
			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();
		},
		computeTangents: function () {
			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
		},
		computeOffsets: function () {
			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
		}
	} );
	
	Object.defineProperties( THREE.BufferGeometry.prototype, {
		drawcalls: {
			get: function () {
				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;
			}
		},
		offsets: {
			get: function () {
				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.Material.prototype, {
		wrapAround: {
			get: function () {
				console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
			},
			set: function ( value ) {
				console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
			}
		},
		wrapRGB: {
			get: function () {
				console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
				return new THREE.Color();
			}
		}
	} );
	
	Object.defineProperties( THREE.MeshPhongMaterial.prototype, {
		metal: {
			get: function () {
				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;
			},
			set: function ( value ) {
				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
			}
		}
	} );
	
	Object.defineProperties( THREE.ShaderMaterial.prototype, {
		derivatives: {
			get: function () {
				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;
			},
			set: function ( value ) {
				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;
			}
		}
	} );
	
	//
	
	THREE.EventDispatcher.prototype = Object.assign( Object.create( {
	
		// Note: Extra base ensures these properties are not 'assign'ed.
	
		constructor: THREE.EventDispatcher,
	
		apply: function ( target ) {
	
			console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
					"just inherit or Object.assign the prototype to mix-in." );
	
			Object.assign( target, this );
	
		}
	
	} ), THREE.EventDispatcher.prototype );
	
	//
	
	Object.assign( THREE.WebGLRenderer.prototype, {
		supportsFloatTextures: function () {
			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );
		},
		supportsHalfFloatTextures: function () {
			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );
		},
		supportsStandardDerivatives: function () {
			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );
		},
		supportsCompressedTextureS3TC: function () {
			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
		},
		supportsCompressedTexturePVRTC: function () {
			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
		},
		supportsBlendMinMax: function () {
			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );
		},
		supportsVertexTextures: function () {
			return this.capabilities.vertexTextures;
		},
		supportsInstancedArrays: function () {
			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );
		},
		enableScissorTest: function ( boolean ) {
			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );
		},
		initMaterial: function () {
			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
		},
		addPrePlugin: function () {
			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
		},
		addPostPlugin: function () {
			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
		},
		updateShadowMap: function () {
			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
		}
	} );
	
	Object.defineProperties( THREE.WebGLRenderer.prototype, {
		shadowMapEnabled: {
			get: function () {
				return this.shadowMap.enabled;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function () {
				return this.shadowMap.type;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function () {
				return this.shadowMap.cullFace;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
				this.shadowMap.cullFace = value;
			}
		}
	} );
	
	Object.defineProperties( THREE.WebGLShadowMap.prototype, {
		cullFace: {
			get: function () {
				return this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;
			},
			set: function ( cullFace ) {
				var value = ( cullFace !== THREE.CullFaceBack );
				console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
				this.renderReverseSided = value;
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.WebGLRenderTarget.prototype, {
		wrapS: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;
			}
		},
		format: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;
			}
		},
		type: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;
			}
		}
	} );
	
	//
	
	Object.assign( THREE.Audio.prototype, {
		load: function ( file ) {
			console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
			var scope = this;
			var audioLoader = new THREE.AudioLoader();
			audioLoader.load( file, function ( buffer ) {
				scope.setBuffer( buffer );
			} );
			return this;
		}
	} );
	
	Object.assign( THREE.AudioAnalyser.prototype, {
		getData: function ( file ) {
			console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
			return this.getFrequencyData();
		}
	} );
	
	//
	
	THREE.GeometryUtils = {
	
		merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
	
			var matrix;
	
			if ( geometry2 instanceof THREE.Mesh ) {
	
				geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;
	
			}
	
			geometry1.merge( geometry2, matrix, materialIndexOffset );
	
		},
	
		center: function ( geometry ) {
	
			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();
	
		}
	
	};
	
	THREE.ImageUtils = {
	
		crossOrigin: undefined,
	
		loadTexture: function ( url, mapping, onLoad, onError ) {
	
			console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
	
			var loader = new THREE.TextureLoader();
			loader.setCrossOrigin( this.crossOrigin );
	
			var texture = loader.load( url, onLoad, undefined, onError );
	
			if ( mapping ) texture.mapping = mapping;
	
			return texture;
	
		},
	
		loadTextureCube: function ( urls, mapping, onLoad, onError ) {
	
			console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
	
			var loader = new THREE.CubeTextureLoader();
			loader.setCrossOrigin( this.crossOrigin );
	
			var texture = loader.load( urls, onLoad, undefined, onError );
	
			if ( mapping ) texture.mapping = mapping;
	
			return texture;
	
		},
	
		loadCompressedTexture: function () {
	
			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
	
		},
	
		loadCompressedTextureCube: function () {
	
			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
	
		}
	
	};
	
	//
	
	THREE.Projector = function () {
	
		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
		this.projectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );
	
		};
	
		this.unprojectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );
	
		};
	
		this.pickingRay = function ( vector, camera ) {
	
			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
		};
	
	};
	
	//
	
	THREE.CanvasRenderer = function () {
	
		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
	
		this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};
	
	};
	
	// File:examples/js/pmrem/PMREMGenerator.js
	
	/**
	 * @author Prashant Sharma / spidersharma03
	 * @author Ben Houston / bhouston, https://clara.io
	 *
	 * To avoid cube map seams, I create an extra pixel around each face. This way when the cube map is
	 * sampled by an application later(with a little care by sampling the centre of the texel), the extra 1 border
	 *	of pixels makes sure that there is no seams artifacts present. This works perfectly for cubeUV format as
	 *	well where the 6 faces can be arranged in any manner whatsoever.
	 * Code in the beginning of fragment shader's main function does this job for a given resolution.
	 *	Run Scene_PMREM_Test.html in the examples directory to see the sampling from the cube lods generated
	 *	by this class.
	 */
	
	THREE.PMREMGenerator = function( sourceTexture ) {
	
		this.sourceTexture = sourceTexture;
		this.resolution = 256; // NODE: 256 is currently hard coded in the glsl code for performance reasons
	
		var monotonicEncoding = ( sourceTexture.encoding === THREE.LinearEncoding ) ||
			( sourceTexture.encoding === THREE.GammaEncoding ) || ( sourceTexture.encoding === THREE.sRGBEncoding );
	
		this.sourceTexture.minFilter = ( monotonicEncoding ) ? THREE.LinearFilter : THREE.NearestFilter;
		this.sourceTexture.magFilter = ( monotonicEncoding ) ? THREE.LinearFilter : THREE.NearestFilter;
		this.sourceTexture.generateMipmaps = this.sourceTexture.generateMipmaps && monotonicEncoding;
	
		this.cubeLods = [];
	
		var size = this.resolution;
		var params = {		format: this.sourceTexture.format,
			magFilter: this.sourceTexture.magFilter,
			minFilter: this.sourceTexture.minFilter,
			type: this.sourceTexture.type,
			generateMipmaps: this.sourceTexture.generateMipmaps,
			anisotropy: this.sourceTexture.anisotropy,
			encoding: this.sourceTexture.encoding
		 };
	
		// how many LODs fit in the given CubeUV Texture.
		this.numLods = Math.log( size ) / Math.log( 2 ) - 2;  // IE11 doesn't support Math.log2
	
		for ( var i = 0; i < this.numLods; i ++ ) {
	
			var renderTarget = new THREE.WebGLRenderTargetCube( size, size, params );
			this.cubeLods.push( renderTarget );
			size = Math.max( 16, size / 2 );
	
		}
	
		this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0.0, 1000 );
	
		this.shader = this.getShader();
		this.planeMesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2, 0 ), this.shader );
		this.planeMesh.material.side = THREE.DoubleSide;
		this.scene = new THREE.Scene();
		this.scene.add( this.planeMesh );
		this.scene.add( this.camera );
	
		this.shader.uniforms[ 'envMap' ].value = this.sourceTexture;
		this.shader.envMap = this.sourceTexture;
	
	};
	
	THREE.PMREMGenerator.prototype = {
	
		constructor : THREE.PMREMGenerator,
	
		/*
		 * Prashant Sharma / spidersharma03: More thought and work is needed here.
		 * Right now it's a kind of a hack to use the previously convolved map to convolve the current one.
		 * I tried to use the original map to convolve all the lods, but for many textures(specially the high frequency)
		 * even a high number of samples(1024) dosen't lead to satisfactory results.
		 * By using the previous convolved maps, a lower number of samples are generally sufficient(right now 32, which
		 * gives okay results unless we see the reflection very carefully, or zoom in too much), however the math
		 * goes wrong as the distribution function tries to sample a larger area than what it should be. So I simply scaled
		 * the roughness by 0.9(totally empirical) to try to visually match the original result.
		 * The condition "if(i <5)" is also an attemt to make the result match the original result.
		 * This method requires the most amount of thinking I guess. Here is a paper which we could try to implement in future::
		 * http://http.developer.nvidia.com/GPUGems3/gpugems3_ch20.html
		 */
		update: function( renderer ) {
	
			this.shader.uniforms[ 'envMap' ].value = this.sourceTexture;
			this.shader.envMap = this.sourceTexture;
	
			var gammaInput = renderer.gammaInput;
			var gammaOutput = renderer.gammaOutput;
			var toneMapping = renderer.toneMapping;
			var toneMappingExposure = renderer.toneMappingExposure;
	
			renderer.toneMapping = THREE.LinearToneMapping;
			renderer.toneMappingExposure = 1.0;
			renderer.gammaInput = false;
			renderer.gammaOutput = false;
	
			for ( var i = 0; i < this.numLods; i ++ ) {
	
				var r = i / ( this.numLods - 1 );
				this.shader.uniforms[ 'roughness' ].value = r * 0.9; // see comment above, pragmatic choice
				var size = this.cubeLods[ i ].width;
				this.shader.uniforms[ 'mapSize' ].value = size;
				this.renderToCubeMapTarget( renderer, this.cubeLods[ i ] );
	
				if ( i < 5 ) this.shader.uniforms[ 'envMap' ].value = this.cubeLods[ i ].texture;
	
			}
	
			renderer.toneMapping = toneMapping;
			renderer.toneMappingExposure = toneMappingExposure;
			renderer.gammaInput = gammaInput;
			renderer.gammaOutput = gammaOutput;
	
		},
	
		renderToCubeMapTarget: function( renderer, renderTarget ) {
	
			for ( var i = 0; i < 6; i ++ ) {
	
				this.renderToCubeMapTargetFace( renderer, renderTarget, i )
	
			}
	
		},
	
		renderToCubeMapTargetFace: function( renderer, renderTarget, faceIndex ) {
	
			renderTarget.activeCubeFace = faceIndex;
			this.shader.uniforms[ 'faceIndex' ].value = faceIndex;
			renderer.render( this.scene, this.camera, renderTarget, true );
	
		},
	
		getShader: function() {
	
			return new THREE.ShaderMaterial( {
	
				uniforms: {
					"faceIndex": { value: 0 },
					"roughness": { value: 0.5 },
					"mapSize": { value: 0.5 },
					"envMap": { value: null },
					"testColor": { value: new THREE.Vector3( 1, 1, 1 ) }
				},
	
				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",
	
				fragmentShader:
					"#include <common>\n\
					varying vec2 vUv;\n\
					uniform int faceIndex;\n\
					uniform float roughness;\n\
					uniform samplerCube envMap;\n\
					uniform float mapSize;\n\
					uniform vec3 testColor;\n\
					\n\
					float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\
						float a = ggxRoughness + 0.0001;\n\
						a *= a;\n\
						return ( 2.0 / a - 2.0 );\n\
					}\n\
					vec3 ImportanceSamplePhong(vec2 uv, mat3 vecSpace, float specPow) {\n\
						float phi = uv.y * 2.0 * PI;\n\
						float cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\
						float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\
						vec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\
						return vecSpace * sampleDir;\n\
					}\n\
					vec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\n\
					{\n\
						float a = Roughness * Roughness;\n\
						float Phi = 2.0 * PI * uv.x;\n\
						float CosTheta = sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\n\
						float SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\
						return vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\n\
					}\n\
					mat3 matrixFromVector(vec3 n) {\n\
						float a = 1.0 / (1.0 + n.z);\n\
						float b = -n.x * n.y * a;\n\
						vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\
						vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\
						return mat3(b1, b2, n);\n\
					}\n\
					\n\
					vec4 testColorMap(float Roughness) {\n\
						vec4 color;\n\
						if(faceIndex == 0)\n\
							color = vec4(1.0,0.0,0.0,1.0);\n\
						else if(faceIndex == 1)\n\
							color = vec4(0.0,1.0,0.0,1.0);\n\
						else if(faceIndex == 2)\n\
							color = vec4(0.0,0.0,1.0,1.0);\n\
						else if(faceIndex == 3)\n\
							color = vec4(1.0,1.0,0.0,1.0);\n\
						else if(faceIndex == 4)\n\
							color = vec4(0.0,1.0,1.0,1.0);\n\
						else\n\
							color = vec4(1.0,0.0,1.0,1.0);\n\
						color *= ( 1.0 - Roughness );\n\
						return color;\n\
					}\n\
					void main() {\n\
						vec3 sampleDirection;\n\
						vec2 uv = vUv*2.0 - 1.0;\n\
						float offset = -1.0/mapSize;\n\
						const float a = -1.0;\n\
						const float b = 1.0;\n\
						float c = -1.0 + offset;\n\
						float d = 1.0 - offset;\n\
						float bminusa = b - a;\n\
						uv.x = (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\n\
						uv.y = (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\n\
						if (faceIndex==0) {\n\
							sampleDirection = vec3(1.0, -uv.y, -uv.x);\n\
						} else if (faceIndex==1) {\n\
							sampleDirection = vec3(-1.0, -uv.y, uv.x);\n\
						} else if (faceIndex==2) {\n\
							sampleDirection = vec3(uv.x, 1.0, uv.y);\n\
						} else if (faceIndex==3) {\n\
							sampleDirection = vec3(uv.x, -1.0, -uv.y);\n\
						} else if (faceIndex==4) {\n\
							sampleDirection = vec3(uv.x, -uv.y, 1.0);\n\
						} else {\n\
							sampleDirection = vec3(-uv.x, -uv.y, -1.0);\n\
						}\n\
						mat3 vecSpace = matrixFromVector(normalize(sampleDirection));\n\
						vec3 rgbColor = vec3(0.0);\n\
						const int NumSamples = 32;\n\
						vec3 vect;\n\
						float weight = 0.0;\n\
						for( int i = 0; i < NumSamples; i ++ ) {\n\
							float sini = sin(float(i));\n\
							float cosi = cos(float(i));\n\
							float r = rand(vec2(sini, cosi));\n\
							vect = ImportanceSampleGGX(vec2(float(i) / float(NumSamples), r), vecSpace, roughness);\n\
							float dotProd = dot(vect, normalize(sampleDirection));\n\
							weight += dotProd;\n\
							vec3 color = envMapTexelToLinear(textureCube(envMap,vect)).rgb;\n\
							rgbColor.rgb += color;\n\
						}\n\
						rgbColor /= float(NumSamples);\n\
						//rgbColor = testColorMap( roughness ).rgb;\n\
						gl_FragColor = linearToOutputTexel( vec4( rgbColor, 1.0 ) );\n\
					}",
				blending: THREE.CustomBlending,
				blendSrc: THREE.OneFactor,
				blendDst: THREE.ZeroFactor,
				blendSrcAlpha: THREE.OneFactor,
				blendDstAlpha: THREE.ZeroFactor,
				blendEquation: THREE.AddEquation
			} );
	
		}
	
	};
	
	// File:examples/js/pmrem/PMREMCubeUVPacker.js
	
	/**
	 * @author Prashant Sharma / spidersharma03
	 * @author Ben Houston / bhouston, https://clara.io
	 *
	 * This class takes the cube lods(corresponding to different roughness values), and creates a single cubeUV
	 * Texture. The format for a given roughness set of faces is simply::
	 * +X+Y+Z
	 * -X-Y-Z
	 * For every roughness a mip map chain is also saved, which is essential to remove the texture artifacts due to
	 * minification.
	 * Right now for every face a PlaneMesh is drawn, which leads to a lot of geometry draw calls, but can be replaced
	 * later by drawing a single buffer and by sending the appropriate faceIndex via vertex attributes.
	 * The arrangement of the faces is fixed, as assuming this arrangement, the sampling function has been written.
	 */
	
	
	THREE.PMREMCubeUVPacker = function( cubeTextureLods, numLods ) {
	
		this.cubeLods = cubeTextureLods;
		this.numLods = numLods;
		var size = cubeTextureLods[ 0 ].width * 4;
	
		var sourceTexture = cubeTextureLods[ 0 ].texture;
		var params = {
			format: sourceTexture.format,
			magFilter: sourceTexture.magFilter,
			minFilter: sourceTexture.minFilter,
			type: sourceTexture.type,
			generateMipmaps: sourceTexture.generateMipmaps,
			anisotropy: sourceTexture.anisotropy,
			encoding: sourceTexture.encoding
		};
	
		if( sourceTexture.encoding === THREE.RGBM16Encoding ) {
			params.magFilter = THREE.LinearFilter;
			params.minFilter = THREE.LinearFilter;
		}
	
		this.CubeUVRenderTarget = new THREE.WebGLRenderTarget( size, size, params );
		this.CubeUVRenderTarget.texture.mapping = THREE.CubeUVReflectionMapping;
		this.camera = new THREE.OrthographicCamera( - size * 0.5, size * 0.5, - size * 0.5, size * 0.5, 0.0, 1000 );
	
		this.scene = new THREE.Scene();
		this.scene.add( this.camera );
	
		this.objects = [];
		var xOffset = 0;
		var faceOffsets = [];
		faceOffsets.push( new THREE.Vector2( 0, 0 ) );
		faceOffsets.push( new THREE.Vector2( 1, 0 ) );
		faceOffsets.push( new THREE.Vector2( 2, 0 ) );
		faceOffsets.push( new THREE.Vector2( 0, 1 ) );
		faceOffsets.push( new THREE.Vector2( 1, 1 ) );
		faceOffsets.push( new THREE.Vector2( 2, 1 ) );
		var yOffset = 0;
		var textureResolution = size;
		size = cubeTextureLods[ 0 ].width;
	
		var offset2 = 0;
		var c = 4.0;
		this.numLods = Math.log( cubeTextureLods[ 0 ].width ) / Math.log( 2 ) - 2; // IE11 doesn't support Math.log2
		for ( var i = 0; i < this.numLods; i ++ ) {
	
			var offset1 = ( textureResolution - textureResolution / c ) * 0.5;
			if ( size > 16 )
			c *= 2;
			var nMips = size > 16 ? 6 : 1;
			var mipOffsetX = 0;
			var mipOffsetY = 0;
			var mipSize = size;
	
			for ( var j = 0; j < nMips; j ++ ) {
	
				// Mip Maps
				for ( var k = 0; k < 6; k ++ ) {
	
					// 6 Cube Faces
					var material = this.getShader();
					material.uniforms[ 'envMap' ].value = this.cubeLods[ i ].texture;
					material.envMap = this.cubeLods[ i ].texture;
					material.uniforms[ 'faceIndex' ].value = k;
					material.uniforms[ 'mapSize' ].value = mipSize;
					var color = material.uniforms[ 'testColor' ].value;
					//color.copy(testColor[j]);
					var planeMesh = new THREE.Mesh(
					new THREE.PlaneGeometry( mipSize, mipSize, 0 ),
					material );
					planeMesh.position.x = faceOffsets[ k ].x * mipSize - offset1 + mipOffsetX;
					planeMesh.position.y = faceOffsets[ k ].y * mipSize - offset1 + offset2 + mipOffsetY;
					planeMesh.material.side = THREE.DoubleSide;
					this.scene.add( planeMesh );
					this.objects.push( planeMesh );
	
				}
				mipOffsetY += 1.75 * mipSize;
				mipOffsetX += 1.25 * mipSize;
				mipSize /= 2;
	
			}
			offset2 += 2 * size;
			if ( size > 16 )
			size /= 2;
	
		}
	
	};
	
	THREE.PMREMCubeUVPacker.prototype = {
	
		constructor : THREE.PMREMCubeUVPacker,
	
		update: function( renderer ) {
	
			var gammaInput = renderer.gammaInput;
			var gammaOutput = renderer.gammaOutput;
			var toneMapping = renderer.toneMapping;
			var toneMappingExposure = renderer.toneMappingExposure;
			renderer.gammaInput = false;
			renderer.gammaOutput = false;
			renderer.toneMapping = THREE.LinearToneMapping;
			renderer.toneMappingExposure = 1.0;
			renderer.render( this.scene, this.camera, this.CubeUVRenderTarget, false );
	
			renderer.toneMapping = toneMapping;
			renderer.toneMappingExposure = toneMappingExposure;
			renderer.gammaInput = gammaInput;
			renderer.gammaOutput = gammaOutput;
	
		},
	
		getShader: function() {
	
			var shaderMaterial = new THREE.ShaderMaterial( {
	
				uniforms: {
					"faceIndex": { value: 0 },
					"mapSize": { value: 0 },
					"envMap": { value: null },
					"testColor": { value: new THREE.Vector3( 1, 1, 1 ) }
				},
	
				vertexShader:
					"precision highp float;\
					varying vec2 vUv;\
					void main() {\
						vUv = uv;\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\
					}",
	
				fragmentShader:
					"precision highp float;\
					varying vec2 vUv;\
					uniform samplerCube envMap;\
					uniform float mapSize;\
					uniform vec3 testColor;\
					uniform int faceIndex;\
					\
					void main() {\
						vec3 sampleDirection;\
						vec2 uv = vUv;\
						uv = uv * 2.0 - 1.0;\
						uv.y *= -1.0;\
						if(faceIndex == 0) {\
							sampleDirection = normalize(vec3(1.0, uv.y, -uv.x));\
						} else if(faceIndex == 1) {\
							sampleDirection = normalize(vec3(uv.x, 1.0, uv.y));\
						} else if(faceIndex == 2) {\
							sampleDirection = normalize(vec3(uv.x, uv.y, 1.0));\
						} else if(faceIndex == 3) {\
							sampleDirection = normalize(vec3(-1.0, uv.y, uv.x));\
						} else if(faceIndex == 4) {\
							sampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));\
						} else {\
							sampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));\
						}\
						vec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\
						gl_FragColor = linearToOutputTexel( color );\
					}",
	
				blending: THREE.CustomBlending,
				premultipliedAlpha: false,
				blendSrc: THREE.OneFactor,
				blendDst: THREE.ZeroFactor,
				blendSrcAlpha: THREE.OneFactor,
				blendDstAlpha: THREE.ZeroFactor,
				blendEquation: THREE.AddEquation
	
			} );
	
			return shaderMaterial;
	
		}
	
	};
	
	// File:examples/js/shaders/CopyShader.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Full-screen textured quad shader
	 */
	
	THREE.CopyShader = {
	
		uniforms: {
	
			"tDiffuse": { value: null },
			"opacity":  { value: 1.0 }
	
		},
	
		vertexShader: [
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
			"}"
	
		].join( "\n" ),
	
		fragmentShader: [
	
			"uniform float opacity;",
	
			"uniform sampler2D tDiffuse;",
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vec4 texel = texture2D( tDiffuse, vUv );",
				"gl_FragColor = opacity * texel;",
	
			"}"
	
		].join( "\n" )
	
	};
	
	// File:examples/js/shaders/CompositeShader.js
	
	/**
	 * @author bhouston / http://clara.io
	 *
	 * Various composite operations
	 */
	
	THREE.CompositeShader = {
	
	  defines: {
	
			"BLENDING": THREE.NoBlending
	
	  },
	
		uniforms: {
	
	    "tSource": { type: "t", value: null },
	    "opacitySource": { type: "f", value: 1.0 },
	
			"tDestination": { type: "t", value: null },
	    "opacityDestination": { type: "f", value: 1.0 }
	
		},
	
		vertexShader: [
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
			"}"
	
		].join( "\n" ),
	
		fragmentShader: [
	
	    "uniform sampler2D tSource;",
	    "uniform float opacitySource;",
	
			"uniform sampler2D tDestination;",
	    "uniform float opacityDestination;",
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vec4 d = opacityDestination * texture2D( tDestination, vUv );",
				"vec4 s = opacitySource * texture2D( tSource, vUv );",
	
	      // all blending modes are implemented assuming premultiplied values
	
	      "#if (BLENDING == " + THREE.NormalBlending + ")",
	
	        "gl_FragColor = d * ( 1.0 - s.a ) + s;",
	
	      "#elif (BLENDING == " + THREE.AdditiveBlending + ")",
	
	        "gl_FragColor = d + s;",
	
	      "#elif (BLENDING == " + THREE.SubtractiveBlending + ")",
	
	        "gl_FragColor = d - s;",
	
	      "#elif (BLENDING == " + THREE.MultiplyBlending + ")",
	
	        "gl_FragColor = d * s;",
	
	      "#else", // THREE.NoBlending
	
	        "gl_FragColor = s;",
	
	      "#endif",
	
			"}"
	
		].join( "\n" )
	
	};
	
	// File:examples/js/shaders/GlossyMirrorShader.js
	
	THREE.GlossyMirrorShader = {
	
		defines: {
			"SPECULAR_MAP": 0,
			"ROUGHNESS_MAP": 0,
			"GLOSSY_REFLECTIONS": 1,
			"REFLECTION_LOD_LEVELS": 4,
			"PERSPECTIVE_CAMERA": 1
		},
	
		uniforms: {
	
		 	"metalness": { type: "f", value: 0.0 },
	
		 	"specularColor": { type: "c", value: new THREE.Color( 0xffffff ) },
			"tSpecular": { type: "t", value: null },
	
			"tReflection": { type: "t", value: null },
			"tReflection1": { type: "t", value: null },
			"tReflection2": { type: "t", value: null },
			"tReflection3": { type: "t", value: null },
			"tReflection4": { type: "t", value: null },
			"tReflectionDepth": { type: "t", value: null },
	
			"roughness": { type: "f", value: 0.0 },
		 	"distanceFade": { type: "f", value: 0.01 },
		 	"fresnelStrength": { type: "f", value: 1.0 },
	
			"reflectionTextureMatrix" : { type: "m4", value: new THREE.Matrix4() },
			"mirrorCameraWorldMatrix": { type: "m4", value: new THREE.Matrix4() },
			"mirrorCameraProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
			"mirrorCameraInverseProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
			"mirrorCameraNear": { type: "f", value: 0 },
			"mirrorCameraFar": { type: "f", value: 0 },
			"screenSize": { type: "v2", value: new THREE.Vector2() },
			"mirrorNormal": { type: "v3", value: new THREE.Vector3() },
			"mirrorWorldPosition": { type: "v3", value: new THREE.Vector3() }
		},
	
		vertexShader: [
	
			"uniform mat4 reflectionTextureMatrix;",
	
			"varying vec4 mirrorCoord;",
			"varying vec3 vecPosition;",
			"varying vec3 worldNormal;",
			"varying vec2 vUv;",
	
			"void main() {",
				"vUv = uv;",
				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
				"vecPosition = cameraPosition - worldPosition.xyz;",
				"worldNormal = (modelMatrix * vec4(normal,0.0)).xyz;",
				"mirrorCoord = reflectionTextureMatrix * worldPosition;",
	
				"gl_Position = projectionMatrix * mvPosition;",
	
			"}"
	
		].join( "\n" ),
	
		blending: THREE.NormalBlending,
		transparent: true,
	
		fragmentShader: [
	
			"#include <common>",
			"#include <packing>",
			"#include <bsdfs>",
	
			"uniform float roughness;",
			"#if ROUGHNESS_MAP == 1",
				"uniform sampler2D tRoughness;",
			"#endif",
	
			"uniform float metalness;",
			"uniform float distanceFade;",
			"uniform float fresnelStrength;",
	
			"uniform vec3 specularColor;",
			"#if SPECULAR_MAP == 1",
				"uniform sampler2D tSpecular;",
			"#endif",
	
			"uniform sampler2D tReflection;",
			"#if GLOSSY_REFLECTIONS == 1",
				"uniform sampler2D tReflection1;",
				"uniform sampler2D tReflection2;",
				"uniform sampler2D tReflection3;",
				"uniform sampler2D tReflection4;",
				"uniform sampler2D tReflectionDepth;",
			"#endif",
	
			"varying vec3 vecPosition;",
			"varying vec3 worldNormal;",
			"varying vec2 vUv;",
	
			"varying vec4 mirrorCoord;",
			"uniform mat4 mirrorCameraProjectionMatrix;",
	 		"uniform mat4 mirrorCameraInverseProjectionMatrix;",
			"uniform mat4 mirrorCameraWorldMatrix;",
			"uniform float mirrorCameraNear;",
			"uniform float mirrorCameraFar;",
			"uniform vec2 screenSize;",
			"uniform vec3 mirrorNormal;",
			"uniform vec3 mirrorWorldPosition;",
	
			"#if GLOSSY_REFLECTIONS == 1",
	
				"float getReflectionDepth() {",
	
					"return unpackRGBAToDepth( texture2DProj( tReflectionDepth, mirrorCoord ) );",
	
		 		"}",
	
				"float getReflectionViewZ( const in float reflectionDepth ) {",
					"#if PERSPECTIVE_CAMERA == 1",
		 				"return perspectiveDepthToViewZ( reflectionDepth, mirrorCameraNear, mirrorCameraFar );",
					"#else",
						"return orthographicDepthToViewZ( reflectionDepth, mirrorCameraNear, mirrorCameraFar );",
					"#endif",
		 		"}",
	
		 		"vec3 getReflectionViewPosition( const in vec2 screenPosition, const in float reflectionDepth, const in float reflectionViewZ ) {",
	
		 			"float clipW = mirrorCameraProjectionMatrix[2][3] * reflectionViewZ + mirrorCameraProjectionMatrix[3][3];",
		 			"vec4 clipPosition = vec4( ( vec3( screenPosition, reflectionDepth ) - 0.5 ) * 2.0, 1.0 );",
		 			"clipPosition *= clipW;", // unprojection.
					"return ( mirrorCameraInverseProjectionMatrix * clipPosition ).xyz;",
	
		 		"}",
	
			"#endif",
	
			"vec4 getReflection( const in vec4 mirrorCoord, const in float lodLevel ) {",
	
				"#if GLOSSY_REFLECTIONS == 0",
	
					"return texture2DProj( tReflection, mirrorCoord );",
	
				"#else",
	
					"vec4 color0, color1;",
					"float alpha;",
	
					"if( lodLevel < 1.0 ) {",
						"color0 = texture2DProj( tReflection, mirrorCoord );",
						"color1 = texture2DProj( tReflection1, mirrorCoord );",
						"alpha = lodLevel;",
					"}",
					"else if( lodLevel < 2.0) {",
						"color0 = texture2DProj( tReflection1, mirrorCoord );",
						"color1 = texture2DProj( tReflection2, mirrorCoord );",
						"alpha = lodLevel - 1.0;",
					"}",
					"else if( lodLevel < 3.0 ) {",
						"color0 = texture2DProj( tReflection2, mirrorCoord );",
						"color1 = texture2DProj( tReflection3, mirrorCoord );",
						"alpha = lodLevel - 2.0;",
					"}",
					"else {",
						"color0 = texture2DProj( tReflection3, mirrorCoord );",
						"color1 = color0;",
						"alpha = 0.0;",
					"}",
	
					"return mix( color0, color1, alpha );",
	
				"#endif",
	
			"}",
	
			"void main() {",
	
				"vec3 specular = specularColor;",
				"#if SPECULAR_MAP == 1",
					"specular *= texture2D( tSpecular, vUv );",
				"#endif",
	
				"float fade = 1.0;",
	
				"#if GLOSSY_REFLECTIONS == 1",
	
					"float localRoughness = roughness;",
					"#if ROUGHNESS_MAP == 1",
						"localRoughness *= texture2D( tRoughness, vUv ).r;",
					"#endif",
	
					"vec2 screenPosition = gl_FragCoord.xy / screenSize;",
					"float reflectionDepth = getReflectionDepth();",
					"float reflectionViewZ = getReflectionViewZ( reflectionDepth );",
	
					"vec3 reflectionViewPosition = getReflectionViewPosition( screenPosition, reflectionDepth, reflectionViewZ );",
					"vec3 reflectionWorldPosition = ( mirrorCameraWorldMatrix * vec4( reflectionViewPosition, 1.0 ) ).xyz;",
	
					"vec3 closestPointOnMirror = projectOnPlane( reflectionWorldPosition, mirrorWorldPosition, mirrorNormal );",
	
	
					"vec3 pointOnMirror = linePlaneIntersect( cameraPosition, normalize( reflectionWorldPosition - cameraPosition ), mirrorWorldPosition, mirrorNormal );",
					"float distance = length( closestPointOnMirror - reflectionWorldPosition );",
	
	
					"localRoughness = localRoughness * distance * 0.2;",
					"float lodLevel = localRoughness;",
	
					"fade = 1.0 - ( distanceFade * distance );",
				"#else",
	
					"float lodLevel = 0.0;",
	
				"#endif",
	
				"vec4 reflection = getReflection( mirrorCoord, lodLevel );",
	
				// apply dieletric-conductor model parameterized by metalness parameter.
				"float dotNV = clamp( dot( normalize( worldNormal ), normalize( vecPosition ) ), EPSILON, 1.0 );",
				"specular = mix( vec3( 0.05 ), specular, metalness );",
				// TODO: Invert fresnel.
				"vec3 fresnel;",
				"if( fresnelStrength < 0.0 ) {",
					"fresnel = mix( specular, specular * pow( dotNV, 2.0 ), -fresnelStrength ) * pow( 1.0 - roughness, 2.0 );",
				"} else {",
					"fresnel = mix( specular, F_Schlick( specular, dotNV ), fresnelStrength ) * pow( 1.0 - roughness, 2.0 );",
				"}",
				"gl_FragColor = vec4( reflection.rgb, fresnel * fade * reflection.a );", // fresnel controls alpha
	
	
			"}"
	
			].join( "\n" )
	
	};
	// File:examples/js/shaders/SAOShader.js
	
	/**
	 * @author bhouston / http://clara.io/
	 *
	 * Scalable Ambient Occlusion
	 *
	 */
	
	THREE.ShaderChunk['sao'] = [
	
	"#include <packing>",
	
	"float getDepth( const in vec2 screenPosition ) {",
	
		"#if DEPTH_PACKING == 1",
			"return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
		"#else",
			"return texture2D( tDepth, screenPosition ).x;",
		"#endif",
	
	"}",
	
	"vec4 setDepth( const in float depth ) {",
	
		"#if DEPTH_PACKING == 1",
			"return packDepthToRGBA( depth );",
		"#else",
			"return vec4( depth, 0, 0, 0 );",
		"#endif",
	
	"}",
	
	"float getViewZ( const in float depth ) {",
	
		"#if PERSPECTIVE_CAMERA == 1",
			"return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
		"#else",
			"return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
		"#endif",
	
	"}"
	
	].join( "\n" );
	
	THREE.SAOShader = {
	
		blending: THREE.NoBlending,
	
		defines: {
			'NUM_SAMPLES': 13,
			'NUM_RINGS': 7,
			"NORMAL_TEXTURE": 0,
			"DIFFUSE_TEXTURE": 1,
			"DEPTH_PACKING": 1,
			"DEPTH_MIPS": 0,
			"PERSPECTIVE_CAMERA": 1
		},
	
		extensions: {
			'derivatives': true
		},
	
		uniforms: {
	
			"tDepth":       { type: "t", value: null },
			"tDepth1":       { type: "t", value: null },
			"tDepth2":       { type: "t", value: null },
			"tDepth3":       { type: "t", value: null },
	
			"tDiffuse":     { type: "t", value: null },
			"tNormal":      { type: "t", value: null },
			"size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
	
			"cameraNear":   { type: "f", value: 1 },
			"cameraFar":    { type: "f", value: 100 },
			"cameraProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
			"cameraInverseProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
	
			"intensity":    { type: "f", value: 0.1 },
	
			"occlusionSphereWorldRadius": { type: "f", value: 100.0 },
			"worldToScreenRatio": { type: "v2", value: new THREE.Vector2( 1, 1 ) },
			"randomSeed":   { type: "f", value: 0.0 }
		},
	
		vertexShader: [
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vUv = uv;",
	
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
			"}"
	
		].join( "\n" ),
	
		fragmentShader: [
	
	
			"#include <common>",
	
			"varying vec2 vUv;",
	
			"#if DIFFUSE_TEXTURE == 1",
				"uniform sampler2D tDiffuse;",
			"#endif",
	
			"#define MAX_MIP_LEVEL 3",
	
			"uniform sampler2D tDepth;",
	
			"#if DEPTH_MIPS == 1",
				"uniform sampler2D tDepth1;",
				"uniform sampler2D tDepth2;",
				"uniform sampler2D tDepth3;",
			"#endif",
	
			"#if NORMAL_TEXTURE == 1",
				"uniform sampler2D tNormal;",
			"#endif",
	
			"uniform float cameraNear;",
			"uniform float cameraFar;",
			"uniform mat4 cameraProjectionMatrix;",
			"uniform mat4 cameraInverseProjectionMatrix;",
	
			"uniform float intensity;",
			"uniform float occlusionSphereWorldRadius;",
			"uniform vec2 size;",
			"uniform vec2 worldToScreenRatio;",
			"uniform float randomSeed;",
	
	
			"#include <sao>",
	
			"vec4 getDefaultColor( const in vec2 screenPosition ) {",
	
				"#if DIFFUSE_TEXTURE == 1",
					"return texture2D( tDiffuse, vUv );",
				"#else",
					"return vec4( 1.0 );",
				"#endif",
	
			"}",
	
			"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {",
	
				"float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];",
				"vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );",
				"clipPosition *= clipW;", // unprojection.
				"return ( cameraInverseProjectionMatrix * clipPosition ).xyz;",
	
			"}",
	
			"vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {",
	
				"#if NORMAL_TEXTURE == 1",
					"return -unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );",
				"#else",
					"return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );",
				"#endif",
	
			"}",
	
			"float getDepthMIP( const in vec2 screenPosition, const int mipLevel ) {",
	
				"vec4 rawDepth;",
				"#if DEPTH_MIPS == 0",
					"rawDepth = texture2D( tDepth, screenPosition );",
				"#else",
					"if( mipLevel == 0 ) {",
						"rawDepth = texture2D( tDepth, screenPosition );",
					"}",
					"else if( mipLevel == 1 ) {",
						"rawDepth = texture2D( tDepth1, screenPosition );",
					"}",
					"else if( mipLevel == 2 ) {",
						"rawDepth = texture2D( tDepth2, screenPosition );",
					"}",
					"else {",
						"rawDepth = texture2D( tDepth3, screenPosition );",
					"}",
				"#endif",
	
				"#if DEPTH_PACKING == 1",
					"return unpackRGBAToDepth( rawDepth );",
				"#else",
					"return rawDepth.x;",
				"#endif",
	
			"}",
	
			"float scaleDividedByCameraFar;",
			"float minResolutionMultipliedByCameraFar;",
			"float errorCorrectionFactor;",
	
			"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {",
	
				"vec3 viewDelta = sampleViewPosition - centerViewPosition;",
				"float viewDistance2 = dot( viewDelta, viewDelta );",
	
				"return max( ( dot( centerViewNormal, viewDelta ) + centerViewPosition.z * 0.001 ) / ( viewDistance2 + 0.0001 ), 0.0 );// * smoothstep( pow2( occlusionSphereWorldRadius ), 0.0, viewDistance2 );",
	
			"}",
	
			/*
			"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {",
	
				"vec3 viewDelta = sampleViewPosition - centerViewPosition;",
				"float viewDistance2 = dot( viewDelta, viewDelta );",
	
				"return max( pow3( pow2( occlusionSphereWorldRadius ) - viewDistance2 ), 0.0 ) *",
					"max( ( dot( centerViewNormal, viewDelta ) - 0.01 * occlusionSphereWorldRadius ) / ( viewDistance2 + 0.0001 ), 0.0 );",
	
			"}",*/
	
			//"const float maximumScreenRadius = 10.0;",
	
			"int getMipLevel( const in vec2 occlusionSphereScreenRadius ) {",
	    		"return int( clamp( floor( log2( length( occlusionSphereScreenRadius * size ) ) - 4.0 ), 0.0, 3.0 ) );",
			"}",
	
			// moving costly divides into consts
			"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );",
			"const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );",
	
			"float getAmbientOcclusion( const in vec3 centerViewPosition ) {",
	
				// precompute some variables require in getOcclusion.
				"vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );",
	
				"vec2 invSize = 1.0 / size;",
	
				"vec2 occlusionSphereScreenRadius = occlusionSphereWorldRadius * worldToScreenRatio / centerViewPosition.z;",
	
				// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
				"float random = rand( vUv + randomSeed );",
				"float angle = random * PI2;",
				"float radiusStep = INV_NUM_SAMPLES;",
				"float radius = radiusStep * ( 0.5 + random );",
	
				"float occlusionSum = 0.0;",
	
				"for( int i = 0; i < NUM_SAMPLES; i ++ ) {",
					"radius = (float(i) + 0.5) * radiusStep;",
					"vec2 sampleUvOffset = vec2( cos( angle ), sin( angle ) ) * radius * occlusionSphereScreenRadius * 1.0;",
	
					// round to nearest true sample to avoid misalignments between viewZ and normals, etc.
					"sampleUvOffset = floor( sampleUvOffset * size + vec2( 0.5 ) ) * invSize;",
					"if( sampleUvOffset.x == 0.0 && sampleUvOffset.y == 0.0 ) continue;",
	
					"angle += ANGLE_STEP;",
	
					"vec2 sampleUv = vUv + sampleUvOffset;",
	
					"if( sampleUv.x <= 0.0 || sampleUv.y <= 0.0 || sampleUv.x >= 1.0 || sampleUv.y >= 1.0 ) continue;", // skip points outside of texture.
	
					//"int depthMipLevel = getMipLevel( radius * occlusionSphereScreenRadius );",
					"float sampleDepth = getDepthMIP( sampleUv, int( 4.0 * radius ) );",
					"if( sampleDepth >= ( 1.0 - EPSILON ) ) {",
						"continue;",
					"}",
	
					"float sampleViewZ = getViewZ( sampleDepth );",
					"vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );",
					"occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );",
	
				"}",
	
				"return occlusionSum * intensity * 2.0 * occlusionSphereWorldRadius / ( float( NUM_SAMPLES ) );",
				//"return occlusionSum * intensity * 5.0 / ( float( NUM_SAMPLES ) * pow( occlusionSphereWorldRadius, 6.0 ) );",
	
			"}",
	
	
			"void main() {",
	
				"float centerDepth = getDepth( vUv );",
				"if( centerDepth >= ( 1.0 - EPSILON ) ) {",
					"discard;",
				"}",
	
			/*	"float mipDepth = unpackRGBAToDepth( texture2D( tDepth3, vUv ) );",
				"gl_FragColor.xyz = vec3( (centerDepth - mipDepth) * 50.0 + 0.5 );",
				"gl_FragColor.a = 1.0;",
				"return;",*/
	
				"float centerViewZ = getViewZ( centerDepth );",
				"vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );",
	
				"float ambientOcclusion = getAmbientOcclusion( viewPosition );",
	
				//"gl_FragColor = getDefaultColor( vUv );",
	
				"gl_FragColor = packDepthToRGBA( centerDepth );",
				"gl_FragColor.x = max( 1.0 - ambientOcclusion, 0.0 );",
	
			"}"
	
		].join( "\n" )
	
	};
	
	// source: http://g3d.cs.williams.edu/websvn/filedetails.php?repname=g3d&path=%2FG3D10%2Fdata-files%2Fshader%2FAmbientOcclusion%2FAmbientOcclusion_minify.pix
	THREE.SAODepthMinifyShader = {
	
		blending: THREE.NoBlending,
	
		defines: {
			"DEPTH_PACKING": 1,
		//	"JITTERED_SAMPLING": 1
		},
	
		uniforms: {
	
			"tDepth":	{ type: "t", value: null },
			"cameraNear":   { type: "f", value: 1 },
			"cameraFar":    { type: "f", value: 100 },
			"size": { type: "v2", value: new THREE.Vector2( 256, 256 ) },
	
		},
	
		vertexShader: [
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vUv = uv;",
	
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
			"}"
	
		].join( "\n" ),
	
		fragmentShader: [
	
	
			"#include <common>",
			"#include <packing>",
	
			"varying vec2 vUv;",
	
			"uniform sampler2D tDepth;",
			"uniform vec2 size;",
			"uniform float cameraNear;",
			"uniform float cameraFar;",
	
			"void main() {",
	
	/*		g3d_FragColor.mask = texelFetch(
				CSZ_buffer,
				clamp(
					ssP * 2 + ivec2(ssP.y & 1, ssP.x & 1),
					ivec2(0),
					textureSize(CSZ_buffer, previousMIPNumber) - ivec2(1)),
				previousMIPNumber).mask;
	
		 }*/
	
		 		"vec2 uv = vUv;",
	
			//	"uv += ( round( vec2( rand( vUv * size ), rand( vUv * size + vec2( 0.333, 2.0 ) ) ) ) - 0.5 ) / size;",
				"vec2 invSize = 0.5 / size;",
	
				// NOTE: no need for depth decoding if nearest interpolation is used.
			/*	"float viewZ = 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, -1.0 ) ) ), cameraNear, cameraFar );",
				"viewZ += 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, 1.0 ) ) ), cameraNear, cameraFar );",
				"viewZ += 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, 1.0 ) ) ), cameraNear, cameraFar );",
				"viewZ += 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, -1.0 ) ) ), cameraNear, cameraFar );",
				"viewZ *= 0.25;",
				"gl_FragColor = packDepthToRGBA( viewZToPerspectiveDepth( 1.0 / viewZ, cameraNear, cameraFar ) );",*/
				"float depth = unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, -1.0 ) ) );",
				"depth += unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, 1.0 ) ) );",
				"depth += unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, 1.0 ) ) );",
				"depth += unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, -1.0 ) ) );",
				"depth *= 0.25;",
				"gl_FragColor = packDepthToRGBA( depth );",
			"}"
	
		].join( "\n" )
	
	};
	
	THREE.SAOBilaterialFilterShader = {
	
		blending: THREE.NoBlending,
	
		defines: {
			"PERSPECTIVE_CAMERA": 1,
			"KERNEL_SAMPLE_RADIUS": 4,
		},
	
		uniforms: {
	
			"tAODepth":	{ type: "t", value: null },
			"tAONormal":	{ type: "t", value: null },
			"size": { type: "v2", value: new THREE.Vector2( 256, 256 ) },
	
			"kernelDirection": { type: "v2", value: new THREE.Vector2( 1, 0 ) },
	
			"cameraNear":   { type: "f", value: 1 },
			"cameraFar":    { type: "f", value: 100 },
			"edgeSharpness":    { type: "f", value: 3 },
			"packOutput":    { type: "f", value: 1 }
	
		},
	
		vertexShader: [
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vUv = uv;",
	
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
			"}"
	
		].join( "\n" ),
	
		fragmentShader: [
	
			"#include <common>",
	
			"varying vec2 vUv;",
	
			"uniform sampler2D tAODepth;",
			"uniform sampler2D tAONormal;",
			"uniform vec2 size;",
	
			"uniform float cameraNear;",
			"uniform float cameraFar;",
			"uniform float edgeSharpness;",
			"uniform int packOutput;",
	
			"uniform vec2 kernelDirection;",
	
			"#include <packing>",
	
			"float getViewZ( const in float depth ) {",
	
				"#if PERSPECTIVE_CAMERA == 1",
					"return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
				"#else",
					"return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
				"#endif",
	
			"}",
	
			"void addTapInfluence( const in vec2 tapUv, const in vec3 centerNormal, const in float centerViewZ, const in float kernelWeight, inout float aoSum, inout float weightSum ) {",
	
				"vec4 depthTexel = texture2D( tAODepth, tapUv );",
				"float ao = depthTexel.r;",
				"depthTexel.r = 1.0;",
				"float depth = unpackRGBAToDepth( depthTexel );",
	
				"if( depth >= ( 1.0 - EPSILON ) ) {",
					"return;",
				"}",
	
				"float tapViewZ = -getViewZ( depth );",
				"float depthWeight = max(0.0, 1.0 - (edgeSharpness * 20.0) * abs(tapViewZ - centerViewZ));",
	
				"vec3 normal = unpackRGBToNormal(texture2D(tAONormal, tapUv).rgb);",
				"float normalCloseness = dot(normal, centerNormal);",
				"float k_normal = 4.0;",
				"float normalError = (1.0 - pow4( normalCloseness )) * k_normal;",
				"float normalWeight = max((1.0 - edgeSharpness * normalError), 0.00);",
	
				"float tapWeight = kernelWeight * ( depthWeight + normalWeight );",
	
				"aoSum += ao * tapWeight;",
				"weightSum += tapWeight;",
			"}",
	
			"float normpdf(in float x, in float sigma) {",
				"return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;",
			"}",
	
			"void main() {",
	
				"vec4 depthTexel = texture2D( tAODepth, vUv );",
				"float ao = depthTexel.r;",
				"depthTexel.r = 1.0;",
				"float depth = unpackRGBAToDepth( depthTexel );",
				"if( depth >= ( 1.0 - EPSILON ) ) {",
					"discard;",
				"}",
	
				"float centerViewZ = -getViewZ( depth );",
	
				"float weightSum = normpdf(0.0, 5.0) + 0.1;",
				"float aoSum = ao * weightSum;",
	
				"vec2 uvIncrement = ( kernelDirection / size );",
	
				"vec2 rTapUv = vUv, lTapUv = vUv;",
				"vec3 normalCenter = unpackRGBToNormal(texture2D(tAONormal, vUv).rgb);",
	
				"for( int i = 1; i <= KERNEL_SAMPLE_RADIUS; i ++ ) {",
	
					"float kernelWeight = normpdf(float(i), 5.0) + 0.1;",
	
					"rTapUv += uvIncrement;",
					"addTapInfluence( rTapUv, normalCenter, centerViewZ, kernelWeight, aoSum, weightSum );",
	
					"lTapUv -= uvIncrement;",
					"addTapInfluence( lTapUv, normalCenter, centerViewZ, kernelWeight, aoSum, weightSum );",
	
				"}",
	
				"ao = aoSum / weightSum;",
				"if( packOutput == 1 ) {",
					"gl_FragColor = depthTexel;",
					"gl_FragColor.r = ao;",
				"}",
				"else {",
					"gl_FragColor = vec4( vec3( ao ), 1.0 );",
				"}",
	
			"}"
	
		].join( "\n" )
	
	};
	
	// File:examples/js/shaders/BlurShader.js
	
	/**
	 * @author bhouston / http://clara.io
	 *
	 * For a horizontal blur, use X_STEP 1, Y_STEP 0
	 * For a vertical blur, use X_STEP 0, Y_STEP 1
	 *
	 */
	
	THREE.BlurShader = {
	
		defines: {
	
			"KERNEL_RADIUS": 4
	
		},
	
		uniforms: {
	
			"tDiffuse":         { type: "t", value: null },
			"size":             { type: "v2", value: new THREE.Vector2( 512, 512 ) },
			"sampleUvOffsets":  { type: "v2v", value: [ new THREE.Vector2( 0, 0 ) ] },
			"sampleWeights":    { type: "1fv", value: [ 1.0 ] },
	
		},
	
		vertexShader: [
	
			"#include <common>",
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vUv = uv;",
	
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
			"}"
	
		].join( "\n" ),
	
		fragmentShader: [
	
			"uniform sampler2D tDiffuse;",
			"uniform vec2 size;",
	
			"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];",
			"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];",
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vec2 invSize = 1.0 / size;",
	
				"float weightSum = sampleWeights[0];",
				"vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;",
	
				"for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {",
	
					"float weight = sampleWeights[i];",
					"vec2 sampleUvOffset = sampleUvOffsets[i] * invSize;",
					"diffuseSum += ( texture2D( tDiffuse, vUv + sampleUvOffset ) + texture2D( tDiffuse, vUv - sampleUvOffset ) ) * weight;",
					"weightSum += 2.0 * weight;",
	
				"}",
	
				"gl_FragColor =diffuseSum / weightSum;",
	
			"}"
	
		].join( "\n" )
	
	};
	
	
	THREE.BlurShaderUtils = {
	
		createSampleWeights: function( kernelRadius, stdDev ) {
	
			var gaussian = function( x, stdDev ) {
				return Math.exp( - ( x*x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );
			};
	
			var weights = [];
	
			for( var i = 0; i <= kernelRadius; i ++ ) {
				weights.push( gaussian( i, stdDev ) );
			}
	
			return weights;
		},
	
		createSampleOffsets: function( kernelRadius, uvIncrement ) {
	
			var offsets = [];
	
			for( var i = 0; i <= kernelRadius; i ++ ) {
				offsets.push( uvIncrement.clone().multiplyScalar( i ) );
			}
	
			return offsets;
	
		},
	
		configure: function( material, kernelRadius, stdDev, uvIncrement ) {
	
			kernelRadius = kernelRadius | 0;
	
			if( ( material.defines[ 'KERNEL_RADIUS' ] !== kernelRadius ) || ( material.stdDev != stdDev ) ) {
	
				material.defines[ 'KERNEL_RADIUS' ] = kernelRadius;
				material.uniforms[ 'sampleUvOffsets' ].value = THREE.BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );
				material.uniforms[ 'sampleWeights' ].value = THREE.BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );
	
				material.uvIncrement = uvIncrement;
				material.stdDev = stdDev;
	
				material.needsUpdate = true;
			}
	
		}
	
	};
	
	// File:examples/js/postprocessing/EffectComposer.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.EffectComposer = function ( renderer, renderTarget ) {
	
		this.renderer = renderer;
	
		if ( renderTarget === undefined ) {
	
			var parameters = {
				minFilter: THREE.LinearFilter,
				magFilter: THREE.LinearFilter,
				format: THREE.RGBAFormat,
				stencilBuffer: false
			};
			var size = renderer.getSize();
			renderTarget = new THREE.WebGLRenderTarget( size.width, size.height, parameters );
	
		}
	
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
	
		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;
	
		this.passes = [];
	
		if ( THREE.CopyShader === undefined )
			console.error( "THREE.EffectComposer relies on THREE.CopyShader" );
	
		this.copyPass = new THREE.ShaderPass( THREE.CopyShader );
	
	};
	
	Object.assign( THREE.EffectComposer.prototype, {
	
		swapBuffers: function() {
	
			var tmp = this.readBuffer;
			this.readBuffer = this.writeBuffer;
			this.writeBuffer = tmp;
	
		},
	
		addPass: function ( pass ) {
	
			this.passes.push( pass );
	
			var size = this.renderer.getSize();
			pass.setSize( size.width, size.height );
	
		},
	
		insertPass: function ( pass, index ) {
	
			this.passes.splice( index, 0, pass );
	
		},
	
		render: function ( delta ) {
	
			var maskActive = false;
	
			var pass, i, il = this.passes.length;
	
			for ( i = 0; i < il; i ++ ) {
	
				pass = this.passes[ i ];
	
				if ( pass.enabled === false ) continue;
	
				pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );
	
				if ( pass.needsSwap ) {
	
					if ( maskActive ) {
	
						var context = this.renderer.context;
	
						context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
	
						this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );
	
						context.stencilFunc( context.EQUAL, 1, 0xffffffff );
	
					}
	
					this.swapBuffers();
	
				}
	
				if ( THREE.MaskPass !== undefined ) {
	
					if ( pass instanceof THREE.MaskPass ) {
	
						maskActive = true;
	
					} else if ( pass instanceof THREE.ClearMaskPass ) {
	
						maskActive = false;
	
					}
	
				}
	
			}
	
		},
	
		reset: function ( renderTarget ) {
	
			if ( renderTarget === undefined ) {
	
				var size = this.renderer.getSize();
	
				renderTarget = this.renderTarget1.clone();
				renderTarget.setSize( size.width, size.height );
	
			}
	
			this.renderTarget1.dispose();
			this.renderTarget2.dispose();
			this.renderTarget1 = renderTarget;
			this.renderTarget2 = renderTarget.clone();
	
			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;
	
		},
	
		setSize: function ( width, height ) {
	
			this.renderTarget1.setSize( width, height );
			this.renderTarget2.setSize( width, height );
	
			for ( var i = 0; i < this.passes.length; i ++ ) {
	
				this.passes[i].setSize( width, height );
	
			}
	
		}
	
	} );
	
	
	THREE.Pass = function () {
	
		// if set to true, the pass is processed by the composer
		this.enabled = true;
	
		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;
	
		// if set to true, the pass clears its buffer before rendering
		this.clear = false;
	
		// if set to true, the result of the pass is rendered to screen
		this.renderToScreen = false;
	
	};
	
	Object.assign( THREE.Pass.prototype, {
	
		setSize: function( width, height ) {},
	
		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			console.error( "THREE.Pass: .render() must be implemented in derived pass." );
	
		}
	
	} );
	
	// File:examples/js/postprocessing/RenderPass.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {
	
		THREE.Pass.call( this );
	
		this.scene = scene;
		this.camera = camera;
	
		this.overrideMaterial = overrideMaterial;
	
		this.clearColor = clearColor;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;
	
		this.clear = true;
		this.needsSwap = false;
	
	};
	
	THREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {
	
		constructor: THREE.RenderPass,
	
		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			var oldAutoClear = renderer.autoClear;
			renderer.autoClear = false;
	
			this.scene.overrideMaterial = this.overrideMaterial;
	
			var oldClearColor, oldClearAlpha;
	
			if ( this.clearColor !== undefined ) {
	
				oldClearColor = renderer.getClearColor();
				oldClearAlpha = renderer.getClearAlpha();
	
				renderer.setClearColor( this.clearColor, this.clearAlpha );
	
			}
	
			renderer.renderOverride( this.overrideMaterial, this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );
	
			if ( this.clearColor ) {
	
				renderer.setClearColor( oldClearColor, oldClearAlpha );
	
			}
	
			this.scene.overrideMaterial = null;
			renderer.autoClear = oldAutoClear;
	
		}
	
	} );
	
	// File:examples/js/postprocessing/MaskPass.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MaskPass = function ( scene, camera ) {
	
		THREE.Pass.call( this );
	
		this.scene = scene;
		this.camera = camera;
	
		this.clear = true;
		this.needsSwap = false;
	
		this.inverse = false;
	
	};
	
	THREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {
	
		constructor: THREE.MaskPass,
	
		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			var context = renderer.context;
			var state = renderer.state;
	
			// don't update color or depth
	
			state.buffers.color.setMask( false );
			state.buffers.depth.setMask( false );
	
			// lock buffers
	
			state.buffers.color.setLocked( true );
			state.buffers.depth.setLocked( true );
	
			// set up stencil
	
			var writeValue, clearValue;
	
			if ( this.inverse ) {
	
				writeValue = 0;
				clearValue = 1;
	
			} else {
	
				writeValue = 1;
				clearValue = 0;
	
			}
	
			state.buffers.stencil.setTest( true );
			state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
			state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
			state.buffers.stencil.setClear( clearValue );
	
			// draw into the stencil buffer
	
			renderer.render( this.scene, this.camera, readBuffer, this.clear );
			renderer.render( this.scene, this.camera, writeBuffer, this.clear );
	
			// unlock color and depth buffer for subsequent rendering
	
			state.buffers.color.setLocked( false );
			state.buffers.depth.setLocked( false );
	
			// only render where stencil is set to 1
	
			state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
			state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );
	
		}
	
	} );
	
	
	THREE.ClearMaskPass = function () {
	
		THREE.Pass.call( this );
	
		this.needsSwap = false;
	
	};
	
	THREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );
	
	Object.assign( THREE.ClearMaskPass.prototype, {
	
		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			renderer.state.buffers.stencil.setTest( false );
	
		}
	
	} );
	
	// File:examples/js/postprocessing/ShaderPass.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ShaderPass = function ( shader, textureID ) {
	
		THREE.Pass.call( this );
	
		this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";
	
		if ( shader instanceof THREE.ShaderMaterial ) {
	
			this.uniforms = shader.uniforms;
	
			this.material = shader;
	
		} else if ( shader ) {
	
			this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
			this.material = new THREE.ShaderMaterial( {
	
				defines: shader.defines || {},
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
	
			} );
	
		}
	
	};
	
	THREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {
	
		constructor: THREE.ShaderPass,
	
		render: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			if ( this.uniforms[ this.textureID ] ) {
	
				this.uniforms[ this.textureID ].value = readBuffer.texture;
	
			}
	
			if ( this.renderToScreen ) {
	
				renderer.renderPass( this.material );
	
			} else {
	
				renderer.renderPass( this.material, writeBuffer, this.clear );
	
			}
	
		}
	
	} );
	
	// File:examples/js/postprocessing/SAOPass.js
	
	/**
	*
	* Scalable Ambient Occlusion
	*
	* @author bhouston / http://clara.io/
	*
	*
	*/
	
	THREE.SAOPass = function ( scene, camera ) {
	
		THREE.Pass.call( this );
	
		this.scene = scene;
		this.camera = camera;
	
		this.intensity = 0.5;
		this.implicitNormals = false; // explicit normals requires or there are artifacts on mobile.
		this.occlusionSphereWorldRadius = 20;
		this.blurEnabled = true;
		this.outputOverride = null; // 'beauty', 'depth', 'sao'
		this.depthMIPs = false;
		this.downSamplingRatio = 2;
		this.blurKernelSize = (this.downSamplingRatio === 1) ? 8 : 6;
		this.edgeSharpness = 1;
	
		/*
		if ( false && renderer.extensions.get('WEBGL_depth_texture') ) {
	
			console.log( "using depth extension");
	
			this.depthTexture = optionalBuffers.depthTexture || new THREE.DepthTexture();
			this.depthTexture.type = isWebGL2 ? THREE.FloatType : THREE.UnsignedShortType;
			this.depthTexture.minFilter = THREE.NearestFilter;
			this.depthTexture.maxFilter = THREE.NearestFilter;
	
			this.beautyRenderTarget.depthBuffer = true;
			this.beautyRenderTarget.depthTexture = this.depthTexture;
	
		}*/
	
		this.depthMaterial = new THREE.MeshDepthMaterial();
		this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
		this.depthMaterial.blending = THREE.NoBlending;
		this.depthMaterial.side = THREE.DoubleSide;
	
		this.normalMaterial = new THREE.MeshNormalMaterial();
	
		if ( THREE.SAOShader === undefined )	console.error( "THREE.SAOPass relies on THREE.SAOShader" );
		if ( THREE.CopyShader === undefined )	console.error( "THREE.SAOPass relies on THREE.CopyShader" );
	
		this.depthMinifyMaterial = new THREE.ShaderMaterial( THREE.SAODepthMinifyShader );
		this.depthMinifyMaterial.uniforms = THREE.UniformsUtils.clone( this.depthMinifyMaterial.uniforms );
		this.depthMinifyMaterial.defines = THREE.UniformsUtils.cloneDefines( this.depthMinifyMaterial.defines );
		this.depthMinifyMaterial.blending = THREE.NoBlending;
	
		this.saoMaterial = new THREE.ShaderMaterial( THREE.SAOShader );
		this.saoMaterial.uniforms = THREE.UniformsUtils.clone( this.saoMaterial.uniforms );
		this.saoMaterial.defines = THREE.UniformsUtils.cloneDefines( this.saoMaterial.defines );
		this.saoMaterial.defines[ 'DIFFUSE_TEXTURE' ] = 0;
		this.saoMaterial.defines[ 'NORMAL_TEXTURE' ] = this.implicitNormals ? 0 : 1;
		this.saoMaterial.defines[ 'MODE' ] = 2;
	
		this.bilateralFilterMaterial = new THREE.ShaderMaterial( THREE.SAOBilaterialFilterShader );
		this.bilateralFilterMaterial.uniforms = THREE.UniformsUtils.clone( this.bilateralFilterMaterial.uniforms );
		this.bilateralFilterMaterial.defines = THREE.UniformsUtils.cloneDefines( this.bilateralFilterMaterial.defines );
		this.bilateralFilterMaterial.blending = THREE.NoBlending;
		this.bilateralFilterMaterial.premultipliedAlpha = true;
	
		this.bilateralUpsamplerMaterial = this.getBilateralUpsamplerMaterial();
	
		this.copyMaterial = new THREE.ShaderMaterial( THREE.CopyShader );
		this.copyMaterial.uniforms = THREE.UniformsUtils.clone( this.copyMaterial.uniforms );
		this.copyMaterial.uniforms['opacity'].value = 1.0;
		this.copyMaterial.blending = THREE.NoBlending;
		this.copyMaterial.premultipliedAlpha = true;
		this.copyMaterial.transparent = true;
		this.copyMaterial.depthTest = false;
		this.copyMaterial.depthWrite = false;
	
	};
	
	THREE.SAOPass.prototype = {
	
		dispose: function() {
	
			if( this.saoRenderTarget ) {
				this.saoRenderTarget.dispose();
				this.saoRenderTarget = null;
			}
			if( this.blurIntermediateRenderTarget ) {
				this.blurIntermediateRenderTarget.dispose();
				this.blurIntermediateRenderTarget = null;
			}
			if( this.depthRenderTarget ) {
				this.depthRenderTarget.dispose();
				this.depthRenderTarget = null;
			}
			if( this.depth1RenderTarget ) {
				this.depth1RenderTarget.dispose();
				this.depth1RenderTarget = null;
			}
			if( this.depth2RenderTarget ) {
				this.depth2RenderTarget.dispose();
				this.depth2RenderTarget = null;
			}
			if( this.depth3RenderTarget ) {
				this.depth3RenderTarget.dispose();
				this.depth3RenderTarget = null;
			}
			if( this.normalRenderTarget ) {
				this.normalRenderTarget.dispose();
				this.normalRenderTarget = null;
			}
			if( this.normalRenderTargetFullRes ) {
				this.normalRenderTargetFullRes.dispose();
				this.normalRenderTargetFullRes = null;
			}
			if( this.depthRenderTargetFullRes ) {
				this.depthRenderTargetFullRes.dispose();
				this.depthRenderTargetFullRes = null;
			}
			if( this.saoRenderTargetFullRes ) {
				this.saoRenderTargetFullRes.dispose();
				this.saoRenderTargetFullRes = null;
			}
		},
	
		setSize: function ( width, height ) {
	
			if( this.saoRenderTargetFullRes ) this.saoRenderTargetFullRes.setSize( width, height );
			if( this.depthRenderTargetFullRes ) this.depthRenderTargetFullRes.setSize( width, height );
			if( this.normalRenderTargetFullRes ) this.normalRenderTargetFullRes.setSize( width, height );
			width = Math.ceil( width / this.downSamplingRatio );
			height = Math.ceil( height / this.downSamplingRatio );
			if( this.saoRenderTarget ) this.saoRenderTarget.setSize( width, height );
			if( this.blurIntermediateRenderTarget ) this.blurIntermediateRenderTarget.setSize( width, height );
			if( this.depthRenderTarget ) this.depthRenderTarget.setSize( width, height );
			if( this.depth1RenderTarget ) this.depth1RenderTarget.setSize( Math.ceil( width / 2 ), Math.ceil( height / 2 ) );
			if( this.depth2RenderTarget ) this.depth2RenderTarget.setSize( Math.ceil( width / 4 ), Math.ceil( height / 4 ) );
			if( this.depth3RenderTarget ) this.depth3RenderTarget.setSize( Math.ceil( width / 8 ), Math.ceil( height / 8 ) );
			if( this.normalRenderTarget ) this.normalRenderTarget.setSize( width, height );
	
			this.saoMaterial.uniforms[ 'size' ].value.set( width, height );
			this.bilateralFilterMaterial.uniforms[ 'size' ].value.set( width, height );
			//console.log( 'downsampledsize: ', width, height );
		},
	
		updateParameters: function( camera ) {
	
			var vSizeAt1M = 1 / ( Math.tan( THREE.Math.DEG2RAD * camera.fov * 0.5 ) * 2 );
			var sizeAt1M = new THREE.Vector2( vSizeAt1M / camera.aspect, vSizeAt1M );
	
			this.saoMaterial.uniforms['worldToScreenRatio'].value = sizeAt1M;
			this.saoMaterial.uniforms['intensity'].value = this.intensity;
			this.saoMaterial.uniforms['occlusionSphereWorldRadius'].value = this.occlusionSphereWorldRadius;
	
			this.depthMinifyMaterial.uniforms[ 'cameraNear' ].value = camera.near;
			this.depthMinifyMaterial.uniforms[ 'cameraFar' ].value = camera.far;
	
			this.saoMaterial.uniforms[ 'cameraNear' ].value = camera.near;
			this.saoMaterial.uniforms[ 'cameraFar' ].value = camera.far;
			this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = camera.projectionMatrix;
			this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( camera.projectionMatrix );
	
			this.bilateralFilterMaterial.uniforms[ "cameraNear" ].value = camera.near;
			this.bilateralFilterMaterial.uniforms[ "cameraFar" ].value = camera.far;
		},
	
		render: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			var width = readBuffer.width, height = readBuffer.height;
	
			width = Math.ceil( width / this.downSamplingRatio );
			height = Math.ceil( height / this.downSamplingRatio );
	
			var depthTexture = ( readBuffer.depthBuffer && readBuffer.depthTexture ) ? readBuffer.depthTexture : null;
	
			if ( ! this.saoRenderTarget ) {
	
				this.saoRenderTarget = new THREE.WebGLRenderTarget( width, height,
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.saoRenderTargetFullRes = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
						{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.blurIntermediateRenderTarget = new THREE.WebGLRenderTarget( width, height,
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.depth1RenderTarget = new THREE.WebGLRenderTarget( Math.ceil( width / 2 ), Math.ceil( height / 2 ),
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.depth2RenderTarget = new THREE.WebGLRenderTarget( Math.ceil( width / 4 ), Math.ceil( height / 4 ),
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.depth3RenderTarget = new THREE.WebGLRenderTarget( Math.ceil( width / 8 ), Math.ceil( height / 8 ),
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.normalRenderTarget = new THREE.WebGLRenderTarget( width, height,
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
				this.normalRenderTargetFullRes = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
					{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );
			}
	
			if( ! depthTexture && ! this.depthRenderTarget ) {
	
				this.depthRenderTarget = new THREE.WebGLRenderTarget( width, height,
					{ minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
				this.depthRenderTargetFullRes = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
					{ minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
	
			}
	
			this.updateParameters( this.camera );
	
			var clearColor = renderer.getClearColor(), clearAlpha = renderer.getClearAlpha(), autoClear = renderer.autoClear;
			renderer.autoClear = false;
	
			if( ! this.renderToScreen ) {
	
				this.copyMaterial.uniforms[ 'tDiffuse' ].value = readBuffer.texture;
				this.copyMaterial.blending = THREE.NoBlending;
	
				renderer.renderPass( this.copyMaterial, writeBuffer, true );
	
			}
	
			var depthPackingMode = 0;
	
			if( ! depthTexture ) {
	
				var oldClearColor = renderer.getClearColor(), oldClearAlpha = renderer.getClearAlpha();
				renderer.setClearColor( 0xffffff, 1.0 );
	
				renderer.renderOverride( this.depthMaterial, this.scene, this.camera, this.depthRenderTarget, true );
	
				renderer.setClearColor( 0xffffff, 1.0 );
	
				if( this.downSamplingRatio !== 1.0 ) {
	
					renderer.renderOverride( this.depthMaterial, this.scene, this.camera, this.depthRenderTargetFullRes, true );
	
					renderer.setClearColor( oldClearColor, oldClearAlpha );
	
				}
				depthTexture = this.depthRenderTarget.texture;
				depthPackingMode = 1;
	
			}
	
			if( this.depthMIPs ) {
	
				this.depthMinifyMaterial.uniforms['tDepth'].value = depthTexture;
				this.depthMinifyMaterial.uniforms['size'].value.set( width, height );
				renderer.renderPass( this.depthMinifyMaterial, this.depth1RenderTarget, true );
	
				this.depthMinifyMaterial.uniforms['tDepth'].value = this.depth1RenderTarget.texture;
				this.depthMinifyMaterial.uniforms['size'].value.set( Math.ceil( width / 2 ), Math.ceil( height / 2 ) );
				renderer.renderPass( this.depthMinifyMaterial, this.depth2RenderTarget, true );
	
				this.depthMinifyMaterial.uniforms['tDepth'].value = this.depth2RenderTarget.texture;
				this.depthMinifyMaterial.uniforms['size'].value.set( Math.ceil( width / 4 ), Math.ceil( height / 4 ) );
				renderer.renderPass( this.depthMinifyMaterial, this.depth3RenderTarget, true );
	
			}
	
			if( this.outputOverride === "depth" ) {
	
				this.copyMaterial.uniforms[ 'tDiffuse' ].value = depthTexture;
				this.copyMaterial.blending = THREE.NoBlending;
	
				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;
	
			}
			if( this.outputOverride === "depth1" ) {
	
				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.depth1RenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;
	
				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;
	
			}
			if( this.outputOverride === "depth2" ) {
	
				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.depth2RenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;
	
				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;
	
			}
			if( this.outputOverride === "depth3" ) {
	
				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.depth3RenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;
	
				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;
	
			}
	
			if( ! this.implicitNormals ) {
	
				var oldClearColor = renderer.getClearColor(), oldClearAlpha = renderer.getClearAlpha();
				renderer.setClearColor( new THREE.Color( 0.5, 0.5, 1.0 ), 1.0 );
	
				renderer.renderOverride( this.normalMaterial, this.scene, this.camera, this.normalRenderTarget, true );
	
				if( this.downSamplingRatio !== 1.0 ) {
	
						renderer.setClearColor( new THREE.Color( 0.5, 0.5, 1.0 ), 1.0 );
	
						renderer.renderOverride( this.normalMaterial, this.scene, this.camera, this.normalRenderTargetFullRes, true );
	
				}
	
				renderer.setClearColor( oldClearColor, oldClearAlpha );
	
			}
	
			if( this.outputOverride === "normal" ) {
	
				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;
	
				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : this.renderToScreen ? null : writeBuffer, true );
				return;
	
			}
	
			this.saoMaterial.defines[ 'DEPTH_PACKING' ] = depthPackingMode;
			this.saoMaterial.defines[ 'DEPTH_MIPS' ] = this.depthMIPs ? 1 : 0;
			this.saoMaterial.uniforms[ "tNormal" ].value = this.normalRenderTarget.texture;
			this.saoMaterial.uniforms[ "tDepth" ].value = depthTexture;
			if( this.depthMIPs ) {
	
				this.saoMaterial.uniforms[ "tDepth1" ].value = this.depth1RenderTarget.texture;
				this.saoMaterial.uniforms[ "tDepth2" ].value = this.depth2RenderTarget.texture;
				this.saoMaterial.uniforms[ "tDepth3" ].value = this.depth3RenderTarget.texture;
			}
	
			var oldClearColor = renderer.getClearColor(), oldClearAlpha = renderer.getClearAlpha();
			renderer.setClearColor( 0xffffff, 1.0 );
	
			renderer.renderPass( this.saoMaterial, this.saoRenderTarget, true ); // , 0xffffff, 0.0, "sao"
	
			if( this.blurEnabled ) {
	
				this.bilateralFilterMaterial.defines[ 'KERNEL_SAMPLE_RADIUS' ] = this.blurKernelSize;
				this.bilateralFilterMaterial.uniforms[ "tAODepth" ].value = this.saoRenderTarget.texture;
				this.bilateralFilterMaterial.uniforms[ "tAONormal" ].value = this.normalRenderTarget.texture;
				this.bilateralFilterMaterial.uniforms[ "kernelDirection" ].value = new THREE.Vector2( 1, 0 );
				this.bilateralFilterMaterial.uniforms[ "packOutput" ].value = 1;
				this.bilateralFilterMaterial.uniforms[ 'edgeSharpness' ].value = this.edgeSharpness;
	
				renderer.renderPass( this.bilateralFilterMaterial, this.blurIntermediateRenderTarget, true ); // , 0xffffff, 0.0, "sao vBlur"
	
				this.bilateralFilterMaterial.uniforms[ "tAODepth" ].value = this.blurIntermediateRenderTarget.texture;
				this.bilateralFilterMaterial.uniforms[ "kernelDirection" ].value = new THREE.Vector2( 0, 1 );
				this.bilateralFilterMaterial.uniforms[ "packOutput" ].value = 0;
	
				renderer.renderPass( this.bilateralFilterMaterial, this.saoRenderTarget, true ); // 0xffffff, 0.0, "sao hBlur"
	
			}
			if(this.downSamplingRatio > 1.0)
			{
				//Bilateral Up sampler
				this.bilateralUpsamplerMaterial.uniforms["inputTexture"].value = this.saoRenderTarget.texture;
				this.bilateralUpsamplerMaterial.uniforms["NormalTextureFullRes"].value = this.normalRenderTargetFullRes.texture;
				this.bilateralUpsamplerMaterial.uniforms["DepthTextureFullRes"].value = this.depthRenderTargetFullRes.texture;
				this.bilateralUpsamplerMaterial.uniforms["NormalTextureHalfRes"].value = this.normalRenderTarget.texture;
				this.bilateralUpsamplerMaterial.uniforms["DepthTextureHalfRes"].value = this.depthRenderTarget.texture;
				this.bilateralUpsamplerMaterial.uniforms["texSize"].value = new THREE.Vector2(this.saoRenderTarget.width, this.saoRenderTarget.height);
				this.bilateralUpsamplerMaterial.uniforms["cameraNearFar"].value = new THREE.Vector2(this.camera.near, this.camera.far);
				renderer.renderPass( this.bilateralUpsamplerMaterial, this.saoRenderTargetFullRes, true ); // 0xffffff, 0.0, "sao hBlur"
	
			}
			renderer.setClearColor( oldClearColor, oldClearAlpha );
	
			if( this.outputOverride === "sao" ) {
	
				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.downSamplingRatio > 1.0 ? this.saoRenderTargetFullRes.texture
				: this.saoRenderTarget.texture;
				this.copyMaterial.blending = THREE.NoBlending;
	
				renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, true );
				return;
	
			}
	
			renderer.autoClear = false;
	
			this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.downSamplingRatio > 1.0 ? this.saoRenderTargetFullRes.texture
			: this.saoRenderTarget.texture;
			this.copyMaterial.blending = THREE.MultiplyBlending;
			this.copyMaterial.premultipliedAlpha = true;
	
			renderer.renderPass( this.copyMaterial, this.renderToScreen ? null : writeBuffer, false );
	
			renderer.autoClear = autoClear;
			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha );
	
		},
	
		getBilateralUpsamplerMaterial: function(kernelRadius) {
	
			return new THREE.ShaderMaterial( {
	
				uniforms: {
					"inputTexture": { value: null },
					"NormalTextureFullRes": { value: null },
					"DepthTextureFullRes": { value: null },
					"NormalTextureHalfRes": { value: null },
					"DepthTextureHalfRes": { value: null },
					"texSize": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
					"cameraNearFar": 	{ value: new THREE.Vector2( 0.5, 0.5 ) },
				},
	
				vertexShader:
					"varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",
	
				fragmentShader:
					"#include <common>\n\
					#include <packing>\n\
					varying vec2 vUv;\n\
					uniform sampler2D inputTexture;\n\
					uniform sampler2D NormalTextureFullRes;\n\
					uniform sampler2D DepthTextureFullRes;\n\
					uniform sampler2D NormalTextureHalfRes;\n\
					uniform sampler2D DepthTextureHalfRes;\n\
					uniform vec2 texSize;\
					uniform vec2 cameraNearFar;\
					\
					void main()\
					{\
						vec2 uvOffsets[4];\
						uvOffsets[0] = vUv + vec2(0.0, 1.0)/texSize;\
						uvOffsets[1] = vUv + vec2(1.0, 0.0)/texSize;\
						uvOffsets[2] = vUv + vec2(-1.0, 0.0)/texSize;\
						uvOffsets[3] = vUv + vec2(0.0, -1.0)/texSize;\
						\
						float depth_weights[4];\
						float depth_hires = unpackRGBAToDepth(texture2D(DepthTextureFullRes, vUv));\
						depth_hires = -perspectiveDepthToViewZ(depth_hires, cameraNearFar.x, cameraNearFar.y);\
						if(depth_hires == 1.0)\
							discard;\
						float depth_coarse1 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[0]));\
						depth_coarse1 = -perspectiveDepthToViewZ(depth_coarse1, cameraNearFar.x, cameraNearFar.y);\
						depth_weights[0] = 1.0 / (0.001 + abs(depth_hires-depth_coarse1));\
						float depth_coarse2 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[1]));\
						depth_coarse2 = -perspectiveDepthToViewZ(depth_coarse2, cameraNearFar.x, cameraNearFar.y);\
						depth_weights[1] = 1.0 / (0.001 + abs(depth_hires-depth_coarse2));\
						float depth_coarse3 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[2]));\
						depth_coarse3 = -perspectiveDepthToViewZ(depth_coarse3, cameraNearFar.x, cameraNearFar.y);\
						depth_weights[2] = 1.0 / (0.001 + abs(depth_hires-depth_coarse3));\
						float depth_coarse4 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[3]));\
						depth_coarse4 = -perspectiveDepthToViewZ(depth_coarse4, cameraNearFar.x, cameraNearFar.y);\
						depth_weights[3] = 1.0 / (0.001 + abs(depth_hires-depth_coarse4));\
						\
						float norm_weights[4];\
						vec3 norm_fullRes = unpackRGBToNormal(texture2D(NormalTextureFullRes, vUv).rgb);\
						vec3 norm_coarse1 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[0]).rgb);\
						norm_weights[0] = pow(abs(dot(norm_coarse1, norm_fullRes)), 32.0);\
						vec3 norm_coarse2 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[1]).rgb);\
						norm_weights[1] = pow(abs(dot(norm_coarse2, norm_fullRes)), 32.0);\
						vec3 norm_coarse3 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[2]).rgb);\
						norm_weights[2] = pow(abs(dot(norm_coarse3, norm_fullRes)), 32.0);\
						vec3 norm_coarse4 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[3]).rgb);\
						norm_weights[3] = pow(abs(dot(norm_coarse4, norm_fullRes)), 32.0);\
						\
						vec3 colorOut = vec3(0.0);\
						float weight_sum = 0.0;\
						float weight = norm_weights[0] * depth_weights[0];\
						colorOut += texture2D(inputTexture, uvOffsets[0]).rgb*weight;\
						weight_sum += weight;\
					  weight = norm_weights[1] * depth_weights[1];\
						colorOut += texture2D(inputTexture, uvOffsets[1]).rgb*weight;\
						weight_sum += weight;\
					  weight = norm_weights[2] * depth_weights[2];\
						colorOut += texture2D(inputTexture, uvOffsets[2]).rgb*weight;\
						weight_sum += weight;\
					  weight = norm_weights[3] * depth_weights[3];\
						colorOut += texture2D(inputTexture, uvOffsets[3]).rgb*weight;\
						weight_sum += weight;\
						colorOut /= weight_sum;\
						gl_FragColor = vec4(colorOut, 1.0);\
					}"
			} );
		}
	
	};
	
	// File:examples/js/postprocessing/ManualMSAARenderPass.js
	
	/**
	*
	* Manual Multi-Sample Anti-Aliasing Render Pass
	*
	* @author bhouston / http://clara.io/
	*
	* This manual approach to MSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.
	*
	* References: https://en.wikipedia.org/wiki/Multisample_anti-aliasing
	*
	*/
	
	THREE.ManualMSAARenderPass = function ( scene, camera, clearColor, clearAlpha ) {
	
		THREE.Pass.call( this );
	
		this.scene = scene;
		this.camera = camera;
	
		this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.
		this.unbiased = true;
	
		this.needsSwap = false;
	
		// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.
		this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;
	
		if ( THREE.CopyShader === undefined ) console.error( "THREE.ManualMSAARenderPass relies on THREE.CopyShader" );
	
		this.overMaterial = new THREE.ShaderMaterial( THREE.CopyShader );
		this.overMaterial.uniforms = THREE.UniformsUtils.clone( this.overMaterial.uniforms );
		this.overMaterial.blending = THREE.NormalBlending;
		this.overMaterial.premultipliedAlpha = true;
		this.overMaterial.transparent = true;
		this.overMaterial.depthTest = false;
		this.overMaterial.depthWrite = false;
	
		this.addMaterial = new THREE.ShaderMaterial( THREE.CopyShader );
		this.addMaterial.uniforms = THREE.UniformsUtils.clone( this.addMaterial.uniforms );
		this.addMaterial.blending = THREE.AdditiveBlending;
		this.addMaterial.premultipliedAlpha = true;
		this.addMaterial.transparent = true;
		this.addMaterial.depthTest = false;
		this.addMaterial.depthWrite = false;
	
	};
	
	THREE.ManualMSAARenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {
	
		dispose: function() {
	
			if ( this.sampleRenderTarget ) {
				this.sampleRenderTarget.dispose();
				this.sampleRenderTarget = null;
			}
			if ( this.accumulateRenderTarget ) {
				this.accumulateRenderTarget.dispose();
				this.accumulateRenderTarget = null;
			}
	
		},
	
		setSize: function ( width, height ) {
	
			if ( this.sampleRenderTarget ) this.sampleRenderTarget.setSize( width, height );
			if ( this.accumulateRenderTarget ) this.accumulateRenderTarget.setSize( width, height );
	
		},
	
		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			if ( ! this.sampleRenderTarget ) {
	
				this.sampleRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
					{ minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
				this.accumulateRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
					{ minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
	
	
			}
	
			var jitterOffsets = THREE.ManualMSAARenderPass.JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];
	
			var autoClear = renderer.autoClear;
			renderer.autoClear = false;
	
			var oldClearColor = renderer.getClearColor().getHex();
			var oldClearAlpha = renderer.getClearAlpha();
	
			var baseSampleWeight = 1.0 / jitterOffsets.length;
			var roundingRange = 1 / 32;
	
			this.addMaterial.uniforms[ "tDiffuse" ].value = this.sampleRenderTarget.texture;
	
			var width = readBuffer.width, height = readBuffer.height;
	
			renderer.setClearColor( 0x000000, 0 );
	
			// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
			for ( var i = 0; i < jitterOffsets.length; i ++ ) {
	
				var jitterOffset = jitterOffsets[i];
				if ( this.camera.setViewOffset ) {
					this.camera.setViewOffset( width, height,
						jitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625,   // 0.0625 = 1 / 16
						width, height );
				}
	
				var sampleWeight = baseSampleWeight;
				if( this.unbiased ) {
					// the theory is that equal weights for each sample lead to an accumulation of rounding errors.
					// The following equation varies the sampleWeight per sample so that it is uniformly distributed
					// across a range of values whose rounding errors cancel each other out.
					var uniformCenteredDistribution = ( -0.5 + ( i + 0.5 ) / jitterOffsets.length );
					sampleWeight += roundingRange * uniformCenteredDistribution;
				}
	
				this.addMaterial.uniforms[ "opacity" ].value = sampleWeight;
				renderer.render( this.scene, this.camera, this.sampleRenderTarget, true );
				renderer.renderPass( this.addMaterial, this.accumulateRenderTarget, ( i === 0 ) );
			}
	
			if ( this.camera.clearViewOffset ) this.camera.clearViewOffset();
	
			this.overMaterial.uniforms[ "tDiffuse" ].value = this.accumulateRenderTarget.texture;
	
			renderer.setClearColor( this.clearColor, this.clearAlpha );
			renderer.renderPass( this.overMaterial, this.renderToScreen ? null : readBuffer, this.clear );
	
			renderer.autoClear = autoClear;
			renderer.setClearColor( oldClearColor, oldClearAlpha );
		}
	
	} );
	
	// These jitter vectors are specified in integers because it is easier.
	// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)
	// before being used, thus these integers need to be scaled by 1/16.
	//
	// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
	THREE.ManualMSAARenderPass.JitterVectors = [
		[
			[ 0, 0 ]
		],
		[
			[ 4, 4 ], [ - 4, - 4 ]
		],
		[
			[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]
		],
		[
			[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],
			[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]
		],
		[
			[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],
			[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],
			[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],
			[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]
		],
		[
			[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],
			[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],
			[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],
			[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],
			[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],
			[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],
			[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],
			[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]
		]
	];
	
	// File:examples/js/postprocessing/ClearPass.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ClearPass = function ( clearColor, clearAlpha ) {
	
		THREE.Pass.call( this );
	
		this.needsSwap = false;
	
		this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;
	
	};
	
	THREE.ClearPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {
	
		constructor: THREE.ClearPass,
	
		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			var oldClearColor, oldClearAlpha;
	
			if ( this.clearColor ) {
	
				oldClearColor = renderer.getClearColor().getHex();
				oldClearAlpha = renderer.getClearAlpha();
	
				renderer.setClearColor( this.clearColor, this.clearAlpha );
	
			}
	
			renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );
			renderer.clear();
	
			if ( this.clearColor ) {
	
				renderer.setClearColor( oldClearColor, oldClearAlpha );
	
			}
	
		}
	
	} );
	
	// File:examples/js/postprocessing/TexturePass.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.TexturePass = function ( map, opacity ) {
	
		THREE.Pass.call( this );
	
		if ( THREE.CopyShader === undefined )
			console.error( "THREE.TexturePass relies on THREE.CopyShader" );
	
		var shader = THREE.CopyShader;
	
		this.map = map;
		this.opacity = ( opacity !== undefined ) ? opacity : 1.0;
	
		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
		this.material = new THREE.ShaderMaterial( {
	
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			depthTest: false,
			depthWrite: false
	
		} );
	
		this.needsSwap = false;
	
		this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		this.scene  = new THREE.Scene();
	
		this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
		this.scene.add( this.quad );
	
	};
	
	THREE.TexturePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {
	
		constructor: THREE.TexturePass,
	
		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			var oldAutoClear = renderer.autoClear;
			renderer.autoClear = false;
	
			this.quad.material = this.material;
	
			this.uniforms[ "opacity" ].value = this.opacity;
			this.uniforms[ "tDiffuse" ].value = this.map;
			this.material.transparent = ( this.opacity < 1.0 );
	
			renderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );
	
			renderer.autoClear = oldAutoClear;
		}
	
	} );
	
	// File:examples/js/postprocessing/CubeTexturePass.js
	
	/**
	 * @author bhouston / http://clara.io/
	 */
	
	THREE.CubeTexturePass = function ( camera, envMap, opacity ) {
	
		THREE.Pass.call( this );
	
		this.camera = camera;
	
		this.needsSwap = false;
	
		this.cubeMaterial = new THREE.MeshCubeMaterial();
	
		this.cubeMesh = new THREE.Mesh(
			new THREE.BoxBufferGeometry( 10, 10, 10 ),
			this.cubeMaterial
		);
	
		this.envMap = envMap;
		this.envMapIntensity = 1.0;
		this.opacity = ( opacity !== undefined ) ? opacity : 1.0;
		this.roughness = 0.0;
	
		this.cubeScene = new THREE.Scene();
		this.cubeCamera = new THREE.PerspectiveCamera();
		this.cubeScene.add( this.cubeMesh );
	
	};
	
	THREE.CubeTexturePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {
	
		constructor: THREE.CubeTexturePass,
	
		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {
	
			var oldAutoClear = renderer.autoClear;
			renderer.autoClear = false;
	
			this.cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );
			this.cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );
	
			if( this.cubeMaterial.envMap != this.envMap ) {
				this.cubeMaterial.envMap = this.envMap;
				this.cubeMaterial.needsUpdate = true;
			}
			this.cubeMaterial.envMapIntensity = this.envMapIntensity;
			this.cubeMaterial.roughness = this.roughness;
			this.cubeMaterial.opacity = this.opacity;
			this.cubeMaterial.transparent = ( this.opacity < 1.0 );
	
			renderer.render( this.cubeScene, this.cubeCamera, this.renderToScreen ? null : readBuffer, this.clear );
	
			renderer.autoClear = oldAutoClear;
	
		}
	
	} );
	
	// File:examples/js/GlossyMirror.js
	
	/**
	 * @author spidersharma03
	 * @author bhouston / Ben Houston / ben@clara.io
	 */
	
	THREE.MirrorHelper = function(mirror) {
	  this.scene = new THREE.Scene();
	  this.cameraOrtho = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	  this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
	  this.scene.add(this.quad);
	  this.mirror = mirror;
	  this.numMipMaps = 4;
	
	
	  this.mirrorTextureMipMaps = [];
	  this.tempRenderTargets = [];
	  var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };
	  var mirrorTexture = mirror.mirrorRenderTarget;
	  var width = mirrorTexture.width/2, height = mirrorTexture.height/2;
	  for( var i=0; i<this.numMipMaps; i++) {
	    var renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
	    renderTarget.texture.generateMipmaps = false;
	    this.mirrorTextureMipMaps.push(renderTarget);
	    width /= 2; height /= 2;
	  }
	
	  width = mirrorTexture.width/2; height = mirrorTexture.height/2;
	  for( var i=0; i<this.numMipMaps; i++) {
	    var renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
	    renderTarget.texture.generateMipmaps = false;
	    this.tempRenderTargets.push(renderTarget);
	    width /= 2; height /= 2;
	  }
	
	  this.vBlurMaterial = new THREE.ShaderMaterial( THREE.BlurShader );
	  this.vBlurMaterial.side = THREE.DoubleSide;
	  this.vBlurMaterial.uniforms[ 'size' ].value.set( mirrorTexture.width/2, mirrorTexture.height/2 );
	  this.vBlurMaterial.blending = THREE.NoBlending;
	  THREE.BlurShaderUtils.configure( this.vBlurMaterial, 5, 3.0, new THREE.Vector2( 0, 1 ) );
	
	  this.hBlurMaterial = this.vBlurMaterial.clone();
	  this.hBlurMaterial.side = THREE.DoubleSide;
	  this.hBlurMaterial.uniforms[ 'size' ].value.set( mirrorTexture.width/2, mirrorTexture.height/2 );
	  this.hBlurMaterial.blending = THREE.NoBlending;
	  THREE.BlurShaderUtils.configure( this.hBlurMaterial, 5, 3.0, new THREE.Vector2( 1, 0 ) );
	}
	
	
	THREE.MirrorHelper.prototype = {
	
	  constructor: THREE.MirrorHelper,
	
	  update: function(renderer) {
	
	    var textureIn = this.mirror.mirrorRenderTarget;
	    for( var i=0; i<this.numMipMaps; i++) {
	      var renderTarget = this.mirrorTextureMipMaps[i];
	      var tempRenderTarget = this.tempRenderTargets[i];
	
	      this.hBlurMaterial.uniforms[ 'size' ].value.set( textureIn.width, textureIn.height );
	      this.hBlurMaterial.uniforms[ "tDiffuse" ].value = textureIn.texture;
	      this.quad.material = this.hBlurMaterial;
	      renderer.render(this.scene, this.cameraOrtho, tempRenderTarget, true);
	
	      this.vBlurMaterial.uniforms[ 'size' ].value.set( tempRenderTarget.width, tempRenderTarget.height );
	      this.vBlurMaterial.uniforms[ "tDiffuse" ].value = tempRenderTarget.texture;
	      this.quad.material = this.vBlurMaterial;
	      renderer.render(this.scene, this.cameraOrtho, renderTarget, true);
	
	      textureIn = renderTarget;
	    }
	  }
	}
	
	
	
	THREE.GlossyMirror = function ( options ) {
	
		THREE.Object3D.call( this );
	
		this.name = 'mirror_' + this.id;
	
		options = options || {};
	
		this.matrixNeedsUpdate = true;
	
		var width = options.textureWidth !== undefined ? options.textureWidth : 512;
		var height = options.textureHeight !== undefined ? options.textureHeight : 512;
	
		this.localMirrorNormal = options.localMirrorNormal !== undefined ? options.localMirrorNormal : new THREE.Vector3( 0, 0, 1 );
	
		this.distanceFade = 0.1;
		this.metalness = 0.0;
		this.specularColor = new THREE.Color( 0xffffff );
		this.roughness = 0.0;
		this.fresnelStrength = 1.0;
	
		this.mirrorPlane = new THREE.Plane();
		this.mirrorWorldPosition = new THREE.Vector3();
		this.cameraWorldPosition = new THREE.Vector3();
		this.rotationMatrix = new THREE.Matrix4();
		this.lookAtPosition = new THREE.Vector3( 0, 0, - 1 );
	
		// For debug only, show the normal and plane of the mirror
		var debugMode = options.debugMode !== undefined ? options.debugMode : false;
	
		if ( debugMode ) {
	
			var arrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 0, 1 ), new THREE.Vector3( 0, 0, 0 ), 10, 0xffff80 );
			var planeGeometry = new THREE.Geometry();
			planeGeometry.vertices.push( new THREE.Vector3( - 10, - 10, 0 ) );
			planeGeometry.vertices.push( new THREE.Vector3( 10, - 10, 0 ) );
			planeGeometry.vertices.push( new THREE.Vector3( 10, 10, 0 ) );
			planeGeometry.vertices.push( new THREE.Vector3( - 10, 10, 0 ) );
			planeGeometry.vertices.push( planeGeometry.vertices[ 0 ] );
			var plane = new THREE.Line( planeGeometry, new THREE.LineBasicMaterial( { color: 0xffff80 } ) );
	
			this.add( arrow );
			this.add( plane );
	
		}
	
		this.reflectionTextureMatrix = new THREE.Matrix4();
	
		this.mirrorNormal = new THREE.Vector3();
		var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };
	
		this.mirrorRenderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
	
		this.material = new THREE.ShaderMaterial( THREE.GlossyMirrorShader );
		this.material.defines = THREE.UniformsUtils.cloneDefines( this.material.defines );
		this.material.uniforms = THREE.UniformsUtils.clone( this.material.uniforms );
		this.material.uniforms.tReflection.value = this.mirrorRenderTarget;
		this.material.uniforms.reflectionTextureMatrix.value = this.reflectionTextureMatrix;
	
		if ( ! THREE.Math.isPowerOfTwo( width ) || ! THREE.Math.isPowerOfTwo( height ) ) {
	
			this.mirrorRenderTarget.texture.generateMipmaps = false;
	
		}
	
		this.clipPlane = new THREE.Plane( this.localMirrorNormal, 0 );
		this.originalClipPlane = this.clipPlane.clone();
		this.falseClipPlane = this.clipPlane.clone();
		this.falseClipPlane.constant = 10000;
	
		this.depthMaterial = new THREE.MeshDepthMaterial();
	 	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	 	this.depthMaterial.blending = THREE.NoBlending;
		this.depthMaterial.side = THREE.DoubleSide;
	
		this.depthRenderTarget = new THREE.WebGLRenderTarget( width, height,
	 					{ minFilter: THREE.LinearFilter, magFilter: THREE.NearesFilter, format: THREE.RGBAFormat } );
		this.material.uniforms.tReflectionDepth.value = this.depthRenderTarget.texture;
	
	
	  	this.material.uniforms[ 'screenSize' ].value = new THREE.Vector2(width, height);
	
		this.mirrorHelper = new THREE.MirrorHelper(this);
	
		this.material.uniforms.tReflection.value = this.mirrorRenderTarget;
		this.material.uniforms.tReflection1.value = this.mirrorHelper.mirrorTextureMipMaps[0].texture;
		this.material.uniforms.tReflection2.value = this.mirrorHelper.mirrorTextureMipMaps[1].texture;
		this.material.uniforms.tReflection3.value = this.mirrorHelper.mirrorTextureMipMaps[2].texture;
		this.material.uniforms.tReflection4.value = this.mirrorHelper.mirrorTextureMipMaps[3].texture;
	
	};
	
	THREE.GlossyMirror.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {
	
		constructor: THREE.GlossyMirror,
	
		updateReflectionTextureMatrix: function ( camera ) {
	
			this.updateMatrixWorld();
			camera.updateMatrixWorld();
	
			this.mirrorWorldPosition.setFromMatrixPosition( this.matrixWorld );
			this.cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );
	
			this.rotationMatrix.extractRotation( this.matrixWorld );
	
			this.mirrorNormal.copy( this.localMirrorNormal );
			this.mirrorNormal.applyMatrix4( this.rotationMatrix );
	
			var view = this.mirrorWorldPosition.clone().sub( this.cameraWorldPosition );
			view.reflect( this.mirrorNormal ).negate();
			view.add( this.mirrorWorldPosition );
	
			this.rotationMatrix.extractRotation( camera.matrixWorld );
	
			this.lookAtPosition.set( 0, 0, - 1 );
			this.lookAtPosition.applyMatrix4( this.rotationMatrix );
			this.lookAtPosition.add( this.cameraWorldPosition );
	
			var target = this.mirrorWorldPosition.clone().sub( this.lookAtPosition );
			target.reflect( this.mirrorNormal ).negate();
			target.add( this.mirrorWorldPosition );
	
			this.up.set( 0, - 1, 0 );
			this.up.applyMatrix4( this.rotationMatrix );
			this.up.reflect( this.mirrorNormal ).negate();
	
			this.mirrorCamera.position.copy( view );
			this.mirrorCamera.up = this.up;
			this.mirrorCamera.lookAt( target );
	
			this.mirrorCamera.updateProjectionMatrix();
			this.mirrorCamera.updateMatrixWorld();
			this.mirrorCamera.matrixWorldInverse.getInverse( this.mirrorCamera.matrixWorld );
	
			// Update the texture matrix
			this.reflectionTextureMatrix.set( 0.5, 0.0, 0.0, 0.5,
									0.0, 0.5, 0.0, 0.5,
									0.0, 0.0, 0.5, 0.5,
									0.0, 0.0, 0.0, 1.0 );
			this.reflectionTextureMatrix.multiply( this.mirrorCamera.projectionMatrix );
			this.reflectionTextureMatrix.multiply( this.mirrorCamera.matrixWorldInverse );
	
			this.mirrorPlane.setFromNormalAndCoplanarPoint( this.mirrorNormal, this.mirrorWorldPosition );
			this.mirrorPlane.applyMatrix4( this.mirrorCamera.matrixWorldInverse );
	
	
			this.material.uniforms[ 'mirrorCameraProjectionMatrix' ].value.copy( this.mirrorCamera.projectionMatrix );
			this.material.uniforms[ 'mirrorCameraInverseProjectionMatrix' ].value.getInverse( this.mirrorCamera.projectionMatrix );
	
			this.material.uniforms[ 'mirrorCameraWorldMatrix' ].value.copy( camera.matrixWorld );
			this.material.uniforms[ 'mirrorCameraNear' ].value = this.mirrorCamera.near;
			this.material.uniforms[ 'mirrorCameraFar' ].value = this.mirrorCamera.far;
	
			this.material.uniforms[ 'mirrorNormal' ].value = this.mirrorNormal;
			this.material.uniforms[ 'mirrorWorldPosition' ].value = this.mirrorWorldPosition;
			this.material.transparent = true;
		},
	
		render: function ( renderer, scene, camera ) {
	
			if ( ! camera instanceof THREE.PerspectiveCamera ) console.error( "THREE.GlossyMirror: camera is not a Perspective Camera!" );
	
			if( ! this.mirrorCamera ) {
				this.mirrorCamera = camera.clone();
				this.mirrorCamera.matrixAutoUpdate = true;
	
			}
	
	
			if ( this.matrixNeedsUpdate ) this.updateReflectionTextureMatrix( camera );
	
			this.matrixNeedsUpdate = true;
	
			// Render the mirrored view of the current scene into the target texture
	
	
			if(this.clipPlane !== undefined) {
	
				this.clipPlane.copy(this.originalClipPlane);
	
				this.clipPlane.applyMatrix4(this.matrixWorld);
				this.clippingPlanes = [this.clipPlane];
			}
	
			renderer.clippingPlanes = this.clippingPlanes;
	
			if ( scene !== undefined && scene instanceof THREE.Scene ) {
	
				// We can't render ourself to ourself
				var visible = this.material.visible;
				this.material.visible = false;
	
				renderer.render( scene, this.mirrorCamera, this.mirrorRenderTarget, true );
	
				this.material.visible = visible;
	
			}
			scene.overrideMaterial = this.depthMaterial;
	
			var visible = this.material.visible;
	
			var oldClearColor = renderer.getClearColor(), oldClearAlpha = renderer.getClearAlpha();
	
			renderer.setClearColor(0xffffff, 1);
			this.material.visible = false;
	
			renderer.render( scene, this.mirrorCamera, this.depthRenderTarget, true );
	
			scene.overrideMaterial = null;
			renderer.setClearColor( oldClearColor, oldClearAlpha );
	
	
			this.material.visible = visible;
			this.material.uniforms.distanceFade.value = this.distanceFade;
			this.material.uniforms.metalness.value = this.metalness;
			this.material.uniforms.fresnelStrength.value = this.fresnelStrength;
			this.material.uniforms.specularColor.value.copy( this.specularColor );
			this.material.uniforms.roughness.value = this.roughness;
	
			if(this.clipPlane !== undefined) {
	
				this.clipPlane.copy(this.falseClipPlane);
	
			}
			if(this.mirrorHelper !== undefined) {
	
				this.mirrorHelper.update(renderer);
	
			}
		}
	
	} );
	// File:src/extras/CurveUtils.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.CurveUtils = {
	
		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {
	
			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
	
		},
	
		// Puay Bing, thanks for helping with this derivative!
	
		tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {
	
			return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
				3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
				6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
				3 * t * t * p3;
	
		},
	
		tangentSpline: function ( t, p0, p1, p2, p3 ) {
	
			// To check if my formulas are correct
	
			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3  t2
	
			return h00 + h10 + h01 + h11;
	
		},
	
		// Catmull-Rom
	
		interpolate: function( p0, p1, p2, p3, t ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	// File:src/extras/SceneUtils.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SceneUtils = {
	
		createMultiMaterialObject: function ( geometry, materials ) {
	
			var group = new THREE.Group();
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				group.add( new THREE.Mesh( geometry, materials[ i ] ) );
	
			}
	
			return group;
	
		},
	
		detach: function ( child, parent, scene ) {
	
			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );
	
		},
	
		attach: function ( child, scene, parent ) {
	
			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );
	
			scene.remove( child );
			parent.add( child );
	
		}
	
	};
	
	// File:src/extras/ShapeUtils.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.ShapeUtils = {
	
		// calculate area of the contour polygon
	
		area: function ( contour ) {
	
			var n = contour.length;
			var a = 0.0;
	
			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
			}
	
			return a * 0.5;
	
		},
	
		triangulate: ( function () {
	
			/**
			 * This code is a quick port of code written in C++ which was submitted to
			 * flipcode.com by John W. Ratcliff  // July 22, 2000
			 * See original code and more information here:
			 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
			 *
			 * ported to actionscript by Zevan Rosser
			 * www.actionsnippet.com
			 *
			 * ported to javascript by Joshua Koo
			 * http://www.lab4games.net/zz85/blog
			 *
			 */
	
			function snip( contour, u, v, w, n, verts ) {
	
				var p;
				var ax, ay, bx, by;
				var cx, cy, px, py;
	
				ax = contour[ verts[ u ] ].x;
				ay = contour[ verts[ u ] ].y;
	
				bx = contour[ verts[ v ] ].x;
				by = contour[ verts[ v ] ].y;
	
				cx = contour[ verts[ w ] ].x;
				cy = contour[ verts[ w ] ].y;
	
				if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;
	
				var aX, aY, bX, bY, cX, cY;
				var apx, apy, bpx, bpy, cpx, cpy;
				var cCROSSap, bCROSScp, aCROSSbp;
	
				aX = cx - bx;  aY = cy - by;
				bX = ax - cx;  bY = ay - cy;
				cX = bx - ax;  cY = by - ay;
	
				for ( p = 0; p < n; p ++ ) {
	
					px = contour[ verts[ p ] ].x;
					py = contour[ verts[ p ] ].y;
	
					if ( ( ( px === ax ) && ( py === ay ) ) ||
						 ( ( px === bx ) && ( py === by ) ) ||
						 ( ( px === cx ) && ( py === cy ) ) )	continue;
	
					apx = px - ax;  apy = py - ay;
					bpx = px - bx;  bpy = py - by;
					cpx = px - cx;  cpy = py - cy;
	
					// see if p is inside triangle abc
	
					aCROSSbp = aX * bpy - aY * bpx;
					cCROSSap = cX * apy - cY * apx;
					bCROSScp = bX * cpy - bY * cpx;
	
					if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;
	
				}
	
				return true;
	
			}
	
			// takes in an contour array and returns
	
			return function triangulate( contour, indices ) {
	
				var n = contour.length;
	
				if ( n < 3 ) return null;
	
				var result = [],
					verts = [],
					vertIndices = [];
	
				/* we want a counter-clockwise polygon in verts */
	
				var u, v, w;
	
				if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {
	
					for ( v = 0; v < n; v ++ ) verts[ v ] = v;
	
				} else {
	
					for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
	
				}
	
				var nv = n;
	
				/*  remove nv - 2 vertices, creating 1 triangle every time */
	
				var count = 2 * nv;   /* error detection */
	
				for ( v = nv - 1; nv > 2; ) {
	
					/* if we loop, it is probably a non-simple polygon */
	
					if ( ( count -- ) <= 0 ) {
	
						//** Triangulate: ERROR - probable bad polygon!
	
						//throw ( "Warning, unable to triangulate polygon!" );
						//return null;
						// Sometimes warning is fine, especially polygons are triangulated in reverse.
						console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );
	
						if ( indices ) return vertIndices;
						return result;
	
					}
	
					/* three consecutive vertices in current polygon, <u,v,w> */
	
					u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
					v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
					w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
					if ( snip( contour, u, v, w, nv, verts ) ) {
	
						var a, b, c, s, t;
	
						/* true names of the vertices */
	
						a = verts[ u ];
						b = verts[ v ];
						c = verts[ w ];
	
						/* output Triangle */
	
						result.push( [ contour[ a ],
							contour[ b ],
							contour[ c ] ] );
	
	
						vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
						/* remove v from the remaining polygon */
	
						for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
	
							verts[ s ] = verts[ t ];
	
						}
	
						nv --;
	
						/* reset error detection counter */
	
						count = 2 * nv;
	
					}
	
				}
	
				if ( indices ) return vertIndices;
				return result;
	
			}
	
		} )(),
	
		triangulateShape: function ( contour, holes ) {
	
			function removeDupEndPts(points) {
	
				var l = points.length;
	
				if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {
	
					points.pop();
	
				}
	
			}
	
			removeDupEndPts( contour );
			holes.forEach( removeDupEndPts );
	
			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
	
				// inOtherPt needs to be collinear to the inSegment
				if ( inSegPt1.x !== inSegPt2.x ) {
	
					if ( inSegPt1.x < inSegPt2.x ) {
	
						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
	
					} else {
	
						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
	
					}
	
				} else {
	
					if ( inSegPt1.y < inSegPt2.y ) {
	
						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
	
					} else {
	
						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
	
					}
	
				}
	
			}
	
			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
	
				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	
				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	
				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	
				if ( Math.abs( limit ) > Number.EPSILON ) {
	
					// not parallel
	
					var perpSeg2;
					if ( limit > 0 ) {
	
						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
	
					} else {
	
						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
	
					}
	
					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 === 0 ) {
	
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt1 ];
	
					}
					if ( perpSeg2 === limit ) {
	
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt2 ];
	
					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];
	
					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
	
				} else {
	
					// parallel or collinear
					if ( ( perpSeg1 !== 0 ) ||
						 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];
	
					// they are collinear or degenerate
					var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
					var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {
	
						if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
							 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
						return [ inSeg1Pt1 ];                 						// they are the same point
	
					}
					// segment#1  is a single point
					if ( seg1Pt ) {
	
						if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];
	
					}
					// segment#2  is a single point
					if ( seg2Pt ) {
	
						if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];
	
					}
	
					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if ( seg1dx !== 0 ) {
	
						// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
	
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
	
						} else {
	
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
	
						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
	
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
	
						} else {
	
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
	
						}
	
					} else {
	
						// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
	
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
	
						} else {
	
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
	
						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
	
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
	
						} else {
	
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
	
						}
	
					}
					if ( seg1minVal <= seg2minVal ) {
	
						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal === seg2minVal )	{
	
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];
	
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];
	
					} else {
	
						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal === seg2maxVal )	{
	
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];
	
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];
	
					}
	
				}
	
			}
	
			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
	
				// The order of legs is important
	
				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;
	
				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
	
				if ( Math.abs( from2toAngle ) > Number.EPSILON ) {
	
					// angle != 180 deg.
	
					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	
					if ( from2toAngle > 0 ) {
	
						// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
	
					} else {
	
						// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
	
					}
	
				} else {
	
					// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );
	
				}
	
			}
	
	
			function removeHoles( contour, holes ) {
	
				var shape = contour.concat(); // work on this shape
				var hole;
	
				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
	
					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;
	
					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
	
					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
	
					var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
					if ( ! insideAngle ) {
	
						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;
	
					}
	
					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;
	
					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
	
					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
	
					insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
					if ( ! insideAngle ) {
	
						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;
	
					}
	
					return	true;
	
				}
	
				function intersectsShapeEdge( inShapePt, inHolePt ) {
	
					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
	
						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;
	
					}
	
					return	false;
	
				}
	
				var indepHoles = [];
	
				function intersectsHoleEdge( inShapePt, inHolePt ) {
	
					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
	
						chkHole = holes[ indepHoles[ ihIdx ]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
	
							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;
	
						}
	
					}
					return	false;
	
				}
	
				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;
	
				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
					indepHoles.push( h );
	
				}
	
				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {
	
					counter --;
					if ( counter < 0 ) {
	
						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;
	
					}
	
					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
	
						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;
	
						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {
	
							holeIdx = indepHoles[ h ];
	
							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[ cutKey ] !== undefined )			continue;
	
							hole = holes[ holeIdx ];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
	
								holePt = hole[ h2 ];
								if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
	
								holeIndex = h2;
								indepHoles.splice( h, 1 );
	
								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );
	
								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
								minShapeIndex = shapeIndex;
	
								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );
	
								break;
	
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found
	
							failedCuts[ cutKey ] = true;			// remember failure
	
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found
	
					}
	
				}
	
				return shape; 			/* shape with no holes */
	
			}
	
	
			var i, il, f, face,
				key, index,
				allPointsMap = {};
	
			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
			var allpoints = contour.concat();
	
			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
				Array.prototype.push.apply( allpoints, holes[ h ] );
	
			}
	
			//console.log( "allpoints",allpoints, allpoints.length );
	
			// prepare all points map
	
			for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
				key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
				if ( allPointsMap[ key ] !== undefined ) {
	
					console.warn( "THREE.ShapeUtils: Duplicate point", key, i );
	
				}
	
				allPointsMap[ key ] = i;
	
			}
	
			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );
	
			var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );
	
			// check all face vertices against all points map
	
			for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
				face = triangles[ i ];
	
				for ( f = 0; f < 3; f ++ ) {
	
					key = face[ f ].x + ":" + face[ f ].y;
	
					index = allPointsMap[ key ];
	
					if ( index !== undefined ) {
	
						face[ f ] = index;
	
					}
	
				}
	
			}
	
			return triangles.concat();
	
		},
	
		isClockWise: function ( pts ) {
	
			return THREE.ShapeUtils.area( pts ) < 0;
	
		},
	
		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve
	
		// Quad Bezier Functions
	
		b2: ( function () {
	
			function b2p0( t, p ) {
	
				var k = 1 - t;
				return k * k * p;
	
			}
	
			function b2p1( t, p ) {
	
				return 2 * ( 1 - t ) * t * p;
	
			}
	
			function b2p2( t, p ) {
	
				return t * t * p;
	
			}
	
			return function b2( t, p0, p1, p2 ) {
	
				return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );
	
			};
	
		} )(),
	
		// Cubic Bezier Functions
	
		b3: ( function () {
	
			function b3p0( t, p ) {
	
				var k = 1 - t;
				return k * k * k * p;
	
			}
	
			function b3p1( t, p ) {
	
				var k = 1 - t;
				return 3 * k * k * t * p;
	
			}
	
			function b3p2( t, p ) {
	
				var k = 1 - t;
				return 3 * k * t * t * p;
	
			}
	
			function b3p3( t, p ) {
	
				return t * t * t * p;
	
			}
	
			return function b3( t, p0, p1, p2, p3 ) {
	
				return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );
	
			};
	
		} )()
	
	};
	
	// File:src/extras/core/Curve.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/
	
	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/
	
	THREE.Curve = function () {
	
	};
	
	THREE.Curve.prototype = {
	
		constructor: THREE.Curve,
	
		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]
	
		getPoint: function ( t ) {
	
			console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
			return null;
	
		},
	
		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]
	
		getPointAt: function ( u ) {
	
			var t = this.getUtoTmapping( u );
			return this.getPoint( t );
	
		},
	
		// Get sequence of points using getPoint( t )
	
		getPoints: function ( divisions ) {
	
			if ( ! divisions ) divisions = 5;
	
			var points = [];
	
			for ( var d = 0; d <= divisions; d ++ ) {
	
				points.push( this.getPoint( d / divisions ) );
	
			}
	
			return points;
	
		},
	
		// Get sequence of points using getPointAt( u )
	
		getSpacedPoints: function ( divisions ) {
	
			if ( ! divisions ) divisions = 5;
	
			var points = [];
	
			for ( var d = 0; d <= divisions; d ++ ) {
	
				points.push( this.getPointAt( d / divisions ) );
	
			}
	
			return points;
	
		},
	
		// Get total curve arc length
	
		getLength: function () {
	
			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];
	
		},
	
		// Get list of cumulative segment lengths
	
		getLengths: function ( divisions ) {
	
			if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;
	
			if ( this.cacheArcLengths
				&& ( this.cacheArcLengths.length === divisions + 1 )
				&& ! this.needsUpdate ) {
	
				//console.log( "cached", this.cacheArcLengths );
				return this.cacheArcLengths;
	
			}
	
			this.needsUpdate = false;
	
			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;
	
			cache.push( 0 );
	
			for ( p = 1; p <= divisions; p ++ ) {
	
				current = this.getPoint ( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;
	
			}
	
			this.cacheArcLengths = cache;
	
			return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
		},
	
		updateArcLengths: function() {
	
			this.needsUpdate = true;
			this.getLengths();
	
		},
	
		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	
		getUtoTmapping: function ( u, distance ) {
	
			var arcLengths = this.getLengths();
	
			var i = 0, il = arcLengths.length;
	
			var targetArcLength; // The targeted u distance value to get
	
			if ( distance ) {
	
				targetArcLength = distance;
	
			} else {
	
				targetArcLength = u * arcLengths[ il - 1 ];
	
			}
	
			//var time = Date.now();
	
			// binary search for the index with largest value smaller than target u distance
	
			var low = 0, high = il - 1, comparison;
	
			while ( low <= high ) {
	
				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
				comparison = arcLengths[ i ] - targetArcLength;
	
				if ( comparison < 0 ) {
	
					low = i + 1;
	
				} else if ( comparison > 0 ) {
	
					high = i - 1;
	
				} else {
	
					high = i;
					break;
	
					// DONE
	
				}
	
			}
	
			i = high;
	
			//console.log('b' , i, low, high, Date.now()- time);
	
			if ( arcLengths[ i ] === targetArcLength ) {
	
				var t = i / ( il - 1 );
				return t;
	
			}
	
			// we could get finer grain at lengths, or use simple interpolation between two points
	
			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];
	
			var segmentLength = lengthAfter - lengthBefore;
	
			// determine where we are between the 'before' and 'after' points
	
			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
			// add that fractional amount to t
	
			var t = ( i + segmentFraction ) / ( il - 1 );
	
			return t;
	
		},
	
		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation
	
		getTangent: function( t ) {
	
			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;
	
			// Capping in case of danger
	
			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;
	
			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );
	
			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();
	
		},
	
		getTangentAt: function ( u ) {
	
			var t = this.getUtoTmapping( u );
			return this.getTangent( t );
	
		}
	
	};
	
	// TODO: Transformation for Curves?
	
	/**************************************************************
	 *	3D Curves
	 **************************************************************/
	
	// A Factory method for creating new curve subclasses
	
	THREE.Curve.create = function ( constructor, getPointFunc ) {
	
		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;
	
		return constructor;
	
	};
	
	// File:src/extras/core/CurvePath.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/
	
	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	
	THREE.CurvePath = function () {
	
		this.curves = [];
	
		this.autoClose = false; // Automatically closes the path
	
	};
	
	THREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {
	
		constructor: THREE.CurvePath,
	
		add: function ( curve ) {
	
			this.curves.push( curve );
	
		},
	
		closePath: function () {
	
			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
	
			if ( ! startPoint.equals( endPoint ) ) {
	
				this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );
	
			}
	
		},
	
		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
	
		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')
	
		getPoint: function ( t ) {
	
			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;
	
			// To think about boundaries points.
	
			while ( i < curveLengths.length ) {
	
				if ( curveLengths[ i ] >= d ) {
	
					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];
	
					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
	
					return curve.getPointAt( u );
	
				}
	
				i ++;
	
			}
	
			return null;
	
			// loop where sum != 0, sum > d , sum+1 <d
	
		},
	
		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength
	
		getLength: function () {
	
			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];
	
		},
	
		// cacheLengths must be recalculated.
		updateArcLengths: function () {
	
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getLengths();
	
		},
	
		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.
	
		getCurveLengths: function () {
	
			// We use cache values if curves and cache array are same length
	
			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
	
				return this.cacheLengths;
	
			}
	
			// Get length of sub-curve
			// Push sums into cached array
	
			var lengths = [], sums = 0;
	
			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
				sums += this.curves[ i ].getLength();
				lengths.push( sums );
	
			}
	
			this.cacheLengths = lengths;
	
			return lengths;
	
		},
	
		getSpacedPoints: function ( divisions ) {
	
			if ( ! divisions ) divisions = 40;
	
			var points = [];
	
			for ( var i = 0; i <= divisions; i ++ ) {
	
				points.push( this.getPoint( i / divisions ) );
	
			}
	
			if ( this.autoClose ) {
	
				points.push( points[ 0 ] );
	
			}
	
			return points;
	
		},
	
		getPoints: function ( divisions ) {
	
			divisions = divisions || 12;
	
			var points = [], last;
	
			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {
	
				var curve = curves[ i ];
				var resolution = curve instanceof THREE.EllipseCurve ? divisions * 2
					: curve instanceof THREE.LineCurve ? 1
					: curve instanceof THREE.SplineCurve ? divisions * curve.points.length
					: divisions;
	
				var pts = curve.getPoints( resolution );
	
				for ( var j = 0; j < pts.length; j++ ) {
	
					var point = pts[ j ];
	
					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates
	
					points.push( point );
					last = point;
	
				}
	
			}
	
			if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {
	
				points.push( points[ 0 ] );
	
			}
	
			return points;
	
		},
	
		/**************************************************************
		 *	Create Geometries Helpers
		 **************************************************************/
	
		/// Generate geometry from path points (for Line or Points objects)
	
		createPointsGeometry: function ( divisions ) {
	
			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );
	
		},
	
		// Generate geometry from equidistant sampling along the path
	
		createSpacedPointsGeometry: function ( divisions ) {
	
			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );
	
		},
	
		createGeometry: function ( points ) {
	
			var geometry = new THREE.Geometry();
	
			for ( var i = 0, l = points.length; i < l; i ++ ) {
	
				var point = points[ i ];
				geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );
	
			}
	
			return geometry;
	
		}
	
	} );
	
	// File:src/extras/core/Font.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Font = function ( data ) {
	
		this.data = data;
	
	};
	
	Object.assign( THREE.Font.prototype, {
	
		generateShapes: function ( text, size, divisions ) {
	
			function createPaths( text ) {
	
				var chars = String( text ).split( '' );
				var scale = size / data.resolution;
				var offset = 0;
	
				var paths = [];
	
				for ( var i = 0; i < chars.length; i ++ ) {
	
					var ret = createPath( chars[ i ], scale, offset );
					offset += ret.offset;
	
					paths.push( ret.path );
	
				}
	
				return paths;
	
			}
	
			function createPath( c, scale, offset ) {
	
				var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];
	
				if ( ! glyph ) return;
	
				var path = new THREE.ShapePath();
	
				var pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;
				var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
	
				if ( glyph.o ) {
	
					var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
	
					for ( var i = 0, l = outline.length; i < l; ) {
	
						var action = outline[ i ++ ];
	
						switch ( action ) {
	
							case 'm': // moveTo
	
								x = outline[ i ++ ] * scale + offset;
								y = outline[ i ++ ] * scale;
	
								path.moveTo( x, y );
	
								break;
	
							case 'l': // lineTo
	
								x = outline[ i ++ ] * scale + offset;
								y = outline[ i ++ ] * scale;
	
								path.lineTo( x, y );
	
								break;
	
							case 'q': // quadraticCurveTo
	
								cpx  = outline[ i ++ ] * scale + offset;
								cpy  = outline[ i ++ ] * scale;
								cpx1 = outline[ i ++ ] * scale + offset;
								cpy1 = outline[ i ++ ] * scale;
	
								path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
	
								laste = pts[ pts.length - 1 ];
	
								if ( laste ) {
	
									cpx0 = laste.x;
									cpy0 = laste.y;
	
									for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
										var t = i2 / divisions;
										b2( t, cpx0, cpx1, cpx );
										b2( t, cpy0, cpy1, cpy );
	
									}
	
								}
	
								break;
	
							case 'b': // bezierCurveTo
	
								cpx  = outline[ i ++ ] * scale + offset;
								cpy  = outline[ i ++ ] * scale;
								cpx1 = outline[ i ++ ] * scale + offset;
								cpy1 = outline[ i ++ ] * scale;
								cpx2 = outline[ i ++ ] * scale + offset;
								cpy2 = outline[ i ++ ] * scale;
	
								path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
	
								laste = pts[ pts.length - 1 ];
	
								if ( laste ) {
	
									cpx0 = laste.x;
									cpy0 = laste.y;
	
									for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
										var t = i2 / divisions;
										b3( t, cpx0, cpx1, cpx2, cpx );
										b3( t, cpy0, cpy1, cpy2, cpy );
	
									}
	
								}
	
								break;
	
						}
	
					}
	
				}
	
				return { offset: glyph.ha * scale, path: path };
	
			}
	
			//
	
			if ( size === undefined ) size = 100;
			if ( divisions === undefined ) divisions = 4;
	
			var data = this.data;
	
			var paths = createPaths( text );
			var shapes = [];
	
			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
			}
	
			return shapes;
	
		}
	
	} );
	
	// File:src/extras/core/Path.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/
	
	THREE.Path = function ( points ) {
	
		THREE.CurvePath.call( this );
		this.currentPoint = new THREE.Vector2();
	
		if ( points ) {
	
			this.fromPoints( points );
	
		}
	
	};
	
	THREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {
	
		constructor: THREE.Path,
	
		// Create path using straight lines to connect all points
		// - vectors: array of Vector2
		fromPoints: function ( vectors ) {
	
			this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
			for ( var i = 1, l = vectors.length; i < l; i ++ ) {
	
				this.lineTo( vectors[ i ].x, vectors[ i ].y );
	
			}
	
		},
	
		moveTo: function ( x, y ) {
	
			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?
	
		},
	
		lineTo: function ( x, y ) {
	
			var curve = new THREE.LineCurve( this.currentPoint.clone(), new THREE.Vector2( x, y ) );
			this.curves.push( curve );
	
			this.currentPoint.set( x, y );
	
		},
	
		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
			var curve = new THREE.QuadraticBezierCurve(
				this.currentPoint.clone(),
				new THREE.Vector2( aCPx, aCPy ),
				new THREE.Vector2( aX, aY )
			);
	
			this.curves.push( curve );
	
			this.currentPoint.set( aX, aY );
	
		},
	
		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
			var curve = new THREE.CubicBezierCurve(
				this.currentPoint.clone(),
				new THREE.Vector2( aCP1x, aCP1y ),
				new THREE.Vector2( aCP2x, aCP2y ),
				new THREE.Vector2( aX, aY )
			);
	
			this.curves.push( curve );
	
			this.currentPoint.set( aX, aY );
	
		},
	
		splineThru: function ( pts /*Array of Vector*/ ) {
	
			var npts = [ this.currentPoint.clone() ].concat( pts );
	
			var curve = new THREE.SplineCurve( npts );
			this.curves.push( curve );
	
			this.currentPoint.copy( pts[ pts.length - 1 ] );
	
		},
	
		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
	
			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );
	
		},
	
		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
		},
	
		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
	
			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
		},
	
		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
			var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
			if ( this.curves.length > 0 ) {
	
				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );
	
				if ( ! firstPoint.equals( this.currentPoint ) ) {
	
					this.lineTo( firstPoint.x, firstPoint.y );
	
				}
	
			}
	
			this.curves.push( curve );
	
			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );
	
		}
	
	} );
	
	
	// minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	THREE.ShapePath = function() {
		this.subPaths = [];
		this.currentPath = null;
	}
	
	THREE.ShapePath.prototype = {
		moveTo: function ( x, y ) {
			this.currentPath = new THREE.Path();
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo( x, y );
		},
		lineTo: function ( x, y ) {
			this.currentPath.lineTo( x, y );
		},
		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
		},
		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
		},
		splineThru: function ( pts ) {
			this.currentPath.splineThru( pts );
		},
	
		toShapes: function ( isCCW, noHoles ) {
	
			function toShapesNoHoles( inSubpaths ) {
	
				var shapes = [];
	
				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
	
					var tmpPath = inSubpaths[ i ];
	
					var tmpShape = new THREE.Shape();
					tmpShape.curves = tmpPath.curves;
	
					shapes.push( tmpShape );
	
				}
	
				return shapes;
	
			}
	
			function isPointInsidePolygon( inPt, inPolygon ) {
	
				var polyLen = inPolygon.length;
	
				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
	
					var edgeLowPt  = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];
	
					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
					if ( Math.abs( edgeDy ) > Number.EPSILON ) {
	
						// not parallel
						if ( edgeDy < 0 ) {
	
							edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
	
						}
						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
						if ( inPt.y === edgeLowPt.y ) {
	
							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
	
						} else {
	
							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt
	
						}
	
					} else {
	
						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;
	
					}
	
				}
	
				return	inside;
	
			}
	
			var isClockWise = THREE.ShapeUtils.isClockWise;
	
			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];
	
			if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
			var solid, tmpPath, tmpShape, shapes = [];
	
			if ( subPaths.length === 1 ) {
	
				tmpPath = subPaths[ 0 ];
				tmpShape = new THREE.Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;
	
			}
	
			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;
	
			// console.log("Holes first", holesFirst);
	
			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;
	
			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];
	
			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
	
				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;
	
				if ( solid ) {
	
					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
	
					newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;
	
					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];
	
					//console.log('cw', i);
	
				} else {
	
					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
	
					//console.log('ccw', i);
	
				}
	
			}
	
			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
	
	
			if ( newShapes.length > 1 ) {
	
				var ambiguous = false;
				var toChange = [];
	
				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
					betterShapeHoles[ sIdx ] = [];
	
				}
	
				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
					var sho = newShapeHoles[ sIdx ];
	
					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
	
						var ho = sho[ hIdx ];
						var hole_unassigned = true;
	
						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
	
							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
	
								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {
	
									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );
	
								} else {
	
									ambiguous = true;
	
								}
	
							}
	
						}
						if ( hole_unassigned ) {
	
							betterShapeHoles[ sIdx ].push( ho );
	
						}
	
					}
	
				}
				// console.log("ambiguous: ", ambiguous);
				if ( toChange.length > 0 ) {
	
					// console.log("to change: ", toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
	
				}
	
			}
	
			var tmpHoles;
	
			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
	
				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];
	
				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
	
					tmpShape.holes.push( tmpHoles[ j ].h );
	
				}
	
			}
	
			//console.log("shape", shapes);
	
			return shapes;
	
		}
	}
	
	// File:src/extras/core/Shape.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/
	
	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
	
	THREE.Shape = function () {
	
		THREE.Path.apply( this, arguments );
	
		this.holes = [];
	
	};
	
	THREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {
	
		constructor: THREE.Shape,
	
		// Convenience method to return ExtrudeGeometry
	
		extrude: function ( options ) {
	
			return new THREE.ExtrudeGeometry( this, options );
	
		},
	
		// Convenience method to return ShapeGeometry
	
		makeGeometry: function ( options ) {
	
			return new THREE.ShapeGeometry( this, options );
	
		},
	
		getPointsHoles: function ( divisions ) {
	
			var holesPts = [];
	
			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
				holesPts[ i ] = this.holes[ i ].getPoints( divisions );
	
			}
	
			return holesPts;
	
		},
	
		// Get points of shape and holes (keypoints based on segments parameter)
	
		extractAllPoints: function ( divisions ) {
	
			return {
	
				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )
	
			};
	
		},
	
		extractPoints: function ( divisions ) {
	
			return this.extractAllPoints( divisions );
	
		}
	
	} );
	
	// File:src/extras/curves/LineCurve.js
	
	/**************************************************************
	 *	Line
	 **************************************************************/
	
	THREE.LineCurve = function ( v1, v2 ) {
	
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;
	
	THREE.LineCurve.prototype.getPoint = function ( t ) {
	
		if ( t === 1 ) {
	
			return this.v2.clone();
	
		}
	
		var point = this.v2.clone().sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );
	
		return point;
	
	};
	
	// Line curve is linear, so we can overwrite default getPointAt
	
	THREE.LineCurve.prototype.getPointAt = function ( u ) {
	
		return this.getPoint( u );
	
	};
	
	THREE.LineCurve.prototype.getTangent = function( t ) {
	
		var tangent = this.v2.clone().sub( this.v1 );
	
		return tangent.normalize();
	
	};
	
	// File:src/extras/curves/QuadraticBezierCurve.js
	
	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/
	
	
	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
	
	
	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
		var b2 = THREE.ShapeUtils.b2;
	
		return new THREE.Vector2(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y )
		);
	
	};
	
	
	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {
	
		var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;
	
		return new THREE.Vector2(
			tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
			tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
		).normalize();
	
	};
	
	// File:src/extras/curves/CubicBezierCurve.js
	
	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/
	
	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	
	};
	
	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
	
	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {
	
		var b3 = THREE.ShapeUtils.b3;
	
		return new THREE.Vector2(
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		);
	
	};
	
	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {
	
		var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;
	
		return new THREE.Vector2(
			tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		).normalize();
	
	};
	
	// File:src/extras/curves/SplineCurve.js
	
	/**************************************************************
	 *	Spline curve
	 **************************************************************/
	
	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {
	
		this.points = ( points == undefined ) ? [] : points;
	
	};
	
	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
	
	THREE.SplineCurve.prototype.getPoint = function ( t ) {
	
		var points = this.points;
		var point = ( points.length - 1 ) * t;
	
		var intPoint = Math.floor( point );
		var weight = point - intPoint;
	
		var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
		var interpolate = THREE.CurveUtils.interpolate;
	
		return new THREE.Vector2(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight )
		);
	
	};
	
	// File:src/extras/curves/EllipseCurve.js
	
	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/
	
	THREE.EllipseCurve = function( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		this.aX = aX;
		this.aY = aY;
	
		this.xRadius = xRadius;
		this.yRadius = yRadius;
	
		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;
	
		this.aClockwise = aClockwise;
	
		this.aRotation = aRotation || 0;
	
	};
	
	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
	
	THREE.EllipseCurve.prototype.getPoint = function( t ) {
	
		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;
	
		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;
	
		if ( deltaAngle < Number.EPSILON ) {
	
			if ( samePoints ) {
	
				deltaAngle = 0;
	
			} else {
	
				deltaAngle = twoPi;
	
			}
	
		}
	
		if ( this.aClockwise === true && ! samePoints ) {
	
			if ( deltaAngle === twoPi ) {
	
				deltaAngle = - twoPi;
	
			} else {
	
				deltaAngle = deltaAngle - twoPi;
	
			}
	
		}
	
		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );
	
		if ( this.aRotation !== 0 ) {
	
			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );
	
			var tx = x - this.aX;
			var ty = y - this.aY;
	
			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;
	
		}
	
		return new THREE.Vector2( x, y );
	
	};
	
	// File:src/extras/curves/ArcCurve.js
	
	/**************************************************************
	 *	Arc curve
	 **************************************************************/
	
	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
	};
	
	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
	
	// File:src/extras/curves/LineCurve3.js
	
	/**************************************************************
	 *	Line3D
	 **************************************************************/
	
	THREE.LineCurve3 = THREE.Curve.create(
	
		function ( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			if ( t === 1 ) {
	
				return this.v2.clone();
	
			}
	
			var vector = new THREE.Vector3();
	
			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );
	
			return vector;
	
		}
	
	);
	
	// File:src/extras/curves/QuadraticBezierCurve3.js
	
	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/
	
	THREE.QuadraticBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var b2 = THREE.ShapeUtils.b2;
	
			return new THREE.Vector3(
				b2( t, this.v0.x, this.v1.x, this.v2.x ),
				b2( t, this.v0.y, this.v1.y, this.v2.y ),
				b2( t, this.v0.z, this.v1.z, this.v2.z )
			);
	
		}
	
	);
	
	// File:src/extras/curves/CubicBezierCurve3.js
	
	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/
	
	THREE.CubicBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		},
	
		function ( t ) {
	
			var b3 = THREE.ShapeUtils.b3;
	
			return new THREE.Vector3(
				b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
				b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
			);
	
		}
	
	);
	
	// File:src/extras/curves/SplineCurve3.js
	
	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/
	
	
	THREE.SplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */ ) {
	
			console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
			this.points = ( points == undefined ) ? [] : points;
	
		},
	
		function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 1 ) * t;
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
			var interpolate = THREE.CurveUtils.interpolate;
	
			return new THREE.Vector3(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
				interpolate( point0.z, point1.z, point2.z, point3.z, weight )
			);
	
		}
	
	);
	
	// File:src/extras/curves/CatmullRomCurve3.js
	
	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */
	
	THREE.CatmullRomCurve3 = ( function() {
	
		var
			tmp = new THREE.Vector3(),
			px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();
	
		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM
	
		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/
	
		function CubicPoly() {
	
		}
	
		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {
	
			this.c0 = x0;
			this.c1 = t0;
			this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
	
		};
	
		CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {
	
			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
	
			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;
	
			// initCubicPoly
			this.init( x1, x2, t1, t2 );
	
		};
	
		// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
		CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {
	
			this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
	
		};
	
		CubicPoly.prototype.calc = function( t ) {
	
			var t2 = t * t;
			var t3 = t2 * t;
			return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
	
		};
	
		// Subclass Three.js curve
		return THREE.Curve.create(
	
			function ( p /* array of Vector3 */ ) {
	
				this.points = p || [];
				this.closed = false;
	
			},
	
			function ( t ) {
	
				var points = this.points,
					point, intPoint, weight, l;
	
				l = points.length;
	
				if ( l < 2 ) console.log( 'duh, you need at least 2 points' );
	
				point = ( l - ( this.closed ? 0 : 1 ) ) * t;
				intPoint = Math.floor( point );
				weight = point - intPoint;
	
				if ( this.closed ) {
	
					intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	
				} else if ( weight === 0 && intPoint === l - 1 ) {
	
					intPoint = l - 2;
					weight = 1;
	
				}
	
				var p0, p1, p2, p3; // 4 points
	
				if ( this.closed || intPoint > 0 ) {
	
					p0 = points[ ( intPoint - 1 ) % l ];
	
				} else {
	
					// extrapolate first point
					tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
					p0 = tmp;
	
				}
	
				p1 = points[ intPoint % l ];
				p2 = points[ ( intPoint + 1 ) % l ];
	
				if ( this.closed || intPoint + 2 < l ) {
	
					p3 = points[ ( intPoint + 2 ) % l ];
	
				} else {
	
					// extrapolate last point
					tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
					p3 = tmp;
	
				}
	
				if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {
	
					// init Centripetal / Chordal Catmull-Rom
					var pow = this.type === 'chordal' ? 0.5 : 0.25;
					var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
					var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
					var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
	
					// safety check for repeated points
					if ( dt1 < 1e-4 ) dt1 = 1.0;
					if ( dt0 < 1e-4 ) dt0 = dt1;
					if ( dt2 < 1e-4 ) dt2 = dt1;
	
					px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
					py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
					pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	
				} else if ( this.type === 'catmullrom' ) {
	
					var tension = this.tension !== undefined ? this.tension : 0.5;
					px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
					py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
					pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );
	
				}
	
				var v = new THREE.Vector3(
					px.calc( weight ),
					py.calc( weight ),
					pz.calc( weight )
				);
	
				return v;
	
			}
	
		);
	
	} )();
	
	// File:src/extras/curves/ClosedSplineCurve3.js
	
	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/
	
	
	THREE.ClosedSplineCurve3 = function ( points ) {
	
		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );
	
		THREE.CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;
	
	};
	
	THREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );
	
	// File:src/extras/geometries/BoxGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */
	
	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'BoxGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
	
		this.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();
	
	};
	
	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
	
	THREE.CubeGeometry = THREE.BoxGeometry;
	
	// File:src/extras/geometries/BoxBufferGeometry.js
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	THREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'BoxBufferGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
	
		var scope = this;
	
		// segments
		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;
	
		// these are used to calculate buffer length
		var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
		var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );
	
		// buffers
		var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
		var vertices = new Float32Array( vertexCount * 3 );
		var normals = new Float32Array( vertexCount * 3 );
		var uvs = new Float32Array( vertexCount * 2 );
	
		// offset variables
		var vertexBufferOffset = 0;
		var uvBufferOffset = 0;
		var indexBufferOffset = 0;
		var numberOfVertices = 0;
	
		// group variables
		var groupStart = 0;
	
		// build each side of the box geometry
		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
		buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
		buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz
	
		// build geometry
		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
		// helper functions
	
		function calculateVertexCount ( w, h, d ) {
	
			var vertices = 0;
	
			// calculate the amount of vertices for each side (plane)
			vertices += (w + 1) * (h + 1) * 2; // xy
			vertices += (w + 1) * (d + 1) * 2; // xz
			vertices += (d + 1) * (h + 1) * 2; // zy
	
			return vertices;
	
		}
	
		function calculateIndexCount ( w, h, d ) {
	
			var index = 0;
	
			// calculate the amount of squares for each side
			index += w * h * 2; // xy
			index += w * d * 2; // xz
			index += d * h * 2; // zy
	
			return index * 6; // two triangles per square => six vertices per square
	
		}
	
		function buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
	
			var segmentWidth	= width / gridX;
			var segmentHeight = height / gridY;
	
			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;
	
			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;
	
			var vertexCounter = 0;
			var groupCount = 0;
	
			var vector = new THREE.Vector3();
	
			// generate vertices, normals and uvs
	
			for ( var iy = 0; iy < gridY1; iy ++ ) {
	
				var y = iy * segmentHeight - heightHalf;
	
				for ( var ix = 0; ix < gridX1; ix ++ ) {
	
					var x = ix * segmentWidth - widthHalf;
	
					// set values to correct vector component
					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;
	
					// now apply vector to vertex buffer
					vertices[ vertexBufferOffset ] = vector.x;
					vertices[ vertexBufferOffset + 1 ] = vector.y;
					vertices[ vertexBufferOffset + 2 ] = vector.z;
	
					// set values to correct vector component
					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;
	
					// now apply vector to normal buffer
					normals[ vertexBufferOffset ] = vector.x;
					normals[ vertexBufferOffset + 1 ] = vector.y;
					normals[ vertexBufferOffset + 2 ] = vector.z;
	
					// uvs
					uvs[ uvBufferOffset ] = ix / gridX;
					uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );
	
					// update offsets and counters
					vertexBufferOffset += 3;
					uvBufferOffset += 2;
					vertexCounter += 1;
	
				}
	
			}
	
			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment
	
			for ( iy = 0; iy < gridY; iy ++ ) {
	
				for ( ix = 0; ix < gridX; ix ++ ) {
	
					// indices
					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;
	
					// face one
					indices[ indexBufferOffset ] = a;
					indices[ indexBufferOffset + 1 ] = b;
					indices[ indexBufferOffset + 2 ] = d;
	
					// face two
					indices[ indexBufferOffset + 3 ] = b;
					indices[ indexBufferOffset + 4 ] = c;
					indices[ indexBufferOffset + 5 ] = d;
	
					// update offsets and counters
					indexBufferOffset += 6;
					groupCount += 6;
	
				}
	
			}
	
			// add a group to the geometry. this will ensure multi material support
			scope.addGroup( groupStart, groupCount, materialIndex );
	
			// calculate new start value for groups
			groupStart += groupCount;
	
			// update total number of vertices
			numberOfVertices += vertexCounter;
	
		}
	
	};
	
	THREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;
	
	// File:src/extras/geometries/CircleGeometry.js
	
	/**
	 * @author hughes
	 */
	
	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CircleGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	
	};
	
	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
	
	// File:src/extras/geometries/CircleBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'CircleBufferGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		var vertices = segments + 2;
	
		var positions = new Float32Array( vertices * 3 );
		var normals = new Float32Array( vertices * 3 );
		var uvs = new Float32Array( vertices * 2 );
	
		// center data is already zero, but need to set a few extras
		normals[ 2 ] = 1.0;
		uvs[ 0 ] = 0.5;
		uvs[ 1 ] = 0.5;
	
		for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {
	
			var segment = thetaStart + s / segments * thetaLength;
	
			positions[ i ] = radius * Math.cos( segment );
			positions[ i + 1 ] = radius * Math.sin( segment );
	
			normals[ i + 2 ] = 1; // normal z
	
			uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
			uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;
	
		}
	
		var indices = [];
	
		for ( var i = 1; i <= segments; i ++ ) {
	
			indices.push( i, i + 1, 0 );
	
		}
	
		this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;
	
	// File:src/extras/geometries/CylinderBufferGeometry.js
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	THREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'CylinderBufferGeometry';
	
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		var scope = this;
	
		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;
	
		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;
	
		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;
	
		// used to calculate buffer length
	
		var nbCap = 0;
	
		if ( openEnded === false ) {
	
			if ( radiusTop > 0 ) nbCap ++;
			if ( radiusBottom > 0 ) nbCap ++;
	
		}
	
		var vertexCount = calculateVertexCount();
		var indexCount = calculateIndexCount();
	
		// buffers
	
		var indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
		var vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
		// helper variables
	
		var index = 0,
		    indexOffset = 0,
		    indexArray = [],
		    halfHeight = height / 2;
	
		// group variables
		var groupStart = 0;
	
		// generate geometry
	
		generateTorso();
	
		if ( openEnded === false ) {
	
			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', vertices );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );
	
		// helper functions
	
		function calculateVertexCount() {
	
			var count = ( radialSegments + 1 ) * ( heightSegments + 1 );
	
			if ( openEnded === false ) {
	
				count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );
	
			}
	
			return count;
	
		}
	
		function calculateIndexCount() {
	
			var count = radialSegments * heightSegments * 2 * 3;
	
			if ( openEnded === false ) {
	
				count += radialSegments * nbCap * 3;
	
			}
	
			return count;
	
		}
	
		function generateTorso() {
	
			var x, y;
			var normal = new THREE.Vector3();
			var vertex = new THREE.Vector3();
	
			var groupCount = 0;
	
			// this will be used to calculate the normal
			var tanTheta = ( radiusBottom - radiusTop ) / height;
	
			// generate vertices, normals and uvs
	
			for ( y = 0; y <= heightSegments; y ++ ) {
	
				var indexRow = [];
	
				var v = y / heightSegments;
	
				// calculate the radius of the current row
				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
				for ( x = 0; x <= radialSegments; x ++ ) {
	
					var u = x / radialSegments;
	
					// vertex
					vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * Math.cos( u * thetaLength + thetaStart );
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
					// normal
					normal.copy( vertex );
	
					// handle special case if radiusTop/radiusBottom is zero
	
					if ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {
	
						normal.x = Math.sin( u * thetaLength + thetaStart );
						normal.z = Math.cos( u * thetaLength + thetaStart );
	
					}
	
					normal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();
					normals.setXYZ( index, normal.x, normal.y, normal.z );
	
					// uv
					uvs.setXY( index, u, 1 - v );
	
					// save index of vertex in respective row
					indexRow.push( index );
	
					// increase index
					index ++;
	
				}
	
				// now save vertices of the row in our index array
				indexArray.push( indexRow );
	
			}
	
			// generate indices
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				for ( y = 0; y < heightSegments; y ++ ) {
	
					// we use the index array to access the correct indices
					var i1 = indexArray[ y ][ x ];
					var i2 = indexArray[ y + 1 ][ x ];
					var i3 = indexArray[ y + 1 ][ x + 1 ];
					var i4 = indexArray[ y ][ x + 1 ];
	
					// face one
					indices.setX( indexOffset, i1 ); indexOffset ++;
					indices.setX( indexOffset, i2 ); indexOffset ++;
					indices.setX( indexOffset, i4 ); indexOffset ++;
	
					// face two
					indices.setX( indexOffset, i2 ); indexOffset ++;
					indices.setX( indexOffset, i3 ); indexOffset ++;
					indices.setX( indexOffset, i4 ); indexOffset ++;
	
					// update counters
					groupCount += 6;
	
				}
	
			}
	
			// add a group to the geometry. this will ensure multi material support
			scope.addGroup( groupStart, groupCount, 0 );
	
			// calculate new start value for groups
			groupStart += groupCount;
	
		}
	
		function generateCap( top ) {
	
			var x, centerIndexStart, centerIndexEnd;
	
			var uv = new THREE.Vector2();
			var vertex = new THREE.Vector3();
	
			var groupCount = 0;
	
			var radius = ( top === true ) ? radiusTop : radiusBottom;
			var sign = ( top === true ) ? 1 : - 1;
	
			// save the index of the first center vertex
			centerIndexStart = index;
	
			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment
	
			for ( x = 1; x <= radialSegments; x ++ ) {
	
				// vertex
				vertices.setXYZ( index, 0, halfHeight * sign, 0 );
	
				// normal
				normals.setXYZ( index, 0, sign, 0 );
	
				// uv
				uv.x = 0.5;
				uv.y = 0.5;
	
				uvs.setXY( index, uv.x, uv.y );
	
				// increase index
				index ++;
	
			}
	
			// save the index of the last center vertex
			centerIndexEnd = index;
	
			// now we generate the surrounding vertices, normals and uvs
	
			for ( x = 0; x <= radialSegments; x ++ ) {
	
				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;
	
				var cosTheta = Math.cos( theta );
				var sinTheta = Math.sin( theta );
	
				// vertex
				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
				// normal
				normals.setXYZ( index, 0, sign, 0 );
	
				// uv
				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.setXY( index, uv.x, uv.y );
	
				// increase index
				index ++;
	
			}
	
			// generate indices
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;
	
				if ( top === true ) {
	
					// face top
					indices.setX( indexOffset, i ); indexOffset ++;
					indices.setX( indexOffset, i + 1 ); indexOffset ++;
					indices.setX( indexOffset, c ); indexOffset ++;
	
				} else {
	
					// face bottom
					indices.setX( indexOffset, i + 1 ); indexOffset ++;
					indices.setX( indexOffset, i ); indexOffset ++;
					indices.setX( indexOffset, c ); indexOffset ++;
	
				}
	
				// update counters
				groupCount += 3;
	
			}
	
			// add a group to the geometry. this will ensure multi material support
			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );
	
			// calculate new start value for groups
			groupStart += groupCount;
	
		}
	
	};
	
	THREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;
	
	// File:src/extras/geometries/CylinderGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CylinderGeometry';
	
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();
	
	};
	
	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
	
	// File:src/extras/geometries/ConeBufferGeometry.js
	
	/*
	 * @author: abelnation / http://github.com/abelnation
	 */
	
	THREE.ConeBufferGeometry = function (
		radius, height,
		radialSegments, heightSegments,
		openEnded, thetaStart, thetaLength ) {
	
		THREE.CylinderBufferGeometry.call( this,
			0, radius, height,
			radialSegments, heightSegments,
			openEnded, thetaStart, thetaLength );
	
		this.type = 'ConeBufferGeometry';
	
		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
	};
	
	THREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;
	
	// File:src/extras/geometries/ConeGeometry.js
	
	/**
	 * @author abelnation / http://github.com/abelnation
	 */
	
	THREE.ConeGeometry = function (
		radius, height,
		radialSegments, heightSegments,
		openEnded, thetaStart, thetaLength ) {
	
		THREE.CylinderGeometry.call( this,
			0, radius, height,
			radialSegments, heightSegments,
			openEnded, thetaStart, thetaLength );
	
		this.type = 'ConeGeometry';
	
		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
	};
	
	THREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );
	THREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;
	
	// File:src/extras/geometries/EdgesGeometry.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {
	
		THREE.BufferGeometry.call( this );
	
		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
		var thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );
	
		var edge = [ 0, 0 ], hash = {};
	
		function sortFunction( a, b ) {
	
			return a - b;
	
		}
	
		var keys = [ 'a', 'b', 'c' ];
	
		var geometry2;
	
		if ( geometry instanceof THREE.BufferGeometry ) {
	
			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( geometry );
	
		} else {
	
			geometry2 = geometry.clone();
	
		}
	
		geometry2.mergeVertices();
		geometry2.computeFaceNormals();
	
		var vertices = geometry2.vertices;
		var faces = geometry2.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0; j < 3; j ++ ) {
	
				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );
	
				var key = edge.toString();
	
				if ( hash[ key ] === undefined ) {
	
					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
	
				} else {
	
					hash[ key ].face2 = i;
	
				}
	
			}
	
		}
	
		var coords = [];
	
		for ( var key in hash ) {
	
			var h = hash[ key ];
	
			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {
	
				var vertex = vertices[ h.vert1 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );
	
				vertex = vertices[ h.vert2 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );
	
			}
	
		}
	
		this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );
	
	};
	
	THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
	
	// File:src/extras/geometries/ExtrudeGeometry.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ExtrudeGeometry = function ( shapes, options ) {
	
		if ( typeof( shapes ) === "undefined" ) {
	
			shapes = [];
			return;
	
		}
	
		THREE.Geometry.call( this );
	
		this.type = 'ExtrudeGeometry';
	
		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides
	
		//this.computeVertexNormals();
	
		//console.log( "took", ( Date.now() - startTime ) );
	
	};
	
	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
	
	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		var sl = shapes.length;
	
		for ( var s = 0; s < sl; s ++ ) {
	
			var shape = shapes[ s ];
			this.addShape( shape, options );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
		var amount = options.amount !== undefined ? options.amount : 100;
	
		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var steps = options.steps !== undefined ? options.steps : 1;
	
		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;
	
		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
	
		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {
	
			extrudePts = extrudePath.getSpacedPoints( steps );
	
			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion
	
			// SETUP TNB variables
	
			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?
	
			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );
	
			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();
	
		}
	
		// Safeguards if bevels are not enabled
	
		if ( ! bevelEnabled ) {
	
			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;
	
		}
	
		// Variables initialization
	
		var ahole, h, hl; // looping of holes
		var scope = this;
	
		var shapesOffset = this.vertices.length;
	
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				if ( THREE.ShapeUtils.isClockWise( ahole ) ) {
	
					holes[ h ] = ahole.reverse();
	
				}
	
			}
	
			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
		}
	
	
		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );
	
		/* Vertices */
	
		var contour = vertices; // vertices has all points but contour has only points of circumference
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			vertices = vertices.concat( ahole );
	
		}
	
	
		function scalePt2 ( pt, vec, size ) {
	
			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
			return vec.clone().multiplyScalar( size ).add( pt );
	
		}
	
		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;
	
	
		// Find directions for point movement
	
	
		function getBevelVec( inPt, inPrev, inNext ) {
	
			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.
	
			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt
	
			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html
	
			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
	
			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
	
			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			if ( Math.abs( collinear0 ) > Number.EPSILON ) {
	
				// not collinear
	
				// length of vectors for normalizing
	
				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
	
				// shift adjacent points by unit vectors to the left
	
				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
	
				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
				// scaling factor for v_prev to intersection point
	
				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
				// vector from inPt to intersection point
	
				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {
	
					return	new THREE.Vector2( v_trans_x, v_trans_y );
	
				} else {
	
					shrink_by = Math.sqrt( v_trans_lensq / 2 );
	
				}
	
			} else {
	
				// handle special case of collinear edges
	
				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > Number.EPSILON ) {
	
					if ( v_next_x > Number.EPSILON ) {
	
						direction_eq = true;
	
					}
	
				} else {
	
					if ( v_prev_x < - Number.EPSILON ) {
	
						if ( v_next_x < - Number.EPSILON ) {
	
							direction_eq = true;
	
						}
	
					} else {
	
						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
	
							direction_eq = true;
	
						}
	
					}
	
				}
	
				if ( direction_eq ) {
	
					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );
	
				} else {
	
					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );
	
				}
	
			}
	
			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
		}
	
	
		var contourMovements = [];
	
		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
			if ( j === il ) j = 0;
			if ( k === il ) k = 0;
	
			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)
	
			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
		}
	
		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			oneHoleMovements = [];
	
			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
			}
	
			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );
	
		}
	
	
		// Loop bevelSegments, 1 for the front, 1 for the back
	
		for ( b = 0; b < bevelSegments; b ++ ) {
	
			//for ( b = bevelSegments; b > 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
	
			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
			//bs = bevelSize * t; // linear
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
				v( vert.x, vert.y,  - z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					v( vert.x, vert.y,  - z );
	
				}
	
			}
	
		}
	
		bs = bevelSize;
	
		// Back facing vertices
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
			if ( ! extrudeByPath ) {
	
				v( vert.x, vert.y, 0 );
	
			} else {
	
				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
	
				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
	
				v( position2.x, position2.y, position2.z );
	
			}
	
		}
	
		// Add stepped vertices...
		// Including front facing vertices
	
		var s;
	
		for ( s = 1; s <= steps; s ++ ) {
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, amount / steps * s );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
		}
	
	
		// Add bevel segments planes
	
		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 );
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y,  amount + z );
	
					} else {
	
						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
					}
	
				}
	
			}
	
		}
	
		/* Faces */
	
		// Top and bottom faces
	
		buildLidFaces();
	
		// Sides faces
	
		buildSideFaces();
	
	
		/////  Internal functions
	
		function buildLidFaces() {
	
			if ( bevelEnabled ) {
	
				var layer = 0; // steps + 1
				var offset = vlen * layer;
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
				}
	
				layer = steps + bevelSegments * 2;
				offset = vlen * layer;
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
				}
	
			} else {
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
				}
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
				}
	
			}
	
		}
	
		// Create faces for the z-sides of the shape
	
		function buildSideFaces() {
	
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );
	
				//, true
				layeroffset += ahole.length;
	
			}
	
		}
	
		function sidewalls( contour, layeroffset ) {
	
			var j, k;
			i = contour.length;
	
			while ( -- i >= 0 ) {
	
				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;
	
				//console.log('b', i,j, i-1, k,vertices.length);
	
				var s = 0, sl = steps  + bevelSegments * 2;
	
				for ( s = 0; s < sl; s ++ ) {
	
					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );
	
					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;
	
					f4( a, b, c, d, contour, s, sl, j, k );
	
				}
	
			}
	
		}
	
	
		function v( x, y, z ) {
	
			scope.vertices.push( new THREE.Vector3( x, y, z ) );
	
		}
	
		function f3( a, b, c ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
	
			scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );
	
			var uvs = uvgen.generateTopUV( scope, a, b, c );
	
			scope.faceVertexUvs[ 0 ].push( uvs );
	
		}
	
		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;
	
			scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
			scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );
	
			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );
	
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.WorldUVGenerator = {
	
		generateTopUV: function ( geometry, indexA, indexB, indexC ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
	
			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];
	
		},
	
		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];
	
			if ( Math.abs( a.y - b.y ) < 0.01 ) {
	
				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];
	
			} else {
	
				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];
	
			}
	
		}
	};
	
	// File:src/extras/geometries/ShapeGeometry.js
	
	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ShapeGeometry = function ( shapes, options ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ShapeGeometry';
	
		if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
	};
	
	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
	
	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
			this.addShape( shapes[ i ], options );
	
		}
	
		return this;
	
	};
	
	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {
	
		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	
		//
	
		var i, l, hole;
	
		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe...
	
			for ( i = 0, l = holes.length; i < l; i ++ ) {
	
				hole = holes[ i ];
	
				if ( THREE.ShapeUtils.isClockWise( hole ) ) {
	
					holes[ i ] = hole.reverse();
	
				}
	
			}
	
			reverse = false;
	
		}
	
		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );
	
		// Vertices
	
		for ( i = 0, l = holes.length; i < l; i ++ ) {
	
			hole = holes[ i ];
			vertices = vertices.concat( hole );
	
		}
	
		//
	
		var vert, vlen = vertices.length;
		var face, flen = faces.length;
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = vertices[ i ];
	
			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );
	
		}
	
		for ( i = 0; i < flen; i ++ ) {
	
			face = faces[ i ];
	
			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;
	
			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );
	
		}
	
	};
	
	// File:src/extras/geometries/LatheBufferGeometry.js
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	 // points - to create a closed torus, one must use a set of points
	 //    like so: [ a, b, c, d, a ], see first is the same as last.
	 // segments - the number of circumference segments to create
	 // phiStart - the starting radian
	 // phiLength - the radian (0 to 2PI) range of the lathed section
	 //    2PI is a closed lathe, less than 2PI is a portion.
	
	THREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'LatheBufferGeometry';
	
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
	
		segments = Math.floor( segments ) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;
	
		// clamp phiLength so it's in range of [ 0, 2PI ]
		phiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );
	
		// these are used to calculate buffer length
		var vertexCount = ( segments + 1 ) * points.length;
		var indexCount = segments * points.length * 2 * 3;
	
		// buffers
		var indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
		var vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
		// helper variables
		var index = 0, indexOffset = 0, base;
		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;
		var vertex = new THREE.Vector3();
		var uv = new THREE.Vector2();
		var i, j;
	
		// generate vertices and uvs
	
		for ( i = 0; i <= segments; i ++ ) {
	
			var phi = phiStart + i * inverseSegments * phiLength;
	
			var sin = Math.sin( phi );
			var cos = Math.cos( phi );
	
			for ( j = 0; j <= ( points.length - 1 ); j ++ ) {
	
				// vertex
				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;
				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
				// uv
				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );
				uvs.setXY( index, uv.x, uv.y );
	
				// increase index
				index ++;
	
			}
	
		}
	
		// generate indices
	
		for ( i = 0; i < segments; i ++ ) {
	
			for ( j = 0; j < ( points.length - 1 ); j ++ ) {
	
				base = j + i * points.length;
	
				// indices
				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;
	
				// face one
				indices.setX( indexOffset, a ); indexOffset++;
				indices.setX( indexOffset, b ); indexOffset++;
				indices.setX( indexOffset, d ); indexOffset++;
	
				// face two
				indices.setX( indexOffset, b ); indexOffset++;
				indices.setX( indexOffset, c ); indexOffset++;
				indices.setX( indexOffset, d ); indexOffset++;
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', vertices );
		this.addAttribute( 'uv', uvs );
	
		// generate normals
	
		this.computeVertexNormals();
	
		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).
	
		if( phiLength === Math.PI * 2 ) {
	
			var normals = this.attributes.normal.array;
			var n1 = new THREE.Vector3();
			var n2 = new THREE.Vector3();
			var n = new THREE.Vector3();
	
			// this is the buffer offset for the last line of vertices
			base = segments * points.length * 3;
	
			for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {
	
				// select the normal of the vertex in the first line
				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];
	
				// select the normal of the vertex in the last line
				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];
	
				// average normals
				n.addVectors( n1, n2 ).normalize();
	
				// assign the new values to both normals
				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;
	
			} // next row
	
		}
	
	};
	
	THREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;
	
	// File:src/extras/geometries/LatheGeometry.js
	
	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 */
	
	// points - to create a closed torus, one must use a set of points
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2PI) range of the lathed section
	//    2PI is a closed lathe, less than 2PI is a portion.
	
	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'LatheGeometry';
	
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
	
		this.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();
	
	};
	
	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
	
	// File:src/extras/geometries/PlaneGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'PlaneGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	
	};
	
	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
	
	// File:src/extras/geometries/PlaneBufferGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'PlaneBufferGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		var width_half = width / 2;
		var height_half = height / 2;
	
		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;
	
		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;
	
		var segment_width = width / gridX;
		var segment_height = height / gridY;
	
		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );
	
		var offset = 0;
		var offset2 = 0;
	
		for ( var iy = 0; iy < gridY1; iy ++ ) {
	
			var y = iy * segment_height - height_half;
	
			for ( var ix = 0; ix < gridX1; ix ++ ) {
	
				var x = ix * segment_width - width_half;
	
				vertices[ offset ] = x;
				vertices[ offset + 1 ] = - y;
	
				normals[ offset + 2 ] = 1;
	
				uvs[ offset2 ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );
	
				offset += 3;
				offset2 += 2;
	
			}
	
		}
	
		offset = 0;
	
		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );
	
		for ( var iy = 0; iy < gridY; iy ++ ) {
	
			for ( var ix = 0; ix < gridX; ix ++ ) {
	
				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;
	
				indices[ offset ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;
	
				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;
	
				offset += 6;
	
			}
	
		}
	
		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
	};
	
	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
	
	// File:src/extras/geometries/RingBufferGeometry.js
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	THREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'RingBufferGeometry';
	
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		innerRadius = innerRadius || 20;
		outerRadius = outerRadius || 50;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;
	
		// these are used to calculate buffer length
		var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
		var indexCount = thetaSegments * phiSegments * 2 * 3;
	
		// buffers
		var indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
		var vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
		// some helper variables
		var index = 0, indexOffset = 0, segment;
		var radius = innerRadius;
		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		var vertex = new THREE.Vector3();
		var uv = new THREE.Vector2();
		var j, i;
	
		// generate vertices, normals and uvs
	
		// values are generate from the inside of the ring to the outside
	
		for ( j = 0; j <= phiSegments; j ++ ) {
	
			for ( i = 0; i <= thetaSegments; i ++ ) {
	
				segment = thetaStart + i / thetaSegments * thetaLength;
	
				// vertex
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
				// normal
				normals.setXYZ( index, 0, 0, 1 );
	
				// uv
				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;
				uvs.setXY( index, uv.x, uv.y );
	
				// increase index
				index++;
	
			}
	
			// increase the radius for next row of vertices
			radius += radiusStep;
	
		}
	
		// generate indices
	
		for ( j = 0; j < phiSegments; j ++ ) {
	
			var thetaSegmentLevel = j * ( thetaSegments + 1 );
	
			for ( i = 0; i < thetaSegments; i ++ ) {
	
				segment = i + thetaSegmentLevel;
	
				// indices
				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;
	
				// face one
				indices.setX( indexOffset, a ); indexOffset++;
				indices.setX( indexOffset, b ); indexOffset++;
				indices.setX( indexOffset, c ); indexOffset++;
	
				// face two
				indices.setX( indexOffset, a ); indexOffset++;
				indices.setX( indexOffset, c ); indexOffset++;
				indices.setX( indexOffset, d ); indexOffset++;
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', vertices );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );
	
	};
	
	THREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;
	
	// File:src/extras/geometries/RingGeometry.js
	
	/**
	 * @author Kaleb Murphy
	 */
	
	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'RingGeometry';
	
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
	
	};
	
	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
	
	// File:src/extras/geometries/SphereGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'SphereGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	
	};
	
	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
	
	// File:src/extras/geometries/SphereBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */
	
	THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'SphereBufferGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 50;
	
		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
		var thetaEnd = thetaStart + thetaLength;
	
		var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );
	
		var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
		var index = 0, vertices = [], normal = new THREE.Vector3();
	
		for ( var y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
	
			var v = y / heightSegments;
	
			for ( var x = 0; x <= widthSegments; x ++ ) {
	
				var u = x / widthSegments;
	
				var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				var py = radius * Math.cos( thetaStart + v * thetaLength );
				var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
				normal.set( px, py, pz ).normalize();
	
				positions.setXYZ( index, px, py, pz );
				normals.setXYZ( index, normal.x, normal.y, normal.z );
				uvs.setXY( index, u, 1 - v );
	
				verticesRow.push( index );
	
				index ++;
	
			}
	
			vertices.push( verticesRow );
	
		}
	
		var indices = [];
	
		for ( var y = 0; y < heightSegments; y ++ ) {
	
			for ( var x = 0; x < widthSegments; x ++ ) {
	
				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];
	
				if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
				if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );
	
			}
	
		}
	
		this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
		this.addAttribute( 'position', positions );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
	
	// File:src/extras/geometries/TextGeometry.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */
	
	THREE.TextGeometry = function ( text, parameters ) {
	
		parameters = parameters || {};
	
		var font = parameters.font;
	
		if ( font instanceof THREE.Font === false ) {
	
			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new THREE.Geometry();
	
		}
	
		var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );
	
		// translate parameters to ExtrudeGeometry API
	
		parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
		// defaults
	
		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
		THREE.ExtrudeGeometry.call( this, shapes, parameters );
	
		this.type = 'TextGeometry';
	
	};
	
	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
	
	// File:src/extras/geometries/TorusBufferGeometry.js
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	THREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'TorusBufferGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
	
		radius = radius || 100;
		tube = tube || 40;
		radialSegments = Math.floor( radialSegments ) || 8;
		tubularSegments = Math.floor( tubularSegments ) || 6;
		arc = arc || Math.PI * 2;
	
		// used to calculate buffer length
		var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
		var indexCount = radialSegments * tubularSegments * 2 * 3;
	
		// buffers
		var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
		var vertices = new Float32Array( vertexCount * 3 );
		var normals = new Float32Array( vertexCount * 3 );
		var uvs = new Float32Array( vertexCount * 2 );
	
		// offset variables
		var vertexBufferOffset = 0;
		var uvBufferOffset = 0;
		var indexBufferOffset = 0;
	
		// helper variables
		var center = new THREE.Vector3();
		var vertex = new THREE.Vector3();
		var normal = new THREE.Vector3();
	
		var j, i;
	
		// generate vertices, normals and uvs
	
		for ( j = 0; j <= radialSegments; j ++ ) {
	
			for ( i = 0; i <= tubularSegments; i ++ ) {
	
				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;
	
				// vertex
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );
	
				vertices[ vertexBufferOffset ] = vertex.x;
				vertices[ vertexBufferOffset + 1 ] = vertex.y;
				vertices[ vertexBufferOffset + 2 ] = vertex.z;
	
				// this vector is used to calculate the normal
				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
	
				// normal
				normal.subVectors( vertex, center ).normalize();
	
				normals[ vertexBufferOffset ] = normal.x;
				normals[ vertexBufferOffset + 1 ] = normal.y;
				normals[ vertexBufferOffset + 2 ] = normal.z;
	
				// uv
				uvs[ uvBufferOffset ] = i / tubularSegments;
				uvs[ uvBufferOffset + 1 ] = j / radialSegments;
	
				// update offsets
				vertexBufferOffset += 3;
				uvBufferOffset += 2;
	
			}
	
		}
	
		// generate indices
	
		for ( j = 1; j <= radialSegments; j ++ ) {
	
			for ( i = 1; i <= tubularSegments; i ++ ) {
	
				// indices
				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;
	
				// face one
				indices[ indexBufferOffset ] = a;
				indices[ indexBufferOffset + 1 ] = b;
				indices[ indexBufferOffset + 2 ] = d;
	
				// face two
				indices[ indexBufferOffset + 3 ] = b;
				indices[ indexBufferOffset + 4 ] = c;
				indices[ indexBufferOffset + 5 ] = d;
	
				// update offset
				indexBufferOffset += 6;
	
			}
	
		}
	
		// build geometry
		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
	};
	
	THREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;
	
	// File:src/extras/geometries/TorusGeometry.js
	
	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */
	
	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
	
		this.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
	
	};
	
	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
	
	// File:src/extras/geometries/TorusKnotBufferGeometry.js
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * see: http://www.blackpawn.com/texts/pqtorus/
	 */
	THREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'TorusKnotBufferGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};
	
		radius = radius || 100;
		tube = tube || 40;
		tubularSegments = Math.floor( tubularSegments ) || 64;
		radialSegments = Math.floor( radialSegments ) || 8;
		p = p || 2;
		q = q || 3;
	
		// used to calculate buffer length
		var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
		var indexCount = radialSegments * tubularSegments * 2 * 3;
	
		// buffers
		var indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
		var vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
		// helper variables
		var i, j, index = 0, indexOffset = 0;
	
		var vertex = new THREE.Vector3();
		var normal = new THREE.Vector3();
		var uv = new THREE.Vector2();
	
		var P1 = new THREE.Vector3();
		var P2 = new THREE.Vector3();
	
		var B = new THREE.Vector3();
		var T = new THREE.Vector3();
		var N = new THREE.Vector3();
	
		// generate vertices, normals and uvs
	
		for ( i = 0; i <= tubularSegments; ++ i ) {
	
			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
	
			var u = i / tubularSegments * p * Math.PI * 2;
	
			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
	
			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );
	
			// calculate orthonormal basis
	
			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );
	
			// normalize B, N. T can be ignored, we don't use it
	
			B.normalize();
			N.normalize();
	
			for ( j = 0; j <= radialSegments; ++ j ) {
	
				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
	
				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos( v );
				var cy = tube * Math.sin( v );
	
				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
	
				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );
	
				// vertex
				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
				normal.subVectors( vertex, P1 ).normalize();
				normals.setXYZ( index, normal.x, normal.y, normal.z );
	
				// uv
				uv.x = i / tubularSegments;
				uv.y = j / radialSegments;
				uvs.setXY( index, uv.x, uv.y );
	
				// increase index
				index ++;
	
			}
	
		}
	
		// generate indices
	
		for ( j = 1; j <= tubularSegments; j ++ ) {
	
			for ( i = 1; i <= radialSegments; i ++ ) {
	
				// indices
				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
				// face one
				indices.setX( indexOffset, a ); indexOffset++;
				indices.setX( indexOffset, b ); indexOffset++;
				indices.setX( indexOffset, d ); indexOffset++;
	
				// face two
				indices.setX( indexOffset, b ); indexOffset++;
				indices.setX( indexOffset, c ); indexOffset++;
				indices.setX( indexOffset, d ); indexOffset++;
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', vertices );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );
	
		// this function calculates the current position on the torus curve
	
		function calculatePositionOnCurve( u, p, q, radius, position ) {
	
			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = q / p * u;
			var cs = Math.cos( quOverP );
	
			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;
	
		}
	
	};
	
	THREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;
	
	// File:src/extras/geometries/TorusKnotGeometry.js
	
	/**
	 * @author oosmoxiecode
	 */
	
	THREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusKnotGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};
	
		if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );
	
		this.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();
	
	};
	
	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
	
	// File:src/extras/geometries/TubeGeometry.js
	
	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */
	
	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TubeGeometry';
	
		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed,
			taper: taper
		};
	
		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;
	
		var grid = [];
	
		var scope = this,
	
			tangent,
			normal,
			binormal,
	
			numpoints = segments + 1,
	
			u, v, r,
	
			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;
	
		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;
	
		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		function vert( x, y, z ) {
	
			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;
	
		}
	
		// construct the grid
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			grid[ i ] = [];
	
			u = i / ( numpoints - 1 );
	
			pos = path.getPointAt( u );
	
			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];
	
			r = radius * taper( u );
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				v = j / radialSegments * 2 * Math.PI;
	
				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );
	
				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;
	
				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );
	
			}
	
		}
	
	
		// construct the mesh
	
		for ( i = 0; i < segments; i ++ ) {
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
				jp = ( j + 1 ) % radialSegments;
	
				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];
	
				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
	
	THREE.TubeGeometry.NoTaper = function ( u ) {
	
		return 1;
	
	};
	
	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {
	
		return Math.sin( Math.PI * u );
	
	};
	
	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {
	
		var	normal = new THREE.Vector3(),
	
			tangents = [],
			normals = [],
			binormals = [],
	
			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),
	
			numpoints = segments + 1,
			theta,
			smallest,
	
			tx, ty, tz,
			i, u;
	
	
		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		// compute the tangent vectors for each segment on the path
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			u = i / ( numpoints - 1 );
	
			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();
	
		}
	
		initialNormal3();
	
		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}
	
		function initialNormal2() {
	
			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );
	
			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );
	
			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	
		}
		*/
	
		function initialNormal3() {
	
			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component
	
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );
	
			if ( tx <= smallest ) {
	
				smallest = tx;
				normal.set( 1, 0, 0 );
	
			}
	
			if ( ty <= smallest ) {
	
				smallest = ty;
				normal.set( 0, 1, 0 );
	
			}
	
			if ( tz <= smallest ) {
	
				normal.set( 0, 0, 1 );
	
			}
	
			vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	
		}
	
	
		// compute the slowly-varying normal and binormal vectors for each segment on the path
	
		for ( i = 1; i < numpoints; i ++ ) {
	
			normals[ i ] = normals[ i - 1 ].clone();
	
			binormals[ i ] = binormals[ i - 1 ].clone();
	
			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
			if ( vec.length() > Number.EPSILON ) {
	
				vec.normalize();
	
				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
			}
	
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
		}
	
	
		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
		if ( closed ) {
	
			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );
	
			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {
	
				theta = - theta;
	
			}
	
			for ( i = 1; i < numpoints; i ++ ) {
	
				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
			}
	
		}
	
	};
	
	// File:src/extras/geometries/PolyhedronGeometry.js
	
	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'PolyhedronGeometry';
	
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};
	
		radius = radius || 1;
		detail = detail || 0;
	
		var that = this;
	
		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {
	
			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );
	
		}
	
		var p = this.vertices;
	
		var faces = [];
	
		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {
	
			var v1 = p[ indices[ i ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];
	
			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
	
		}
	
		var centroid = new THREE.Vector3();
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			subdivide( faces[ i ], detail );
	
		}
	
	
		// Handle case when face straddles the seam
	
		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {
	
			var uvs = this.faceVertexUvs[ 0 ][ i ];
	
			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;
	
			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );
	
			if ( max > 0.9 && min < 0.1 ) {
	
				// 0.9 is somewhat arbitrary
	
				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;
	
			}
	
		}
	
	
		// Apply radius
	
		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {
	
			this.vertices[ i ].multiplyScalar( radius );
	
		}
	
	
		// Merge vertices
	
		this.mergeVertices();
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	
		// Project vector onto sphere's surface
	
		function prepare( vector ) {
	
			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;
	
			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.
	
			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );
	
			return vertex;
	
		}
	
	
		// Approximate a curved face with recursively sub-divided triangles.
	
		function make( v1, v2, v3 ) {
	
			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
			that.faces.push( face );
	
			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
	
			var azi = azimuth( centroid );
	
			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );
	
		}
	
	
		// Analytically subdivide a face to the required detail level.
	
		function subdivide( face, detail ) {
	
			var cols = Math.pow( 2, detail );
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];
	
			// Construct all of the vertices for this subdivision.
	
			for ( var i = 0 ; i <= cols; i ++ ) {
	
				v[ i ] = [];
	
				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;
	
				for ( var j = 0; j <= rows; j ++ ) {
	
					if ( j === 0 && i === cols ) {
	
						v[ i ][ j ] = aj;
	
					} else {
	
						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );
	
					}
	
				}
	
			}
	
			// Construct all of the faces.
	
			for ( var i = 0; i < cols ; i ++ ) {
	
				for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
	
					var k = Math.floor( j / 2 );
	
					if ( j % 2 === 0 ) {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k ],
							v[ i ][ k ]
						);
	
					} else {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k + 1 ],
							v[ i + 1 ][ k ]
						);
	
					}
	
				}
	
			}
	
		}
	
	
		// Angle around the Y axis, counter-clockwise when looking from above.
	
		function azimuth( vector ) {
	
			return Math.atan2( vector.z, - vector.x );
	
		}
	
	
		// Angle above the XZ plane.
	
		function inclination( vector ) {
	
			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
		}
	
	
		// Texture fixing helper. Spheres have some odd behaviours.
	
		function correctUV( uv, vector, azimuth ) {
	
			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();
	
		}
	
	
	};
	
	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
	
	// File:src/extras/geometries/DodecahedronGeometry.js
	
	/**
	 * @author Abe Pazos / https://hamoid.com
	 */
	
	THREE.DodecahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;
	
		var vertices = [
	
			// (1, 1, 1)
			- 1, - 1, - 1,    - 1, - 1,  1,
			- 1,  1, - 1,    - 1,  1,  1,
			 1, - 1, - 1,     1, - 1,  1,
			 1,  1, - 1,     1,  1,  1,
	
			// (0, 1/, )
			 0, - r, - t,     0, - r,  t,
			 0,  r, - t,     0,  r,  t,
	
			// (1/, , 0)
			- r, - t,  0,    - r,  t,  0,
			 r, - t,  0,     r,  t,  0,
	
			// (, 0, 1/)
			- t,  0, - r,     t,  0, - r,
			- t,  0,  r,     t,  0,  r
		];
	
		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'DodecahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
	
	// File:src/extras/geometries/IcosahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.IcosahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];
	
		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'IcosahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
	
	// File:src/extras/geometries/OctahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.OctahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
		];
	
		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'OctahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
	
	// File:src/extras/geometries/TetrahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.TetrahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];
	
		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'TetrahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
	
	// File:src/extras/geometries/ParametricGeometry.js
	
	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */
	
	THREE.ParametricGeometry = function ( func, slices, stacks ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ParametricGeometry';
	
		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};
	
		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];
	
		var i, j, p;
		var u, v;
	
		var sliceCount = slices + 1;
	
		for ( i = 0; i <= stacks; i ++ ) {
	
			v = i / stacks;
	
			for ( j = 0; j <= slices; j ++ ) {
	
				u = j / slices;
	
				p = func( u, v );
				verts.push( p );
	
			}
	
		}
	
		var a, b, c, d;
		var uva, uvb, uvc, uvd;
	
		for ( i = 0; i < stacks; i ++ ) {
	
			for ( j = 0; j < slices; j ++ ) {
	
				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = ( i + 1 ) * sliceCount + j + 1;
				d = ( i + 1 ) * sliceCount + j;
	
				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );
	
				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );
	
				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		// console.log(this);
	
		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
	
	// File:src/extras/geometries/WireframeGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeGeometry = function ( geometry ) {
	
		THREE.BufferGeometry.call( this );
	
		var edge = [ 0, 0 ], hash = {};
	
		function sortFunction( a, b ) {
	
			return a - b;
	
		}
	
		var keys = [ 'a', 'b', 'c' ];
	
		if ( geometry instanceof THREE.Geometry ) {
	
			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var numEdges = 0;
	
			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );
	
					var key = edge.toString();
	
					if ( hash[ key ] === undefined ) {
	
						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;
	
					}
	
				}
	
			}
	
			var coords = new Float32Array( numEdges * 2 * 3 );
	
			for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
				for ( var j = 0; j < 2; j ++ ) {
	
					var vertex = vertices[ edges [ 2 * i + j ] ];
	
					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;
	
				}
	
			}
	
			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
		} else if ( geometry instanceof THREE.BufferGeometry ) {
	
			if ( geometry.index !== null ) {
	
				// Indexed BufferGeometry
	
				var indices = geometry.index.array;
				var vertices = geometry.attributes.position;
				var groups = geometry.groups;
				var numEdges = 0;
	
				if ( groups.length === 0 ) {
	
					geometry.addGroup( 0, indices.length );
	
				}
	
				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );
	
				for ( var o = 0, ol = groups.length; o < ol; ++ o ) {
	
					var group = groups[ o ];
	
					var start = group.start;
					var count = group.count;
	
					for ( var i = start, il = start + count; i < il; i += 3 ) {
	
						for ( var j = 0; j < 3; j ++ ) {
	
							edge[ 0 ] = indices[ i + j ];
							edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );
	
							var key = edge.toString();
	
							if ( hash[ key ] === undefined ) {
	
								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;
	
							}
	
						}
	
					}
	
				}
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
					for ( var j = 0; j < 2; j ++ ) {
	
						var index = 6 * i + 3 * j;
						var index2 = edges[ 2 * i + j ];
	
						coords[ index + 0 ] = vertices.getX( index2 );
						coords[ index + 1 ] = vertices.getY( index2 );
						coords[ index + 2 ] = vertices.getZ( index2 );
	
					}
	
				}
	
				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			} else {
	
				// non-indexed BufferGeometry
	
				var vertices = geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numTris; i < l; i ++ ) {
	
					for ( var j = 0; j < 3; j ++ ) {
	
						var index = 18 * i + 6 * j;
	
						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];
	
						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];
	
					}
	
				}
	
				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			}
	
		}
	
	};
	
	THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
	
	// File:src/extras/helpers/AxisHelper.js
	
	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AxisHelper = function ( size ) {
	
		size = size || 1;
	
		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );
	
		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );
	
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		THREE.LineSegments.call( this, geometry, material );
	
	};
	
	THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
	
	// File:src/extras/helpers/ArrowHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */
	
	THREE.ArrowHelper = ( function () {
	
		var lineGeometry = new THREE.BufferGeometry();
		lineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );
	
		var coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );
	
		return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	
			// dir is assumed to be normalized
	
			THREE.Object3D.call( this );
	
			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.position.copy( origin );
	
			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
	
			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );
	
			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );
	
		};
	
	}() );
	
	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
	
	THREE.ArrowHelper.prototype.setDirection = ( function () {
	
		var axis = new THREE.Vector3();
		var radians;
	
		return function setDirection( dir ) {
	
			// dir is assumed to be normalized
	
			if ( dir.y > 0.99999 ) {
	
				this.quaternion.set( 0, 0, 0, 1 );
	
			} else if ( dir.y < - 0.99999 ) {
	
				this.quaternion.set( 1, 0, 0, 0 );
	
			} else {
	
				axis.set( dir.z, 0, - dir.x ).normalize();
	
				radians = Math.acos( dir.y );
	
				this.quaternion.setFromAxisAngle( axis, radians );
	
			}
	
		};
	
	}() );
	
	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();
	
		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();
	
	};
	
	THREE.ArrowHelper.prototype.setColor = function ( color ) {
	
		this.line.material.color.copy( color );
		this.cone.material.color.copy( color );
	
	};
	
	// File:src/extras/helpers/BoxHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BoxHelper = function ( object, color ) {
	
		if ( color === undefined ) color = 0xffff00;
	
		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );
	
		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );
	
		if ( object !== undefined ) {
	
			this.update( object );
	
		}
	
	};
	
	THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
	
	THREE.BoxHelper.prototype.update = ( function () {
	
		var box = new THREE.Box3();
	
		return function update( object ) {
	
			if ( object instanceof THREE.Box3 ) {
	
				box.copy( object );
	
			} else {
	
				box.setFromObject( object );
	
			}
	
			if ( box.isEmpty() ) return;
	
			var min = box.min;
			var max = box.max;
	
			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/
	
			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/
	
			var position = this.geometry.attributes.position;
			var array = position.array;
	
			array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
			array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
			array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
			array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
	
			position.needsUpdate = true;
	
			this.geometry.computeBoundingSphere();
	
		};
	
	} )();
	
	// File:src/extras/helpers/BoundingBoxHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	// a helper to show the world-axis-aligned bounding box for an object
	
	THREE.BoundingBoxHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0x888888;
	
		this.object = object;
	
		this.box = new THREE.Box3();
	
		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );
	
	};
	
	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
	
	THREE.BoundingBoxHelper.prototype.update = function () {
	
		this.box.setFromObject( this.object );
	
		this.box.size( this.scale );
	
		this.box.center( this.position );
	
	};
	
	// File:src/extras/helpers/CameraHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */
	
	THREE.CameraHelper = function ( camera ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
	
		var pointMap = {};
	
		// colors
	
		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;
	
		// near
	
		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );
	
		// far
	
		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );
	
		// sides
	
		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );
	
		// cone
	
		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );
	
		// up
	
		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );
	
		// target
	
		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );
	
		// cross
	
		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );
	
		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );
	
		function addLine( a, b, hex ) {
	
			addPoint( a, hex );
			addPoint( b, hex );
	
		}
	
		function addPoint( id, hex ) {
	
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );
	
			if ( pointMap[ id ] === undefined ) {
	
				pointMap[ id ] = [];
	
			}
	
			pointMap[ id ].push( geometry.vertices.length - 1 );
	
		}
	
		THREE.LineSegments.call( this, geometry, material );
	
		this.camera = camera;
		if( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();
	
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.pointMap = pointMap;
	
		this.update();
	
	};
	
	THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
	
	THREE.CameraHelper.prototype.update = function () {
	
		var geometry, pointMap;
	
		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();
	
		function setPoint( point, x, y, z ) {
	
			vector.set( x, y, z ).unproject( camera );
	
			var points = pointMap[ point ];
	
			if ( points !== undefined ) {
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					geometry.vertices[ points[ i ] ].copy( vector );
	
				}
	
			}
	
		}
	
		return function update() {
	
			geometry = this.geometry;
			pointMap = this.pointMap;
	
			var w = 1, h = 1;
	
			// we need just camera projection matrix
			// world matrix must be identity
	
			camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
			// center / target
	
			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );
	
			// near
	
			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );
	
			// far
	
			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );
	
			// up
	
			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );
	
			// cross
	
			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );
	
			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );
	
			geometry.verticesNeedUpdate = true;
	
		};
	
	}();
	
	// File:src/extras/helpers/DirectionalLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.DirectionalLightHelper = function ( light, size ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		if ( size === undefined ) size = 1;
	
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.Float32Attribute( [
			- size,   size, 0,
			  size,   size, 0,
			  size, - size, 0,
			- size, - size, 0,
			- size,   size, 0
		], 3 ) );
	
		var material = new THREE.LineBasicMaterial( { fog: false } );
	
		this.add( new THREE.Line( geometry, material ) );
	
		geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );
	
		this.add( new THREE.Line( geometry, material ));
	
		this.update();
	
	};
	
	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
	
	THREE.DirectionalLightHelper.prototype.dispose = function () {
	
		var lightPlane = this.children[ 0 ];
		var targetLine = this.children[ 1 ];
	
		lightPlane.geometry.dispose();
		lightPlane.material.dispose();
		targetLine.geometry.dispose();
		targetLine.material.dispose();
	
	};
	
	THREE.DirectionalLightHelper.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();
	
		return function update() {
	
			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );
	
			var lightPlane = this.children[ 0 ];
			var targetLine = this.children[ 1 ];
	
			lightPlane.lookAt( v3 );
			lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			targetLine.lookAt( v3 );
			targetLine.scale.z = v3.length();
	
		};
	
	}();
	
	// File:src/extras/helpers/EdgesHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimum angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */
	
	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
	
	// File:src/extras/helpers/FaceNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {
	
		// FaceNormalsHelper only supports THREE.Geometry
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xffff00;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry instanceof THREE.Geometry ) {
	
			nNormals = objGeometry.faces.length;
	
		} else {
	
			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	
		}
	
		//
	
		var geometry = new THREE.BufferGeometry();
	
		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
		this.update();
	
	};
	
	THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
	
	THREE.FaceNormalsHelper.prototype.update = ( function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();
	
		return function update() {
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			var vertices = objGeometry.vertices;
	
			var faces = objGeometry.faces;
	
			var idx = 0;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				var normal = face.normal;
	
				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );
	
				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
				position.setXYZ( idx, v1.x, v1.y, v1.z );
	
				idx = idx + 1;
	
				position.setXYZ( idx, v2.x, v2.y, v2.z );
	
				idx = idx + 1;
	
			}
	
			position.needsUpdate = true;
	
			return this;
	
		};
	
	}() );
	
	// File:src/extras/helpers/GridHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.GridHelper = function ( size, divisions, color1, color2 ) {
	
		divisions = divisions || 1;
		color1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );
	
		var center = divisions / 2;
		var step = ( size * 2 ) / divisions;
		var vertices = [], colors = [];
	
		for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {
	
			vertices.push( - size, 0, k, size, 0, k );
			vertices.push( k, 0, - size, k, 0, size );
	
			var color = i === center ? color1 : color2;
	
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
	
		}
	
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		THREE.LineSegments.call( this, geometry, material );
	
	};
	
	THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;
	
	THREE.GridHelper.prototype.setColors = function () {
	
		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );
	
	};
	
	// File:src/extras/helpers/HemisphereLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.HemisphereLightHelper = function ( light, sphereSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.colors = [ new THREE.Color(), new THREE.Color() ];
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.rotateX( - Math.PI / 2 );
	
		for ( var i = 0, il = 8; i < il; i ++ ) {
	
			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];
	
		}
	
		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );
	
		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );
	
		this.update();
	
	};
	
	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
	
	THREE.HemisphereLightHelper.prototype.dispose = function () {
	
		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();
	
	};
	
	THREE.HemisphereLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
	
		return function update() {
	
			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );
	
			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;
	
		};
	
	}();
	
	// File:src/extras/helpers/PointLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PointLightHelper = function ( light, sphereSize ) {
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		var geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		THREE.Mesh.call( this, geometry, material );
	
		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
		var d = light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.scale.set( d, d, d );
	
		}
	
		this.add( this.lightDistance );
		*/
	
	};
	
	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
	
	THREE.PointLightHelper.prototype.dispose = function () {
	
		this.geometry.dispose();
		this.material.dispose();
	
	};
	
	THREE.PointLightHelper.prototype.update = function () {
	
		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		/*
		var d = this.light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
	
		}
		*/
	
	};
	
	// File:src/extras/helpers/SkeletonHelper.js
	
	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkeletonHelper = function ( object ) {
	
		this.bones = this.getBoneList( object );
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );
	
			}
	
		}
	
		geometry.dynamic = true;
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
		THREE.LineSegments.call( this, geometry, material );
	
		this.root = object;
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	
	THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
	
	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {
	
		var boneList = [];
	
		if ( object instanceof THREE.Bone ) {
	
			boneList.push( object );
	
		}
	
		for ( var i = 0; i < object.children.length; i ++ ) {
	
			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );
	
		}
	
		return boneList;
	
	};
	
	THREE.SkeletonHelper.prototype.update = function () {
	
		var geometry = this.geometry;
	
		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );
	
		var boneMatrix = new THREE.Matrix4();
	
		var j = 0;
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );
	
				j += 2;
	
			}
	
		}
	
		geometry.verticesNeedUpdate = true;
	
		geometry.computeBoundingSphere();
	
	};
	
	// File:src/extras/helpers/SpotLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.SpotLightHelper = function ( light ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		var geometry = new THREE.BufferGeometry();
	
		var positions = [
			0, 0, 0,   0,   0,   1,
			0, 0, 0,   1,   0,   1,
			0, 0, 0, - 1,   0,   1,
			0, 0, 0,   0,   1,   1,
			0, 0, 0,   0, - 1,   1
		];
	
		for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {
	
			var p1 = ( i / l ) * Math.PI * 2;
			var p2 = ( j / l ) * Math.PI * 2;
	
			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);
	
		}
	
		geometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );
	
		var material = new THREE.LineBasicMaterial( { fog: false } );
	
		this.cone = new THREE.LineSegments( geometry, material );
		this.add( this.cone );
	
		this.update();
	
	};
	
	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
	
	THREE.SpotLightHelper.prototype.dispose = function () {
	
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	
	};
	
	THREE.SpotLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();
	
		return function update() {
	
			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );
	
			this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
			this.cone.lookAt( vector2.sub( vector ) );
	
			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		};
	
	}();
	
	// File:src/extras/helpers/VertexNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xff0000;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry instanceof THREE.Geometry ) {
	
			nNormals = objGeometry.faces.length * 3;
	
		} else if ( objGeometry instanceof THREE.BufferGeometry ) {
	
			nNormals = objGeometry.attributes.normal.count;
	
		}
	
		//
	
		var geometry = new THREE.BufferGeometry();
	
		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
	
	THREE.VertexNormalsHelper.prototype.update = ( function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();
	
		return function update() {
	
			var keys = [ 'a', 'b', 'c' ];
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry instanceof THREE.Geometry ) {
	
				var vertices = objGeometry.vertices;
	
				var faces = objGeometry.faces;
	
				var idx = 0;
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
						var vertex = vertices[ face[ keys[ j ] ] ];
	
						var normal = face.vertexNormals[ j ];
	
						v1.copy( vertex ).applyMatrix4( matrixWorld );
	
						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
						position.setXYZ( idx, v1.x, v1.y, v1.z );
	
						idx = idx + 1;
	
						position.setXYZ( idx, v2.x, v2.y, v2.z );
	
						idx = idx + 1;
	
					}
	
				}
	
			} else if ( objGeometry instanceof THREE.BufferGeometry ) {
	
				var objPos = objGeometry.attributes.position;
	
				var objNorm = objGeometry.attributes.normal;
	
				var idx = 0;
	
				// for simplicity, ignore index and drawcalls, and render every normal
	
				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
	
					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
	
					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
	
					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
					position.setXYZ( idx, v1.x, v1.y, v1.z );
	
					idx = idx + 1;
	
					position.setXYZ( idx, v2.x, v2.y, v2.z );
	
					idx = idx + 1;
	
				}
	
			}
	
			position.needsUpdate = true;
	
			return this;
	
		};
	
	}() );
	
	// File:src/extras/helpers/WireframeHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
	
	// File:src/extras/objects/ImmediateRenderObject.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ImmediateRenderObject = function ( material ) {
	
		THREE.Object3D.call( this );
	
		this.material = material;
		this.render = function ( renderCallback ) {};
	
	};
	
	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
	
	// File:src/extras/objects/MorphBlendMesh.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphBlendMesh = function( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.animationsMap = {};
		this.animationsList = [];
	
		// prepare default animation
		// (all frames played together in 1 second)
	
		var numFrames = this.geometry.morphTargets.length;
	
		var name = "__default";
	
		var startFrame = 0;
		var endFrame = numFrames - 1;
	
		var fps = numFrames / 1;
	
		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );
	
	};
	
	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
	
	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
		var animation = {
	
			start: start,
			end: end,
	
			length: end - start + 1,
	
			fps: fps,
			duration: ( end - start ) / fps,
	
			lastFrame: 0,
			currentFrame: 0,
	
			active: false,
	
			time: 0,
			direction: 1,
			weight: 1,
	
			directionBackwards: false,
			mirroredLoop: false
	
		};
	
		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );
	
	};
	
	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
		var pattern = /([a-z]+)_?(\d+)/i;
	
		var firstAnimation, frameRanges = {};
	
		var geometry = this.geometry;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );
	
			if ( chunks && chunks.length > 1 ) {
	
				var name = chunks[ 1 ];
	
				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };
	
				var range = frameRanges[ name ];
	
				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;
	
				if ( ! firstAnimation ) firstAnimation = name;
	
			}
	
		}
	
		for ( var name in frameRanges ) {
	
			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );
	
		}
	
		this.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = 1;
			animation.directionBackwards = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = - 1;
			animation.directionBackwards = true;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.weight = weight;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = time;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
		var time = 0;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			time = animation.time;
	
		}
	
		return time;
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
		var duration = - 1;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			duration = animation.duration;
	
		}
	
		return duration;
	
	};
	
	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = 0;
			animation.active = true;
	
		} else {
	
			console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.active = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.update = function ( delta ) {
	
		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
			var animation = this.animationsList[ i ];
	
			if ( ! animation.active ) continue;
	
			var frameTime = animation.duration / animation.length;
	
			animation.time += animation.direction * delta;
	
			if ( animation.mirroredLoop ) {
	
				if ( animation.time > animation.duration || animation.time < 0 ) {
	
					animation.direction *= - 1;
	
					if ( animation.time > animation.duration ) {
	
						animation.time = animation.duration;
						animation.directionBackwards = true;
	
					}
	
					if ( animation.time < 0 ) {
	
						animation.time = 0;
						animation.directionBackwards = false;
	
					}
	
				}
	
			} else {
	
				animation.time = animation.time % animation.duration;
	
				if ( animation.time < 0 ) animation.time += animation.duration;
	
			}
	
			var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;
	
			if ( keyframe !== animation.currentFrame ) {
	
				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
				this.morphTargetInfluences[ keyframe ] = 0;
	
				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;
	
			}
	
			var mix = ( animation.time % frameTime ) / frameTime;
	
			if ( animation.directionBackwards ) mix = 1 - mix;
	
			if ( animation.currentFrame !== animation.lastFrame ) {
	
				this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
				this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
			} else {
	
				this.morphTargetInfluences[ animation.currentFrame ] = weight;
	
			}
	
		}
	
	};
	


/***/ },
/* 65 */
/*!**********************************************************!*\
  !*** ./~/rollbar-browser/dist/rollbar.umd.nojson.min.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	!function(e,r){if(true)module.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{var t=r();for(var n in t)("object"==typeof exports?exports:e)[n]=t[n]}}(this,function(){return function(e){function r(n){if(t[n])return t[n].exports;var o=t[n]={exports:{},id:n,loaded:!1};return e[n].call(o.exports,o,o.exports,r),o.loaded=!0,o.exports}var t={};return r.m=e,r.c=t,r.p="",r(0)}([function(e,r,t){e.exports=t(1)},function(e,r,t){"use strict";function n(){var e="undefined"==typeof JSON?{}:JSON;o.setupJSON(e)}var o=t(2),i=t(3);n();var a=window._rollbarConfig,s=a&&a.globalAlias||"Rollbar",u=window[s]&&"undefined"!=typeof window[s].shimId;!u&&a?o.wrapper.init(a):(window.Rollbar=o.wrapper,window.RollbarNotifier=i.Notifier),e.exports=o.wrapper},function(e,r,t){"use strict";function n(e,r,t){!t[4]&&window._rollbarWrappedError&&(t[4]=window._rollbarWrappedError,window._rollbarWrappedError=null),e.uncaughtError.apply(e,t),r&&r.apply(window,t)}function o(e,r){if(r.hasOwnProperty&&r.hasOwnProperty("addEventListener")){var t=r.addEventListener;r.addEventListener=function(r,n,o){t.call(this,r,e.wrap(n),o)};var n=r.removeEventListener;r.removeEventListener=function(e,r,t){n.call(this,e,r&&r._wrapped||r,t)}}}var i=t(3),a=t(8),s=i.Notifier;window._rollbarWrappedError=null;var u={};u.init=function(e,r){var t=new s(r);if(t.configure(e),e.captureUncaught){var i;r&&a.isType(r._rollbarOldOnError,"function")?i=r._rollbarOldOnError:window.onerror&&!window.onerror.belongsToShim&&(i=window.onerror),window.onerror=function(){var e=Array.prototype.slice.call(arguments,0);n(t,i,e)};var u,c,l=["EventTarget","Window","Node","ApplicationCache","AudioTrackList","ChannelMergerNode","CryptoOperation","EventSource","FileReader","HTMLUnknownElement","IDBDatabase","IDBRequest","IDBTransaction","KeyOperation","MediaController","MessagePort","ModalWindow","Notification","SVGElementInstance","Screen","TextTrack","TextTrackCue","TextTrackList","WebSocket","WebSocketWorker","Worker","XMLHttpRequest","XMLHttpRequestEventTarget","XMLHttpRequestUpload"];for(u=0;u<l.length;++u)c=l[u],window[c]&&window[c].prototype&&o(t,window[c].prototype)}return window.Rollbar=t,s.processPayloads(),t},e.exports={wrapper:u,setupJSON:i.setupJSON}},function(e,r,t){"use strict";function n(e){b=e,v.setupJSON(e)}function o(e,r){return function(){var t=r||this;try{return e.apply(t,arguments)}catch(n){console.error("[Rollbar]:",n)}}}function i(){d||(d=setTimeout(p,1e3))}function a(){return y}function s(e){y=y||this;var r="https://"+s.DEFAULT_ENDPOINT;this.options={enabled:!0,endpoint:r,environment:"production",scrubFields:h([],s.DEFAULT_SCRUB_FIELDS),checkIgnore:null,logLevel:s.DEFAULT_LOG_LEVEL,reportLevel:s.DEFAULT_REPORT_LEVEL,uncaughtErrorLevel:s.DEFAULT_UNCAUGHT_ERROR_LEVEL,payload:{}},this.lastError=null,this.plugins={},this.parentNotifier=e,e&&(e.hasOwnProperty("shimId")?e.notifier=this:this.configure(e.options))}function u(e){return o(function(){var r=this._getLogArgs(arguments);return this._log(e||r.level||this.options.logLevel||s.DEFAULT_LOG_LEVEL,r.message,r.err,r.custom,r.callback)})}function c(e,r){e||(e=r?b.stringify(r):"");var t={body:e};return r&&(t.extra=h(!0,{},r)),{message:t}}function l(e,r,t){var n=g.guessErrorClass(r.message),o=r.name||n[0],i=n[1],a={exception:{"class":o,message:i}};if(e&&(a.exception.description=e||"uncaught exception"),r.stack){var s,u,l,p,f,d,v,w;for(a.frames=[],v=0;v<r.stack.length;++v)s=r.stack[v],u={filename:s.url?m.sanitizeUrl(s.url):"(unknown)",lineno:s.line||null,method:s.func&&"?"!==s.func?s.func:"[anonymous]",colno:s.column},l=p=f=null,d=s.context?s.context.length:0,d&&(w=Math.floor(d/2),p=s.context.slice(0,w),l=s.context[w],f=s.context.slice(w)),l&&(u.code=l),(p||f)&&(u.context={},p&&p.length&&(u.context.pre=p),f&&f.length&&(u.context.post=f)),s.args&&(u.args=s.args),a.frames.push(u);return a.frames.reverse(),t&&(a.extra=h(!0,{},t)),{trace:a}}return c(o+": "+i,t)}function p(){var e;try{for(;e=window._rollbarPayloadQueue.shift();)f(e.endpointUrl,e.accessToken,e.payload,e.callback)}finally{d=void 0}}function f(e,r,t,n){n=n||function(){};var o=(new Date).getTime();o-x>=6e4&&(x=o,L=0);var i=window._globalRollbarOptions.maxItems,a=window._globalRollbarOptions.itemsPerMinute,s=function(){return!t.ignoreRateLimit&&i>=1&&_>=i},u=function(){return!t.ignoreRateLimit&&a>=1&&L>=a};return s()?void n(new Error(i+" max items reached")):u()?void n(new Error(a+" items per minute reached")):(_++,L++,s()&&y._log(y.options.uncaughtErrorLevel,"maxItems has been hit. Ignoring errors for the remainder of the current page load.",null,{maxItems:i},null,!1,!0),t.ignoreRateLimit&&delete t.ignoreRateLimit,void w.post(e,r,t,function(e,r){return e?n(e):n(null,r)}))}var d,h=t(4),g=t(5),m=t(8),v=t(10),w=v.XHR,b=null;s.NOTIFIER_VERSION="1.8.4",s.DEFAULT_ENDPOINT="api.rollbar.com/api/1/",s.DEFAULT_SCRUB_FIELDS=["pw","pass","passwd","password","secret","confirm_password","confirmPassword","password_confirmation","passwordConfirmation","access_token","accessToken","secret_key","secretKey","secretToken"],s.DEFAULT_LOG_LEVEL="debug",s.DEFAULT_REPORT_LEVEL="debug",s.DEFAULT_UNCAUGHT_ERROR_LEVEL="error",s.DEFAULT_ITEMS_PER_MIN=60,s.DEFAULT_MAX_ITEMS=0,s.LEVELS={debug:0,info:1,warning:2,error:3,critical:4},window._rollbarPayloadQueue=window._rollbarPayloadQueue||[],window._globalRollbarOptions={startTime:(new Date).getTime(),maxItems:s.DEFAULT_MAX_ITEMS,itemsPerMinute:s.DEFAULT_ITEMS_PER_MIN};var y,E=s.prototype;E._getLogArgs=function(e){for(var r,t,n,i,a,u,c=this.options.logLevel||s.DEFAULT_LOG_LEVEL,l=[],p=0;p<e.length;++p)u=e[p],a=m.typeName(u),"string"===a?r?l.push(u):r=u:"function"===a?i=o(u,this):"date"===a?l.push(u):"error"===a||u instanceof Error||"undefined"!=typeof DOMException&&u instanceof DOMException?t?l.push(u):t=u:"object"===a&&(n?l.push(u):n=u);return l.length&&(n=n||{},n.extraArgs=l),{level:c,message:r,err:t,custom:n,callback:i}},E._route=function(e){var r=this.options.endpoint,t=/\/$/.test(r),n=/^\//.test(e);return t&&n?e=e.substring(1):t||n||(e="/"+e),r+e},E._processShimQueue=function(e){for(var r,t,n,o,i,a,u,c={};t=e.shift();)r=t.shim,n=t.method,o=t.args,i=r.parentShim,u=c[r.shimId],u||(i?(a=c[i.shimId],u=new s(a)):u=this,c[r.shimId]=u),u[n]&&m.isType(u[n],"function")&&u[n].apply(u,o)},E._buildPayload=function(e,r,t,n,o){var i=this.options.accessToken,a=this.options.environment,u=h(!0,{},this.options.payload),c=m.uuid4();if(void 0===s.LEVELS[r])throw new Error("Invalid level");if(!t&&!n&&!o)throw new Error("No message, stack info or custom data");var l={environment:a,endpoint:this.options.endpoint,uuid:c,level:r,platform:"browser",framework:"browser-js",language:"javascript",body:this._buildBody(t,n,o),request:{url:window.location.href,query_string:window.location.search,user_ip:"$remote_ip"},client:{runtime_ms:e.getTime()-window._globalRollbarOptions.startTime,timestamp:Math.round(e.getTime()/1e3),javascript:{browser:window.navigator.userAgent,language:window.navigator.language,cookie_enabled:window.navigator.cookieEnabled,screen:{width:window.screen.width,height:window.screen.height},plugins:this._getBrowserPlugins()}},server:{},notifier:{name:"rollbar-browser-js",version:s.NOTIFIER_VERSION}};u.body&&delete u.body;var p={access_token:i,data:h(!0,l,u)};return this._scrub(p.data),p},E._buildBody=function(e,r,t){var n;return n=r?l(e,r,t):c(e,t)},E._getBrowserPlugins=function(){if(!this._browserPlugins){var e,r,t=window.navigator.plugins||[],n=t.length,o=[];for(r=0;n>r;++r)e=t[r],o.push({name:e.name,description:e.description});this._browserPlugins=o}return this._browserPlugins},E._scrub=function(e){function r(e,r,t,n,o,i){return r+m.redact(i)}function t(e){var t;if(m.isType(e,"string"))for(t=0;t<s.length;++t)e=e.replace(s[t],r);return e}function n(e,r){var t;for(t=0;t<a.length;++t)if(a[t].test(e)){r=m.redact(r);break}return r}function o(e,r){var o=n(e,r);return o===r?t(o):o}var i=this.options.scrubFields,a=this._getScrubFieldRegexs(i),s=this._getScrubQueryParamRegexs(i);return m.traverse(e,o),e},E._getScrubFieldRegexs=function(e){for(var r,t=[],n=0;n<e.length;++n)r="\\[?(%5[bB])?"+e[n]+"\\[?(%5[bB])?\\]?(%5[dD])?",t.push(new RegExp(r,"i"));return t},E._getScrubQueryParamRegexs=function(e){for(var r,t=[],n=0;n<e.length;++n)r="\\[?(%5[bB])?"+e[n]+"\\[?(%5[bB])?\\]?(%5[dD])?",t.push(new RegExp("("+r+"=)([^&\\n]+)","igm"));return t},E._urlIsWhitelisted=function(e){var r,t,n,o,i,a,s,u,c,l;try{if(r=this.options.hostWhiteList,t=e&&e.data&&e.data.body&&e.data.body.trace,!r||0===r.length)return!0;if(!t)return!0;for(s=r.length,i=t.frames.length,c=0;i>c;c++){if(n=t.frames[c],o=n.filename,!m.isType(o,"string"))return!0;for(l=0;s>l;l++)if(a=r[l],u=new RegExp(a),u.test(o))return!0}}catch(p){return this.configure({hostWhiteList:null}),console.error("[Rollbar]: Error while reading your configuration's hostWhiteList option. Removing custom hostWhiteList.",p),!0}return!1},E._messageIsIgnored=function(e){var r,t,n,o,i,a,s,u,c;try{if(i=!1,n=this.options.ignoredMessages,!n||0===n.length)return!1;if(s=e&&e.data&&e.data.body,u=s&&s.trace&&s.trace.exception&&s.trace.exception.message,c=s&&s.message&&s.message.body,r=u||c,!r)return!1;for(o=n.length,t=0;o>t&&(a=new RegExp(n[t],"gi"),!(i=a.test(r)));t++);}catch(l){this.configure({ignoredMessages:null}),console.error("[Rollbar]: Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.")}return i},E._enqueuePayload=function(e,r,t,n){var o={callback:n,accessToken:this.options.accessToken,endpointUrl:this._route("item/"),payload:e},a=function(){if(n){var e="This item was not sent to Rollbar because it was ignored. This can happen if a custom checkIgnore() function was used or if the item's level was less than the notifier' reportLevel. See https://rollbar.com/docs/notifier/rollbar.js/configuration for more details.";n(null,{err:0,result:{id:null,uuid:null,message:e}})}};if(this._internalCheckIgnore(r,t,e))return void a();try{if(m.isType(this.options.checkIgnore,"function")&&this.options.checkIgnore(r,t,e))return void a()}catch(s){this.configure({checkIgnore:null}),console.error("[Rollbar]: Error while calling custom checkIgnore() function. Removing custom checkIgnore().",s)}if(this._urlIsWhitelisted(e)&&!this._messageIsIgnored(e)){if(this.options.verbose){if(e.data&&e.data.body&&e.data.body.trace){var u=e.data.body.trace,c=u.exception.message;console.error("[Rollbar]: ",c)}console.info("[Rollbar]: ",o)}m.isType(this.options.logFunction,"function")&&this.options.logFunction(o);try{m.isType(this.options.transform,"function")&&this.options.transform(e)}catch(s){this.configure({transform:null}),console.error("[Rollbar]: Error while calling custom transform() function. Removing custom transform().",s)}this.options.enabled&&(window._rollbarPayloadQueue.push(o),i())}},E._internalCheckIgnore=function(e,r,t){var n=r[0],o=s.LEVELS[n]||0,i=s.LEVELS[this.options.reportLevel]||0;if(i>o)return!0;var a=this.options?this.options.plugins:{};if(a&&a.jquery&&a.jquery.ignoreAjaxErrors)try{return!!t.data.body.message.extra.isAjax}catch(u){return!1}return!1},E._log=function(e,r,t,n,o,i,a){var s=null;if(t)try{if(s=t._savedStackTrace?t._savedStackTrace:g.parse(t),t===this.lastError)return;this.lastError=t}catch(u){console.error("[Rollbar]: Error while parsing the error object.",u),r=t.message||t.description||r||String(t),t=null}var c=this._buildPayload(new Date,e,r,s,n);a&&(c.ignoreRateLimit=!0),this._enqueuePayload(c,!!i,[e,r,t,n],o)},E.log=u(),E.debug=u("debug"),E.info=u("info"),E.warn=u("warning"),E.warning=u("warning"),E.error=u("error"),E.critical=u("critical"),E.uncaughtError=o(function(e,r,t,n,o,i){if(i=i||null,o&&m.isType(o,"error"))return void this._log(this.options.uncaughtErrorLevel,e,o,i,null,!0);if(r&&m.isType(r,"error"))return void this._log(this.options.uncaughtErrorLevel,e,r,i,null,!0);var a={url:r||"",line:t};a.func=g.guessFunctionName(a.url,a.line),a.context=g.gatherContext(a.url,a.line);var s={mode:"onerror",message:o?String(o):e||"uncaught exception",url:document.location.href,stack:[a],useragent:navigator.userAgent},u=this._buildPayload(new Date,this.options.uncaughtErrorLevel,e,s,i);this._enqueuePayload(u,!0,[this.options.uncaughtErrorLevel,e,r,t,n,o])}),E.global=o(function(e){e=e||{};var r={startTime:e.startTime,maxItems:e.maxItems,itemsPerMinute:e.itemsPerMinute};h(!0,window._globalRollbarOptions,r),void 0!==e.maxItems&&(_=0),void 0!==e.itemsPerMinute&&(L=0)}),E.configure=o(function(e,r){var t=h(!0,{},e);h(!r,this.options,t),this.global(t)}),E.scope=o(function(e){var r=new s(this);return h(!0,r.options.payload,e),r}),E.wrap=function(e,r){try{var t;if(t=m.isType(r,"function")?r:function(){return r||{}},!m.isType(e,"function"))return e;if(e._isWrap)return e;if(!e._wrapped){e._wrapped=function(){try{return e.apply(this,arguments)}catch(r){throw r.stack||(r._savedStackTrace=g.parse(r)),r._rollbarContext=t()||{},r._rollbarContext._wrappedSource=e.toString(),window._rollbarWrappedError=r,r}},e._wrapped._isWrap=!0;for(var n in e)e.hasOwnProperty(n)&&(e._wrapped[n]=e[n])}return e._wrapped}catch(o){return e}},E.loadFull=function(){console.error("[Rollbar]: Unexpected Rollbar.loadFull() called on a Notifier instance")},s.processPayloads=function(e){return e?void p():void i()};var x=(new Date).getTime(),_=0,L=0;e.exports={Notifier:s,setupJSON:n,topLevelNotifier:a}},function(e,r){"use strict";var t=Object.prototype.hasOwnProperty,n=Object.prototype.toString,o=function(e){return"function"==typeof Array.isArray?Array.isArray(e):"[object Array]"===n.call(e)},i=function(e){if(!e||"[object Object]"!==n.call(e))return!1;var r=t.call(e,"constructor"),o=e.constructor&&e.constructor.prototype&&t.call(e.constructor.prototype,"isPrototypeOf");if(e.constructor&&!r&&!o)return!1;var i;for(i in e);return"undefined"==typeof i||t.call(e,i)};e.exports=function a(){var e,r,t,n,s,u,c=arguments[0],l=1,p=arguments.length,f=!1;for("boolean"==typeof c?(f=c,c=arguments[1]||{},l=2):("object"!=typeof c&&"function"!=typeof c||null==c)&&(c={});p>l;++l)if(e=arguments[l],null!=e)for(r in e)t=c[r],n=e[r],c!==n&&(f&&n&&(i(n)||(s=o(n)))?(s?(s=!1,u=t&&o(t)?t:[]):u=t&&i(t)?t:{},c[r]=a(f,u,n)):"undefined"!=typeof n&&(c[r]=n));return c}},function(e,r,t){"use strict";function n(){return l}function o(){return null}function i(e){var r={};return r._stackFrame=e,r.url=e.fileName,r.line=e.lineNumber,r.func=e.functionName,r.column=e.columnNumber,r.args=e.args,r.context=o(r.url,r.line),r}function a(e){function r(){var r=[];try{r=c.parse(e)}catch(t){r=[]}for(var n=[],o=0;o<r.length;o++)n.push(new i(r[o]));return n}return{stack:r(),message:e.message,name:e.name}}function s(e){return new a(e)}function u(e){if(!e)return["Unknown error. There was no error message to display.",""];var r=e.match(p),t="(unknown)";return r&&(t=r[r.length-1],e=e.replace((r[r.length-2]||"")+t+":",""),e=e.replace(/(^[\s]+|[\s]+$)/g,"")),[t,e]}var c=t(6),l="?",p=new RegExp("^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): ");e.exports={guessFunctionName:n,guessErrorClass:u,gatherContext:o,parse:s,Stack:a,Frame:i}},function(e,r,t){var n,o,i;!function(a,s){"use strict";o=[t(7)],n=s,i="function"==typeof n?n.apply(r,o):n,!(void 0!==i&&(e.exports=i))}(this,function(e){"use strict";function r(e,r,t){if("function"==typeof Array.prototype.map)return e.map(r,t);for(var n=new Array(e.length),o=0;o<e.length;o++)n[o]=r.call(t,e[o]);return n}function t(e,r,t){if("function"==typeof Array.prototype.filter)return e.filter(r,t);for(var n=[],o=0;o<e.length;o++)r.call(t,e[o])&&n.push(e[o]);return n}var n=/(^|@)\S+\:\d+/,o=/^\s*at .*(\S+\:\d+|\(native\))/m,i=/^(eval@)?(\[native code\])?$/;return{parse:function(e){if("undefined"!=typeof e.stacktrace||"undefined"!=typeof e["opera#sourceloc"])return this.parseOpera(e);if(e.stack&&e.stack.match(o))return this.parseV8OrIE(e);if(e.stack)return this.parseFFOrSafari(e);throw new Error("Cannot parse given Error object")},extractLocation:function(e){if(-1===e.indexOf(":"))return[e];var r=e.replace(/[\(\)\s]/g,"").split(":"),t=r.pop(),n=r[r.length-1];if(!isNaN(parseFloat(n))&&isFinite(n)){var o=r.pop();return[r.join(":"),o,t]}return[r.join(":"),t,void 0]},parseV8OrIE:function(n){var i=t(n.stack.split("\n"),function(e){return!!e.match(o)},this);return r(i,function(r){r.indexOf("(eval ")>-1&&(r=r.replace(/eval code/g,"eval").replace(/(\(eval at [^\()]*)|(\)\,.*$)/g,""));var t=r.replace(/^\s+/,"").replace(/\(eval code/g,"(").split(/\s+/).slice(1),n=this.extractLocation(t.pop()),o=t.join(" ")||void 0,i="eval"===n[0]?void 0:n[0];return new e(o,void 0,i,n[1],n[2],r)},this)},parseFFOrSafari:function(n){var o=t(n.stack.split("\n"),function(e){return!e.match(i)},this);return r(o,function(r){if(r.indexOf(" > eval")>-1&&(r=r.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g,":$1")),-1===r.indexOf("@")&&-1===r.indexOf(":"))return new e(r);var t=r.split("@"),n=this.extractLocation(t.pop()),o=t.shift()||void 0;return new e(o,void 0,n[0],n[1],n[2],r)},this)},parseOpera:function(e){return!e.stacktrace||e.message.indexOf("\n")>-1&&e.message.split("\n").length>e.stacktrace.split("\n").length?this.parseOpera9(e):e.stack?this.parseOpera11(e):this.parseOpera10(e)},parseOpera9:function(r){for(var t=/Line (\d+).*script (?:in )?(\S+)/i,n=r.message.split("\n"),o=[],i=2,a=n.length;a>i;i+=2){var s=t.exec(n[i]);s&&o.push(new e(void 0,void 0,s[2],s[1],void 0,n[i]))}return o},parseOpera10:function(r){for(var t=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,n=r.stacktrace.split("\n"),o=[],i=0,a=n.length;a>i;i+=2){var s=t.exec(n[i]);s&&o.push(new e(s[3]||void 0,void 0,s[2],s[1],void 0,n[i]))}return o},parseOpera11:function(o){var i=t(o.stack.split("\n"),function(e){return!!e.match(n)&&!e.match(/^Error created at/)},this);return r(i,function(r){var t,n=r.split("@"),o=this.extractLocation(n.pop()),i=n.shift()||"",a=i.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^\)]*\)/g,"")||void 0;i.match(/\(([^\)]*)\)/)&&(t=i.replace(/^[^\(]+\(([^\)]*)\)$/,"$1"));var s=void 0===t||"[arguments not available]"===t?void 0:t.split(",");return new e(a,s,o[0],o[1],o[2],r)},this)}}})},function(e,r,t){var n,o,i;!function(t,a){"use strict";o=[],n=a,i="function"==typeof n?n.apply(r,o):n,!(void 0!==i&&(e.exports=i))}(this,function(){"use strict";function e(e){return!isNaN(parseFloat(e))&&isFinite(e)}function r(e,r,t,n,o,i){void 0!==e&&this.setFunctionName(e),void 0!==r&&this.setArgs(r),void 0!==t&&this.setFileName(t),void 0!==n&&this.setLineNumber(n),void 0!==o&&this.setColumnNumber(o),void 0!==i&&this.setSource(i)}return r.prototype={getFunctionName:function(){return this.functionName},setFunctionName:function(e){this.functionName=String(e)},getArgs:function(){return this.args},setArgs:function(e){if("[object Array]"!==Object.prototype.toString.call(e))throw new TypeError("Args must be an Array");this.args=e},getFileName:function(){return this.fileName},setFileName:function(e){this.fileName=String(e)},getLineNumber:function(){return this.lineNumber},setLineNumber:function(r){if(!e(r))throw new TypeError("Line Number must be a Number");this.lineNumber=Number(r)},getColumnNumber:function(){return this.columnNumber},setColumnNumber:function(r){if(!e(r))throw new TypeError("Column Number must be a Number");this.columnNumber=Number(r)},getSource:function(){return this.source},setSource:function(e){this.source=String(e)},toString:function(){var r=this.getFunctionName()||"{anonymous}",t="("+(this.getArgs()||[]).join(",")+")",n=this.getFileName()?"@"+this.getFileName():"",o=e(this.getLineNumber())?":"+this.getLineNumber():"",i=e(this.getColumnNumber())?":"+this.getColumnNumber():"";return r+t+n+o+i}},r})},function(e,r,t){"use strict";function n(e){return{}.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}function o(e,r){return n(e)===r}function i(e){if(!o(e,"string"))throw new Error("received invalid input");for(var r=l,t=r.parser[r.strictMode?"strict":"loose"].exec(e),n={},i=14;i--;)n[r.key[i]]=t[i]||"";return n[r.q.name]={},n[r.key[12]].replace(r.q.parser,function(e,t,o){t&&(n[r.q.name][t]=o)}),n}function a(e){var r=i(e);return""===r.anchor&&(r.source=r.source.replace("#","")),e=r.source.replace("?"+r.query,"")}function s(e,r){var t,n,i,a=o(e,"object"),u=o(e,"array"),c=[];if(a)for(t in e)e.hasOwnProperty(t)&&c.push(t);else if(u)for(i=0;i<e.length;++i)c.push(i);for(i=0;i<c.length;++i)t=c[i],n=e[t],a=o(n,"object"),u=o(n,"array"),a||u?e[t]=s(n,r):e[t]=r(t,n);return e}function u(e){return e=String(e),new Array(e.length+1).join("*")}function c(){var e=(new Date).getTime(),r="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(r){var t=(e+16*Math.random())%16|0;return e=Math.floor(e/16),("x"===r?t:7&t|8).toString(16)});return r}t(9);var l={strictMode:!1,key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}},p={isType:o,parseUri:i,parseUriOptions:l,redact:u,sanitizeUrl:a,traverse:s,typeName:n,uuid4:c};e.exports=p},function(e,r){!function(e){"use strict";e.console=e.console||{};for(var r,t,n=e.console,o={},i=function(){},a="memory".split(","),s="assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn".split(",");r=a.pop();)n[r]||(n[r]=o);for(;t=s.pop();)n[t]||(n[t]=i)}("undefined"==typeof window?this:window)},function(e,r,t){"use strict";function n(e){i=e}var o=t(8),i=null,a={XMLHttpFactories:[function(){return new XMLHttpRequest},function(){return new ActiveXObject("Msxml2.XMLHTTP")},function(){return new ActiveXObject("Msxml3.XMLHTTP")},function(){return new ActiveXObject("Microsoft.XMLHTTP")}],createXMLHTTPObject:function(){var e,r=!1,t=a.XMLHttpFactories,n=t.length;for(e=0;n>e;e++)try{r=t[e]();break}catch(o){}return r},post:function(e,r,t,n){if(!o.isType(t,"object"))throw new Error("Expected an object to POST");t=i.stringify(t),n=n||function(){};var s=a.createXMLHTTPObject();if(s)try{try{var u=function(){try{u&&4===s.readyState&&(u=void 0,200===s.status?n(null,i.parse(s.responseText)):n(o.isType(s.status,"number")&&s.status>=400&&s.status<600?new Error(String(s.status)):new Error))}catch(e){var r;r=e&&e.stack?e:new Error(e),n(r)}};s.open("POST",e,!0),s.setRequestHeader&&(s.setRequestHeader("Content-Type","application/json"),s.setRequestHeader("X-Rollbar-Access-Token",r)),s.onreadystatechange=u,s.send(t)}catch(c){if("undefined"!=typeof XDomainRequest){"http:"===window.location.href.substring(0,5)&&"https"===e.substring(0,5)&&(e="http"+e.substring(5));var l=function(){n(new Error("Request timed out"))},p=function(){n(new Error("Error during request"))},f=function(){n(null,i.parse(s.responseText))};s=new XDomainRequest,s.onprogress=function(){},s.ontimeout=l,s.onerror=p,s.onload=f,s.open("POST",e,!0),s.send(t)}}}catch(d){n(d)}}};e.exports={XHR:a,setupJSON:n}}])});

/***/ },
/* 66 */
/*!***************************************!*\
  !*** ./~/immutable/dist/immutable.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  global.Immutable = factory()
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;
	
	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }
	
	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';
	
	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;
	
	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};
	
	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };
	
	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }
	
	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }
	
	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}
	
	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }
	
	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }
	
	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^321.
	    // However note that we're currently calling ToNumber() instead of ToUint32()
	    // which should be improved in the future, as floating point numbers should
	    // not be accepted as an array index.
	    if (typeof index !== 'number') {
	      var numIndex = +index;
	      if ('' + numIndex !== index) {
	        return NaN;
	      }
	      index = numIndex;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }
	
	  function returnTrue() {
	    return true;
	  }
	
	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }
	
	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }
	
	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }
	
	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }
	
	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }
	
	
	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }
	
	
	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }
	
	
	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }
	
	
	
	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }
	
	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }
	
	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }
	
	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }
	
	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }
	
	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;
	
	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;
	
	
	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  /* global Symbol */
	
	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;
	
	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';
	
	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
	
	
	  function src_Iterator__Iterator(next) {
	      this.next = next;
	    }
	
	    src_Iterator__Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };
	
	
	  src_Iterator__Iterator.KEYS = ITERATE_KEYS;
	  src_Iterator__Iterator.VALUES = ITERATE_VALUES;
	  src_Iterator__Iterator.ENTRIES = ITERATE_ENTRIES;
	
	  src_Iterator__Iterator.prototype.inspect =
	  src_Iterator__Iterator.prototype.toSource = function () { return this.toString(); }
	  src_Iterator__Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };
	
	
	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }
	
	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }
	
	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }
	
	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }
	
	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }
	
	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }
	
	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }
	
	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };
	
	    Seq.prototype.toSeq = function() {
	      return this;
	    };
	
	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };
	
	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };
	
	    // abstract __iterateUncached(fn, reverse)
	
	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };
	
	    // abstract __iteratorUncached(type, reverse)
	
	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };
	
	
	
	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }
	
	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };
	
	
	
	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }
	
	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };
	
	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };
	
	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };
	
	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };
	
	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };
	
	
	
	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }
	
	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };
	
	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };
	
	
	
	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;
	
	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
	
	  Seq.prototype[IS_SEQ_SENTINEL] = true;
	
	
	
	  // #pragma Root Sequences
	
	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }
	
	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };
	
	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new src_Iterator__Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };
	
	
	
	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }
	
	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };
	
	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };
	
	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new src_Iterator__Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };
	
	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }
	
	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };
	
	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new src_Iterator__Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };
	
	
	
	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }
	
	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	
	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };
	
	
	
	
	  // # pragma Helper functions
	
	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }
	
	  var EMPTY_SEQ;
	
	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }
	
	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }
	
	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }
	
	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new src_Iterator__Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }
	
	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }
	
	
	  createClass(KeyedCollection, Collection);function KeyedCollection() {}
	
	  createClass(IndexedCollection, Collection);function IndexedCollection() {}
	
	  createClass(SetCollection, Collection);function SetCollection() {}
	
	
	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;
	
	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }
	
	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }
	
	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }
	
	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }
	
	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }
	
	  var src_Math__imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };
	
	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }
	
	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    return hashJSObj(o);
	  }
	
	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }
	
	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }
	
	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }
	
	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }
	
	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }
	
	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }
	
	    return hash;
	  }
	
	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;
	
	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());
	
	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }
	
	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }
	
	  var objHashUID = 0;
	
	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }
	
	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};
	
	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }
	
	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }
	
	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }
	
	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };
	
	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };
	
	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };
	
	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };
	
	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };
	
	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };
	
	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };
	
	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };
	
	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };
	
	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };
	
	
	
	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };
	
	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };
	
	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };
	
	
	
	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }
	
	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };
	
	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };
	
	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new src_Iterator__Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };
	
	
	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;
	
	
	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new src_Iterator__Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }
	
	
	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }
	
	
	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }
	
	
	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }
	
	
	  function countByFactory(iterable, grouper, context) {
	    var groups = src_Map__Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }
	
	
	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : src_Map__Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }
	
	
	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;
	
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	
	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }
	
	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);
	
	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }
	
	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }
	
	    var sliceSeq = makeSequence(iterable);
	
	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
	
	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }
	
	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };
	
	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }
	
	    return sliceSeq;
	  }
	
	
	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new src_Iterator__Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }
	
	
	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }
	
	
	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});
	
	    if (iters.length === 0) {
	      return iterable;
	    }
	
	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }
	
	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }
	
	
	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }
	
	
	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }
	
	
	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new src_Iterator__Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }
	
	
	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }
	
	
	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }
	
	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }
	
	
	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new src_Iterator__Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }
	
	
	  // #pragma Helper Functions
	
	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }
	
	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }
	
	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }
	
	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }
	
	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }
	
	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }
	
	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }
	
	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }
	
	  createClass(src_Map__Map, KeyedCollection);
	
	    // @pragma Construction
	
	    function src_Map__Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    src_Map__Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };
	
	    // @pragma Access
	
	    src_Map__Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };
	
	    // @pragma Modification
	
	    src_Map__Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };
	
	    src_Map__Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };
	
	    src_Map__Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };
	
	    src_Map__Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };
	
	    src_Map__Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };
	
	    src_Map__Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };
	
	    src_Map__Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };
	
	    // @pragma Composition
	
	    src_Map__Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };
	
	    src_Map__Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };
	
	    src_Map__Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    src_Map__Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger(undefined), arguments);
	    };
	
	    src_Map__Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMerger(merger), iters);
	    };
	
	    src_Map__Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    src_Map__Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };
	
	    src_Map__Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };
	
	    // @pragma Mutability
	
	    src_Map__Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };
	
	    src_Map__Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };
	
	    src_Map__Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };
	
	    src_Map__Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };
	
	    src_Map__Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };
	
	    src_Map__Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };
	
	    src_Map__Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };
	
	
	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }
	
	  src_Map__Map.isMap = isMap;
	
	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
	
	  var MapPrototype = src_Map__Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;
	
	
	  // #pragma Trie Nodes
	
	
	
	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }
	
	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && entries.length === 1) {
	        return; // undefined
	      }
	
	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new ArrayMapNode(ownerID, newEntries);
	    };
	
	
	
	
	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }
	
	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };
	
	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;
	
	      if (!exists && value === NOT_SET) {
	        return this;
	      }
	
	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	
	      if (newNode === node) {
	        return this;
	      }
	
	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }
	
	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }
	
	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };
	
	
	
	
	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }
	
	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };
	
	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];
	
	      if (removed && !node) {
	        return this;
	      }
	
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }
	
	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };
	
	
	
	
	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }
	
	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	
	      var removed = value === NOT_SET;
	
	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };
	
	
	
	
	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }
	
	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };
	
	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	
	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }
	
	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }
	
	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };
	
	
	
	  // #pragma Iterators
	
	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }
	
	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }
	
	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }
	
	  createClass(MapIterator, src_Iterator__Iterator);
	
	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }
	
	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };
	
	
	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }
	
	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }
	
	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }
	
	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }
	
	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }
	
	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }
	
	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }
	
	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	
	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
	
	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }
	
	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }
	
	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }
	
	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }
	
	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }
	
	  function deepMerger(merger) {
	    return function(existing, value, key) 
	      {return existing && existing.mergeDeepWith && isIterable(value) ?
	        existing.mergeDeepWith(merger, value) :
	        merger ? merger(existing, value, key) : value};
	  }
	
	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }
	
	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }
	
	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }
	
	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }
	
	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }
	
	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }
	
	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
	
	  createClass(List, IndexedCollection);
	
	    // @pragma Construction
	
	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }
	
	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };
	
	    // @pragma Access
	
	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };
	
	    // @pragma Modification
	
	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };
	
	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };
	
	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };
	
	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };
	
	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };
	
	    // @pragma Composition
	
	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };
	
	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };
	
	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger(undefined), arguments);
	    };
	
	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMerger(merger), iters);
	    };
	
	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };
	
	    // @pragma Iteration
	
	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };
	
	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new src_Iterator__Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };
	
	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };
	
	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };
	
	
	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }
	
	  List.isList = isList;
	
	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
	
	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	
	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }
	
	    // TODO: seems like these methods are very similar
	
	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };
	
	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }
	
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }
	
	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };
	
	
	
	  var DONE = {};
	
	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;
	
	    return iterateNodeOrLeaf(list._root, list._level, 0);
	
	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }
	
	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }
	
	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }
	
	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }
	
	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }
	
	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);
	
	    if (index !== index) {
	      return list;
	    }
	
	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }
	
	    index += list._origin;
	
	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }
	
	    if (!didAlter.value) {
	      return list;
	    }
	
	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }
	
	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }
	
	    var newNode;
	
	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }
	
	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }
	
	    SetRef(didAlter);
	
	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }
	
	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }
	
	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }
	
	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }
	
	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }
	
	    var newLevel = list._level;
	    var newRoot = list._root;
	
	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }
	
	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);
	
	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }
	
	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
	
	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }
	
	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }
	
	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
	
	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;
	
	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }
	
	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }
	
	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }
	
	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }
	
	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }
	
	  createClass(OrderedMap, src_Map__Map);
	
	    // @pragma Construction
	
	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };
	
	    // @pragma Access
	
	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };
	
	    // @pragma Modification
	
	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };
	
	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };
	
	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };
	
	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };
	
	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };
	
	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };
	
	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };
	
	
	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }
	
	  OrderedMap.isOrderedMap = isOrderedMap;
	
	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
	
	
	
	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }
	
	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }
	
	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }
	
	  createClass(Stack, IndexedCollection);
	
	    // @pragma Construction
	
	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }
	
	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };
	
	    // @pragma Access
	
	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };
	
	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };
	
	    // @pragma Modification
	
	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };
	
	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };
	
	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };
	
	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };
	
	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };
	
	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    // @pragma Mutability
	
	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };
	
	    // @pragma Iteration
	
	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };
	
	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new src_Iterator__Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };
	
	
	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }
	
	  Stack.isStack = isStack;
	
	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
	
	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }
	
	  createClass(src_Set__Set, SetCollection);
	
	    // @pragma Construction
	
	    function src_Set__Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    src_Set__Set.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    src_Set__Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    src_Set__Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };
	
	    // @pragma Access
	
	    src_Set__Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };
	
	    // @pragma Modification
	
	    src_Set__Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };
	
	    src_Set__Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };
	
	    src_Set__Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };
	
	    // @pragma Composition
	
	    src_Set__Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };
	
	    src_Set__Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    src_Set__Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    src_Set__Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };
	
	    src_Set__Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };
	
	    src_Set__Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };
	
	    src_Set__Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };
	
	    src_Set__Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    src_Set__Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };
	
	    src_Set__Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };
	
	    src_Set__Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };
	
	
	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }
	
	  src_Set__Set.isSet = isSet;
	
	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
	
	  var SetPrototype = src_Set__Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;
	
	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;
	
	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }
	
	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }
	
	  createClass(OrderedSet, src_Set__Set);
	
	    // @pragma Construction
	
	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };
	
	
	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }
	
	  OrderedSet.isOrderedSet = isOrderedSet;
	
	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	
	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;
	
	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }
	
	  createClass(Record, KeyedCollection);
	
	    function Record(defaultValues, name) {
	      var hasInitialized;
	
	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = src_Map__Map(values);
	      };
	
	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;
	
	      return RecordType;
	    }
	
	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };
	
	    // @pragma Access
	
	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };
	
	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };
	
	    // @pragma Modification
	
	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };
	
	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };
	
	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };
	
	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };
	
	
	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	
	
	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }
	
	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }
	
	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }
	
	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }
	
	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }
	
	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }
	
	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }
	
	    var notAssociative = !isAssociative(a);
	
	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }
	
	    var flipped = false;
	
	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }
	
	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });
	
	    return allEqual && a.size === bSize;
	  }
	
	  createClass(Range, IndexedSeq);
	
	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }
	
	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step > 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };
	
	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };
	
	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };
	
	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };
	
	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };
	
	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };
	
	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };
	
	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new src_Iterator__Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };
	
	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };
	
	
	  var EMPTY_RANGE;
	
	  createClass(Repeat, IndexedSeq);
	
	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }
	
	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };
	
	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };
	
	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };
	
	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };
	
	    Repeat.prototype.reverse = function() {
	      return this;
	    };
	
	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new src_Iterator__Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };
	
	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };
	
	
	  var EMPTY_REPEAT;
	
	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }
	
	  Iterable.Iterator = src_Iterator__Iterator;
	
	  mixin(Iterable, {
	
	    // ### Conversion to other types
	
	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },
	
	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },
	
	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },
	
	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },
	
	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return src_Map__Map(this.toKeyedSeq());
	    },
	
	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },
	
	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },
	
	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return src_Set__Set(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },
	
	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },
	
	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	
	    // ### Common JavaScript methods and properties
	
	    toString: function() {
	      return '[Iterable]';
	    },
	
	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },
	
	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },
	
	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },
	
	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },
	
	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },
	
	    findEntry: function(predicate, context) {
	      var found;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },
	
	    findLastEntry: function(predicate, context) {
	      return this.toSeq().reverse().findEntry(predicate, context);
	    },
	
	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },
	
	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },
	
	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },
	
	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },
	
	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },
	
	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },
	
	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },
	
	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },
	
	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },
	
	
	    // ### More sequential methods
	
	    butLast: function() {
	      return this.slice(0, -1);
	    },
	
	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },
	
	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },
	
	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },
	
	    equals: function(other) {
	      return deepEqual(this, other);
	    },
	
	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },
	
	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },
	
	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },
	
	    first: function() {
	      return this.find(returnTrue);
	    },
	
	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },
	
	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },
	
	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },
	
	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },
	
	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },
	
	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },
	
	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },
	
	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },
	
	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },
	
	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },
	
	    last: function() {
	      return this.toSeq().reverse().first();
	    },
	
	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },
	
	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },
	
	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },
	
	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },
	
	    rest: function() {
	      return this.slice(1);
	    },
	
	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },
	
	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },
	
	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },
	
	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },
	
	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },
	
	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },
	
	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },
	
	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },
	
	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },
	
	
	    // ### Hashable Object
	
	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }
	
	
	    // ### Internal
	
	    // abstract __iterate(fn, reverse)
	
	    // abstract __iterator(type, reverse)
	  });
	
	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;
	
	  // Temporary warning about using length
	  (function () {
	    try {
	      Object.defineProperty(IterablePrototype, 'length', {
	        get: function () {
	          if (!Iterable.noLengthWarning) {
	            var stack;
	            try {
	              throw new Error();
	            } catch (error) {
	              stack = error.stack;
	            }
	            if (stack.indexOf('_wrapObject') === -1) {
	              console && console.warn && console.warn(
	                'iterable.length has been deprecated, '+
	                'use iterable.size or iterable.count(). '+
	                'This warning will become a silent error in a future version. ' +
	                stack
	              );
	              return this.size;
	            }
	          }
	        }
	      });
	    } catch (e) {}
	  })();
	
	
	
	  mixin(KeyedIterable, {
	
	    // ### More sequential methods
	
	    flip: function() {
	      return reify(this, flipFactory(this));
	    },
	
	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },
	
	    findLastKey: function(predicate, context) {
	      return this.toSeq().reverse().findKey(predicate, context);
	    },
	
	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },
	
	    lastKeyOf: function(searchValue) {
	      return this.findLastKey(function(value ) {return is(value, searchValue)});
	    },
	
	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },
	
	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }
	
	  });
	
	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};
	
	
	
	  mixin(IndexedIterable, {
	
	    // ### Conversion to other types
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },
	
	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    indexOf: function(searchValue) {
	      var key = this.toKeyedSeq().keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    lastIndexOf: function(searchValue) {
	      return this.toSeq().reverse().indexOf(searchValue);
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },
	
	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },
	
	
	    // ### More collection methods
	
	    findLastIndex: function(predicate, context) {
	      var key = this.toKeyedSeq().findLastKey(predicate, context);
	      return key === undefined ? -1 : key;
	    },
	
	    first: function() {
	      return this.get(0);
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },
	
	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },
	
	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },
	
	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },
	
	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },
	
	    last: function() {
	      return this.get(-1);
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },
	
	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },
	
	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }
	
	  });
	
	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	
	  mixin(SetIterable, {
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },
	
	    includes: function(value) {
	      return this.has(value);
	    },
	
	
	    // ### More sequential methods
	
	    keySeq: function() {
	      return this.valueSeq();
	    }
	
	  });
	
	  SetIterable.prototype.has = IterablePrototype.includes;
	
	
	  // Mixin subclasses
	
	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);
	
	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);
	
	
	  // #pragma Helper functions
	
	  function keyMapper(v, k) {
	    return k;
	  }
	
	  function entryMapper(v, k) {
	    return [k, v];
	  }
	
	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }
	
	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }
	
	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : value;
	  }
	
	  function defaultZipper() {
	    return arrCopy(arguments);
	  }
	
	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }
	
	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }
	
	  function murmurHashOfSize(size, h) {
	    h = src_Math__imul(h, 0xCC9E2D51);
	    h = src_Math__imul(h << 15 | h >>> -15, 0x1B873593);
	    h = src_Math__imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = src_Math__imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = src_Math__imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }
	
	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }
	
	  var Immutable = {
	
	    Iterable: Iterable,
	
	    Seq: Seq,
	    Collection: Collection,
	    Map: src_Map__Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: src_Set__Set,
	    OrderedSet: OrderedSet,
	
	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,
	
	    is: is,
	    fromJS: fromJS
	
	  };
	
	  return Immutable;
	
	}));

/***/ },
/* 67 */
/*!********************************!*\
  !*** ./~/snabbdom/snabbdom.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	// jshint newcap: false
	/* global require, module, document, Element */
	'use strict';
	
	var VNode = __webpack_require__(/*! ./vnode */ 68);
	var is = __webpack_require__(/*! ./is */ 69);
	
	function isUndef(s) { return s === undefined; }
	function isDef(s) { return s !== undefined; }
	
	function emptyNodeAt(elm) {
	  return VNode(elm.tagName, {}, [], undefined, elm);
	}
	
	var emptyNode = VNode('', {}, [], undefined, undefined);
	
	function sameVnode(vnode1, vnode2) {
	  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
	}
	
	function createKeyToOldIdx(children, beginIdx, endIdx) {
	  var i, map = {}, key;
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) map[key] = i;
	  }
	  return map;
	}
	
	function createRmCb(childElm, listeners) {
	  return function() {
	    if (--listeners === 0) childElm.parentElement.removeChild(childElm);
	  };
	}
	
	var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
	
	function init(modules) {
	  var i, j, cbs = {};
	  for (i = 0; i < hooks.length; ++i) {
	    cbs[hooks[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
	    }
	  }
	
	  function createElm(vnode, insertedVnodeQueue) {
	    var i, data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) i(vnode);
	      if (isDef(i = data.vnode)) vnode = i;
	    }
	    var elm, children = vnode.children, sel = vnode.sel;
	    if (isDef(sel)) {
	      // Parse selector
	      var hashIdx = sel.indexOf('#');
	      var dotIdx = sel.indexOf('.', hashIdx);
	      var hash = hashIdx > 0 ? hashIdx : sel.length;
	      var dot = dotIdx > 0 ? dotIdx : sel.length;
	      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
	      elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? document.createElementNS(i, tag)
	                                                          : document.createElement(tag);
	      if (hash < dot) elm.id = sel.slice(hash + 1, dot);
	      if (dotIdx > 0) elm.className = sel.slice(dot+1).replace(/\./g, ' ');
	      if (is.array(children)) {
	        for (i = 0; i < children.length; ++i) {
	          elm.appendChild(createElm(children[i], insertedVnodeQueue));
	        }
	      } else if (is.primitive(vnode.text)) {
	        elm.appendChild(document.createTextNode(vnode.text));
	      }
	      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
	      i = vnode.data.hook; // Reuse variable
	      if (isDef(i)) {
	        if (i.create) i.create(emptyNode, vnode);
	        if (i.insert) insertedVnodeQueue.push(vnode);
	      }
	    } else {
	      elm = vnode.elm = document.createTextNode(vnode.text);
	    }
	    return vnode.elm;
	  }
	
	  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      parentElm.insertBefore(createElm(vnodes[startIdx], insertedVnodeQueue), before);
	    }
	  }
	
	  function invokeDestroyHook(vnode) {
	    var i = vnode.data, j;
	    if (isDef(i)) {
	      if (isDef(i = i.hook) && isDef(i = i.destroy)) i(vnode);
	      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
	      if (isDef(i = vnode.children)) {
	        for (j = 0; j < vnode.children.length; ++j) {
	          invokeDestroyHook(vnode.children[j]);
	        }
	      }
	    }
	  }
	
	  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var i, listeners, rm, ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.sel)) {
	          invokeDestroyHook(ch);
	          listeners = cbs.remove.length + 1;
	          rm = createRmCb(ch.elm, listeners);
	          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
	          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
	            i(ch, rm);
	          } else {
	            rm();
	          }
	        } else { // Text node
	          parentElm.removeChild(ch.elm);
	        }
	      }
	    }
	  }
	
	  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
	    var oldStartIdx = 0, newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, before;
	
	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	        idxInOld = oldKeyToIdx[newStartVnode.key];
	        if (isUndef(idxInOld)) { // New element
	          parentElm.insertBefore(createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	          oldCh[idxInOld] = undefined;
	          parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;
	      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }
	
	  function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
	    var i, hook;
	    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
	      i(oldVnode, vnode);
	    }
	    if (isDef(i = oldVnode.data) && isDef(i = i.vnode)) oldVnode = i;
	    if (isDef(i = vnode.data) && isDef(i = i.vnode)) vnode = i;
	    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;
	    if (oldVnode === vnode) return;
	    if (isDef(vnode.data)) {
	      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
	      i = vnode.data.hook;
	      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
	      } else if (isDef(ch)) {
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      elm.textContent = vnode.text;
	    }
	    if (isDef(hook) && isDef(i = hook.postpatch)) {
	      i(oldVnode, vnode);
	    }
	  }
	
	  return function(oldVnode, vnode) {
	    var i;
	    var insertedVnodeQueue = [];
	    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();
	    if (oldVnode instanceof Element) {
	      if (oldVnode.parentElement !== null) {
	        createElm(vnode, insertedVnodeQueue);
	        oldVnode.parentElement.replaceChild(vnode.elm, oldVnode);
	      } else {
	        oldVnode = emptyNodeAt(oldVnode);
	        patchVnode(oldVnode, vnode, insertedVnodeQueue);
	      }
	    } else {
	      patchVnode(oldVnode, vnode, insertedVnodeQueue);
	    }
	    for (i = 0; i < insertedVnodeQueue.length; ++i) {
	      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
	    }
	    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
	    return vnode;
	  };
	}
	
	module.exports = {init: init};


/***/ },
/* 68 */
/*!*****************************!*\
  !*** ./~/snabbdom/vnode.js ***!
  \*****************************/
/***/ function(module, exports) {

	module.exports = function(sel, data, children, text, elm) {
	  var key = data === undefined ? undefined : data.key;
	  return {sel: sel, data: data, children: children,
	          text: text, elm: elm, key: key};
	};


/***/ },
/* 69 */
/*!**************************!*\
  !*** ./~/snabbdom/is.js ***!
  \**************************/
/***/ function(module, exports) {

	module.exports = {
	  array: Array.isArray,
	  primitive: function(s) { return typeof s === 'string' || typeof s === 'number'; },
	};


/***/ },
/* 70 */
/*!*************************!*\
  !*** ./~/snabbdom/h.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	var VNode = __webpack_require__(/*! ./vnode */ 68);
	var is = __webpack_require__(/*! ./is */ 69);
	
	function addNS(data, children) {
	  data.ns = 'http://www.w3.org/2000/svg';
	  if (children !== undefined) {
	    for (var i = 0; i < children.length; ++i) {
	      addNS(children[i].data, children[i].children);
	    }
	  }
	}
	
	module.exports = function h(sel, b, c) {
	  var data = {}, children, text, i;
	  if (arguments.length === 3) {
	    data = b;
	    if (is.array(c)) { children = c; }
	    else if (is.primitive(c)) { text = c; }
	  } else if (arguments.length === 2) {
	    if (is.array(b)) { children = b; }
	    else if (is.primitive(b)) { text = b; }
	    else { data = b; }
	  }
	  if (is.array(children)) {
	    for (i = 0; i < children.length; ++i) {
	      if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);
	    }
	  }
	  if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
	    addNS(data, children);
	  }
	  return VNode(sel, data, children, text, undefined);
	};


/***/ },
/* 71 */
/*!*************************************!*\
  !*** ./~/snabbdom/modules/class.js ***!
  \*************************************/
/***/ function(module, exports) {

	function updateClass(oldVnode, vnode) {
	  var cur, name, elm = vnode.elm,
	      oldClass = oldVnode.data.class || {},
	      klass = vnode.data.class || {};
	  for (name in klass) {
	    cur = klass[name];
	    if (cur !== oldClass[name]) {
	      elm.classList[cur ? 'add' : 'remove'](name);
	    }
	  }
	}
	
	module.exports = {create: updateClass, update: updateClass};


/***/ },
/* 72 */
/*!*************************************!*\
  !*** ./~/snabbdom/modules/props.js ***!
  \*************************************/
/***/ function(module, exports) {

	function updateProps(oldVnode, vnode) {
	  var key, cur, old, elm = vnode.elm,
	      oldProps = oldVnode.data.props || {}, props = vnode.data.props || {};
	  for (key in props) {
	    cur = props[key];
	    old = oldProps[key];
	    if (old !== cur) {
	      elm[key] = cur;
	    }
	  }
	}
	
	module.exports = {create: updateProps, update: updateProps};


/***/ },
/* 73 */
/*!******************************************!*\
  !*** ./~/snabbdom/modules/attributes.js ***!
  \******************************************/
/***/ function(module, exports) {

	var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", 
	                "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", 
	                "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", 
	                "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", 
	                "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", 
	                "truespeed", "typemustmatch", "visible"];
	    
	var booleanAttrsDict = {};
	for(var i=0, len = booleanAttrs.length; i < len; i++) {
	  booleanAttrsDict[booleanAttrs[i]] = true;
	}
	    
	function updateAttrs(oldVnode, vnode) {
	  var key, cur, old, elm = vnode.elm,
	      oldAttrs = oldVnode.data.attrs || {}, attrs = vnode.data.attrs || {};
	  
	  // update modified attributes, add new attributes
	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      // TODO: add support to namespaced attributes (setAttributeNS)
	      if(!cur && booleanAttrsDict[key])
	        elm.removeAttribute(key);
	      else
	        elm.setAttribute(key, cur);
	    }
	  }
	  //remove removed attributes
	  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
	  // the other option is to remove all attributes with value == undefined
	  for (key in oldAttrs) {
	    if (!(key in attrs)) {
	      elm.removeAttribute(key);
	    }
	  }
	}
	
	module.exports = {create: updateAttrs, update: updateAttrs};


/***/ },
/* 74 */
/*!*************************************!*\
  !*** ./~/snabbdom/modules/style.js ***!
  \*************************************/
/***/ function(module, exports) {

	var raf = requestAnimationFrame || setTimeout;
	var nextFrame = function(fn) { raf(function() { raf(fn); }); };
	
	function setNextFrame(obj, prop, val) {
	  nextFrame(function() { obj[prop] = val; });
	}
	
	function updateStyle(oldVnode, vnode) {
	  var cur, name, elm = vnode.elm,
	      oldStyle = oldVnode.data.style || {},
	      style = vnode.data.style || {},
	      oldHasDel = 'delayed' in oldStyle;
	  for (name in style) {
	    cur = style[name];
	    if (name === 'delayed') {
	      for (name in style.delayed) {
	        cur = style.delayed[name];
	        if (!oldHasDel || cur !== oldStyle.delayed[name]) {
	          setNextFrame(elm.style, name, cur);
	        }
	      }
	    } else if (name !== 'remove' && cur !== oldStyle[name]) {
	      elm.style[name] = cur;
	    }
	  }
	}
	
	function applyDestroyStyle(vnode) {
	  var style, name, elm = vnode.elm, s = vnode.data.style;
	  if (!s || !(style = s.destroy)) return;
	  for (name in style) {
	    elm.style[name] = style[name];
	  }
	}
	
	function applyRemoveStyle(vnode, rm) {
	  var s = vnode.data.style;
	  if (!s || !s.remove) {
	    rm();
	    return;
	  }
	  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,
	      compStyle, style = s.remove, amount = 0, applied = [];
	  for (name in style) {
	    applied.push(name);
	    elm.style[name] = style[name];
	  }
	  compStyle = getComputedStyle(elm);
	  var props = compStyle['transition-property'].split(', ');
	  for (; i < props.length; ++i) {
	    if(applied.indexOf(props[i]) !== -1) amount++;
	  }
	  elm.addEventListener('transitionend', function(ev) {
	    if (ev.target === elm) --amount;
	    if (amount === 0) rm();
	  });
	}
	
	module.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};


/***/ },
/* 75 */
/*!**********************************************!*\
  !*** ./~/snabbdom/modules/eventlisteners.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	var is = __webpack_require__(/*! ../is */ 69);
	
	function arrInvoker(arr) {
	  return function() {
	    // Special case when length is two, for performance
	    arr.length === 2 ? arr[0](arr[1]) : arr[0].apply(undefined, arr.slice(1));
	  };
	}
	
	function fnInvoker(o) {
	  return function(ev) { o.fn(ev); };
	}
	
	function updateEventListeners(oldVnode, vnode) {
	  var name, cur, old, elm = vnode.elm,
	      oldOn = oldVnode.data.on || {}, on = vnode.data.on;
	  if (!on) return;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    if (old === undefined) {
	      if (is.array(cur)) {
	        elm.addEventListener(name, arrInvoker(cur));
	      } else {
	        cur = {fn: cur};
	        on[name] = cur;
	        elm.addEventListener(name, fnInvoker(cur));
	      }
	    } else if (is.array(old)) {
	      // Deliberately modify old array since it's captured in closure created with `arrInvoker`
	      old.length = cur.length;
	      for (var i = 0; i < old.length; ++i) old[i] = cur[i];
	      on[name]  = old;
	    } else {
	      old.fn = cur;
	      on[name] = old;
	    }
	  }
	}
	
	module.exports = {create: updateEventListeners, update: updateEventListeners};


/***/ },
/* 76 */
/*!***********************************!*\
  !*** ./src/utils/eventEmitter.js ***!
  \***********************************/
/***/ function(module, exports) {

	"use strict";
	
	// Fork of: https://github.com/scottcorgan/tiny-emitter
	
	/**
	 * Event Emitter
	 * @mixin
	 * @public
	 */
	function eventEmitter() {
	  var e = {};
	
	  /**
	   *
	   * Subscribe to an event.
	   *
	   * @param {string} name
	   * @param {function} callback
	   * @param {any} [context]
	   * @public
	   * @instance
	   * @memberof eventEmitter
	   */
	  function on(name, callback, context) {
	    (e[name] || (e[name] = [])).push({
	      fn: callback,
	      ctx: context
	    });
	    return this;
	  }
	
	  /**
	   *
	   * Subscribe to an event only once.
	   *
	   * @param {string} name
	   * @param {function} callback
	   * @param {any} [context]
	   * @memberof eventEmitter
	   * @instance
	   * @public
	   */
	  function once(name, callback, context) {
	    function listener() {
	      off(name, listener);
	      callback.apply(context, arguments);
	    }
	
	    listener._ = callback;
	
	    return on(name, listener, context);
	  }
	
	  /**
	   *
	   * Emit an event
	   *
	   * @param {string} name
	   * @param {any} ...rest arguments for the event
	   * @memberof eventEmitter
	   * @instance
	   * @public
	   */
	  function emit(name) {
	    var data = [].slice.call(arguments, 1);
	    var evtArr = (e[name] || []).slice();
	    var i = 0;
	    var len = evtArr.length;
	
	    for (i; i < len; i++) {
	      evtArr[i].fn.apply(evtArr[i].ctx, data);
	    }
	
	    return this;
	  }
	
	  /**
	   * Unsubscribe from an event or all events.
	   * If no callback is provided, it unsubscribes all callback from this event.
	   *
	   * @param {string} name
	   * @param {function} callback
	   * @memberof eventEmitter
	   * @instance
	   * @public
	   */
	  function off(name, callback) {
	    var evts = e[name];
	    var liveEvents = [];
	
	    if (evts && callback) {
	      for (var i = 0, len = evts.length; i < len; i++) {
	        if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
	      }
	    }
	
	    liveEvents.length ? e[name] = liveEvents : delete e[name];
	
	    return this;
	  }
	
	  return { on: on, once: once, emit: emit, off: off };
	}
	
	module.exports = eventEmitter;

/***/ },
/* 77 */
/*!*************************!*\
  !*** ./vendor/ramda.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	;(function() {
	
	  'use strict';
	
	  // jshint unused:vars
	    var _arity = function _arity(n, fn) {
	        // jshint unused:vars
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.apply(this, arguments);
	            };
	        case 1:
	            return function (a0) {
	                return fn.apply(this, arguments);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.apply(this, arguments);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.apply(this, arguments);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.apply(this, arguments);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.apply(this, arguments);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.apply(this, arguments);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.apply(this, arguments);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.apply(this, arguments);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.apply(this, arguments);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.apply(this, arguments);
	            };
	        default:
	            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
	        }
	    };
	
	    var _arrayFromIterator = function _arrayFromIterator(iter) {
	        var list = [];
	        var next;
	        while (!(next = iter.next()).done) {
	            list.push(next.value);
	        }
	        return list;
	    };
	
	    /**
	     * Private `concat` function to merge two array-like objects.
	     *
	     * @private
	     * @param {Array|Arguments} [set1=[]] An array-like object.
	     * @param {Array|Arguments} [set2=[]] An array-like object.
	     * @return {Array} A new, merged array.
	     * @example
	     *
	     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     */
	    var _concat = function _concat(set1, set2) {
	        set1 = set1 || [];
	        set2 = set2 || [];
	        var idx;
	        var len1 = set1.length;
	        var len2 = set2.length;
	        var result = [];
	        idx = 0;
	        while (idx < len1) {
	            result[result.length] = set1[idx];
	            idx += 1;
	        }
	        idx = 0;
	        while (idx < len2) {
	            result[result.length] = set2[idx];
	            idx += 1;
	        }
	        return result;
	    };
	
	    var _filter = function _filter(fn, list) {
	        var idx = 0, len = list.length, result = [];
	        while (idx < len) {
	            if (fn(list[idx])) {
	                result[result.length] = list[idx];
	            }
	            idx += 1;
	        }
	        return result;
	    };
	
	    var _forceReduced = function _forceReduced(x) {
	        return {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };
	
	    var _has = function _has(prop, obj) {
	        return Object.prototype.hasOwnProperty.call(obj, prop);
	    };
	
	    /**
	     * Tests whether or not an object is an array.
	     *
	     * @private
	     * @param {*} val The object to test.
	     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
	     * @example
	     *
	     *      _isArray([]); //=> true
	     *      _isArray(null); //=> false
	     *      _isArray({}); //=> false
	     */
	    var _isArray = Array.isArray || function _isArray(val) {
	        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
	    };
	
	    var _isPlaceholder = function _isPlaceholder(a) {
	        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
	    };
	
	    var _isString = function _isString(x) {
	        return Object.prototype.toString.call(x) === '[object String]';
	    };
	
	    var _isTransformer = function _isTransformer(obj) {
	        return typeof obj['@@transducer/step'] === 'function';
	    };
	
	    var _map = function _map(fn, functor) {
	        var idx = 0;
	        var len = functor.length;
	        var result = Array(len);
	        while (idx < len) {
	            result[idx] = fn(functor[idx]);
	            idx += 1;
	        }
	        return result;
	    };
	
	    var _pipe = function _pipe(f, g) {
	        return function () {
	            return g.call(this, f.apply(this, arguments));
	        };
	    };
	
	    var _reduced = function _reduced(x) {
	        return x && x['@@transducer/reduced'] ? x : {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };
	
	    /**
	     * An optimized, private array `slice` implementation.
	     *
	     * @private
	     * @param {Arguments|Array} args The array or arguments object to consider.
	     * @param {Number} [from=0] The array index to slice from, inclusive.
	     * @param {Number} [to=args.length] The array index to slice to, exclusive.
	     * @return {Array} A new, sliced array.
	     * @example
	     *
	     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
	     *
	     *      var firstThreeArgs = function(a, b, c, d) {
	     *        return _slice(arguments, 0, 3);
	     *      };
	     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
	     */
	    var _slice = function _slice(args, from, to) {
	        switch (arguments.length) {
	        case 1:
	            return _slice(args, 0, args.length);
	        case 2:
	            return _slice(args, from, args.length);
	        default:
	            var list = [];
	            var idx = 0;
	            var len = Math.max(0, Math.min(args.length, to) - from);
	            while (idx < len) {
	                list[idx] = args[from + idx];
	                idx += 1;
	            }
	            return list;
	        }
	    };
	
	    var _xfBase = {
	        init: function () {
	            return this.xf['@@transducer/init']();
	        },
	        result: function (result) {
	            return this.xf['@@transducer/result'](result);
	        }
	    };
	
	    var _xwrap = function () {
	        function XWrap(fn) {
	            this.f = fn;
	        }
	        XWrap.prototype['@@transducer/init'] = function () {
	            throw new Error('init not implemented on XWrap');
	        };
	        XWrap.prototype['@@transducer/result'] = function (acc) {
	            return acc;
	        };
	        XWrap.prototype['@@transducer/step'] = function (acc, x) {
	            return this.f(acc, x);
	        };
	        return function _xwrap(fn) {
	            return new XWrap(fn);
	        };
	    }();
	
	    /**
	     * Similar to hasMethod, this checks whether a function has a [methodname]
	     * function. If it isn't an array it will execute that function otherwise it
	     * will default to the ramda implementation.
	     *
	     * @private
	     * @param {Function} fn ramda implemtation
	     * @param {String} methodname property to check for a custom implementation
	     * @return {Object} Whatever the return value of the method is.
	     */
	    var _checkForMethod = function _checkForMethod(methodname, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
	        };
	    };
	
	    /**
	     * Optimized internal one-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry1 = function _curry1(fn) {
	        return function f1(a) {
	            if (arguments.length === 0 || _isPlaceholder(a)) {
	                return f1;
	            } else {
	                return fn.apply(this, arguments);
	            }
	        };
	    };
	
	    /**
	     * Optimized internal two-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry2 = function _curry2(fn) {
	        return function f2(a, b) {
	            switch (arguments.length) {
	            case 0:
	                return f2;
	            case 1:
	                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
	                    return fn(a, _b);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b);
	                }) : fn(a, b);
	            }
	        };
	    };
	
	    /**
	     * Optimized internal three-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry3 = function _curry3(fn) {
	        return function f3(a, b, c) {
	            switch (arguments.length) {
	            case 0:
	                return f3;
	            case 1:
	                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                });
	            case 2:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _curry1(function (_c) {
	                    return fn(a, b, _c);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
	                    return fn(_a, _b, c);
	                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b, c);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b, c);
	                }) : _isPlaceholder(c) ? _curry1(function (_c) {
	                    return fn(a, b, _c);
	                }) : fn(a, b, c);
	            }
	        };
	    };
	
	    /**
	     * Internal curryN function.
	     *
	     * @private
	     * @category Function
	     * @param {Number} length The arity of the curried function.
	     * @param {Array} received An array of arguments received thus far.
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curryN = function _curryN(length, received, fn) {
	        return function () {
	            var combined = [];
	            var argsIdx = 0;
	            var left = length;
	            var combinedIdx = 0;
	            while (combinedIdx < received.length || argsIdx < arguments.length) {
	                var result;
	                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
	                    result = received[combinedIdx];
	                } else {
	                    result = arguments[argsIdx];
	                    argsIdx += 1;
	                }
	                combined[combinedIdx] = result;
	                if (!_isPlaceholder(result)) {
	                    left -= 1;
	                }
	                combinedIdx += 1;
	            }
	            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
	        };
	    };
	
	    /**
	     * Returns a function that dispatches with different strategies based on the
	     * object in list position (last argument). If it is an array, executes [fn].
	     * Otherwise, if it has a function with [methodname], it will execute that
	     * function (functor case). Otherwise, if it is a transformer, uses transducer
	     * [xf] to return a new transformer (transducer case). Otherwise, it will
	     * default to executing [fn].
	     *
	     * @private
	     * @param {String} methodname property to check for a custom implementation
	     * @param {Function} xf transducer to initialize if object is transformer
	     * @param {Function} fn default ramda implementation
	     * @return {Function} A function that dispatches on object in list position
	     */
	    var _dispatchable = function _dispatchable(methodname, xf, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            if (!_isArray(obj)) {
	                var args = _slice(arguments, 0, length - 1);
	                if (typeof obj[methodname] === 'function') {
	                    return obj[methodname].apply(obj, args);
	                }
	                if (_isTransformer(obj)) {
	                    var transducer = xf.apply(null, args);
	                    return transducer(obj);
	                }
	            }
	            return fn.apply(this, arguments);
	        };
	    };
	
	    var _xall = function () {
	        function XAll(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.all = true;
	        }
	        XAll.prototype['@@transducer/init'] = _xfBase.init;
	        XAll.prototype['@@transducer/result'] = function (result) {
	            if (this.all) {
	                result = this.xf['@@transducer/step'](result, true);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAll.prototype['@@transducer/step'] = function (result, input) {
	            if (!this.f(input)) {
	                this.all = false;
	                result = _reduced(this.xf['@@transducer/step'](result, false));
	            }
	            return result;
	        };
	        return _curry2(function _xall(f, xf) {
	            return new XAll(f, xf);
	        });
	    }();
	
	    var _xfilter = function () {
	        function XFilter(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFilter.prototype['@@transducer/init'] = _xfBase.init;
	        XFilter.prototype['@@transducer/result'] = _xfBase.result;
	        XFilter.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
	        };
	        return _curry2(function _xfilter(f, xf) {
	            return new XFilter(f, xf);
	        });
	    }();
	
	    var _xfind = function () {
	        function XFind(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.found = false;
	        }
	        XFind.prototype['@@transducer/init'] = _xfBase.init;
	        XFind.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, void 0);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFind.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, input));
	            }
	            return result;
	        };
	        return _curry2(function _xfind(f, xf) {
	            return new XFind(f, xf);
	        });
	    }();
	
	    var _xfindIndex = function () {
	        function XFindIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.found = false;
	        }
	        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindIndex.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, -1);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
	            }
	            return result;
	        };
	        return _curry2(function _xfindIndex(f, xf) {
	            return new XFindIndex(f, xf);
	        });
	    }();
	
	    var _xmap = function () {
	        function XMap(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XMap.prototype['@@transducer/init'] = _xfBase.init;
	        XMap.prototype['@@transducer/result'] = _xfBase.result;
	        XMap.prototype['@@transducer/step'] = function (result, input) {
	            return this.xf['@@transducer/step'](result, this.f(input));
	        };
	        return _curry2(function _xmap(f, xf) {
	            return new XMap(f, xf);
	        });
	    }();
	
	    /**
	     * Returns `true` if all elements of the list match the predicate, `false` if
	     * there are any that don't.
	     *
	     * Dispatches to the `all` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
	     *         otherwise.
	     * @see R.any, R.none, R.transduce
	     * @example
	     *
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      var lessThan3 = R.flip(R.lt)(3);
	     *      R.all(lessThan2)([1, 2]); //=> false
	     *      R.all(lessThan3)([1, 2]); //=> true
	     */
	    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (!fn(list[idx])) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    }));
	
	    /**
	     * Creates a function that is bound to a context.
	     * Note: `R.bind` does not provide the additional argument-binding capabilities of
	     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Function
	     * @category Object
	     * @sig (* -> *) -> {*} -> (* -> *)
	     * @param {Function} fn The function to bind to context
	     * @param {Object} thisObj The context to bind `fn` to
	     * @return {Function} A function that will execute in the context of `thisObj`.
	     * @see R.partial
	     */
	    var bind = _curry2(function bind(fn, thisObj) {
	        return _arity(fn.length, function () {
	            return fn.apply(thisObj, arguments);
	        });
	    });
	
	    /**
	     * Returns a curried equivalent of the provided function, with the specified
	     * arity. The curried function has two unusual capabilities. First, its
	     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curry
	     * @example
	     *
	     *      var sumArgs = (...args) => R.sum(args);
	     *
	     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curryN = _curry2(function curryN(length, fn) {
	        if (length === 1) {
	            return _curry1(fn);
	        }
	        return _arity(length, _curryN(length, [], fn));
	    });
	
	    /**
	     * Returns a new list containing only those items that match a given predicate
	     * function. The predicate function is passed one argument: *(value)*.
	     *
	     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the
	     * native `Array.prototype.filter` method. For more details on this behavior,
	     * see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
	     *
	     * Dispatches to the `filter` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} The new filtered array.
	     * @see R.reject, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *
	     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
	     */
	    var filter = _curry2(_dispatchable('filter', _xfilter, _filter));
	
	    /**
	     * Returns the first element of the list which matches the predicate, or
	     * `undefined` if no element matches.
	     *
	     * Dispatches to the `find` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     *        desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
	     *      R.find(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx += 1;
	        }
	    }));
	
	    /**
	     * Returns the index of the first element of the list which matches the
	     * predicate, or `-1` if no element matches.
	     *
	     * Dispatches to the `findIndex` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
	     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    }));
	
	    /**
	     * Iterate over an input `list`, calling a provided function `fn` for each
	     * element in the list.
	     *
	     * `fn` receives one argument: *(value)*.
	     *
	     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.forEach` method. For more
	     * details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
	     *
	     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
	     * the original array. In some libraries this function is named `each`.
	     *
	     * Dispatches to the `forEach` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> *) -> [a] -> [a]
	     * @param {Function} fn The function to invoke. Receives one argument, `value`.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} The original list.
	     * @see R.addIndex
	     * @example
	     *
	     *      var printXPlusFive = x => console.log(x + 5);
	     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
	     *      //-> 6
	     *      //-> 7
	     *      //-> 8
	     */
	    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            fn(list[idx]);
	            idx += 1;
	        }
	        return list;
	    }));
	
	    /**
	     * Returns true if its arguments are identical, false otherwise. Values are
	     * identical if they reference the same memory. `NaN` is identical to `NaN`;
	     * `0` and `-0` are not identical.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      var o = {};
	     *      R.identical(o, o); //=> true
	     *      R.identical(1, 1); //=> true
	     *      R.identical(1, '1'); //=> false
	     *      R.identical([], []); //=> false
	     *      R.identical(0, -0); //=> false
	     *      R.identical(NaN, NaN); //=> true
	     */
	    // SameValue algorithm
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Step 6.a: NaN == NaN
	    var identical = _curry2(function identical(a, b) {
	        // SameValue algorithm
	        if (a === b) {
	            // Steps 1-5, 7-10
	            // Steps 6.b-6.e: +0 != -0
	            return a !== 0 || 1 / a === 1 / b;
	        } else {
	            // Step 6.a: NaN == NaN
	            return a !== a && b !== b;
	        }
	    });
	
	    /**
	     * See if an object (`val`) is an instance of the supplied constructor. This
	     * function will check up the inheritance chain, if any.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Type
	     * @sig (* -> {*}) -> a -> Boolean
	     * @param {Object} ctor A constructor
	     * @param {*} val The value to test
	     * @return {Boolean}
	     * @example
	     *
	     *      R.is(Object, {}); //=> true
	     *      R.is(Number, 1); //=> true
	     *      R.is(Object, 1); //=> false
	     *      R.is(String, 's'); //=> true
	     *      R.is(String, new String('')); //=> true
	     *      R.is(Object, new String('')); //=> true
	     *      R.is(Object, 's'); //=> false
	     *      R.is(Number, {}); //=> false
	     */
	    var is = _curry2(function is(Ctor, val) {
	        return val != null && val.constructor === Ctor || val instanceof Ctor;
	    });
	
	    /**
	     * Tests whether or not an object is similar to an array.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Type
	     * @category List
	     * @sig * -> Boolean
	     * @param {*} x The object to test.
	     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
	     * @example
	     *
	     *      R.isArrayLike([]); //=> true
	     *      R.isArrayLike(true); //=> false
	     *      R.isArrayLike({}); //=> false
	     *      R.isArrayLike({length: 10}); //=> false
	     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
	     */
	    var isArrayLike = _curry1(function isArrayLike(x) {
	        if (_isArray(x)) {
	            return true;
	        }
	        if (!x) {
	            return false;
	        }
	        if (typeof x !== 'object') {
	            return false;
	        }
	        if (x instanceof String) {
	            return false;
	        }
	        if (x.nodeType === 1) {
	            return !!x.length;
	        }
	        if (x.length === 0) {
	            return true;
	        }
	        if (x.length > 0) {
	            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
	        }
	        return false;
	    });
	
	    /**
	     * Returns a list containing the names of all the enumerable own properties of
	     * the supplied object.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own properties.
	     * @example
	     *
	     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
	     */
	    // cover IE < 9 keys issues
	    var keys = function () {
	        // cover IE < 9 keys issues
	        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
	        var nonEnumerableProps = [
	            'constructor',
	            'valueOf',
	            'isPrototypeOf',
	            'toString',
	            'propertyIsEnumerable',
	            'hasOwnProperty',
	            'toLocaleString'
	        ];
	        var contains = function contains(list, item) {
	            var idx = 0;
	            while (idx < list.length) {
	                if (list[idx] === item) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        };
	        return typeof Object.keys === 'function' ? _curry1(function keys(obj) {
	            return Object(obj) !== obj ? [] : Object.keys(obj);
	        }) : _curry1(function keys(obj) {
	            if (Object(obj) !== obj) {
	                return [];
	            }
	            var prop, ks = [], nIdx;
	            for (prop in obj) {
	                if (_has(prop, obj)) {
	                    ks[ks.length] = prop;
	                }
	            }
	            if (hasEnumBug) {
	                nIdx = nonEnumerableProps.length - 1;
	                while (nIdx >= 0) {
	                    prop = nonEnumerableProps[nIdx];
	                    if (_has(prop, obj) && !contains(ks, prop)) {
	                        ks[ks.length] = prop;
	                    }
	                    nIdx -= 1;
	                }
	            }
	            return ks;
	        });
	    }();
	
	    /**
	     * Returns a partial copy of an object containing only the keys specified. If
	     * the key does not exist, the property is ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.omit, R.props
	     * @example
	     *
	     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
	     */
	    var pick = _curry2(function pick(names, obj) {
	        var result = {};
	        var idx = 0;
	        while (idx < names.length) {
	            if (names[idx] in obj) {
	                result[names[idx]] = obj[names[idx]];
	            }
	            idx += 1;
	        }
	        return result;
	    });
	
	    /**
	     * Returns a partial copy of an object containing only the keys that satisfy
	     * the supplied predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
	     * @param {Function} pred A predicate to determine whether or not a key
	     *        should be included on the output object.
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties that satisfy `pred`
	     *         on it.
	     * @see R.pick
	     * @example
	     *
	     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
	     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
	     */
	    var pickBy = _curry2(function pickBy(test, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (test(obj[prop], prop, obj)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });
	
	    /**
	     * Returns a function that when supplied an object returns the indicated
	     * property of that object, if it exists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig s -> {s: a} -> a | Undefined
	     * @param {String} p The property name
	     * @param {Object} obj The object to query
	     * @return {*} The value at `obj.p`.
	     * @example
	     *
	     *      R.prop('x', {x: 100}); //=> 100
	     *      R.prop('x', {}); //=> undefined
	     */
	    var prop = _curry2(function prop(p, obj) {
	        return obj[p];
	    });
	
	    /**
	     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> [v]
	     * @param {Array} ps The property names to fetch
	     * @param {Object} obj The object to query
	     * @return {Array} The corresponding values or partially applied function.
	     * @example
	     *
	     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
	     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
	     *
	     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
	     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
	     */
	    var props = _curry2(function props(ps, obj) {
	        var len = ps.length;
	        var out = [];
	        var idx = 0;
	        while (idx < len) {
	            out[idx] = obj[ps[idx]];
	            idx += 1;
	        }
	        return out;
	    });
	
	    /**
	     * Returns a new list or string with the elements or characters in reverse
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {Array|String} list
	     * @return {Array|String}
	     * @example
	     *
	     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
	     *      R.reverse([1, 2]);     //=> [2, 1]
	     *      R.reverse([1]);        //=> [1]
	     *      R.reverse([]);         //=> []
	     *
	     *      R.reverse('abc');      //=> 'cba'
	     *      R.reverse('ab');       //=> 'ba'
	     *      R.reverse('a');        //=> 'a'
	     *      R.reverse('');         //=> ''
	     */
	    var reverse = _curry1(function reverse(list) {
	        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
	    });
	
	    /**
	     * Returns the elements of the given list or string (or object with a `slice`
	     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
	     *
	     * Dispatches to the `slice` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @sig Number -> Number -> String -> String
	     * @param {Number} fromIndex The start index (inclusive).
	     * @param {Number} toIndex The end index (exclusive).
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
	     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
	     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
	     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
	     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
	     */
	    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
	        return Array.prototype.slice.call(list, fromIndex, toIndex);
	    }));
	
	    /**
	     * Returns all but the first element of the given list or string (or object
	     * with a `tail` method).
	     *
	     * Dispatches to the `slice` method of the first argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.head, R.init, R.last
	     * @example
	     *
	     *      R.tail([1, 2, 3]);  //=> [2, 3]
	     *      R.tail([1, 2]);     //=> [2]
	     *      R.tail([1]);        //=> []
	     *      R.tail([]);         //=> []
	     *
	     *      R.tail('abc');  //=> 'bc'
	     *      R.tail('ab');   //=> 'b'
	     *      R.tail('a');    //=> ''
	     *      R.tail('');     //=> ''
	     */
	    var tail = _checkForMethod('tail', slice(1, Infinity));
	
	    /**
	     * Gives a single-word string description of the (native) type of a value,
	     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
	     * attempt to distinguish user Object types any further, reporting them all as
	     * 'Object'.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Type
	     * @sig (* -> {*}) -> String
	     * @param {*} val The value to test
	     * @return {String}
	     * @example
	     *
	     *      R.type({}); //=> "Object"
	     *      R.type(1); //=> "Number"
	     *      R.type(false); //=> "Boolean"
	     *      R.type('s'); //=> "String"
	     *      R.type(null); //=> "Null"
	     *      R.type([]); //=> "Array"
	     *      R.type(/[A-z]/); //=> "RegExp"
	     */
	    var type = _curry1(function type(val) {
	        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
	    });
	
	    /**
	     * Returns a list of all the enumerable own properties of the supplied object.
	     * Note that the order of the output array is not guaranteed across different
	     * JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own properties.
	     * @example
	     *
	     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
	     */
	    var values = _curry1(function values(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var vals = [];
	        var idx = 0;
	        while (idx < len) {
	            vals[idx] = obj[props[idx]];
	            idx += 1;
	        }
	        return vals;
	    });
	
	    // Values of other types are only equal if identical.
	    var _equals = function _equals(a, b, stackA, stackB) {
	        if (identical(a, b)) {
	            return true;
	        }
	        if (type(a) !== type(b)) {
	            return false;
	        }
	        if (a == null || b == null) {
	            return false;
	        }
	        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
	            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
	        }
	        switch (type(a)) {
	        case 'Arguments':
	        case 'Array':
	        case 'Object':
	            break;
	        case 'Boolean':
	        case 'Number':
	        case 'String':
	            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
	                return false;
	            }
	            break;
	        case 'Date':
	            if (!identical(a.valueOf(), b.valueOf())) {
	                return false;
	            }
	            break;
	        case 'Error':
	            if (!(a.name === b.name && a.message === b.message)) {
	                return false;
	            }
	            break;
	        case 'RegExp':
	            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
	                return false;
	            }
	            break;
	        case 'Map':
	        case 'Set':
	            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
	                return false;
	            }
	            break;
	        case 'Int8Array':
	        case 'Uint8Array':
	        case 'Uint8ClampedArray':
	        case 'Int16Array':
	        case 'Uint16Array':
	        case 'Int32Array':
	        case 'Uint32Array':
	        case 'Float32Array':
	        case 'Float64Array':
	            break;
	        case 'ArrayBuffer':
	            break;
	        default:
	            // Values of other types are only equal if identical.
	            return false;
	        }
	        var keysA = keys(a);
	        if (keysA.length !== keys(b).length) {
	            return false;
	        }
	        var idx = stackA.length - 1;
	        while (idx >= 0) {
	            if (stackA[idx] === a) {
	                return stackB[idx] === b;
	            }
	            idx -= 1;
	        }
	        stackA.push(a);
	        stackB.push(b);
	        idx = keysA.length - 1;
	        while (idx >= 0) {
	            var key = keysA[idx];
	            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
	                return false;
	            }
	            idx -= 1;
	        }
	        stackA.pop();
	        stackB.pop();
	        return true;
	    };
	
	    /**
	     * `_makeFlat` is a helper function that returns a one-level or fully recursive
	     * function based on the flag passed in.
	     *
	     * @private
	     */
	    var _makeFlat = function _makeFlat(recursive) {
	        return function flatt(list) {
	            var value, result = [], idx = 0, j, ilen = list.length, jlen;
	            while (idx < ilen) {
	                if (isArrayLike(list[idx])) {
	                    value = recursive ? flatt(list[idx]) : list[idx];
	                    j = 0;
	                    jlen = value.length;
	                    while (j < jlen) {
	                        result[result.length] = value[j];
	                        j += 1;
	                    }
	                } else {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	            return result;
	        };
	    };
	
	    var _reduce = function () {
	        function _arrayReduce(xf, acc, list) {
	            var idx = 0, len = list.length;
	            while (idx < len) {
	                acc = xf['@@transducer/step'](acc, list[idx]);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                idx += 1;
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _iterableReduce(xf, acc, iter) {
	            var step = iter.next();
	            while (!step.done) {
	                acc = xf['@@transducer/step'](acc, step.value);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                step = iter.next();
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _methodReduce(xf, acc, obj) {
	            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
	        }
	        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	        return function _reduce(fn, acc, list) {
	            if (typeof fn === 'function') {
	                fn = _xwrap(fn);
	            }
	            if (isArrayLike(list)) {
	                return _arrayReduce(fn, acc, list);
	            }
	            if (typeof list.reduce === 'function') {
	                return _methodReduce(fn, acc, list);
	            }
	            if (list[symIterator] != null) {
	                return _iterableReduce(fn, acc, list[symIterator]());
	            }
	            if (typeof list.next === 'function') {
	                return _iterableReduce(fn, acc, list);
	            }
	            throw new TypeError('reduce: list must be array or iterable');
	        };
	    }();
	
	    /**
	     * Creates a new list iteration function from an existing one by adding two new
	     * parameters to its callback function: the current index, and the entire list.
	     *
	     * This would turn, for instance, Ramda's simple `map` function into one that
	     * more closely resembles `Array.prototype.map`. Note that this will only work
	     * for functions in which the iteration callback function is the first
	     * parameter, and where the list is the last parameter. (This latter might be
	     * unimportant if the list parameter is not used.)
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Function
	     * @category List
	     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
	     * @param {Function} fn A list iteration function that does not pass index or list to its callback
	     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
	     * @example
	     *
	     *      var mapIndexed = R.addIndex(R.map);
	     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
	     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
	     */
	    var addIndex = _curry1(function addIndex(fn) {
	        return curryN(fn.length, function () {
	            var idx = 0;
	            var origFn = arguments[0];
	            var list = arguments[arguments.length - 1];
	            var args = _slice(arguments);
	            args[0] = function () {
	                var result = origFn.apply(this, _concat(arguments, [
	                    idx,
	                    list
	                ]));
	                idx += 1;
	                return result;
	            };
	            return fn.apply(this, args);
	        });
	    });
	
	    /**
	     * Returns a curried equivalent of the provided function. The curried function
	     * has two unusual capabilities. First, its arguments needn't be provided one
	     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (* -> a) -> (* -> a)
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curryN
	     * @example
	     *
	     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
	     *
	     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curry = _curry1(function curry(fn) {
	        return curryN(fn.length, fn);
	    });
	
	    /**
	     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
	     * cyclical data structures.
	     *
	     * Dispatches symmetrically to the `equals` methods of both arguments, if
	     * present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> b -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      R.equals(1, 1); //=> true
	     *      R.equals(1, '1'); //=> false
	     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
	     *
	     *      var a = {}; a.v = a;
	     *      var b = {}; b.v = b;
	     *      R.equals(a, b); //=> true
	     */
	    var equals = _curry2(function equals(a, b) {
	        return _equals(a, b, [], []);
	    });
	
	    /**
	     * Returns a new list by pulling every item out of it (and all its sub-arrays)
	     * and putting them in a new array, depth-first.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b]
	     * @param {Array} list The array to consider.
	     * @return {Array} The flattened list.
	     * @see R.unnest
	     * @example
	     *
	     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
	     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
	     */
	    var flatten = _curry1(_makeFlat(true));
	
	    /**
	     * Returns a new list, constructed by applying the supplied function to every
	     * element of the supplied list.
	     *
	     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays),
	     * unlike the native `Array.prototype.map` method. For more details on this
	     * behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
	     *
	     * Dispatches to the `map` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * Also treats functions as functors and will compose them together.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Functor f => (a -> b) -> f a -> f b
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {Array} list The list to be iterated over.
	     * @return {Array} The new list.
	     * @see R.transduce, R.addIndex
	     * @example
	     *
	     *      var double = x => x * 2;
	     *
	     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
	     *
	     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
	     */
	    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
	        switch (Object.prototype.toString.call(functor)) {
	        case '[object Function]':
	            return curryN(functor.length, function () {
	                return fn.call(this, functor.apply(this, arguments));
	            });
	        case '[object Object]':
	            return _reduce(function (acc, key) {
	                acc[key] = fn(functor[key]);
	                return acc;
	            }, {}, keys(functor));
	        default:
	            return _map(fn, functor);
	        }
	    }));
	
	    /**
	     * Like `mapObj`, but passes additional arguments to the predicate function.
	     * The predicate function is passed three arguments: *(value, key, obj)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}
	     * @param {Function} fn A function called for each property in `obj`. Its return value will
	     *        become a new property on the return object.
	     * @param {Object} obj The object to iterate over.
	     * @return {Object} A new object with the same keys as `obj` and values that are the result
	     *         of running each property through `fn`.
	     * @example
	     *
	     *      var values = { x: 1, y: 2, z: 3 };
	     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
	     *
	     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
	     */
	    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
	        return _reduce(function (acc, key) {
	            acc[key] = fn(obj[key], key, obj);
	            return acc;
	        }, {}, keys(obj));
	    });
	
	    /**
	     * Returns a single item by iterating through the list, successively calling
	     * the iterator function and passing it an accumulator value and the current
	     * value from the array, and then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It may use
	     * `R.reduced` to shortcut the iteration.
	     *
	     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.reduce` method. For more details
	     * on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
	     *
	     * Dispatches to the `reduce` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig ((a, b) -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.reduced, R.addIndex
	     * @example
	     *
	     *      var numbers = [1, 2, 3];
	     *      var add = (a, b) => a + b;
	     *
	     *      R.reduce(add, 10, numbers); //=> 16
	     */
	    var reduce = _curry3(_reduce);
	
	    var _flatCat = function () {
	        var preservingReduced = function (xf) {
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return xf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    var ret = xf['@@transducer/step'](result, input);
	                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
	                }
	            };
	        };
	        return function _xcat(xf) {
	            var rxf = preservingReduced(xf);
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return rxf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
	                }
	            };
	        };
	    }();
	
	    var _indexOf = function _indexOf(list, item, from) {
	        var idx = from;
	        while (idx < list.length) {
	            if (equals(list[idx], item)) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    };
	
	    var _xchain = _curry2(function _xchain(f, xf) {
	        return map(f, _flatCat(xf));
	    });
	
	    /**
	     * `chain` maps a function over a list and concatenates the results. `chain`
	     * is also known as `flatMap` in some libraries
	     *
	     * Dispatches to the `chain` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig (a -> [b]) -> [a] -> [b]
	     * @param {Function} fn
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      var duplicate = n => [n, n];
	     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
	     */
	    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
	        if (typeof monad === 'function') {
	            return function () {
	                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
	            };
	        }
	        return _makeFlat(false)(map(fn, monad));
	    }));
	
	    /**
	     * Performs left-to-right function composition. The leftmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * In some libraries this function is named `sequence`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.compose
	     * @example
	     *
	     *      var f = R.pipe(Math.pow, R.negate, R.inc);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var pipe = function pipe() {
	        if (arguments.length === 0) {
	            throw new Error('pipe requires at least one argument');
	        }
	        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
	    };
	
	    /* globals Set */
	    // manually crawl the list to distinguish between +0 and -0
	    // non-zero numbers can utilise Set
	    // all these types can utilise Set
	    // null can utilise Set
	    // other objects need R.equals for equality
	    // anything else not covered above, defer to R.equals
	    var _contains = typeof Set === 'undefined' ? function _contains(a, list) {
	        return _indexOf(list, a, 0) >= 0;
	    } : function _containsSet(a, list) {
	        var idx, inf, item;
	        switch (typeof a) {
	        case 'number':
	            if (a === 0) {
	                // manually crawl the list to distinguish between +0 and -0
	                idx = 0;
	                inf = 1 / a;
	                while (idx < list.length) {
	                    item = list[idx];
	                    if (item === 0 && 1 / item === inf) {
	                        return true;
	                    }
	                    idx += 1;
	                }
	                return false;
	            }
	            // non-zero numbers can utilise Set
	            return new Set(list).has(a);
	        // all these types can utilise Set
	        case 'string':
	        case 'boolean':
	        case 'function':
	        case 'undefined':
	            return new Set(list).has(a);
	        case 'object':
	            if (a === null) {
	                // null can utilise Set
	                return new Set(list).has(a);
	            }
	            // other objects need R.equals for equality
	            return _indexOf(list, a, 0) >= 0;
	        default:
	            // anything else not covered above, defer to R.equals
	            return _indexOf(list, a, 0) >= 0;
	        }
	    };
	
	    /**
	     * Performs right-to-left function composition. The rightmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipe
	     * @example
	     *
	     *      var f = R.compose(R.inc, R.negate, Math.pow);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var compose = function compose() {
	        if (arguments.length === 0) {
	            throw new Error('compose requires at least one argument');
	        }
	        return pipe.apply(this, reverse(arguments));
	    };
	
	    /**
	     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
	     * least one element of the given list; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Boolean
	     * @param {Object} a The item to compare against.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
	     * @see R.any
	     * @example
	     *
	     *      R.contains(3, [1, 2, 3]); //=> true
	     *      R.contains(4, [1, 2, 3]); //=> false
	     *      R.contains([42], [[42]]); //=> true
	     */
	    var contains = _curry2(_contains);
	
	    /**
	     * Returns a partial copy of an object omitting the keys specified.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [String] -> {String: *} -> {String: *}
	     * @param {Array} names an array of String property names to omit from the new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with properties from `names` not on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
	     */
	    var omit = _curry2(function omit(names, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (!_contains(prop, names)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });
	
	    var R = {
	        addIndex: addIndex,
	        all: all,
	        chain: chain,
	        compose: compose,
	        contains: contains,
	        curry: curry,
	        curryN: curryN,
	        filter: filter,
	        find: find,
	        findIndex: findIndex,
	        flatten: flatten,
	        forEach: forEach,
	        is: is,
	        map: map,
	        mapObjIndexed: mapObjIndexed,
	        omit: omit,
	        pick: pick,
	        pickBy: pickBy,
	        prop: prop,
	        props: props,
	        reduce: reduce,
	        values: values
	    };
	
	  /* TEST_ENTRY_POINT */
	
	  if (true) {
	    module.exports = R;
	  } else if (typeof define === 'function' && define.amd) {
	    define(function() { return R; });
	  } else {
	    this.R = R;
	  }
	
	}.call(this));


/***/ },
/* 78 */
/*!**************************!*\
  !*** ./src/store/api.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _apiBase = __webpack_require__(/*! ./apiBase */ 79);
	
	var _apiBase2 = _interopRequireDefault(_apiBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function fetchNext(url, urls, success, failure, _ref) {
	  var contentType = _ref.contentType;
	  var method = _ref.method;
	  var body = _ref.body;
	
	  function tryNext(err) {
	    if (urls.length) {
	      return fetchNext(urls[0], urls.slice(1), success, failure, { contentType: contentType, method: method, body: body });
	    } else {
	      failure(err);
	    }
	  }
	
	  if (contentType === 'img') {
	    (function () {
	      var img = new Image();
	      img.crossOrigin = 'anonymous'; // don't send cookies, but do send Origin: header
	      img.addEventListener('load', function (e) {
	        success(img);
	      });
	      img.addEventListener('error', tryNext);
	      img.src = url; //s.shift();
	    })();
	  } else if (contentType === 'external') {
	      // This will need to use JSONP in some fashion (either dynamic function,
	      // or some sort of global plugin namespace in order to work, since
	      // CORS prevents us from just loading the file via xhr
	      throw new Error('External Script support not allowed in the browser');
	    } else {
	      (function () {
	        var request = new XMLHttpRequest();
	        var requestMethod = method || 'GET';
	        if (requestMethod !== 'GET') request.withCredentials = true;
	        request.open(requestMethod, url, true);
	        if (body) request.setRequestHeader('Content-Type', 'application/json');
	
	        if (contentType === 'binary') request.responseType = "arraybuffer";
	        request.onload = function (xhr) {
	          var response = request.response;
	
	          if (request.status >= 200 && request.status < 400) {
	            if (contentType === 'json') response = JSON.parse(response);
	            success(response);
	          } else {
	            tryNext(request);
	          }
	        };
	        request.onerror = tryNext;
	        request.send(body);
	      })();
	    }
	}
	
	var callApi = (0, _apiBase2.default)(fetchNext);
	
	exports.default = callApi;

/***/ },
/* 79 */
/*!******************************!*\
  !*** ./src/store/apiBase.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = apiBase;
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 98);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _rsvp = __webpack_require__(/*! rsvp */ 105);
	
	var _rsvp2 = _interopRequireDefault(_rsvp);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Simple, persistent api cache for now.
	var apiCache = {};
	var fetchingCache = {};
	
	function apiBase(fetchNext) {
	  return function (store, _ref) {
	    var types = _ref.types;
	    var url = _ref.url;
	    var fireAndForget = _ref.fireAndForget;
	    var payload = _ref.payload;
	    var queryKey = _ref.queryKey;
	    var requestPayload = _ref.requestPayload;
	    var cache = _ref.cache;
	    var method = _ref.method;
	    var contentType = _ref.contentType;
	    var body = _ref.body;
	    var files = _ref.files;
	    var success = _ref.success;
	    var failure = _ref.failure;
	
	    var urls = Array.isArray(url) ? url : [url];
	    if (!contentType) contentType = 'json';
	
	    var _ref2 = types || ['IGN', 'IGN', 'IGN'];
	
	    var _ref3 = (0, _slicedToArray3.default)(_ref2, 3);
	
	    var requestType = _ref3[0];
	    var successType = _ref3[1];
	    var failureType = _ref3[2];
	
	    // If we provide a 'queryKey', there can be only one query at once
	
	    if (queryKey) {
	      if (apiCache[queryKey]) return fireAndForget ? apiCache[queryKey] : _promise2.default.resolve(apiCache[queryKey]);
	      if (fetchingCache[queryKey]) {
	        if (fireAndForget) {
	          fetchingCache[queryKey].push({ payload: payload, store: store });
	          store.dispatch({ type: requestType, payload: payload });
	          return;
	        } else {
	          return new _rsvp2.default.Promise(function (resolve, reject) {
	            fetchingCache[queryKey].push({ payload: payload, store: store, resolve: resolve, reject: reject });
	            store.dispatch({ type: requestType, payload: payload });
	          });
	        }
	      }
	      fetchingCache[queryKey] = [{ payload: payload, store: store }];
	    }
	
	    store.dispatch({ type: requestType, payload: payload });
	
	    var promise = new _rsvp2.default.Promise(function (resolve, reject) {
	      function onFailure(error) {
	        if (queryKey) {
	          (0, _ramda.forEach)(function (_ref4) {
	            var payload = _ref4.payload;
	            var store = _ref4.store;
	            var reject = _ref4.reject;
	
	            store.dispatch({ type: failureType, payload: payload, error: error });
	            if (reject) reject(error);
	          }, fetchingCache[queryKey]);
	          delete fetchingCache[queryKey];
	        } else {
	          store.dispatch({ type: failureType, payload: payload, error: error });
	        }
	        if (failure) failure(error);
	        reject(error);
	      };
	
	      function onSuccess(response) {
	        if (queryKey) {
	          apiCache[queryKey] = response;
	          (0, _ramda.forEach)(function (_ref5) {
	            var payload = _ref5.payload;
	            var store = _ref5.store;
	            var resolve = _ref5.resolve;
	
	            store.dispatch({ type: successType, payload: payload, response: response });
	            if (resolve) resolve(response);
	          }, fetchingCache[queryKey]);
	          delete fetchingCache[queryKey];
	        } else {
	          store.dispatch({ type: successType, payload: payload, response: response });
	        }
	        if (success) success(response);
	        resolve(response);
	      };
	
	      fetchNext(urls[0], urls.slice(1), onSuccess, onFailure, { contentType: contentType, method: method, body: body, files: files });
	    });
	
	    return fireAndForget ? null : promise;
	  };
	}

/***/ },
/* 80 */
/*!********************************************!*\
  !*** ./~/babel-runtime/core-js/promise.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/promise */ 81), __esModule: true };

/***/ },
/* 81 */
/*!*********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/promise.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/es6.object.to-string */ 82);
	__webpack_require__(/*! ../modules/es6.string.iterator */ 5);
	__webpack_require__(/*! ../modules/web.dom.iterable */ 83);
	__webpack_require__(/*! ../modules/es6.promise */ 87);
	module.exports = __webpack_require__(/*! ../modules/_core */ 13).Promise;

/***/ },
/* 82 */
/*!***************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.to-string.js ***!
  \***************************************************************************/
/***/ function(module, exports) {



/***/ },
/* 83 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/web.dom.iterable.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./es6.array.iterator */ 84);
	var global        = __webpack_require__(/*! ./_global */ 12)
	  , hide          = __webpack_require__(/*! ./_hide */ 16)
	  , Iterators     = __webpack_require__(/*! ./_iterators */ 28)
	  , TO_STRING_TAG = __webpack_require__(/*! ./_wks */ 46)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 84 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.array.iterator.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ 85)
	  , step             = __webpack_require__(/*! ./_iter-step */ 86)
	  , Iterators        = __webpack_require__(/*! ./_iterators */ 28)
	  , toIObject        = __webpack_require__(/*! ./_to-iobject */ 34);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(/*! ./_iter-define */ 9)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 85 */
/*!**************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_add-to-unscopables.js ***!
  \**************************************************************************/
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 86 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_iter-step.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 87 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.promise.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(/*! ./_library */ 10)
	  , global             = __webpack_require__(/*! ./_global */ 12)
	  , ctx                = __webpack_require__(/*! ./_ctx */ 14)
	  , classof            = __webpack_require__(/*! ./_classof */ 54)
	  , $export            = __webpack_require__(/*! ./_export */ 11)
	  , isObject           = __webpack_require__(/*! ./_is-object */ 19)
	  , anObject           = __webpack_require__(/*! ./_an-object */ 18)
	  , aFunction          = __webpack_require__(/*! ./_a-function */ 15)
	  , anInstance         = __webpack_require__(/*! ./_an-instance */ 88)
	  , forOf              = __webpack_require__(/*! ./_for-of */ 89)
	  , setProto           = __webpack_require__(/*! ./_set-proto */ 90).set
	  , speciesConstructor = __webpack_require__(/*! ./_species-constructor */ 92)
	  , task               = __webpack_require__(/*! ./_task */ 93).set
	  , microtask          = __webpack_require__(/*! ./_microtask */ 95)
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ 46)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ 96)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(/*! ./_set-to-string-tag */ 45)($Promise, PROMISE);
	__webpack_require__(/*! ./_set-species */ 97)(PROMISE);
	Wrapper = __webpack_require__(/*! ./_core */ 13)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ 55)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 88 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_an-instance.js ***!
  \*******************************************************************/
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 89 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_for-of.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(/*! ./_ctx */ 14)
	  , call        = __webpack_require__(/*! ./_iter-call */ 50)
	  , isArrayIter = __webpack_require__(/*! ./_is-array-iter */ 51)
	  , anObject    = __webpack_require__(/*! ./_an-object */ 18)
	  , toLength    = __webpack_require__(/*! ./_to-length */ 38)
	  , getIterFn   = __webpack_require__(/*! ./core.get-iterator-method */ 53);
	module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    call(iterator, f, step.value, entries);
	  }
	};

/***/ },
/* 90 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_set-proto.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , anObject = __webpack_require__(/*! ./_an-object */ 18);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(/*! ./_ctx */ 14)(Function.call, __webpack_require__(/*! ./_object-gopd */ 91).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 91 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gopd.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(/*! ./_object-pie */ 61)
	  , createDesc     = __webpack_require__(/*! ./_property-desc */ 25)
	  , toIObject      = __webpack_require__(/*! ./_to-iobject */ 34)
	  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ 24)
	  , has            = __webpack_require__(/*! ./_has */ 27)
	  , IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ 20)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(/*! ./_descriptors */ 21) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 92 */
/*!***************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_species-constructor.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(/*! ./_an-object */ 18)
	  , aFunction = __webpack_require__(/*! ./_a-function */ 15)
	  , SPECIES   = __webpack_require__(/*! ./_wks */ 46)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 93 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_task.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(/*! ./_ctx */ 14)
	  , invoke             = __webpack_require__(/*! ./_invoke */ 94)
	  , html               = __webpack_require__(/*! ./_html */ 44)
	  , cel                = __webpack_require__(/*! ./_dom-create */ 23)
	  , global             = __webpack_require__(/*! ./_global */ 12)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(/*! ./_cof */ 36)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 94 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_invoke.js ***!
  \**************************************************************/
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 95 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_microtask.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(/*! ./_global */ 12)
	  , macrotask = __webpack_require__(/*! ./_task */ 93).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(/*! ./_cof */ 36)(process) == 'process'
	  , head, last, notify;
	
	var flush = function(){
	  var parent, fn;
	  if(isNode && (parent = process.domain))parent.exit();
	  while(head){
	    fn = head.fn;
	    fn(); // <- currently we use it only for Promise - try / catch not required
	    head = head.next;
	  } last = undefined;
	  if(parent)parent.enter();
	};
	
	// Node.js
	if(isNode){
	  notify = function(){
	    process.nextTick(flush);
	  };
	// browsers with MutationObserver
	} else if(Observer){
	  var toggle = true
	    , node   = document.createTextNode('');
	  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	  notify = function(){
	    node.data = toggle = !toggle;
	  };
	// environments with maybe non-completely correct, but existent Promise
	} else if(Promise && Promise.resolve){
	  notify = function(){
	    Promise.resolve().then(flush);
	  };
	// for other environments - macrotask based on:
	// - setImmediate
	// - MessageChannel
	// - window.postMessag
	// - onreadystatechange
	// - setTimeout
	} else {
	  notify = function(){
	    // strange IE + webpack dev server bug - use .call(global)
	    macrotask.call(global, flush);
	  };
	}
	
	module.exports = function(fn){
	  var task = {fn: fn, next: undefined};
	  if(last)last.next = task;
	  if(!head){
	    head = task;
	    notify();
	  } last = task;
	};

/***/ },
/* 96 */
/*!********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_redefine-all.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(/*! ./_hide */ 16);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 97 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_set-species.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(/*! ./_global */ 12)
	  , core        = __webpack_require__(/*! ./_core */ 13)
	  , dP          = __webpack_require__(/*! ./_object-dp */ 17)
	  , DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ 21)
	  , SPECIES     = __webpack_require__(/*! ./_wks */ 46)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 98 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/helpers/slicedToArray.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(/*! babel-runtime/core-js/is-iterable */ 99);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 102);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 99 */
/*!************************************************!*\
  !*** ./~/babel-runtime/core-js/is-iterable.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/is-iterable */ 100), __esModule: true };

/***/ },
/* 100 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/is-iterable.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/web.dom.iterable */ 83);
	__webpack_require__(/*! ../modules/es6.string.iterator */ 5);
	module.exports = __webpack_require__(/*! ../modules/core.is-iterable */ 101);

/***/ },
/* 101 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/core.is-iterable.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(/*! ./_classof */ 54)
	  , ITERATOR  = __webpack_require__(/*! ./_wks */ 46)('iterator')
	  , Iterators = __webpack_require__(/*! ./_iterators */ 28);
	module.exports = __webpack_require__(/*! ./_core */ 13).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 102 */
/*!*************************************************!*\
  !*** ./~/babel-runtime/core-js/get-iterator.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/get-iterator */ 103), __esModule: true };

/***/ },
/* 103 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/get-iterator.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/web.dom.iterable */ 83);
	__webpack_require__(/*! ../modules/es6.string.iterator */ 5);
	module.exports = __webpack_require__(/*! ../modules/core.get-iterator */ 104);

/***/ },
/* 104 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/core.get-iterator.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(/*! ./_an-object */ 18)
	  , get      = __webpack_require__(/*! ./core.get-iterator-method */ 53);
	module.exports = __webpack_require__(/*! ./_core */ 13).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 105 */
/*!*****************************!*\
  !*** ./~/rsvp/dist/rsvp.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(process, setImmediate, global, module) {/*!
	 * @overview RSVP - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$rsvp$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$rsvp$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$rsvp$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$rsvp$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$rsvp$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$rsvp$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;
	
	    var lib$rsvp$utils$$now = Date.now || function() { return new Date().getTime(); };
	
	    function lib$rsvp$utils$$F() { }
	
	    var lib$rsvp$utils$$o_create = (Object.create || function (o) {
	      if (arguments.length > 1) {
	        throw new Error('Second argument not supported');
	      }
	      if (typeof o !== 'object') {
	        throw new TypeError('Argument must be an object');
	      }
	      lib$rsvp$utils$$F.prototype = o;
	      return new lib$rsvp$utils$$F();
	    });
	    function lib$rsvp$events$$indexOf(callbacks, callback) {
	      for (var i=0, l=callbacks.length; i<l; i++) {
	        if (callbacks[i] === callback) { return i; }
	      }
	
	      return -1;
	    }
	
	    function lib$rsvp$events$$callbacksFor(object) {
	      var callbacks = object._promiseCallbacks;
	
	      if (!callbacks) {
	        callbacks = object._promiseCallbacks = {};
	      }
	
	      return callbacks;
	    }
	
	    var lib$rsvp$events$$default = {
	
	      /**
	        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For
	        Example:
	
	        ```javascript
	        var object = {};
	
	        RSVP.EventTarget.mixin(object);
	
	        object.on('finished', function(event) {
	          // handle event
	        });
	
	        object.trigger('finished', { detail: value });
	        ```
	
	        `EventTarget.mixin` also works with prototypes:
	
	        ```javascript
	        var Person = function() {};
	        RSVP.EventTarget.mixin(Person.prototype);
	
	        var yehuda = new Person();
	        var tom = new Person();
	
	        yehuda.on('poke', function(event) {
	          console.log('Yehuda says OW');
	        });
	
	        tom.on('poke', function(event) {
	          console.log('Tom says OW');
	        });
	
	        yehuda.trigger('poke');
	        tom.trigger('poke');
	        ```
	
	        @method mixin
	        @for RSVP.EventTarget
	        @private
	        @param {Object} object object to extend with EventTarget methods
	      */
	      'mixin': function(object) {
	        object['on']      = this['on'];
	        object['off']     = this['off'];
	        object['trigger'] = this['trigger'];
	        object._promiseCallbacks = undefined;
	        return object;
	      },
	
	      /**
	        Registers a callback to be executed when `eventName` is triggered
	
	        ```javascript
	        object.on('event', function(eventInfo){
	          // handle the event
	        });
	
	        object.trigger('event');
	        ```
	
	        @method on
	        @for RSVP.EventTarget
	        @private
	        @param {String} eventName name of the event to listen for
	        @param {Function} callback function to be called when the event is triggered.
	      */
	      'on': function(eventName, callback) {
	        if (typeof callback !== 'function') {
	          throw new TypeError('Callback must be a function');
	        }
	
	        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks;
	
	        callbacks = allCallbacks[eventName];
	
	        if (!callbacks) {
	          callbacks = allCallbacks[eventName] = [];
	        }
	
	        if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {
	          callbacks.push(callback);
	        }
	      },
	
	      /**
	        You can use `off` to stop firing a particular callback for an event:
	
	        ```javascript
	        function doStuff() { // do stuff! }
	        object.on('stuff', doStuff);
	
	        object.trigger('stuff'); // doStuff will be called
	
	        // Unregister ONLY the doStuff callback
	        object.off('stuff', doStuff);
	        object.trigger('stuff'); // doStuff will NOT be called
	        ```
	
	        If you don't pass a `callback` argument to `off`, ALL callbacks for the
	        event will not be executed when the event fires. For example:
	
	        ```javascript
	        var callback1 = function(){};
	        var callback2 = function(){};
	
	        object.on('stuff', callback1);
	        object.on('stuff', callback2);
	
	        object.trigger('stuff'); // callback1 and callback2 will be executed.
	
	        object.off('stuff');
	        object.trigger('stuff'); // callback1 and callback2 will not be executed!
	        ```
	
	        @method off
	        @for RSVP.EventTarget
	        @private
	        @param {String} eventName event to stop listening to
	        @param {Function} callback optional argument. If given, only the function
	        given will be removed from the event's callback queue. If no `callback`
	        argument is given, all callbacks will be removed from the event's callback
	        queue.
	      */
	      'off': function(eventName, callback) {
	        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, index;
	
	        if (!callback) {
	          allCallbacks[eventName] = [];
	          return;
	        }
	
	        callbacks = allCallbacks[eventName];
	
	        index = lib$rsvp$events$$indexOf(callbacks, callback);
	
	        if (index !== -1) { callbacks.splice(index, 1); }
	      },
	
	      /**
	        Use `trigger` to fire custom events. For example:
	
	        ```javascript
	        object.on('foo', function(){
	          console.log('foo event happened!');
	        });
	        object.trigger('foo');
	        // 'foo event happened!' logged to the console
	        ```
	
	        You can also pass a value as a second argument to `trigger` that will be
	        passed as an argument to all event listeners for the event:
	
	        ```javascript
	        object.on('foo', function(value){
	          console.log(value.name);
	        });
	
	        object.trigger('foo', { name: 'bar' });
	        // 'bar' logged to the console
	        ```
	
	        @method trigger
	        @for RSVP.EventTarget
	        @private
	        @param {String} eventName name of the event to be triggered
	        @param {*} options optional value to be passed to any event handlers for
	        the given `eventName`
	      */
	      'trigger': function(eventName, options, label) {
	        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, callback;
	
	        if (callbacks = allCallbacks[eventName]) {
	          // Don't cache the callbacks.length since it may grow
	          for (var i=0; i<callbacks.length; i++) {
	            callback = callbacks[i];
	
	            callback(options, label);
	          }
	        }
	      }
	    };
	
	    var lib$rsvp$config$$config = {
	      instrument: false
	    };
	
	    lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);
	
	    function lib$rsvp$config$$configure(name, value) {
	      if (name === 'onerror') {
	        // handle for legacy users that expect the actual
	        // error to be passed to their function added via
	        // `RSVP.configure('onerror', someFunctionHere);`
	        lib$rsvp$config$$config['on']('error', value);
	        return;
	      }
	
	      if (arguments.length === 2) {
	        lib$rsvp$config$$config[name] = value;
	      } else {
	        return lib$rsvp$config$$config[name];
	      }
	    }
	
	    var lib$rsvp$instrument$$queue = [];
	
	    function lib$rsvp$instrument$$scheduleFlush() {
	      setTimeout(function() {
	        var entry;
	        for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {
	          entry = lib$rsvp$instrument$$queue[i];
	
	          var payload = entry.payload;
	
	          payload.guid = payload.key + payload.id;
	          payload.childGuid = payload.key + payload.childId;
	          if (payload.error) {
	            payload.stack = payload.error.stack;
	          }
	
	          lib$rsvp$config$$config['trigger'](entry.name, entry.payload);
	        }
	        lib$rsvp$instrument$$queue.length = 0;
	      }, 50);
	    }
	
	    function lib$rsvp$instrument$$instrument(eventName, promise, child) {
	      if (1 === lib$rsvp$instrument$$queue.push({
	        name: eventName,
	        payload: {
	          key: promise._guidKey,
	          id:  promise._id,
	          eventName: eventName,
	          detail: promise._result,
	          childId: child && child._id,
	          label: promise._label,
	          timeStamp: lib$rsvp$utils$$now(),
	          error: lib$rsvp$config$$config["instrument-with-stack"] ? new Error(promise._label) : null
	        }})) {
	          lib$rsvp$instrument$$scheduleFlush();
	        }
	      }
	    var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;
	    function lib$rsvp$then$$then(onFulfillment, onRejection, label) {
	      var parent = this;
	      var state = parent._state;
	
	      if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {
	        lib$rsvp$config$$config.instrument && lib$rsvp$instrument$$default('chained', parent, parent);
	        return parent;
	      }
	
	      parent._onError = null;
	
	      var child = new parent.constructor(lib$rsvp$$internal$$noop, label);
	      var result = parent._result;
	
	      lib$rsvp$config$$config.instrument && lib$rsvp$instrument$$default('chained', parent, child);
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$rsvp$config$$config.async(function(){
	          lib$rsvp$$internal$$invokeCallback(state, child, callback, result);
	        });
	      } else {
	        lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$rsvp$then$$default = lib$rsvp$then$$then;
	    function lib$rsvp$promise$resolve$$resolve(object, label) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
	      lib$rsvp$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;
	    function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {
	      if (state === lib$rsvp$$internal$$FULFILLED) {
	        return {
	          state: 'fulfilled',
	          value: value
	        };
	      } else {
	         return {
	          state: 'rejected',
	          reason: value
	        };
	      }
	    }
	
	    function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$rsvp$$internal$$noop, label);
	      this._abortOnReject = abortOnReject;
	
	      if (this._validateInput(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._init();
	
	        if (this.length === 0) {
	          lib$rsvp$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$rsvp$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$rsvp$$internal$$reject(this.promise, this._validationError());
	      }
	    }
	
	    var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;
	
	    lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {
	      return lib$rsvp$utils$$isArray(input);
	    };
	
	    lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {
	      return new Error('Array Methods must be provided an Array');
	    };
	
	    lib$rsvp$enumerator$$Enumerator.prototype._init = function() {
	      this._result = new Array(this.length);
	    };
	
	    lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length     = this.length;
	      var promise    = this.promise;
	      var input      = this._input;
	
	      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$rsvp$enumerator$$Enumerator.prototype._settleMaybeThenable = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$rsvp$promise$resolve$$default) {
	        var then = lib$rsvp$$internal$$getThen(entry);
	
	        if (then === lib$rsvp$then$$default &&
	            entry._state !== lib$rsvp$$internal$$PENDING) {
	          entry._onError = null;
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = this._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);
	        } else if (c === lib$rsvp$promise$$default) {
	          var promise = new c(lib$rsvp$$internal$$noop);
	          lib$rsvp$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      if (lib$rsvp$utils$$isMaybeThenable(entry)) {
	        this._settleMaybeThenable(entry, i);
	      } else {
	        this._remaining--;
	        this._result[i] = this._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);
	      }
	    };
	
	    lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$rsvp$$internal$$PENDING) {
	        this._remaining--;
	
	        if (this._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {
	          lib$rsvp$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = this._makeResult(state, i, value);
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$rsvp$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
	      return value;
	    };
	
	    lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$rsvp$promise$all$$all(entries, label) {
	      return new lib$rsvp$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
	    }
	    var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;
	    function lib$rsvp$promise$race$$race(entries, label) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
	
	      if (!lib$rsvp$utils$$isArray(entries)) {
	        lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
	        return promise;
	      }
	
	      var length = entries.length;
	
	      function onFulfillment(value) {
	        lib$rsvp$$internal$$resolve(promise, value);
	      }
	
	      function onRejection(reason) {
	        lib$rsvp$$internal$$reject(promise, reason);
	      }
	
	      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
	        lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
	      }
	
	      return promise;
	    }
	    var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;
	    function lib$rsvp$promise$reject$$reject(reason, label) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
	      lib$rsvp$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;
	
	    var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';
	    var lib$rsvp$promise$$counter = 0;
	
	    function lib$rsvp$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$rsvp$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    function lib$rsvp$promise$$Promise(resolver, label) {
	      this._id = lib$rsvp$promise$$counter++;
	      this._label = label;
	      this._state = undefined;
	      this._result = undefined;
	      this._subscribers = [];
	
	      lib$rsvp$config$$config.instrument && lib$rsvp$instrument$$default('created', this);
	
	      if (lib$rsvp$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$rsvp$promise$$needsResolver();
	        this instanceof lib$rsvp$promise$$Promise ? lib$rsvp$$internal$$initializePromise(this, resolver) : lib$rsvp$promise$$needsNew();
	      }
	    }
	
	    var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;
	
	    // deprecated
	    lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;
	    lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;
	    lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;
	    lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;
	    lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;
	
	    lib$rsvp$promise$$Promise.prototype = {
	      constructor: lib$rsvp$promise$$Promise,
	
	      _guidKey: lib$rsvp$promise$$guidKey,
	
	      _onError: function (reason) {
	        var promise = this;
	        lib$rsvp$config$$config.after(function() {
	          if (promise._onError) {
	            lib$rsvp$config$$config['trigger']('error', reason, promise._label);
	          }
	        });
	      },
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfillment
	      @param {Function} onRejection
	      @param {String} label optional string for labeling the promise.
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$rsvp$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      @param {String} label optional string for labeling the promise.
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection, label) {
	        return this.then(undefined, onRejection, label);
	      },
	
	    /**
	      `finally` will be invoked regardless of the promise's fate just as native
	      try/catch/finally behaves
	
	      Synchronous example:
	
	      ```js
	      findAuthor() {
	        if (Math.random() > 0.5) {
	          throw new Error();
	        }
	        return new Author();
	      }
	
	      try {
	        return findAuthor(); // succeed or fail
	      } catch(error) {
	        return findOtherAuther();
	      } finally {
	        // always runs
	        // doesn't affect the return value
	      }
	      ```
	
	      Asynchronous example:
	
	      ```js
	      findAuthor().catch(function(reason){
	        return findOtherAuther();
	      }).finally(function(){
	        // author was either found, or not
	      });
	      ```
	
	      @method finally
	      @param {Function} callback
	      @param {String} label optional string for labeling the promise.
	      Useful for tooling.
	      @return {Promise}
	    */
	      'finally': function(callback, label) {
	        var promise = this;
	        var constructor = promise.constructor;
	
	        return promise.then(function(value) {
	          return constructor.resolve(callback()).then(function() {
	            return value;
	          });
	        }, function(reason) {
	          return constructor.resolve(callback()).then(function() {
	            return constructor.reject(reason);
	          });
	        }, label);
	      }
	    };
	    function  lib$rsvp$$internal$$withOwnPromise() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$rsvp$$internal$$noop() {}
	
	    var lib$rsvp$$internal$$PENDING   = void 0;
	    var lib$rsvp$$internal$$FULFILLED = 1;
	    var lib$rsvp$$internal$$REJECTED  = 2;
	
	    var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();
	
	    function lib$rsvp$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$rsvp$$internal$$GET_THEN_ERROR.error = error;
	        return lib$rsvp$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {
	      lib$rsvp$config$$config.async(function(promise) {
	        var sealed = false;
	        var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$rsvp$$internal$$resolve(promise, value, undefined);
	          } else {
	            lib$rsvp$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$rsvp$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$rsvp$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$rsvp$$internal$$FULFILLED) {
	        lib$rsvp$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {
	        thenable._onError = null;
	        lib$rsvp$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {
	          if (thenable !== value) {
	            lib$rsvp$$internal$$resolve(promise, value, undefined);
	          } else {
	            lib$rsvp$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          lib$rsvp$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$rsvp$then$$default &&
	          constructor.resolve === lib$rsvp$promise$resolve$$default) {
	        lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {
	          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$rsvp$utils$$isFunction(then)) {
	          lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$rsvp$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$rsvp$$internal$$fulfill(promise, value);
	      } else if (lib$rsvp$utils$$objectOrFunction(value)) {
	        lib$rsvp$$internal$$handleMaybeThenable(promise, value, lib$rsvp$$internal$$getThen(value));
	      } else {
	        lib$rsvp$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$rsvp$$internal$$publishRejection(promise) {
	      if (promise._onError) {
	        promise._onError(promise._result);
	      }
	
	      lib$rsvp$$internal$$publish(promise);
	    }
	
	    function lib$rsvp$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$rsvp$$internal$$FULFILLED;
	
	      if (promise._subscribers.length === 0) {
	        if (lib$rsvp$config$$config.instrument) {
	          lib$rsvp$instrument$$default('fulfilled', promise);
	        }
	      } else {
	        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);
	      }
	    }
	
	    function lib$rsvp$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }
	      promise._state = lib$rsvp$$internal$$REJECTED;
	      promise._result = reason;
	      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);
	    }
	
	    function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onError = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$rsvp$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);
	      }
	    }
	
	    function lib$rsvp$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (lib$rsvp$config$$config.instrument) {
	        lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);
	      }
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$rsvp$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();
	
	    function lib$rsvp$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$rsvp$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$rsvp$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$rsvp$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$rsvp$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$rsvp$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$rsvp$$internal$$reject(promise, error);
	      } else if (settled === lib$rsvp$$internal$$FULFILLED) {
	        lib$rsvp$$internal$$fulfill(promise, value);
	      } else if (settled === lib$rsvp$$internal$$REJECTED) {
	        lib$rsvp$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$rsvp$$internal$$initializePromise(promise, resolver) {
	      var resolved = false;
	      try {
	        resolver(function resolvePromise(value){
	          if (resolved) { return; }
	          resolved = true;
	          lib$rsvp$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          if (resolved) { return; }
	          resolved = true;
	          lib$rsvp$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$rsvp$$internal$$reject(promise, e);
	      }
	    }
	
	    function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {
	      this._superConstructor(Constructor, entries, false /* don't abort on reject */, label);
	    }
	
	    lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
	    lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
	    lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;
	    lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {
	      return new Error('allSettled must be called with an array');
	    };
	
	    function lib$rsvp$all$settled$$allSettled(entries, label) {
	      return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;
	    }
	    var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;
	    function lib$rsvp$all$$all(array, label) {
	      return lib$rsvp$promise$$default.all(array, label);
	    }
	    var lib$rsvp$all$$default = lib$rsvp$all$$all;
	    var lib$rsvp$asap$$len = 0;
	    var lib$rsvp$asap$$toString = {}.toString;
	    var lib$rsvp$asap$$vertxNext;
	    function lib$rsvp$asap$$asap(callback, arg) {
	      lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;
	      lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;
	      lib$rsvp$asap$$len += 2;
	      if (lib$rsvp$asap$$len === 2) {
	        // If len is 1, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        lib$rsvp$asap$$scheduleFlush();
	      }
	    }
	
	    var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;
	
	    var lib$rsvp$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};
	    var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$rsvp$asap$$isNode = typeof self === 'undefined' &&
	      typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$rsvp$asap$$useNextTick() {
	      var nextTick = process.nextTick;
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // setImmediate should be used instead instead
	      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
	      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
	        nextTick = setImmediate;
	      }
	      return function() {
	        nextTick(lib$rsvp$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$rsvp$asap$$useVertxTimer() {
	      return function() {
	        lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);
	      };
	    }
	
	    function lib$rsvp$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$rsvp$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$rsvp$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$rsvp$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$rsvp$asap$$flush, 1);
	      };
	    }
	
	    var lib$rsvp$asap$$queue = new Array(1000);
	    function lib$rsvp$asap$$flush() {
	      for (var i = 0; i < lib$rsvp$asap$$len; i+=2) {
	        var callback = lib$rsvp$asap$$queue[i];
	        var arg = lib$rsvp$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$rsvp$asap$$queue[i] = undefined;
	        lib$rsvp$asap$$queue[i+1] = undefined;
	      }
	
	      lib$rsvp$asap$$len = 0;
	    }
	
	    function lib$rsvp$asap$$attemptVertex() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(/*! vertx */ 109);
	        lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$rsvp$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$rsvp$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$rsvp$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$rsvp$asap$$isNode) {
	      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();
	    } else if (lib$rsvp$asap$$BrowserMutationObserver) {
	      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();
	    } else if (lib$rsvp$asap$$isWorker) {
	      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();
	    } else if (lib$rsvp$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();
	    } else {
	      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();
	    }
	    function lib$rsvp$defer$$defer(label) {
	      var deferred = {};
	
	      deferred['promise'] = new lib$rsvp$promise$$default(function(resolve, reject) {
	        deferred['resolve'] = resolve;
	        deferred['reject'] = reject;
	      }, label);
	
	      return deferred;
	    }
	    var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;
	    function lib$rsvp$filter$$filter(promises, filterFn, label) {
	      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
	        if (!lib$rsvp$utils$$isFunction(filterFn)) {
	          throw new TypeError("You must pass a function as filter's second argument.");
	        }
	
	        var length = values.length;
	        var filtered = new Array(length);
	
	        for (var i = 0; i < length; i++) {
	          filtered[i] = filterFn(values[i]);
	        }
	
	        return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {
	          var results = new Array(length);
	          var newLength = 0;
	
	          for (var i = 0; i < length; i++) {
	            if (filtered[i]) {
	              results[newLength] = values[i];
	              newLength++;
	            }
	          }
	
	          results.length = newLength;
	
	          return results;
	        });
	      });
	    }
	    var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;
	
	    function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {
	      this._superConstructor(Constructor, object, true, label);
	    }
	
	    var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;
	
	    lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
	    lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;
	    lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {
	      this._result = {};
	    };
	
	    lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {
	      return input && typeof input === 'object';
	    };
	
	    lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {
	      return new Error('Promise.hash must be called with an object');
	    };
	
	    lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {
	      var enumerator = this;
	      var promise    = enumerator.promise;
	      var input      = enumerator._input;
	      var results    = [];
	
	      for (var key in input) {
	        if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {
	          results.push({
	            position: key,
	            entry: input[key]
	          });
	        }
	      }
	
	      var length = results.length;
	      enumerator._remaining = length;
	      var result;
	
	      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
	        result = results[i];
	        enumerator._eachEntry(result.entry, result.position);
	      }
	    };
	
	    function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {
	      this._superConstructor(Constructor, object, false, label);
	    }
	
	    lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);
	    lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
	    lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;
	
	    lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {
	      return new Error('hashSettled must be called with an object');
	    };
	
	    function lib$rsvp$hash$settled$$hashSettled(object, label) {
	      return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;
	    }
	    var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;
	    function lib$rsvp$hash$$hash(object, label) {
	      return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;
	    }
	    var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;
	    function lib$rsvp$map$$map(promises, mapFn, label) {
	      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
	        if (!lib$rsvp$utils$$isFunction(mapFn)) {
	          throw new TypeError("You must pass a function as map's second argument.");
	        }
	
	        var length = values.length;
	        var results = new Array(length);
	
	        for (var i = 0; i < length; i++) {
	          results[i] = mapFn(values[i]);
	        }
	
	        return lib$rsvp$promise$$default.all(results, label);
	      });
	    }
	    var lib$rsvp$map$$default = lib$rsvp$map$$map;
	
	    function lib$rsvp$node$$Result() {
	      this.value = undefined;
	    }
	
	    var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();
	    var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();
	
	    function lib$rsvp$node$$getThen(obj) {
	      try {
	       return obj.then;
	      } catch(error) {
	        lib$rsvp$node$$ERROR.value= error;
	        return lib$rsvp$node$$ERROR;
	      }
	    }
	
	
	    function lib$rsvp$node$$tryApply(f, s, a) {
	      try {
	        f.apply(s, a);
	      } catch(error) {
	        lib$rsvp$node$$ERROR.value = error;
	        return lib$rsvp$node$$ERROR;
	      }
	    }
	
	    function lib$rsvp$node$$makeObject(_, argumentNames) {
	      var obj = {};
	      var name;
	      var i;
	      var length = _.length;
	      var args = new Array(length);
	
	      for (var x = 0; x < length; x++) {
	        args[x] = _[x];
	      }
	
	      for (i = 0; i < argumentNames.length; i++) {
	        name = argumentNames[i];
	        obj[name] = args[i + 1];
	      }
	
	      return obj;
	    }
	
	    function lib$rsvp$node$$arrayResult(_) {
	      var length = _.length;
	      var args = new Array(length - 1);
	
	      for (var i = 1; i < length; i++) {
	        args[i - 1] = _[i];
	      }
	
	      return args;
	    }
	
	    function lib$rsvp$node$$wrapThenable(then, promise) {
	      return {
	        then: function(onFulFillment, onRejection) {
	          return then.call(promise, onFulFillment, onRejection);
	        }
	      };
	    }
	
	    function lib$rsvp$node$$denodeify(nodeFunc, options) {
	      var fn = function() {
	        var self = this;
	        var l = arguments.length;
	        var args = new Array(l + 1);
	        var arg;
	        var promiseInput = false;
	
	        for (var i = 0; i < l; ++i) {
	          arg = arguments[i];
	
	          if (!promiseInput) {
	            // TODO: clean this up
	            promiseInput = lib$rsvp$node$$needsPromiseInput(arg);
	            if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {
	              var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);
	              lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);
	              return p;
	            } else if (promiseInput && promiseInput !== true) {
	              arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);
	            }
	          }
	          args[i] = arg;
	        }
	
	        var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);
	
	        args[l] = function(err, val) {
	          if (err)
	            lib$rsvp$$internal$$reject(promise, err);
	          else if (options === undefined)
	            lib$rsvp$$internal$$resolve(promise, val);
	          else if (options === true)
	            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));
	          else if (lib$rsvp$utils$$isArray(options))
	            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));
	          else
	            lib$rsvp$$internal$$resolve(promise, val);
	        };
	
	        if (promiseInput) {
	          return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);
	        } else {
	          return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);
	        }
	      };
	
	      fn.__proto__ = nodeFunc;
	
	      return fn;
	    }
	
	    var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;
	
	    function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {
	      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
	      if (result === lib$rsvp$node$$ERROR) {
	        lib$rsvp$$internal$$reject(promise, result.value);
	      }
	      return promise;
	    }
	
	    function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){
	      return lib$rsvp$promise$$default.all(args).then(function(args){
	        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
	        if (result === lib$rsvp$node$$ERROR) {
	          lib$rsvp$$internal$$reject(promise, result.value);
	        }
	        return promise;
	      });
	    }
	
	    function lib$rsvp$node$$needsPromiseInput(arg) {
	      if (arg && typeof arg === 'object') {
	        if (arg.constructor === lib$rsvp$promise$$default) {
	          return true;
	        } else {
	          return lib$rsvp$node$$getThen(arg);
	        }
	      } else {
	        return false;
	      }
	    }
	    var lib$rsvp$platform$$platform;
	
	    /* global self */
	    if (typeof self === 'object') {
	      lib$rsvp$platform$$platform = self;
	
	    /* global global */
	    } else if (typeof global === 'object') {
	      lib$rsvp$platform$$platform = global;
	    } else {
	      throw new Error('no global: `self` or `global` found');
	    }
	
	    var lib$rsvp$platform$$default = lib$rsvp$platform$$platform;
	    function lib$rsvp$race$$race(array, label) {
	      return lib$rsvp$promise$$default.race(array, label);
	    }
	    var lib$rsvp$race$$default = lib$rsvp$race$$race;
	    function lib$rsvp$reject$$reject(reason, label) {
	      return lib$rsvp$promise$$default.reject(reason, label);
	    }
	    var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;
	    function lib$rsvp$resolve$$resolve(value, label) {
	      return lib$rsvp$promise$$default.resolve(value, label);
	    }
	    var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;
	    function lib$rsvp$rethrow$$rethrow(reason) {
	      setTimeout(function() {
	        throw reason;
	      });
	      throw reason;
	    }
	    var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;
	
	    // defaults
	    lib$rsvp$config$$config.async = lib$rsvp$asap$$default;
	    lib$rsvp$config$$config.after = function(cb) {
	      setTimeout(cb, 0);
	    };
	    var lib$rsvp$$cast = lib$rsvp$resolve$$default;
	    function lib$rsvp$$async(callback, arg) {
	      lib$rsvp$config$$config.async(callback, arg);
	    }
	
	    function lib$rsvp$$on() {
	      lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);
	    }
	
	    function lib$rsvp$$off() {
	      lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);
	    }
	
	    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
	    if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
	      var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];
	      lib$rsvp$config$$configure('instrument', true);
	      for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {
	        if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {
	          lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);
	        }
	      }
	    }
	
	    var lib$rsvp$umd$$RSVP = {
	      'race': lib$rsvp$race$$default,
	      'Promise': lib$rsvp$promise$$default,
	      'allSettled': lib$rsvp$all$settled$$default,
	      'hash': lib$rsvp$hash$$default,
	      'hashSettled': lib$rsvp$hash$settled$$default,
	      'denodeify': lib$rsvp$node$$default,
	      'on': lib$rsvp$$on,
	      'off': lib$rsvp$$off,
	      'map': lib$rsvp$map$$default,
	      'filter': lib$rsvp$filter$$default,
	      'resolve': lib$rsvp$resolve$$default,
	      'reject': lib$rsvp$reject$$default,
	      'all': lib$rsvp$all$$default,
	      'rethrow': lib$rsvp$rethrow$$default,
	      'defer': lib$rsvp$defer$$default,
	      'EventTarget': lib$rsvp$events$$default,
	      'configure': lib$rsvp$config$$configure,
	      'async': lib$rsvp$$async
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(/*! !webpack amd define */ 110)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$rsvp$umd$$RSVP; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$rsvp$umd$$RSVP;
	    } else if (typeof lib$rsvp$platform$$default !== 'undefined') {
	      lib$rsvp$platform$$default['RSVP'] = lib$rsvp$umd$$RSVP;
	    }
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 106), __webpack_require__(/*! (webpack)/~/node-libs-browser/~/timers-browserify/main.js */ 107).setImmediate, (function() { return this; }()), __webpack_require__(/*! ./../../webpack/buildin/module.js */ 108)(module)))

/***/ },
/* 106 */
/*!**********************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/process/browser.js ***!
  \**********************************************************/
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 107 */
/*!*****************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/timers-browserify/main.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(/*! process/browser.js */ 106).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/timers-browserify/main.js */ 107).setImmediate, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/timers-browserify/main.js */ 107).clearImmediate))

/***/ },
/* 108 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 109 */
/*!***********************!*\
  !*** vertx (ignored) ***!
  \***********************/
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 110 */
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 111 */,
/* 112 */
/*!***************************************!*\
  !*** ./src/store/clientMiddleware.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = promiseMiddleware;
	
	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 113);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _isPromise = __webpack_require__(/*! ./isPromise */ 114);
	
	var _isPromise2 = _interopRequireDefault(_isPromise);
	
	var _isPlainObject = __webpack_require__(/*! ./isPlainObject */ 127);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PENDING = 'PENDING';
	var FULFILLED = 'FULFILLED';
	var REJECTED = 'REJECTED';
	
	function isAction(action) {
	  return (0, _isPlainObject2.default)(action) && typeof action.type !== 'undefined';
	}
	
	function promiseMiddleware(store) {
	  var dispatch = store.dispatch;
	
	  return function (next) {
	    return function (action) {
	      if (typeof action === 'function') return action(store);
	
	      if (!isAction(action) || !(0, _isPromise2.default)(action.payload) || action.error) {
	        return next(action);
	      }
	
	      var type = action.type;
	      var payload = action.payload;
	      var meta = action.meta;
	
	      dispatch((0, _extends3.default)({
	        type: type + '_' + PENDING
	      }, meta && { meta: meta }));
	
	      return payload.then(function (result) {
	        return dispatch((0, _extends3.default)({ type: type + '_' + FULFILLED, payload: result }, meta && { meta: meta }));
	      }, function (error) {
	        return dispatch((0, _extends3.default)({ type: type + '_' + REJECTED, payload: payload, error: error }, meta && { meta: meta }));
	      });
	    };
	  };
	};

/***/ },
/* 113 */
/*!********************************************!*\
  !*** ./~/babel-runtime/helpers/extends.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};

/***/ },
/* 114 */
/*!********************************!*\
  !*** ./src/store/isPromise.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isPromise;
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function isPromise(value) {
	  if (value !== null && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object') {
	    return typeof value.then === 'function';
	  }
	}

/***/ },
/* 115 */
/*!*******************************************!*\
  !*** ./~/babel-runtime/helpers/typeof.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(/*! babel-runtime/core-js/symbol/iterator */ 116);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(/*! babel-runtime/core-js/symbol */ 118);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 116 */
/*!****************************************************!*\
  !*** ./~/babel-runtime/core-js/symbol/iterator.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/iterator */ 117), __esModule: true };

/***/ },
/* 117 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/symbol/iterator.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.string.iterator */ 5);
	__webpack_require__(/*! ../../modules/web.dom.iterable */ 83);
	module.exports = __webpack_require__(/*! ../../modules/_wks */ 46)('iterator');

/***/ },
/* 118 */
/*!*******************************************!*\
  !*** ./~/babel-runtime/core-js/symbol.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol */ 119), __esModule: true };

/***/ },
/* 119 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/symbol/index.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.symbol */ 120);
	__webpack_require__(/*! ../../modules/es6.object.to-string */ 82);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Symbol;

/***/ },
/* 120 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.symbol.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(/*! ./_global */ 12)
	  , core           = __webpack_require__(/*! ./_core */ 13)
	  , has            = __webpack_require__(/*! ./_has */ 27)
	  , DESCRIPTORS    = __webpack_require__(/*! ./_descriptors */ 21)
	  , $export        = __webpack_require__(/*! ./_export */ 11)
	  , redefine       = __webpack_require__(/*! ./_redefine */ 26)
	  , META           = __webpack_require__(/*! ./_meta */ 121).KEY
	  , $fails         = __webpack_require__(/*! ./_fails */ 22)
	  , shared         = __webpack_require__(/*! ./_shared */ 41)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 45)
	  , uid            = __webpack_require__(/*! ./_uid */ 42)
	  , wks            = __webpack_require__(/*! ./_wks */ 46)
	  , keyOf          = __webpack_require__(/*! ./_keyof */ 122)
	  , enumKeys       = __webpack_require__(/*! ./_enum-keys */ 123)
	  , isArray        = __webpack_require__(/*! ./_is-array */ 124)
	  , anObject       = __webpack_require__(/*! ./_an-object */ 18)
	  , toIObject      = __webpack_require__(/*! ./_to-iobject */ 34)
	  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ 24)
	  , createDesc     = __webpack_require__(/*! ./_property-desc */ 25)
	  , _create        = __webpack_require__(/*! ./_object-create */ 30)
	  , gOPNExt        = __webpack_require__(/*! ./_object-gopn-ext */ 125)
	  , $GOPD          = __webpack_require__(/*! ./_object-gopd */ 91)
	  , $DP            = __webpack_require__(/*! ./_object-dp */ 17)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , setter         = false
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
	    configurable: true,
	    set: function(value){
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    }
	  });
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = gOPD(it = toIObject(it), key = toPrimitive(key, true));
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	var $stringify = function stringify(it){
	  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	  var args = [it]
	    , i    = 1
	    , replacer, $replacer;
	  while(arguments.length > i)args.push(arguments[i++]);
	  replacer = args[1];
	  if(typeof replacer == 'function')$replacer = replacer;
	  if($replacer || !isArray(replacer))replacer = function(key, value){
	    if($replacer)value = $replacer.call(this, key, value);
	    if(!isSymbol(value))return value;
	  };
	  args[1] = replacer;
	  return _stringify.apply($JSON, args);
	};
	var BUGGY_JSON = $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	});
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(/*! ./_object-gopn */ 126).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(/*! ./_object-pie */ 61).f  = $propertyIsEnumerable
	  __webpack_require__(/*! ./_object-gops */ 60).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(/*! ./_library */ 10)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	// 19.4.2.2 Symbol.hasInstance
	// 19.4.2.3 Symbol.isConcatSpreadable
	// 19.4.2.4 Symbol.iterator
	// 19.4.2.6 Symbol.match
	// 19.4.2.8 Symbol.replace
	// 19.4.2.9 Symbol.search
	// 19.4.2.10 Symbol.species
	// 19.4.2.11 Symbol.split
	// 19.4.2.12 Symbol.toPrimitive
	// 19.4.2.13 Symbol.toStringTag
	// 19.4.2.14 Symbol.unscopables
	for(var symbols = (
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; ){
	  var key     = symbols[i++]
	    , Wrapper = core.Symbol
	    , sym     = wks(key);
	  if(!(key in Wrapper))dP(Wrapper, key, {value: USE_NATIVE ? sym : wrap(sym)});
	};
	
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	if(!QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild)setter = true;
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || BUGGY_JSON), 'JSON', {stringify: $stringify});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ 16)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 121 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_meta.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(/*! ./_uid */ 42)('meta')
	  , isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , has      = __webpack_require__(/*! ./_has */ 27)
	  , setDesc  = __webpack_require__(/*! ./_object-dp */ 17).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(/*! ./_fails */ 22)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 122 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_keyof.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(/*! ./_object-keys */ 32)
	  , toIObject = __webpack_require__(/*! ./_to-iobject */ 34);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 123 */
/*!*****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_enum-keys.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(/*! ./_object-keys */ 32)
	  , gOPS    = __webpack_require__(/*! ./_object-gops */ 60)
	  , pIE     = __webpack_require__(/*! ./_object-pie */ 61);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 124 */
/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_is-array.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(/*! ./_cof */ 36);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 125 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gopn-ext.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(/*! ./_to-iobject */ 34)
	  , gOPN      = __webpack_require__(/*! ./_object-gopn */ 126).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 126 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-gopn.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(/*! ./_object-keys-internal */ 33)
	  , hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ 43).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 127 */
/*!************************************!*\
  !*** ./src/store/isPlainObject.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isPlainObject;
	
	var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ 128);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var fnToString = function fnToString(fn) {
	  return Function.prototype.toString.call(fn);
	};
	var objStringValue = fnToString(Object);
	
	/**
	 * @param {any} obj The object to inspect.
	 * @returns {boolean} True if the argument appears to be a plain object.
	 */
	function isPlainObject(obj) {
	  if (!obj || (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) !== 'object') {
	    return false;
	  }
	
	  var proto = typeof obj.constructor === 'function' ? (0, _getPrototypeOf2.default)(obj) : Object.prototype;
	
	  if (proto === null) {
	    return true;
	  }
	
	  var constructor = proto.constructor;
	
	  return typeof constructor === 'function' && constructor instanceof constructor && fnToString(constructor) === objStringValue;
	}

/***/ },
/* 128 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/core-js/object/get-prototype-of.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-prototype-of */ 129), __esModule: true };

/***/ },
/* 129 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/get-prototype-of.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.get-prototype-of */ 130);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.getPrototypeOf;

/***/ },
/* 130 */
/*!**********************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.get-prototype-of.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(/*! ./_to-object */ 48)
	  , $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ 47);
	
	__webpack_require__(/*! ./_object-sap */ 131)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 131 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-sap.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(/*! ./_export */ 11)
	  , core    = __webpack_require__(/*! ./_core */ 13)
	  , fails   = __webpack_require__(/*! ./_fails */ 22);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 132 */
/*!**********************************!*\
  !*** ./src/modules/animation.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createReducer;
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setFrameTime = setFrameTime;
	exports.getTime = getTime;
	exports.setTime = setTime;
	exports.isPlaying = isPlaying;
	exports.startPlaying = startPlaying;
	exports.incrementTime = incrementTime;
	exports.stopPlaying = stopPlaying;
	exports.queueClip = queueClip;
	exports.queueAnimation = queueAnimation;
	exports.findAnimationIndex = findAnimationIndex;
	exports.removeAnimation = removeAnimation;
	exports.addClip = addClip;
	exports.getClips = getClips;
	exports.getTimelineAnimation = getTimelineAnimation;
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _cuid = __webpack_require__(/*! cuid */ 140);
	
	var _cuid2 = _interopRequireDefault(_cuid);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 141);
	
	var _createReducer3 = _interopRequireDefault(_createReducer2);
	
	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 142);
	
	var _tweenFunctions = __webpack_require__(/*! ./utils/tweenFunctions */ 263);
	
	var _tweenFunctions2 = _interopRequireDefault(_tweenFunctions);
	
	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 253);
	
	var _scene = __webpack_require__(/*! ./scene */ 147);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SET_TIME = 'SET_TIME';
	var SET_FRAME_TIME = 'SET_FRAME_TIME';
	var START_PLAYING = 'START_PLAYING';
	var STOP_PLAYING = 'STOP_PLAYING';
	var UPDATE_TRACK = 'UPDATE_TRACK';
	var UPDATE_ANIMATION = 'UPDATE_ANIMATION';
	var REMOVE_ANIMATION = 'REMOVE_ANIMATION';
	var QUEUE_ANIMATION = 'QUEUE_ANIMATION';
	var QUEUE_TIMELINE_ANIMATION = 'QUEUE_TIMELINE_ANIMATION';
	var ADD_CLIP = 'ADD_CLIP';
	
	/**
	 * Animation module.
	 *
	 * This module controls the animation happening. The properties of an
	 * animation are [defined here in the Animation type](global.html#Animation).
	 *
	 * Animations can be queued dynamically with [`queueAnimation`](module-animation.html#.queueAnimation)
	 * Or, to play existing clips, queue a clip for playing with [`queueClip`](module-animation.html#.queueClip).
	 *
	 * @module animation
	 * @public
	 *
	 */
	
	var initialState = (0, _immutable.Map)({
	  time: 0,
	  startTime: null,
	  playing: false,
	  autoplay: false,
	  frameTime: 0,
	  animations: (0, _immutable.List)(),
	  clips: (0, _immutable.Map)(),
	  timelineAnimationIndex: -1
	});
	
	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SET_TIME, function (state, _ref) {
	  var time = _ref.time;
	  var startTime = _ref.startTime;
	
	  return state.set('time', time).set('startTime', startTime);
	}), (0, _defineProperty3.default)(_createReducer, SET_FRAME_TIME, function (state, frameTime) {
	  var currentFrameTime = state.get('frameTime');
	  // Apply a smoothing moving average to frameTime
	  return state.set('frameTime', currentFrameTime + (frameTime - currentFrameTime) * 0.1);
	}), (0, _defineProperty3.default)(_createReducer, START_PLAYING, function (state, autoplay) {
	  return state.merge({ playing: true, autoplay: !!autoplay });
	}), (0, _defineProperty3.default)(_createReducer, STOP_PLAYING, function (state) {
	  return state.set('playing', false);
	}), (0, _defineProperty3.default)(_createReducer, UPDATE_TRACK, function (state, _ref2) {
	  var path = _ref2.path;
	  var attrs = _ref2.attrs;
	
	  var anim = state.getIn(['animations', path[0]]);
	  var track = anim && anim.tracks[path[1]];
	  if (track) (0, _assign2.default)(track, attrs);
	  return state;
	}), (0, _defineProperty3.default)(_createReducer, UPDATE_ANIMATION, function (state, _ref3) {
	  var index = _ref3.index;
	  var attrs = _ref3.attrs;
	
	  var anim = state.getIn(['animations', index]);
	  if (anim) (0, _assign2.default)(anim, attrs);
	  return state;
	}), (0, _defineProperty3.default)(_createReducer, REMOVE_ANIMATION, function (state, idx) {
	  var newState = state;
	  if (idx === state.get('timelineAnimationIndex')) newState = newState.set('timelineAnimationIndex', -1);
	  return newState.deleteIn(['animations', idx]);
	}), (0, _defineProperty3.default)(_createReducer, QUEUE_ANIMATION, function (state, animation) {
	  return state.updateIn(['animations'], (0, _immutable.List)(), function (list) {
	    return list.push(animation);
	  });
	}), (0, _defineProperty3.default)(_createReducer, QUEUE_TIMELINE_ANIMATION, function (state, animation) {
	  return state.set('timelineAnimationIndex', state.get('animations').size - 1);
	}), (0, _defineProperty3.default)(_createReducer, ADD_CLIP, function (state, _ref4) {
	  var clip = _ref4.clip;
	  var id = _ref4.id;
	
	  return state.setIn(['clips', id], (0, _immutable.Map)(clip).set('id', id));
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref5) {
	  var clips = _ref5.clips;
	
	  return clips ? state.mergeIn(['clips'], clips) : state;
	}), _createReducer));
	function setFrameTime(frameTime) {
	  return { type: SET_FRAME_TIME, payload: frameTime };
	};
	
	/**
	 * Return the current animation time.
	 * @returns {Number}
	 * @public
	 *
	 */
	function getTime(store) {
	  return store.getIn(['animation', 'time']);
	};
	
	/**
	 * Set the current animation time.
	 * @public
	 * @param {Number} time in seconds
	 */
	function setTime(time) {
	  return function (store) {
	    var startTime = new Date();
	    var delta = time - store.getIn(['animation', 'time']);
	
	    if (delta !== 0) {
	      if (store.getIn(['animation', 'animations']).size) {
	        store.getIn(['animation', 'animations']).forEach(function (anim, animIdx) {
	          updateAnimation(store, delta, time, anim, animIdx);
	        });
	      } else {
	        if (store.getIn(['animation', 'autoplay'])) {
	          store.dispatch(stopPlaying());
	        }
	      }
	    }
	    store.dispatch({ type: SET_TIME, payload: { time: time, startTime: startTime } });
	  };
	};
	
	function getKeyframeValueFor(t, keyframes, tween, currentValue) {
	  var vs = keyframes.vs;
	  var ts = keyframes.ts;
	
	  if (!ts.length) return currentValue;
	
	  var idx = (0, _ramda.findIndex)(function (kt) {
	    return t <= kt;
	  }, ts);
	  if (idx === -1) return vs[vs.length - 1];
	
	  // FIXME: Handle keyframe that hasn't started yet
	  if (idx === 0) return vs[0];
	
	  //console.log('tween?', frame1.v, frame2.v, frame2.t - frame1.t);
	  var v = tween(t - ts[idx - 1], vs[idx - 1], vs[idx], ts[idx] - ts[idx - 1]);
	  //console.log('getkeyframe value?', t, idx, v);
	  return v;
	}
	
	function getKeyframeValue(t, keyframes, tween, currentValue) {
	  //console.log('get keyframe value: ', t, keyframes, tween);
	  if (keyframes.ts) return getKeyframeValueFor(t, keyframes, tween, currentValue);
	  var result = {};
	  var keys = (0, _keys2.default)(keyframes);
	  for (var i = 0; i < keys.length; i++) {
	    result[keys[i]] = getKeyframeValueFor(t, keyframes[keys[i]], tween, currentValue[keys[i]]);
	  }
	  return result;
	};
	
	function updateAnimation(store, delta, time, animation, animationIdx) {
	  //console.log('updateAnimation', delta, time, animation.name, animationIdx);
	
	  var tracks = animation.tracks;
	  var first = animation.first;
	  var iterations = animation.iterations;
	  var duration = animation.duration;
	  var easingFn = animation.easingFn;
	  var easingDuration = animation.easingDuration;
	  var playSpeed = animation.playSpeed;
	  var easingTime = animation.easingTime;
	
	  var animationStart = animation.start;
	  var trackSet = animation.set;
	
	  var animationTime = time;
	
	  var isEasing = first && time < animationStart + easingDuration;
	  if (isEasing) {
	    easingTime += delta * easingFn(time - animationStart, 0, 1, easingDuration);
	    animationTime = animationStart + easingTime;
	  } else if (easingTime) {
	    animationTime = time - easingDuration + easingTime;
	  }
	
	  var reverse = playSpeed < 0;
	
	  if (playSpeed !== 1) {
	    animationTime = (animationTime - animationStart) * playSpeed + animationStart;
	    if (reverse) animationTime = animationTime + duration;
	  }
	
	  var inProgress = false;
	  var ops = [];
	
	  var s = new Date();
	  var track = undefined;
	  for (var trackIdx = 0; trackIdx < tracks.length; trackIdx++) {
	    track = tracks[trackIdx];
	    var start = track.start + animationStart;
	    var end = track.end + animationStart;
	
	    if (reverse ? animationTime > end : animationTime < start) {
	      inProgress = true;
	      continue;
	    }
	
	    var endValue = track.value;
	    var _track = track;
	    var tween = _track.tween;
	    var path = _track.path;
	    var keyframes = _track.keyframes;
	    var duration = _track.duration;
	    var currentValue = _track.currentValue;
	    var trackSet = _track.trackSet;
	
	    var startValue = track.startValue;
	
	    // TODO: this should be more efficient
	    //let currentValue = endValue; //get(store, path);
	
	    if (startValue == null && !keyframes) {
	      startValue = (0, _sceneGraph.get)(store, path);
	      store.dispatch({ type: UPDATE_TRACK, payload: { path: [animationIdx, trackIdx], attrs: { startValue: startValue } } });
	    }
	
	    var v = keyframes ? getKeyframeValue(animationTime - start, keyframes, tween, currentValue) : animationTime > end ? endValue : tween(animationTime - start, startValue, endValue, duration);
	
	    var op = trackSet(path, v);
	    if (op) ops.push(op);
	
	    if (reverse ? animationTime >= start : animationTime <= end) inProgress = true;
	  }
	
	  //console.log('dispatch animations',ops.length, 'in',  new Date() - s);
	  if (ops.length) store.dispatch((0, _sceneGraph.multi)(ops));
	
	  if (inProgress) {
	    if (isEasing) {
	      store.dispatch({ type: UPDATE_ANIMATION, payload: { index: animationIdx, attrs: {
	            easingTime: easingTime
	          } } });
	    }
	  } else {
	    if (iterations > 1) {
	      store.dispatch({ type: UPDATE_ANIMATION, payload: { index: animationIdx, attrs: {
	            first: false, easingTime: 0, start: time, iterations: iterations - 1
	          } } });
	    } else {
	      if (animation.onEnd) animation.onEnd();
	
	      if (animationIdx !== store.getIn(['animation', 'timelineAnimationIndex'])) {
	        store.dispatch({ type: REMOVE_ANIMATION, payload: animationIdx });
	      } else {
	        store.dispatch({ type: UPDATE_ANIMATION, payload: {
	            index: animationIdx, attrs: { start: time }
	          } });
	        store.dispatch(stopPlaying());
	      }
	    }
	  }
	};
	
	/**
	 * Are we currently playing
	 * @returns {Boolean}
	 */
	function isPlaying(store) {
	  return store.getIn(['animation', 'playing']);
	};
	
	/**
	 * Start time
	 * @public
	 */
	function startPlaying() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  return function (store) {
	    store.dispatch({ type: START_PLAYING, payload: options.autoplay });
	    store.dispatch(setTime(store.getIn(['animation', 'time'])));
	  };
	};
	
	/*
	 * If we are currently playing, increment time
	 */
	function incrementTime() {
	  return function (store) {
	    if (store.getIn(['animation', 'playing'])) {
	      var startTime = store.getIn(['animation', 'startTime']);
	      var time = store.getIn(['animation', 'time']);
	      var delta = startTime ? new Date() - startTime : 0;
	      store.dispatch(setTime(time + delta));
	    }
	  };
	};
	
	function getLastKeyframeTime(keyframes) {
	  if (keyframes.ts) return keyframes.ts.length ? keyframes.ts[keyframes.ts.length - 1] : 0;
	  var lastTime = 0;
	  var times = undefined;
	  var keys = (0, _keys2.default)(keyframes);
	  for (var i = 0; i < keys.length; i++) {
	    times = keyframes[keys[i]].ts;
	    lastTime = times.length ? Math.max(times[times.length - 1], lastTime) : lastTime;
	  }
	  return lastTime;
	};
	
	/**
	 * Stop time
	 * @public
	 */
	function stopPlaying() {
	  return { type: STOP_PLAYING };
	};
	
	function formatTrack(store, sceneTime, attrs) {
	  var id = (0, _cuid2.default)();
	  var path = Array.isArray(attrs.path) ? attrs.path : attrs.path && (0, _scene.find)(store, attrs.path);
	  if (!path && !attrs.set) {
	    console.log('path is not defined for track', attrs);
	    return null;
	  }
	  var start = attrs.start || 0;
	  var value = attrs.value;
	  var tween = attrs.tween || getTweenFunction(value, attrs.easing || 'linear');
	  var trackSet = attrs.set || _sceneGraph.set;
	  var keyframes = attrs.keyframes;
	  var duration = keyframes ? getLastKeyframeTime(keyframes) : attrs.duration || 0;
	  var end = duration + start;
	  var startValue = duration === 0 ? value : attrs.startValue;
	  var currentValue = path && (0, _sceneGraph.get)(store, path);
	  return { path: path, start: start, end: end, value: value, duration: duration, tween: tween, startValue: startValue, keyframes: keyframes, currentValue: currentValue, trackSet: trackSet };
	};
	
	/**
	 * Queue a clip to be played
	 *
	 * @public
	 * @param {String} clipId the id of the clip to be queued.
	 * @param {Object} attrs Attrs to override the clip settings.
	 * @param {Object} options
	 * @param {Boolean} options.useTimeline Display the clip in the timeline
	 * @returns {Promise}
	 *
	 * @example
	 * var clips = animation.getClips();
	 * animation.queueClip(clips[0].id, {autoplay: true});
	 *
	 */
	function queueClip(clipId, attrs) {
	  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
	  return function (store) {
	    var clip = store.getIn(['animation', 'clips', clipId]);
	    if (clip) {
	      store.dispatch(queueAnimation((0, _assign2.default)({}, clip.toJS(), attrs)));
	      if (options.useTimeline) store.dispatch({ type: QUEUE_TIMELINE_ANIMATION });
	    }
	  };
	};
	
	/**
	 * Queue an animation
	 *
	 * @public
	 * @param {Animation} attrs the animation object
	 * @returns {Promise}
	 */
	function queueAnimation(attrs) {
	  return function (store) {
	    var sceneTime = store.getIn(['animation', 'time']);
	
	    var name = attrs.name || 'Animation';
	    var iterations = attrs.iterations || 1;
	    var start = attrs.start || sceneTime;
	    var easing = attrs.easing || 'linear';
	    var easingFn = getTweenFunction(1, easing);
	    var easingDuration = attrs.easingDuration || 0;
	    var playSpeed = typeof attrs.playSpeed !== 'undefined' ? attrs.playSpeed : 1;
	    var trackList = (0, _ramda.filter)(function (t) {
	      return !!t;
	    }, (0, _ramda.map)(function (attrs) {
	      return formatTrack(store, sceneTime, attrs);
	    }, attrs.tracks));
	    var duration = (0, _ramda.reduce)(function (lastEnd, track) {
	      return Math.max(lastEnd, track.end);
	    }, 0, trackList);
	    var onEnd = attrs.onEnd || null;
	
	    //let end = 0;
	    //forEach((t) => { if (t.get('end') > end) end = t.get('end'); }, trackList);
	
	    store.dispatch({
	      type: QUEUE_ANIMATION,
	      payload: {
	        name: name,
	        start: start,
	        easingTime: 0,
	        first: true,
	        easing: easing,
	        easingFn: easingFn,
	        easingDuration: easingDuration,
	        iterations: iterations,
	        tracks: trackList,
	        onEnd: onEnd,
	        playSpeed: playSpeed,
	        duration: duration
	      }
	    });
	
	    if (attrs.autoplay && !isPlaying(store)) {
	      store.dispatch(startPlaying({ autoplay: true }));
	    }
	
	    return _promise2.default.resolve(true);
	  };
	};
	
	function findAnimationIndex(name, store) {
	  return store.getIn(['animation', 'animations']).findIndex(function (anim) {
	    return anim.name === name;
	  });
	};
	
	/**
	 * Remove an animation
	 *
	 * @public
	 * @param {String} name the name of the animation
	 * @returns {Promise}
	 */
	function removeAnimation(name) {
	  return function (store) {
	    var animationIdx = findAnimationIndex(name, store);
	    if (animationIdx !== -1) {
	      return store.dispatch({ type: REMOVE_ANIMATION, payload: animationIdx });
	    }
	  };
	};
	
	/**
	 * Add a clip to the store.
	 * @param {Object} clip
	 * @param {String} id
	 * @returns {Promise}
	 */
	function addClip(clip, id) {
	  return { type: ADD_CLIP, payload: { clip: clip, id: id } };
	};
	
	/**
	 * Return a list of clips available.
	 *
	 * @public
	 * @returns {Clip[]}
	 */
	function getClips(store) {
	  return (0, _ramda.values)(store.getIn(['animation', 'clips']).toJS());
	};
	
	function getTweenFunction(value, easing) {
	  var tweenFn = _tweenFunctions2.default[easing];
	  if (!tweenFn) throw new Error('Unknown easing function: ' + easing);
	
	  if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== 'object') return tweenFn;
	
	  var keys = (0, _keys2.default)(value);
	
	  return function (t, b, c, d) {
	    var result = {};
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      result[key] = tweenFn(t, b[key], c[key], d);
	    }
	    return result;
	  };
	};
	
	function getTimelineAnimation(store) {
	  var index = store.getIn(['animation', 'timelineAnimationIndex']);
	  if (index < 0) return null;
	  return store.getIn(['animation', 'animations', index]);
	}
	
	var publicApi = {
	  reducer: reducer,
	  actions: { setTime: setTime, startPlaying: startPlaying, stopPlaying: stopPlaying, removeAnimation: removeAnimation, queueAnimation: queueAnimation,
	    addClip: addClip, queueClip: queueClip
	  },
	  selectors: { getTime: getTime, getClips: getClips, getTimelineAnimation: getTimelineAnimation, isPlaying: isPlaying }
	};
	
	exports.default = publicApi;

/***/ },
/* 133 */
/*!************************************************!*\
  !*** ./~/babel-runtime/core-js/object/keys.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/keys */ 134), __esModule: true };

/***/ },
/* 134 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/keys.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.keys */ 135);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.keys;

/***/ },
/* 135 */
/*!**********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.keys.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(/*! ./_to-object */ 48)
	  , $keys    = __webpack_require__(/*! ./_object-keys */ 32);
	
	__webpack_require__(/*! ./_object-sap */ 131)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 136 */
/*!***************************************************!*\
  !*** ./~/babel-runtime/helpers/defineProperty.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(/*! babel-runtime/core-js/object/define-property */ 137);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	
	  return obj;
	};

/***/ },
/* 137 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/core-js/object/define-property.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ 138), __esModule: true };

/***/ },
/* 138 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/define-property.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.define-property */ 139);
	var $Object = __webpack_require__(/*! ../../modules/_core */ 13).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 139 */
/*!*********************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.define-property.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 11);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ 21), 'Object', {defineProperty: __webpack_require__(/*! ./_object-dp */ 17).f});

/***/ },
/* 140 */
/*!*************************************!*\
  !*** ./~/cuid/dist/browser-cuid.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * cuid.js
	 * Collision-resistant UID generator for browsers and node.
	 * Sequential for fast db lookups and recency sorting.
	 * Safe for element IDs and server-side lookups.
	 *
	 * Extracted from CLCTR
	 *
	 * Copyright (c) Eric Elliott 2012
	 * MIT License
	 */
	
	/*global window, navigator, document, require, process, module */
	(function (app) {
	  'use strict';
	  var namespace = 'cuid',
	    c = 0,
	    blockSize = 4,
	    base = 36,
	    discreteValues = Math.pow(base, blockSize),
	
	    pad = function pad(num, size) {
	      var s = "000000000" + num;
	      return s.substr(s.length-size);
	    },
	
	    randomBlock = function randomBlock() {
	      return pad((Math.random() *
	            discreteValues << 0)
	            .toString(base), blockSize);
	    },
	
	    safeCounter = function () {
	      c = (c < discreteValues) ? c : 0;
	      c++; // this is not subliminal
	      return c - 1;
	    },
	
	    api = function cuid() {
	      // Starting with a lowercase letter makes
	      // it HTML element ID friendly.
	      var letter = 'c', // hard-coded allows for sequential access
	
	        // timestamp
	        // warning: this exposes the exact date and time
	        // that the uid was created.
	        timestamp = (new Date().getTime()).toString(base),
	
	        // Prevent same-machine collisions.
	        counter,
	
	        // A few chars to generate distinct ids for different
	        // clients (so different computers are far less
	        // likely to generate the same id)
	        fingerprint = api.fingerprint(),
	
	        // Grab some more chars from Math.random()
	        random = randomBlock() + randomBlock();
	
	        counter = pad(safeCounter().toString(base), blockSize);
	
	      return  (letter + timestamp + counter + fingerprint + random);
	    };
	
	  api.slug = function slug() {
	    var date = new Date().getTime().toString(36),
	      counter,
	      print = api.fingerprint().slice(0,1) +
	        api.fingerprint().slice(-1),
	      random = randomBlock().slice(-2);
	
	      counter = safeCounter().toString(36).slice(-4);
	
	    return date.slice(-2) +
	      counter + print + random;
	  };
	
	  api.globalCount = function globalCount() {
	    // We want to cache the results of this
	    var cache = (function calc() {
	        var i,
	          count = 0;
	
	        for (i in window) {
	          count++;
	        }
	
	        return count;
	      }());
	
	    api.globalCount = function () { return cache; };
	    return cache;
	  };
	
	  api.fingerprint = function browserPrint() {
	    return pad((navigator.mimeTypes.length +
	      navigator.userAgent.length).toString(36) +
	      api.globalCount().toString(36), 4);
	  };
	
	  // don't change anything from here down.
	  if (app.register) {
	    app.register(namespace, api);
	  } else if (true) {
	    module.exports = api;
	  } else {
	    app[namespace] = api;
	  }
	
	}(this.applitude || this));


/***/ },
/* 141 */
/*!********************************************!*\
  !*** ./src/modules/utils/createReducer.js ***!
  \********************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createReducer;
	function createReducer(initialState, handlers) {
	  return function reducer(state, action, allState, createEvent) {
	    if (action && handlers.hasOwnProperty(action.type)) {
	      return handlers[action.type](state, action.payload, { action: action, createEvent: createEvent, state: allState });
	    } else {
	      return state || initialState;
	    }
	  };
	}

/***/ },
/* 142 */
/*!***********************************!*\
  !*** ./src/modules/sceneGraph.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.virtualTargetId = exports.vrCameraId = exports.virtualCameraId = undefined;
	exports.initNode = initNode;
	exports.addNode = addNode;
	exports.setVRCamera = setVRCamera;
	exports.deleteNode = deleteNode;
	exports.addOperator = addOperator;
	exports.get = get;
	exports.getVRCamera = getVRCamera;
	exports.set = set;
	exports.merge = merge;
	exports.replace = replace;
	exports.multi = multi;
	exports.touch = touch;
	exports.reparent = reparent;
	exports.findParent = findParent;
	exports.findRoot = findRoot;
	exports.clone = clone;
	exports.oldNodeJSON = oldNodeJSON;
	exports.exportJSON = exportJSON;
	exports.updateNodeTransform = updateNodeTransform;
	exports.getEvalSceneGraph = getEvalSceneGraph;
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 102);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 98);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _cuid = __webpack_require__(/*! cuid */ 140);
	
	var _cuid2 = _interopRequireDefault(_cuid);
	
	var _nodeUuid = __webpack_require__(/*! node-uuid */ 143);
	
	var _nodeUuid2 = _interopRequireDefault(_nodeUuid);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 141);
	
	var _createReducer3 = _interopRequireDefault(_createReducer2);
	
	var _assets = __webpack_require__(/*! ./assets */ 144);
	
	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 253);
	
	var _nonImmutable = __webpack_require__(/*! ../operators/nonImmutable */ 149);
	
	var _nonImmutable2 = _interopRequireDefault(_nonImmutable);
	
	var _evalSceneGraph = __webpack_require__(/*! ./utils/evalSceneGraph */ 254);
	
	var _createStore = __webpack_require__(/*! ../store/createStore */ 257);
	
	var _scene = __webpack_require__(/*! ./scene */ 147);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SET = 'SET';
	//import { fetchmaterial } from './files';
	
	var MERGE = 'MERGE';
	var REPLACE = 'REPLACE';
	var MULTI = 'MULTI';
	var REPARENT = 'REPARENT';
	var ADD_OPERATOR = 'ADD_OPERATOR';
	var TOUCH = 'TOUCH';
	var virtualCameraId = 'cccccccc-cccc-1ccc-accc-cccccccccccc';
	var vrCameraId = 'bbbbbbbb-bbbb-0bbb-zbbb-bbbbbbbbbbbb';
	var virtualTargetId = 'dddddddd-dddd-0ddd-addd-dddddddddddd';
	
	/*
	 * Convert from immutable.js scenegraph to our new object format
	 */
	function convertFromImmutable(scene) {
	  return scene.map(function (node) {
	    var warnings = node.get('warnings').toArray();
	    var plugs = node.get('plugs').map(function (ops, plug) {
	      return ops.map(function (op) {
	        var type = op.get('type');
	        var operator = (0, _nonImmutable.lookupOperator)(plug, type, warnings);
	        var opjs = operator.init(type, op.toJS(), op.get('name'));
	        //console.log('init operator: ', plug, opjs);
	        return opjs;
	      }).toArray();
	    }).toObject();
	    var nodeJS = node.toJS();
	    nodeJS.plugs = plugs;
	    nodeJS.warnings = warnings;
	    nodeJS._v = 0;
	    return nodeJS;
	  }).toObject();
	}
	
	/**
	 * Initialize node from object literal format
	 */
	function initNode(node) {
	  var plugs = {};
	  var warnings = node.warnings || [];
	  (0, _keys2.default)(node.plugs).forEach(function (plugName) {
	    plugs[plugName] = node.plugs[plugName].map(function (op) {
	      var type = op.type;
	      var operator = (0, _nonImmutable.lookupOperator)(plugName, type, warnings);
	      return operator.init(type, op, op.name);
	    });
	  });
	  return (0, _assign2.default)({}, node, { warnings: warnings, plugs: plugs, _v: 0 });
	}
	
	/*
	 * Read and initialize nodes from object literal format
	 */
	function initNodes(nodes) {
	  var result = {};
	  (0, _keys2.default)(nodes).forEach(function (id) {
	    result[id] = initNode(nodes[id]);
	  });
	  return result;
	}
	
	/**
	 * This module contains actions to manipulate the scene graph.
	 *
	 * @module sceneGraph
	 * @public
	 *
	 */
	
	/*
	 * Reducer
	 */
	function reducer(records) {
	  var _createReducer;
	
	  function createOperator(OperatorRecord, type, props, name) {
	    if (!name) name = type;
	
	    var Op = new OperatorRecord({ type: type, name: name });
	    // Calling merge directly so that the immutable shim has its `set` method called
	    // Filtering the operator to only known keys.
	    return Op.merge((0, _ramda.pick)(OperatorRecord.keys(), props));
	  };
	
	  function checkNode(node) {
	    if (!node.hasOwnProperty('_v')) node._v = 0;
	    return node;
	  }
	
	  function buildNode(_ref) {
	    var id = _ref.id;
	    var name = _ref.name;
	    var type = _ref.type;
	    var children = _ref.children;
	    var parent = _ref.parent;
	    var plugs = _ref.plugs;
	
	    var warnings = [];
	
	    var initPlugs = (0, _ramda.mapObjIndexed)(function (ops, plug) {
	      if (!records[plug]) {
	        warnings = warnings.push('No Plug: ' + plug);
	        return [];
	      }
	      return ops.map(function (op) {
	        if (!Array.isArray(op)) throw new Error('Expect op to be an array of 2 or 3');
	
	        var _op = (0, _slicedToArray3.default)(op, 3);
	
	        var type = _op[0];
	        var props = _op[1];
	        var name = _op[2];
	
	        var operator = (0, _nonImmutable.lookupOperator)(plug, type, warnings);
	        var opdata = operator.init(type, props, name); // Object.assign({}, props, { type, name });
	        //console.log('init operator: ', type, props, opdata);
	        return opdata;
	        //let OperatorRecord = records[plug][type];
	
	        //if (!OperatorRecord) {
	        //  warnings = warnings.push(`No Operator: ${plug} - ${type}`);
	        //  //console.log('WARNING:', warnings.toJS());
	        //  OperatorRecord = records.None.NoOp;
	        //}
	        //return createOperator(OperatorRecord, type, props, name);
	      });
	    }, plugs);
	
	    var newChildren = children || [];
	
	    return {
	      id: id,
	      name: name,
	      type: type,
	      children: newChildren,
	      parent: parent,
	      plugs: initPlugs,
	      warnings: warnings,
	      _v: 0
	    };
	  };
	
	  function errorNode(_ref2) {
	    var id = _ref2.id;
	    var name = _ref2.name;
	    var children = _ref2.children;
	    var parent = _ref2.parent;
	
	    children = children ? (0, _immutable.List)(children) : (0, _immutable.List)();
	    return (0, _immutable.Map)({ id: id, name: name, type: 'ErrorNode', children: children, parent: parent, plugs: (0, _immutable.Map)() });
	  };
	
	  function addOperator(state, path, operator) {
	    var _path = (0, _slicedToArray3.default)(path, 2);
	
	    var id = _path[0];
	    var plug = _path[1];
	
	    var ops = state.getIn([id, 'plugs', plug]);
	    if (!ops) throw new Error('Invalid path to \'addOperator\': ' + id + ':' + plug);
	    state.setIn([id, 'plugs', plug], ops.push(buildOperator(plug)(operator)));
	  };
	
	  function newInitialState() {
	    return {
	      _v: 0,
	      nodes: {},
	      fileReferences: { to: {}, from: {} },
	      nodeReferences: { to: {}, from: {} },
	      evaluatedNodes: {},
	      loaded: false,
	      _ev: 0
	    };
	  }
	
	  function setReducer(state, _ref3) {
	    var path = _ref3.path;
	    var value = _ref3.value;
	
	    if (!path.length || path.length < 2) {
	      throw new Error('SET requires a path with length 2 or 4');
	    }
	
	    var _path2 = (0, _slicedToArray3.default)(path, 4);
	
	    var nodeId = _path2[0];
	    var plugName = _path2[1];
	    var idx = _path2[2];
	    var key = _path2[3];
	
	    var node = state.nodes[nodeId];
	
	    if (path.length === 2 && path[1] === 'name') {
	      node.name = value;
	    } else {
	      var plug = node && node.plugs[plugName];
	      var op = plug && plug[idx];
	      if (!op) throw new Error('Setting data on unknown operator: ' + path.join(','));
	
	      var operator = _nonImmutable2.default[plugName][op.type];
	      operator.set(op, key, value);
	    }
	    node._v += 1;
	    state._v += 1;
	
	    return state;
	  }
	
	  var sceneReducer = (0, _createReducer3.default)({}, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, _createStore.ActionTypes.INIT, function (state) {
	    return newInitialState();
	  }), (0, _defineProperty3.default)(_createReducer, TOUCH, function (state, id) {
	    var node = state.nodes[id];
	    if (node) {
	      node._v += 1;
	      state._v += 1;
	    }
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, SET, setReducer), (0, _defineProperty3.default)(_createReducer, MERGE, function (state, _ref4) {
	    var path = _ref4.path;
	    var attrs = _ref4.attrs;
	
	    if (!path.length || path.length !== 3) {
	      throw new Error('MERGE requires a path with length 3');
	    }
	    if ((typeof attrs === 'undefined' ? 'undefined' : (0, _typeof3.default)(attrs)) !== 'object') {
	      throw new Error('MERGE requires an object to merge in');
	    }
	
	    var _path3 = (0, _slicedToArray3.default)(path, 3);
	
	    var nodeId = _path3[0];
	    var plugName = _path3[1];
	    var idx = _path3[2];
	
	    var node = state.nodes[nodeId];
	    var plug = node && node.plugs[plugName];
	    var op = plug && plug[idx];
	    var operator = op && _nonImmutable2.default[plugName][op.type];
	    if (!operator) throw new Error('Setting data on unknown operator: ' + path.join(','));
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(attrs)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var k = _step.value;
	
	        operator.set(op, k, attrs[k]);
	      }
	      //op._v += 1;
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    node._v += 1;
	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, REPLACE, function (state, _ref5) {
	    var id = _ref5.id;
	    var node = _ref5.node;
	
	    var originalNode = state.nodes[id];
	    if (!originalNode) return;
	
	    var v = originalNode._v;
	    state.nodes[id] = node;
	    node._v = v + 1;
	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.ADD_NODE, function (state, attrs) {
	    var id = attrs.id;
	    var parent = attrs.parent;
	
	    var parentNode = parent && state.nodes[parent];
	    if (parent && !parentNode) throw new Error('Unknown parent: \'' + parent + '\'');
	
	    if (state.nodes[id]) throw new Error('Adding a node that already exists: ' + id);
	
	    state.nodes[id] = attrs.node ? checkNode(attrs.node) : buildNode(attrs);
	
	    if (parent && !parentNode.children) {
	      parentNode.children = [];
	    }
	    if (parent && parentNode.children.indexOf(id) === -1) {
	      parentNode.children.push(id);
	    }
	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.DELETE_NODE, function (state, nodeId) {
	    function deleteNodesFromState(id) {
	      var node = state.nodes[id];
	      if (node) {
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;
	
	        try {
	          for (var _iterator2 = (0, _getIterator3.default)(node.children || []), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var childId = _step2.value;
	
	            deleteNodesFromState(childId);
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	
	        var references = state.nodeReferences.from[id];
	        (0, _keys2.default)(references || {}).forEach(function (refKey) {
	          var path = JSON.parse(refKey);
	          setReducer(state, { path: path, value: null });
	        });
	        delete state.nodes[id];
	      }
	      return node;
	    }
	    var node = deleteNodesFromState(nodeId);
	    if (!node) return state;
	    var parent = node.parent && state.nodes[node.parent];
	    if (parent) {
	      var idx = parent.children.indexOf(nodeId);
	      if (idx !== -1) parent.children.splice(idx, 1);
	      parent._v += 1;
	    }
	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, ADD_OPERATOR, function (state, attrs) {
	    var id = attrs.id;
	    var plug = attrs.plug;
	    var op = attrs.op;
	
	    var node = state.nodes[id];
	    if (!node) throw new Error('Unknown node: ' + id);
	
	    var ops = node.plugs[plug];
	    if (!ops) throw new Error('Unknown plug: ' + plug);
	
	    if (!Array.isArray(op)) throw new Error('Expect op to be an array of 2 or 3');
	
	    var _op2 = (0, _slicedToArray3.default)(op, 3);
	
	    var type = _op2[0];
	    var props = _op2[1];
	    var name = _op2[2];
	
	    var operator = (0, _nonImmutable.lookupOperator)(plug, type, node.warnings);
	    ops.push(operator.init(type, op, name));
	    node._v += 1;
	    state._v += 1;
	
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, MULTI, function (state, ops) {
	    var v = state._v;
	    for (var opId in ops) {
	      var op = ops[opId];
	      if (op.type === SET) setReducer(state, op.payload);
	    }
	    state._v = v + 1;
	    //console.log('create new multi state in: ', new Date() - s);
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, REPARENT, function (state, _ref6) {
	    var parentId = _ref6.parentId;
	    var childIds = _ref6.childIds;
	
	    var newParentNode = state.nodes[parentId];
	    if (!newParentNode) {
	      console.warn('Unknown parent for reparent: ' + parentId);
	      return state;
	    }
	
	    (0, _ramda.forEach)(function (childId) {
	      var childNode = state.nodes[childId];
	      if (!childNode) return;
	
	      var childParentId = childNode && childNode.parent;
	      var prevParentNode = childParentId && state.nodes[childParentId];
	      var idx = prevParentNode && prevParentNode.children ? prevParentNode.children.indexOf(childId) : -1;
	      if (idx !== -1) {
	        prevParentNode.children.splice(idx, 1);
	        prevParentNode._v += 1;
	      }
	
	      newParentNode.children.push(childId);
	      childNode.parent = parentId;
	      childNode._v += 1;
	    }, childIds.slice()); // iterate copy of array to protect from corruption from child removals
	
	    newParentNode._v += 1;
	    state._v += 1;
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref7) {
	    var scene = _ref7.scene;
	    var nodes = _ref7.nodes;
	
	    var sceneJS = scene ? convertFromImmutable(scene) : initNodes(JSON.parse(nodes));
	
	    (0, _assign2.default)(state.nodes, sceneJS);
	
	    if (!state.nodes[virtualCameraId]) {
	      state.nodes[virtualCameraId] = buildNode({
	        id: virtualCameraId,
	        name: 'CAMERA',
	        type: 'Camera',
	        plugs: {
	          Camera: [['Camera', {}]],
	          Transform: [['Transform', {}]],
	          Properties: [['Default', {}]]
	        }
	      });
	    }
	    if (!state.nodes[vrCameraId]) {
	      state.nodes[vrCameraId] = buildNode({
	        id: vrCameraId,
	        name: 'VR CAMERA',
	        type: 'Camera',
	        plugs: {
	          Camera: [['Camera', { fieldOfView: 45 }]],
	          Transform: [['Transform', { translation: { x: 0, y: 1.6, z: 1 } }]],
	          Properties: [['Default', {}]]
	        }
	      });
	    }
	    if (!state.nodes[virtualTargetId]) {
	      state.nodes[virtualTargetId] = buildNode({
	        id: virtualTargetId,
	        name: 'VIRTUAL TARGET NULL',
	        type: 'Null',
	        plugs: {
	          Transform: [['Transform', {}]]
	        }
	      });
	    }
	
	    state._v += 1;
	
	    return state;
	    //const newState = state.merge(scene);
	    //return newState.get(virtualCameraId) ? newState : newState.set(virtualCameraId, buildNode({
	    //  id: virtualCameraId,
	    //  name: 'CAMERA',
	    //  type: 'Camera',
	    //  plugs: {
	    //    Camera: [['Camera', {}]],
	    //    Transform: [['Transform', {}]],
	    //    Properties: [['Default', {}]],
	    //  },
	    //}));
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADED_FILE, function (state, id) {
	    if (state.fileReferences.from[id]) {
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;
	
	      try {
	        for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(state.fileReferences.from[id])), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var refKey = _step3.value;
	
	          var _JSON$parse = JSON.parse(refKey);
	
	          var _JSON$parse2 = (0, _slicedToArray3.default)(_JSON$parse, 3);
	
	          var nodeId = _JSON$parse2[0];
	          var plugName = _JSON$parse2[1];
	          var opIdx = _JSON$parse2[2];
	
	          state.nodes[nodeId]._v += 1;
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	
	      state._v += 1;
	    }
	    return state;
	  }), (0, _defineProperty3.default)(_createReducer, _actionTypes.SET_VR_CAMERA, function (state, cameraId) {
	    // FIXME: remove this
	    var camNode = state.get(cameraId);
	    if (camNode.type === 'Camera') return state.set(vrCameraId, camNode);else return state;
	  }), _createReducer));
	
	  return sceneReducer;
	}
	
	// Return a new node object from existing node
	function copyNode(node) {
	  var newPlugs = {};
	  var _iteratorNormalCompletion4 = true;
	  var _didIteratorError4 = false;
	  var _iteratorError4 = undefined;
	
	  try {
	    for (var _iterator4 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	      var plug = _step4.value;
	
	      newPlugs[plug] = (0, _ramda.map)(function (op) {
	        return (0, _assign2.default)({}, op);
	      }, node.plugs[plug]);
	    }
	  } catch (err) {
	    _didIteratorError4 = true;
	    _iteratorError4 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion4 && _iterator4.return) {
	        _iterator4.return();
	      }
	    } finally {
	      if (_didIteratorError4) {
	        throw _iteratorError4;
	      }
	    }
	  }
	
	  return {
	    id: _nodeUuid2.default.v4(),
	    name: node.name,
	    type: node.type,
	    parent: node.parent,
	    children: [].concat(node.children),
	    plugs: newPlugs,
	    _v: 1
	  };
	}
	
	/**
	 * Add a node to the scene.
	 *
	 * @public
	 * @param {Node} node
	 * @returns {Promise}
	 */
	function addNode(node) {
	  var id = node.id;
	  var name = node.name;
	  var type = node.type;
	  var plugs = node.plugs;
	  var parent = node.parent;
	
	  if (!id) id = _nodeUuid2.default.v4(); //cuid();
	  name = name || id;
	
	  return {
	    type: _actionTypes.ADD_NODE,
	    payload: { id: id, name: name, type: type, plugs: plugs, parent: parent },
	    resolve: id
	  };
	};
	
	function setVRCamera(camId) {
	  return { type: _actionTypes.SET_VR_CAMERA, payload: camId };
	}
	
	/**
	 * Deletes a node
	 *
	 * @public
	 * @param {String} id The node id
	 * @returns {Promise}
	 */
	function deleteNode(id) {
	  return {
	    type: _actionTypes.DELETE_NODE,
	    payload: id
	  };
	};
	
	/**
	 *
	 * Add an operator to a plug of a node.
	 */
	function addOperator(id, plug, op) {
	  return {
	    type: ADD_OPERATOR,
	    payload: { id: id, plug: plug, op: op }
	  };
	};
	
	/**
	 * get a property
	 *
	 * @param {Path} path to the operator property.
	 * @returns {any} value
	 *
	 * @example
	 * // scene.get([uuid
	 */
	function get(store, path) {
	  if (!Array.isArray(path)) throw new Error('Expect path to be an array');
	
	  var sceneGraph = store.get('sceneGraph');
	  var result = sceneGraph.nodes[path[0]];
	
	  if (path.length >= 2) {
	    if (path[1] === 'name' || path[1] === 'type') {
	      return result && result[path[1]];
	    }
	    result = result && result.plugs[path[1]];
	  }
	
	  if (path.length >= 3) {
	    result = result && result[path[2]];
	  }
	
	  if (path.length >= 4 && result) {
	    var operator = (0, _nonImmutable.lookupOperator)(path[1], result.type, []);
	    result = operator.get(result, path[3]);
	  }
	  return result;
	};
	
	function getVRCamera(store) {
	  return store.getIn(['sceneGraph', vrCameraId]);
	}
	
	/**
	 * set a property on an operator. This takes a Path array,
	 * and a value
	 *
	 * @param {Path} path includes the operator property.
	 * @param {any} value
	 * @returns {Promise}
	 *
	 */
	function set(path, value) {
	  return { type: SET, payload: { path: path, value: value }, meta: { remote: true } };
	};
	
	/**
	 * Merges an object into an operator.
	 *
	 * @param {Path} path to the operator.
	 * @param {Object} attrs
	 * @returns {Promise}
	 *
	 */
	function merge(path, attrs) {
	  return { type: MERGE, payload: { path: path, attrs: attrs } };
	};
	
	/**
	 * Replace a node with the given node contents
	 * @private
	 *
	 */
	function replace(id, node) {
	  return { type: REPLACE, payload: { id: id, node: node } };
	};
	
	/**
	 * An array of scene actions.
	 *
	 * @param {Action[]} ops
	 * @returns {Promise}
	 */
	function multi(ops) {
	  return { type: MULTI, payload: ops };
	};
	
	/**
	 * Touch sceneGraph node, so it is re-evaluated and translated
	 */
	function touch(id) {
	  return { type: TOUCH, payload: id };
	};
	
	/**
	 * Reparent nodes to the new parent.
	 *
	 * @public
	 * @param {String} parent id of the new parent node
	 * @param {Array} childIds list of ids to reparent
	 *
	 * @example
	 * // reparent children of 'MyModel' to 'NewParentNull'
	 * const parentId = scene.find({ name: 'NewParentNull' });
	 * const nodesToReparent = scene.filter({ from: { name: 'MyModel' } });
	 * sceneGraph.reparent(parentId, nodesToReparent);
	 */
	function reparent(parentId, childIds) {
	  return { type: REPARENT, payload: { parentId: parentId, childIds: childIds } };
	};
	
	/**
	 * Return the parent id of the node.
	 */
	function findParent(store, id) {
	  var node = store.get('sceneGraph').nodes[id];
	  return node && node.parent;
	};
	
	/**
	 * Return the root parent id of the node.
	 */
	function findRoot(store, id) {
	  var node = store.get('sceneGraph').nodes[id];
	  var parent = node && node.parent;
	  return parent ? findRoot(store, parent) : id;
	};
	
	/**
	 * Clone nodes. Given a list of ids, this will copy the node with a new id,
	 * and update the parent and child of each node. By passing in a map of *old
	 * parent id* to *new parent id*, the nodes can be cloned to a different location
	 * in the sceneGraph (or from one to another).
	 *
	 * @public
	 * @param {Array} ids list of ids to clone
	 * @param {Object} nodeMap of {oldNodeId: newNodeId} Can be used for passing
	 *                         new parents, or new depencies.
	 * @param {Object?} options
	 * @param {Boolean?} options.cloneDependencies Clone dependencies as well.
	 *
	 * @example
	 * // clone children of 'MyModel' to 'NewParentNull'
	 * const parentId = scene.find({ name: 'NewParentNull' });
	 * const myModelId = scene.find({ name: 'MyModel' });
	 * const nodesToClone = scene.filter({ from: { id: myModelId } });
	 * sceneGraph.clone(nodesToClone, { [myModelId]: parentId });
	 * // clone dependencies
	 * sceneGraph.clone(nodesToClone, { [myModelId]: parentId }, {cloneDependencies: true});
	 */
	function clone(ids) {
	  var nodeMap = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	  var cloneDependencies = options.cloneDependencies;
	
	  var nodes = (0, _ramda.reduce)(function (acc, id) {
	    acc[id] = true;return acc;
	  }, {}, ids);
	  var assets = {};
	
	  return function (store) {
	    var sceneGraph = store.get('sceneGraph');
	
	    // Find dependencies
	    function checkDependency(id) {
	      var node = sceneGraph.nodes[id];
	      var name = node && node.name;
	      if (!node || !node.plugs) return;
	
	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;
	
	      try {
	        for (var _iterator5 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var plug = _step5.value;
	
	          var ops = node.plugs[plug];
	
	          var _iteratorNormalCompletion6 = true;
	          var _didIteratorError6 = false;
	          var _iteratorError6 = undefined;
	
	          try {
	            for (var _iterator6 = (0, _getIterator3.default)(ops), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	              var op = _step6.value;
	
	              var operator = _nonImmutable2.default[plug][op.type];
	              if (operator) {
	                var _iteratorNormalCompletion7 = true;
	                var _didIteratorError7 = false;
	                var _iteratorError7 = undefined;
	
	                try {
	                  for (var _iterator7 = (0, _getIterator3.default)(operator.referenceKeys), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	                    var key = _step7.value;
	
	                    var refId = op[key];
	                    if (refId && !nodes[refId] && !nodeMap[refId]) {
	                      nodes[refId] = true;
	                      checkDependency(refId);
	                    }
	                  }
	                } catch (err) {
	                  _didIteratorError7 = true;
	                  _iteratorError7 = err;
	                } finally {
	                  try {
	                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
	                      _iterator7.return();
	                    }
	                  } finally {
	                    if (_didIteratorError7) {
	                      throw _iteratorError7;
	                    }
	                  }
	                }
	
	                var _iteratorNormalCompletion8 = true;
	                var _didIteratorError8 = false;
	                var _iteratorError8 = undefined;
	
	                try {
	                  for (var _iterator8 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	                    var key = _step8.value;
	
	                    var refId = op[key];
	                    if (refId && store.getIn(['assets', refId])) {
	                      assets[refId] = true;
	                    }
	                  }
	                } catch (err) {
	                  _didIteratorError8 = true;
	                  _iteratorError8 = err;
	                } finally {
	                  try {
	                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
	                      _iterator8.return();
	                    }
	                  } finally {
	                    if (_didIteratorError8) {
	                      throw _iteratorError8;
	                    }
	                  }
	                }
	              }
	            }
	          } catch (err) {
	            _didIteratorError6 = true;
	            _iteratorError6 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                _iterator6.return();
	              }
	            } finally {
	              if (_didIteratorError6) {
	                throw _iteratorError6;
	              }
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }
	    }
	
	    if (cloneDependencies) (0, _ramda.forEach)(checkDependency, ids);
	
	    // Generate new ids
	    (0, _ramda.forEach)(function (id) {
	      return nodes[id] = _nodeUuid2.default.v4();
	    }, (0, _keys2.default)(nodes));
	    (0, _ramda.forEach)(function (assetId) {
	      return assets[assetId] = _nodeUuid2.default.v4();
	    }, (0, _keys2.default)(assets));
	
	    function updateDependencies(node) {
	      var resultNode = node;
	      var _iteratorNormalCompletion9 = true;
	      var _didIteratorError9 = false;
	      var _iteratorError9 = undefined;
	
	      try {
	        var _loop = function _loop() {
	          var plug = _step9.value;
	
	          var ops = node.plugs[plug];
	          ops.forEach(function (op, opIdx) {
	            var operator = _nonImmutable2.default[plug][op.type];
	            if (operator) {
	              var _iteratorNormalCompletion10 = true;
	              var _didIteratorError10 = false;
	              var _iteratorError10 = undefined;
	
	              try {
	                for (var _iterator10 = (0, _getIterator3.default)(operator.referenceKeys), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	                  var key = _step10.value;
	
	                  var refId = op[key];
	                  var newRef = refId && (nodes[refId] || nodeMap[refId]);
	                  if (newRef) resultNode.plugs[plug][opIdx][key] = newRef;
	                }
	              } catch (err) {
	                _didIteratorError10 = true;
	                _iteratorError10 = err;
	              } finally {
	                try {
	                  if (!_iteratorNormalCompletion10 && _iterator10.return) {
	                    _iterator10.return();
	                  }
	                } finally {
	                  if (_didIteratorError10) {
	                    throw _iteratorError10;
	                  }
	                }
	              }
	
	              var _iteratorNormalCompletion11 = true;
	              var _didIteratorError11 = false;
	              var _iteratorError11 = undefined;
	
	              try {
	                for (var _iterator11 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
	                  var key = _step11.value;
	
	                  var refId = op[key];
	                  if (refId && assets[refId]) {
	                    resultNode.plugs[plug][opIdx][key] = assets[refId];
	                  }
	                }
	              } catch (err) {
	                _didIteratorError11 = true;
	                _iteratorError11 = err;
	              } finally {
	                try {
	                  if (!_iteratorNormalCompletion11 && _iterator11.return) {
	                    _iterator11.return();
	                  }
	                } finally {
	                  if (_didIteratorError11) {
	                    throw _iteratorError11;
	                  }
	                }
	              }
	
	              ;
	            }
	          });
	        };
	
	        for (var _iterator9 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	          _loop();
	        }
	      } catch (err) {
	        _didIteratorError9 = true;
	        _iteratorError9 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion9 && _iterator9.return) {
	            _iterator9.return();
	          }
	        } finally {
	          if (_didIteratorError9) {
	            throw _iteratorError9;
	          }
	        }
	      }
	
	      return resultNode;
	    }
	
	    // Remap parents, children and dependencies
	    (0, _ramda.forEach)(function (id) {
	      var oldNode = sceneGraph.nodes[id];
	      var newNode = copyNode(oldNode);
	      newNode.id = nodes[id];
	
	      var nodeParent = oldNode.parent;
	      var parent = nodeParent && (nodes[nodeParent] || nodeMap[nodeParent] || nodeParent);
	      newNode.parent = parent;
	
	      newNode.children = [];
	      var _iteratorNormalCompletion12 = true;
	      var _didIteratorError12 = false;
	      var _iteratorError12 = undefined;
	
	      try {
	        for (var _iterator12 = (0, _getIterator3.default)(oldNode.children), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
	          var childId = _step12.value;
	
	          if (nodes[childId]) newNode.children.push(nodes[childId]);else if (nodeMap[childId]) newNode.children.push(nodeMap[childId]);
	        }
	      } catch (err) {
	        _didIteratorError12 = true;
	        _iteratorError12 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion12 && _iterator12.return) {
	            _iterator12.return();
	          }
	        } finally {
	          if (_didIteratorError12) {
	            throw _iteratorError12;
	          }
	        }
	      }
	
	      store.dispatch({
	        type: _actionTypes.ADD_NODE,
	        payload: {
	          id: nodes[id],
	          parent: parent,
	          node: updateDependencies(newNode)
	        }
	      });
	    }, (0, _keys2.default)(nodes));
	
	    var firstNodeRootId = findRoot(store, nodes[(0, _keys2.default)(nodes)[0]]);
	
	    (0, _ramda.forEach)(function (assetId) {
	      var asset = store.getIn(['assets', assetId]);
	      if (asset) {
	        store.dispatch((0, _assets.addFile)(asset.set('id', assets[assetId]).set('sceneId', firstNodeRootId).toJS()));
	      }
	    }, (0, _keys2.default)(assets));
	
	    return _promise2.default.resolve(nodes);
	  };
	};
	
	function oldNodeJSON(node) {
	  var plugs = (0, _keys2.default)(node.plugs).map(function (plugName) {
	    return {
	      type: plugName,
	      operators: node.plugs[plugName].map(function (op) {
	        var operator = (0, _nonImmutable.lookupOperator)(plugName, op.type, []);
	        return operator.export(op);
	      })
	    };
	  });
	
	  return {
	    _id: node.id,
	    name: node.name,
	    type: node.type,
	    plugs: plugs,
	    nodes: []
	  };
	};
	
	/**
	 * Given a list of nodes, build and return the old scene graph format.
	 */
	function exportJSON(store, nodes) {
	  var rootNode = undefined;
	  var nodeMap = {};
	  var sceneGraph = store.get('sceneGraph');
	
	  (0, _ramda.forEach)(function (nodeId) {
	    var node = sceneGraph.nodes[nodeId];
	    if (!node) return;
	
	    var newNode = oldNodeJSON(node);
	    nodeMap[newNode._id] = newNode;
	    if (!rootNode) rootNode = newNode;
	
	    if (node.parent && nodeMap[node.parent]) {
	      nodeMap[node.parent].nodes.push(newNode);
	    }
	  }, nodes);
	
	  return rootNode;
	};
	
	//export function importMaterial(id) {
	//  return ({dispatch, getState}) => {
	//    // let sceneId = getState().getIn(['scene','id']);
	//    return dispatch(fetchMaterial(id)).then((mat) => {
	//      return dispatch(addNode({...mat, plugs: {
	//        Material: [['Material', {color: {r: 1, g: 0, b: 0, a: 1}}]]
	//      }, parent: 'materiallibrary'}));
	//    }).catch((err) => {
	//      // console.log('handle rejected promise?', err);
	//      return false;
	//      // throw err;
	//    });
	//  }
	//}
	
	function updateNodeTransform(store, nodeId, newTransform) {
	  var parentNodeId = findParent(store, nodeId);
	
	  //const parent = store.getIn(['sceneGraph',parentNode.get('id'),'parent']);
	  var parentWorldTransform = (0, _scene.getWorldTransform)(store, parentNodeId);
	  //console.log( 'parentWorldTransform', parentWorldTransform );
	
	  var position = new _three2.default.Vector3(),
	      quaternion = new _three2.default.Quaternion(),
	      scale = new _three2.default.Vector3();
	
	  var tempTransform = new _three2.default.Matrix4();
	  tempTransform.copy(newTransform);
	
	  if (parentWorldTransform) {
	    var invParentWorldTransform = new _three2.default.Matrix4();
	    invParentWorldTransform.getInverse(parentWorldTransform, true);
	    tempTransform.multiplyMatrices(invParentWorldTransform, tempTransform);
	  }
	  tempTransform.decompose(position, quaternion, scale);
	  //console.log( 'position', JSON.stringify( position ) );
	  //console.log( 'scale', JSON.stringify( scale ) );
	  var euler = new _three2.default.Euler().setFromQuaternion(quaternion, 'ZYX');
	  //console.log( 'euler', JSON.stringify( euler ) );
	
	  //let translation = node.getIn(['plugs','Transform',0,'translation']);
	  //let rotation = node.getIn(['plugs','Transform',0,'rotation']);
	  store.dispatch(set([nodeId, 'Transform', 0, 'translation'], { x: position.x, y: position.y, z: position.z }));
	  store.dispatch(set([nodeId, 'Transform', 0, 'rotation'], { x: _three2.default.Math.radToDeg(euler.x), y: _three2.default.Math.radToDeg(euler.y), z: _three2.default.Math.radToDeg(euler.z) }));
	}
	
	function getEvalSceneGraph(store) {
	  var sceneGraph = store.get('sceneGraph');
	
	  if (sceneGraph._v === sceneGraph._ev) {
	    return sceneGraph;
	  }
	
	  var sceneId = store.getIn(['sceneIO', 'id']); // getSceneId
	  //console.log('updateSceneGraph', sceneGraph._ev, 'from', sceneGraph._v);
	  (0, _evalSceneGraph.evaluateSceneGraph)(store, sceneId, sceneGraph);
	  return sceneGraph;
	};
	
	var publicApi = {
	  reducer: reducer,
	  actions: { set: set, merge: merge, multi: multi, addNode: addNode, deleteNode: deleteNode, reparent: reparent, clone: clone, setVRCamera: setVRCamera, addOperator: addOperator },
	  selectors: { get: get, exportJSON: exportJSON, getVRCamera: getVRCamera }
	};
	exports.default = publicApi;
	exports.virtualCameraId = virtualCameraId;
	exports.vrCameraId = vrCameraId;
	exports.virtualTargetId = virtualTargetId;

/***/ },
/* 143 */
/*!*****************************!*\
  !*** ./~/node-uuid/uuid.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php
	
	(function() {
	  var _global = this;
	
	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	  var _rng;
	
	  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	  //
	  // Moderately fast, high quality
	  if (typeof(_global.require) == 'function') {
	    try {
	      var _rb = _global.require('crypto').randomBytes;
	      _rng = _rb && function() {return _rb(16);};
	    } catch(e) {}
	  }
	
	  if (!_rng && _global.crypto && crypto.getRandomValues) {
	    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	    //
	    // Moderately fast, high quality
	    var _rnds8 = new Uint8Array(16);
	    _rng = function whatwgRNG() {
	      crypto.getRandomValues(_rnds8);
	      return _rnds8;
	    };
	  }
	
	  if (!_rng) {
	    // Math.random()-based (RNG)
	    //
	    // If all else fails, use Math.random().  It's fast, but is of unspecified
	    // quality.
	    var  _rnds = new Array(16);
	    _rng = function() {
	      for (var i = 0, r; i < 16; i++) {
	        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
	        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	      }
	
	      return _rnds;
	    };
	  }
	
	  // Buffer class to use
	  var BufferClass = typeof(_global.Buffer) == 'function' ? _global.Buffer : Array;
	
	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }
	
	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = (buf && offset) || 0, ii = 0;
	
	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	      if (ii < 16) { // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });
	
	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }
	
	    return buf;
	  }
	
	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0, bth = _byteToHex;
	    return  bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]];
	  }
	
	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html
	
	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();
	
	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [
	    _seedBytes[0] | 0x01,
	    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	  ];
	
	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
	
	  // Previous uuid creation time
	  var _lastMSecs = 0, _lastNSecs = 0;
	
	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];
	
	    options = options || {};
	
	    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;
	
	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = options.msecs != null ? options.msecs : new Date().getTime();
	
	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;
	
	    // Time since last uuid creation (in msecs)
	    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;
	
	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }
	
	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }
	
	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }
	
	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;
	
	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;
	
	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;
	
	    // `time_mid`
	    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;
	
	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;
	
	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;
	
	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;
	
	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }
	
	    return buf ? buf : unparse(b);
	  }
	
	  // **`v4()` - Generate random UUID**
	
	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;
	
	    if (typeof(options) == 'string') {
	      buf = options == 'binary' ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};
	
	    var rnds = options.random || (options.rng || _rng)();
	
	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = (rnds[6] & 0x0f) | 0x40;
	    rnds[8] = (rnds[8] & 0x3f) | 0x80;
	
	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }
	
	    return buf || unparse(rnds);
	  }
	
	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	
	  if (typeof(module) != 'undefined' && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else  if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return uuid;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	 
	
	  } else {
	    // Publish as global (in browsers)
	    var _previousRoot = _global.uuid;
	
	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function() {
	      _global.uuid = _previousRoot;
	      return uuid;
	    };
	
	    _global.uuid = uuid;
	  }
	}).call(this);


/***/ },
/* 144 */
/*!*******************************!*\
  !*** ./src/modules/assets.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createReducer;
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NULL_SCENE_ID = undefined;
	exports.addFile = addFile;
	exports.removeFile = removeFile;
	exports.isLoading = isLoading;
	exports.getImage = getImage;
	exports.getOrFetchImage = getOrFetchImage;
	exports.getOrFetchBinary = getOrFetchBinary;
	exports.getHash = getHash;
	exports.getUrl = getUrl;
	exports.fetchText = fetchText;
	exports.fetchTransit = fetchTransit;
	exports.find = find;
	exports.filter = filter;
	exports.exportJSON = exportJSON;
	exports.getActiveAssets = getActiveAssets;
	exports.importImage = importImage;
	exports.importFile = importFile;
	
	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 145);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 141);
	
	var _createReducer3 = _interopRequireDefault(_createReducer2);
	
	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 142);
	
	var _scene = __webpack_require__(/*! ./scene */ 147);
	
	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 253);
	
	var _selectors = __webpack_require__(/*! ./utils/selectors */ 148);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Managing assets
	 *
	 * @module assets
	 * @public
	 */
	
	var ADD_FILE = 'ADD_FILE';
	var REMOVE_FILE = 'REMOVE_FILE';
	
	var IMPORTING_FILE = 'IMPORTING_FILE';
	var IMPORTED_FILE = 'IMPORTED_FILE';
	var IMPORT_FILE_ERROR = 'IMPORT_FILE_ERROR';
	
	var initialState = (0, _immutable.Map)({});
	
	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, ADD_FILE, function (state, attrs, _ref) {
	  var action = _ref.action;
	  var createEvent = _ref.createEvent;
	  var id = attrs.id;
	
	  if (action.meta && action.meta.saveFile) createEvent('saveFile', attrs);
	  return state.set(id, (0, _immutable.Map)(attrs));
	}), (0, _defineProperty3.default)(_createReducer, REMOVE_FILE, function (state, id) {
	  return state.delete(id);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref2) {
	  var assets = _ref2.assets;
	
	  return state.merge(assets);
	}), _createReducer));
	
	function addFile(attrs, saveFile) {
	  return { type: ADD_FILE, payload: attrs, meta: { saveFile: saveFile } };
	};
	
	function removeFile(id) {
	  return { type: REMOVE_FILE, payload: id };
	};
	
	function urlsFor(file) {
	  return (0, _ramda.map)(function (host) {
	    return host + '/' + file.get('hash') + file.get('suffix') + '?filename=' + file.get('name');
	  }, (["https://d9t51ywbksa1j.cloudfront.net","https://editor.vimarket.io/resources"]));
	}
	
	function isLoading(id) {
	  return function (_ref3) {
	    var getIn = _ref3.getIn;
	    return getIn(['sceneIO', 'loadingFiles', id]);
	  };
	};
	
	function getImage(id) {
	  return images[id];
	};
	
	function getOrFetchImage(id) {
	  var attrs = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  return function (store) {
	    var file = store.getIn(['assets', id]);
	    if (!file) return;
	
	    return store.callApi((0, _assign2.default)({
	      types: [_actionTypes.LOADING_FILE, _actionTypes.LOADED_FILE, _actionTypes.LOADING_FILE_ERROR],
	      url: urlsFor(file),
	      contentType: 'img',
	      payload: id,
	      queryKey: 'IMAGE' + file.get('hash'),
	      fireAndForget: true
	    }, attrs));
	  };
	}
	
	function getOrFetchBinary(id) {
	  return function (store) {
	    var file = store.getIn(['assets', id]);
	    if (file.get('content')) {
	      return file.get('content');
	    } else {
	      return store.callApi({
	        types: [_actionTypes.LOADING_FILE, _actionTypes.LOADED_FILE, _actionTypes.LOADING_FILE_ERROR],
	        url: urlsFor(file),
	        contentType: 'binary',
	        payload: id,
	        queryKey: 'FILE' + file.get('hash'),
	        fireAndForget: true
	      });
	    }
	  };
	}
	
	function getHash(store, id) {
	  return store.getIn(['assets', id, 'hash']);
	};
	
	/**
	 * get the url for the asset.
	 *
	 * @public
	 * @param {String} id
	 * @returns {String} the url pointing to the asset.
	 *
	 */
	function getUrl(store, id) {
	  var asset = store.getIn(['assets', id]);
	  return asset && urlsFor(asset)[0];
	};
	
	function fetchText(hash) {
	  return function (store) {
	    return store.callApi({
	      contentType: 'text',
	      url: (0, _ramda.map)(function (host) {
	        return host + '/' + hash;
	      }, (["https://d9t51ywbksa1j.cloudfront.net","https://editor.vimarket.io/resources"]))
	    });
	  };
	};
	
	function fetchTransit(uuid) {
	  return function (store) {
	    return store.callApi({
	      contentType: 'text',
	      url: '/api/scenes/' + uuid
	    });
	  };
	};
	
	function find(store, fn) {
	  return store.get('assets').find(fn);
	};
	
	function filter(store, fn) {
	  return store.getIn(['assets']).filter(fn || function () {
	    return true;
	  });
	};
	
	function exportJSON(store) {
	  return store.getIn(['assets']).map(function (asset) {
	    var json = asset.toJS();
	    json._id = json.id;
	    delete json.id;
	    return json;
	  }).toArray();
	};
	
	function getActiveAssets(store) {
	  var sceneGraph = (0, _sceneGraph.getEvalSceneGraph)(store);
	  return filter(store, function (v, k) {
	    return !!sceneGraph.fileReferences.from[k];
	  });
	};
	
	function logBase(value, base) {
	  return Math.log(value) / Math.log(base);
	}
	function ceilPower2(value) {
	  return Math.pow(2, Math.ceil(logBase(value, 2)));
	}
	function clamp(value, min, max) {
	  return Math.max(min, Math.min(value, max));
	}
	
	function computeNewSize(imgInfo, maxSize) {
	  var newSize = {};
	  newSize.width = clamp(ceilPower2(imgInfo.width), 1, maxSize.width);
	  newSize.height = clamp(ceilPower2(imgInfo.height), 1, maxSize.height);
	  return newSize;
	};
	
	function resizeImage(file, maxWidth, maxHeight) {
	  return new _promise2.default(function (resolve, reject) {
	    var img = document.createElement("img");
	    var reader = new FileReader();
	    reader.onload = function (e) {
	      img.src = e.target.result;
	
	      img.onload = function () {
	        var canvas = document.createElement("canvas");
	        var ctx = canvas.getContext("2d");
	        ctx.drawImage(img, 0, 0);
	
	        var width = img.width;
	        var height = img.height;
	        var newSize = computeNewSize({ width: width, height: height }, { width: maxWidth, height: maxHeight });
	        canvas.width = newSize.width;
	        canvas.height = newSize.height;
	
	        var ctx2 = canvas.getContext("2d");
	        ctx2.drawImage(img, 0, 0, newSize.width, newSize.height);
	
	        resolve(canvas.toDataURL(file.type));
	      };
	    };
	    reader.readAsDataURL(file);
	  });
	}
	
	var MAX_IMG_SIZE = 4096;
	var NULL_SCENE_ID = exports.NULL_SCENE_ID = '00000000-0000-0000-0000-000000000000';
	
	/**
	 *
	 * This will upload an image, add an image node to the scene graph, and return
	 * an object with the id of the new node, and the id of the uploaded asset.
	 *
	 * If you save the assetId, that assetId can be passed into this function
	 * to get a new image node for the scene. That means you can restore the state of
	 * a scene without having to reimport the previous image.
	 *
	 * See [The demo example](tutorial-demo-ImportImage.html) for an example of usage.
	 *
	 * @public
	 * @param {(File|String)} image A [File](https://developer.mozilla.org/en/docs/Web/API/File) to import, an assetId from a previous import, or url src of image.
	 * @param {Object} options
	 * @param {Number} options.resizeTo A max width/height to resize the
	 *   image to (preserves aspect ratio of image)
	 * @returns Promise resolve to an object with `assetId` and `imageNodeId` keys
	 *
	 */
	function importImage(file) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  return function (store) {
	    function fetchAsset(uuid) {
	      return store.callApi({
	        types: [IMPORTING_FILE, IMPORTED_FILE, IMPORT_FILE_ERROR],
	        url: ("https://editor.vimarket.io/api") + '/files/' + uuid + '/asset'
	      });
	    }
	
	    function importImageURL(url) {
	      var body = (0, _stringify2.default)({
	        url: url,
	        maxSize: options.resizeTo || MAX_IMG_SIZE,
	        sceneId: NULL_SCENE_ID
	      });
	
	      return store.callApi({
	        types: [IMPORTING_FILE, IMPORTED_FILE, IMPORT_FILE_ERROR],
	        method: 'POST',
	        url: ("https://editor.vimarket.io/api") + '/files/image',
	        body: body
	      });
	    };
	
	    // Post to the server to create the image asset
	    function importImage(image) {
	      var body = (0, _stringify2.default)({
	        content: image,
	        name: file.name,
	        sceneId: NULL_SCENE_ID,
	        type: file.type
	      });
	
	      return importFile(store, { body: body });
	    }
	
	    // Add the asset to the store.
	    function addImageAsset(image) {
	      return store.dispatch(addFile((0, _assign2.default)({ id: image._id }, image)));
	    }
	
	    // Create the image node from given asset
	    function createImageNode(imageAsset) {
	      return store.dispatch((0, _sceneGraph.addNode)({
	        name: imageAsset.name || file.name,
	        type: 'Image',
	        parent: (0, _scene.find)(store, { name: 'Material Library' }),
	        plugs: {
	          Image: [['Image', { glBitmapFile: imageAsset.id, glOption: 1 }]],
	          Properties: [['ImageProperties', {}]]
	        }
	      })).then(function (imageNodeId) {
	        return {
	          imageNodeId: imageNodeId,
	          assetId: imageAsset.id,
	          imageSize: {
	            width: imageAsset.height,
	            height: imageAsset.width,
	            originalWidth: imageAsset.originalWidth,
	            originalHeight: imageAsset.originalHeight
	          }
	        };
	      });
	    }
	
	    if (typeof file === 'string') {
	      if ((0, _selectors.isUuid)(file)) {
	        return fetchAsset(file).then(addImageAsset).then(createImageNode);
	      } else {
	        return importImageURL(file).then(addImageAsset).then(createImageNode).catch(function (err) {
	          var errMessage = undefined;
	
	          if (err.status && err.status < 500) errMessage = 'Image not imported, bad url';else if (err.status && err.status >= 500) errMessage = 'Image not imported, internal error';else errMessage = err;
	
	          return _promise2.default.reject(errMessage);
	        });
	      }
	    }
	
	    if (!file.type) return _promise2.default.reject('Expect a File');
	    if (file.type !== 'image/jpeg' && file.type !== 'image/png') return _promise2.default.reject('File must be a jpg or png');
	
	    var max = options.resizeTo || MAX_IMG_SIZE;
	
	    return resizeImage(file, max, max).then(importImage).then(addImageAsset).then(createImageNode);
	  };
	}
	
	function importFile(store) {
	  var attrs = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  return store.callApi((0, _assign2.default)({
	    types: [IMPORTING_FILE, IMPORTED_FILE, IMPORT_FILE_ERROR],
	    method: 'POST',
	    url: ("https://editor.vimarket.io/api") + '/files'
	  }, attrs));
	}
	
	var publicApi = {
	  reducer: reducer,
	  actions: { addFile: addFile, removeFile: removeFile, importImage: importImage },
	  selectors: { _getHash: getHash, getUrl: getUrl, filter: filter, find: find, getActiveAssets: getActiveAssets, exportJSON: exportJSON }
	};
	exports.default = publicApi;

/***/ },
/* 145 */
/*!***************************************************!*\
  !*** ./~/babel-runtime/core-js/json/stringify.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/json/stringify */ 146), __esModule: true };

/***/ },
/* 146 */
/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/json/stringify.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(/*! ../../modules/_core */ 13)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 147 */
/*!******************************!*\
  !*** ./src/modules/scene.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.find = find;
	exports.filter = filter;
	exports.get = get;
	exports.getAll = getAll;
	exports.getEval = getEval;
	exports.getWorldTransform = getWorldTransform;
	exports.getRelativeTransform = getRelativeTransform;
	exports.getLocalTransform = getLocalTransform;
	exports.set = set;
	exports.setAll = setAll;
	exports.getWarnings = getWarnings;
	exports.setVRCamera = setVRCamera;
	exports.clone = clone;
	exports.pruneAssets = pruneAssets;
	exports.exportJSON = exportJSON;
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 102);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 142);
	
	var _assets = __webpack_require__(/*! ./assets */ 144);
	
	var _selectors = __webpack_require__(/*! ./utils/selectors */ 148);
	
	var _nonImmutable = __webpack_require__(/*! ../operators/nonImmutable */ 149);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * This module is a high level scene graph manipulation and query library.
	 *
	 * * Either id, name, or regex's can be used for node names.
	 * * All `get` functions return the value, or undefined if no match is found
	 * * All `find` functions return an `id` or a Path
	 * * All `filter` functions return an array of `id` or Path
	 * *
	 * @module scene
	 * @public
	 *
	 */
	
	/**
	 * Finds first matching node.
	 * If propertyName is specified, will look for the first matching operator,
	 * and if found, return a path to the operator property.
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @public
	 * @param {(String|QueryObject)} query The query object to filter on (or a string that gets converted to a query object).
	 *
	 * @example
	 *
	 * // Return the node uuid
	 * scene.find('Box'); -> 'uuid'
	 * // Return the path to the transform operator
	 * scene.find('Box','Transform','translation'); -> ['uuid','Transform',0]
	 * // Match the first node that starts with Box
	 * scene.find('Box*');
	 *
	 */
	function find(store, query, onlyNode) {
	  var queryObj = (0, _selectors.buildQueryObject)(query);
	  var sceneGraph = store.get('sceneGraph');
	
	  // Don't need to do a search if we have an id
	  if (queryObj.id) {
	    var foundNode = sceneGraph.nodes[queryObj.id];
	    if (foundNode && queryObj.parent) {
	      return foundNode.parent || null;
	    }
	    if (foundNode && queryObj.child) {
	      return (0, _selectors.findChild)(store, foundNode, { type: queryObj.child, shallow: true }, false, true) || null;
	    }
	    return foundNode ? (0, _selectors.getMatch)(foundNode, queryObj, onlyNode) : null;
	  }
	
	  // If we ask to search `all`, then we do a linear search. This lets us
	  // find nodes from scenes not in the active scene graph.
	  if (queryObj.from && queryObj.from.all) {
	    var result = undefined;
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(sceneGraph.nodes)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var id = _step.value;
	
	        result = (0, _selectors.getMatch)(sceneGraph.nodes[id], queryObj);
	        if (result) return result;
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    return null;
	  }
	
	  var rootId = queryObj.from ? find(store, queryObj.from, true) : store.getIn(['sceneIO', 'id']);
	  var rootNode = rootId && sceneGraph.nodes[rootId];
	
	  return rootNode ? (0, _selectors.findChild)(store, rootNode, queryObj, queryObj.includeParent && rootNode, onlyNode) : null;
	};
	
	function matchSceneNode(store, queryObj, onlyNode) {
	  var node = store.getIn('sceneGraph').nodes[store.getIn(['sceneIO', 'id'])];
	  return node && (0, _selectors.getMatch)(node, queryObj, onlyNode) || null;
	};
	
	/**
	 * This function will iterate through the scene graph, returning an array
	 * of all elements that match the parameters provided.
	 *
	 * The return value of this function will either be an array of ids (if nodequery and
	 * plug are provied), or an array of paths (if property is provided).
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @public
	 * @param {(String|QueryObject)} query The query object to filter on (or a string that gets converted to a query object).
	 * @returns {Array}
	 */
	function filter(store, query) {
	  var queryObj = (0, _selectors.buildQueryObject)(query);
	  var fromId = queryObj.from ? find(store, queryObj.from) : store.getIn(['sceneIO', 'id']);
	
	  // No matching from query, return empty search
	  if (queryObj.from && !fromId) return [];
	
	  var fromNode = store.get('sceneGraph').nodes[fromId];
	
	  if (!fromNode) {
	    throw new Error('Unknown node to filter from');
	  }
	
	  return (0, _selectors.matchChildren)(store, fromNode, queryObj, queryObj.includeParent && fromNode);
	};
	
	/**
	 * Returns the value at the matching property.
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @param {(String|QueryObject|Path)} query The query object to filter on (or a string that gets converted to a query object).
	 * @returns {any}
	 * @public
	 */
	function get(store, query) {
	  var path = Array.isArray(query) ? query : find(store, query);
	  if (!path || !Array.isArray(path)) return undefined;
	  if (path.length >= 2 && path[1] === 'eval') {
	    var evalNode = (0, _sceneGraph.getEvalSceneGraph)(store).evaluatedNodes[path[0]];
	    var evalPlug = evalNode && evalNode[path[2]];
	    return evalPlug && path[3] ? evalPlug[path[3]] : evalPlug;
	  }
	  return (0, _sceneGraph.get)(store, path);
	};
	
	/**
	 * Returns an array of values for the matching properties
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @param {(String|QueryObject|Path)} query The query object to filter on (or a found path)
	 * @returns {any[]}
	 * @public
	 */
	function getAll(store, query) {
	  var paths = Array.isArray(query) ? query : filter(store, query);
	  return paths ? (0, _ramda.reduce)(function (obj, path) {
	    obj[path[0]] = (0, _sceneGraph.get)(store, path);
	    return obj;
	  }, {}, paths) : undefined;
	};
	
	/**
	 * Returns the evaluated plug (and/or property).
	 * @param {String} nodeId id of the node
	 * @param {String} plug
	 * @param {?String} key
	 *
	 * @example
	 *
	 * // Return the calculated transform
	 * ctx.getEval('Box','Transfrom','translation');
	 * // Return the orbitTarget for the scene camera
	 * ctx.getEval(true, 'Player', 'orbitTarget');
	 */
	function getEval(store, nodeId, plug, key) {
	  return get(store, key ? [nodeId, plug, key] : [nodeId, plug]);
	};
	
	/**
	 * Get the world transform for a node.
	 *
	 * @param {String} id
	 * @public
	 * @returns {?THREE.Matrix4}
	 */
	function getWorldTransform(store, id) {
	  var transform = get(store, { id: id, evalPlug: 'Transform' });
	  if (!transform) return null;
	
	  var localTransform = transform.transform;
	  var node = store.get('sceneGraph').nodes[id];
	  var parent = node && node.parent;
	
	  var parentTransform = parent && getWorldTransform(store, parent);
	  return parentTransform ? new _three2.default.Matrix4().copy(parentTransform).multiply(localTransform) : new _three2.default.Matrix4().copy(localTransform);
	}
	
	/**
	 * Get the transform for a node relative to a specified ancestor node. If rootId is not in id's
	 *  ancestry, the result is simply the world transform.
	 *
	 * @param {String} id
	 * @param {String} rootId - the node for which we want to calculated id's relative transform from
	 * @public
	 * @returns {?THREE.Matrix4}
	 */
	function getRelativeTransform(store, id, rootId) {
	  var transform = get(store, { id: id, evalPlug: 'Transform' });
	  if (!transform || id === rootId) return null;
	
	  var localTransform = transform.transform;
	  var node = store.get('sceneGraph').nodes[id];
	  var parent = node && node.parent;
	  var parentTransform = parent && getRelativeTransform(store, parent, rootId);
	  return parentTransform ? new _three2.default.Matrix4().copy(parentTransform).multiply(localTransform) : new _three2.default.Matrix4().copy(localTransform);
	}
	
	/**
	 * Get the local transform for a node.
	 *
	 * @returns {?THREE.Matrix4}
	 */
	function getLocalTransform(transform) {
	  var translation = transform.translation;
	  var rotation = transform.rotation;
	  var scale = transform.scale;
	  var rotateOrder = transform.rotateOrder;
	  var preRotation = transform.preRotation;
	  var rotatePivotOffset = transform.rotatePivotOffset;
	  var localRotatePivot = transform.localRotatePivot;
	  var scalePivotOffset = transform.scalePivotOffset;
	  var localScalePivot = transform.localScalePivot;
	  var shear = transform.shear;
	
	  if (scale.x === 0) scale.x = 0.0000001;
	  if (scale.y === 0) scale.y = 0.0000001;
	  if (scale.z === 0) scale.z = 0.0000001;
	  var zero = new _three2.default.Vector3(0, 0, 0);
	
	  var matrixStack = [];
	
	  var translationM = new _three2.default.Matrix4().makeTranslation(translation.x, translation.y, translation.z);
	  matrixStack.push(translationM);
	
	  var rotatePivotOffestM = new _three2.default.Matrix4();
	  if (!rotatePivotOffset.equals(zero)) {
	    rotatePivotOffestM.makeTranslation(rotatePivotOffset.x, rotatePivotOffset.y, rotatePivotOffset.z);
	    matrixStack.push(rotatePivotOffestM);
	  }
	
	  var localRotatePivotM = new _three2.default.Matrix4();
	  var invLocalRotatePivotM = new _three2.default.Matrix4();
	  var localRotatePivotFlag = false;
	  if (!localRotatePivot.equals(zero)) {
	    localRotatePivotM.makeTranslation(localRotatePivot.x, localRotatePivot.y, localRotatePivot.z);
	    matrixStack.push(localRotatePivotM);
	    invLocalRotatePivotM.getInverse(localRotatePivotM, true);
	    localRotatePivotFlag = true;
	  }
	
	  var preRotationM = new _three2.default.Matrix4();
	  if (!preRotation.equals(zero)) {
	    var localRotationRadians = new _three2.default.Vector3().copy(preRotation).multiplyScalar(Math.PI / 180);
	    preRotationM.makeRotationFromEuler(new _three2.default.Euler(localRotationRadians.x, localRotationRadians.y, localRotationRadians.z, rotateOrder));
	    matrixStack.push(preRotationM);
	  }
	
	  var rotationRadians = new _three2.default.Vector3().copy(rotation).multiplyScalar(Math.PI / 180);
	  var rotationM = new _three2.default.Matrix4().makeRotationFromEuler(new _three2.default.Euler(rotationRadians.x, rotationRadians.y, rotationRadians.z, rotateOrder));
	  matrixStack.push(rotationM);
	
	  if (localRotatePivotFlag) matrixStack.push(invLocalRotatePivotM);
	
	  var scalePivotOffsetM = new _three2.default.Matrix4();
	  if (!scalePivotOffset.equals(zero)) {
	    scalePivotOffsetM.makeTranslation(scalePivotOffset.x, scalePivotOffset.y, scalePivotOffset.z);
	    matrixStack.push(scalePivotOffsetM);
	  }
	
	  var localScalePivotM = new _three2.default.Matrix4();
	  var invLocalScalePivotM = new _three2.default.Matrix4();
	  var localScalePivotFlag = false;
	  if (!localScalePivot.equals(zero)) {
	    localScalePivotM.makeTranslation(localScalePivot.x, localScalePivot.y, localScalePivot.z);
	    matrixStack.push(localScalePivotM);
	    invLocalScalePivotM.getInverse(localScalePivotM, true);
	    localScalePivotFlag = true;
	  }
	
	  var sX = shear.x,
	      sY = shear.y,
	      sZ = shear.z;
	  var shearM = new _three2.default.Matrix4().set(1, sX, sY, 0, 0, 1, sZ, 0, 0, 0, 1, 0, 0, 0, 0, 1); //.makeShear(new THREE.Vector3(0, 0, 0));
	  matrixStack.push(shearM);
	
	  var scaleM = new _three2.default.Matrix4().makeScale(scale.x, scale.y, scale.z);
	  matrixStack.push(scaleM);
	
	  if (localScalePivotFlag) matrixStack.push(invLocalScalePivotM);
	
	  return new _three2.default.Matrix4().multiplyMatricesList(matrixStack);
	}
	
	/**
	 * Sets the property at path to value.
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @param {(Path|QueryObject|String)} query The query object to filter on (or a string that gets converted to a query object).
	 * @param {any} value The value to set, the type must match the property being set.
	 * @public
	 */
	function set(query, value) {
	  return function (store) {
	    var path = Array.isArray(query) ? query : find(store, query);
	    if (!path) return console.warn('No matching query', query);
	    if (path.length === 3) {
	      if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== 'object') throw new Error('If no property is set, expect an object to merge into the operator');
	      return store.dispatch((0, _sceneGraph.merge)(path, value));
	    } else if (path.length === 4) {
	      return store.dispatch((0, _sceneGraph.set)(path, value));
	    } else if (path.length === 2) {
	      if (path[1] !== 'name') throw new Error('Can only set node name');
	      return store.dispatch((0, _sceneGraph.set)(path, value));
	    }
	  };
	};
	
	/**
	 * Given an array of paths, will set the `value` on each path.
	 * This can be combined with `find` to set a number of properties at once.
	 *
	 * (See {@tutorial sdk-SceneGraph})
	 *
	 * @public
	 * @param {(Path[]|QueryObject|String)} query An array of path arrays, or a QueryObject
	 * @param {any} value The value to set the properties to.
	 *
	 * @example
	 *
	 * // Move all boxes to the origin
	 * const paths = ctx.find('Box*', 'Transform', 'translation');
	 * setAll(paths, {x: 0, y: 0, z: 0});
	 *
	 */
	function setAll(query, value) {
	  //if (!Array.isArray(paths)) return Promise.reject('paths must be an array');
	  return function (store) {
	    var paths = Array.isArray(query) ? query : filter(store, query);
	    //console.log('ctx.setAll', paths, value);
	    return _promise2.default.all((0, _ramda.map)(function (path) {
	      return store.dispatch(set(path, value));
	    }, paths));
	  };
	};
	
	/*
	 * Returns an array of nodes with warnings in the scene graph.
	 * @private
	 */
	function getWarnings(store) {
	  var sceneGraph = store.get('sceneGraph');
	  var nodeIds = (0, _keys2.default)(sceneGraph.nodes);
	  var node = undefined;
	  var warningNodes = [];
	  for (var i = 0; i < nodeIds.length; i++) {
	    node = sceneGraph.nodes[nodeIds[i]];
	    if (node && node.warnings && node.warnings.length) warningNodes.push(node);
	  }
	  return warningNodes;
	}
	
	function setVRCamera(query) {
	  return function (store) {
	    query.type = 'Camera';
	    var newVRCamera = find(store, query);
	    store.dispatch((0, _sceneGraph.setVRCamera)(newVRCamera));
	  };
	}
	
	/**
	 * Given a query, clone these nodes. Without options, these nodes will be cloned
	 * in place
	 *
	 * @public
	 * @param {(QueryObject|String|Path[])} query A list of nodes (from filter), or query that will find a list of nodes to clone
	 * @param {Object} options
	 * @param {String?} options.to The scene being cloned to (default is the active scene)
	 * @param {String?} options.withNull Add a null to clone the nodes to
	 * @param {Object?} options.includeDependencies Clone dependencies (default true)
	 *
	 * @example
	 *
	 * // Clone all nodes from Objects on import scene into active scene
	 * scene.clone({from: {id: importId, child: 'Objects'}});
	 *
	 * // Clone children of a null to a new null
	 * scene.clone({from: {id: importId, child: 'Objects'}}, {withNull: 'New Parent Null'});
	 *
	 * // Clone children, without also cloning dependencies.
	 *
	 *
	 * // Return the path to the transform operator
	 * scene.find('Box','Transform','translation'); -> ['uuid','Transform',0]
	 * // Match the first node that starts with Box
	 * scene.find('Box*');
	 *
	 */
	function clone(query) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  if (options.cloneDependencies === undefined) options.cloneDependencies = true;
	
	  return function (store) {
	    var _nodeMap;
	
	    var paths = Array.isArray(query) ? query : filter(store, query);
	    if (!paths.length) {
	      console.warn('No match for clone: ', query);
	      return _promise2.default.resolve(true);
	    }
	
	    var fromSceneId = (0, _sceneGraph.findRoot)(store, paths[0]);
	    var toSceneId = options.to || store.getIn(['sceneIO', 'id']);
	    var fromObjectsId = find(store, { id: fromSceneId, child: 'Objects' });
	    var toObjectsId = find(store, { id: toSceneId, child: 'Objects' });
	
	    var nodeMap = (_nodeMap = {}, (0, _defineProperty3.default)(_nodeMap, fromObjectsId, toObjectsId), (0, _defineProperty3.default)(_nodeMap, find(store, { id: fromSceneId, child: 'MaterialLibrary' }), find(store, { id: toSceneId, child: 'MaterialLibrary' })), _nodeMap);
	
	    var nullNode = options.withNull ? store.dispatch((0, _sceneGraph.addNode)({
	      name: options.withNull,
	      parent: toObjectsId,
	      type: 'Null',
	      plugs: {
	        Null: [['Null', {}]],
	        Transform: [['Transform', {}]],
	        Properties: [['Default', {}]]
	      }
	    })) : _promise2.default.resolve(null);
	
	    return nullNode.then(function (nullNodeId) {
	      if (nullNodeId) nodeMap[fromObjectsId] = nullNodeId;
	      return store.dispatch((0, _sceneGraph.clone)(paths, nodeMap, { cloneDependencies: options.cloneDependencies })).then(function (cloneMap) {
	        if (nullNodeId) cloneMap[options.withNull] = nullNodeId;
	        return cloneMap;
	      });
	    });
	  };
	}
	function pruneAssets() {
	  return function (store) {
	    var sceneGraph = store.get('sceneGraph');
	    var usedAssets = {};
	    var nodes = filter(store, { includeParent: true });
	
	    function storeFileRefs(id) {
	      var plugs = sceneGraph.nodes[id] && sceneGraph.nodes[id].plugs;
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        var _loop = function _loop() {
	          var plugName = _step2.value;
	
	          plugs[plugName].forEach(function (op, opIdx) {
	            var operator = (0, _nonImmutable.lookupOperator)(plugName, op.type, []);
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	              for (var _iterator3 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                var refKey = _step3.value;
	
	                if (op[refKey]) usedAssets[op[refKey]] = true;
	              }
	            } catch (err) {
	              _didIteratorError3 = true;
	              _iteratorError3 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                  _iterator3.return();
	                }
	              } finally {
	                if (_didIteratorError3) {
	                  throw _iteratorError3;
	                }
	              }
	            }
	          });
	        };
	
	        for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(plugs || {})), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          _loop();
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    };
	
	    nodes.forEach(storeFileRefs);
	
	    return _promise2.default.all((0, _assets.filter)(store).map(function (asset) {
	      return !usedAssets[asset.get('id')] && store.dispatch((0, _assets.removeFile)(asset.get('id')));
	    }));
	  };
	}
	
	function exportJSON(store, sceneId) {
	  var _sceneId = sceneId || store.getIn(['sceneIO', 'id']);
	
	  var nodes = filter(store, { from: { id: _sceneId }, includeParent: true });
	  return {
	    sceneGraph: (0, _sceneGraph.exportJSON)(store, nodes),
	    assets: (0, _assets.exportJSON)(store)
	  };
	};
	
	var publicApi = {
	  actions: { set: set, setAll: setAll, clone: clone, pruneAssets: pruneAssets, setVRCamera: setVRCamera },
	  selectors: { get: get, getAll: getAll, getWorldTransform: getWorldTransform, find: find, filter: filter, getWarnings: getWarnings, exportJSON: exportJSON }
	};
	
	exports.default = publicApi;

/***/ },
/* 148 */
/*!****************************************!*\
  !*** ./src/modules/utils/selectors.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isUuid = isUuid;
	exports.buildQueryObject = buildQueryObject;
	exports.getMatch = getMatch;
	exports.matchChildren = matchChildren;
	exports.findChild = findChild;
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 113);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
	
	/**
	 * Test whether a string is a uuid or not.
	 * @param {String} id
	 */
	function isUuid(id) {
	  return uuidRegex.test(id);
	};
	
	function pathToRegExp(query) {
	  if (query instanceof RegExp) return query;
	  query = query.replace(/\*/g, '(.*)').replace(/^\"|\"$/g, "");
	  return new RegExp('^' + query + '$', 'i');
	};
	
	var re = {
	  bareName: "^([^!%\[#:]*)*", // Match the name, up to % or #
	  type: "(?:\%([^#!:]*))*", // Match the type
	  filter: "(?::([^#:]*))*", // Any filter?
	  evalPlug: "(?:\!([^#\[]*))*", // Evaluated plug name
	  plugName: "(?:\#([^\[]*))*", // Plug name
	  attrs: "(.*)" // Any attribute selectors (entire match)
	};
	
	var queryRegex = new RegExp(re.bareName + re.type + re.filter + re.evalPlug + re.plugName + re.attrs);
	
	var queryRegexNoName = new RegExp("()" + re.type + re.filter + re.evalPlug + re.plugName + re.attrs);
	
	var attrsRegex = /(?:\[([^\]]*)\])/g;
	
	/*
	 * Parse "[translation][name='Transform']" and turn it into
	 * operator/property/properties fields for matching.
	 */
	function parseOperatorAttributes(attrsString) {
	  // Take "[translation][name='Transform']" and convert it into
	  // a filter function that will match the specific operator
	  var items, match;
	
	  var property = undefined;
	  var properties = undefined;
	
	  while ((match = attrsRegex.exec(attrsString)) !== null) {
	    items = match[1].split('=');
	    if (items.length === 2) {
	      if (!properties) properties = {};
	      properties[items[0]] = items[1];
	    } else {
	      property = items[0];
	    }
	  }
	
	  return { property: property, properties: properties };
	};
	
	function buildQueryObjectFromString(query) {
	  // Support looking for the active scene node with '~'.
	  var scene = query[0] === '~';
	  var quotedIdx = !scene && query[0] === '"' && query.slice(1).indexOf('"');
	  var quotedName = quotedIdx && quotedIdx !== -1;
	
	  var matches = quotedName || scene ? queryRegexNoName.exec(query.slice(scene ? 1 : quotedIdx + 2)) : queryRegex.exec(query);
	  var name = quotedName ? query.slice(1, quotedIdx + 1) : scene ? false : matches[1];
	  var type = matches[2];
	  var filter = matches[3];
	  var evalPlug = matches[4];
	  var plug = matches[5];
	  var attrs = matches[6];
	  var id = isUuid(name) ? name : undefined;
	  return (0, _extends3.default)({ scene: scene, id: id, name: id || !name ? undefined : pathToRegExp(name),
	    type: type, filter: filter, evalPlug: evalPlug, plug: plug }, parseOperatorAttributes(attrs), { includeParent: true });
	};
	
	/**
	 * Takes a query string, and returns an object with the attributes we are looking
	 * for.
	 */
	function buildQueryObject(query) {
	  if (typeof query === 'string') return buildQueryObjectFromString(query);
	  if ((typeof query === 'undefined' ? 'undefined' : (0, _typeof3.default)(query)) === 'object') {
	    //if (typeof query.name === 'string' && query.name.indexOf('*') !== -1)
	    return (0, _assign2.default)({}, query, {
	      name: query.name ? pathToRegExp(query.name) : undefined,
	      // include parent by default if no from query is specified
	      includeParent: query.includeParent === undefined ? !query.from : query.includeParent
	    });
	  }
	  return {};
	}
	
	/*
	 * Given a QueryObject, will return a matching path for this node, or
	 * null if the node does not match.
	 */
	function getMatch(node, queryObj, onlyNode) {
	  var nodeMatch = getNodeMatch(node, queryObj);
	  return !nodeMatch ? null : onlyNode ? nodeMatch.id : matchInside(node, queryObj);
	}
	
	/*
	 * Given a QueryObject, will return the node if the node matches the
	 * node query parameters (id, name, type).
	 */
	function getNodeMatch(node, queryObj) {
	  if (queryObj.id !== undefined && queryObj.id !== node.id) return null;
	  if (queryObj.name !== undefined && !queryObj.name.test(node.name)) return null;
	  if (queryObj.type !== undefined) {
	    if (typeof queryObj.type === 'string') {
	      if (queryObj.type !== node.type) return null;
	    } else if (Array.isArray(queryObj.type)) {
	      if (!(0, _ramda.contains)(node.type, queryObj.type)) return null;
	    }
	  }
	  if (queryObj.hasPlug !== undefined && !node.plugs[queryObj.hasPlug]) return null;
	
	  return node;
	};
	
	function matchInside(node, queryObj) {
	  var properties = queryObj.properties;
	  var property = queryObj.property;
	  var operator = queryObj.operator;
	  var operatorIndex = queryObj.operatorIndex;
	
	  if (queryObj.evalPlug) {
	    return property ? [node.id, 'eval', queryObj.evalPlug, property] : [node.id, 'eval', queryObj.evalPlug];
	  }
	
	  if (!queryObj.plug) {
	    if (property === 'name' || property === 'type') {
	      return [node.id, property];
	    }
	    return node.id;
	  }
	
	  var plug = node.plugs[queryObj.plug];
	  if (!plug) return null;
	
	  var propKeys = properties && (0, _keys2.default)(properties);
	
	  if (!properties && !property && !operator && operatorIndex === undefined) {
	    return node.id; // No operator query provided.
	  }
	  var idx = queryObj.operatorIndex !== undefined ? queryObj.operatorIndex : (0, _ramda.findIndex)(function (op) {
	    return (property ? op.hasOwnProperty(property) : true) && (properties ? (0, _ramda.all)(function (k) {
	      return op[k] === properties[k];
	    }, propKeys) : true);
	  }, plug);
	
	  if (idx === -1) return null;
	  return property ? [node.id, queryObj.plug, idx, property] : [node.id, queryObj.plug, idx];
	};
	
	function matchChildren(store, node, queryObj, parentNodeToMatch) {
	  var results = [];
	  var sceneGraph = store.get('sceneGraph');
	
	  var parentMatch = parentNodeToMatch && getMatch(parentNodeToMatch, queryObj);
	  if (parentMatch) results.push(parentMatch);
	
	  (0, _ramda.forEach)(function (childId) {
	    var childNode = sceneGraph.nodes[childId];
	    if (!childNode) throw new Error('Invalid child for \'' + node.get('name') + '\' - ' + childId);
	
	    var match = getMatch(childNode, queryObj);
	    if (match) results.push(match);
	    if (!queryObj.shallow) {
	      results = results.concat(matchChildren(store, childNode, queryObj));
	    }
	  }, node.children || []);
	
	  return results;
	};
	
	function findChild(store, node, queryObj, parentNodeToMatch, onlyNode) {
	  var result = undefined;
	  if (parentNodeToMatch) {
	    result = getMatch(parentNodeToMatch, queryObj, onlyNode);
	    if (result) return result;
	  }
	  var sceneGraph = store.get('sceneGraph');
	  var match = (0, _ramda.find)(function (childId) {
	    var childNode = sceneGraph.nodes[childId];
	    result = getMatch(childNode, queryObj, onlyNode);
	    if (result) return true;
	    result = !queryObj.shallow && findChild(store, childNode, queryObj, null, onlyNode);
	    if (result) return true;
	  }, node.children || []);
	  return match ? result : null;
	};

/***/ },
/* 149 */
/*!***************************************!*\
  !*** ./src/operators/nonImmutable.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.lookupOperator = lookupOperator;
	
	var _makeAllOperatorsNonImmutable = __webpack_require__(/*! ./makeAllOperatorsNonImmutable */ 150);
	
	var _makeAllOperatorsNonImmutable2 = _interopRequireDefault(_makeAllOperatorsNonImmutable);
	
	var _Annotation = __webpack_require__(/*! ./Annotation */ 152);
	
	var _Annotation2 = _interopRequireDefault(_Annotation);
	
	var _BinMesh = __webpack_require__(/*! ./BinMesh */ 153);
	
	var _BinMesh2 = _interopRequireDefault(_BinMesh);
	
	var _Camera = __webpack_require__(/*! ./Camera */ 200);
	
	var _Camera2 = _interopRequireDefault(_Camera);
	
	var _Environment = __webpack_require__(/*! ./Environment */ 201);
	
	var _Environment2 = _interopRequireDefault(_Environment);
	
	var _Image = __webpack_require__(/*! ./Image */ 202);
	
	var _Image2 = _interopRequireDefault(_Image);
	
	var _Light = __webpack_require__(/*! ./Light */ 204);
	
	var _Light2 = _interopRequireDefault(_Light);
	
	var _Material = __webpack_require__(/*! ./Material */ 205);
	
	var _Material2 = _interopRequireDefault(_Material);
	
	var _Player = __webpack_require__(/*! ./Player */ 206);
	
	var _Player2 = _interopRequireDefault(_Player);
	
	var _PolyMesh = __webpack_require__(/*! ./PolyMesh */ 207);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _Properties = __webpack_require__(/*! ./Properties */ 251);
	
	var _Properties2 = _interopRequireDefault(_Properties);
	
	var _Transform = __webpack_require__(/*! ./Transform */ 252);
	
	var _Transform2 = _interopRequireDefault(_Transform);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NoOp = { schema: {} };
	
	var Bone = { Bone: NoOp };
	var Null = { Null: NoOp };
	var Pass = { Pass: NoOp };
	var Mixer = { Action: NoOp, Mixer: NoOp };
	var Renderer = { 'vray/create': NoOp, WebGLRenderer: NoOp };
	var Timeline = { Timeline: NoOp };
	var GeneralRenderer = { GeneralRenderer: NoOp };
	var Viewport = { Viewport: NoOp };
	
	var records = (0, _makeAllOperatorsNonImmutable2.default)({
	  Annotation: _Annotation2.default, BinMesh: _BinMesh2.default, Bone: Bone, Camera: _Camera2.default, Environment: _Environment2.default, GeneralRenderer: GeneralRenderer, Light: _Light2.default, Material: _Material2.default,
	  Mixer: Mixer, Null: Null, Pass: Pass, Player: _Player2.default, PolyMesh: _PolyMesh2.default, Properties: _Properties2.default,
	  Renderer: Renderer, Timeline: Timeline, Transform: _Transform2.default, Image: _Image2.default, Viewport: Viewport
	}, { withNone: true });
	
	function lookupOperator(plugName, type, warnings) {
	  var plug = records[plugName];
	  if (!plug) {
	    warnings.push('Unknown plug: ' + plugName);
	    return records.None.NoOp;
	  }
	  var operator = plug[type];
	  if (!operator) {
	    warnings.push('Unknown Operator: ' + plugName + ', ' + type);
	    return records.None.NoOp;
	  }
	  return operator;
	}
	
	exports.default = records;

/***/ },
/* 150 */
/*!*******************************************************!*\
  !*** ./src/operators/makeAllOperatorsNonImmutable.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = makeAllOperators;
	
	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 102);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _schemaTypes = __webpack_require__(/*! ./schemaTypes */ 151);
	
	var _schemaTypes2 = _interopRequireDefault(_schemaTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function makeAllOperators(hierarchy, _ref) {
	  var withNone = _ref.withNone;
	
	  var records = (0, _ramda.mapObjIndexed)(function (ops, plug) {
	    return (0, _ramda.mapObjIndexed)(function (op, name) {
	      return makeOperator(plug, op, name);
	    }, ops);
	  }, hierarchy);
	  if (withNone) records.None = { NoOp: makeOperator('None', { schema: {} }, 'NoOp') };
	  return records;
	};
	
	function makeOperator(plug, op, name) {
	  var fileReferenceKeys = [];
	  var referenceKeys = [];
	  var nodeReferenceKeys = [];
	  var nodeReferenceListKeys = [];
	  var plugReferences = {};
	
	  var props = (0, _ramda.mapObjIndexed)(function (info, key) {
	    var prop = _schemaTypes2.default[info.type] ? (0, _assign2.default)({ type: info.type, schema: info }, _schemaTypes2.default[info.type](info)) : { set: function set(v) {
	        return v;
	      } };
	
	    if (prop.isFileReference) fileReferenceKeys.push(key);
	    if (prop.isNodeReference) {
	      nodeReferenceKeys.push(key);
	      referenceKeys.push(key);
	    }
	    if (prop.isPlugReference) {
	      plugReferences[key] = prop.isPlugReference;
	      referenceKeys.push(key);
	    }
	    if (prop.isReferenceList) nodeReferenceListKeys.push(key);
	
	    return prop;
	  }, op.schema);
	
	  var keys = (0, _keys2.default)(props);
	
	  return {
	    keys: keys,
	    referenceKeys: referenceKeys,
	    fileReferenceKeys: fileReferenceKeys,
	    nodeReferenceKeys: nodeReferenceKeys,
	    nodeReferenceListKeys: nodeReferenceListKeys,
	    plugReferences: plugReferences,
	    environment: op.environment,
	
	    getProperties: function getProperties() {
	      return props;
	    },
	    typeOf: function typeOf(key) {
	      return op.schema[key] && op.schema[key].type;
	    },
	    set: function set(data, key, val) {
	      data[key] = props[key] ? props[key].set(val) : val;
	      return data[key];
	    },
	
	    /*
	    equals(data1, data2) {
	      //return (JSON.stringify(data1) === JSON.stringify(data2));
	      let isEqual = true;
	       for(let key in keys){
	        if(data1.hasOwnProperty(key) &&
	          ((data1[key].equals && !data1[key].equals(data2)) ||
	          (data1[key] !== data2[key]))){
	            isEqual = false;
	            break;
	        }
	      }
	      return isEqual;
	    },
	    */
	
	    export: function _export(data) {
	      // This could be written to remove default keys
	      return (0, _assign2.default)({}, data, {
	        name: name, primitive: plug
	      });
	    },
	    get: function get(data, key) {
	      return props[key] && props[key].get ? props[key].get(data[key]) : data[key];
	    },
	    init: function init(type) {
	      var initAttrs = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	      var name = arguments[2];
	
	      var result = { type: type, name: name || type };
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = (0, _getIterator3.default)(keys), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value;
	
	          result[key] = props[key].set(initAttrs[key]); //props.set(result, key, props[key]);
	        }
	        //result._v = 1;
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return result;
	    },
	    update: function update(data, primitive, options) {
	      var newPrimitive = op.update ? op.update.call(op, data, primitive, options) : (0, _assign2.default)(primitive, data);
	      var result = newPrimitive || primitive;
	
	      if (!result.nodeId) result.nodeId = options.node.id;
	      if (!result.id) result.id = options.node.id;
	      result._v = options.node._v;
	      return result;
	    }
	  };
	}

/***/ },
/* 151 */
/*!**************************************!*\
  !*** ./src/operators/schemaTypes.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 145);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//import { FileReference, NodeReference, PlugReference, Vec2, Vec3, Color} from './primitives';
	
	function initVector3(from) {
	  if (!from) return new _three.Vector3();
	  if (from instanceof _three.Vector3) return from;
	  if (from.hasOwnProperty('x')) return new _three.Vector3(from.x, from.y, from.z);
	  if (Array.isArray(from)) return new _three.Vector3(from[0], from[1], from[2]);
	  return new _three.Vector3();
	};
	
	function initVector2(from) {
	  if (!from) return new _three.Vector2();
	  if (from instanceof _three.Vector2) return from;
	  if (from.hasOwnProperty('x')) return new _three.Vector2(from.x, from.y);
	  if (Array.isArray(from)) return new _three.Vector2(from[0], from[1]);
	  return new _three.Vector2();
	};
	
	function initColor(from) {
	  if (!from) return new _three.Color();
	  if (Array.isArray(from)) return new _three.Color(from[0], from[1], from[2]);
	  if (from.hasOwnProperty('r')) return new _three.Color(from.r, from.g, from.b, from.a);
	  return new _three.Color();
	}
	
	var schemaTypes = {
	  'Boolean': function Boolean(schema) {
	    var defaultValue = schema.defaultValue || false;
	
	    return {
	      defaultValue: defaultValue,
	
	      set: function set(val) {
	        return val == null ? defaultValue : !!val;
	      }
	    };
	  },
	
	  'Label': function Label(schema) {
	    return { set: function set(val) {
	        return val;
	      } };
	  },
	
	  'Number': (function (_Number) {
	    function Number(_x) {
	      return _Number.apply(this, arguments);
	    }
	
	    Number.toString = function () {
	      return _Number.toString();
	    };
	
	    return Number;
	  })(function (schema) {
	    var min = schema.minValue;
	    var max = schema.maxValue;
	    var defaultValue = schema.defaultValue || 0;
	
	    var clamp = undefined;
	
	    if (min !== undefined && max !== undefined) clamp = function (v) {
	      return Math.min(Math.max(min, v), max);
	    };else if (min !== undefined) clamp = function (v) {
	      return Math.max(v, min);
	    };else if (max !== undefined) clamp = function (v) {
	      return Math.min(v, max);
	    };else clamp = function (v) {
	      return v;
	    };
	
	    return {
	      defaultValue: defaultValue,
	
	      set: function set(val) {
	        var num = Number(val);
	        if (isNaN(num)) return defaultValue;
	        return Math.round(clamp(num) * 10000) / 10000;
	      }
	    };
	  }),
	
	  'Integer': function Integer(schema) {
	    var min = schema.minValue;
	    var max = schema.maxValue;
	    var defaultValue = schema.defaultValue || 0;
	
	    var clamp = undefined;
	
	    if (min !== undefined && max !== undefined) clamp = function (v) {
	      return Math.min(Math.max(min, v), max);
	    };else if (min !== undefined) clamp = function (v) {
	      return Math.max(v, min);
	    };else if (max !== undefined) clamp = function (v) {
	      return Math.min(v, max);
	    };else clamp = function (v) {
	      return v;
	    };
	
	    return {
	      defaultValue: defaultValue,
	
	      set: function set(val) {
	        var num = Number(val);
	        if (isNaN(num)) return defaultValue;
	        return parseInt(clamp(num));
	      }
	    };
	  },
	
	  'Plug': function Plug(schema) {
	    if (!schema.plug) throw new Error("plug property expects a `plug` property");
	
	    return {
	      isPlugReference: schema.plug,
	
	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id;
	      }
	    };
	  },
	
	  'Options': function Options(schema) {
	    var defaultValue = schema.defaultValue;
	    return {
	      defaultValue: defaultValue,
	
	      set: function set(val) {
	        return val == null ? defaultValue : val;
	      }
	    };
	  },
	
	  'Image': function Image(schema) {
	    return {
	      isFileReference: true,
	
	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id; // ? FileReference({id}) : null;
	      }
	    };
	  },
	
	  'Binary': function Binary(schema) {
	    return {
	      isFileReference: true,
	
	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id; // ? FileReference({id}) : null;
	      }
	    };
	  },
	
	  'File': function File(schema) {
	    return {
	      isFileReference: true,
	
	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id; // ? FileReference({id}) : null;
	      }
	    };
	  },
	
	  'Object': function Object(schema) {
	    var defaultValue = schema.defaultValue || {};
	    return {
	      set: function set(obj) {
	        return obj || defaultValue;
	      },
	
	      equals: function equals(val1, val2) {
	        return (0, _stringify2.default)(val1) === (0, _stringify2.default)(val2);
	      }
	    };
	  },
	
	  'Text': function Text(schema) {
	    var defaultValue = schema.defaultValue || '';
	
	    return {
	      defaultValue: defaultValue,
	
	      set: function set(val) {
	        return typeof val === 'string' ? val : defaultValue;
	      }
	    };
	  },
	
	  'String': function String(schema) {
	    var defaultValue = schema.defaultValue;
	
	    return {
	      defaultValue: defaultValue,
	
	      set: function set(str) {
	        return str || defaultValue;
	      }
	    };
	  },
	
	  'Node': function Node(schema) {
	    return {
	      isNodeReference: true,
	
	      set: function set(id) {
	        if (id && id.id) return id.id;
	        return id; // ? NodeReference({id}) : null;
	      }
	    };
	  },
	
	  'NodeList': function NodeList(schema) {
	    return {
	      isReferenceList: true,
	
	      set: function set(ids) {
	        if (Array.isArray(ids)) {
	          return ids.map(function (id) {
	            return id && id.id ? id.id : id;
	          });
	        }
	        return [];
	      }
	    };
	  },
	
	  'Vec2': function Vec2(schema) {
	    var defaultValue = initVector2(schema.defaultValue);
	
	    return {
	      defaultValue: defaultValue,
	
	      set: function set(val) {
	        return initVector2(val || defaultValue);
	      },
	
	      get: function get(val) {
	        return val.clone();
	      },
	
	      equals: function equals(val1, val2) {
	        return val1.equals(val2);
	      }
	    };
	  },
	
	  'Color': function Color(schema) {
	    var defaultValue = initColor(schema.defaultValue);
	
	    return {
	      defaultValue: defaultValue,
	
	      set: function set(val) {
	        return initColor(val || defaultValue);
	      },
	
	      get: function get(val) {
	        return val.clone();
	      },
	
	      equals: function equals(val1, val2) {
	        return val1.equals(val2);
	      }
	    };
	  },
	
	  'Vec3': function Vec3(schema) {
	    var defaultValue = initVector3(schema.defaultValue);
	
	    return {
	      defaultValue: defaultValue,
	
	      set: function set(val) {
	        return initVector3(val || defaultValue);
	      },
	
	      get: function get(val) {
	        return val.clone();
	      },
	
	      equals: function equals(val1, val2) {
	        return val1.equals(val2);
	      }
	    };
	  }
	};
	
	exports.default = schemaTypes;

/***/ },
/* 152 */
/*!*************************************!*\
  !*** ./src/operators/Annotation.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Annotation = {
	  schema: {
	    useText: { type: 'Boolean', label: 'Use Custom Text', defaultValue: false, animatable: false },
	    text: { type: 'Text', label: 'Custom Text', defaultValue: 'Annotation Text', animatable: false },
	    open: { type: 'Boolean', label: 'Open by default', defaultValue: false, animatable: false },
	    // Mis-spelled `limitVisibility`
	    limitVisilibility: { type: 'Boolean', label: "Limit Visibility", defaultValue: false, animatable: false },
	    visibilityAngle: { type: 'Number', label: "Visibility Angle", defaultValue: 180, step: 5, minValue: 10, maxValue: 180, animatable: false },
	    directionMode: { label: 'Direction Mode', type: 'Options',
	      labels: ['Manual', 'Away From Origin'],
	      values: ['manual', 'awayFromOrigin'],
	      defaultValue: 'manual' },
	    directionTarget: { type: 'Node', label: 'Direction Target' }
	  },
	
	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;
	
	    (0, _assign2.default)(primitive, operator);
	    if (!operator.useText) primitive.text = node.name;
	  }
	};
	
	exports.default = { Annotation: Annotation };

/***/ },
/* 153 */
/*!**********************************!*\
  !*** ./src/operators/BinMesh.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _bingeom = __webpack_require__(/*! ../translators/bingeom */ 154);
	
	var _assets = __webpack_require__(/*! ../modules/assets */ 144);
	
	var _MeshSmooth = __webpack_require__(/*! ./PolyMesh/MeshSmooth */ 196);
	
	var _MeshSmooth2 = _interopRequireDefault(_MeshSmooth);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ProxyMesh = {
	  schema: {
	    binary: { type: 'Binary', label: 'Binary Geometry File' },
	    reducedBinary: { type: 'Binary', label: 'Reduced Binary Geometry File' },
	    operatorDisplay: { type: "Number", defaultValue: 1, label: 'Operator Display Type' },
	    nbLevel: { type: "Number", defaultValue: 1 }, // 1 -> only binary, 2 -> level0 and binary, 3 -> level0, level1, binary, ....
	    level0: { type: 'Binary', label: 'Binary Geometry File' },
	    level1: { type: 'Binary', label: 'Binary Geometry File' },
	    level2: { type: 'Binary', label: 'Binary Geometry File' },
	    level3: { type: 'Binary', label: 'Binary Geometry File' },
	    level4: { type: 'Binary', label: 'Binary Geometry File' }
	  },
	
	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;
	    var store = _ref.store;
	    var properties = _ref.properties;
	    var previousResult = _ref.previousResult;
	    var loaded = _ref.loaded;
	
	    var visible = properties.visible;
	    var binary = operator.binary;
	    var fetch = visible || properties.prefetch && loaded;
	    var bingeom = fetch && binary && store.hasApi() && (0, _assets.getOrFetchBinary)(binary)(store);
	    var mesh = bingeom && (0, _bingeom.convertToCNSPolyMesh)(bingeom, binary);
	    //console.log('Mesh update', 'visible:', visible, 'prefetch:', properties.prefetch, 'fetch:', fetch, 'bingeom:', !!bingeom, node.name, mesh);
	    primitive.mesh = mesh;
	    primitive.previousMesh = previousResult && previousResult.mesh;
	  }
	};
	
	var Instance = {
	  schema: {
	    geometry: { label: "Mesh", plug: 'BinMesh', type: "Plug" }
	  },
	
	  update: function update(operator, primitive) {
	    primitive.mesh = operator.geometry && operator.geometry.mesh;
	  }
	};
	
	exports.default = { ProxyMesh: ProxyMesh, MeshSmooth: _MeshSmooth2.default, Instance: Instance };

/***/ },
/* 154 */
/*!************************************!*\
  !*** ./src/translators/bingeom.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.validatePolymeshData = validatePolymeshData;
	exports.checkGeometryCache = checkGeometryCache;
	exports.cacheGeometry = cacheGeometry;
	exports.convertToPolyMesh = convertToPolyMesh;
	exports.convertToBingeom = convertToBingeom;
	exports.convertToCNSPolyMesh = convertToCNSPolyMesh;
	
	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 145);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _polyMesh = __webpack_require__(/*! ../polyMesh */ 159);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function validateAndRetype(data) {
	  if (data instanceof Uint32Array) return data;else if (data instanceof ArrayBuffer) return new Uint32Array(data);else if (typeof Buffer !== "undefined" && data instanceof Buffer) {
	    return new Uint32Array(new Uint8Array(data).buffer);
	  }
	  throw new Error("Invalid bingeom type: " + (typeof data === "undefined" ? "undefined" : (0, _typeof3.default)(data)));
	};
	
	function extractFooter(data) {
	  var jsonLength = data[data.length - 2];
	  if (!jsonLength) throw new Error("No footer in bingeom");
	  var charData = new Uint8Array(data.buffer);
	  var len = charData.byteLength - 8;
	  charData = charData.subarray(len - jsonLength, len);
	  return JSON.parse(String.fromCharCode.apply(null, charData));
	}
	
	function validateDataInfo(dataInfo) {
	  return dataInfo !== undefined && typeof dataInfo.o === "number" && typeof dataInfo.l === "number";
	}
	
	function validatePolymeshData(jsonData) {
	  return jsonData && validateDataInfo(jsonData.faceCount) && validateDataInfo(jsonData.faces) && validateDataInfo(jsonData.positions);
	}
	
	function assert(truthy, message) {
	  if (!truthy) throw new Error(message);
	}
	
	var RawUintByteSize = { 1: 'RawUint8', 2: 'RawUint16', 4: 'RawUint32' };
	
	var types = {
	  RawUint8: { shift: 0, arr: Uint8Array },
	  RawUint16: { shift: 1, arr: Uint16Array },
	  RawUint32: { shift: 2, arr: Uint32Array },
	  RawFloat32: { shift: 2, arr: Float32Array }
	};
	
	function readArray(buffer, _ref) {
	  var o = _ref.o;
	  var l = _ref.l;
	  var b = _ref.b;
	  var dataType = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var typeinfo = types[dataType || RawUintByteSize[b || 4]];
	  return new typeinfo.arr(buffer, o, l >> typeinfo.shift);
	}
	
	function noTriangulation(faces, faceSize) {
	  return faces;
	}
	
	function staticTriangulation(faces, faceSize) {
	  if (faces.length % faceSize !== 0) throw new Error("Invalid face index array");
	  var trianglePerFace = faceSize - 2;
	  var nbFaces = 3 * (faces.length * trianglePerFace) / faceSize; // number of triangulated faces
	
	  var newFaces = new faces.constructor(nbFaces);
	  for (var inn = 0, out = 0, il = faces.length; out < il;) {
	    var first = faces[out++];
	    var second = faces[out++];
	    for (var j = trianglePerFace; j > 0; --j) {
	      newFaces[inn++] = first;
	      newFaces[inn++] = second;
	      second = faces[out++];
	      newFaces[inn++] = second;
	    }
	  }
	  return newFaces;
	};
	
	function dynamicTriangulation(faces, faceCount) {
	  var fl = faceCount.length;
	  var nbFaces = -(fl << 1); // starts at -2*fl because the number of triangle in on face 'x' is faceCount[x]-2
	  for (var i = fl - 1; i >= 0; --i) {
	    nbFaces += faceCount[i];
	  }var newFaces = new faces.constructor(nbFaces * 3); // can reuse the same constructor as faces because the max index is the same
	  for (var inn = 0, out = 0, f = 0, _fl = faceCount.length; f < _fl; ++f) {
	    var first = faces[out++];
	    var second = faces[out++];
	    for (var j = faceCount[f] - 2; j > 0; --j) {
	      newFaces[inn++] = first;
	      newFaces[inn++] = second;
	      second = faces[out++];
	      newFaces[inn++] = second;
	    }
	  }
	  return newFaces;
	};
	
	var geometryCache = {};
	
	function checkGeometryCache(hash) {
	  return geometryCache[hash];
	}
	
	/*
	 * cache geometry by file hash. This might break when we start adding
	 * on operators, so verify that.
	 */
	function cacheGeometry(hash, geometry) {
	  geometryCache[hash] = geometry;
	  return geometry;
	}
	
	function convertToPolyMesh(data) {
	  var binaryData = validateAndRetype(data);
	  var jsonData = extractFooter(binaryData);
	  //console.log('extracted footer: ', jsonData);
	  var buffer = binaryData.buffer;
	  assert(validatePolymeshData(jsonData), 'Invalid Polymesh Data?');
	
	  var positions = readArray(buffer, jsonData.positions, 'RawFloat32');
	  var fc = readArray(buffer, jsonData.faceCount);
	  var faceCount = fc;
	  if (fc.length === 1) faceCount = fc[0];
	  var triangulationFunction = fc.length === 1 ? fc[0] !== 3 ? staticTriangulation : noTriangulation : dynamicTriangulation;
	  var faces = triangulationFunction(readArray(buffer, jsonData.faces), faceCount);
	
	  // normalMap
	  var normalMap = jsonData.normalMap && {
	    faces: triangulationFunction(readArray(buffer, jsonData.normalMap.faces), faceCount),
	    values: readArray(buffer, jsonData.normalMap.values, "RawFloat32")
	  };
	
	  var uvs = null;
	
	  // uvMaps
	  if (jsonData.uvMaps && (0, _keys2.default)(jsonData.uvMaps).length) {
	    uvs = {};
	    for (var attr in jsonData.uvMaps) {
	      if (jsonData.uvMaps.hasOwnProperty(attr)) {
	        var map = jsonData.uvMaps[attr];
	        // TODO for vray?: if (options.uvsToVec3Array) throw new Error('vec3ForUvs');
	
	        uvs[attr] = {
	          faces: triangulationFunction(readArray(buffer, map.faces), faceCount),
	          values: readArray(buffer, map.values, "RawFloat32")
	        };
	      }
	    }
	  }
	
	  // // extra data
	  // if (tmp = jsonData.materialIds) {//this.materialIds = reader.readArray(tmp, "RawUint32");
	  //   let rawMtl = reader.readArray(tmp, "RawUint32");
	  //   if (triangulationFunction !== noTriangulation) {  // noTriangulation, material id already correct!
	  //     let nbTriangulatedFaces = this.faces.length / 3;    // already know the right size of the material ids array
	  //
	  //     let materialTriangulationFunction = (triangulationFunction === staticTriangulation) ? staticMaterialTriangulation : dynamicMaterialTriangulation;
	  //     rawMtl = materialTriangulationFunction(rawMtl, faceCount, nbTriangulatedFaces);
	  //   }
	  //   this.materialIds = rawMtl;
	  // }
	  // return this;
	  return { positions: positions, faces: faces, normalMap: normalMap, uvs: uvs };
	}
	
	var BIN_VERSION = 1000;
	
	/*
	 * Convert PolyMesh to bingeom
	 */
	function convertToBingeom(polyMesh) {
	  //{ positions, faces, normalMap, uvs }) {
	  var jsonFooter = { blendShapes: {}, colorMaps: {} }; //, uvMaps: { 'default': {}} };
	  var byteLength = 0;
	  var buffers = [];
	  var bufferFooters = [];
	
	  function extract(key, typedArray, footer, readInto) {
	    var sourceBuf = readInto ? new readInto(typedArray).buffer : typedArray.buffer;
	    var buf = new Uint8Array(sourceBuf, 0, typedArray.byteLength);
	
	    var reuseFooter = null;
	    for (var i = 0; i < buffers.length; i++) {
	      if (equalsArrayBuffers(buf, buffers[i])) {
	        reuseFooter = bufferFooters[i];
	        break;
	      }
	    }
	
	    if (reuseFooter !== null) {
	      footer[key] = reuseFooter;
	    } else {
	      footer[key] = { b: buf.length / typedArray.length, l: buf.byteLength, o: byteLength };
	      byteLength += buf.byteLength;
	      buffers.push(buf);
	      bufferFooters.push(footer[key]);
	    }
	    //console.log( "extract: key", key, "result", footer[key], (reuseFooter !== null ) ? 'deduped' : '');
	  }
	
	  function equalsArrayBuffers(a, b) {
	    // a and b must be Uint8Arrays.
	
	    if (a.length !== b.length) {
	      return false;
	    }
	
	    for (var i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) {
	        return false;
	      }
	    }
	
	    return true;
	  };
	
	  function offsetsSum(offsets) {
	    var arr = new Uint32Array(offsets.length - 1);
	    for (var i = 0; i < offsets.length - 1; i++) {
	      arr[i] = offsets[i + 1] - offsets[i];
	    }
	    return arr;
	  }
	
	  extract('faces', polyMesh.positions.faceValueIndices, jsonFooter);
	  extract('faceCount', offsetsSum(polyMesh.faceRangeOffsets), jsonFooter);
	  extract('positions', polyMesh.positions.values.data, jsonFooter, Float32Array);
	
	  if (polyMesh.normalMap) {
	    jsonFooter.normalMap = {};
	    extract('faces', polyMesh.normalMap.faceValueIndices, jsonFooter.normalMap);
	    extract('values', polyMesh.normalMap.values.data, jsonFooter.normalMap, Float32Array);
	  }
	
	  if (polyMesh.uvMaps && polyMesh.uvMaps.length) {
	    jsonFooter.uvMaps = {};
	    polyMesh.uvMaps.namesByIndex.forEach(function (uvName) {
	      var uvMap = polyMesh.uvMaps.byName[uvName];
	      jsonFooter.uvMaps[uvName] = {};
	      extract('faces', uvMap.faceValueIndices, jsonFooter.uvMaps[uvName]);
	      extract('values', uvMap.values.data, jsonFooter.uvMaps[uvName], Float32Array);
	    });
	  }
	
	  var jsonFooterString = (0, _stringify2.default)(jsonFooter);
	  jsonFooterString += ({ 0: "", 1: "   ", 2: "  ", 3: " " })[jsonFooterString.length % 4];
	
	  var currentByte = 0;
	  var result = new Uint8Array(byteLength + jsonFooterString.length + 8);
	  for (var i = 0; i < buffers.length; i++) {
	    result.set(buffers[i], currentByte);
	    currentByte += buffers[i].byteLength;
	  }
	
	  for (var i = 0; i < jsonFooterString.length; i++) {
	    result[currentByte++] = jsonFooterString.charCodeAt(i);
	  }
	  var currentDWord = currentByte >> 2;
	  var newBytes32 = new Uint32Array(result.buffer);
	  newBytes32[currentDWord] = jsonFooterString.length;
	  newBytes32[currentDWord + 1] = BIN_VERSION;
	  return new Uint32Array(result.buffer);
	}
	
	var polyMeshCaches = {};
	
	function convertToCNSPolyMesh(data, refId) {
	  if (refId && polyMeshCaches[refId]) return polyMeshCaches[refId];
	
	  var binaryData = validateAndRetype(data);
	  var jsonData = extractFooter(binaryData);
	  var buffer = binaryData.buffer;
	
	  if (jsonData && !jsonData.faceCount && !jsonData.faces && !jsonData.positions) {
	    console.warn('Warning: PolyMesh is empty.');
	    return new _polyMesh.PolyMesh();
	  }
	
	  assert(validatePolymeshData(jsonData), 'Invalid Polymesh Data?');
	
	  var fc = readArray(buffer, jsonData.faceCount);
	  //console.log( 'CNS', CNS );
	  var importer = new _polyMesh.Importer();
	  //console.log( 'importer', importer );
	  if (fc.length === 1) {
	    importer.defaultFaceArity = fc[0];
	  } else {
	    importer.setFaceArities(fc);
	  }
	
	  importer.collapsePositions = false;
	  importer.collapseMapValues = false;
	
	  var positionFaceIndices = readArray(buffer, jsonData.faces);
	  var positionValues = readArray(buffer, jsonData.positions, 'RawFloat32');
	
	  var positionsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypePosition);
	
	  importer.setMapIndices(positionsId, positionFaceIndices);
	  importer.setMapValues(positionsId, positionValues);
	
	  // normalMap
	  if (jsonData.normalMap) {
	
	    var normalFaceIndices = readArray(buffer, jsonData.normalMap.faces);
	    var normalValues = readArray(buffer, jsonData.normalMap.values, 'RawFloat32');
	
	    var normalsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypeNormal);
	
	    importer.setMapIndices(normalsId, normalFaceIndices);
	    importer.setMapValues(normalsId, normalValues);
	  }
	
	  // uvMaps
	  if (jsonData.uvMaps && (0, _keys2.default)(jsonData.uvMaps).length) {
	    for (var attr in jsonData.uvMaps) {
	      if (jsonData.uvMaps.hasOwnProperty(attr)) {
	        var map = jsonData.uvMaps[attr];
	
	        var uvFaceIndices = readArray(buffer, map.faces);
	        var uvValues = readArray(buffer, map.values, 'RawFloat32');
	
	        var uvsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypeUV, attr);
	
	        importer.setMapIndices(uvsId, uvFaceIndices);
	        importer.setMapValues(uvsId, uvValues);
	      }
	    }
	  }
	
	  // skinning
	  if (jsonData.skinning) {
	
	    importer.setSkinning(readArray(buffer, jsonData.skinning.positionSkinRange, "RawUint32"), readArray(buffer, jsonData.skinning.skinWeights, "RawFloat32"), readArray(buffer, jsonData.skinning.skinBoneIndices, "RawUint16"), readArray(buffer, jsonData.skinning.poseSkinToPoseBoneTransform, "RawFloat32"), readArray(buffer, jsonData.skinning.poseBoneToWorldTransform, "RawFloat32"));
	  }
	
	  // TODO: add support for UVs.
	  // TODO: add support for Colors.
	  // TODO: add support for MaterialIDs.
	
	  var polyMesh = importer.toMeshAndClear();
	  //console.log('bingeom jsonDate ', jsonData);
	  //console.log('bingeom.js convertToCNSPolyMesh ', polyMesh );
	
	  if (refId) polyMeshCaches[refId] = polyMesh;
	  return polyMesh;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/buffer/index.js */ 155).Buffer))

/***/ },
/* 155 */
/*!*******************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/buffer/index.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(/*! base64-js */ 156)
	var ieee754 = __webpack_require__(/*! ieee754 */ 157)
	var isArray = __webpack_require__(/*! isarray */ 158)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/buffer/index.js */ 155).Buffer, (function() { return this; }())))

/***/ },
/* 156 */
/*!*********************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	'use strict'
	
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	function init () {
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i]
	    revLookup[code.charCodeAt(i)] = i
	  }
	
	  revLookup['-'.charCodeAt(0)] = 62
	  revLookup['_'.charCodeAt(0)] = 63
	}
	
	init()
	
	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	
	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}


/***/ },
/* 157 */
/*!*****************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/buffer/~/ieee754/index.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 158 */
/*!*****************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/buffer/~/isarray/index.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 159 */
/*!*******************************!*\
  !*** ./src/polyMesh/index.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ThreeExport = exports.Selection = exports.PolyMesh = exports.PolyMaps = exports.PolyMap = exports.Importer = undefined;
	
	__webpack_require__(/*! ./three/ThreeInstanceScalarSize */ 160);
	
	__webpack_require__(/*! ./generic/utility/polyfill */ 161);
	
	var _Importer = __webpack_require__(/*! ./geometric/tool/Importer */ 162);
	
	var _Importer2 = _interopRequireDefault(_Importer);
	
	var _PolyMesh = __webpack_require__(/*! ./geometric/model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ./geometric/model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _PolyMaps = __webpack_require__(/*! ./geometric/model/PolyMaps */ 177);
	
	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);
	
	var _Selection = __webpack_require__(/*! ./geometric/transient/Selection */ 191);
	
	var _Selection2 = _interopRequireDefault(_Selection);
	
	var _ThreeExport = __webpack_require__(/*! ./three/ThreeExport */ 192);
	
	var _ThreeExport2 = _interopRequireDefault(_ThreeExport);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Importer = _Importer2.default;
	exports.PolyMap = _PolyMap2.default;
	exports.PolyMaps = _PolyMaps2.default;
	exports.PolyMesh = _PolyMesh2.default;
	exports.Selection = _Selection2.default;
	exports.ThreeExport = _ThreeExport2.default;

/***/ },
/* 160 */
/*!*******************************************************!*\
  !*** ./src/polyMesh/three/ThreeInstanceScalarSize.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_three2.default.Vector2.InstanceScalarSize = 2;
	_three2.default.Vector3.InstanceScalarSize = 3;
	_three2.default.Vector4.InstanceScalarSize = 4;
	
	_three2.default.Color.InstanceScalarSize = 3;
	_three2.default.Quaternion.InstanceScalarSize = 4;
	
	_three2.default.Matrix3.InstanceScalarSize = 9;
	_three2.default.Matrix4.InstanceScalarSize = 16;

/***/ },
/* 161 */
/*!**************************************************!*\
  !*** ./src/polyMesh/generic/utility/polyfill.js ***!
  \**************************************************/
/***/ function(module, exports) {

	'use strict';
	
	if (!Uint32Array.prototype.fill) {
	  Object.defineProperty(Uint32Array.prototype, 'fill', { value: function value(_value, start, end) {
	      start = start || 0;
	      end = end || this.length;
	      for (var i = start; i < end; i++) {
	        this[i] = _value;
	      }
	      return this;
	    } });
	}
	
	if (!Uint32Array.prototype.slice) {
	  Object.defineProperty(Uint32Array.prototype, 'slice', { value: function value(start, end) {
	      var i = start === undefined ? 0 : start;
	      var finalIdx = end === undefined ? this.length : end;
	      var count = finalIdx - i;
	      var a = new this.constructor(count);
	      var n = 0;
	      while (i < finalIdx) {
	        a[n] = this[i];
	        ++n;
	        ++i;
	      }
	      return a;
	    } });
	}

/***/ },
/* 162 */
/*!*************************************************!*\
  !*** ./src/polyMesh/geometric/tool/Importer.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Importer;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ScalarArrayView = __webpack_require__(/*! ../../generic/container/ScalarArrayView */ 175);
	
	var _ScalarArrayView2 = _interopRequireDefault(_ScalarArrayView);
	
	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	var _PolyMaps = __webpack_require__(/*! ../model/PolyMaps */ 177);
	
	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _Skinning = __webpack_require__(/*! ../model/Skinning */ 187);
	
	var _Skinning2 = _interopRequireDefault(_Skinning);
	
	var _ImportConversions = __webpack_require__(/*! ../algorithm/ImportConversions */ 188);
	
	var _ImportConversions2 = _interopRequireDefault(_ImportConversions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Importer() {
	
	  this.defaultFaceArity = 3; // triangles
	  this.collapsePositions = true; // re-index positions
	  this.collapseMapValues = true; // join equal map values at the same vertex
	
	  this.faceArities = null;
	  this.materialIds = null;
	
	  this.mapIds = [];
	  this.mapValues = {};
	  this.mapIndices = {};
	
	  this.skinning = null;
	};
	
	Importer.prototype = {
	
	  constructor: Importer,
	
	  setFaceArities: function setFaceArities(array, optionalNumberOfElements, optionalOffset, optionalStride) {
	
	    this.faceArities = new _ScalarArrayView2.default(optionalNumberOfElements || null, array, optionalOffset, optionalStride);
	
	    return this;
	  },
	
	  setMaterialIds: function setMaterialIds(array, optionalNumberOfElements, optionalOffset, optionalStride) {
	
	    this.materialIds = new _ScalarArrayView2.default(optionalNumberOfElements || null, array, optionalOffset, optionalStride);
	
	    return this;
	  },
	
	  setMapValues: function setMapValues(mapId, array, optionalNumberOfElements, optionalOffset, optionalStride) {
	
	    var id = _PolyMaps2.default.checkId(mapId),
	        ids = this.mapIds;
	
	    if (ids.indexOf(id) === -1) ids.push(id);
	
	    this.mapValues[id] = new _ObjectArrayView2.default(_PolyMaps2.default.getTypeInfo(_PolyMaps2.default.getAnchorName(mapId)).ElementType, optionalNumberOfElements || null, !optionalOffset ? array : array.subarray(optionalOffset), optionalStride);
	
	    return this;
	  },
	
	  setMapIndices: function setMapIndices(mapId, array, optionalNumberOfElements, optionalOffset, optionalStride) {
	
	    this.mapIndices[_PolyMaps2.default.checkId(mapId)] = new _ScalarArrayView2.default(optionalNumberOfElements || null, array, optionalOffset, optionalStride);
	
	    return this;
	  },
	
	  setSkinning: function setSkinning(positionSkinRange, skinWeights, skinBoneIndices, poseSkinToPoseBoneTransform, poseBoneToWorldTransform) {
	    this.skinning = {};
	
	    this.skinning.positionSkinRange = positionSkinRange;
	    this.skinning.skinWeights = skinWeights;
	    this.skinning.skinBoneIndices = skinBoneIndices;
	
	    this.skinning.poseSkinToPoseBoneTransform = new _ObjectArrayView2.default(_three2.default.Matrix4, null, poseSkinToPoseBoneTransform);
	    this.skinning.poseBoneToWorldTransform = new _ObjectArrayView2.default(_three2.default.Matrix4, null, poseBoneToWorldTransform);
	
	    return this;
	  },
	
	  toMeshAndClear: function toMeshAndClear() {
	
	    var mapIds = this.mapIds,
	        mapValueData = this.mapValues,
	        mapIndexData = this.mapIndices,
	        PositionMapId = _PolyMaps2.default.IdPositions,
	        positions = mapValueData[PositionMapId],
	        faceArities = this.faceArities,
	        materialIds = this.materialIds;
	
	    if (!positions) throw Error("No positions!");
	
	    var positionIndices = mapIndexData[PositionMapId] || null,
	        nFaceVertices = positionIndices ? positionIndices.length : positions.length;
	
	    var faceOffsets = null;
	    //  -----------
	
	    if (faceArities === null) {
	
	      var fixedArity = this.defaultFaceArity,
	          nFaces = nFaceVertices / fixedArity | 0;
	
	      faceArities = new Uint32Array(nFaces + 1).fill(fixedArity, 1);
	    } else {
	
	      var nFaces = faceArities.length;
	      faceArities = faceArities.toArray(Uint32Array, 1);
	    }
	
	    // Here faceOffsets contains the face arities after a zero at index 0,
	    // their accumulation yields the offsets (including length sentinel):
	    faceOffsets = _Arrays2.default.accumulate(faceArities); // (in-place)
	
	    var indices = null;
	    //  -------
	
	    for (var i = 0; i !== mapIds.length; ++i) {
	      // avoid aliasing with the map indices in case it's the same array
	
	      var mapId = mapIds[i];
	      if (mapId === PositionMapId) continue;
	
	      var mapIndexView = mapIndexData[mapId];
	
	      if (mapIndexView !== undefined) mapIndexView.forceRepack(Uint32Array);
	    }
	
	    if (this.collapsePositions) {
	      // re-index values
	
	      var indices = null;
	
	      if (positionIndices !== null) indices = positionIndices.repack(Uint32Array).data;
	
	      positions = _ImportConversions2.default.collapsePositions(positions, indices);
	    } else if (positionIndices !== null) {
	      // use given indices as-is
	      indices = positionIndices.repack(Uint32Array).data;
	    }
	
	    var mesh = _PolyMesh2.default.fromData(
	    /*  ==== */faceOffsets, positions, indices, materialIds && materialIds.repack(Uint32Array).data);
	
	    for (var i = 0; i !== mapIds.length; ++i) {
	
	      var mapId = mapIds[i];
	      if (mapId === PositionMapId) continue;
	
	      var mapIndexView = mapIndexData[mapId],
	          mapValueView = mapValueData[mapId],
	          polyMap = _PolyMap2.default.fromData(faceOffsets, mapIndexView.data, mapValueView);
	
	      if (this.collapseMapValues) {
	
	        _ImportConversions2.default.collapseMapVertexValues(mesh, polyMap);
	
	        polyMap.compactValues();
	      }
	
	      _PolyMaps2.default.assignMap(mesh, mapId, polyMap);
	    }
	
	    if (this.skinning) mesh.skinning = new _Skinning2.default(this.skinning);
	
	    Importer.call(this); // re-run constructor to clear state
	
	    return mesh;
	  }
	
	};

/***/ },
/* 163 */
/*!***********************************************************!*\
  !*** ./src/polyMesh/generic/container/ObjectArrayView.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ObjectArrayView;
	
	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 164);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	var _FlatArrayView = __webpack_require__(/*! ./FlatArrayView */ 172);
	
	var _FlatArrayView2 = _interopRequireDefault(_FlatArrayView);
	
	var _ObjectBuffer = __webpack_require__(/*! ./ObjectBuffer */ 173);
	
	var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Object view mapping fixed size objects to flat arrays.
	 *
	 * @constructor
	 *
	 * @param {!function(new:*)} type
	 *
	 *    object constructor
	 *
	 * @param {number} length
	 *
	 *    number of objects to map,
	 *    can be null when an existing array is given,
	 *
	 * @param {ArrayOrType=} optionalArrayOrType
	 *
	 *    existing array or array constructor, default is Float32Array
	 *
	 * @param {number=} optionalStride
	 *
	 *    an explicit stride for cases where it differs from the element size
	 *    deduced from {@code type.InstanceScalarSize}
	 */
	function ObjectArrayView(type, length, optionalArrayOrType, optionalStride) {
	
	  var elementSize = type.InstanceScalarSize || optionalStride;
	  var stride = optionalStride || elementSize;
	  var arrayLength = length !== null ? length * stride : null;
	
	  if (elementSize === undefined || stride === undefined) throw Error("Can't determine element size / stride!");
	
	  var existingArrayOrType = optionalArrayOrType || Float32Array;
	
	  var array = _Arrays2.default.maybeCreate(existingArrayOrType, arrayLength);
	
	  _FlatArrayView2.default.call(this, array, length ||
	  // Note: Integer division by 'stride', rounding towards infinity
	  // at a minimum remainder of 'elementSize':
	  (array.length + stride - elementSize) / stride | 0);
	
	  this.type = type;
	  this.stride = stride;
	  this.elementSize = elementSize;
	  this.tempBuffer = new Float32Array(elementSize);
	};
	
	ObjectArrayView.prototype = (0, _assign2.default)((0, _create2.default)(_FlatArrayView2.default.prototype), {
	
	  constructor: ObjectArrayView,
	
	  getAt: function getAt(index, optionalValue) {
	
	    var result = optionalValue || new this.type();
	    return result.fromArray(this.data, index * this.stride);
	  },
	
	  setAt: function setAt(index, value) {
	
	    value.toArray(this.data, index * this.stride);
	  },
	
	  addAt: function addAt(index, value) {
	
	    value.toArray(this.tempBuffer, 0);
	    for (var i = 0, offset = index * this.stride; i < this.elementSize; i++) {
	      this.data[offset + i] += this.tempBuffer[i];
	    }
	  },
	
	  multiplyScalarAt: function multiplyScalarAt(index, scalar) {
	
	    for (var i = 0, offset = index * this.stride; i < this.elementSize; i++) {
	      this.data[offset + i] *= scalar;
	    }
	  },
	
	  newCompatibleView: function newCompatibleView(arrayOrType, optionalLength) {
	
	    return new ObjectArrayView(this.type, optionalLength || null, arrayOrType, this.stride);
	  },
	
	  newCompatibleBuffer: function newCompatibleBuffer() {
	
	    return new _ObjectBuffer2.default(this.type, this.data.constructor, this.stride);
	  }
	
	});
	
	ObjectArrayView.fromObjects = function (type, objects, optionalArrayType) {
	
	  var result = new ObjectArrayView(type, objects.length, optionalArrayType);
	
	  _Arrays2.default.copyObjects(objects, result.data);
	  return result;
	};

/***/ },
/* 164 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/object/create.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/create */ 165), __esModule: true };

/***/ },
/* 165 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/create.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.create */ 166);
	var $Object = __webpack_require__(/*! ../../modules/_core */ 13).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 166 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.create.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 11)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(/*! ./_object-create */ 30)});

/***/ },
/* 167 */
/*!************************************************!*\
  !*** ./src/polyMesh/generic/utility/Arrays.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(/*! babel-runtime/core-js/object/freeze */ 168);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	var _Orders = __webpack_require__(/*! ./Orders */ 171);
	
	var _Orders2 = _interopRequireDefault(_Orders);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @typedef {(function(new:Array)|Array)} ArrayOrType
	 */
	
	/**
	 * Various utilities for working with arrays.
	 *
	 * @namespace
	 */
	var Arrays = {
	
	  /**
	   * Empty arrays.
	   *
	   * @namespace
	   */
	  Empty: (0, _freeze2.default)({
	
	    /** @const @type {!Array} */
	    Array: (0, _freeze2.default)(new Array(0)),
	
	    // Note: Typed arrays can't - and don't have to frozen, since
	    // they have an immutable length.
	
	    /** @const @type {!Array<!number>} */
	    Float64Array: new Float64Array(0),
	    /** @const @type {!Array<!number>} */
	    Float32Array: new Float32Array(0),
	    /** @const @type {!Array<!number>} */
	    Uint32Array: new Uint32Array(0),
	    /** @const @type {!Array<!number>} */
	    Int32Array: new Int32Array(0)
	
	  }),
	
	  //
	
	  rangeCopy: function rangeCopy(src, srcOffset, dst, dstOffset, length) {
	
	    for (var i = 0; i !== length; ++i) {
	      dst[dstOffset + i] = src[srcOffset + i];
	    }return dst;
	  },
	
	  rangeEquals: function rangeEquals(a, aStart, b, bStart, length) {
	
	    for (var i = 0; i !== length; ++i) {
	      if (a[aStart + i] !== b[bStart + i]) return false;
	    }return true;
	  },
	
	  stridedCopy: function stridedCopy(src, srcOffset, srcStride, dst, dstOffset, dstStride, elementLength, numElements) {
	
	    for (var i = 0; i !== numElements; ++i) {
	      for (var j = 0; j !== elementLength; ++j) {
	
	        dst[dstOffset + i * dstStride + j] = src[srcOffset + i * srcStride + j];
	      }
	    }return dst;
	  },
	
	  /**
	   * For each element add the previous element.
	   *
	   * @param {!Array<!number>} array
	   */
	  accumulate: function accumulate(array) {
	
	    for (var i = 1, n = array.length; i < n; ++i) {
	      array[i] += array[i - 1];
	    }return array;
	  },
	
	  slice: function slice(array, from, optionalTo) {
	
	    // Not all browsers have .slice for typed arrays...
	
	    return array.slice !== undefined ? array.slice(from, optionalTo) : new array.constructor(array.subarray(from, optionalTo));
	  },
	
	  clone: function clone(array) {
	
	    // Not all browsers have .slice for typed arrays...
	
	    return array !== null ? array.slice !== undefined ? array.slice(0) : new array.constructor(array) : null;
	  },
	
	  binarySearch: function binarySearch(array, elem, optionalBegin, optionalUntil) {
	
	    var left = optionalBegin === undefined ? 0 : optionalBegin,
	        right = optionalUntil === undefined ? array.length - left : optionalUntil,
	        rightBound = right;
	
	    while (left < right) {
	
	      var mid = left + right >>> 1,
	          midVal = array[mid];
	
	      if (midVal < elem) left = mid + 1;else right = mid;
	    }
	
	    return left < rightBound && array[left] === elem ? left : ~left;
	  },
	
	  sort: function sort(array, optionalOrder) {
	
	    // TODO: Optimized sorting - a likely and improvable bottleneck:
	    //
	    // - A customized sort beats Chrome by a factor of 18 at block
	    //   sizes of 10.000 elements, where the performance is roughly
	    //   equal for a few elements. At this scale Chrome is already
	    //   3-4 times slower than Firefox - the more elements there are
	    //   the worse it gets.
	    //
	    // - The same routine beats Firefox by a factor of 5 with small
	    //   block sizes, where the performance becomes roughly equal at
	    //   10.000 elements.
	    //
	    // My test code did not contain duplicate elements (and does not
	    // handle them well, in the moment) and used a Quicksort with a
	    // median index pivot (which is rather lousy). It did implement
	    // a decent partitioner based on Hoare's algorithm, though.
	
	    if (array.sort !== undefined) {
	
	      return array.sort(optionalOrder || _Orders2.default.Numeric);
	    } else {
	      // some browsers may not yet support the above
	
	      return Array.prototype.sort.call(array, optionalOrder || _Orders2.default.Numeric);
	    }
	
	    return array;
	  },
	
	  unique: function unique(sortedArray, optionalOrder) {
	
	    var n = sortedArray.length;
	
	    if (n <= 1) return sortedArray.length;
	
	    var writeIndex = 0,
	        prevValue = sortedArray[0];
	
	    if (optionalOrder === undefined) {
	
	      for (var i = 1; i !== n; ++i) {
	
	        var value = sortedArray[i];
	        if (value !== prevValue) {
	
	          prevValue = value;
	
	          if (++writeIndex !== i) sortedArray[writeIndex] = value;
	        }
	      }
	    } else {
	
	      var compare = optionalOrder;
	
	      if (!optionallyBuiltMap) {
	
	        for (var i = 1; i !== n; ++i) {
	
	          var value = sortedArray[i];
	          if (compare(value, prevValue) !== 0) {
	
	            prevValue = value;
	
	            if (++writeIndex !== i) sortedArray[writeIndex] = value;
	          }
	        }
	      }
	    }
	
	    return writeIndex + 1; // new length
	  },
	
	  //
	
	  /**
	   * Utiltiy function for taking an argument that is either an existing
	   * array or an array type / constructor.
	   *
	   * Example:
	   * <pre>
	   * const array = Arrays.maybeCreate( arg || Uint32Array, n );
	   * </pre>
	   *
	   * @param {!ArrayOrType} existingArrayOrType
	   * @param {number=} requiredLength
	   * @throws Error when argument missing or an array and too short
	   */
	  maybeCreate: function maybeCreate(existingArrayOrType, requiredLength) {
	    if (!existingArrayOrType) throw Error("Missing array!");
	
	    var validLength = requiredLength !== null && !isNaN(requiredLength);
	
	    // Safari returns "object" for typeof Uint32Array, Float32Array, etc, so use instanceof
	    if (typeof existingArrayOrType === 'function' || existingArrayOrType instanceof Function) {
	
	      if (!validLength) throw Error("Missing or invalid length!");
	
	      // Note: Browsers show wEirD behavior when it comes to
	      // argument checks of typed array constructors...
	
	      return new existingArrayOrType(requiredLength);
	    }
	
	    // otherwise assume we got an existing array
	
	    if (validLength && existingArrayOrType.length < requiredLength) throw Error("Array too short: " + existingArrayOrType.length + " < " + requiredLength);
	
	    return existingArrayOrType;
	  },
	
	  copyObjects: function copyObjects(objects, array, optionalStride) {
	
	    if (!objects) return null;
	
	    var nObjects = objects.length;
	    if (nObjects === 0) return array;
	
	    var stride = objects[0].constructor.InstanceScalarSize || optionalStride;
	
	    if (stride === undefined) throw Error("Arrays.fromObjects: Cannot determine stride!");
	
	    var result = Arrays.maybeCreate(arrayOrType, nObjects * stride);
	
	    for (var i = 0, offset = 0; i !== nObjects; ++i, offset += stride) {
	
	      var object = objects[i];
	
	      if (object === undefined) {
	        console.warn("Arrays.fromObjects: Undefined object.");
	        array.fill(0, offset, offset + stride);
	        continue;
	      }
	
	      object.toArray(array, offset);
	    }
	
	    return array;
	  }
	
	};
	
	exports.default = Arrays;

/***/ },
/* 168 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/object/freeze.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/freeze */ 169), __esModule: true };

/***/ },
/* 169 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/freeze.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.freeze */ 170);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.freeze;

/***/ },
/* 170 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.freeze.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , meta     = __webpack_require__(/*! ./_meta */ 121).onFreeze;
	
	__webpack_require__(/*! ./_object-sap */ 131)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 171 */
/*!************************************************!*\
  !*** ./src/polyMesh/generic/utility/Orders.js ***!
  \************************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Orders = {
	
	  Numeric: function Numeric(a, b) {
	    return a - b;
	  },
	
	  Natural: function Natural(a, b) {
	    return a < b ? -1 : b < a ? 1 : 0;
	  },
	
	  // Note: Unstable compare functions are not an optimization.
	  // Some operations require to detect equality!
	
	  derefedNumbersIn: function derefedNumbersIn(array) {
	
	    return function compare(a, b) {
	      return array[a] - array[b];
	    };
	  },
	
	  derefedTuplesIn: function derefedTuplesIn(array, elementSize, optionalStride) {
	
	    if (!elementSize) throw Error("Invalid element size!");
	
	    var stride = optionalStride || elementSize;
	
	    if (stride === 1 && elementSize === 1) return Orders.derefNumbersIn(array);
	
	    return function compare(a, b) {
	
	      var offsetA = a * stride;
	      var offsetB = b * stride;
	
	      var result = array[offsetA] - array[offsetB];
	
	      for (var i = 1; i !== elementSize && result === 0; ++i) {
	
	        result = array[offsetA + i] - array[offsetB + i];
	      }return result;
	    };
	  },
	
	  derefedNumbersStableIn: function derefedNumbersStableIn(array) {
	
	    return function compare(a, b) {
	
	      var result = array[a] - array[b];
	      return result !== 0 ? result : a - b;
	    };
	  },
	
	  derefedTuplesStableIn: function derefedTuplesStableIn(array, elementSize, optionalStride) {
	
	    if (!elementSize) throw Error("Invalid element size!");
	
	    var stride = optionalStride || elementSize;
	
	    if (stride === 1 && elementSize === 1) return Orders.derefNumbersStableIn(array);
	
	    return function compare(a, b) {
	
	      var offsetA = a * stride;
	      var offsetB = b * stride;
	
	      var result = array[offsetA] - array[offsetB];
	
	      for (var i = 1; i !== elementSize && result === 0; ++i) {
	
	        result = array[offsetA + i] - array[offsetB + i];
	      }return result !== 0 ? result : a - b;
	    };
	  }
	
	};
	
	exports.default = Orders;

/***/ },
/* 172 */
/*!*********************************************************!*\
  !*** ./src/polyMesh/generic/container/FlatArrayView.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = FlatArrayView;
	
	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	var _Orders = __webpack_require__(/*! ../utility/Orders */ 171);
	
	var _Orders2 = _interopRequireDefault(_Orders);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function FlatArrayView(data, length) {
	
	  this.data = data;
	  this.length = length;
	};
	
	FlatArrayView.prototype = {
	
	  constructor: FlatArrayView,
	
	  offset: 0, // in scalars, constant default
	  stride: 1, // in scalars, constant default
	  elementSize: 1, // in scalars, constant default
	
	  // Access to element ranges
	
	  newRangeArray: function newRangeArray(optionalNumberOfElements) {
	
	    var n = optionalNumberOfElements || 1;
	    return new this.data.constructor(n * this.elementSize);
	  },
	
	  rangeToArray: function rangeToArray(index, n, optionalArray, optionalWriteOffset) {
	
	    var data = this.data;
	    var stride = this.stride;
	    var elemSize = this.elementSize;
	
	    var array = optionalArray || new this.data.constructor(n * this.elementSize);
	    var writeOffset = optionalWriteOffset || 0;
	
	    for (var offset = this.offset + index * stride, end = offset + n * stride; offset < end; offset += stride) {
	
	      for (var i = offset, e = offset + elemSize; i !== e; ++i) {
	
	        array[writeOffset++] = data[i];
	      }
	    }return array;
	  },
	
	  arrayToRange: function arrayToRange(array, index, n, optionalReadOffset) {
	
	    var data = this.data;
	    var stride = this.stride;
	    var elemSize = this.elementSize;
	    var readOffset = optionalReadOffset || 0;
	
	    for (var offset = this.offset + index * stride, end = offset + n * stride; offset < end; offset += stride) {
	
	      for (var i = offset, e = offset + elemSize; i !== e; ++i) {
	
	        data[i] = array[readOffset++];
	      }
	    }return this;
	  },
	
	  // Bulk copy operations
	
	  toArray: function toArray(optionalArrayOrType, optionalOffset) {
	
	    var stride = this.stride;
	    var length = this.length;
	    var elemSize = this.elementSize;
	    var writeOffset = optionalOffset === undefined ? 0 : optionalOffset;
	    var minimumLength = writeOffset + length * elemSize;
	
	    if (stride === elemSize) {
	      // data is packed, can use typed array API
	
	      var data = this.data;
	      var offset = this.offset;
	      var dataEnd = offset + length * elemSize;
	
	      if (writeOffset === 0 && (optionalArrayOrType === undefined || optionalArrayOrType === this.data.constructor)) return _Arrays2.default.slice(data, offset, dataEnd);
	
	      var array = _Arrays2.default.maybeCreate(optionalArrayOrType, minimumLength);
	
	      array.set(data.subarray(offset, dataEnd), writeOffset);
	
	      return array;
	    } else {
	      // data is strided, twiddle it apart
	
	      var array = _Arrays2.default.maybeCreate(optionalArrayOrType, minimumLength);
	
	      return this.rangeToArray(0, length, array, optionalOffset);
	    }
	  },
	
	  fromArray: function fromArray(array, optionalOffset) {
	
	    var stride = this.stride;
	    var length = this.length;
	    var elemSize = this.elementSize;
	    var readOffset = optionalOffset === undefined ? 0 : optionalOffset;
	    var minimumLength = readOffset + length * elemSize;
	
	    if (stride === elemSize) {
	      // data is packed, can use typed array API
	
	      var readView = readOffset === 0 && array.length === minimumLength ? array : array.subarray(readOffset, minimumLength);
	
	      this.data.set(readView, this.offset);
	    } else {
	      // data is strided, scatter it
	
	      return this.arrayToRange(array, 0, length, readOffset);
	    }
	
	    return this;
	  },
	
	  // Array data management
	
	  repack: function repack(optionalArrayType) {
	
	    var currentArrayType = this.data.constructor;
	    var requestedArrayType = optionalArrayType || currentArrayType;
	
	    if (this.stride !== this.elementSize || requestedArrayType !== currentArrayType) this.forceRepack(optionalArrayType);
	
	    return this;
	  },
	
	  forceRepack: function forceRepack(optionalArrayType) {
	
	    this.data = this.toArray(optionalArrayType);
	    this.offset = 0;
	    this.stride = this.elementSize;
	
	    return this;
	  },
	
	  // Factory methods for views / buffers
	
	  clone: function clone() {
	
	    return this.newCompatibleView(this.toArray(), this.length);
	  },
	
	  newCompatibleView: function newCompatibleView(arrayOrType, optionalLength) {
	
	    throw Error("not implemented"); // abstract
	  },
	
	  newCompatibleBuffer: function newCompatibleBuffer() {
	
	    throw Error("not implemented"); // abstract
	  },
	
	  // Factory methods for compare functions
	
	  newCompareAtIndices: function newCompareAtIndices() {
	
	    return _Orders2.default.derefedTuplesIn(this.data, this.elementSize, this.stride);
	  },
	
	  newCompareAtIndicesStable: function newCompareAtIndicesStable() {
	
	    return _Orders2.default.derefedTuplesStableIn(this.data, this.elementSize, this.stride);
	  }
	
	};

/***/ },
/* 173 */
/*!********************************************************!*\
  !*** ./src/polyMesh/generic/container/ObjectBuffer.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ObjectBuffer;
	
	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 164);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _BlockBuffer = __webpack_require__(/*! ./BlockBuffer */ 174);
	
	var _BlockBuffer2 = _interopRequireDefault(_BlockBuffer);
	
	var _ObjectArrayView = __webpack_require__(/*! ./ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function ObjectBuffer(type, optionalArrayType, optionalElementSize) {
	
	  _BlockBuffer2.default.call(this, optionalArrayType || Float32Array);
	
	  this.elementSize = optionalElementSize || type.InstanceScalarSize;
	  this.type = type;
	};
	
	ObjectBuffer.prototype = (0, _assign2.default)((0, _create2.default)(_BlockBuffer2.default.prototype), {
	
	  constructor: ObjectBuffer,
	
	  toObjectArrayViewAndClear: function toObjectArrayViewAndClear() {
	
	    return new _ObjectArrayView2.default(this.type, null, this.toArrayAndClear());
	  },
	
	  getAt: function getAt(index, optionalValue) {
	
	    var result = optionalValue || new this.type();
	
	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & this.intraBlockIndexMask;
	
	    return result.fromArray(this.blocks[blockIndex], blockOffset * this.elementSize);
	  },
	
	  setAt: function setAt(index, value) {
	
	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & this.intraBlockIndexMask;
	
	    value.toArray(this.blocks[blockIndex], blockOffset * this.elementSize);
	  },
	
	  push: function push(value) {
	
	    var index = this.length++;
	    var block = this.lastBlock;
	    var blockOffset = index & this.intraBlockIndexMask;
	
	    if (blockOffset === 0) {
	
	      var blockSize = this.intraBlockIndexMask + 1;
	      block = new this.arrayType(blockSize * this.elementSize);
	      this.lastBlock = block;
	      this.blocks.push(block);
	    }
	
	    value.toArray(block, blockOffset * this.elementSize);
	
	    return index + 1;
	  }
	
	});

/***/ },
/* 174 */
/*!*******************************************************!*\
  !*** ./src/polyMesh/generic/container/BlockBuffer.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = BlockBuffer;
	
	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function BlockBuffer(arrayType, nIntraBlockIndexBits) {
	
	  this.blocks = [];
	  this.lastBlock = null;
	  this.arrayType = arrayType;
	
	  var nBits = nIntraBlockIndexBits || 12;
	  this.intraBlockIndexBits = nBits;
	  this.intraBlockIndexMask = (1 << nBits) - 1;
	
	  this.length = 0;
	};
	
	BlockBuffer.prototype = {
	
	  constructor: BlockBuffer,
	
	  elementSize: 1, // in scalars, constant default
	
	  toArrayAndClear: function toArrayAndClear() {
	
	    var result = this.toArray();
	    this.clear();
	    return result;
	  },
	
	  newRangeArray: function newRangeArray(optionalNumberOfElements) {
	
	    var n = optionalNumberOfElements || 1;
	    return new this.arrayType(n * this.elementSize);
	  },
	
	  rangeToArray: function rangeToArray(index, n, optionalArray, optionalWriteOffset) {
	
	    var intraBlockIndexMask = this.intraBlockIndexMask;
	    var elementSize = this.elementSize;
	
	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & intraBlockIndexMask;
	
	    var block = this.blocks[blockIndex];
	
	    var array = optionalArray || new this.arrayType(n * elementSize);
	    var writeOffset = optionalWriteOffset === undefined ? 0 : optionalWriteOffset;
	
	    for (var i = 0; i < n; ++i) {
	
	      for (var j = blockOffset * elementSize, s = j + elementSize; j !== s; ++j) {
	
	        array[writeOffset++] = block[j];
	      }if ((++blockOffset & intraBlockIndexMask) === 0) block = this.blocks[++blockIndex];
	    }
	
	    return array;
	  },
	
	  arrayToRange: function arrayToRange(array, index, n, optionalReadOffset) {
	
	    var intraBlockIndexMask = this.intraBlockIndexMask;
	    var elementSize = this.elementSize;
	
	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & intraBlockIndexMask;
	
	    var block = this.blocks[blockIndex];
	
	    var readOffset = optionalReadOffset === undefined ? 0 : optionalReadOffset;
	
	    for (var i = 0; i < n; ++i) {
	
	      for (var j = blockOffset * elementSize, s = j + elementSize; j !== s; ++j) {
	
	        block[j] = array[readOffset++];
	      }if ((++blockOffset & intraBlockIndexMask) === 0) block = this.blocks[++blockIndex];
	    }
	
	    return this;
	  },
	
	  pushArrayRange: function pushArrayRange(array, n, optionalReadOffset) {
	
	    var intraBlockIndexMask = this.intraBlockIndexMask;
	    var elementSize = this.elementSize;
	
	    var blockOffset = this.length; // masked later
	
	    var block = this.lastBlock;
	
	    var readOffset = optionalReadOffset === undefined ? 0 : optionalReadOffset;
	
	    for (var i = 0; i < n; ++i) {
	
	      if ((blockOffset &= intraBlockIndexMask) === 0) {
	
	        var blockSize = intraBlockIndexMask + 1;
	        block = new this.arrayType(blockSize * elementSize);
	        this.lastBlock = block;
	        this.blocks.push(block);
	      }
	
	      for (var j = blockOffset++ * elementSize, s = j + elementSize; j !== s; ++j) {
	
	        block[j] = array[readOffset++];
	      }
	    }
	
	    return this.length += n;
	  },
	
	  clear: function clear() {
	
	    this.blocks = [];
	    this.length = 0;
	    this.lastBlock = null;
	
	    return this;
	  },
	
	  toArray: function toArray(optionalArrayOrType, optionalOffset) {
	
	    var writeOffset = optionalOffset === undefined ? 0 : optionalOffset;
	    var elementSize = this.elementSize;
	    var minArraySize = this.length * elementSize + writeOffset;
	
	    var array = _Arrays2.default.maybeCreate(optionalArrayOrType || this.arrayType, minArraySize);
	
	    var blocks = this.blocks;
	    var blockSize = (1 << this.intraBlockIndexBits) * elementSize;
	    var nFullBlocks = Math.max(blocks.length - 1, 0);
	
	    for (var i = 0; i !== nFullBlocks; ++i) {
	
	      array.set(blocks[i], writeOffset);
	      writeOffset += blockSize;
	    }
	
	    var lastBlockUse = minArraySize - writeOffset;
	
	    if (lastBlockUse !== 0) array.set(blocks[nFullBlocks].subarray(0, lastBlockUse), writeOffset);
	
	    return array;
	  }
	
	};

/***/ },
/* 175 */
/*!***********************************************************!*\
  !*** ./src/polyMesh/generic/container/ScalarArrayView.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ScalarArrayView;
	
	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 164);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	var _FlatArrayView = __webpack_require__(/*! ./FlatArrayView */ 172);
	
	var _FlatArrayView2 = _interopRequireDefault(_FlatArrayView);
	
	var _ScalarBuffer = __webpack_require__(/*! ./ScalarBuffer */ 176);
	
	var _ScalarBuffer2 = _interopRequireDefault(_ScalarBuffer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function ScalarArrayView(length, optionalArrayOrType, optionalOffset, optionalStride) {
	
	  var offset = optionalOffset === undefined ? 0 : optionalOffset;
	  var stride = optionalStride === undefined ? 1 : optionalStride;
	
	  var offsetLength = (offset + stride - 1) / stride | 0;
	  var minArrayLength = length !== null ? (offsetLength + length) * stride : null;
	
	  var array = _Arrays2.default.maybeCreate(optionalArrayOrType || Uint32Array, minArrayLength);
	
	  _FlatArrayView2.default.call(this, array, length !== null ? length :
	  // figure out length from user-provided array
	  (array.length - offset + stride - 1) / stride | 0);
	
	  this.offset = offset;
	  this.stride = stride;
	};
	
	ScalarArrayView.prototype = (0, _assign2.default)((0, _create2.default)(_FlatArrayView2.default.prototype), {
	
	  constructor: ScalarArrayView,
	
	  getAt: function getAt(index) {
	
	    return this.array[this.offset + index * this.stride];
	  },
	
	  setAt: function setAt(index, value) {
	
	    this.array[this.offset + index * this.stride] = value;
	  },
	
	  newCompatibleView: function newCompatibleView(arrayOrType, optionalLength) {
	
	    return new ScalarArrayView(optionalLength || null, arrayOrType, 0);
	  },
	
	  newCompatibleBuffer: function newCompatibleBuffer() {
	
	    return new _ScalarBuffer2.default(this.data.constructor);
	  }
	
	});

/***/ },
/* 176 */
/*!********************************************************!*\
  !*** ./src/polyMesh/generic/container/ScalarBuffer.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ScalarBuffer;
	
	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 164);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _BlockBuffer = __webpack_require__(/*! ./BlockBuffer */ 174);
	
	var _BlockBuffer2 = _interopRequireDefault(_BlockBuffer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function ScalarBuffer(optionalArrayType) {
	
	  _BlockBuffer2.default.call(this, optionalArrayType || Uint32Array);
	};
	
	ScalarBuffer.prototype = (0, _assign2.default)((0, _create2.default)(_BlockBuffer2.default.prototype), {
	
	  constructor: ScalarBuffer,
	
	  getAt: function getAt(index) {
	
	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & this.intraBlockIndexMask;
	
	    return this.blocks[blockIndex][blockOffset];
	  },
	
	  setAt: function setAt(index, value) {
	
	    var blockIndex = index >> this.intraBlockIndexBits;
	    var blockOffset = index & this.intraBlockIndexMask;
	
	    this.blocks[blockIndex][blockOffset] = value;
	    return this;
	  },
	
	  push: function push(value) {
	
	    var index = this.length++;
	    var block = this.lastBlock;
	    var blockOffset = index & this.intraBlockIndexMask;
	
	    if (blockOffset === 0) {
	
	      var blockSize = this.intraBlockIndexMask + 1;
	      block = new this.arrayType(blockSize);
	      this.lastBlock = block;
	      this.blocks.push(block);
	    }
	
	    block[blockOffset] = value;
	
	    return index + 1;
	  }
	
	});

/***/ },
/* 177 */
/*!**************************************************!*\
  !*** ./src/polyMesh/geometric/model/PolyMaps.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = PolyMaps;
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 164);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function PolyMaps() {
	
	  _ObjectsByName2.default.call(this);
	};
	
	PolyMaps.prototype = (0, _create2.default)(_ObjectsByName2.default.prototype);
	PolyMaps.prototype.constructor = PolyMaps;
	
	// Pretty much an alias to ObjectsByName, adding a static interface
	// and a custom iterator for uniform access of maps within a mesh...
	
	(0, _assign2.default)(PolyMaps, {
	
	  TypePosition: 1,
	  TypeNormal: 2,
	  TypeTangent: 4,
	  TypeUV: 8,
	  TypeColor: 16,
	
	  id: function id(typeId, name) {
	
	    var anchorName = PolyMaps.TypeInfo[typeId].AnchorName;
	    return name != null ? anchorName + '.' + name : anchorName;
	  },
	
	  checkId: function checkId(id) {
	
	    var anchorName = PolyMaps.getAnchorName(id);
	    var mapName = PolyMaps.getMapName(id, anchorName);
	    var typeInfo = PolyMaps.getTypeInfo(anchorName);
	
	    if (typeInfo === null || mapName === '') throw Error("Invalid PolyMap ID '" + id + "'!");
	
	    return id;
	  },
	
	  getAnchorName: function getAnchorName(id) {
	
	    var dot = id.indexOf('.');
	    return dot === -1 ? id : id.slice(0, dot);
	  },
	
	  getMapName: function getMapName(id, anchorName) {
	
	    return id === anchorName ? null : id.slice(anchorName.length + 1);
	  },
	
	  getTypeInfo: function getTypeInfo(anchorName) {
	
	    var info = PolyMaps.TypeInfo;
	    for (var i = 0, n = info.length; i !== n; ++i) {
	      var entry = info[i];
	      if (entry !== null && entry.AnchorName === anchorName) return info[i];
	    }
	    return null;
	  },
	
	  resolveMap: function resolveMap(mesh, id) {
	
	    var anchorName = PolyMaps.getAnchorName(id);
	    if (id === anchorName) return mesh[anchorName];
	
	    var maps = mesh[anchorName];
	    return maps && maps.byName[id.slice(anchorName.length + 1)];
	  },
	
	  assignMap: function assignMap(mesh, id, map) {
	
	    var anchorName = PolyMaps.getAnchorName(id);
	    var mapName = PolyMaps.getMapName(id, anchorName);
	
	    if (mapName === null) {
	
	      mesh[anchorName] = map;
	    } else {
	
	      var maps = mesh[anchorName];
	
	      if (maps === null) {
	
	        maps = new PolyMaps();
	        mesh[anchorName] = maps;
	      }
	
	      maps.set(mapName, map);
	    }
	  },
	
	  Iterator: function Iterator(mesh) {
	
	    _ObjectsByName2.default.Iterator.call(this);
	    this.reset(mesh || null);
	  }
	
	});
	
	PolyMaps.TypeInfo = [null, { // 1
	  Type: PolyMaps.TypePosition,
	  AnchorName: 'positions',
	  ElementType: _three2.default.Vector3
	}, { // 2
	  Type: PolyMaps.TypeNormal,
	  AnchorName: 'normalMap',
	  ElementType: _three2.default.Vector3
	}, null, { // 4
	  Type: PolyMaps.TypeTangent,
	  AnchorName: 'tangentMap',
	  ElementType: _three2.default.Vector3
	}, null, null, null, { // 8
	  Type: PolyMaps.TypeUV,
	  AnchorName: 'uvMaps',
	  ElementType: _three2.default.Vector2
	}, null, null, null, null, null, null, null, {
	  Type: PolyMaps.TypeColor,
	  AnchorName: 'colorMaps',
	  ElementType: _three2.default.Color
	}];
	
	(0, _assign2.default)(PolyMaps, {
	
	  IdPositions: PolyMaps.id(PolyMaps.TypePosition),
	  IdNormals: PolyMaps.id(PolyMaps.TypeNormal),
	  IdTangents: PolyMaps.id(PolyMaps.TypeTangent)
	
	});
	
	PolyMaps.Iterator.prototype = (0, _assign2.default)((0, _create2.default)(_ObjectsByName2.default.Iterator.prototype), {
	
	  constructor: PolyMaps.Iterator,
	  _super: _ObjectsByName2.default.Iterator.prototype,
	
	  reset: function reset(optionalMesh) {
	
	    this._super.reset.call(this, null);
	
	    var mesh = optionalMesh || null;
	    this.mesh = mesh;
	    this.byName = mesh;
	    this.typeId = 0;
	  },
	
	  getId: function getId() {
	
	    return PolyMaps.id(this.typeId, this.name);
	  },
	
	  next: function next() {
	
	    // Note: Not using dynamic resolution here because it may impact
	    // compiler optimizations in a negative way.
	
	    // If iterating a collection, keep going:
	
	    if (this._super.next.call(this)) return true;
	
	    // Otherwise count up the id:
	
	    var mesh = this.mesh;
	    var type = this.typeId;
	
	    var elem = null;
	    var object = null;
	
	    type <<= 1;
	
	    switch (type) {
	
	      case 0:
	        type = 1;
	      // v-v-v
	
	      case PolyMaps.TypePosition:
	        elem = mesh.positions;
	        break;
	
	      case PolyMaps.TypeNormal:
	        elem = mesh.normalMap;
	        break;
	
	      case PolyMaps.TypeTangent:
	        elem = mesh.tangentMap;
	        break;
	
	      case PolyMaps.TypeUV:
	        object = mesh.uvMaps;
	        break;
	
	      case PolyMaps.TypeColor:
	        object = mesh.colorMaps;
	        break;
	
	      default:
	
	        this.reset(null);
	        return false;
	
	    }
	
	    this.typeId = type;
	
	    if (object !== null && object !== undefined) {
	
	      this.byName = object.byName;
	      return this._super.reset.call(this, object).next();
	    } else if (elem !== null && elem !== undefined) {
	
	      this.element = elem;
	      this.index = type;
	      this.name = null;
	      return true;
	    }
	
	    return this.next();
	  }
	
	});

/***/ },
/* 178 */
/*!*********************************************************!*\
  !*** ./src/polyMesh/generic/container/ObjectsByName.js ***!
  \*********************************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ObjectsByName;
	/**
	 * This class works around the problem that {@code for .. in} loops poison
	 * the surrounding function and inhibit all optimizations with V8. This is
	 * of course undesirable, especially since some data processing may happen
	 * in the same function, and redundant workarounds would obscure the code.
	 *
	 * Therefore we use an extra data structure with an array of names.
	 *
	 * A noteworthy property is that there is no reliance on the indices, so
	 * {@code .namesByIndex} can be sorted (unless within an ongoing iteration,
	 * of course) in-place, e.g. alphabetically or by use frequency for UI or
	 * caching purposes.
	 *
	 * Further, we provide a nested {@code Iterator} class that treats {@code
	 * null} values gracefully.
	 *
	 * Example:
	 * <pre>
	 * // Create an iterator
	 * const iterator = new ObjectsByName.Iterator( objects );
	 *
	 * // Iterate when this.objects is an ObjectsByName instance, do nothing
	 * // in case it is null
	 * for ( iterator.next(); ) {
	 *     // [... use iterator.name, iterator.index and iterator.element ...]
	 * }
	 * </pre>
	 *
	 * @template T
	 * @constructor
	 */
	function ObjectsByName() {
	
	  /** @const @type {!Object<!string,T>} */
	  this.byName = {};
	
	  /** @const @type {!Array<T>} */
	  this.namesByIndex = [];
	};
	
	ObjectsByName.prototype = {
	
	  constructor: ObjectsByName,
	
	  /** @type {!number} */
	  get length() {
	    return this.namesByIndex.length;
	  },
	
	  set: function set(name, object) {
	
	    var byName = this.byName;
	    if (name in byName === false) this.namesByIndex.push(name);
	    byName[name] = object;
	  }
	
	};
	
	/**
	 * @template T
	 * @constructor
	 * @param {ObjectsByName<T>=} optionalContainer
	 */
	ObjectsByName.Iterator = function (optionalContainer) {
	
	  this.reset(optionalContainer || null);
	};
	
	ObjectsByName.Iterator.prototype = {
	
	  constructor: ObjectsByName.Iterator,
	
	  /**
	   * @param {ObjectsByName<T>=} optionalContainer
	   * @return {!ObjectsByName.Iterator<T>}
	   */
	  reset: function reset(optionalContainer) {
	
	    if (optionalContainer !== undefined) this.container = optionalContainer;
	
	    this.name = null;
	    this.index = -1;
	    this.element = null;
	    return this;
	  },
	
	  /**
	   * @return {!boolean}
	   */
	  next: function next() {
	
	    var map = this.container;
	    if (map === null) return false;
	
	    var names = map.namesByIndex;
	    var index = ++this.index;
	
	    if (index >= names.length) {
	
	      this.name = null;
	      return false;
	    }
	
	    this.element = map.byName[this.name = names[index]];
	    return true;
	  },
	
	  /**
	   * @param {!string} name
	   * @param {T} element
	   * @return {!ObjectsByName<T>}
	   */
	  add: function add(name, element) {
	
	    // TODO if ( this === null ) this = new ObjectsByName();
	
	    var namesByIndex = this.namesByIndex;
	
	    if (namesByIndex.indexOf(name) !== -1) throw Error("ObjectsByName: Name '" + name + "' not unique!");
	
	    namesByIndex.push(name);
	    this.byName[name] = element;
	
	    return this;
	  }
	
	};
	
	ObjectsByName.shallowClone = (function () {
	
	  var i = new ObjectsByName.Iterator();
	
	  return function shallowClone(that) {
	
	    var newMap = new ObjectsByName();
	
	    if (!that) return newMap;
	
	    var byName = newMap.byName;
	    var names = newMap.namesByIndex;
	
	    names.length = that.namesByIndex.length;
	
	    for (i.reset(that); i.next();) {
	
	      var name = i.name;
	      byName[name] = i.element;
	      names[i.index] = name;
	    }
	
	    i.reset(null); // (!)
	
	    return newMap;
	  };
	})();

/***/ },
/* 179 */
/*!*************************************************!*\
  !*** ./src/polyMesh/geometric/model/PolyMap.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = PolyMap;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _IndexMappings = __webpack_require__(/*! ../../generic/algorithm/IndexMappings */ 180);
	
	var _IndexMappings2 = _interopRequireDefault(_IndexMappings);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	var _EdgeVertexAdjacency = __webpack_require__(/*! ./adjacency/EdgeVertexAdjacency */ 181);
	
	var _EdgeVertexAdjacency2 = _interopRequireDefault(_EdgeVertexAdjacency);
	
	var _FaceEdgeAdjacency = __webpack_require__(/*! ./adjacency/FaceEdgeAdjacency */ 183);
	
	var _FaceEdgeAdjacency2 = _interopRequireDefault(_FaceEdgeAdjacency);
	
	var _ValueAdjacency = __webpack_require__(/*! ./adjacency/ValueAdjacency */ 184);
	
	var _ValueAdjacency2 = _interopRequireDefault(_ValueAdjacency);
	
	var _FaceFaceAdjacency = __webpack_require__(/*! ./adjacency/FaceFaceAdjacency */ 185);
	
	var _FaceFaceAdjacency2 = _interopRequireDefault(_FaceFaceAdjacency);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @template T
	 * @constructor
	 *
	 * @param {!PolyMap|!Object} from object to copy the properties from
	 */
	function PolyMap(from) {
	
	  if (!from) {
	    this.faceRangeOffsets = new Uint32Array(1);
	    this.faceValueIndices = new Uint32Array(0);
	    this.values = new _ObjectArrayView2.default(_three2.default.Vector3, 0);
	  } else {
	
	    this.faceRangeOffsets = from.faceRangeOffsets; //Uint32Array
	    this.faceValueIndices = from.faceValueIndices; //Uint32Array
	    this.values = from.values; //ObjectArrayView contains Three.Vector3 or Three.Vector2 usually
	
	    // Cached transient information (can be rebuilt from the above):
	
	    // Inverse index (value indices -> faces):
	    var valueFaceIndices = from.valueFaceIndices || null;
	    this.valueFaceIndices = valueFaceIndices;
	    this.valueFaceIndexOffsets = // only reuse when complete
	    valueFaceIndices && from.valueFaceIndexOffsets || null;
	
	    // The low value index acts as the pivot for edge enumeration, so
	    // the following array is indexed by edge UIDs:
	    this._edgeVertexAdjacency = null;
	    this._faceEdgeAdjacency = null;
	    this._valueAdjacency = null;
	    this._valueValueAdjacency = null;
	    this._faceFaceAdjacency = null;
	  }
	};
	
	PolyMap.fromData = function (faceOffsets, indices, values) {
	
	  var result = new PolyMap({
	
	    faceRangeOffsets: faceOffsets,
	
	    faceValueIndices: indices || _IndexMappings2.default.identity(values.length, Uint32Array),
	
	    values: values.repack(Float32Array)
	
	  });
	
	  var nFaceVertices = faceOffsets[faceOffsets.length - 1];
	
	  if (result.faceValueIndices.length !== nFaceVertices) throw Error("Number of postition indices or unindexed " + "data values does not match the number of face vertices!");
	
	  return result;
	};
	
	PolyMap.prototype = {
	
	  constructor: PolyMap,
	
	  findValueIndexOffset: function findValueIndexOffset(faceIndex, valueIndex) {
	
	    var offsets = this.faceRangeOffsets;
	    var indices = this.faceValueIndices;
	
	    var begin = offsets[faceIndex];
	    var until = offsets[faceIndex + 1];
	
	    for (var i = begin; i !== until; ++i) {
	      if (indices[i] === valueIndex) return i;
	    }return -1;
	  },
	
	  // adjacency structures, computed on-demand adjacency structures.
	
	  get edgeVertexAdjacency() {
	
	    if (!this._edgeVertexAdjacency) this._edgeVertexAdjacency = new _EdgeVertexAdjacency2.default(this);
	
	    return this._edgeVertexAdjacency;
	  },
	
	  get faceEdgeAdjacency() {
	
	    if (!this._faceEdgeAdjacency) this._faceEdgeAdjacency = new _FaceEdgeAdjacency2.default(this);
	
	    return this._faceEdgeAdjacency;
	  },
	
	  get valueAdjacency() {
	
	    if (!this._valueAdjacency) this._valueAdjacency = new _ValueAdjacency2.default(this);
	
	    return this._valueAdjacency;
	  },
	
	  get valueValueAdjacency() {
	
	    if (!this._valueValueAdjacency) this._valueValueAdjacency = new ValueValueAdjacency(this);
	
	    return this._valueValueAdjacency;
	  },
	
	  get faceFaceAdjacency() {
	
	    if (!this._faceFaceAdjacency) this._faceFaceAdjacency = new _FaceFaceAdjacency2.default(this);
	
	    return this._faceFaceAdjacency;
	  },
	
	  // Inverse index (value index -> faces) build
	
	  updateInverseIndex: function updateInverseIndex() {
	
	    if (this.valueFaceIndices === null) {
	
	      var faceOffsets = this.faceRangeOffsets;
	
	      var faceIndex = -1;
	      var nextFaceStart = faceOffsets[0];
	
	      var indices = this.faceValueIndices;
	
	      var writeOffsets = this._updateValueFaceIndexOffsets();
	      var nDestOffsets = writeOffsets.length;
	
	      var nFaceIndices = indices.length;
	      var faceIndices = new Uint32Array(nFaceIndices);
	
	      for (var i = 0; i !== nFaceIndices; ++i) {
	
	        if (i === nextFaceStart) nextFaceStart = faceOffsets[++faceIndex + 1];
	
	        faceIndices[writeOffsets[indices[i]]++] = faceIndex;
	      }
	
	      this.valueFaceIndices = faceIndices;
	
	      // Shift the write offsets back to their initial values:
	
	      if (writeOffsets.byteOffset === 0) throw Error("Invalid .valueFaceIndexOffsets != null!");
	
	      this.valueFaceIndexOffsets = new Uint32Array(writeOffsets.buffer, 0, nDestOffsets);
	    }
	
	    return this;
	  },
	
	  _updateValueFaceIndexOffsets: function _updateValueFaceIndexOffsets() {
	
	    var result = this.valueFaceIndexOffsets;
	
	    if (result === null) {
	
	      var nValues = this.values.length;
	      var requiredLength = nValues + 2;
	
	      // Two extra values... Why?
	      //
	      // 1. For uniform access we keep n+1 offsets, that is
	      //    0, o_0, o_1, o_2 ..., <length>
	      //
	      // 2. The build of the inverse indices is destructive
	      //    and shifts the offsets by one index. The result
	      //    is something like:
	      //
	      //    o_0, o_1, o_2, ..., <length>, <length>
	      //
	      //    Now we will want our leading zero back.
	
	      var buffer = new Uint32Array(requiredLength);
	      var histogramArea = buffer.subarray(2);
	
	      result = buffer.subarray(1);
	
	      _IndexMappings2.default.histogram(this.faceValueIndices, nValues, histogramArea);
	
	      _Arrays2.default.accumulate(histogramArea);
	
	      this.valueFaceIndices = null;
	      this.valueFaceIndexOffsets = result;
	    }
	
	    return result;
	  },
	
	  // Compaction
	
	  compactValues: function compactValues() {
	
	    var values = this.values;
	    var nValues = values.length;
	
	    if (nValues !== 0) {
	
	      var sourceToTargetMap = new Uint32Array(nValues);
	      var nCompactValues = this._compactFaceIndexOffsets(sourceToTargetMap);
	
	      if (nCompactValues !== nValues) {
	
	        this._compactData(sourceToTargetMap, nCompactValues);
	        this._compactIndices(sourceToTargetMap);
	      }
	    }
	
	    return this;
	  },
	
	  _compactFaceIndexOffsets: function _compactFaceIndexOffsets(outSourceToTargetMap) {
	
	    var faceIndexOffsets = this._updateValueFaceIndexOffsets();
	    var nValues = outSourceToTargetMap.length;
	
	    var nCompactValues = 0;
	    var offset = 0; // == faceIndexOffsets[ 0 ]
	
	    for (var i = 0; i !== nValues; ++i) {
	
	      var nextOffset = faceIndexOffsets[i + 1];
	
	      outSourceToTargetMap[i] = nCompactValues;
	      // Note: Filling in incorrect values at indices that are no longer
	      // used, actually. But those allow to replay the compaction of the
	      // offsets on the values once the size is known.
	      //
	      // The value that corresponds to the last index in an equal range
	      // is the one to keep.
	
	      if (offset !== nextOffset) {
	
	        if (nCompactValues !== i) faceIndexOffsets[nCompactValues] = offset;
	
	        offset = nextOffset;
	        ++nCompactValues;
	      }
	    }
	
	    faceIndexOffsets[nCompactValues] = offset;
	
	    if (nCompactValues !== nValues) {
	
	      // Note: Since only empty ranges were removed, neither need to null
	      // nor rebuild .valueFaceIndices.
	
	      if (faceIndexOffsets.byteOffset !== 0) {
	        // this will be our leading zero and we want to keep it, so have
	        // a little dance with the typed arrays API...
	
	        var bufferView = new Uint32Array(faceIndexOffsets.buffer),
	            slice = _Arrays2.default.slice(bufferView, 0, nCompactValues + 2);
	
	        faceIndexOffsets = slice.subarray(1);
	
	        // ... phew!
	      } else {
	
	          faceIndexOffsets = _Arrays2.default.slice(faceIndexOffsets, 0, nCompactValues + 1);
	        }
	    }
	
	    this.valueFaceIndexOffsets = faceIndexOffsets;
	    return nCompactValues;
	  },
	
	  _compactData: function _compactData(sourceToTargetMap, nCompactValues) {
	
	    // Rewrite the values to a new buffer, avoiding to build another
	    // temporary map, instead exploit the bogus padding of the STTM:
	
	    var values = this.values;
	    var nValues = values.length;
	    var newValues = new _ObjectArrayView2.default(values.type, nCompactValues);
	    var writeIndex = sourceToTargetMap[0];
	    var element = newValues.newRangeArray();
	
	    for (var i = 1; i !== nValues; ++i) {
	
	      var nextWriteIndex = sourceToTargetMap[i];
	
	      if (writeIndex !== nextWriteIndex) {
	        // now i - 1 is the source position we want
	
	        values.rangeToArray(i - 1, 1, element);
	        newValues.arrayToRange(element, writeIndex, 1);
	
	        writeIndex = nextWriteIndex;
	      }
	    }
	
	    values.rangeToArray(nValues - 1, 1, element);
	    newValues.arrayToRange(element, writeIndex, 1);
	
	    this.values = newValues;
	  },
	
	  _compactIndices: function _compactIndices(sourceToTargetMap) {
	
	    // The size of the index array does not change - it has already (else
	    // there'd be no unused indices), but we don't know when (the typical
	    // case would be in a previous transaction), so the same array can be
	    // in use elsewhere...
	
	    var indices = this.faceValueIndices;
	    var nIndices = indices.length;
	
	    var newIndices = new Uint32Array(nIndices);
	
	    _IndexMappings2.default.apply(indices, sourceToTargetMap, newIndices);
	    this.faceValueIndices = newIndices;
	  }
	
	};

/***/ },
/* 180 */
/*!*********************************************************!*\
  !*** ./src/polyMesh/generic/algorithm/IndexMappings.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Utilties for working with arrays of indices that are broadly useful and not
	 * tailored towards a specific purpose.
	 *
	 * @namespace
	 */
	var IndexMappings = {
	
	  /**
	   * Create or populate an array with elements equal to their indices.
	   *
	   * @param {!number} n
	   * @param {ArrayOrType=} arrayOrType defaults to Uint32Array
	   * @return {!Array<!number>}
	   */
	  identity: function identity(n, arrayOrType) {
	
	    var result = _Arrays2.default.maybeCreate(arrayOrType || Uint32Array, n);
	    for (var i = 0; i !== n; ++i) {
	      result[i] = i;
	    }return result;
	  },
	
	  /**
	   * Get an identity map as a view onto a globally shared buffer which
	   * must not be changed.
	   *
	   * @param {!number} n
	   * @return {!Uint32Array}
	   */
	  identityForReading: function identityForReading(n) {
	
	    var proto = IndexMappings._identityProto;
	
	    if (n > proto.length) {
	
	      proto = IndexMappings.identity(n * 5 / 4 | 0);
	      IndexMappings._identityProto = proto;
	    }
	
	    return proto.subarray(0, n);
	  },
	
	  _identityProto: _Arrays2.default.Empty.Uint32Array,
	
	  /**
	   * Create an array where each index corresponds to the values and the
	   * values map back to the index of the source array.
	   *
	   * For non-surjective mappings, the missing indices are not written to.
	   * For non-injective mappings, duplicate indices will map to their last
	   * position of occurence in the input.
	   *
	   * @param {!Array<!number>} source integer indices
	   * @param {number} n
	   *    maximum entry in source map + 1
	   *    can be {@code null} when an existing array is given
	   * @param {ArrayOrType=} arrayOrType defaults to Uint32Array
	   * @return {!Array<!number>}
	   */
	  inverse: function inverse(source, n, arrayOrType) {
	
	    var result = _Arrays2.default.maybeCreate(arrayOrType || Uint32Array, n);
	
	    for (var i = 0, e = source.length; i !== e; ++i) {
	      result[source[i]] = i;
	    }return result;
	  },
	
	  /**
	   * Transform one mapping with another, in-place unless an explicit
	   * destination is given.
	   *
	   * @param {!Array<!number>} map indices to transform
	   * @param {!Array<!number>} transform mapping to apply
	   * @param {Array<!number>=} optionalDestination
	   * @return {!Array<!number>} same as {@code map}
	   */
	  apply: function apply(map, transform, optionalDestination) {
	
	    var dst = optionalDestination || map;
	
	    for (var i = 0, n = map.length; i !== n; ++i) {
	      dst[i] = transform[map[i]];
	    }return map;
	  },
	
	  /**
	   * Count the equal elements.
	   *
	   * When an existing array is used for the destination, it must be
	   * filled with zeroes.
	   *
	   * @param {!Array<!number>} source integer indices
	   * @param {!number} n maximum entry in source map + 1
	   * @param {ArrayOrType=} arrayOrType defaults to Uint32Array
	   * @return {!Array<!number>}
	   */
	  histogram: function histogram(source, n, arrayOrType) {
	
	    var result = _Arrays2.default.maybeCreate(arrayOrType || Uint32Array, n);
	
	    for (var i = 0, e = source.length; i !== e; ++i) {
	      ++result[source[i]];
	    }return result;
	  }
	
	};
	exports.default = IndexMappings;

/***/ },
/* 181 */
/*!***********************************************************************!*\
  !*** ./src/polyMesh/geometric/model/adjacency/EdgeVertexAdjacency.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = EdgeVertexAdjacency;
	
	var _MergeSort = __webpack_require__(/*! ../../../generic/algorithm/MergeSort */ 182);
	
	var _MergeSort2 = _interopRequireDefault(_MergeSort);
	
	var _Arrays = __webpack_require__(/*! ../../../generic/utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @template T
	 * @constructor
	 *
	 */
	function EdgeVertexAdjacency(polyMap) {
	
	  this.polyMap = polyMap;
	
	  // The low value index acts as the pivot for edge enumeration, so
	  // the following array is indexed by edge UIDs:
	  this.edgeHighVertexIndices = null;
	
	  // Low -> high value index mapping (describes ranges of edge UIDs):
	  this.edgePivotRangeOffsets = null;
	
	  this.edgeVertices = null;
	
	  this._compactEdgeLowToHighMap(this._buildEdgeLowToHighMap());
	
	  this._inverseMapping();
	};
	
	EdgeVertexAdjacency.prototype = {
	
	  constructor: EdgeVertexAdjacency,
	
	  getNumEdges: function getNumEdges() {
	
	    return this.edgeHighVertexIndices.length;
	  },
	
	  // VV -> E
	  findEdgeId: function findEdgeId(faceValueIndexA, faceValueIndexB) {
	
	    var loVertex = faceValueIndexA;
	    var hiVertex = faceValueIndexB;
	
	    if (hiVertex < loVertex) {
	      loVertex = faceValueIndexB;
	      hiVertex = faceValueIndexA;
	    }
	
	    var rangeOffsets = this.edgePivotRangeOffsets;
	
	    return _Arrays2.default.binarySearch(this.edgeHighVertexIndices, hiVertex, rangeOffsets[loVertex], rangeOffsets[loVertex + 1]);
	  },
	
	  // E -> VV
	  getVerticesForEdge: function getVerticesForEdge(edgeId) {
	    return {
	      v: this.edgeVertices[edgeId * 2],
	      vNext: this.edgeVertices[edgeId * 2 + 1]
	    };
	  },
	
	  _inverseMapping: function _inverseMapping() {
	
	    var numEdges = this.getNumEdges();
	
	    var edgeVertices = new Uint32Array(numEdges * 2);
	
	    for (var v0 = 0; v0 < this.edgePivotRangeOffsets.length - 1; v0++) {
	
	      var edgeBegin = this.edgePivotRangeOffsets[v0];
	      var edgeEnd = this.edgePivotRangeOffsets[v0 + 1];
	
	      for (var i = edgeBegin; i <= edgeEnd; i++) {
	        var v1 = this.edgeHighVertexIndices[i];
	
	        edgeVertices[i * 2 + 0] = v0;
	        edgeVertices[i * 2 + 1] = v1;
	      }
	    }
	    this.edgeVertices = edgeVertices;
	  },
	
	  _buildEdgeLowToHighMap: function _buildEdgeLowToHighMap() {
	
	    var faceOffsets = this.polyMap.faceRangeOffsets;
	    var valueIndices = this.polyMap.faceValueIndices;
	
	    var nValues = this.polyMap.values.length;
	    var offsets = new Uint32Array(nValues + 2);
	    var histogramArea = offsets.subarray(2);
	
	    var faceBegin = faceOffsets[0];
	    var maxEdgesSharingPivot = 0;
	
	    // Construct histogram and accumulate:
	
	    for (var i = 1, n = faceOffsets.length; i !== n; ++i) {
	
	      var faceUntil = faceOffsets[i];
	      var vertexA = valueIndices[faceUntil - 1];
	
	      for (var j = faceBegin; j !== faceUntil; ++j) {
	
	        var vertexB = valueIndices[j];
	        var loVertex = vertexB < vertexA ? vertexB : vertexA;
	
	        var nEdges = ++histogramArea[loVertex];
	
	        if (nEdges > maxEdgesSharingPivot) maxEdgesSharingPivot = nEdges;
	
	        vertexA = vertexB;
	      }
	
	      faceBegin = faceUntil;
	    }
	
	    _Arrays2.default.accumulate(histogramArea);
	
	    // Build the indices array (shifting the offsets):
	
	    var writeOffsets = offsets.subarray(1);
	    var indices = new Uint32Array(writeOffsets[nValues]);
	
	    faceBegin = faceOffsets[0];
	
	    for (var i = 1, n = faceOffsets.length; i !== n; ++i) {
	
	      var faceUntil = faceOffsets[i];
	      var vertexA = valueIndices[faceUntil - 1];
	
	      for (var j = faceBegin; j !== faceUntil; ++j) {
	
	        var vertexB = valueIndices[j];
	
	        var loVertex = vertexA;
	        var hiVertex = vertexB;
	
	        if (hiVertex < loVertex) {
	
	          loVertex = vertexB;
	          hiVertex = vertexA;
	        }
	
	        indices[writeOffsets[loVertex]++] = hiVertex;
	
	        vertexA = vertexB;
	      }
	
	      faceBegin = faceUntil;
	    }
	
	    this.edgePivotRangeOffsets = offsets;
	    this.edgeHighVertexIndices = indices;
	
	    return maxEdgesSharingPivot;
	  },
	
	  _compactEdgeLowToHighMap: function _compactEdgeLowToHighMap(maxEdgesSharingPivot) {
	
	    var offsets = this.edgePivotRangeOffsets;
	    var indices = this.edgeHighVertexIndices;
	
	    var sorter = new _MergeSort2.default(Uint32Array, maxEdgesSharingPivot);
	
	    var nOffsets = this.polyMap.values.length + 1;
	
	    var rangeUntil = 0;
	    var rangeBegin = 0;
	    var writeOffset = 0;
	
	    for (var i = 1; i !== nOffsets; ++i) {
	
	      rangeUntil = offsets[i];
	
	      if (rangeBegin !== rangeUntil) {
	
	        sorter.sortRange(indices, rangeBegin, rangeUntil);
	
	        // Unique-compact indices within each range:
	
	        var prevElement = indices[rangeBegin];
	        indices[writeOffset++] = prevElement;
	
	        for (var j = rangeBegin + 1; j < rangeUntil; ++j) {
	
	          var element = indices[j];
	          if (element !== prevElement) {
	
	            indices[writeOffset++] = element;
	            prevElement = element;
	          }
	        }
	      }
	
	      offsets[i] = writeOffset; // re-write compact offsets
	      rangeBegin = rangeUntil; // certainly >= writeOffset
	    }
	
	    // Shrink to fit (offsets only has 2 extra elements, so view it):
	
	    this.edgeHighVertexIndices = _Arrays2.default.slice(indices, 0, writeOffset);
	
	    this.edgePivotRangeOffsets = offsets.subarray(0, nOffsets);
	  }
	
	};

/***/ },
/* 182 */
/*!*****************************************************!*\
  !*** ./src/polyMesh/generic/algorithm/MergeSort.js ***!
  \*****************************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = MergeSort;
	function MergeSort(arrayType, maxRangeLength) {
	
	  this.ping = new arrayType(maxRangeLength);
	  this.pong = new arrayType(maxRangeLength);
	};
	
	MergeSort.apply = function (array) {
	
	  var sorter = new MergeSort(array.constructor, array.length);
	  sorter.sortRange(array, 0, array.length);
	};
	
	MergeSort.prototype = {
	
	  constructor: MergeSort,
	
	  sortRange: function sortRange(array, begin, until) {
	
	    var length = until - begin;
	
	    if (length <= 4) {
	      // this implementation requires at least three elements and also
	      // has a high base cost when it comes to very short ranges
	
	      if (length >= 2) this._handleShortRange(array, begin, length);
	      return;
	    }
	
	    var read = array;
	    var readBegin = begin;
	    var readUntil = until;
	
	    var write = this.ping;
	    var writeOffset = 0;
	
	    var blockSize = 1;
	    var blockPairSize = 2;
	
	    for (var run = true; run;) {
	
	      var nMerges = (length + blockSize - 1) / blockSize >> 1,
	          l = readBegin,
	          endR = readBegin + blockPairSize;
	
	      for (var last = 0; last <= 1; ++last) {
	
	        for (var i = 1; i !== nMerges; ++i, l += blockSize, endR += blockPairSize) {
	
	          var r = l + blockSize,
	              endL = r,
	              valL = read[l],
	              valR = read[r];
	
	          for (var merge = true; merge;) {
	
	            if (valR < valL) {
	
	              write[writeOffset++] = valR;
	
	              if (++r === endR) {
	
	                write[writeOffset++] = valL;
	                while (++l !== endL) write[writeOffset++] = read[l];
	                merge = false;
	              } else valR = read[r];
	            } else {
	
	              write[writeOffset++] = valL;
	
	              if (++l === endL) {
	
	                write[writeOffset++] = valR;
	                while (++r !== endR) write[writeOffset++] = read[r];
	                merge = false;
	              } else valL = read[l];
	            }
	          }
	        }
	
	        // Handle edge cases before the last pass:
	
	        if (last === 0) {
	
	          nMerges = 2; // one more merge (1-based, exclusive)
	
	          if (endR > readUntil) endR = readUntil;else if (endR !== readUntil) {
	
	            var writeOffsetTemp = writeOffset + blockPairSize;
	
	            for (var j = endR; j !== readUntil; ++j) {
	              write[writeOffsetTemp++] = read[j];
	            }
	          }
	        }
	      }
	
	      if (write !== array) {
	        // not done yet? prepare next level
	
	        blockSize = blockPairSize;
	        blockPairSize <<= 1;
	
	        read = write;
	        readBegin = 0;
	        readUntil = length;
	
	        if (blockPairSize < length) {
	          // at least two more levels? destination is temporary
	
	          var ping = this.ping;
	          write = write === ping ? this.pong : ping;
	          writeOffset = 0;
	        } else {
	          // next will be the last level -> write back to source
	
	          write = array;
	          writeOffset = begin;
	        }
	      } else run = false;
	    }
	  },
	
	  _handleShortRange: function _handleShortRange(array, begin, length) {
	
	    var valA = array[begin];
	    var valB = array[begin + 1];
	
	    switch (length) {
	
	      case 2:
	
	        if (valB < valA) {
	
	          array[begin] = valB;
	          array[begin + 1] = valA;
	        }
	        break;
	
	      case 3:
	        {
	
	          var valC = array[begin + 2];
	
	          if (valB < valA) {
	
	            var tmp = valA;valA = valB;valB = tmp;
	          }
	
	          if (valC < valB) {
	
	            var tmp = valB;valB = valC;valC = tmp;
	          }
	
	          if (valB < valA) {
	
	            var tmp = valA;valA = valB;valB = tmp;
	          }
	
	          array[begin] = valA;
	          array[begin + 1] = valB;
	          array[begin + 2] = valC;
	
	          break;
	        }
	
	      case 4:
	        {
	
	          var valC = array[begin + 2];
	          var valD = array[begin + 3];
	
	          if (valB < valA) {
	
	            var tmp = valA;valA = valB;valB = tmp;
	          }
	
	          if (valD < valC) {
	
	            var tmp = valC;valC = valD;valD = tmp;
	          }
	
	          if (valC < valA) {
	
	            var tmp = valA;valA = valC;valC = tmp;
	          }
	
	          if (valD < valB) {
	
	            var tmp = valB;valB = valD;valD = tmp;
	          }
	
	          if (valC < valB) {
	
	            var tmp = valB;valB = valC;valC = tmp;
	          }
	
	          array[begin] = valA;
	          array[begin + 1] = valB;
	          array[begin + 2] = valC;
	          array[begin + 3] = valD;
	        }
	    }
	  }
	
	};

/***/ },
/* 183 */
/*!*********************************************************************!*\
  !*** ./src/polyMesh/geometric/model/adjacency/FaceEdgeAdjacency.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = FaceEdgeAdjacency;
	function FaceEdgeAdjacency(polyMap) {
	
	  this.polyMap = polyMap;
	
	  this.faceEdgeIndices = null;
	
	  this.edgeFaceCounts = null;
	  this.edgeFaceIndices = null;
	
	  this._compute();
	};
	
	FaceEdgeAdjacency.prototype = {
	
	  constructor: FaceEdgeAdjacency,
	
	  // F -> E
	  //faceValueIndex is the index of value on the face
	  //ie: the index of the value in faceValueIndices
	  //    not the value of faceValueIndices
	  getEdgeIdFromFaceValueIndex: function getEdgeIdFromFaceValueIndex(faceValueIndex) {
	    return this.faceEdgeIndices[faceValueIndex];
	  },
	
	  // E -> F, part 1
	  getNumFacesForEdgeId: function getNumFacesForEdgeId(edgeID) {
	    return this.edgeFaceCounts[edgeID];
	  },
	  // E -> F, part 2
	  getFaceForEdgeId: function getFaceForEdgeId(edgeId, faceOffset) {
	    return this.edgeFaceIndices[edgeId * 2 + faceOffset];
	  },
	
	  //returns false if there is an invalid surface
	  //if this function returns false this adjacency structure is invalid and cannot be used
	  checkValidity: function checkValidity() {
	    var invalidSurface = true;
	    for (var i = 0; i < this.edgeFaceCounts.length; i++) {
	      if (this.edgeFaceCounts[i] > 2) invalidSurface = false;
	    }
	    return invalidSurface;
	  },
	
	  _compute: function _compute() {
	
	    var polyMap = this.polyMap;
	    var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;
	
	    var faceRangeOffsets = polyMap.faceRangeOffsets;
	    var faceValueIndices = polyMap.faceValueIndices;
	
	    var numEdges = edgeVertexAdjacency.edgeHighVertexIndices.length;
	    //const numFaces = faceRangeOffsets.length - 1;
	    var edgeFaceCounts = new Uint32Array(numEdges);
	    var edgeFaceIndices = new Uint32Array(numEdges * 2);
	    var faceEdgeIndices = new Uint32Array(faceValueIndices.length);
	
	    for (var f = 0; f < faceRangeOffsets.length - 1; f++) {
	
	      var faceBegin = faceRangeOffsets[f];
	      var faceUntil = faceRangeOffsets[f + 1];
	      var numFaceValues = faceUntil - faceBegin;
	
	      var vNext = faceValueIndices[faceBegin];
	
	      // count faces on each edge.
	      for (var fv = 0; fv < numFaceValues; fv++) {
	
	        var v = vNext;
	        vNext = faceValueIndices[faceBegin + (fv + 1) % numFaceValues];
	
	        var edgeId = edgeVertexAdjacency.findEdgeId(v, vNext);
	
	        var faceValueIndex = faceBegin + fv;
	
	        faceEdgeIndices[faceValueIndex] = edgeId;
	
	        edgeFaceIndices[edgeId * 2 + edgeFaceCounts[edgeId]] = f;
	        edgeFaceCounts[edgeId]++;
	      }
	    }
	
	    this.faceEdgeIndices = faceEdgeIndices;
	
	    this.edgeFaceCounts = edgeFaceCounts;
	    this.edgeFaceIndices = edgeFaceIndices;
	
	    return this;
	  }
	};

/***/ },
/* 184 */
/*!******************************************************************!*\
  !*** ./src/polyMesh/geometric/model/adjacency/ValueAdjacency.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ValueAdjacency;
	function ValueAdjacency(polyMap) {
	
	  this.polyMap = polyMap;
	
	  this._compute();
	};
	
	ValueAdjacency.prototype = {
	
	  constructor: ValueAdjacency,
	
	  // V -> E, part 1
	  getNumEdgesForVertex: function getNumEdgesForVertex(valueIndex) {
	    var valueBegin = this.valueEdgeOffsets[valueIndex];
	    var valueUntil = this.valueEdgeOffsets[valueIndex + 1];
	    var numValueEdges = valueUntil - valueBegin;
	
	    return numValueEdges;
	  },
	
	  // V -> E, part 2
	  getEdgeForVertexId: function getEdgeForVertexId(valueIndex, edgeOffset) {
	    var valueBegin = this.valueEdgeOffsets[valueIndex];
	    return this.valueEdgeIndices[valueBegin + edgeOffset];
	  },
	
	  //V->VV returns the adjacent values to a given vertex
	  getAdjacentValues: function getAdjacentValues(valueIndex) {
	    var edgeVertexAdjacency = this.polyMap.edgeVertexAdjacency;
	    var adjacentValues = [];
	    var numEdges = this.getNumEdgesForVertex(valueIndex);
	
	    for (var i = 0; i < numEdges; i++) {
	      var edge = this.getEdgeForVertexId(valueIndex, i);
	      var values = edgeVertexAdjacency.getVerticesForEdge(edge);
	      var adjacentValue = values.v === valueIndex ? values.vNext : values.v;
	      adjacentValues.push(adjacentValue);
	    }
	    return adjacentValues;
	  },
	
	  //V->VV for a given faceValueIndex and face, returns the (0-2) adjacent faceValueIndices on that face
	  getAdjacentFaceValuesIndicesOnFace: function getAdjacentFaceValuesIndicesOnFace(faceValueIndex, face) {
	
	    var adjacentValuesOnFace = [];
	    var faceBegin = this.polyMap.faceRangeOffsets[face];
	    var faceEnd = this.polyMap.faceRangeOffsets[face + 1];
	    var faceSize = faceEnd - faceBegin;
	    if (faceSize < 3) return adjacentValuesOnFace;
	
	    var next = faceValueIndex === faceEnd - 1 ? faceBegin : faceValueIndex + 1;
	    var prev = faceValueIndex === faceBegin ? faceEnd - 1 : faceValueIndex - 1;
	
	    adjacentValuesOnFace.push(prev);
	    adjacentValuesOnFace.push(next);
	
	    return adjacentValuesOnFace;
	  },
	
	  // V -> F, part 1
	  getNumFacesForVertex: function getNumFacesForVertex(faceValueIndex) {
	    var valueBegin = this.valueFaceOffsets[faceValueIndex];
	    var valueUntil = this.valueFaceOffsets[faceValueIndex + 1];
	    var numValueFace = valueUntil - valueBegin;
	
	    return numValueFace;
	  },
	
	  // V -> F, part 2
	  getFaceForVertexId: function getFaceForVertexId(faceValueIndex, faceOffset) {
	    var valueBegin = this.valueFaceOffsets[faceValueIndex];
	    return this.valueFaceIndices[valueBegin + faceOffset];
	  },
	
	  _compute: function _compute() {
	
	    var polyMap = this.polyMap;
	
	    var faceRangeOffsets = polyMap.faceRangeOffsets;
	    var faceValueIndices = polyMap.faceValueIndices;
	
	    var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;
	
	    var valueFaceCount = new Uint32Array(polyMap.values.length);
	    var valueEdgeCount = new Uint32Array(polyMap.values.length);
	    //const numFaces = faceRangeOffsets.length - 1;
	
	    var numEdges = edgeVertexAdjacency.getNumEdges();
	    var edgeUnique = new Uint8Array(numEdges);
	
	    // histogram.
	    for (var f = 0; f < polyMap.faceRangeOffsets.length - 1; f++) {
	
	      var faceBegin = polyMap.faceRangeOffsets[f];
	      var faceUntil = polyMap.faceRangeOffsets[f + 1];
	      var numFaceValues = faceUntil - faceBegin;
	
	      var vNext = polyMap.faceValueIndices[faceBegin];
	
	      for (var fv = 0; fv < numFaceValues; fv++) {
	
	        var v = vNext;
	        vNext = polyMap.faceValueIndices[faceBegin + (fv + 1) % numFaceValues];
	
	        var e = edgeVertexAdjacency.findEdgeId(v, vNext);
	
	        valueFaceCount[v]++;
	
	        // is this the first time processing this edge
	        if (edgeUnique[e] === 0) {
	          edgeUnique[e] = 1;
	
	          valueEdgeCount[v]++;
	          valueEdgeCount[vNext]++;
	        }
	      }
	    }
	
	    // create offset arrays.
	    var faceSum = 0,
	        edgeSum = 0;
	    var valueFaceOffsets = new Uint32Array(valueFaceCount.length + 1);
	    var valueEdgeOffsets = new Uint32Array(valueEdgeCount.length + 1);
	    for (var i = 0; i < valueFaceCount.length; i++) {
	      valueFaceOffsets[i] = faceSum;
	      faceSum += valueFaceCount[i];
	      valueFaceCount[i] = 0;
	
	      valueEdgeOffsets[i] = edgeSum;
	      edgeSum += valueEdgeCount[i];
	      valueEdgeCount[i] = 0;
	    }
	    valueFaceOffsets[valueFaceCount.length] = faceSum;
	    valueEdgeOffsets[valueEdgeCount.length] = edgeSum;
	
	    // fill in the values
	    var valueFaceIndices = new Uint32Array(faceSum);
	    var valueEdgeIndices = new Uint32Array(edgeSum);
	
	    for (var f = 0; f < polyMap.faceRangeOffsets.length - 1; f++) {
	
	      var faceBegin = polyMap.faceRangeOffsets[f];
	      var faceUntil = polyMap.faceRangeOffsets[f + 1];
	      var numFaceValues = faceUntil - faceBegin;
	
	      var vNext = polyMap.faceValueIndices[faceBegin];
	
	      for (var fv = 0; fv < numFaceValues; fv++) {
	
	        var v = vNext;
	        vNext = polyMap.faceValueIndices[faceBegin + (fv + 1) % numFaceValues];
	
	        var e = edgeVertexAdjacency.findEdgeId(v, vNext);
	
	        valueFaceIndices[valueFaceOffsets[v] + valueFaceCount[v]++] = f;
	
	        // is this the first time processing this edge
	        if (edgeUnique[e] === 1) {
	          edgeUnique[e] = 2;
	
	          valueEdgeIndices[valueEdgeOffsets[v] + valueEdgeCount[v]++] = e;
	          valueEdgeIndices[valueEdgeOffsets[vNext] + valueEdgeCount[vNext]++] = e;
	        }
	      }
	    }
	
	    this.valueFaceOffsets = valueFaceOffsets;
	    this.valueFaceIndices = valueFaceIndices;
	
	    this.valueEdgeOffsets = valueEdgeOffsets;
	    this.valueEdgeIndices = valueEdgeIndices;
	  }
	};

/***/ },
/* 185 */
/*!*********************************************************************!*\
  !*** ./src/polyMesh/geometric/model/adjacency/FaceFaceAdjacency.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = FaceFaceAdjacency;
	function FaceFaceAdjacency(polyMap) {
	
	  //for each face there is an offset array (faceFaceCounts)
	  //this offset array indexes into an array of all faces that are adjacent (faceFaceIndices)
	
	  this.polyMap = polyMap;
	
	  this.faceFaceCounts = null;
	  this.faceFaceIndices = null;
	
	  this._compute();
	};
	
	FaceFaceAdjacency.prototype = {
	
	  constructor: FaceFaceAdjacency,
	
	  //F->F
	  getAdjacentFaces: function getAdjacentFaces(face) {
	    var numAdjacentFaces = this.faceFaceCounts[face + 1] - this.faceFaceCounts[face];
	    var adjacentFaces = new Uint32Array(numAdjacentFaces);
	    for (var i = this.faceFaceCounts[face], j = 0; i < this.faceFaceCounts[face + 1]; i++, j++) {
	      adjacentFaces[j] = this.faceFaceIndices[i];
	    }
	    return adjacentFaces;
	  },
	
	  //return array of 0-2 faces
	  //valuesIndex is the index of the vertex in the values array
	  adjacentFacesOnVertex: function adjacentFacesOnVertex(face, valuesIndex) {
	    var adjacentFaces = this.getAdjacentFaces(face);
	    var faceRangeOffsets = this.polyMap.faceRangeOffsets;
	    var faceValueIndices = this.polyMap.faceValueIndices;
	    var adjacentFacesOnVertex = [];
	
	    for (var i = 0; i < adjacentFaces.length; i++) {
	      for (var j = faceRangeOffsets[adjacentFaces[i]]; j < faceRangeOffsets[adjacentFaces[i] + 1]; j++) {
	        if (faceValueIndices[j] === valuesIndex) {
	          adjacentFacesOnVertex.push(adjacentFaces[i]);
	          break;
	        }
	      }
	    }
	    return adjacentFacesOnVertex;
	  },
	
	  _compute: function _compute() {
	
	    var faceRangeOffsets = this.polyMap.faceRangeOffsets;
	    var faceValueIndices = this.polyMap.faceValueIndices;
	    var faceEdgeAdjacency = this.polyMap.faceEdgeAdjacency;
	
	    var faceFaceCounts = new Uint32Array(faceRangeOffsets.length);
	    var faceFaceIndices = [];
	
	    for (var i = 0; i < faceRangeOffsets.length - 1; i++) {
	
	      var adjacentFaces = [];
	      for (var j = faceRangeOffsets[i]; j < faceRangeOffsets[i + 1]; j++) {
	        var edge = faceEdgeAdjacency.getEdgeIdFromFaceValueIndex(j);
	
	        //if edge has 2 faces then find the adjacent face that isnt the given face
	        var numFaces = faceEdgeAdjacency.getNumFacesForEdgeId(edge);
	        if (numFaces > 1) {
	          var adjacentFaceIndex = faceEdgeAdjacency.getFaceForEdgeId(edge, 0);
	          if (adjacentFaceIndex === i) adjacentFaceIndex = faceEdgeAdjacency.getFaceForEdgeId(edge, 1);
	          adjacentFaces.push(adjacentFaceIndex);
	        }
	      }
	
	      faceFaceCounts[i + 1] = faceFaceCounts[i] + adjacentFaces.length;
	      faceFaceIndices.push.apply(faceFaceIndices, adjacentFaces);
	    }
	
	    this.faceFaceCounts = faceFaceCounts;
	    this.faceFaceIndices = Uint32Array.from(faceFaceIndices);
	
	    return this;
	  }
	};

/***/ },
/* 186 */
/*!**************************************************!*\
  !*** ./src/polyMesh/geometric/model/PolyMesh.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = PolyMesh;
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	var _PolyMaps = __webpack_require__(/*! ./PolyMaps */ 177);
	
	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);
	
	var _PolyMap = __webpack_require__(/*! ./PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function PolyMesh(from) {
	
	  if (!from) {
	    this.faceRangeOffsets = new Uint32Array(1);
	    this.positions = new _PolyMap2.default();
	
	    this.colorMaps = new _ObjectsByName2.default();
	    this.uvMaps = new _ObjectsByName2.default();
	  } else {
	
	    if (!from.colorMaps) console.error('Polymesh must have initialized colorMaps container.');
	    if (!from.uvMaps) console.error('Polymesh must have initialized uvMaps container.');
	
	    this.faceRangeOffsets = from.faceRangeOffsets; //Uint32Array
	    this.materialIds = from.materialIds; //PolyMap
	
	    this.positions = from.positions; //PolyMap
	
	    this.normalMap = from.normalMap; //PolyMap
	    this.tangentMap = from.tangentMap; //PolyMap
	    this.colorMaps = _ObjectsByName2.default.shallowClone(from.colorMaps); //ObjectsByName contains PolyMap
	    this.uvMaps = _ObjectsByName2.default.shallowClone(from.uvMaps); //ObjectsByName contains PolyMap
	
	    this.skinning = from.skinning; //Skinning
	  }
	};
	
	PolyMesh.prototype = {
	
	  constructor: PolyMesh,
	
	  getNumFaces: function getNumFaces() {
	
	    return this.faceRangeOffsets.length - 1;
	  },
	
	  getNumFaceVertices: function getNumFaceVertices() {
	
	    return this.positions.faceValueIndices.length;
	  },
	
	  getNumVertices: function getNumVertices() {
	
	    return this.positions.values.length;
	  },
	
	  getMapById: function getMapById(mapId) {
	
	    return _PolyMaps2.default.resolveMap(this, mapId) || null;
	  }
	
	};
	
	PolyMesh.fromData = function (faceRangeOffsets, positions, optionalIndices, optionalMaterialIds) {
	
	  return new PolyMesh({
	
	    faceRangeOffsets: faceRangeOffsets,
	
	    positions: positions instanceof _PolyMap2.default ? positions : _PolyMap2.default.fromData(faceRangeOffsets, optionalIndices || null, positions),
	
	    materialIds: optionalMaterialIds || null, // Uint32Array
	
	    normalMap: null, // optional PolyMap< THREE.Vector3 >
	    tangentMap: null, // optional PolyMap< THREE.Vector3 >
	
	    uvMaps: new _ObjectsByName2.default(), // optional ObjectsByName< PolyMap<THREE.Vector2> >
	    colorMaps: new _ObjectsByName2.default(), // optional ObjectsByName< PolyMap<THREE.Color> >
	
	    skinning: null
	
	  });
	};

/***/ },
/* 187 */
/*!**************************************************!*\
  !*** ./src/polyMesh/geometric/model/Skinning.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Skinning;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Skinning(from) {
	
	  this.positionSkinRange = from.positionSkinRange; //Uint32Array
	  this.skinWeights = from.skinWeights; //Float32Array
	  this.skinBoneIndices = from.skinBoneIndices; //Uint16Array
	
	  this.poseSkinToPoseBoneTransform = from.poseSkinToPoseBoneTransform; //ObjectArrayView of Matrix4's
	  this.poseBoneToWorldTransform = from.poseBoneToWorldTransform; //ObjectArrayView of Matrix4's
	};
	
	Skinning.fromData = function (positionSkinRange, skinWeights, skinBoneIndices) {
	
	  if (result.skinWeights.length !== result.skinBoneIndices.length) throw Error("skinWeights and skinBoneIndices sizes do not match.");
	
	  var result = new Skinning({
	
	    positionSkinRange: positionSkinRange,
	    skinWeights: skinWeights,
	    skinBoneIndices: skinBoneIndices,
	
	    poseSkinToPoseBoneTransform: poseSkinToPoseBoneTransform,
	    poseBoneToWorldTransform: poseBoneToWorldTransform
	
	  });
	
	  return result;
	};
	
	Skinning.prototype = {
	
	  constructor: Skinning,
	
	  applyTransforms: function applyTransforms(positions, skinToWorldTransform, boneWorldTransforms, rootBoneIndex) {
	    return this.deform(this.createFinalTransforms(skinToWorldTransform, boneWorldTransforms, rootBoneIndex), positions);
	  },
	
	  createFinalTransforms: function createFinalTransforms(skinToWorldTransform, boneWorldTransforms, rootBoneIndex) {
	
	    var poseSkinToPoseBoneTransform = this.poseSkinToPoseBoneTransform;
	    var worldToSkinTransform = new _three2.default.Matrix4().getInverse(skinToWorldTransform, true);
	    var finalTransforms = new Array(poseSkinToPoseBoneTransform.length);
	
	    var identity = new _three2.default.Matrix4().identity();
	
	    if (poseSkinToPoseBoneTransform.length === 0) {
	      return finalTransforms;
	    }
	
	    var rootToWorldTransform = undefined;
	    var worldToRootTransform = undefined;
	    var poseRootToSkinTransform = undefined;
	
	    if (rootBoneIndex > -1) {
	      rootToWorldTransform = boneWorldTransforms[rootBoneIndex];
	      worldToRootTransform = new _three2.default.Matrix4().getInverse(rootToWorldTransform, true);
	      poseRootToSkinTransform = new _three2.default.Matrix4().getInverse(poseSkinToPoseBoneTransform.getAt(rootBoneIndex), true);
	    }
	
	    var boneToRootTransform = new _three2.default.Matrix4();
	    var boneToSkinTransform = new _three2.default.Matrix4();
	    var finalTransform = new _three2.default.Matrix4();
	
	    for (var i = 0, il = poseSkinToPoseBoneTransform.length; i < il; i++) {
	
	      var boneToWorldTransform = boneWorldTransforms[i];
	      if (rootBoneIndex > -1) {
	        boneToRootTransform.multiplyMatrices(worldToRootTransform, boneToWorldTransform);
	        boneToSkinTransform.multiplyMatrices(poseRootToSkinTransform, boneToRootTransform);
	      } else {
	        boneToSkinTransform.multiplyMatrices(worldToSkinTransform, boneToWorldTransform);
	      }
	
	      finalTransforms[i] = new _three2.default.Matrix4().multiplyMatrices(boneToSkinTransform, poseSkinToPoseBoneTransform.getAt(i));
	    }
	
	    return finalTransforms;
	  },
	
	  deform: function deform(finalTransforms, positions) {
	
	    var positionSkinRange = this.positionSkinRange;
	    var skinWeights = this.skinWeights;
	    var skinBoneIndices = this.skinBoneIndices;
	
	    var deformedPositions = new _ObjectArrayView2.default(_three2.default.Vector3, positions.length);
	    var v = new _three2.default.Vector3();
	    var d = new _three2.default.Vector3();
	
	    for (var i = 0; i < positions.length; i++) {
	      positions.getAt(i, v);
	      d.multiplyScalar(0);
	      for (var j = positionSkinRange[i]; j < positionSkinRange[i + 1]; j++) {
	        positions.getAt(i, v);
	        v.applyMatrix4(finalTransforms[skinBoneIndices[j]]);
	        v.multiplyScalar(skinWeights[j]);
	        d.addVectors(d, v);
	      }
	      if (positionSkinRange[i + 1] - positionSkinRange[i] === 0) {
	        d.copy(v);
	      }
	      deformedPositions.setAt(i, d);
	    }
	    return deformedPositions;
	  }
	
	};

/***/ },
/* 188 */
/*!***************************************************************!*\
  !*** ./src/polyMesh/geometric/algorithm/ImportConversions.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	var _GlobalCompaction = __webpack_require__(/*! ../../generic/algorithm/GlobalCompaction */ 189);
	
	var _GlobalCompaction2 = _interopRequireDefault(_GlobalCompaction);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ImportConversions = {
	
	  collapsePositions: function collapsePositions(positions, indices) {
	
	    var compaction = new _GlobalCompaction2.default(positions),
	        compactPositions = compaction.compactedValues(positions);
	
	    if (indices) compaction.transcribeIndices(indices);
	
	    return compactPositions;
	  },
	
	  collapseMapVertexValues: function collapseMapVertexValues(polyMesh, polyMap) {
	
	    var positions = polyMesh.positions.updateInverseIndex(),
	        indexRanges = polyMesh.faceRangeOffsets,
	        positionIndices = positions.faceValueIndices,
	        faceRangeOffsets = positions.faceRangeOffsets,
	        currFaceIndex = -1,
	        nextFaceStart = 0,
	        faceIndexOffsets = positions.valueFaceIndexOffsets,
	        faceIndices = positions.valueFaceIndices,
	        values = polyMap.values,
	        data = values.data,
	        elementSize = values.elementSize,
	        valueIndices = polyMap.faceValueIndices;
	
	    for (var i = 0, n = polyMesh.getNumFaceVertices(); i !== n; ++i) {
	
	      var positionIndex = positionIndices[i],
	          currValueIndex = valueIndices[i],
	          currValueOffset = currValueIndex * elementSize;
	
	      if (i === nextFaceStart) nextFaceStart = faceRangeOffsets[++currFaceIndex + 1];
	
	      var facesStart = faceIndexOffsets[positionIndex],
	          facesUntil = faceIndexOffsets[positionIndex + 1];
	
	      for (var j = facesStart; j !== facesUntil; ++j) {
	
	        var faceIndex = faceIndices[j];
	        if (faceIndex === currFaceIndex) break;
	
	        var valueIndexOffset = positions.findValueIndexOffset(faceIndex, positionIndex),
	            valueIndex = valueIndices[valueIndexOffset];
	
	        if (valueIndex !== currValueIndex) {
	
	          if (_Arrays2.default.rangeEquals(data, currValueOffset, data, valueIndex * elementSize, elementSize)) valueIndices[i] = valueIndex;
	        }
	      }
	    }
	  }
	
	};
	
	exports.default = ImportConversions;

/***/ },
/* 189 */
/*!************************************************************!*\
  !*** ./src/polyMesh/generic/algorithm/GlobalCompaction.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = GlobalCompaction;
	
	var _Arrays = __webpack_require__(/*! ../utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	var _BitSet = __webpack_require__(/*! ../container/BitSet */ 190);
	
	var _BitSet2 = _interopRequireDefault(_BitSet);
	
	var _ObjectArrayView = __webpack_require__(/*! ../container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _IndexMappings = __webpack_require__(/*! ./IndexMappings */ 180);
	
	var _IndexMappings2 = _interopRequireDefault(_IndexMappings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Construct a compact (injective / scattering) map to globally unique values
	 * within an ObjectArrayView and optionally also the (injective / compacting)
	 * source-to-target mapping (STTM).
	 *
	 * For each index in the input data, the STTM contains the index in compacted
	 * form. The STTM can be used to transcribe existing indices into the data or,
	 * if the data is "unindexed", it is the indices.
	 *
	 * @constructor
	 *
	 * @param {!ObjectArrayView} values
	 * @param {boolean=} ttsOnly whether to only create the target-to-source map
	 */
	function GlobalCompaction(values, ttsOnly) {
	
	  var nValues = values.length;
	
	  var tupleOrder = _Arrays2.default.sort(_IndexMappings2.default.identity(nValues), values.newCompareAtIndicesStable());
	
	  var nUnique = 0;
	  var sourceToTargetMap = null;
	
	  var compare = values.newCompareAtIndices();
	
	  if (ttsOnly) {
	
	    nUnique = _Arrays2.default.unique(tupleOrder, compare);
	  } else {
	    // customized UNIQUE algo that builds the STTM on the fly
	
	    sourceToTargetMap = new Uint32Array(nValues);
	
	    var writeIndex = 0;
	    var prevUniqueAt = 0;
	    var minValueIndex = tupleOrder[0];
	
	    for (var i = 1; i < nValues; ++i) {
	
	      var valueIndex = tupleOrder[i];
	
	      if (compare(valueIndex, minValueIndex) !== 0) {
	
	        for (var j = prevUniqueAt; j !== i; ++j) {
	          sourceToTargetMap[tupleOrder[j]] = minValueIndex;
	        }prevUniqueAt = i;
	        minValueIndex = valueIndex;
	
	        if (++writeIndex !== i) tupleOrder[writeIndex] = valueIndex;
	      }
	    }
	
	    for (var j = prevUniqueAt; j !== nValues; ++j) {
	      sourceToTargetMap[tupleOrder[j]] = minValueIndex;
	    }nUnique = writeIndex + 1;
	  }
	
	  // Now that duplicates have been removed, restore the original order by
	  // sorting the indices (since we have a finite integer range, we can do
	  // so very quickly using a BitSet):
	
	  var targetToSourceMap = new _BitSet2.default(nValues).includeFromArray(tupleOrder, 0, nUnique).toIndexArray(nUnique);
	
	  if (sourceToTargetMap !== null) {
	
	    // The STTM already has all equal indices mapped to the first, but
	    // these indices are still in respect to the input, so they need to
	    // be translated to refer to compact data:
	
	    var reusableMemory = tupleOrder;
	
	    var sparseCompaction = _IndexMappings2.default.inverse(targetToSourceMap, null, reusableMemory);
	
	    _IndexMappings2.default.apply(sourceToTargetMap, sparseCompaction);
	  }
	
	  this.targetToSourceMap = targetToSourceMap;
	  this.sourceToTargetMap = sourceToTargetMap;
	};
	
	GlobalCompaction.prototype = {
	
	  constructor: GlobalCompaction,
	
	  compactedValues: function compactedValues(data) {
	
	    var map = this.targetToSourceMap;
	    var nCompact = map.length;
	
	    var result = new _ObjectArrayView2.default(data.type, nCompact);
	
	    var elementData = data.newRangeArray();
	
	    for (var i = 0; i !== nCompact; ++i) {
	
	      data.rangeToArray(map[i], 1, elementData);
	      result.arrayToRange(elementData, i, 1);
	    }
	
	    return result;
	  },
	
	  indices: function indices(nFaceVertices) {
	
	    return new Uint32Array(this.sourceToTargetMap);
	  },
	
	  transcribeIndices: function transcribeIndices(indices) {
	
	    return _IndexMappings2.default.apply(indices, this.sourceToTargetMap);
	  }
	
	};

/***/ },
/* 190 */
/*!**************************************************!*\
  !*** ./src/polyMesh/generic/container/BitSet.js ***!
  \**************************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = BitSet;
	function BitSet(length) {
	
	  this.data = new Uint32Array(length + 31 >>> 5);
	  this.length = length;
	
	  this.byteView = null;
	};
	
	BitSet.prototype = {
	
	  constructor: BitSet,
	
	  clear: function clear() {
	
	    this.data.fill(0);
	    return this;
	  },
	
	  fill: function fill(optionalOffset, optionalLength) {
	
	    var data = this.data;
	
	    var begin = optionalOffset !== undefined ? optionalOffset : 0;
	    var until = optionalLength !== undefined ? begin + optionalLength : this.length;
	
	    var wordIndexBegin = begin >>> 5;
	    var wordIndexUntil = until >>> 5;
	
	    // Smear the highbit with a signed shift for a pattern of MSBs:
	    var maskBegin = -0x80000000 >> ~begin;
	
	    // Power of two minus one yields a pattern of LSBs:
	    var maskUntil = (1 << until) - 1;
	
	    if (wordIndexBegin === wordIndexUntil) data[wordIndexBegin] |= maskBegin & maskUntil;else {
	
	      data[wordIndexBegin] |= maskBegin;
	
	      if (++wordIndexBegin !== wordIndexUntil) data.fill(~0, wordIndexBegin, wordIndexUntil);
	
	      data[wordIndexUntil] |= maskUntil;
	    }
	
	    return this;
	  },
	
	  include: function include(i) {
	
	    this.data[i >>> 5] |= 1 << i;
	  },
	
	  exclude: function exclude(i) {
	
	    this.data[i >>> 5] &= ~(1 << i);
	  },
	
	  contains: function contains(i) {
	
	    return (this.data[i >>> 5] & 1 << i) !== 0;
	  },
	
	  swap: function swap(i, j) {
	
	    var data = this.data;
	
	    var wordIndexI = i >>> 5,
	        maskI = 1 << i;
	    var wordIndexJ = j >>> 5,
	        maskJ = 1 << j;
	
	    var stateI = (data[wordIndexI] & maskI) !== 0;
	    var stateJ = (data[wordIndexJ] & maskJ) !== 0;
	
	    if (stateI !== stateJ) {
	
	      if (stateI) {
	
	        data[wordIndexI] &= ~maskI;
	        data[wordIndexJ] |= maskJ;
	      } else {
	
	        data[wordIndexI] |= maskI;
	        data[wordIndexJ] &= ~maskJ;
	      }
	    }
	  },
	
	  testAndInclude: function testAndInclude(i) {
	
	    var data = this.data;
	
	    var wordIndex = i >>> 5,
	        mask = 1 << i;
	
	    var unchangedWord = data[wordIndex];
	
	    data[wordIndex] = unchangedWord | mask;
	    return (unchangedWord & mask) !== 0;
	  },
	
	  includeFromArray: function includeFromArray(array, optionalOffset, optionalUntil) {
	
	    var data = this.data;
	
	    for (var j = optionalOffset || 0, e = optionalUntil || array.length; j < e; ++j) {
	
	      var i = array[j];
	
	      data[i >>> 5] |= 1 << i;
	    }
	
	    return this;
	  },
	
	  containsAnyIn: function containsAnyIn(array, optionalOffset, optionalUntil) {
	
	    var result = false;
	    var data = this.data;
	
	    for (var j = optionalOffset || 0, e = optionalUntil || array.length; j < e && !result; ++j) {
	
	      var i = array[j];
	
	      result = (data[i >>> 5] & 1 << i) !== 0;
	    }
	
	    return result;
	  },
	
	  countSetBits: function countSetBits(optionalOffset, optionalUntil) {
	
	    var result = 0;
	
	    var begin = optionalOffset !== undefined ? optionalOffset : 0;
	    var until = optionalUntil !== undefined ? optionalUntil : this.length;
	
	    if ((until - begin & -0x4000) === 0)
	      // that is, 'begin' is less than 'until' and fewer than 2048 bytes
	
	      result = this.countSetBitsInShortRange(begin, until);else if (begin < until) {
	      // use a LUT - it's several times faster at scale
	
	      var data = this.byteView;
	      var lut = BitSet._ByteBitCount;
	
	      if (data === null) {
	
	        data = new Uint8Array(this.data.buffer);
	        this.byteView = data;
	      }
	
	      var wordIndexBegin = begin >>> 3;
	      var wordIndexUntil = until >>> 3;
	
	      // Smear the highbit with a signed shift for a pattern of MSBs:
	      var maskBegin = -0x80000000 >> 31 - (begin & 7);
	      // Power of two minus one yields a pattern of LSBs:
	      var maskUntil = (1 << (until & 7)) - 1;
	
	      result = lut[data[wordIndexBegin] & maskBegin];
	
	      for (var j = wordIndexBegin + 1; j !== wordIndexUntil; ++j) {
	        result += lut[data[j]];
	      }result += lut[data[wordIndexUntil] & maskUntil];
	    }
	
	    return result;
	  },
	
	  countSetBitsInShortRange: function countSetBitsInShortRange(begin, until) {
	
	    // Note: For some odd reason the data word must be signed to keep
	    // V8 from deoptimizing - all unsigned access won't do.
	
	    var result = 0;
	
	    var data = this.data;
	
	    var here = begin;
	    var index = here >>> 5;
	
	    var word = data[index] >> here;
	
	    result = word & 1;
	
	    while (++here !== until) {
	
	      if ((here & 31) !== 0) word >>= 1;else word = data[++index] | 0; // cast to signed (important)
	
	      result += word & 1;
	    }
	
	    return result;
	  },
	
	  toIndexArray: function toIndexArray(optionalKnownLength) {
	
	    var result = new Uint32Array(optionalKnownLength === undefined ? this.countSetBits() : optionalKnownLength);
	    var baseIndex = 0;
	    var writeOffset = 0;
	    var data = this.data;
	
	    for (var j = 0, n = data.length; j !== n; ++j) {
	
	      for (var mask = data[j], i = baseIndex; mask !== 0; mask >>>= 1, ++i) {
	
	        if ((mask & 1) !== 0) result[writeOffset++] = i;
	      }baseIndex += 32;
	    }
	
	    return result;
	  }
	
	};
	
	BitSet._ByteBitCount = (function () {
	
	  var lut = new Uint8Array(256);
	
	  for (var i = 0; i !== 256; ++i) {
	
	    var value = 0;
	    for (var m = i; m !== 0; m >>>= 1) {
	      if ((m & 1) !== 0) ++value;
	    }lut[i] = value;
	  }
	
	  return lut;
	})();

/***/ },
/* 191 */
/*!*******************************************************!*\
  !*** ./src/polyMesh/geometric/transient/Selection.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Selection;
	
	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	var _PolyMaps = __webpack_require__(/*! ../model/PolyMaps */ 177);
	
	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);
	
	var _ScalarBuffer = __webpack_require__(/*! ../../generic/container/ScalarBuffer */ 176);
	
	var _ScalarBuffer2 = _interopRequireDefault(_ScalarBuffer);
	
	var _BitSet = __webpack_require__(/*! ../../generic/container/BitSet */ 190);
	
	var _BitSet2 = _interopRequireDefault(_BitSet);
	
	var _IndexMappings = __webpack_require__(/*! ../../generic/algorithm/IndexMappings */ 180);
	
	var _IndexMappings2 = _interopRequireDefault(_IndexMappings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Selection(indices, meaning, optionalMapId) {
	
	  this.indices = indices;
	  this.meaning = meaning;
	  this.mapId = optionalMapId || _PolyMaps2.default.IdPositions;
	};
	
	Selection.Faces = 0;
	Selection.Vertices = 1;
	Selection.Edges = 2;
	
	Selection.prototype = {
	
	  constructor: Selection,
	
	  getIndices: function getIndices(mesh, meaning, optionalMapId) {
	
	    var indices = this.indices,
	        convTab = Selection.ConversionTable,
	        convFunc = convTab[this.meaning][meaning];
	
	    if (convFunc !== null) indices = convFunc.call(null, mesh, indices, this.mapId, optionalMapId || _PolyMaps2.default.IdPositions);
	
	    return indices;
	  }
	
	};
	
	Selection.newRandomSelection = function (seed, density, polyMesh, meaning, optionalMapId) {
	
	  var n = Selection.getNumElements(polyMesh, meaning, optionalMapId),
	      nPopulation = density * n | 0,
	      bits = new _BitSet2.default(n).fill(0, nPopulation),
	      prng = seed;
	
	  for (var i = 0, e = n - 1; i < e; ++i) {
	
	    // Magic constants taken from
	    // https://en.wikipedia.org/wiki/Linear_congruential_generator
	    prng = prng * 22695477 + 1 >>> 0;
	
	    bits.swap(i, i + (prng & 0x3fffffff) % (n - i));
	  }
	
	  return new Selection(bits.toIndexArray(), meaning, optionalMapId);
	};
	
	// Provides an identity mapping in case a selection is not provided:
	
	Selection.getIndices = function (mesh, meaning, optionalSelectionOrMapId, optionalSelection) {
	
	  var mapId = _PolyMaps2.default.IdPositions,
	      selection = optionalSelection;
	
	  if (typeof optionalSelectionOrMapId === 'string') mapId = optionalSelectionOrMapId;else selection = optionalSelectionOrMapId;
	
	  return !selection ? _IndexMappings2.default.identityForReading(Selection.getNumElements(mesh, meaning, mapId)) : selection.getIndices(mesh, meaning, mapId);
	};
	
	Selection.getNumElements = function (mesh, meaning, optionalMapId) {
	
	  switch (meaning) {
	
	    case Selection.Faces:
	      return mesh.getNumFaces();
	
	    case Selection.Vertices:
	      return _PolyMaps2.default.resolveMap(mesh, optionalMapId || _PolyMaps2.default.IdPositions).values.length;
	
	    case Selection.Edges:
	      return _PolyMaps2.default.resolveMap(mesh, optionalMapId || _PolyMaps2.default.IdPositions).getNumEdges();
	
	    default:
	      throw Error("Bad meaning argument!");
	  }
	};
	
	// Conversions:
	
	Selection.convFacesToVertices = function (mesh, indices, _, mapId) {
	
	  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapId),
	      result = new _BitSet2.default(mapOut.values.length),
	      faceRangeOffsets = mesh.faceRangeOffsets,
	      mapValueIndices = mapOut.faceValueIndices;
	
	  for (var i = 0, n = indices.length; i !== n; ++i) {
	
	    var faceIndex = indices[i],
	        begin = faceRangeOffsets[faceIndex],
	        until = faceRangeOffsets[faceIndex + 1];
	
	    result.includeFromArray(mapValueIndices, begin, until);
	  }
	
	  return result.toIndexArray();
	};
	
	Selection.convFacesToEdges = function (mesh, indices, _, mapId) {
	
	  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapId),
	      result = new _BitSet2.default(mapOut.getNumEdges()),
	      faceRangeOffsets = mesh.faceRangeOffsets,
	      mapValueIndices = mapOut.faceValueIndices;
	
	  for (var i = 0, n = indices.length; i !== n; ++i) {
	
	    var faceIndex = indices[i],
	        begin = faceRangeOffsets[faceIndex],
	        until = faceRangeOffsets[faceIndex + 1];
	
	    if (begin !== until) {
	
	      var vertexA = mapValueIndices[until - 1];
	
	      for (var j = begin; j !== until; ++j) {
	
	        var vertexB = mapValueIndices[j];
	        result.include(mapOut.findEdgeId(vertexA, vertexB));
	        vertexA = vertexB;
	      }
	    }
	  }
	
	  return result.toIndexArray();
	};
	
	//
	
	Selection.convVerticesToFaces = function (mesh, indices, mapId, _) {
	
	  var buffer = new _ScalarBuffer2.default(Uint32Array),
	      faceRangeOffsets = mesh.faceRangeOffsets,
	      mapValueIndices = _PolyMaps2.default.resolveMap(mesh, mapId).faceValueIndices,
	      nFaces = mesh.getNumFaces();
	
	  for (var faceIndex = 0; faceIndex !== nFaces; ++faceIndex) {
	
	    var begin = faceRangeOffsets[faceIndex],
	        until = faceRangeOffsets[faceIndex + 1],
	        allVerticesFound = true;
	
	    for (var i = begin; i !== until && allVerticesFound; ++i) allVerticesFound = -1 < _Arrays2.default.binarySearch(indices, mapValueIndices[i]);
	
	    if (allVerticesFound) buffer.push(faceIndex);
	  }
	
	  return buffer.toArrayAndClear();
	};
	
	Selection.convVerticesToVertices = function (mesh, indices, mapIdIn, mapIdOut) {
	
	  if (mapIdIn === mapIdOut) return indices;
	
	  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapIdOut),
	      result = new _BitSet2.default(mapOut.values.length),
	      mapOutValueIndices = mapOut.faceValueIndices,
	      mapIn = _PolyMaps2.default.resolveMap(mesh, mapIdIn).updateInverseIndex(),
	      faceIndexOffsets = mapIn.valueFaceIndexOffsets,
	      faceIndices = mapIn.valueFaceIndices;
	
	  for (var i = 0, n = indices.length; i !== n; ++i) {
	
	    var mapInValueIndex = indices[i],
	        facesBegin = faceIndexOffsets[mapInValueIndex],
	        facesUntil = faceIndexOffsets[mapInValueIndex + 1];
	
	    for (var j = facesBegin; j !== facesUntil; ++j) {
	
	      var vertexOffset = mapIn.findValueIndexOffset(faceIndices[j], mapInValueIndex);
	
	      result.include(mapOutValueIndices[vertexOffset]);
	    }
	  }
	
	  return result.toIndexArray();
	};
	
	Selection.convVerticesToEdges = function (mesh, indices, mapIdIn, mapIdOut) {
	
	  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapIdOut),
	      result = new _BitSet2.default(mapOut.getNumEdges()),
	      faceRangeOffsets = mesh.faceRangeOffsets,
	      mapValueIndices = _PolyMaps2.default.resolveMap(mesh, mapIdIn).faceValueIndices,
	      nFaces = mesh.getNumFaces();
	
	  for (var faceIndex = 0; faceIndex !== nFaces; ++faceIndex) {
	
	    var begin = faceRangeOffsets[faceIndex],
	        until = faceRangeOffsets[faceIndex + 1];
	
	    if (begin !== until) {
	
	      var last = mapValueIndices[--until],
	          lastSelected = -1 < _Arrays2.default.binarySearch(indices, last),
	          vertexA = last,
	          prevSelected = lastSelected;
	
	      for (var j = begin; j !== until; ++j) {
	
	        var vertexB = mapValueIndices[j],
	            selected = -1 < _Arrays2.default.binarySearch(indices, vertexB);
	
	        if (prevSelected && selected) result.include(mapOut.findEdgeId(vertexA, vertexB));
	
	        vertexA = vertexB;
	        prevSelected = selected;
	      }
	
	      if (prevSelected && lastSelected) result.include(mapOut.findEdgeId(vertexA, last));
	    }
	  }
	
	  return result.toIndexArray();
	};
	
	//
	
	Selection.convEdgesToFaces = function (mesh, indices, mapIdIn, _) {
	
	  var tmp = Selection.convEdgesToVertices(mesh, indices, mapIdIn, mapIdIn);
	
	  return Selection.convVerticesToFaces(mesh, tmp, mapIdIn, '');
	};
	
	Selection.convEdgesToVertices = function (mesh, indices, mapIdIn, mapIdOut) {
	
	  var tmp = Selection.convEdgesToVerticesOfSameMap(mesh, indices, mapIdIn);
	
	  return Selection.convVerticesToVertices(mesh, tmp, mapIdIn, mapIdOut);
	};
	
	Selection.convEdgesToEdges = function (mesh, indices, mapIdIn, mapIdOut) {
	
	  if (mapIdIn === mapIdOut) return indices;
	
	  var tmp = Selection.convEdgesToVerticesOfSameMap(mesh, indices, mapIdIn);
	
	  return Selection.convVerticesToEdges(mesh, indices, mapIdIn, mapIdOut);
	};
	
	Selection.convEdgesToVerticesOfSameMap = function (mesh, indices, mapId) {
	
	  var map = _PolyMaps2.default.resolveMap(mesh, mapId).updateEdgeMap(),
	      edgeRangeOffsets = map.edgePivotRangeOffsets,
	      highVertexIndices = map.edgeHighVertexIndices,
	      result = new _BitSet2.default(map.values.length);
	
	  for (var i = 0, n = indices.length; i !== n; ++i) {
	
	    var edgeId = indices[i],
	        hiVertex = highVertexIndices[edgeId],
	        searchResult = _Arrays2.default.binarySearch(edgeRangeOffsets, edgeId + 1);
	
	    if (searchResult < 0) searchResult = ~searchResult;
	
	    var loVertex = searchResult - 1;
	
	    result.include(hiVertex);
	    result.include(loVertex);
	  }
	
	  return result.toIndexArray();
	};
	
	Selection.ConversionTable = [
	
	// From Faces to...
	[
	// ... Faces
	null,
	// ... Vertices
	Selection.convFacesToVertices,
	// ... Edges
	Selection.convFacesToEdges],
	// From Vertices to...
	[
	// ... Faces
	Selection.convVerticesToFaces,
	// ... Vertices
	Selection.convVerticesToVertices,
	// ... Edges
	Selection.convVerticesToEdges],
	// From Edges to...
	[
	// ... Faces
	Selection.convEdgesToFaces,
	// ... Vertices
	Selection.convEdgesToVertices,
	// ... Edges
	Selection.convEdgesToEdges]];

/***/ },
/* 192 */
/*!*******************************************!*\
  !*** ./src/polyMesh/three/ThreeExport.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _PolyMaps = __webpack_require__(/*! ../geometric/model/PolyMaps */ 177);
	
	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);
	
	var _Exporter = __webpack_require__(/*! ../geometric/tool/Exporter */ 193);
	
	var _Exporter2 = _interopRequireDefault(_Exporter);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ThreeExport = {
	
	    NoIndices: 0,
	    SimpleIndices: 1,
	    CompactIndices: 2,
	
	    exportBufferGeometry: function exportBufferGeometry(polyMesh, indicesMode, interleaved, exportTangents, oldMesh, prevTriangulation, prevIndexing, prevValueMap) {
	        var result = new _three2.default.BufferGeometry();
	        var exportSpec = [];
	
	        var _ThreeExport$_prepare = ThreeExport._prepare(polyMesh, exportSpec, indicesMode, interleaved, exportTangents, oldMesh, prevTriangulation, prevIndexing);
	
	        var exporter = _ThreeExport$_prepare.exporter;
	        var triangulationChanged = _ThreeExport$_prepare.triangulationChanged;
	
	        var IdPositions = _PolyMaps2.default.IdPositions;
	        var valueMap = {};
	
	        if (indicesMode !== ThreeExport.NoIndices) {
	
	            var indices = indicesMode === ThreeExport.SimpleIndices ? exporter.getTriangulatingIndices() : exporter.getMapIndices(IdPositions);
	
	            result.setIndex(new _three2.default.BufferAttribute(indices, 1, false));
	        }
	
	        if (!interleaved) {
	
	            for (var i = 0; i !== exportSpec.length; ++i) {
	
	                //console.log(indicesMode);
	
	                var attrSpec = exportSpec[i],
	                    triangulateValues = indicesMode === ThreeExport.NoIndices;
	
	                var data;
	                var newMap = _PolyMaps2.default.resolveMap(polyMesh, attrSpec.mapId),
	                    oldMap = oldMesh && _PolyMaps2.default.resolveMap(oldMesh, attrSpec.mapId);
	
	                if (oldMap !== newMap || !prevValueMap) {
	                    data = indicesMode !== ThreeExport.CompactIndices ? exporter.getUnindexedMapValues(attrSpec.mapId, triangulateValues) : exporter.getMapValues(attrSpec.mapId);
	                } else {
	                    //console.log('skip');
	                    data = prevValueMap[attrSpec.mapId];
	                }
	
	                valueMap[attrSpec.mapId] = data;
	                result.addAttribute(attrSpec.threeName, new _three2.default.BufferAttribute(data, attrSpec.itemSize, attrSpec.normalized));
	            }
	        } else {
	
	            var stride = 0;
	            for (var i = 0; i !== exportSpec.length; ++i) stride += exportSpec[i].itemSize;
	
	            var nValuess = 0;
	            switch (indicesMode) {
	
	                case ThreeExport.NoIndices:
	                    // no. of triangulated vertices
	                    nValuess = exporter.getNumFaceVertices();
	                    break;
	
	                case ThreeExport.SimpleIndices:
	                    // no. of values
	                    nValuess = exporter.mesh.getNumFaceVertices();
	                    break;
	
	                case ThreeExport.CompactIndices:
	                    // as calculated
	                    nValuess = exporter.getNumMapValues(_PolyMaps2.default.IdPositions);
	            }
	
	            var data = new Float32Array(stride * nValuess),
	                buffer = new _three2.default.InterleavedBuffer(data, stride),
	                offset = 0;
	
	            for (var i = 0; i !== exportSpec.length; ++i) {
	
	                var attrSpec = exportSpec[i],
	                    itemSize = attrSpec.itemSize,
	                    mapId = attrSpec.mapId;
	
	                if (indicesMode !== ThreeExport.CompactIndices) {
	
	                    exporter.getUnindexedMapValues(mapId, indicesMode === ThreeExport.NoIndices, data, offset, stride);
	                } else {
	
	                    exporter.getMapValues(mapId, data, offset, stride);
	                }
	
	                result.addAttribute(attrSpec.threeName, new _three2.default.InterleavedBufferAttribute(buffer, itemSize, offset));
	
	                offset += itemSize;
	            }
	        }
	
	        return {
	            geometry: result,
	            triangulation: exporter.triangulation,
	            renderIndexing: exporter.renderIndexing,
	            triangulationChanged: triangulationChanged,
	            valueMap: valueMap
	        };
	    },
	
	    _prepare: function _prepare(polyMesh, outSpec, indicesMode, interleaved, exportTangents, oldMesh, prevTriangulation, prevIndexing) {
	
	        var exporter = new _Exporter2.default(polyMesh),
	            mapsToExport = [];
	
	        var retriangulate = !oldMesh || !prevTriangulation || oldMesh.positions.faceValueIndices !== polyMesh.positions.faceValueIndices;
	        var reIndex = !oldMesh || !prevIndexing;
	
	        var mapOffset = 0;
	        //console.log(polyMesh);
	        for (var iter = new _PolyMaps2.default.Iterator(polyMesh); iter.next();) {
	
	            var threeName = '',
	                itemSize = 3,
	                normalized = false;
	
	            switch (iter.typeId) {
	
	                case _PolyMaps2.default.TypePosition:
	                    threeName = 'position';
	                    break;
	
	                case _PolyMaps2.default.TypeTangent:
	                    // Note: Since tangents are normally ignored by the three.js
	                    // renderer, they must be requested explicitly.
	                    if (!exportTangents) break;
	                    threeName = 'tangent';
	                    break;
	
	                case _PolyMaps2.default.TypeNormal:
	                    threeName = 'normal';
	                    break;
	
	                case _PolyMaps2.default.TypeUV:
	                    if (iter.index >= 2) break; // max two UV maps
	                    threeName = 'uv' + (iter.index !== 0 ? iter.index + 1 : '');
	                    itemSize = 2;
	                    break;
	
	                case _PolyMaps2.default.TypeColor:
	
	                    if (iter.index >= 1) break; // use first color map
	                    threeName = 'color';
	                    normalized = true;
	
	            }
	
	            if (!threeName || interleaved && normalized) continue;
	
	            var mapId = iter.getId();
	            mapsToExport.push(mapId);
	
	            outSpec.push({
	                mapId: mapId,
	                threeName: threeName,
	                itemSize: itemSize,
	                normalized: normalized
	            });
	            ++mapOffset;
	        }
	
	        for (var i = 0; i < outSpec.length && !reIndex; i++) {
	            var oldMap = _PolyMaps2.default.resolveMap(oldMesh, outSpec[i].mapId),
	                newMap = _PolyMaps2.default.resolveMap(polyMesh, outSpec[i].mapId);
	            if (oldMap.faceValueIndices !== newMap.faceValueIndices) reIndex = true;
	        }
	
	        //console.log(polyMesh===(prevData && prevData.mesh));
	        if (indicesMode === ThreeExport.CompactIndices && !reIndex) {
	            prevIndexing.mesh = polyMesh;
	            exporter.renderIndexing = prevIndexing;
	        } else if (indicesMode === ThreeExport.CompactIndices && reIndex) {
	
	            exporter.reindexForRendering(mapsToExport);
	        }
	
	        var triangulationChanged = false;
	        if (retriangulate) {
	            exporter.triangulate();
	            triangulationChanged = true;
	        } else {
	            exporter.triangulation = prevTriangulation;
	        }
	        return { exporter: exporter, triangulationChanged: triangulationChanged };
	    }
	
	};
	
	exports.default = ThreeExport;

/***/ },
/* 193 */
/*!*************************************************!*\
  !*** ./src/polyMesh/geometric/tool/Exporter.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Exporter;
	
	var _Arrays = __webpack_require__(/*! ../../generic/utility/Arrays */ 167);
	
	var _Arrays2 = _interopRequireDefault(_Arrays);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ScalarArrayView = __webpack_require__(/*! ../../generic/container/ScalarArrayView */ 175);
	
	var _ScalarArrayView2 = _interopRequireDefault(_ScalarArrayView);
	
	var _IndexMappings = __webpack_require__(/*! ../../generic/algorithm/IndexMappings */ 180);
	
	var _IndexMappings2 = _interopRequireDefault(_IndexMappings);
	
	var _RenderIndexing = __webpack_require__(/*! ../algorithm/RenderIndexing */ 194);
	
	var _RenderIndexing2 = _interopRequireDefault(_RenderIndexing);
	
	var _SimpleFanTriangulation = __webpack_require__(/*! ../algorithm/SimpleFanTriangulation */ 195);
	
	var _SimpleFanTriangulation2 = _interopRequireDefault(_SimpleFanTriangulation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Exporter(polyMesh) {
	
	  this.mesh = polyMesh;
	
	  this.triangulation = null;
	  this.renderIndexing = null;
	};
	
	Exporter.prototype = {
	
	  constructor: Exporter,
	
	  reindexForRendering: function reindexForRendering(optionalMapIdWhitelist) {
	
	    if (this.triangulation !== null) throw Error("Reindex must come before triangulation!");
	
	    this.renderIndexing = new _RenderIndexing2.default(this.mesh, optionalMapIdWhitelist);
	
	    return this;
	  },
	
	  triangulate: function triangulate(optionalTriangulationType) {
	
	    var triangulationType = optionalTriangulationType || _SimpleFanTriangulation2.default;
	
	    this.triangulation = new triangulationType(this.mesh, this.renderIndexing);
	
	    return this;
	  },
	
	  getNumFaces: function getNumFaces() {
	
	    var triangulation = this.triangulation;
	
	    return triangulation === null ? this.mesh.getNumFaces() : triangulation.numTriangles;
	  },
	
	  getNumFaceVertices: function getNumFaceVertices() {
	
	    return this.triangulation === null ? this.mesh.getNumFaceVertices() : this.getNumFaces() * 3;
	  },
	
	  getNumMapValues: function getNumMapValues(mapId) {
	
	    var renderIndexing = this.renderIndexing;
	
	    return renderIndexing !== null ? renderIndexing.numVertices : this.mesh.getMapById(mapId).values.length;
	  },
	
	  getFaceArities: function getFaceArities(optionalArrayOrType, optionalOffset, optionalStride) {
	
	    if (this.triangulation !== null) throw Error("No face arity export for triangular meshes!");
	
	    var result = new _ScalarArrayView2.default(this.getNumFaces(), optionalArrayOrType, optionalOffset, optionalStride),
	        offsets = this.mesh.faceRangeOffsets,
	        nOffsets = offsets.length;
	
	    if (nOffsets > 1) {
	
	      var prevOffset = offsets[0];
	
	      for (var i = 1; i !== nOffsets; ++i) {
	
	        var offset = offsets[i];
	        result.setAt(i - 1, offset - prevOffset);
	        prevOffset = offset;
	      }
	    }
	
	    return result.data;
	  },
	
	  getMaterialIds: function getMaterialIds(optionalArrayOrType, optionalOffset, optionalStride) {
	
	    var result = null,
	        source = this.mesh.materialIDs;
	
	    if (source === null) return null;
	
	    if (this.triangulation === null) {
	
	      var offset = optionalOffset || 0,
	          stride = optionalStride || 1,
	          arrayOrType = optionalArrayOrType || source.data.constructor;
	
	      if (offset === 0 && stride === 1 && arrayOrType === source.data.constructor) return source;
	
	      result = new _ScalarArrayView2.default(source.length, arrayOrType, offset, stride);
	
	      result.fromArray(source);
	    } else {
	
	      this.triangulation.translateMaterialIds(source, result);
	    }
	
	    return result.data;
	  },
	
	  getMapValues: function getMapValues(mapId, optionalArrayOrType, optionalOffset, optionalStride) {
	
	    var result = null,
	        renderIndexing = this.renderIndexing,
	        source = this.mesh.getMapById(mapId).values,
	        type = source.type,
	        offset = optionalOffset || 0,
	        stride = optionalStride || type.InstanceScalarSize,
	        arrayOrType = optionalArrayOrType || source.data.constructor;
	
	    if (renderIndexing === null && offset === 0 && stride === type.InstanceScalarSize && arrayOrType === source.data.constructor) result = source; // compatible format, just expose the data
	
	    else {
	
	        var length = renderIndexing === null ? source.length : renderIndexing.numVertices;
	
	        result = this._offsetObjects(type, length, arrayOrType, offset, stride);
	
	        if (renderIndexing !== null) {
	
	          renderIndexing.getMapValues(mapId, result);
	        } else {
	
	          result.fromArray(source.data);
	        }
	      }
	
	    return result.data;
	  },
	
	  getMapIndices: function getMapIndices(mapId, optionalArrayOrType, optionalOffset, optionalStride) {
	
	    var result = null,
	        renderIndexing = this.renderIndexing,
	        triangulation = this.triangulation,
	        source = renderIndexing !== null ? renderIndexing.renderIndices : this.mesh.getMapById(mapId).faceValueIndices;
	
	    if (triangulation === null) {
	
	      var offset = optionalOffset || 0,
	          stride = optionalStride || 1,
	          arrayOrType = optionalArrayOrType || source.constructor;
	
	      if (offset === 0 && stride === 1 && arrayOrType === source.constructor) return source;
	
	      result = new _ScalarArrayView2.default(source.length, arrayOrType, offset, stride);
	
	      result.fromArray(source);
	    } else {
	
	      result = new _ScalarArrayView2.default(this.triangulation.numTriangles * 3, optionalArrayOrType, optionalOffset, optionalStride);
	
	      triangulation.translateIndices(source, result);
	    }
	
	    return result.data;
	  },
	
	  getUnindexedMapValues: function getUnindexedMapValues(mapId, allowTriangulation, optionalArrayOrType, optionalOffset, optionalStride) {
	
	    var result = null,
	        polyMap = this.mesh.getMapById(mapId),
	        values = polyMap.values,
	        valueType = values.type,
	        indices = polyMap.faceValueIndices,
	        triangulation = this.triangulation;
	
	    if (!allowTriangulation || triangulation === null) {
	
	      result = this._offsetObjects(valueType, indices.length, optionalArrayOrType || values.data.constructor, optionalOffset, optionalStride);
	
	      var temp = values.newRangeArray(1);
	
	      for (var i = 0, n = indices.length; i !== n; ++i) result.arrayToRange(values.rangeToArray(indices[i], 1, temp), i, 1);
	    } else {
	
	      result = this._offsetObjects(valueType, triangulation.numTriangles * 3, optionalArrayOrType || values.data.constructor, optionalOffset, optionalStride);
	
	      triangulation.translateToUnindexedValues(values, result, indices);
	    }
	
	    return result.data;
	  },
	
	  getTriangulatingIndices: function getTriangulatingIndices(optionalArrayOrType, optionalOffset, optionalStride) {
	
	    var triangulation = this.triangulation;
	
	    if (triangulation === null) return null;
	
	    var result = new _ScalarArrayView2.default(this.getNumFaceVertices(), optionalArrayOrType, optionalOffset, optionalStride),
	        nFaceVertices = this.getNumFaceVertices(),
	        identityMap = _IndexMappings2.default.identityForReading(nFaceVertices);
	
	    triangulation.translateIndices(identityMap, result);
	
	    return result.data;
	  },
	
	  _offsetObjects: function _offsetObjects(type, length, arrayOrType, optionalOffset, optionalStride) {
	
	    var offset = optionalOffset || 0,
	        stride = optionalStride || type.InstanceScalarSize,
	        offsetLength = offset / stride | 0,
	        minArrayLength = (offsetLength + length) * stride,
	        array = _Arrays2.default.maybeCreate(arrayOrType, minArrayLength),
	        offsetView = offset === 0 ? array : array.subarray(offset);
	
	    return new _ObjectArrayView2.default(type, null, offsetView, stride);
	  }
	
	};

/***/ },
/* 194 */
/*!************************************************************!*\
  !*** ./src/polyMesh/geometric/algorithm/RenderIndexing.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = RenderIndexing;
	
	var _PolyMaps = __webpack_require__(/*! ../model/PolyMaps */ 177);
	
	var _PolyMaps2 = _interopRequireDefault(_PolyMaps);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function RenderIndexing(polyMesh, optionalMapIdWhitelist) {
	
	  var mapIds = [],
	      mapStates = [];
	
	  for (var iter = new _PolyMaps2.default.Iterator(polyMesh); iter.next();) {
	
	    var map = iter.element,
	        mapId = iter.getId();
	
	    if (optionalMapIdWhitelist && optionalMapIdWhitelist.indexOf(mapId) === -1) continue;
	
	    mapIds.push(mapId);
	
	    mapStates.push({
	      map: map,
	      faceIndices: map.updateInverseIndex().valueFaceIndices,
	      facesOffset: 0
	    });
	  }
	
	  // Processing face vertices, an n-way MERGE-like step is performed to
	  // identify a previously processed face that uses the same combination
	  // of value indices. Forward processing and the sorted nature of the
	  // inverse PolyMap indices allow this algorithm to be very efficient.
	
	  var nFaceVertices = polyMesh.getNumFaceVertices(),
	      nMaps = mapStates.length,
	      renderIndices = new Uint32Array(nFaceVertices),
	      valueIndices = new Uint32Array(nFaceVertices * nMaps),
	      writeOffset = 0,
	      nVertices = 0,
	      faceRangeOffsets = polyMesh.faceRangeOffsets,
	      faceIndex = -1,
	      nextFaceStart = 0,
	      pivotState = mapStates[nMaps - 1],
	      pivotFaces = pivotState.faceIndices,
	      mapScanStart = nMaps - 2;
	
	  for (var i = 0; i !== nFaceVertices; ++i) {
	
	    if (i === nextFaceStart) nextFaceStart = faceRangeOffsets[++faceIndex + 1];
	
	    // Try to find a face before this one that already uses all the
	    // values for this vertex:
	
	    var reusePossible = true,
	        reuseFromFace = 0;
	
	    for (var j = 0; j !== nMaps; ++j) {
	
	      var mapState = mapStates[j],
	          map = mapState.map,
	          valueIndex = map.faceValueIndices[i];
	
	      // Speculatively write data:
	      valueIndices[writeOffset + j] = valueIndex;
	
	      if (reusePossible) {
	
	        var facesBegin = map.valueFaceIndexOffsets[valueIndex],
	            firstFaceIndex = map.valueFaceIndices[facesBegin];
	
	        // Speculatively prepare the scanning state:
	        mapState.facesOffset = facesBegin;
	
	        // Early-out when a value index is used for the first time:
	        reusePossible = firstFaceIndex !== faceIndex;
	      }
	    }
	
	    if (reusePossible) {
	
	      var pivotFaceIdxPos = pivotState.facesOffset,
	          pivotFaceIndex = 0,
	          pivotFaceGood = true;
	
	      do {
	
	        pivotFaceIndex = pivotFaces[pivotFaceIdxPos++];
	        pivotFaceGood = pivotFaceIndex !== faceIndex;
	        reusePossible = pivotFaceGood;
	
	        for (var j = mapScanStart; pivotFaceGood && j !== -1; --j) {
	
	          var mapState = mapStates[j],
	              faceIdxPos = mapState.facesOffset,
	              faceIndices = mapState.faceIndices,
	              candidate = faceIndices[faceIdxPos];
	
	          while (candidate < pivotFaceIndex) candidate = faceIndices[++faceIdxPos];
	
	          if (candidate !== pivotFaceIndex) pivotFaceGood = false;
	          if (candidate === faceIndex) reusePossible = false;else mapState.facesOffset = faceIdxPos;
	
	          // Note that the next pivot face will have a higher index
	          // and that we'll see the current face when out of input.
	          // Also note that the pivot face has a lower index than
	          // the current face.
	        }
	      } while (reusePossible && !pivotFaceGood);
	
	      reusePossible = pivotFaceGood;
	      reuseFromFace = pivotFaceIndex;
	    }
	
	    if (reusePossible) {
	
	      var positionMap = mapStates[0].map,
	          faceVertexIndex = positionMap.findValueIndexOffset(reuseFromFace, positionMap.faceValueIndices[i]),
	          reuseIndex = renderIndices[faceVertexIndex];
	
	      renderIndices[i] = reuseIndex;
	    } else {
	
	      renderIndices[i] = nVertices++;
	      writeOffset += nMaps;
	    }
	  }
	
	  this.mesh = polyMesh;
	  this.mapIds = mapIds;
	  this.renderIndices = renderIndices;
	  this.valueIndices = valueIndices.slice(0, writeOffset);
	  this.numVertices = nVertices;
	};
	
	RenderIndexing.prototype = {
	
	  constructor: RenderIndexing,
	
	  getMapValues: function getMapValues(mapId, targetView) {
	
	    var mapIds = this.mapIds,
	        mapIndex = mapIds.indexOf(mapId),
	        nVertices = this.numVertices,
	        valueIndices = this.valueIndices;
	
	    if (mapIndex === -1) throw Error("Map with id '" + mapId + "' not found!");
	
	    var map = _PolyMaps2.default.resolveMap(this.mesh, mapId),
	        mapValues = map.values;
	
	    if (targetView.length < nVertices) throw Error("Data won't fit!");
	
	    var viOffset = mapIndex,
	        viStride = mapIds.length,
	        tmp = new targetView.type();
	
	    for (var i = 0; i !== nVertices; ++i) {
	
	      var valueIndex = valueIndices[viOffset + i * viStride];
	      targetView.setAt(i, mapValues.getAt(valueIndex, tmp));
	    }
	  }
	
	};

/***/ },
/* 195 */
/*!********************************************************************!*\
  !*** ./src/polyMesh/geometric/algorithm/SimpleFanTriangulation.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = SimpleFanTriangulation;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function SimpleFanTriangulation(mesh) {
	
	  this.mesh = mesh;
	
	  var nTriangles = 0,
	      faceOffsets = mesh.faceRangeOffsets,
	      faceBegin = faceOffsets[0],
	      maxNumVerticesPerFace = 0;;
	
	  for (var i = 1, n = faceOffsets.length; i < n; ++i) {
	
	    var faceUntil = faceOffsets[i],
	        nVertices = faceUntil - faceBegin;
	
	    if (nVertices >= 3) nTriangles += nVertices - 2;
	
	    maxNumVerticesPerFace = Math.max(maxNumVerticesPerFace, nVertices);
	
	    faceBegin = faceUntil;
	  }
	
	  this.startFaceIndices = this.getStartFaceIndices(mesh.positions, maxNumVerticesPerFace);
	  //console.log( 'this.startFaceIndices', this.startFaceIndices );
	
	  this.numTriangles = nTriangles;
	};
	
	SimpleFanTriangulation.prototype = {
	
	  constructor: SimpleFanTriangulation,
	
	  getStartFaceIndices: function getStartFaceIndices(positionsPolyMap, maxNumVerticesPerFace) {
	
	    //return an array of size faces, that says which face vertex index to use as the starting vertex in simple fan triangulation.
	    // you will want return the first convex vertex face vertex index (in the range 0 to number of vertices in that face), if there is one
	    // otherwise you can return 0.
	
	    var faceOffsets = this.mesh.faceRangeOffsets;
	
	    var numFaces = this.mesh.faceRangeOffsets.length - 1;
	    var startFaceIndices = new Uint32Array(numFaces);
	    var faceEdgeSign = new Float32Array(maxNumVerticesPerFace);
	
	    var faceValueIndices = positionsPolyMap.faceValueIndices;
	    var positionValues = positionsPolyMap.values;
	
	    var dPrev = new _three2.default.Vector3();
	    var d = new _three2.default.Vector3();
	    var dNext = new _three2.default.Vector3();
	    var dTemp;
	
	    var pPrev = new _three2.default.Vector3();
	    var p = new _three2.default.Vector3();
	    var pNext = new _three2.default.Vector3();
	    var pNextNext = new _three2.default.Vector3();
	    var pTemp;
	
	    var cpTemp;
	    var cp = new _three2.default.Vector3();
	    var cpNext = new _three2.default.Vector3();
	
	    for (var i = 0, il = faceOffsets.length - 1; i < il; ++i) {
	
	      var faceBegin = faceOffsets[i];
	      var faceUntil = faceOffsets[i + 1];
	      var numFaceVertices = faceUntil - faceBegin;
	
	      if (numFaceVertices <= 3) {
	        continue;
	      }
	
	      var vPrev;
	      var v = faceValueIndices[faceBegin + (numFaceVertices - 1)];
	      var vNext = faceValueIndices[faceBegin];
	      var vNextNext = faceValueIndices[faceBegin + 1 % numFaceVertices];
	
	      positionValues.getAt(v, p);
	      positionValues.getAt(vNext, pNext);
	      positionValues.getAt(vNextNext, pNextNext);
	
	      d.copy(pNext).sub(p);
	      dNext.copy(pNextNext).sub(pNext);
	
	      cpNext.copy(dNext).cross(d);
	
	      for (var j = 0; j < numFaceVertices; ++j) {
	
	        vPrev = v;
	        v = vNext;
	        vNext = vNextNext;
	        vNextNext = faceValueIndices[faceBegin + (j + 2) % numFaceVertices];
	
	        pTemp = pPrev;
	        pPrev = p;
	        p = pNext;
	        pNext = pNextNext;
	        pNextNext = pTemp;
	        positionValues.getAt(vNextNext, pNextNext);
	
	        dTemp = dPrev;
	        dPrev = d;
	        d = dNext;
	        dNext = dTemp;
	        dNext.copy(pNextNext).sub(pNext);
	
	        cpTemp = cp;
	        cp = cpNext;
	        cpNext = cpTemp;
	        cpNext.copy(dNext).cross(d);
	
	        var sign = cp.dot(cpNext);
	
	        faceEdgeSign[j] = sign;
	      }
	
	      //console.log( 'faceEdgeSign for face: ', i, faceEdgeSign );
	
	      for (var j = 0; j < numFaceVertices; ++j) {
	        var sign = faceEdgeSign[j];
	        var signNext = faceEdgeSign[(j + 1) % numFaceVertices];
	        if (sign >= 0 && signNext >= 0) {
	          startFaceIndices[i] = (j + 1) % numFaceVertices;
	          break;
	        }
	      }
	    }
	
	    return startFaceIndices;
	  },
	
	  translateIndices: function translateIndices(inputArray, outputView) {
	
	    var faceOffsets = this.mesh.faceRangeOffsets,
	        faceBegin = faceOffsets[0],
	        outputArray = outputView.data,
	        writeIndex = outputView.offset,
	        stride = outputView.stride;
	
	    for (var i = 1, e = faceOffsets.length; i < e; ++i) {
	
	      var faceUntil = faceOffsets[i];
	      var numFaceVertices = faceUntil - faceBegin;
	      var startOffset = this.startFaceIndices[i - 1];
	
	      for (var j = 0; j < numFaceVertices - 2; ++j) {
	
	        outputArray[writeIndex] = inputArray[faceBegin + startOffset];
	        writeIndex += stride;
	
	        outputArray[writeIndex] = inputArray[faceBegin + (startOffset + j + 1) % numFaceVertices];
	        writeIndex += stride;
	
	        outputArray[writeIndex] = inputArray[faceBegin + (startOffset + j + 2) % numFaceVertices];
	        writeIndex += stride;
	      }
	
	      faceBegin = faceUntil;
	    }
	  },
	
	  translateMaterialIds: function translateMaterialIds(outputView) {
	
	    var faceOffsets = this.mesh.faceRangeOffsets,
	        inputArray = this.mesh.materialIds,
	        faceBegin = faceOffsets[0];
	
	    for (var i = 1, j = 0, n = faceOffsets.length; i < n; ++i) {
	
	      var materialId = inputArray[i - 1],
	          faceUntil = faceOffsets[i],
	          nVertices = faceUntil - faceBegin,
	          nTriangles = nVertices >= 3 ? nVertices - 2 : 0;
	
	      for (var writeUntil = writeIndex + nTriangles * stride; writeIndex !== writeUntil; writeIndex += stride) outputArray[writeIndex] = materialId;
	
	      faceBegin = faceUntil;
	    }
	  },
	
	  translateToUnindexedValues: function translateToUnindexedValues(inputView, outputView, indices) {
	
	    var faceOffsets = this.mesh.faceRangeOffsets,
	        faceBegin = faceOffsets[0],
	        writeIndex = 0,
	        temp = inputView.newRangeArray(1);
	
	    for (var i = 1, e = faceOffsets.length; i < e; ++i) {
	
	      var faceUntil = faceOffsets[i];
	      var numFaceVertices = faceUntil - faceBegin;
	      var startOffset = this.startFaceIndices[i - 1];
	
	      for (var j = 0; j < numFaceVertices - 2; ++j) {
	
	        outputView.arrayToRange(inputView.rangeToArray(indices[faceBegin + startOffset], 1, temp), writeIndex, 1);
	
	        outputView.arrayToRange(inputView.rangeToArray(indices[faceBegin + (startOffset + j + 1) % numFaceVertices], 1, temp), writeIndex + 1, 1);
	
	        outputView.arrayToRange(inputView.rangeToArray(indices[faceBegin + (startOffset + j + 2) % numFaceVertices], 1, temp), writeIndex + 2, 1);
	
	        writeIndex += 3;
	      }
	
	      faceBegin = faceUntil;
	    }
	  }
	
	};

/***/ },
/* 196 */
/*!**********************************************!*\
  !*** ./src/operators/PolyMesh/MeshSmooth.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _subdivision = __webpack_require__(/*! ../../polyMesh/geometric/operator/subdivision */ 197);
	
	var _subdivision2 = _interopRequireDefault(_subdivision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MeshSmooth = {
	  schema: {
	    subdivisions: { label: 'Subdivisions', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 4 },
	    hardEdges: { label: 'Hard Edges', type: 'Boolean', defaultValue: false }
	  },
	
	  update: function update(operator, primitive) {
	    var mesh = primitive.mesh;
	    var subdivisions = operator.subdivisions || 1;
	    //currently we are always assuming hard edges
	    //const hardEdges = operator.hardEdges || true;
	    if (!mesh) return primitive;
	
	    for (var i = 0; i < subdivisions; i++) {
	      mesh = (0, _subdivision2.default)(mesh);
	    }
	    primitive.mesh = mesh;
	    return primitive;
	  }
	};
	
	exports.default = MeshSmooth;

/***/ },
/* 197 */
/*!********************************************************!*\
  !*** ./src/polyMesh/geometric/operator/subdivision.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = subdivision;
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _polyMeshValidation = __webpack_require__(/*! ./polyMeshValidation */ 198);
	
	var _polyMeshValidation2 = _interopRequireDefault(_polyMeshValidation);
	
	var _removeDuplicateNormals = __webpack_require__(/*! ./removeDuplicateNormals */ 199);
	
	var _removeDuplicateNormals2 = _interopRequireDefault(_removeDuplicateNormals);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function subdivision(mesh) {
	
	  // based on theory given on pages 623-624 of "Real-Time Rendering"
	  var subdividePolyMap = function subdividePolyMap(polyMap, newFaceRangeOffsets, faceEdgeCreases, faceValueCorners) {
	
	    var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;
	    var valueAdjacency = polyMap.valueAdjacency;
	    var faceEdgeAdjacency = polyMap.faceEdgeAdjacency;
	    /*
	    if(!faceEdgeAdjacency.checkValidity()){
	      throw 'This polymap contains an invalid surface and cannot be subdivided. Edge Adjacency will fail.';
	    }//*/
	
	    var values = polyMap.values;
	    var valueType = values.type;
	    var numValues = values.length;
	    var faceRangeOffsets = polyMap.faceRangeOffsets;
	    var numFaces = faceRangeOffsets.length - 1;
	    var faceValueIndices = polyMap.faceValueIndices;
	    var numEdges = edgeVertexAdjacency.getNumEdges();
	
	    var numNewFaces = faceValueIndices.length;
	
	    var vertexCorners = new Uint8Array(polyMap.values.length);
	    for (var i = 0; i < faceValueCorners.length; i++) {
	      vertexCorners[faceValueIndices[i]] = faceValueCorners[i];
	    }
	
	    if (!newFaceRangeOffsets) {
	      newFaceRangeOffsets = new Uint32Array(numNewFaces + 1);
	      for (var f = 0; f < newFaceRangeOffsets.length; f++) {
	        newFaceRangeOffsets[f] = f * 4;
	      }
	    }
	
	    var numNewFaceValueIndices = numNewFaces * 4;
	    var newFaceValueIndices = new Uint32Array(numNewFaceValueIndices);
	
	    // pre allocate all new vertices
	    //    updated vertices (V) + edge centroids (E) + face centroids (V)
	    var edgeOffset = numValues;
	    var faceOffset = edgeOffset + numEdges;
	    var numNewValues = numValues + numEdges + numFaces;
	    var newValues = new _ObjectArrayView2.default(valueType, numNewValues);
	
	    var valueEdgeValence = new Uint8Array(numValues);
	    var valueFaceValence = new Uint8Array(numValues);
	    var edgeFaceValence = new Uint8Array(numEdges);
	    var edgeUnique = new Uint8Array(numEdges);
	
	    var tempFaceCentroid = new valueType();
	    var tempValue = new valueType();
	    var tempNextValue = new valueType();
	    var tempEdgeCentroid = new valueType();
	    var tempConnectedValue = new valueType();
	    var tempConnectedFace = new valueType();
	
	    var nf = 0;
	
	    var edgeCreases = new Uint8Array(numEdges);
	    var valueCreases = new Uint8Array(numValues);
	
	    for (var f = 0; f < numFaces; f++) {
	
	      var faceBegin = faceRangeOffsets[f];
	      var faceUntil = faceRangeOffsets[f + 1];
	      var numFaceValues = faceUntil - faceBegin;
	
	      var vNext = faceValueIndices[faceBegin];
	      var vNextNext = faceValueIndices[faceBegin + 1 % numFaceValues];
	
	      var eNext = edgeVertexAdjacency.findEdgeId(vNext, vNextNext);
	
	      // calculate face centroid
	      tempFaceCentroid.multiplyScalar(0.0);
	
	      for (var fv = 0; fv < numFaceValues; fv++) {
	
	        var v = vNext;
	        vNext = vNextNext;
	        vNextNext = faceValueIndices[faceBegin + (fv + 2) % numFaceValues];
	
	        var e = eNext;
	        eNext = edgeVertexAdjacency.findEdgeId(vNext, vNextNext);
	
	        edgeFaceValence[e]++;
	        valueFaceValence[v]++;
	
	        // is this the first time processing this edge
	        if (edgeUnique[e] == 0) {
	          edgeUnique[e] = 1;
	
	          valueEdgeValence[v]++;
	          valueEdgeValence[vNext]++;
	
	          if (faceEdgeCreases[faceBegin + fv]) {
	            edgeCreases[e] = 1;
	            valueCreases[v]++;
	            valueCreases[vNext]++;
	          }
	        }
	
	        values.getAt(v, tempValue);
	        tempFaceCentroid.add(tempValue);
	
	        newFaceValueIndices[nf++] = edgeOffset + e;
	        newFaceValueIndices[nf++] = vNext;
	        newFaceValueIndices[nf++] = edgeOffset + eNext;
	        newFaceValueIndices[nf++] = faceOffset + f;
	      }
	
	      tempFaceCentroid.multiplyScalar(1.0 / numFaceValues);
	      newValues.setAt(faceOffset + f, tempFaceCentroid);
	    }
	    // create new edges
	    for (var e = 0; e < numEdges; e++) {
	
	      var v = edgeVertexAdjacency.edgeVertices[e * 2];
	      var vNext = edgeVertexAdjacency.edgeVertices[e * 2 + 1];
	
	      values.getAt(v, tempEdgeCentroid);
	      values.getAt(vNext, tempValue);
	      tempEdgeCentroid.add(tempValue);
	      var numNeighbors = 2;
	
	      var edgeFaceCount = faceEdgeAdjacency.edgeFaceCounts[e];
	
	      if (!edgeCreases[e] && edgeFaceCount === 2) {
	
	        //if the edge contains 2 corners do not average with face
	        if (!(vertexCorners[v] && vertexCorners[vNext])) {
	
	          for (var ef = 0; ef < edgeFaceCount; ef++) {
	            var f = faceEdgeAdjacency.edgeFaceIndices[e * 2 + ef];
	            newValues.getAt(faceOffset + f, tempValue);
	            tempEdgeCentroid.add(tempValue);
	            numNeighbors++;
	          }
	        }
	      }
	      tempEdgeCentroid.multiplyScalar(1.0 / numNeighbors);
	
	      newValues.setAt(edgeOffset + e, tempEdgeCentroid);
	    }
	
	    var useBoundaryValues = true;
	
	    // create new values
	    for (var v = 0; v < numValues; v++) {
	
	      values.getAt(v, tempNextValue);
	
	      var boundaryValue = valueEdgeValence[v] !== valueFaceValence[v];
	
	      if (valueEdgeValence[v] === 0 || vertexCorners[v]) {
	        // do nothing, keep original value unmodified.
	      } else if (useBoundaryValues && boundaryValue || valueCreases[v]) {
	
	          // sum of connected boundary vertices.
	          var valueBegin = valueAdjacency.valueEdgeOffsets[v];
	          var valueUntil = valueAdjacency.valueEdgeOffsets[v + 1];
	          var numValueEdges = valueUntil - valueBegin;
	
	          tempConnectedValue.multiplyScalar(0.0);
	          var numConnectedValues = 0;
	
	          for (var ve = 0; ve < numValueEdges; ve++) {
	
	            var e = valueAdjacency.valueEdgeIndices[valueBegin + ve];
	            if (edgeCreases[e]) {
	              var vOther = edgeVertexAdjacency.edgeVertices[e * 2];
	              if (vOther === v) {
	                vOther = edgeVertexAdjacency.edgeVertices[e * 2 + 1];
	              }
	              values.getAt(vOther, tempValue);
	              tempConnectedValue.add(tempValue);
	              numConnectedValues++;
	            }
	          }
	          tempNextValue.multiplyScalar(0.75).add(tempConnectedValue.multiplyScalar(0.25 / numConnectedValues));
	        } else {
	
	          // sum of connected vertices.
	          var valueBegin = valueAdjacency.valueEdgeOffsets[v];
	          var valueUntil = valueAdjacency.valueEdgeOffsets[v + 1];
	          var numValueEdges = valueUntil - valueBegin;
	
	          tempConnectedValue.multiplyScalar(0.0);
	          var numConnectedValues = 0;
	
	          for (var ve = 0; ve < numValueEdges; ve++) {
	
	            var e = valueAdjacency.valueEdgeIndices[valueBegin + ve];
	            var vOther = edgeVertexAdjacency.edgeVertices[e * 2];
	            if (vOther == v) {
	              vOther = edgeVertexAdjacency.edgeVertices[e * 2 + 1];
	            }
	            values.getAt(vOther, tempValue);
	            tempConnectedValue.add(tempValue);
	            numConnectedValues++;
	          }
	
	          tempConnectedValue.multiplyScalar(1 / (numConnectedValues * numConnectedValues));
	
	          var valueBeginF = valueAdjacency.valueFaceOffsets[v];
	          var valueUntilF = valueAdjacency.valueFaceOffsets[v + 1];
	          var numValueFacesF = valueUntilF - valueBeginF;
	
	          tempConnectedFace.multiplyScalar(0.0);
	          var numConnectedFaces = 0;
	
	          for (var vf = 0; vf < numValueFacesF; vf++) {
	
	            var f = valueAdjacency.valueFaceIndices[valueBeginF + vf];
	            newValues.getAt(faceOffset + f, tempValue);
	            tempConnectedFace.add(tempValue);
	            numConnectedFaces++;
	          }
	
	          tempConnectedFace.multiplyScalar(1 / (numConnectedFaces * numConnectedFaces));
	
	          tempNextValue.multiplyScalar((numConnectedFaces - 2) / numConnectedFaces);
	          tempNextValue.add(tempConnectedValue);
	          tempNextValue.add(tempConnectedFace);
	        }
	      newValues.setAt(v, tempNextValue);
	    }
	
	    var pm = {
	      faceRangeOffsets: newFaceRangeOffsets,
	      faceValueIndices: newFaceValueIndices,
	      values: newValues
	    };
	
	    return new _PolyMap2.default(pm);
	  };
	
	  (0, _polyMeshValidation2.default)(mesh);
	  var polyMesh = (0, _removeDuplicateNormals2.default)(mesh);
	
	  var faceEdgeCreases = polyMesh.normalMap ? getFaceEdgeCreases(polyMesh.normalMap) : new Uint8Array(polyMesh.positions.faceValueIndices.length);
	  var faceValueCorners = getValueCorners(polyMesh.positions, faceEdgeCreases);
	
	  var results = new _PolyMesh2.default();
	  results.positions = subdividePolyMap(polyMesh.positions, null, faceEdgeCreases, faceValueCorners);
	  results.faceRangeOffsets = results.positions.faceRangeOffsets;
	
	  if (polyMesh.normalMap) {
	    results.normalMap = subdividePolyMap(polyMesh.normalMap, results.faceRangeOffsets, faceEdgeCreases, faceValueCorners);
	  }
	
	  if (polyMesh.uvMaps) {
	    var uvMaps = new _ObjectsByName2.default();
	    for (var i = 0; i < polyMesh.uvMaps.length; i++) {
	      var name = polyMesh.uvMaps.namesByIndex[i];
	      var uvEdgeCreases = getFaceEdgeCreases(polyMesh.uvMaps.byName[name]);
	      uvMaps.set(name, subdividePolyMap(polyMesh.uvMaps.byName[name], results.faceRangeOffsets, uvEdgeCreases, faceValueCorners));
	    }
	    results.uvMaps = uvMaps;
	  }
	
	  return results;
	};
	
	var getFaceEdgeCreases = function getFaceEdgeCreases(polyMap) {
	
	  var faceEdgeCreases = new Uint8Array(polyMap.faceValueIndices.length);
	  var faceEdgeAdjacency = polyMap.faceEdgeAdjacency;
	
	  for (var fe = 0; fe < faceEdgeAdjacency.faceEdgeIndices.length; fe++) {
	    var edgeIndex = faceEdgeAdjacency.faceEdgeIndices[fe];
	    faceEdgeCreases[fe] = faceEdgeAdjacency.edgeFaceCounts[edgeIndex] !== 2 ? 1 : 0;
	  }
	  return faceEdgeCreases;
	};
	
	var getValueCorners = function getValueCorners(polyMap, faceEdgeCreases) {
	
	  //converted to track indices that are corners instead of values
	  var faceValueCorners = new Uint8Array(polyMap.faceValueIndices.length);
	
	  var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;
	
	  var valueCreaseEdgeCount = new Uint8Array(polyMap.values.length);
	  var edgeProcessed = new Uint8Array(edgeVertexAdjacency.getNumEdges());
	
	  for (var f = 0; f < polyMap.faceRangeOffsets.length - 1; f++) {
	
	    var faceBegin = polyMap.faceRangeOffsets[f];
	    var faceUntil = polyMap.faceRangeOffsets[f + 1];
	    var numFaceValues = faceUntil - faceBegin;
	
	    var vNext = polyMap.faceValueIndices[faceBegin];
	
	    for (var fv = 0; fv < numFaceValues; fv++) {
	
	      var v = vNext;
	      vNext = polyMap.faceValueIndices[faceBegin + (fv + 1) % numFaceValues];
	
	      var e = edgeVertexAdjacency.findEdgeId(v, vNext);
	      if (edgeProcessed[e] === 0) {
	        edgeProcessed[e] = 1;
	
	        if (faceEdgeCreases[faceBegin + fv]) {
	          valueCreaseEdgeCount[v]++;
	          valueCreaseEdgeCount[vNext]++;
	        }
	      }
	    }
	  }
	
	  for (var i = 0; i < faceValueCorners.length; i++) {
	    var valueIndex = polyMap.faceValueIndices[i];
	    if (valueCreaseEdgeCount[valueIndex] > 2) {
	      faceValueCorners[i] = 1;
	    }
	  }
	
	  return faceValueCorners;
	};

/***/ },
/* 198 */
/*!***************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/polyMeshValidation.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = polyMeshValidation;
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var isVec3NaN = function isVec3NaN(v) {
	  return isNaN(v.x) || isNaN(v.y) || isNaN(v.z);
	};
	var isVec3Zero = function isVec3Zero(v) {
	  return v.length() === 0;
	};
	
	var isVec2NaN = function isVec2NaN(v) {
	  return isNaN(v.x) || isNaN(v.y);
	};
	
	var validateValues = function validateValues(polyMapName, values, validationFunc) {
	  //console.log( polyMapName, values.length );
	  var temp = new values.type();
	  var replacement = new values.type();
	  for (var i = 0; i < values.length; i++) {
	    values.getAt(i, temp);
	    if (!validationFunc(temp)) {
	      //console.log( "  badValue at " + i + " is ", temp );
	      values.setAt(i, replacement);
	    }
	  }
	};
	function polyMeshValidation(mesh) {
	
	  validateValues("positions", mesh.positions.values, function (v) {
	    return !isVec3NaN(v);
	  });
	  if (mesh.normalMap) {
	    validateValues("normalMap", mesh.normalMap.values, function (v) {
	      return !isVec3NaN(v) && !isVec3Zero(v);
	    });
	  }
	  if (mesh.uvMaps) {
	    var uvMaps = new _ObjectsByName2.default();
	    for (var i = 0; i < mesh.uvMaps.length; i++) {
	      var name = mesh.uvMaps.namesByIndex[i];
	      validateValues("uvMap[" + name + "]", mesh.uvMaps.byName[name].values, function (v) {
	        return !isVec2NaN(v);
	      });
	    }
	  }
	
	  return mesh;
	};

/***/ },
/* 199 */
/*!*******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeDuplicateNormals.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeDuplicateNormals;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ObjectBuffer = __webpack_require__(/*! ../../generic/container/ObjectBuffer */ 173);
	
	var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function removeDuplicateNormals(polyMesh, removeUnusedValues, withLogging) {
	
	  if (!polyMesh.normalMap) return polyMesh;
	
	  var ru = removeUnusedValues || true;
	  var l = withLogging || false;
	
	  var faceValueIndices = polyMesh.positions.faceValueIndices;
	  var values = polyMesh.positions.values;
	
	  var normalFaceValueIndices = new Uint32Array(polyMesh.normalMap.faceValueIndices);
	  var normalValues = polyMesh.normalMap.values;
	
	  var duplicatesFound = 0;
	
	  var n1 = undefined,
	      n2 = undefined;
	
	  //TODO bad nested array
	  var valuesToIndices = [];
	  for (var i = 0; i < values.length; i++) {
	    valuesToIndices[i] = [];
	  }
	
	  for (var i = 0; i < faceValueIndices.length; i++) {
	    valuesToIndices[faceValueIndices[i]].push(i);
	  }
	
	  //compares every normal on specific vertices to each other
	  //then remaps indices of normals that are the same
	  for (var i = 0; i < valuesToIndices.length; i++) {
	
	    for (var j = 0; j < valuesToIndices[i].length; j++) {
	
	      n1 = normalFaceValueIndices[valuesToIndices[i][j]];
	      for (var k = 0; k < valuesToIndices[i].length; k++) {
	
	        n2 = normalFaceValueIndices[valuesToIndices[i][j + k]];
	        if (n1 !== n2 && normalValues.getAt(n1).dot(normalValues.getAt(n2)) > 0.99) {
	          normalFaceValueIndices[valuesToIndices[i][j + k]] = n1;
	          duplicatesFound++;
	        }
	      }
	    }
	  }
	  if (l) console.log('Normal Duplicates Found: ' + duplicatesFound);
	
	  var normals = normalValues;
	  if (ru && duplicatesFound) {
	    var newNormalValuesBuffer = new _ObjectBuffer2.default(_three2.default.Vector3);
	    var isUsed = new Int32Array(normalValues.length);
	    isUsed.fill(-1);
	
	    var newNormalsCount = 0;
	    for (var i = 0; i < normalFaceValueIndices.length; i++) {
	      if (isUsed[normalFaceValueIndices[i]] === -1) {
	        newNormalValuesBuffer.push(normalValues.getAt(normalFaceValueIndices[i]));
	        isUsed[normalFaceValueIndices[i]] = newNormalsCount++;
	      }
	      normalFaceValueIndices[i] = isUsed[normalFaceValueIndices[i]];
	    }
	
	    var newNormalValues = new _ObjectArrayView2.default(_three2.default.Vector3, newNormalsCount);
	    newNormalValues.fromArray(newNormalValuesBuffer.toArray());
	
	    normals = newNormalValues;
	    if (l) console.log('' + normalValues.length + ' normal values reduced to ' + newNormalValues.length + ', duplicates removed: ' + (normalValues.length - newNormalValues.length));
	  }
	
	  var newNormals = new _PolyMap2.default({
	    faceRangeOffsets: polyMesh.faceRangeOffsets,
	    faceValueIndices: normalFaceValueIndices,
	    values: normals
	  });
	
	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.normalMap = newNormals;
	  return resultMesh;
	};

/***/ },
/* 200 */
/*!*********************************!*\
  !*** ./src/operators/Camera.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var filmSizes = {
	  "-1": "[ Custom ]",
	  "35": "35mm",
	  "70": "IMAX"
	};
	
	// TODO: add more of these!
	var viewType = {
	  values: [0, 1],
	  labels: ["Field of View", "Focal Length"]
	};
	
	var Camera = {
	  schema: {
	    targeted: { label: 'Enable Look Target', type: 'Boolean', defaultValue: false },
	    focalDepthEnabled: { label: 'Use Focal Depth', type: 'Boolean', defaultValue: false },
	    focalDepth: { label: 'Focal Depth', type: 'Number', defaultValue: 100, minValue: 0.001, animatable: true, hidden: true },
	
	    axisDirection: { type: 'Object', hidden: true },
	    zoomAxis: { type: 'Object', hidden: true },
	    //size: { type: 'Object', hidden: true},  // Call getSize() to access this field, and call viewport.getViewRect(() for view resolution
	
	    projection: { label: 'Projection', type: 'Options', defaultValue: 'Perspective', values: ['Perspective', 'Orthographic'] },
	
	    viewCtrl: { type: 'Options', defaultValue: 0, values: viewType.values, labels: viewType.labels, label: "View Control" },
	    fieldOfView: { label: 'Field of View', type: 'Number', defaultValue: 45, minValue: 5, maxValue: 179, animatable: true },
	    focalLength: { label: 'Focal Length (mm)', type: 'Number', defaultValue: 40, minValue: 1, maxValue: 400, step: 1, animatable: true },
	    filmSizeBox: { type: 'Options', defaultValue: '35', values: (0, _keys2.default)(filmSizes), labels: filmSizes, label: "Film Size" },
	    customFilmSize: { label: 'Custom Film Size (mm)', type: 'Number', defaultValue: 35, step: 0.1, minValue: 1, maxValue: 1000 },
	    fStop: { label: 'F-Stop', type: 'Number', defaultValue: 2.8, minValue: 0.7, maxValue: 32, step: 0.1 },
	    filmOffset: { label: 'Film Offset (mm)', type: 'Vec2', defaultValue: { x: 0, y: 0 }, minValue: -1000.0, step: 1.0, maxValue: 1000.0 },
	
	    aspectRatio: { label: 'Aspect Ratio', type: 'Number', defaultValue: 16.0 / 9.0, step: 0.01, minValue: 0.01, maxValue: 10 },
	    nearClip: { label: 'Near Clip', type: 'Number', step: 0.01, defaultValue: 0.1, minValue: 0.01 },
	    farClip: { label: 'Far Clip', type: 'Number', defaultValue: 50000, step: 1, minValue: 0.00001, maxValue: 1000000 },
	    orthoZoom: { label: 'Ortho Zoom', type: 'Number', defaultValue: 1, minValue: 0.01, step: 0.1 },
	
	    // Orbit around
	    targetDistance: { label: 'Distance to Target', type: 'Number', defaultValue: 5.0, minValue: 0.01 }, // Distance to target, in world space
	    target: { label: 'Virtual Target', type: 'Vec3', defaultValue: { x: 0, y: 0, z: 0 }, hidden: true }, // Virtual target, in world space
	
	    // Display
	    showFrustum: { label: 'Show Frustum', type: 'Boolean', defaultValue: false },
	    frustumColor: { label: 'Frustum Color', type: 'Color', defaultValue: { r: 255, g: 200, b: 0 }, animatable: true },
	    showClipping: { label: 'Show Clipping', type: 'Boolean', defaultValue: false },
	    showTarget: { label: 'Show Virtual Target', type: 'Boolean', defaultValue: false }
	  },
	
	  update: function update(operator, primitive, _ref) {
	    var previousResult = _ref.previousResult;
	
	    //console.log('Camera update?', operator.aspectRatio, operator.fieldOfView, primitive, previousResult);
	    (0, _assign2.default)(primitive, operator);
	
	    // Values initialized / editor from the translator that we carry through
	    var keepKeys = ['pivotMatrix', 'upPosition', 'radiusConstraint', 'newRadiusConstraint', 'offset'];
	    if (previousResult) {
	      for (var i = 0; i < keepKeys.length; i++) {
	        if (previousResult[keepKeys[i]]) primitive[keepKeys[i]] = previousResult[keepKeys[i]];
	      }
	    }
	
	    var box = operator.filmSizeBox;
	    primitive.filmSize = box === -1 ? operator.customFilmSize : parseFloat(box);
	  }
	};
	
	exports.default = { Camera: Camera };

/***/ },
/* 201 */
/*!**************************************!*\
  !*** ./src/operators/Environment.js ***!
  \**************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var backgroundStyle = {
	  values: [0, 1, 2, 3, 4],
	  labels: ["Default", "Color", "Image", "CubeMap", "EnvironmentMap"]
	};
	
	var Environment = {
	  schema: {
	    ambientLight: { label: 'Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0 } },
	    environmentMap: { label: "Environment Map", type: 'Plug', plug: 'Material' },
	
	    backgroundStyle: { label: 'Style', type: 'Options', defaultValue: 0, values: backgroundStyle.values, labels: backgroundStyle.labels },
	    backgroundColor: { label: 'Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0 } },
	    backgroundOpacity: { label: 'Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1 },
	
	    background: { label: 'Image', type: 'Plug', plug: 'Image' },
	
	    cubeMapBlurring: { label: 'CubeMap Blur', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 10, step: 0.5, animatable: true },
	    cubeMap: { label: 'CubeMap', type: 'Plug', plug: 'Material' }
	  }
	};
	
	exports.default = { Environment: Environment };

/***/ },
/* 202 */
/*!********************************!*\
  !*** ./src/operators/Image.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _asset = __webpack_require__(/*! ../translators/asset */ 203);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;
	
	var Linear = 3000;
	var sRGB = 3001;
	var RGBE = 3002;
	var LogLUV = 3003;
	var RGBM7 = 3004;
	var RGBM16 = 3005;
	
	var renderType = {
	  Original: 0, WebGL: 1, Renderer: 3
	};
	
	var renderTypes = {
	  values: [0, 1, 2],
	  labels: ["Original", "WebGL", "Renderer"]
	};
	
	var wrapType = {
	  values: [0, 1, 2],
	  labels: ["None", "Wrap", "Mirror"]
	};
	
	var sampleFilter = {
	  values: [NearestFilter, NearestMipMapNearestFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipMapNearestFilter, LinearMipMapLinearFilter],
	  labels: ["Nearest", "Nearest MipMap Nearest", "Nearest MipMap Linear", "Linear", "Linear MipMap Nearest", "Linear MipMap Linear"]
	};
	
	var encodingType = {
	  values: [Linear, sRGB, RGBE, LogLUV, RGBM7, RGBM16],
	  labels: ["Linear", "sRGB", "RGBE/Radiance", "Log LUV", "RGBM 7", "RGBM 16"]
	};
	
	var Image = {
	  schema: {
	    originalBitmapFile: { type: 'Image', hidden: true },
	    glBitmapFile: { type: 'Image', hidden: true },
	    rendererBitmapFile: { type: 'Image', hidden: true },
	    hdrBitmapFile: { type: 'Image', hidden: true },
	
	    renderOption: { label: 'Server Image', type: 'Options', defaultValue: 0, values: renderTypes.values, labels: renderTypes.labels },
	    glOption: { label: 'WebGL Image', type: 'Options', defaultValue: 1, values: renderTypes.values, labels: renderTypes.labels },
	
	    uOffset: { type: 'Number', label: 'U Offset', defaultValue: 0, step: 0.1, animatable: true },
	    vOffset: { type: 'Number', label: 'V Offset', defaultValue: 0, step: 0.1, animatable: true },
	    uTile: { type: 'Number', label: 'U Tile', defaultValue: 1, step: 0.1, animatable: true },
	    vTile: { type: 'Number', label: 'V Tile', defaultValue: 1, step: 0.1, animatable: true },
	    rotation: { type: 'Number', label: 'Rotation', defaultValue: 0, step: 0.1, animatable: true },
	    wrapU: { type: 'Options', defaultValue: 1, values: wrapType.values, labels: wrapType.labels, label: "U Wrap Style" },
	    wrapV: { type: 'Options', defaultValue: 1, values: wrapType.values, labels: wrapType.labels, label: "V Wrap Style" },
	
	    invert: { type: 'Boolean', label: 'Invert', defaultValue: false, animatable: true },
	    gainPivot: { type: 'Number', label: 'Gain Pivot', defaultValue: 0, step: 0.1, animatable: true },
	    gain: { type: 'Number', label: 'Gain', defaultValue: 1.0, step: 0.1, animatable: true },
	    brightness: { type: 'Number', label: 'Brightness', defaultValue: 0, step: 0.1, animatable: true },
	
	    magFilter: { type: 'Options', defaultValue: LinearFilter, values: sampleFilter.values, labels: sampleFilter.labels, label: "Magnify Filter" },
	    minFilter: { type: 'Options', defaultValue: LinearMipMapLinearFilter, values: sampleFilter.values, labels: sampleFilter.labels, label: "Minify Filter" },
	    generateMipMaps: { label: "Use MipMaps", type: "Boolean", defaultValue: true },
	
	    hdrEncoding: { type: 'Options', defaultValue: RGBM16, values: encodingType.values, labels: encodingType.labels, label: "HDR Encoding" }
	  },
	
	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;
	
	    var asset = null;
	
	    //const renderOption = __SERVER__ ? operator.renderOption : operator.glOption;
	    var renderOption = operator.glOption;
	
	    if (renderOption == renderType.Original) {
	      asset = operator.originalBitmapFile;
	    } else if (renderOption === renderType.WebGL) {
	      asset = operator.glBitmapFile || operator.originalBitmapFile;
	    } else {
	      asset = operator.rendererBitmapFile || operator.originalBitmapFile;
	    }
	
	    primitive.asset = asset;
	    primitive.hdr = operator.hdrBitmapFile;
	
	    (0, _ramda.forEach)(function (key) {
	      primitive[key] = operator[key];
	    }, ['uOffset', 'vOffset', 'uTile', 'vTile', 'rotation', 'wrapU', 'wrapV', 'gain', 'gainPivot', 'brightness', 'magFilter', 'minFilter', 'generateMipMaps', 'hdrEncoding', 'invert']);
	
	    primitive.preferHDR = operator.hdrEncoding !== Linear && !!operator.hdrBitmapFile;
	
	    return primitive;
	  }
	};
	
	var Canvas = {
	  schema: {
	    width: { type: "Number", defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: "Width" },
	    height: { type: "Number", defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: "Height" },
	
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0, a: 0 }, animatable: true },
	    opacity: { label: 'Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1, animatable: true },
	
	    uOffset: { type: 'Number', label: 'U Offset', defaultValue: 0, step: 0.1, animatable: true },
	    vOffset: { type: 'Number', label: 'V Offset', defaultValue: 0, step: 0.1, animatable: true },
	    uTile: { type: 'Number', label: 'U Tile', defaultValue: 1, step: 0.1, animatable: true },
	    vTile: { type: 'Number', label: 'V Tile', defaultValue: 1, step: 0.1, animatable: true },
	    rotation: { type: 'Number', label: 'Rotation', defaultValue: 0, step: 0.1, animatable: true },
	    wrapU: { type: 'Options', defaultValue: 1, values: wrapType.values, labels: wrapType.labels, label: "U Wrap Style" },
	    wrapV: { type: 'Options', defaultValue: 1, values: wrapType.values, labels: wrapType.labels, label: "V Wrap Style" },
	
	    invert: { type: 'Boolean', label: 'Invert', defaultValue: false, animatable: true },
	    gainPivot: { type: 'Number', label: 'Gain Pivot', defaultValue: 0, step: 0.1, animatable: true },
	    gain: { type: 'Number', label: 'Gain', defaultValue: 1.0, step: 0.1, animatable: true },
	    brightness: { type: 'Number', label: 'Brightness', defaultValue: 0, step: 0.1, animatable: true },
	
	    magFilter: { type: 'Options', defaultValue: _three2.default.LinearFilter, values: sampleFilter.values, labels: sampleFilter.labels, label: "Magnify Filter" },
	    minFilter: { type: 'Options', defaultValue: _three2.default.LinearMipMapLinearFilter, values: sampleFilter.values, labels: sampleFilter.labels, label: "Minify Filter" },
	    generateMipMaps: { label: "Use MipMaps", type: "Boolean", defaultValue: true },
	
	    hdrEncoding: { type: 'Options', defaultValue: _three2.default.RGBM16, values: encodingType.values, labels: encodingType.labels, label: "HDR Encoding" }
	  },
	
	  update: function update(operator, primitive, _ref2) {
	    var node = _ref2.node;
	
	    var ctxWidth = operator.width;
	    var ctxHeight = operator.height;
	
	    var color = operator.color;
	    if (color) color = 'rgba(' + parseInt(color.r * 255) + ',' + parseInt(color.g * 255) + ',' + parseInt(color.b * 255) + ',' + operator.opacity + ')';
	
	    (0, _ramda.forEach)(function (key) {
	      primitive[key] = operator[key];
	    }, ['uOffset', 'vOffset', 'uTile', 'vTile', 'rotation', 'wrapU', 'wrapV', 'gain', 'gainPivot', 'brightness', 'magFilter', 'minFilter', 'generateMipMaps', 'hdrEncoding', 'invert', 'width', 'height']);
	
	    var op = function op(context) {
	      context.fillStyle = color;
	      context.fillRect(0, 0, ctxWidth, ctxHeight);
	      return true;
	    };
	
	    if (!primitive.canvasOperations) {
	      primitive.canvasOperations = new _immutable.List([op]);
	    } else {
	      primitive.canvasOperations.push(op);
	    }
	
	    return primitive;
	  }
	
	};
	
	var CanvasLinearGradient = {
	  schema: {
	    startIs: { label: "Start Is", type: "Options", values: ['top', 'left', 'top-left', 'bottom-left'], initialValue: 'top' },
	    startColor: { label: 'Start Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0, a: 0 }, animatable: true },
	    startOpacity: { label: 'Start Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1, animatable: true },
	    endColor: { label: 'End Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0, a: 0 }, animatable: true },
	    endOpacity: { label: 'End Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1, animatable: true },
	
	    xOffset: { type: "Number", defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: "X", animatable: true },
	    yOffset: { type: "Number", defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: "Y", animatable: true },
	    width: { type: "Number", defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: "Width" },
	    height: { type: "Number", defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: "Height" },
	
	    composition: { label: "Mode", type: "Options", values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'], initialValue: 'source-over' }
	
	  },
	
	  update: function update(operator, primitive) {
	    var xOffset = operator.xOffset;
	    var yOffset = operator.yOffset;
	    var width = operator.width;
	    var height = operator.height;
	
	    var startColor = startColor;
	    var endColor = endColor;
	    if (startColor) startColor = 'rgba(' + parseInt(startColor.r * 255) + ',' + parseInt(startColor.g * 255) + ',' + parseInt(startColor.b * 255) + ',' + operator.startOpacity + ')';
	    if (endColor) endColor = 'rgba(' + parseInt(endColor.r * 255) + ',' + parseInt(endColor.g * 255) + ',' + parseInt(endColor.b * 255) + ',' + operator.endOpacity + ')';
	
	    var op = function op(canvasContext) {
	      var grd = undefined;
	      switch (operator.startIs) {
	        case 'top':
	          grd = canvasContext.createLinearGradient(xOffset, yOffset, xOffset, yOffset + height);break;
	        case 'left':
	          grd = canvasContext.createLinearGradient(xOffset, yOffset, xOffset + width, yOffset);break;
	        case 'top-left':
	          grd = canvasContext.createLinearGradient(xOffset, yOffset, xOffset + width, yOffset + height);break;
	        default:
	          grd = canvasContext.createLinearGradient(xOffset, yOffset + height, xOffset + width, yOffset);break;
	      }
	      grd.addColorStop(0, startColor);
	      grd.addColorStop(1, endColor);
	      canvasContext.fillStyle = grd;
	
	      canvasContext.globalCompositeOperation = operator.composition;
	
	      canvasContext.fillRect(xOffset, yOffset, width, height);
	      return true;
	    };
	
	    if (!primitive.canvasOperations) {
	      primitive.canvasOperations = new _immutable.List([op]);
	    } else {
	      primitive.canvasOperations.push(op);
	    }
	
	    return primitive;
	  }
	
	};
	
	var CanvasFill = {
	  schema: {
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 0, g: 0, b: 0, a: 0 }, animatable: true },
	    opacity: { label: 'Opacity', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 1, step: 0.1, animatable: true },
	
	    xOffset: { type: "Number", defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: "X", animatable: true },
	    yOffset: { type: "Number", defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: "Y", animatable: true },
	    width: { type: "Number", defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: "Width" },
	    height: { type: "Number", defaultValue: 512, minValue: 16, maxValue: 4096, step: 1, label: "Height" },
	
	    composition: { label: "Mode", type: "Options", values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'], initialValue: 'source-over' }
	
	  },
	
	  update: function update(operator, primitive) {
	    var xOffset = operator.xOffset;
	    var yOffset = operator.yOffset;
	    var width = operator.width;
	    var height = operator.height;
	
	    var color = operator.color;
	    if (color) color = 'rgba(' + parseInt(color.r * 255) + ',' + parseInt(color.g * 255) + ',' + parseInt(color.b * 255) + ',' + operator.opacity + ')';
	
	    var op = function op(canvasContext) {
	      canvasContext.fillStyle = color;
	      canvasContext.globalCompositeOperation = operator.composition;
	      canvasContext.fillRect(xOffset, yOffset, width, height);
	      return true;
	    };
	
	    if (!primitive.canvasOperations) {
	      primitive.canvasOperations = new _immutable.List([op]);
	    } else {
	      primitive.canvasOperations.push(op);
	    }
	
	    return primitive;
	  }
	};
	
	var CanvasComposite = {
	  schema: {
	    sourceImage: { type: "Plug", plug: "Image" },
	    xOffset: { type: "Number", defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: "X", animatable: true },
	    yOffset: { type: "Number", defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: "Y", animatable: true },
	
	    overrideSize: { type: "Boolean", label: 'Override Default Size', defaultValue: false, animatable: true },
	    overrideWidth: { type: "Number", defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: "Override Width", animatable: true },
	    overrideHeight: { type: "Number", defaultValue: 0, minValue: -10000, maxValue: +10000, step: 1, label: "Override Height", animatable: true },
	
	    composition: { label: "Composition", type: "Options", values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'], initialValue: 'source-over' }
	
	  },
	
	  update: function update(operator, primitive, _ref3) {
	    var node = _ref3.node;
	
	    var sourceImage = operator.sourceImage;
	
	    var xOffset = operator.xOffset;
	    var yOffset = operator.yOffset;
	    var overrideSize = operator.overrideSize;
	    var overrideWidth = operator.overrideWidth;
	    var overrideHeight = operator.overrideHeight;
	    var composition = operator.composition;
	
	    var op = function op(context, store) {
	      if (!sourceImage) return false;
	
	      var textureImage = (0, _asset.fetchTextureImage)(store, sourceImage);
	      if (!textureImage) {
	        return false;
	      }
	
	      if (!overrideSize) {
	        overrideWidth = textureImage.width;
	        overrideHeight = textureImage.height;
	      }
	      if (overrideWidth == 0) {
	        overrideWidth = 1;
	      }
	      if (overrideHeight == 0) {
	        overrideHeight = 1;
	      }
	
	      var imgCanvas = document.createElement('canvas');
	      imgCanvas.width = overrideWidth;
	      imgCanvas.height = overrideHeight;
	      var imgCanvasContext = imgCanvas.getContext('2d');
	
	      imgCanvasContext.drawImage(textureImage, 0, 0, overrideWidth, overrideHeight);
	
	      context.globalCompositeOperation = composition;
	
	      context.drawImage(imgCanvas, xOffset, yOffset, overrideWidth, overrideHeight);
	
	      return true;
	    };
	
	    if (!primitive.canvasOperations) {
	      primitive.canvasOperations = new _immutable.List([op]);
	    } else {
	      primitive.canvasOperations.push(op);
	    }
	
	    return primitive;
	  }
	};
	
	exports.default = { Image: Image, Canvas: Canvas, CanvasLinearGradient: CanvasLinearGradient, CanvasFill: CanvasFill, CanvasComposite: CanvasComposite };

/***/ },
/* 203 */
/*!**********************************!*\
  !*** ./src/translators/asset.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getAssetIdFromImage = getAssetIdFromImage;
	exports.getImageFromNode = getImageFromNode;
	exports.fetchTextureImage = fetchTextureImage;
	
	var _assets = __webpack_require__(/*! ../modules/assets */ 144);
	
	function getAssetIdFromImage(store, image) {
	  var asset = image.asset;
	  var hdr = image.hdr;
	
	  return image.preferHDR && hdr ? hdr : asset;
	};
	
	function getImageFromNode(store, image) {
	  var id = getAssetIdFromImage(store, image);
	  return id && (0, _assets.getOrFetchImage)(id)(store);
	}
	
	function fetchTextureImage(store, image) {
	  var ref = image.asset;
	  return ref && (0, _assets.getOrFetchImage)(ref)(store);
	}

/***/ },
/* 204 */
/*!********************************!*\
  !*** ./src/operators/Light.js ***!
  \********************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var DirectionalLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'DirectionalLight' },
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 240, g: 240, b: 240, a: 1 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.8 }
	  }
	};
	
	var SpotLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'SpotLight' },
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 240, g: 240, b: 240, a: 1 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.8 }
	  }
	};
	
	var PointLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'PointLight' },
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 240, g: 240, b: 240, a: 1 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.8 }
	  }
	};
	
	var HemisphereLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'HemisphereLight' },
	    color: { label: 'Sky Color', type: 'Color', defaultValue: { r: 0x33, g: 0x85, b: 0xff, a: 1 } },
	    gndColor: { label: 'Sky Color', type: 'Color', defaultValue: { r: 0xff, g: 0xc8, b: 0x7f, a: 1 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.6 }
	  }
	};
	
	var AreaLight = {
	  schema: {
	    lightType: { label: 'type', type: 'String', defaultValue: 'AreaLight' },
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 240, g: 240, b: 240, a: 1 } },
	    intensity: { label: 'Intensity', type: 'Number', defaultValue: 10 }
	  }
	};
	
	exports.default = { DirectionalLight: DirectionalLight, SpotLight: SpotLight, PointLight: PointLight, HemisphereLight: HemisphereLight, AreaLight: AreaLight };

/***/ },
/* 205 */
/*!***********************************!*\
  !*** ./src/operators/Material.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var Material = {
	  schema: {
	    color: { label: 'Color', type: 'Color', defaultValue: { r: 240, g: 240, b: 240, a: 1 } }
	  },
	  update: function update(operator, primitive) {
	    return primitive.color = operator.color;
	  }
	};
	
	var Physical = {
	  environment: true,
	
	  schema: {
	    baseMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    baseMapTransparent: { label: 'Image Transparent', type: 'Boolean', defaultValue: false },
	    baseColor: { label: 'Color', type: 'Color', defaultValue: { r: 240, g: 240, b: 240, a: 1 } },
	
	    baseFalloff: { label: 'Falloff', type: 'Boolean', defaultValue: false },
	    baseFalloffMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    baseFalloffColor: { label: "Falloff Color", type: 'Color', defaultValue: { r: 240, g: 240, b: 240, a: 1 }, animatable: true },
	
	    opacityMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    opacityFactor: { label: "Factor", type: "Number", defaultValue: 1.0, maxValue: 1.0, minValue: 0.0, step: 0.01, animatable: true },
	
	    opacityFalloffMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    opacityFalloffFactor: { label: 'Falloff Factor', type: 'Number', defaultValue: 1.0, maxValue: 1.0, minValue: 0.0, step: 0.01, animatable: true },
	
	    depthWrite: { label: "Depth Write", type: "Boolean", defaultValue: true },
	    depthTest: { label: "Depth Test", type: "Boolean", defaultValue: true },
	
	    specularMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    specularColor: { label: "Color", type: 'Color', defaultValue: { r: 255, g: 255, b: 255 }, animatable: true },
	
	    roughness: { label: "Roughness", type: "Number", defaultValue: 0.25, minValue: 0.0, maxValue: 1.0, step: 0.01, animatable: true },
	    roughnessMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	
	    metallic: { label: "Metallic", type: "Number", defaultValue: 0.0, minValue: 0.0, maxValue: 1.0, step: 0.01, animatable: true },
	    metallicMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	
	    clearCoat: { label: "Thickness", type: "Number", defaultValue: 0.0, minValue: 0.0, maxValue: 1.0, step: 0.01, animatable: true },
	    clearCoatRoughness: { label: "Roughness", type: "Number", defaultValue: 0.25, minValue: 0.0, maxValue: 1.0, step: 0.01, animatable: true },
	
	    lightMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    ambientColor2: { label: "Color", type: 'Color', animatable: true, defaultValue: { r: 0, g: 0, b: 0 } },
	
	    emissiveMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    emissiveColor: { label: "Color", type: 'Color', animatable: true, defaultValue: { r: 0, g: 0, b: 0 } },
	    emissiveScale: { label: "Scale", type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 100.0, step: 0.1, animatable: true },
	    emissiveLabel: { type: "Label", align: "right", defaultValue: "Emissive uses the second UV channel." },
	
	    translucencyColor: { label: "Color", type: 'Color', animatable: true, defaultValue: { r: 0, g: 0, b: 0 } },
	    translucencyMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    translucencyNormalAlpha: { label: "Normal Alpha", type: "Number", defaultValue: 0.75, minValue: 0.0, maxValue: 1.0, step: 0.05, animatable: true },
	    translucencyNormalPower: { label: "Normal Power", type: "Number", defaultValue: 2.0, minValue: 0.01, maxValue: 100.0, step: 0.05, animatable: true },
	    translucencyViewAlpha: { label: "View Alpha", type: "Number", defaultValue: 0.75, minValue: 0.0, maxValue: 1.0, step: 0.05, animatable: true },
	    translucencyViewPower: { label: "View Power", type: "Number", defaultValue: 2.0, minValue: 0.01, maxValue: 100.0, step: 0.05, animatable: true },
	
	    bumpMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    bumpFactor: { label: "Scale Factor", type: "Number", defaultValue: 0.03, minValue: -5.0, maxValue: 5.0, step: 0.001, animatable: true },
	
	    normalMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    normalFactor: { label: "Scale Factor", type: "Number", defaultValue: 1.0, minValue: -100.0, maxValue: 100.0, step: 0.001, animatable: true },
	
	    anisotropyLabel: { type: "Label", align: "right", defaultValue: "Anisotropy requires the Tangent operator." },
	    anisotropyMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    anisotropy: { label: "Offset", type: "Number", defaultValue: 0.0, minValue: -1.0, maxValue: 1.0, step: 0.025, animatable: true },
	
	    anisotropyRotationMap: { label: 'Image', type: 'Plug', plug: 'Image' },
	    anisotropyRotation: { label: "Rotation Offset", type: "Number", defaultValue: 0.0, minValue: -1.0, maxValue: 1.0, step: 0.025, animatable: true },
	
	    overrideEnvironment: { label: 'Override Environment', type: 'Boolean', defaultValue: false }
	  }
	};
	
	//environmentMap: { label: "Environment Map", type: 'Node', filter: environmentMapFilter },
	var MaterialReference = {
	  schema: {
	    defaultColor: { label: 'Default Color', type: 'Color', defaultValue: { r: 1, g: 1, b: 1, a: 1 } },
	    reference: { type: 'Plug', plug: 'Material', label: "Reference" }
	  },
	  update: function update(operator, primitive) {
	    primitive.color = operator.defaultColor;
	    //return operator.reference || primitive.color = operator.defaultColor;
	  }
	};
	
	var Reference = {
	  schema: {
	    defaultColor: { label: 'Default Color', type: 'Color', defaultValue: { r: 1, g: 1, b: 1, a: 1 } },
	    reference: { type: 'Plug', plug: 'Material', label: "Reference" }
	  },
	  update: function update(operator, primitive) {
	    if (operator.reference) return operator.reference;
	    primitive.defaultColor = operator.defaultColor;
	  }
	};
	
	var EnvironmentMap = {
	  schema: {
	    thumbnailImage: { label: "Thumbnail", type: 'Plug', plug: 'Image' },
	
	    irradianceCubeMap: { label: "Irradiance", type: 'Plug', plug: 'Material' }, //filter: cubeMapFilter },
	    specularCubeMap: { label: "Specular", type: 'Plug', plug: 'Material' } }
	};
	
	//filter: cubeMapFilter },
	
	//giImage:   { label: 'Global Illumination', type: 'Node', initialValue: null, filter: exo.material.ImageUtils.nodeFilter },
	//// these two maps should usually be the global illumination map.
	//reflectionImage:   { label: 'Reflection', type: 'Node', initialValue: null, filter: exo.material.ImageUtils.nodeFilter },
	//refractionImage:   { label: 'Refraction', type: 'Node', initialValue: null, filter: exo.material.ImageUtils.nodeFilter },
	var CubeMap = {
	  schema: {
	    map0: { label: 'Map ( x)', type: 'Plug', plug: 'Image' },
	    map1: { label: 'Map (-x)', type: 'Plug', plug: 'Image' },
	    map2: { label: 'Map ( y)', type: 'Plug', plug: 'Image' },
	    map3: { label: 'Map (-y)', type: 'Plug', plug: 'Image' },
	    map4: { label: 'Map ( z)', type: 'Plug', plug: 'Image' },
	    map5: { label: 'Map (-z)', type: 'Plug', plug: 'Image' }
	  },
	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;
	
	    primitive.maps = [operator.map0, operator.map1, operator.map2, operator.map3, operator.map4, operator.map5];
	  }
	};
	
	var ProxyReference = {
	  schema: {
	    webgl: { type: 'Plug', label: 'WebGL Material', plug: 'Material' },
	    vray: { type: 'Plug', label: 'VRay Material', plug: 'Material' }
	  },
	  update: function update(operator, primitive) {
	    return operator.webgl || primitive;
	  }
	};
	
	var Standard = {
	  schema: {
	    diffuseColor: { label: 'Color', type: 'Color', defaultValue: { r: 240, g: 240, b: 240, a: 1 } }
	  }
	};
	
	var MultiID = {
	  schema: {
	    material0: { type: 'Plug', plug: 'Material', label: 'Material ID 0' },
	    material1: { type: 'Plug', plug: 'Material', label: 'Material ID 1' },
	    material2: { type: 'Plug', plug: 'Material', label: 'Material ID 2' },
	    material3: { type: 'Plug', plug: 'Material', label: 'Material ID 3' },
	    material4: { type: 'Plug', plug: 'Material', label: 'Material ID 4' },
	    material5: { type: 'Plug', plug: 'Material', label: 'Material ID 5' },
	    material6: { type: 'Plug', plug: 'Material', label: 'Material ID 6' },
	    material7: { type: 'Plug', plug: 'Material', label: 'Material ID 7' },
	    material8: { type: 'Plug', plug: 'Material', label: 'Material ID 8' },
	    material9: { type: 'Plug', plug: 'Material', label: 'Material ID 9' },
	    material10: { type: 'Plug', plug: 'Material', label: 'Material ID 10' },
	    material11: { type: 'Plug', plug: 'Material', label: 'Material ID 11' },
	    material12: { type: 'Plug', plug: 'Material', label: 'Material ID 12' },
	    material13: { type: 'Plug', plug: 'Material', label: 'Material ID 13' },
	    material14: { type: 'Plug', plug: 'Material', label: 'Material ID 14' },
	    material15: { type: 'Plug', plug: 'Material', label: 'Material ID 15' },
	    material16: { type: 'Plug', plug: 'Material', label: 'Material ID 16' },
	    material17: { type: 'Plug', plug: 'Material', label: 'Material ID 17' },
	    material18: { type: 'Plug', plug: 'Material', label: 'Material ID 18' },
	    material19: { type: 'Plug', plug: 'Material', label: 'Material ID 19' },
	    material20: { type: 'Plug', plug: 'Material', label: 'Material ID 20' },
	    material21: { type: 'Plug', plug: 'Material', label: 'Material ID 21' },
	    material22: { type: 'Plug', plug: 'Material', label: 'Material ID 22' },
	    material23: { type: 'Plug', plug: 'Material', label: 'Material ID 23' },
	    material24: { type: 'Plug', plug: 'Material', label: 'Material ID 24' },
	    material25: { type: 'Plug', plug: 'Material', label: 'Material ID 25' },
	    material26: { type: 'Plug', plug: 'Material', label: 'Material ID 26' },
	    material27: { type: 'Plug', plug: 'Material', label: 'Material ID 27' },
	    material28: { type: 'Plug', plug: 'Material', label: 'Material ID 28' },
	    material29: { type: 'Plug', plug: 'Material', label: 'Material ID 29' },
	
	    multiID: { type: 'Boolean', label: 'Is MultiID', defaultValue: true }
	  }
	};
	
	var VRmat = {
	  schema: {
	    visMatZipFile: { type: 'File', hidden: true },
	    viewColor: { type: "Color", defaultValue: { r: 240, g: 240, b: 240, a: 1 }, label: "Viewport Color" }
	  }
	};
	
	exports.default = { Material: Material, Physical: Physical, MaterialReference: MaterialReference, Reference: Reference, EnvironmentMap: EnvironmentMap,
	  CubeMap: CubeMap, Standard: Standard, ProxyReference: ProxyReference, MultiID: MultiID, 'vray/VRmat': VRmat };

/***/ },
/* 206 */
/*!*********************************!*\
  !*** ./src/operators/Player.js ***!
  \*********************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var Player = {
	  schema: {
	    autoRotate: { label: 'Auto-Rotate Camera', type: 'Boolean', defaultValue: false },
	    autoRotateNode: { label: 'Rotate Node', type: 'Node' },
	    autoRotateSpeed: { label: 'Rotate Speed (seconds)', type: 'Number', minValue: 1, maxValue: 60, defaultValue: 12 },
	    autoRotateDirection: { label: 'Rotate Direction', type: 'Options', values: ['-', '+'], labels: ['Clockwise', 'Counter-clockwise'], defaultValue: '-' },
	
	    camera: { label: 'Camera', type: 'Node' },
	    constraintCameraY: { label: 'Constrain Camera to Positive Y', type: 'Boolean', defaultValue: false },
	    orbitTarget: { label: 'Orbit Target', type: 'Node' },
	    orbitMode: { label: 'Orbit Mode', type: 'Options', values: ['gyroscope', 'trackball', 'firstPerson'], labels: ['Gyropscope', 'Trackball', 'First Person'], defaultValue: 'gyroscope' },
	
	    toneMapStyle: { label: 'Style', type: 'Options', values: ['Linear', 'Reinhard', 'Cineon', 'Filmic'], defaultValue: 'Linear' },
	    toneMapExposureGain: { label: 'Exposure Gain', type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 20.0, step: 0.1 },
	    toneMapWhitePoint: { label: 'White Point', type: 'Number', defaultValue: 4.0, minValue: 0.0, maxValue: 20.0, step: 0.1 },
	
	    saoPass: { label: 'Enabled', type: 'Boolean', defaultValue: false },
	    saoIntensity: { label: 'Intensity', type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 1000.0, step: 0.1 },
	    saoScale: { label: 'Scale', type: 'Number', defaultValue: 24.0, minValue: 0.0, maxValue: 1000.0, step: 0.1 },
	
	    reflectiveFloor: { label: 'Enabled', type: 'Boolean', defaultValue: false },
	    reflectiveFloorWidth: { label: 'Width', type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 1000.0, step: 1.0 },
	    reflectiveFloorRoughness: { label: 'Roughness', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 10.0, step: 0.1 },
	    reflectiveFloorMetallic: { label: 'Metallic', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 1.0, step: 0.1 },
	    reflectiveFloorFade: { label: 'Fade', type: 'Number', defaultValue: 0.0, minValue: 0.0, maxValue: 10.0, step: 0.1 },
	    reflectiveFloorHeight: { label: 'Height', type: 'Number', defaultValue: 0.0, minValue: -100.0, maxValue: 100.0, step: 0.1 },
	    reflectiveFloorOpacity: { label: 'Opacity', type: 'Number', defaultValue: 1.0, minValue: 0.0, maxValue: 1.0, step: 0.1 },
	    reflectiveFloorFresnel: { label: 'Fresnel Strength', type: 'Number', defaultValue: 1.0, minValue: -1.0, maxValue: 1.0, step: 0.1 },
	    reflectiveFloorExcludeServer: { label: 'Exclude on Server', type: 'Boolean', defaultValue: false },
	
	    configurator: { label: 'Configurator', type: 'Text', hidden: true, defaultValue: '' }
	
	  }
	};
	
	exports.default = { Player: Player };

/***/ },
/* 207 */
/*!*****************************************!*\
  !*** ./src/operators/PolyMesh/index.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Mesh = __webpack_require__(/*! ./Mesh */ 208);
	
	var _Mesh2 = _interopRequireDefault(_Mesh);
	
	var _TransformVertices = __webpack_require__(/*! ./TransformVertices */ 209);
	
	var _TransformVertices2 = _interopRequireDefault(_TransformVertices);
	
	var _MeshSmooth = __webpack_require__(/*! ./MeshSmooth */ 196);
	
	var _MeshSmooth2 = _interopRequireDefault(_MeshSmooth);
	
	var _UVMap = __webpack_require__(/*! ./UVMap */ 210);
	
	var _UVMap2 = _interopRequireDefault(_UVMap);
	
	var _UVTransform = __webpack_require__(/*! ./UVTransform */ 211);
	
	var _UVTransform2 = _interopRequireDefault(_UVTransform);
	
	var _Skin = __webpack_require__(/*! ./Skin */ 212);
	
	var _Skin2 = _interopRequireDefault(_Skin);
	
	var _Box = __webpack_require__(/*! ./Box */ 214);
	
	var _Box2 = _interopRequireDefault(_Box);
	
	var _Sphere = __webpack_require__(/*! ./Sphere */ 227);
	
	var _Sphere2 = _interopRequireDefault(_Sphere);
	
	var _Cone = __webpack_require__(/*! ./Cone */ 235);
	
	var _Cone2 = _interopRequireDefault(_Cone);
	
	var _Capsule = __webpack_require__(/*! ./Capsule */ 237);
	
	var _Capsule2 = _interopRequireDefault(_Capsule);
	
	var _Cylinder = __webpack_require__(/*! ./Cylinder */ 239);
	
	var _Cylinder2 = _interopRequireDefault(_Cylinder);
	
	var _Plane = __webpack_require__(/*! ./Plane */ 241);
	
	var _Plane2 = _interopRequireDefault(_Plane);
	
	var _Torus = __webpack_require__(/*! ./Torus */ 243);
	
	var _Torus2 = _interopRequireDefault(_Torus);
	
	var _Disk = __webpack_require__(/*! ./Disk */ 245);
	
	var _Disk2 = _interopRequireDefault(_Disk);
	
	var _ProxyMesh = __webpack_require__(/*! ./ProxyMesh */ 247);
	
	var _ProxyMesh2 = _interopRequireDefault(_ProxyMesh);
	
	var _Instance = __webpack_require__(/*! ./Instance */ 248);
	
	var _Instance2 = _interopRequireDefault(_Instance);
	
	var _SortFacesByAxis = __webpack_require__(/*! ./SortFacesByAxis */ 249);
	
	var _SortFacesByAxis2 = _interopRequireDefault(_SortFacesByAxis);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = { Mesh: _Mesh2.default, MeshSmooth: _MeshSmooth2.default, Skin: _Skin2.default, TransformVertices: _TransformVertices2.default, UVMap: _UVMap2.default, UVTransform: _UVTransform2.default, Box: _Box2.default, Sphere: _Sphere2.default,
	  Cone: _Cone2.default, Capsule: _Capsule2.default, Cylinder: _Cylinder2.default, Plane: _Plane2.default, Torus: _Torus2.default, Disk: _Disk2.default, ProxyMesh: _ProxyMesh2.default, Instance: _Instance2.default, SortFacesByAxis: _SortFacesByAxis2.default };

/***/ },
/* 208 */
/*!****************************************!*\
  !*** ./src/operators/PolyMesh/Mesh.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _bingeom = __webpack_require__(/*! ../../translators/bingeom */ 154);
	
	var _assets = __webpack_require__(/*! ../../modules/assets */ 144);
	
	var Mesh = {
	  schema: {
	    geometry: { type: 'File', label: 'PolyMesh Geometry File' }
	  },
	
	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;
	    var store = _ref.store;
	    var properties = _ref.properties;
	    var previousResult = _ref.previousResult;
	    var loaded = _ref.loaded;
	
	    var visible = properties.visible;
	    var geom = operator.geometry; // Request geometry so the asset gets referenced
	    var fetch = visible || properties.prefetch && loaded;
	    var ref = fetch && geom;
	    var bingeom = ref && store.hasApi() && (0, _assets.getOrFetchBinary)(ref)(store);
	    var mesh = bingeom && (0, _bingeom.convertToCNSPolyMesh)(bingeom, ref);
	    //console.log('Mesh update', 'visible:', visible, 'prefetch:', properties.prefetch, 'fetch:', fetch, 'bingeom:', !!bingeom,  node.name, mesh);
	    primitive.mesh = mesh;
	    primitive.previousMesh = previousResult && previousResult.mesh;
	    return primitive;
	  }
	};
	
	exports.default = Mesh;

/***/ },
/* 209 */
/*!*****************************************************!*\
  !*** ./src/operators/PolyMesh/TransformVertices.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 98);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _polyMesh = __webpack_require__(/*! ../../polyMesh */ 159);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function stringIndicesToArray() {
	  var str = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
	
	  var indices = str.split(',');
	  var outIndices = [];
	  var i = undefined,
	      j = undefined,
	      start = undefined,
	      end = undefined,
	      v = undefined;
	  for (i = 0; i < indices.length; i++) {
	    v = indices[i];
	    if (v.indexOf('-') !== -1) {
	      var _v$split = v.split('-');
	
	      var _v$split2 = (0, _slicedToArray3.default)(_v$split, 2);
	
	      start = _v$split2[0];
	      end = _v$split2[1];
	
	      start = Number(start);
	      end = Number(end);
	      for (j = start; j <= end; j++) {
	        outIndices.push(j);
	      }
	    } else {
	      outIndices.push(Number(v));
	    }
	  }
	  return outIndices;
	}
	
	var TransformVertices = {
	  schema: {
	    translation: { label: 'Translation', type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    rotation: { label: 'Rotation', type: 'Vec3', step: 1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true, hidden: true },
	    scale: { label: 'Scale', type: 'Vec3', minValue: 0.0001, step: 0.1, defaultValue: { x: 1, y: 1, z: 1 }, animatable: true, hidden: true },
	    updateNormals: { label: 'Update Normals', type: 'Boolean', defaultValue: true, hidden: true },
	    //centerType: { label: 'Center', type: 'Options', display: 'Dropdown',
	    //      labels: ['Selection Center', 'World Center', 'Pivot'],
	    //      values: ['SelectionCenter', 'WorldCenter', 'Pivot'],
	    //      defaultValue: 'SelectionCenter' },
	    //// matrix is used in baking transform and overrides other parameters
	    //matrix: { label: 'Translation', type: 'Object', defaultValue: null, hidden: true },
	    vertexIndices: { label: "Selection", type: 'String', defaultValue: "" }
	  },
	
	  update: function update(operator, primitive) {
	    var mesh = primitive.mesh;
	    if (!mesh) return primitive;
	
	    var seed = Math.random();
	    var density = 0.5;
	    var meaning = _polyMesh.Selection.Vertices;
	
	    var indices = stringIndicesToArray(operator.vertexIndices);
	    //console.log('create selection from: ', operator.vertexIndices, indices);
	
	    var selection = new _polyMesh.Selection(indices, _polyMesh.Selection.Vertices);
	
	    var newMesh = new _polyMesh.PolyMesh(mesh);
	    var newPolyMap = new _polyMesh.PolyMap(_polyMesh.PolyMaps.resolveMap(mesh, 'positions'));
	    var newMapValues = newPolyMap.values.clone();
	    newPolyMap.values = newMapValues;
	    _polyMesh.PolyMaps.assignMap(newMesh, 'positions', newPolyMap);
	
	    var vertexIndices = _polyMesh.Selection.getIndices(mesh, _polyMesh.Selection.Vertices, 'positions', selection);
	
	    var nonuniform = !!selection;
	
	    for (var j = 0, n = vertexIndices.length; j !== n; ++j) {
	      var i = vertexIndices[j];
	
	      newMapValues.setAt(i, newMapValues.getAt(i, new _three2.default.Vector3()).add(operator.translation));
	    }
	    primitive.mesh = newMesh;
	  }
	};
	
	exports.default = TransformVertices;

/***/ },
/* 210 */
/*!*****************************************!*\
  !*** ./src/operators/PolyMesh/UVMap.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _PolyMesh = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../polyMesh/generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ObjectsByName = __webpack_require__(/*! ../../polyMesh/generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var UVMap = {
	  schema: {
	    mWidth: { type: 'Number', label: 'Width', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    mHeight: { type: 'Number', label: 'Height', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    mLength: { type: 'Number', label: 'Length', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	
	    center: { label: 'Center', type: 'Vec3', step: 0.1, defaultValue: new _three2.default.Vector3(0, 0, 0), animatable: true },
	    rotation: { label: 'Rotation', type: 'Vec3', step: 1, minValue: -360, maxValue: 360, defaultValue: new _three2.default.Vector3(0, 0, 0), animatable: true },
	    uTile: { label: 'U Tile', type: 'Number', step: 0.1, defaultValue: 1.0, animatable: true },
	    vTile: { label: 'V Tile', type: 'Number', step: 0.1, defaultValue: 1.0, animatable: true },
	
	    uvProjectionMode: { label: 'Projection', type: 'Options', display: 'Radio',
	      values: [], // FIXME UVMAP type // 0, 1, 2, 3
	      labels: ['Planar', 'Box', 'Cylindrical', 'Spherical'], defaultValue: 0 /* FIXME PROPER value*/ },
	    xAxis: { label: 'Align Local Axis', type: 'Options', display: 'Radio',
	      values: [], //0, 1, 2, 3
	      labels: ['X', 'Y', 'Z', 'Average Normals'], defaultValue: 1 },
	    //uvMapChannel: { label: 'UV Channel', type: 'Text', defaultValue: 'default' },
	
	    autoFit: { label: 'Auto Fit', type: 'Button' },
	    autoAlign: { label: 'Auto Align', type: 'Button' }, // Hidden until local manipulators fixed
	    autoFitAlign: { label: 'Best Fit', type: 'Button' }, // Hidden until local manipulators fixed
	    autoCenter: { label: 'Auto Center', type: 'Button' },
	    resetUVs: { label: 'Reset', type: 'Button' }
	
	  },
	
	  // SubObjects
	  //indices: { label: "Selection", type: 'TextArea', defaultValue: "", display: 'indexStyle' },
	  //componentType: { type: 'Object', hidden: true, defaultValue: 'Face' },
	
	  // For backward compatibility
	  //scale: { label: 'scale', type: 'Vec3', step: 0.1, defaultValue: {x: 0, y: 0, z: 0}, hidden: true },
	
	  //subdivisions: { label: 'Subdivisions', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 4 },
	  //hardEdges: { label: 'Hard Edges', type: 'Boolean', defaultValue: false }
	  update: function update(operator, primitive) {
	    var mesh = primitive.mesh;
	    if (!mesh) return primitive;
	
	    var options = {};
	
	    options.uTile = operator.uTile;
	    options.vTile = operator.vTile;
	    options.uvProjectionMode = operator.uvProjectionMode;
	    options.alignmentAxis = operator.xAxis;
	    options.center = operator.center;
	    options.rotation = operator.rotation;
	    options.mapChannel = operator.uvMapChannel;
	    options.scale = new _three2.default.Vector3(operator.mWidth, operator.mHeight, operator.mLength);
	
	    primitive.mesh = applyUVMap(mesh, options);
	  }
	};
	
	function applyUVMap(polyMesh, uvMapOptions) {
	
	  uvMapOptions = uvMapOptions || {}; // because all values can be defaulted, uvMapOptions should be allowed to be null/undefined too!
	
	  var rotation = uvMapOptions.rotation.multiplyScalar(180 / Math.PI) || new _three2.default.Vector3();
	  var scale = uvMapOptions.scale || new _three2.default.Vector3(1, 1, 1);
	  var center = uvMapOptions.center || new _three2.default.Vector3();
	  var uvProjectionMode = uvMapOptions.uvProjectionMode !== undefined ? uvMapOptions.uvProjectionMode : 0;
	  var alignmentAxis = uvMapOptions.alignmentAxis !== undefined ? uvMapOptions.alignmentAxis : 1;
	  var mapChannel = uvMapOptions.mapChannel !== undefined ? uvMapOptions.mapChannel : 'default';
	  var uTile = uvMapOptions.uTile !== undefined ? uvMapOptions.uTile : 1.0;
	  var vTile = uvMapOptions.vTile !== undefined ? uvMapOptions.vTile : 1.0;
	
	  // Inverse matrix should be used, so uv map follows the gimzo
	  var matrixRotation = new _three2.default.Matrix4().makeRotationFromEuler(new _three2.default.Euler().setFromVector3(rotation, 'ZYX'));
	  var matrixRotationInv = new _three2.default.Matrix4().getInverse(matrixRotation);
	
	  var faceRangeOffsets = polyMesh.faceRangeOffsets;
	  var faceValueIndices = polyMesh.positions.faceValueIndices;
	  var values = polyMesh.positions.values;
	
	  var uvFaceValueIndices = new Uint32Array(faceValueIndices.length);
	  var uvValues = new _ObjectArrayView2.default(_three2.default.Vector2, faceValueIndices.length);
	
	  var vertex1 = new _three2.default.Vector3();
	  var vertex2 = new _three2.default.Vector3();
	  var faceNormal = new _three2.default.Vector3();
	  var newUV = new _three2.default.Vector2();
	
	  //for every face
	  var faceBegin = 0;
	  var faceEnd = 0;
	  var uvValueCounter = 0;
	  for (var i = 1; i < faceRangeOffsets.length; i++) {
	    faceEnd = faceRangeOffsets[i];
	
	    //compute the face normal
	    faceNormal.multiplyScalar(0);
	    for (var j = faceBegin; j < faceEnd; j++) {
	
	      var k = j + 1;
	      if (k >= faceEnd) {
	        k = faceBegin;
	      }
	      values.getAt(faceValueIndices[j], vertex1);
	      values.getAt(faceValueIndices[k], vertex2);
	
	      faceNormal.x += (vertex1.y - vertex2.y) * (vertex1.z + vertex2.z);
	      faceNormal.y += (vertex1.z - vertex2.z) * (vertex1.x + vertex2.x);
	      faceNormal.z += (vertex1.x - vertex2.x) * (vertex1.y + vertex2.y);
	    }
	    faceNormal.normalize();
	
	    //for every index on that face
	    for (var j = faceBegin; j < faceEnd; j++) {
	
	      values.getAt(faceValueIndices[j], vertex1);
	
	      vertex1.sub(center); // Translate to center
	      vertex1.applyMatrix4(matrixRotationInv); // Apply Inverse rotation to the vertex (to follow gizmo)
	
	      switch (uvProjectionMode) {
	
	        case 0:
	          //Planar
	          planarUVMap(vertex1, alignmentAxis, scale, newUV);
	          break;
	
	        case 1:
	          //Box
	          boxUVMap(vertex1, faceNormal, scale, newUV);
	          break;
	
	        case 2:
	          //Cylindrical
	          cylindricalUVMap(vertex1, alignmentAxis, scale, newUV);
	          break;
	
	        case 3:
	          //Spherical
	          sphericalUVMap(vertex1, alignmentAxis, scale, newUV);
	          break;
	
	        default:
	          newUV.set(0, 0);
	          break;
	      }
	
	      // Apply tiling
	      if (uTile !== 1.0) {
	        newUV.x *= uTile;
	      }
	
	      if (vTile !== 1.0) {
	        newUV.y *= vTile;
	      }
	
	      // Avoid disconnected uv faces
	      //TODO check for duplicate uv's on that vertex and don't store it twice;
	
	      uvFaceValueIndices[j] = uvValueCounter;
	      uvValues.setAt(uvValueCounter++, newUV);
	    }
	
	    faceBegin = faceEnd;
	  }
	
	  var resultMesh = new _PolyMesh2.default(polyMesh);
	
	  var newUVMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: uvFaceValueIndices,
	    values: uvValues
	  });
	
	  if (!resultMesh.uvMaps) resultMesh.uvMaps = new _ObjectsByName2.default();
	  resultMesh.uvMaps.set(mapChannel, newUVMap);
	
	  return resultMesh;
	};
	
	function boxUVMap(vertex, normal, scale, uv) {
	
	  var s = 0;
	  var t = 0;
	
	  var x = vertex.x;
	  var y = vertex.y;
	  var z = vertex.z;
	  // Face normal
	  var nx = Math.abs(normal.x);
	  var ny = Math.abs(normal.y);
	  var nz = Math.abs(normal.z);
	
	  if (nx >= ny && nx >= nz) {
	    s = -z / scale.z + 0.5;
	    t = y / scale.y + 0.5;
	  }
	  if (ny >= nx && ny >= nz) {
	    s = x / scale.x + 0.5;
	    t = -z / scale.z + 0.5;
	  }
	  if (nz >= nx && nz >= ny) {
	    s = x / scale.x + 0.5;
	    t = y / scale.y + 0.5;
	  }
	
	  // Otherside of box is mirror of the other side
	  // However, only making them negative is not a good solution for tiling, so we add them to 1 to be flipped in positive side
	  if (normal.x < 0) {
	    s = -s + 1;
	  }
	  if (normal.y < 0) {
	    s = -s + 1;
	  }
	  if (normal.z < 0) {
	    s = -s + 1;
	  }
	
	  uv.set(s, t);
	  return uv;
	};
	
	function planarUVMap(vertex, planeAxis, scale, uv) {
	
	  // Note: In case of plane we will not use scale.z
	  var u = planeAxis === 0 ? -vertex.z : vertex.x;
	  var v = planeAxis === 1 ? -vertex.z : vertex.y;
	
	  u = u / scale.x + 0.5;
	  v = v / scale.y + 0.5;
	
	  uv.set(u, v);
	
	  return uv;
	};
	
	function cylindricalUVMap(vertex, cylinderAxis, scale, uv) {
	
	  var lon = undefined;
	  var t = undefined;
	
	  switch (cylinderAxis) {
	    case 0:
	      lon = xyz_to_longitude(vertex.z / scale.z, vertex.x / scale.x, -vertex.y / scale.y);
	      t = -vertex.x / scale.x + 0.5;
	      break;
	
	    case 1:
	      lon = xyz_to_longitude(vertex.x / scale.x, vertex.y / scale.y, vertex.z / scale.z);
	      t = vertex.y / scale.y + 0.5;
	      break;
	
	    case 2:
	      lon = xyz_to_longitude(-vertex.x / scale.x, vertex.z / scale.z, -vertex.y / scale.y);
	      t = -vertex.z / scale.z + 0.5;
	      break;
	  }
	
	  // convert it from [0-2PI] to [0-1]
	  lon = lon / (Math.PI * 2);
	  uv.set(lon, t);
	
	  return uv;
	};
	
	function sphericalUVMap(vertex, sphereAxis, scale, uv) {
	
	  var lonlat = undefined;
	  var lat = undefined,
	      lon = undefined;
	
	  switch (sphereAxis) {
	    case 0:
	      lonlat = xyz_to_longitudelatitude(vertex.z / scale.z, vertex.x / scale.x, -vertex.y / scale.y);
	      break;
	
	    case 1:
	      lonlat = xyz_to_longitudelatitude(vertex.x / scale.x, -vertex.y / scale.y, vertex.z / scale.z);
	      break;
	
	    case 2:
	      lonlat = xyz_to_longitudelatitude(-vertex.x / scale.x, vertex.z / scale.z, -vertex.y / scale.y);
	      break;
	  }
	
	  // convert longitude from [0, 2PI] to [0,1], and latitude from [-PI, +PI] to [0,1]
	  lon = lonlat.lon / (Math.PI * 2);
	  lat = 0.5 - lonlat.lat / Math.PI;
	  uv.set(lon, lat);
	
	  return uv;
	};
	
	// convert XYZ space to longitude
	// Returns longitude is in interval [-PI,+PI]
	function xyz_to_longitude(x, y, z) {
	
	  var lon = undefined;
	
	  if (x === 0 && z === 0) {
	
	    lon = 0;
	  } else {
	    lon = Math.atan2(x, z);
	
	    // longitude is in interval [-PI,+PI], so we add two PI to negative longitudes to be between [0,2PI]
	    if (lon < 0) {
	      lon += Math.PI * 2;
	    }
	  }
	
	  return lon;
	};
	
	// convert XYZ space to longitude and latitude
	// Returns longitude [0, 2PI] and latitude [-PI, +PI]
	function xyz_to_longitudelatitude(x, y, z) {
	
	  var lo = undefined,
	      la = undefined;
	
	  if (x === 0 && z === 0) {
	    lo = 0;
	
	    if (y !== 0) {
	      la = y < 0 ? -(Math.PI / 2) : Math.PI / 2;
	    } else {
	      la = 0;
	    }
	  } else {
	
	    lo = Math.atan2(x, z);
	
	    // longitude is in interval [-PI,+PI], so we add two PI to negative longitudes to be between [0,2PI]
	    if (lo < 0) {
	      lo += Math.PI * 2;
	    }
	
	    var h = Math.sqrt(x * x + z * z);
	    // latitude is in [-PI,+PI]
	    la = Math.atan2(y, h);
	  }
	  return {
	    lon: lo,
	    lat: la
	  };
	};
	
	exports.default = UVMap;

/***/ },
/* 211 */
/*!***********************************************!*\
  !*** ./src/operators/PolyMesh/UVTransform.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _PolyMesh = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../../polyMesh/geometric/model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../polyMesh/generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ScaleMode = {
	  Scale: 0,
	  Tiling: 1
	};
	
	var UVTransform = {
	  name: 'UVTransform',
	  label: 'UV Transform',
	
	  schema: {
	    rotation: { label: 'Rotation', type: 'Number', step: 0.1, minValue: -360, maxValue: 360, defaultValue: 0, animatable: true },
	    scaleMode: { label: 'Scale Mode', type: 'Options', display: 'Dropdown',
	      labels: ['Scale', 'Tiling'],
	      values: [ScaleMode.Scale, ScaleMode.Tiling],
	      defaultValue: ScaleMode.Scale },
	    tiling: { label: 'Tiling', type: 'Vec2', step: 0.1, defaultValue: new _three2.default.Vector2(1, 1), animatable: true },
	    scale: { label: 'Scale', type: 'Vec2', step: 0.1, defaultValue: new _three2.default.Vector2(1, 1), animatable: true },
	    translation: { label: 'Translation', type: 'Vec2', step: 0.1, defaultValue: new _three2.default.Vector2(0, 0), animatable: true },
	    pivotCenter: { label: 'Pivot Center', type: 'Vec2', step: 0.1, defaultValue: new _three2.default.Vector2(0, 0), animatable: true },
	
	    uvMapChannel: { label: 'UV Channel', type: 'Text', defaultValue: 'default' }
	
	  },
	
	  update: function update(operator, primitive) {
	
	    var mesh = primitive.mesh;
	    if (!mesh) return primitive;
	
	    var mapChannel = operator.uvMapChannel || 'default'; //consider empty channel as default
	
	    var uvMap = mesh.uvMaps ? mesh.uvMaps.byName[mapChannel] : null;
	    if (!uvMap) return primitive;
	
	    var uvVec3 = new _three2.default.Vector3();
	    var uv = new _three2.default.Vector2();
	    var uvValues = new _ObjectArrayView2.default(_three2.default.Vector2, uvMap.values.length);
	
	    var rotation = operator.rotation;
	    var scaleMode = operator.scaleMode;
	    var scale = operator.scale;
	    var tiling = operator.tiling;
	    var translation = operator.translation;
	    var pivotCenter = operator.pivotCenter;
	
	    var uvTransform = getUVTransform(rotation, tiling, scaleMode === ScaleMode.Scale, scale, translation, pivotCenter);
	
	    for (var i = 0; i < uvMap.values.length; i++) {
	      uvMap.values.getAt(i, uv);
	      uvVec3.set(uv.x, uv.y, 0);
	      uvVec3.applyMatrix4(uvTransform);
	      uv.set(uvVec3.x, uvVec3.y);
	      uvValues.setAt(i, uv);
	    }
	
	    var resultMesh = new _PolyMesh2.default(mesh);
	
	    var newUVMap = new _PolyMap2.default({
	      faceRangeOffsets: mesh.faceRangeOffsets,
	      faceValueIndices: uvMap.faceValueIndices,
	      values: uvValues
	    });
	
	    resultMesh.uvMaps.set(mapChannel, newUVMap);
	
	    primitive.mesh = resultMesh;
	  }
	};
	
	function getUVTransform(rotation, tiling, useScale, scale, translation, pivotCenter) {
	
	  var result = new _three2.default.Matrix4();
	
	  result.multiply(new _three2.default.Matrix4().makeTranslation(pivotCenter.x, pivotCenter.y, 0));
	  result.multiply(new _three2.default.Matrix4().makeRotationZ(_three2.default.Math.degToRad(rotation)));
	  if (useScale) {
	    result.multiply(new _three2.default.Matrix4().makeScale(scale.x, scale.y, 0));
	  } else {
	    var safeInverse = function safeInverse(v) {
	      return v == 0 ? 1 : 1 / v;
	    };
	    result.multiply(new _three2.default.Matrix4().makeScale(safeInverse(tiling.x), safeInverse(tiling.y), 0));
	  }
	  result.multiply(new _three2.default.Matrix4().makeTranslation(-pivotCenter.x, -pivotCenter.y, 0));
	  result.multiply(new _three2.default.Matrix4().makeTranslation(translation.x, translation.y, 0));
	
	  return result;
	};
	
	exports.default = UVTransform;

/***/ },
/* 212 */
/*!****************************************!*\
  !*** ./src/operators/PolyMesh/Skin.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _skin = __webpack_require__(/*! ../../polyMesh/geometric/operator/skin */ 213);
	
	var _skin2 = _interopRequireDefault(_skin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Skin = {
	  schema: {
	    boneNodeList: { type: 'NodeList', label: 'Select Bones', plug: 'Bone' },
	    optionalRootBone: { type: 'Node', label: 'Optional Root Bone', defaultValue: null, filter: function filter(n) {
	        return n.isBone();
	      } }
	  },
	
	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;
	    var getWorldTransform = _ref.getWorldTransform;
	
	    var skinWorldTransform = getWorldTransform(node.id);
	
	    // Ensure we reference the bone node list, so that the dependency
	    // graph gets updated properly.
	    var nodeList = operator.boneNodeList;
	    var rootBone = operator.optionalRootBone;
	    var rootBoneIndex = -1;
	
	    //get world transforms for each bone
	    var boneWorldTransforms = nodeList.map(function (boneNode) {
	      return getWorldTransform(boneNode);
	    });
	
	    //get the index of the root bone
	    if (rootBone) {
	      for (var i = 0, il = nodeList.length; i < il; i++) {
	        var boneNode = nodeList[i];
	        if (boneNode == rootBone) {
	          rootBoneIndex = i;
	          break;
	        }
	      }
	    }
	
	    var polyMesh = primitive.mesh;
	    var skinToWorldTransform = skinWorldTransform;
	
	    primitive.mesh = (0, _skin2.default)(polyMesh, skinToWorldTransform, boneWorldTransforms, rootBoneIndex);
	  }
	};
	
	exports.default = Skin;

/***/ },
/* 213 */
/*!*************************************************!*\
  !*** ./src/polyMesh/geometric/operator/skin.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = skin;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _Skinning = __webpack_require__(/*! ../model/Skinning */ 187);
	
	var _Skinning2 = _interopRequireDefault(_Skinning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function skin(polyMesh, skinToWorldTransform, boneWorldTransforms, rootBoneIndex) {
	  if (!polyMesh || !polyMesh.skinning) {
	    //console.warn('Polymesh skinning is undefined.', polyMesh);
	    return polyMesh;
	  }
	
	  var skinning = polyMesh.skinning;
	  var newValues = skinning.applyTransforms(polyMesh.positions.values, skinToWorldTransform, boneWorldTransforms, rootBoneIndex);
	
	  var newPositions = new _PolyMap2.default({
	    faceRangeOffsets: polyMesh.faceRangeOffsets,
	    faceValueIndices: polyMesh.positions.faceValueIndices,
	    values: newValues
	  });
	
	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.positions = newPositions;
	
	  return resultMesh;
	};

/***/ },
/* 214 */
/*!***************************************!*\
  !*** ./src/operators/PolyMesh/Box.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Box = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Box */ 215);
	
	var _Box2 = _interopRequireDefault(_Box);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Box = {
	  schema: {
	    depth: { type: 'Number', label: 'Depth', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    width: { type: 'Number', label: 'Width', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    height: { type: 'Number', label: 'Height', defaultValue: 1, step: 0.1, minValue: 0.0, animatable: true },
	    depthSegments: { type: 'Number', label: 'Depth Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true, i18n: { en: {}, xn: { label: "XXX" }, hn: { label: "DX" } } },
	    widthSegments: { type: 'Number', label: 'Width Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true },
	    heightSegments: { type: 'Number', label: 'Height Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true }
	  },
	
	  update: function update(operator, primitive) {
	    var width = operator.width;
	    var height = operator.height;
	    var depth = operator.depth;
	    var widthSegments = operator.widthSegments;
	    var heightSegments = operator.heightSegments;
	    var depthSegments = operator.depthSegments;
	
	    primitive.mesh = (0, _Box2.default)(width, height, depth, widthSegments, heightSegments, depthSegments);
	  }
	};
	
	exports.default = Box;

/***/ },
/* 215 */
/*!**************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Box.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Box;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _removeDuplicateValues = __webpack_require__(/*! ../operator/removeDuplicateValues */ 216);
	
	var _removeDuplicateValues2 = _interopRequireDefault(_removeDuplicateValues);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Box(width, height, depth, widthSegments, heightSegments, depthSegments) {
	
	  widthSegments = Math.floor(widthSegments) || 1;
	  heightSegments = Math.floor(heightSegments) || 1;
	  depthSegments = Math.floor(depthSegments) || 1;
	
	  var faceRangeOffsets = new Uint32Array(widthSegments * heightSegments * 2 + widthSegments * depthSegments * 2 + heightSegments * depthSegments * 2 + 1); //number of faces
	  var faceValueIndices = new Uint32Array((widthSegments * heightSegments * 2 + widthSegments * depthSegments * 2 + heightSegments * depthSegments * 2) * 4); //number of faces*4
	  var values = new _ObjectArrayView2.default(_three2.default.Vector3, (widthSegments + 1) * (heightSegments + 1) * 2 + (widthSegments + 1) * (depthSegments + 1) * 2 + (heightSegments + 1) * (depthSegments + 1) * 2);
	  var normals = new _ObjectArrayView2.default(_three2.default.Vector3, (widthSegments + 1) * (heightSegments + 1) * 2 + (widthSegments + 1) * (depthSegments + 1) * 2 + (heightSegments + 1) * (depthSegments + 1) * 2);
	  var uvValues = new _ObjectArrayView2.default(_three2.default.Vector2, (widthSegments + 1) * (heightSegments + 1) * 2 + (widthSegments + 1) * (depthSegments + 1) * 2 + (heightSegments + 1) * (depthSegments + 1) * 2);
	
	  var segment_width = width / widthSegments;
	  var segment_height = height / heightSegments;
	  var segment_depth = depth / depthSegments;
	
	  var width_half = width / 2;
	  var height_half = height / 2;
	  var depth_half = depth / 2;
	
	  var ix = undefined,
	      iy = undefined,
	      iz = undefined;
	  var indOffset = 0;
	
	  var newValue = new _three2.default.Vector3();
	  var newNormal = new _three2.default.Vector3();
	  var newUV = new _three2.default.Vector2();
	
	  //push utility for faceValueIndices
	  var indLengthMarker = 0;
	  function pushInd(value) {
	    faceValueIndices[indLengthMarker] = value;
	    indLengthMarker++;
	  }
	
	  //populate FaceRangeOffsets
	  for (iz = 0, ix = 0; iz < faceRangeOffsets.length; iz++, ix += 4) {
	    faceRangeOffsets[iz] = ix; //0 4 8 12 16 20 ...
	  }
	
	  //front and back
	  for (iz = 0; iz < 2; iz++) {
	    //do twice, one for each face
	    for (iy = 0; iy < heightSegments; iy++) {
	      for (ix = 0; ix < widthSegments; ix++) {
	        pushInd(indOffset + iy * (widthSegments + 1) + ix);
	        pushInd(indOffset + iy * (widthSegments + 1) + ix + 1);
	        pushInd(indOffset + (iy + 1) * (widthSegments + 1) + ix + 1);
	        pushInd(indOffset + (iy + 1) * (widthSegments + 1) + ix);
	      }
	    }
	    indOffset += (widthSegments + 1) * (heightSegments + 1);
	  }
	
	  //top and bottom face
	  for (iy = 0; iy < 2; iy++) {
	    //do twice, one for each face
	    for (iz = 0; iz < depthSegments; iz++) {
	      for (ix = 0; ix < widthSegments; ix++) {
	        pushInd(indOffset + iz * (widthSegments + 1) + ix);
	        pushInd(indOffset + iz * (widthSegments + 1) + ix + 1);
	        pushInd(indOffset + (iz + 1) * (widthSegments + 1) + ix + 1);
	        pushInd(indOffset + (iz + 1) * (widthSegments + 1) + ix);
	      }
	    }
	    indOffset += (widthSegments + 1) * (depthSegments + 1);
	  }
	
	  //left and right face
	  for (ix = 0; ix < 2; ix++) {
	    //do twice, one for each face
	    for (iy = 0; iy < heightSegments; iy++) {
	      for (iz = 0; iz < depthSegments; iz++) {
	        pushInd(indOffset + iy * (depthSegments + 1) + iz);
	        pushInd(indOffset + iy * (depthSegments + 1) + iz + 1);
	        pushInd(indOffset + (iy + 1) * (depthSegments + 1) + iz + 1);
	        pushInd(indOffset + (iy + 1) * (depthSegments + 1) + iz);
	      }
	    }
	    indOffset += (depthSegments + 1) * (heightSegments + 1);
	  }
	
	  //push utility for faceValueIndices
	  var valLengthMarker = 0;
	  function pushVal(value) {
	    values.setAt(valLengthMarker, value);
	    valLengthMarker++;
	  }
	
	  //push utility for uv's and normals
	  var uv_normLengthMarker = 0;
	  function push_uv_norm(uv, norm) {
	    uvValues.setAt(uv_normLengthMarker, uv);
	    normals.setAt(uv_normLengthMarker, norm);
	    uv_normLengthMarker++;
	  }
	
	  //populate values, normals, and uv values
	  //front and back
	  for (iz = -1; iz < 2; iz += 2) {
	    //do twice for each side with -1 for first and +1 for second
	    for (iy = 0; iy < heightSegments + 1; iy++) {
	
	      //calculate y coord
	      var y = -1 * iz * iy * segment_height + iz * height_half;
	
	      for (ix = 0; ix < widthSegments + 1; ix++) {
	        //calculate x coord
	        var x = ix * segment_width - width_half;
	
	        //set value
	        newValue.set(x, y, -1 * iz * depth_half);
	        pushVal(newValue);
	
	        //set normal
	        newNormal.set(0, 0, -1 * iz);
	
	        //set uv value
	        newUV.set(ix / widthSegments, iy / heightSegments);
	        push_uv_norm(newUV, newNormal);
	      }
	    }
	  }
	
	  //top and bottom
	  for (iy = -1; iy < 2; iy += 2) {
	    //do twice for each side with -1 for first and +1 for second
	    for (ix = 0; ix < widthSegments + 1; ix++) {
	
	      //calculate z coord
	      var x = -1 * ix * iy * segment_width + iy * width_half;
	
	      for (iz = 0; iz < depthSegments + 1; iz++) {
	        //calculate x coord
	        var z = iz * segment_depth - depth_half;
	
	        //set value
	        newValue.set(x, -1 * iy * height_half, z);
	        pushVal(newValue);
	
	        //set normal
	        newNormal.set(0, -1 * iy, 0);
	
	        //set uv value
	        newUV.set(ix / widthSegments, iz / depthSegments);
	        push_uv_norm(newUV, newNormal);
	      }
	    }
	  }
	
	  //left and right
	  for (ix = -1; ix < 2; ix += 2) {
	    //do twice for each side with -1 for first and +1 for second
	    for (iz = 0; iz < depthSegments + 1; iz++) {
	
	      //calculate y coord
	      var z = -1 * ix * iz * segment_depth + ix * depth_half;
	
	      for (iy = 0; iy < heightSegments + 1; iy++) {
	        //calculate z coord
	        var y = iy * segment_height - height_half;
	
	        //set value
	        newValue.set(-1 * ix * width_half, y, z);
	        pushVal(newValue);
	
	        //set normal
	        newNormal.set(-1 * ix, 0, 0);
	
	        //set uv value
	        newUV.set(iz / depthSegments, iy / heightSegments);
	        push_uv_norm(newUV, newNormal);
	      }
	    }
	  }
	
	  var positionsMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: values
	  });
	
	  var normalMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: normals
	  });
	
	  var uvMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: uvValues
	  });
	
	  var uvMapsByName = new _ObjectsByName2.default();
	  var name = "default";
	  uvMapsByName.set(name, uvMap);
	
	  var polyMesh = new _PolyMesh2.default();
	  polyMesh.faceRangeOffsets = faceRangeOffsets;
	  polyMesh.positions = positionsMap;
	  polyMesh.normalMap = normalMap;
	  polyMesh.uvMaps = uvMapsByName;
	
	  return (0, _removeDuplicateValues2.default)(polyMesh);
	};

/***/ },
/* 216 */
/*!******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeDuplicateValues.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeDuplicateValues;
	
	var _map = __webpack_require__(/*! babel-runtime/core-js/map */ 217);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ObjectBuffer = __webpack_require__(/*! ../../generic/container/ObjectBuffer */ 173);
	
	var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function removeDuplicateValues(polyMesh, withLogging) {
	
	  //removes indentical values in the values array and remaps the indices
	  //also has the side effect of removing values not used by a face
	
	  var l = withLogging || false;
	
	  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
	  var values = polyMesh.positions.values;
	
	  var newValues = new _ObjectBuffer2.default(_three2.default.Vector3);
	
	  var valueMappings = new _map2.default();
	  var newValuesLength = 0;
	
	  var key = 0;
	  var newIndex = 0;
	  var value = new _three2.default.Vector3();
	  var keyValue = new _three2.default.Vector3();
	
	  var boundingBox = new _three2.default.Box3();
	  boundingBox.setFromArray(new Float32Array(values.data));
	  var boundingBoxDiagonalWithShift = boundingBox.size().length() * Math.pow(2, 17);
	
	  for (var ix = 0; ix < faceValueIndices.length; ix++) {
	
	    values.getAt(faceValueIndices[ix], value);
	    //hash function scales values to the diagonal of the bounding box and stores 17 bits of precision in 3 buckets in a 64 bit float (52 bits usable)
	    keyValue.subVectors(value, boundingBox.min).multiplyScalar(boundingBoxDiagonalWithShift);
	    key = keyValue.x * 1000000000000 + keyValue.y * 100000 + keyValue.z;
	
	    if (!valueMappings.has(key)) {
	      valueMappings.set(key, newValuesLength); //save location of value in map
	      newIndex = newValuesLength;
	      newValues.push(value); //push value to the newValues array
	      newValuesLength++;
	    } else {
	      newIndex = valueMappings.get(key);
	    }
	
	    faceValueIndices[ix] = newIndex; //update indices array with new value
	  }
	
	  if (l) console.log('' + values.length + ' values reduced to ' + newValuesLength + ', duplicates removed: ' + (values.length - newValuesLength));
	
	  if (values.length === newValuesLength) return polyMesh;
	
	  var newValuesArray = new _ObjectArrayView2.default(_three2.default.Vector3, newValuesLength);
	  newValuesArray.fromArray(newValues.toArray());
	
	  var newPositions = new _PolyMap2.default({
	    faceRangeOffsets: polyMesh.faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: newValuesArray
	  });
	
	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.positions = newPositions;
	
	  return resultMesh;
	};

/***/ },
/* 217 */
/*!****************************************!*\
  !*** ./~/babel-runtime/core-js/map.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/map */ 218), __esModule: true };

/***/ },
/* 218 */
/*!*****************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/map.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/es6.object.to-string */ 82);
	__webpack_require__(/*! ../modules/es6.string.iterator */ 5);
	__webpack_require__(/*! ../modules/web.dom.iterable */ 83);
	__webpack_require__(/*! ../modules/es6.map */ 219);
	__webpack_require__(/*! ../modules/es7.map.to-json */ 224);
	module.exports = __webpack_require__(/*! ../modules/_core */ 13).Map;

/***/ },
/* 219 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.map.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(/*! ./_collection-strong */ 220);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(/*! ./_collection */ 221)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 220 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_collection-strong.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(/*! ./_object-dp */ 17).f
	  , create      = __webpack_require__(/*! ./_object-create */ 30)
	  , hide        = __webpack_require__(/*! ./_hide */ 16)
	  , redefineAll = __webpack_require__(/*! ./_redefine-all */ 96)
	  , ctx         = __webpack_require__(/*! ./_ctx */ 14)
	  , anInstance  = __webpack_require__(/*! ./_an-instance */ 88)
	  , defined     = __webpack_require__(/*! ./_defined */ 8)
	  , forOf       = __webpack_require__(/*! ./_for-of */ 89)
	  , $iterDefine = __webpack_require__(/*! ./_iter-define */ 9)
	  , step        = __webpack_require__(/*! ./_iter-step */ 86)
	  , setSpecies  = __webpack_require__(/*! ./_set-species */ 97)
	  , DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ 21)
	  , fastKey     = __webpack_require__(/*! ./_meta */ 121).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 221 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_collection.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(/*! ./_global */ 12)
	  , $export        = __webpack_require__(/*! ./_export */ 11)
	  , meta           = __webpack_require__(/*! ./_meta */ 121)
	  , fails          = __webpack_require__(/*! ./_fails */ 22)
	  , hide           = __webpack_require__(/*! ./_hide */ 16)
	  , redefineAll    = __webpack_require__(/*! ./_redefine-all */ 96)
	  , forOf          = __webpack_require__(/*! ./_for-of */ 89)
	  , anInstance     = __webpack_require__(/*! ./_an-instance */ 88)
	  , isObject       = __webpack_require__(/*! ./_is-object */ 19)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 45)
	  , dP             = __webpack_require__(/*! ./_object-dp */ 17).f
	  , each           = __webpack_require__(/*! ./_array-methods */ 222)(0)
	  , DESCRIPTORS    = __webpack_require__(/*! ./_descriptors */ 21);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 222 */
/*!*********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_array-methods.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(/*! ./_ctx */ 14)
	  , IObject  = __webpack_require__(/*! ./_iobject */ 35)
	  , toObject = __webpack_require__(/*! ./_to-object */ 48)
	  , toLength = __webpack_require__(/*! ./_to-length */ 38)
	  , asc      = __webpack_require__(/*! ./_array-species-create */ 223);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 223 */
/*!****************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_array-species-create.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var isObject = __webpack_require__(/*! ./_is-object */ 19)
	  , isArray  = __webpack_require__(/*! ./_is-array */ 124)
	  , SPECIES  = __webpack_require__(/*! ./_wks */ 46)('species');
	module.exports = function(original, length){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length);
	};

/***/ },
/* 224 */
/*!**********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es7.map.to-json.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(/*! ./_export */ 11);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(/*! ./_collection-to-json */ 225)('Map')});

/***/ },
/* 225 */
/*!**************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_collection-to-json.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(/*! ./_classof */ 54)
	  , from    = __webpack_require__(/*! ./_array-from-iterable */ 226);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 226 */
/*!***************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_array-from-iterable.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(/*! ./_for-of */ 89);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 227 */
/*!******************************************!*\
  !*** ./src/operators/PolyMesh/Sphere.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Sphere = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Sphere */ 228);
	
	var _Sphere2 = _interopRequireDefault(_Sphere);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Sphere = {
	  schema: {
	    radius: { label: 'Radius', type: 'Number', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    widthSegments: { label: 'Longitudinal Segments', type: 'Integer', defaultValue: 24, minValue: 3, maxValue: 200, step: 1, animatable: true },
	    heightSegments: { label: 'Latitudinal Segments', type: 'Integer', defaultValue: 24, minValue: 3, maxValue: 200, step: 1, animatable: true },
	    phiStart: { label: 'Phi Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    phiLength: { label: 'Phi Length', type: 'Number', defaultValue: 360, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    thetaStart: { label: 'Theta Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 180, step: 10, animatable: true },
	    thetaLength: { label: 'Theta Length', type: 'Number', defaultValue: 180, minValue: 0, maxValue: 180, step: 10, animatable: true }
	  },
	
	  update: function update(operator, primitive) {
	    var radius = operator.radius;
	    var widthSegments = operator.widthSegments;
	    var heightSegments = operator.heightSegments;
	    var phiStart = operator.phiStart;
	    var phiLength = operator.phiLength;
	    var thetaStart = operator.thetaStart;
	    var thetaLength = operator.thetaLength;
	
	    primitive.mesh = (0, _Sphere2.default)(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
	  }
	};
	
	exports.default = Sphere;

/***/ },
/* 228 */
/*!*****************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Sphere.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Sphere;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _Lathe = __webpack_require__(/*! ./Lathe */ 229);
	
	var _Lathe2 = _interopRequireDefault(_Lathe);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Sphere(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
	
	  radius = radius || 50;
	
	  widthSegments = Math.max(3, Math.floor(widthSegments || 8));
	  heightSegments = Math.max(2, Math.floor(heightSegments || 6));
	
	  phiStart = _three2.default.Math.clamp(phiStart || 0, 0, Math.PI * 2);
	  phiLength = _three2.default.Math.clamp(phiLength || Math.PI * 2, 0, Math.PI * 2 - phiStart);
	
	  thetaStart = _three2.default.Math.clamp(thetaStart || 0, 0, Math.PI);
	  thetaLength = _three2.default.Math.clamp(thetaLength || Math.PI, 0, Math.PI - thetaStart);
	
	  var inverseHeightSegments = 1.0 / heightSegments;
	  var points = new _ObjectArrayView2.default(_three2.default.Vector3, heightSegments + 1);
	  var norms = new _ObjectArrayView2.default(_three2.default.Vector3, heightSegments + 1);
	  var pt = new _three2.default.Vector3();
	
	  for (var i = 0, il = heightSegments; i <= il; i++) {
	
	    var theta = thetaStart + i * inverseHeightSegments * thetaLength;
	
	    pt.set(radius * Math.sin(theta), -radius * Math.cos(theta), 0);
	
	    points.setAt(i, pt);
	    norms.setAt(i, pt.normalize());
	  }
	
	  return (0, _Lathe2.default)(points, norms, widthSegments, phiStart, phiLength);
	}

/***/ },
/* 229 */
/*!****************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Lathe.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Lathe;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _cleanPolyMesh = __webpack_require__(/*! ../operator/cleanPolyMesh */ 230);
	
	var _cleanPolyMesh2 = _interopRequireDefault(_cleanPolyMesh);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Lathe(points, norms, segments, phiStart, phiLength) {
	  //assumes one normal per point
	  var positions = new _ObjectArrayView2.default(_three2.default.Vector3, (segments + 1) * points.length);
	  var normals = new _ObjectArrayView2.default(_three2.default.Vector3, (segments + 1) * norms.length);
	  var positionCounter = 0;
	  var faceRangeOffsets = new Uint32Array(segments * (points.length - 1) + 1); //number of faces
	  var faceValueIndices = new Uint32Array(segments * (points.length - 1) * 4); //number of faces*4
	  var indCounter = 0;
	  var uvValues = new _ObjectArrayView2.default(_three2.default.Vector2, (segments + 1) * points.length);
	  var uvCounter = 0;
	
	  segments = segments || 12;
	  phiStart = phiStart || 0;
	  phiLength = phiLength || 2 * Math.PI;
	
	  var inversePointLength = 1.0 / (points.length - 1);
	  var inverseSegments = 1.0 / segments;
	
	  faceRangeOffsets[0] = 0;
	  var faceCounter = 1;
	
	  var tempUV = new _three2.default.Vector2();
	  var vertex = new _three2.default.Vector3();
	  var normal = new _three2.default.Vector3();
	
	  var rotationMatrix4 = new _three2.default.Matrix4().identity();
	  var rotationMatrix = new _three2.default.Matrix3().identity();
	
	  for (var i = 0, il = segments; i <= il; i++) {
	
	    var phi = phiStart + i * inverseSegments * phiLength;
	    rotationMatrix4.copy(rotationMatrix4.makeRotationY(phi));
	    rotationMatrix.getNormalMatrix(rotationMatrix4);
	
	    var u = i * inverseSegments;
	
	    for (var j = 0, jl = points.length; j < jl; j++) {
	
	      points.getAt(j, vertex);
	      norms.getAt(j, normal);
	
	      vertex.applyMatrix3(rotationMatrix);
	      normal.applyMatrix3(rotationMatrix);
	
	      vertex.set(Math.round(vertex.x * 1000) / 1000, Math.round(vertex.y * 1000) / 1000, Math.round(vertex.z * 1000) / 1000);
	
	      normal.set(Math.round(normal.x * 1000) / 1000, Math.round(normal.y * 1000) / 1000, Math.round(normal.z * 1000) / 1000);
	
	      positions.setAt(positionCounter, vertex);
	      normals.setAt(positionCounter, normal);
	
	      var v = j / (points.length - 1);
	
	      tempUV.set(u, v);
	      uvValues.setAt(positionCounter++, tempUV);
	    }
	  }
	
	  var np = points.length;
	
	  for (var i = 0, il = segments; i < il; i++) {
	
	    for (var j = 0, jl = points.length - 1; j < jl; j++) {
	
	      var base = j + np * i;
	      var a = base;
	      var b = base + np;
	      var c = base + 1 + np;
	      var d = base + 1;
	
	      faceValueIndices[indCounter++] = a;
	      faceValueIndices[indCounter++] = b;
	      faceValueIndices[indCounter++] = c;
	      faceValueIndices[indCounter++] = d;
	      faceRangeOffsets[faceCounter++] = indCounter;
	    }
	  }
	
	  var positionsMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: positions
	  });
	
	  var normalMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: normals
	  });
	
	  var uvMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: uvValues
	  });
	
	  var uvMapsByName = new _ObjectsByName2.default();
	  var name = "default";
	  uvMapsByName.set(name, uvMap);
	
	  var polyMesh = new _PolyMesh2.default();
	  polyMesh.faceRangeOffsets = positionsMap.faceRangeOffsets;
	  polyMesh.positions = positionsMap;
	  polyMesh.normalMap = normalMap;
	  polyMesh.uvMaps = uvMapsByName;
	
	  return (0, _cleanPolyMesh2.default)(new _PolyMesh2.default(polyMesh));
	  //return new PolyMesh( new PolyMesh( polyMesh ) );
	}

/***/ },
/* 230 */
/*!**********************************************************!*\
  !*** ./src/polyMesh/geometric/operator/cleanPolyMesh.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = cleanPolyMesh;
	
	var _removeDuplicateValues = __webpack_require__(/*! ../operator/removeDuplicateValues */ 216);
	
	var _removeDuplicateValues2 = _interopRequireDefault(_removeDuplicateValues);
	
	var _removeDuplicateIndices = __webpack_require__(/*! ../operator/removeDuplicateIndices */ 231);
	
	var _removeDuplicateIndices2 = _interopRequireDefault(_removeDuplicateIndices);
	
	var _removeInvalidSurfaces = __webpack_require__(/*! ../operator/removeInvalidSurfaces */ 232);
	
	var _removeInvalidSurfaces2 = _interopRequireDefault(_removeInvalidSurfaces);
	
	var _removeDuplicateNormals = __webpack_require__(/*! ../operator/removeDuplicateNormals */ 199);
	
	var _removeDuplicateNormals2 = _interopRequireDefault(_removeDuplicateNormals);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function cleanPolyMesh(polyMesh) {
	  //not advisable to remove normals by default. can lead to fusing of normals on joints while doing animation
	  //return removeDuplicateNormals(removeInvalidSurfaces(removeDuplicateIndices(removeDuplicateValues(polyMesh))));
	  return (0, _removeInvalidSurfaces2.default)((0, _removeDuplicateIndices2.default)((0, _removeDuplicateValues2.default)(polyMesh)));
	}

/***/ },
/* 231 */
/*!*******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeDuplicateIndices.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeDuplicateIndices;
	
	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 102);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _map = __webpack_require__(/*! babel-runtime/core-js/map */ 217);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	var _ObjectBuffer = __webpack_require__(/*! ../../generic/container/ObjectBuffer */ 173);
	
	var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function removeDuplicateIndices(polyMesh, withLogging) {
	
	  var l = withLogging || false;
	
	  var faceRangeOffsets = new Uint32Array(polyMesh.positions.faceRangeOffsets);
	  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
	  var normalFaceValueIndices = new Uint32Array(polyMesh.normalMap.faceValueIndices);
	
	  var uvMapNames = [];
	  var uvMapsNewIndices = [];
	  if (polyMesh.uvMaps) {
	    for (var i = 0; i < polyMesh.uvMaps.length; i++) {
	      uvMapNames.push(polyMesh.uvMaps.namesByIndex[i]);
	      uvMapsNewIndices.push(new Uint32Array(polyMesh.uvMaps.byName[uvMapNames[i]].faceValueIndices));
	    }
	  }
	
	  var newIndicesMarker = 0;
	
	  var previousFaceIndex = 0;
	  var currentFaceIndex = 0;
	  var currentFaceSize = 0;
	  var newFaceSize = 0;
	
	  //stores [index value, index];
	  var uniqueIndicesMap = new _map2.default();
	
	  //Check every face
	  for (var i = 1; i < faceRangeOffsets.length; i++) {
	
	    currentFaceIndex = faceRangeOffsets[i];
	    currentFaceSize = currentFaceIndex - previousFaceIndex;
	    newFaceSize = currentFaceSize;
	
	    //check unique
	    uniqueIndicesMap.clear();
	    for (var j = 0; j < currentFaceSize; j++) {
	      uniqueIndicesMap.set(faceValueIndices[previousFaceIndex + j], previousFaceIndex + j);
	    }
	
	    newFaceSize = uniqueIndicesMap.size;
	    //special case face of size 1
	    if (newFaceSize === 1) {
	      if (l && currentFaceSize > 1) console.log('Face ' + i + ' has only 1 unique value. Reducing to a point...');
	      faceRangeOffsets[i] = faceRangeOffsets[i - 1] + 1;
	      faceValueIndices[newIndicesMarker++] = faceValueIndices[previousFaceIndex];
	    } else {
	      if (l && currentFaceSize === 2) console.log('Face ' + i + ' has only 2 unique values. Reducing to a line...');
	
	      faceRangeOffsets[i] = faceRangeOffsets[i - 1] + newFaceSize;
	      var entries = uniqueIndicesMap.entries();
	
	      var element = undefined;
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = (0, _getIterator3.default)(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          element = _step.value;
	
	          normalFaceValueIndices[newIndicesMarker] = normalFaceValueIndices[element[1]];
	          for (var k = 0; k < uvMapsNewIndices.length; k++) {
	            uvMapsNewIndices[k][newIndicesMarker] = uvMapsNewIndices[k][element[1]];
	          }
	          faceValueIndices[newIndicesMarker++] = element[0];
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	    previousFaceIndex = currentFaceIndex;
	  }
	
	  if (l) console.log('' + faceValueIndices.length + ' index values reduced to ' + newIndicesMarker + ', duplicates removed: ' + (faceValueIndices.length - newIndicesMarker));
	
	  var newIndices = new Uint32Array(faceValueIndices.subarray(0, newIndicesMarker));
	  var newNormalIndices = new Uint32Array(normalFaceValueIndices.subarray(0, newIndicesMarker));
	
	  var positions = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: newIndices,
	    values: polyMesh.positions.values
	  });
	
	  var results = new _PolyMesh2.default();
	  results.positions = positions;
	  results.faceRangeOffsets = results.positions.faceRangeOffsets;
	
	  var normalMap = new _PolyMap2.default({
	    faceRangeOffsets: results.faceRangeOffsets,
	    faceValueIndices: newNormalIndices,
	    values: polyMesh.normalMap.values
	  });
	  results.normalMap = normalMap;
	
	  if (polyMesh.uvMaps) {
	    var uvMaps = new _ObjectsByName2.default();
	    for (var i = 0; i < polyMesh.uvMaps.length; i++) {
	      var name = polyMesh.uvMaps.namesByIndex[i];
	      var uvMap = new _PolyMap2.default({
	        faceRangeOffsets: results.faceRangeOffsets,
	        faceValueIndices: uvMapsNewIndices[i],
	        values: polyMesh.uvMaps.byName[name].values
	      });
	      uvMaps.set(name, uvMap);
	    }
	    results.uvMaps = uvMaps;
	  }
	
	  return results;
	};

/***/ },
/* 232 */
/*!******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeInvalidSurfaces.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeInvalidSurfaces;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _removeUnusedValues = __webpack_require__(/*! ../operator/removeUnusedValues */ 233);
	
	var _removeUnusedValues2 = _interopRequireDefault(_removeUnusedValues);
	
	var _applyFunctionToPolyMap = __webpack_require__(/*! ./applyFunctionToPolyMap */ 234);
	
	var _applyFunctionToPolyMap2 = _interopRequireDefault(_applyFunctionToPolyMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function removeInvalidSurfaces(polyMesh, withLogging) {
	
	  //this algorithm assumes no duplicate indices
	  //to remove those use removeDuplicateIndices first
	
	  function removeInvalidSurfacesFromMap(polyMap, polyMapName, additionalArguments) {
	    var l = additionalArguments.withLogging || false;
	
	    var faceRangeOffsets = new Uint32Array(polyMap.faceRangeOffsets);
	    var faceValueIndices = new Uint32Array(polyMap.faceValueIndices);
	    var values = polyMap.values;
	
	    var currentFaceIndex = 0;
	    var previousFaceIndex = 0;
	    var size = 0;
	
	    var newFacesMarker = 1;
	    var newIndicesMarker = 0;
	
	    for (var i = 1; i < faceRangeOffsets.length; i++) {
	
	      currentFaceIndex = faceRangeOffsets[i];
	      size = currentFaceIndex - previousFaceIndex;
	
	      if (size > 2) {
	        //store face
	        faceRangeOffsets[newFacesMarker] = faceRangeOffsets[newFacesMarker - 1] + size;
	        newFacesMarker++;
	
	        //store all the indices on that face
	        for (var j = 0; j < size; j++) {
	          faceValueIndices[newIndicesMarker++] = faceValueIndices[previousFaceIndex + j];
	        }
	      } else if (l) {
	        console.log('Removed face ' + i + ' of size ' + size);
	      }
	      previousFaceIndex = currentFaceIndex;
	    }
	
	    var newFaceRangeOffsets = new Uint32Array(faceRangeOffsets.subarray(0, newFacesMarker));
	    var newFaceValueIndices = new Uint32Array(faceValueIndices.subarray(0, newIndicesMarker));
	
	    var resultMap = new _PolyMap2.default({
	      faceRangeOffsets: newFaceRangeOffsets,
	      faceValueIndices: newFaceValueIndices,
	      values: values
	    });
	    return resultMap;
	  }
	
	  var args = { withLogging: withLogging };
	  var resultMesh = (0, _applyFunctionToPolyMap2.default)(polyMesh, removeInvalidSurfacesFromMap, args);
	
	  if (withLogging) console.log('' + (polyMesh.faceRangeOffsets.length - 1) + ' faces reduced to ' + (resultMesh.faceRangeOffsets.length - 1) + ', faces removed: ' + (polyMesh.faceRangeOffsets.length - resultMesh.faceRangeOffsets.length));
	
	  return (0, _removeUnusedValues2.default)(resultMesh);
	}

/***/ },
/* 233 */
/*!***************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/removeUnusedValues.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeUnusedValues;
	
	var _map = __webpack_require__(/*! babel-runtime/core-js/map */ 217);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function removeUnusedValues(polyMesh, withLogging) {
	
	  var l = withLogging || false;
	
	  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
	  var values = polyMesh.positions.values;
	
	  var newValues = new _ObjectArrayView2.default(_three2.default.Vector3, values.length);
	
	  var valueMappings = new _map2.default();
	  var newValuesLength = 0;
	
	  var newIndex = 0;
	  var value = new _three2.default.Vector3();
	
	  for (var i = 0; i < faceValueIndices.length; i++) {
	    if (!valueMappings.has(faceValueIndices[i])) {
	      valueMappings.set(faceValueIndices[i], newValuesLength);
	      newIndex = newValuesLength;
	      values.getAt(faceValueIndices[i], value);
	      newValues.setAt(newValuesLength, value);
	      newValuesLength++;
	    } else {
	      newIndex = valueMappings.get(faceValueIndices[i]);
	    }
	
	    faceValueIndices[i] = newIndex;
	  }
	
	  if (l) console.log('' + values.length + ' values reduced to ' + newValuesLength + ', unused values removed: ' + (values.length - newValuesLength));
	
	  if (values.length === newValuesLength) return polyMesh;
	
	  var newValuesArray = new _ObjectArrayView2.default(_three2.default.Vector3, newValuesLength);
	  newValuesArray.fromArray(newValues.toArray());
	
	  var newPositions = new _PolyMap2.default({
	    faceRangeOffsets: polyMesh.faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: newValuesArray
	  });
	
	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.positions = newPositions;
	
	  return resultMesh;
	};

/***/ },
/* 234 */
/*!*******************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/applyFunctionToPolyMap.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = applyFunctionToPolyMap;
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function applyFunctionToPolyMap(polyMesh, applyToPolyMapFunction, additionalArguments) {
	  var args = additionalArguments || {};
	
	  var resultMesh = new _PolyMesh2.default(polyMesh);
	  resultMesh.positions = applyToPolyMapFunction(resultMesh.positions, 'positions', args);
	  if (resultMesh.normalMap) resultMesh.normalMap = applyToPolyMapFunction(resultMesh.normalMap, 'normalMap', args);
	
	  var uvMaps = new _ObjectsByName2.default();
	  for (var i = 0; i < polyMesh.uvMaps.length; i++) {
	    var name = polyMesh.uvMaps.namesByIndex[i];
	    var uvMap = applyToPolyMapFunction(polyMesh.uvMaps.byName[name], name, args);
	    uvMaps.set(name, uvMap);
	  }
	  resultMesh.uvMaps = uvMaps;
	  resultMesh.faceRangeOffsets = resultMesh.positions.faceRangeOffsets;
	
	  return resultMesh;
	};

/***/ },
/* 235 */
/*!****************************************!*\
  !*** ./src/operators/PolyMesh/Cone.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Cone = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Cone */ 236);
	
	var _Cone2 = _interopRequireDefault(_Cone);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Cone = {
	  schema: {
	    base: { type: 'Number', label: 'Base Radius', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    height: { type: 'Number', label: 'Height', defaultValue: 1, minValue: 0.0, step: 0.1, animatable: true },
	    radiusSegments: { label: 'Radial Segments', type: 'Integer', defaultValue: 12, minValue: 3, maxValue: 200, animatable: true },
	    heightSegments: { label: 'Height Segments', type: 'Integer', defaultValue: 1, minValue: 1, maxValue: 200, animatable: true },
	    openEnded: { label: 'Open Base', type: 'Boolean', defaultValue: false, animatable: true }
	  },
	
	  update: function update(operator, primitive) {
	    var base = operator.base;
	    var height = operator.height;
	    var radiusSegments = operator.radiusSegments;
	    var heightSegments = operator.heightSegments;
	
	    primitive.mesh = (0, _Cone2.default)(base, radiusSegments, height);
	  }
	};
	
	exports.default = Cone;

/***/ },
/* 236 */
/*!***************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Cone.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Cone;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _Lathe = __webpack_require__(/*! ./Lathe */ 229);
	
	var _Lathe2 = _interopRequireDefault(_Lathe);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Cone(radius, segments, height, thetaStart, thetaLength) {
	
	  radius = radius || 50;
	
	  segments = Math.max(1, Math.floor(segments || 8));
	  var segmentLength = radius / segments;
	  var heightSegmentLength = height / segments;
	
	  thetaStart = _three2.default.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = _three2.default.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);
	
	  var points = new _ObjectArrayView2.default(_three2.default.Vector3, (segments + 1) * 2);
	  var norms = new _ObjectArrayView2.default(_three2.default.Vector3, (segments + 1) * 2);
	  var normPt = new _three2.default.Vector3(0, -1, 0);
	  var pt = new _three2.default.Vector3();
	
	  for (var i = 0, il = segments; i <= il; i++) {
	
	    pt.set(i * segmentLength, -height / 2, 0);
	
	    points.setAt(i, pt);
	    norms.setAt(i, normPt);
	  }
	
	  normPt.set(height, radius, 0);
	  normPt.normalize();
	  for (var i = 0, il = segments; i <= il; i++) {
	
	    pt.set(radius - i * segmentLength, i * heightSegmentLength - height / 2, 0);
	
	    points.setAt(segments + 1 + i, pt);
	    norms.setAt(segments + 1 + i, normPt);
	  }
	
	  var latheSegments = segments < 3 ? 3 : segments;
	  return (0, _Lathe2.default)(points, norms, latheSegments, thetaStart, thetaLength);
	}

/***/ },
/* 237 */
/*!*******************************************!*\
  !*** ./src/operators/PolyMesh/Capsule.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Capsule = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Capsule */ 238);
	
	var _Capsule2 = _interopRequireDefault(_Capsule);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Capsule = {
	  schema: {
	    radius: { type: 'Number', label: 'Radius', defaultValue: 0.5, minValue: 0.1, step: 0.1 },
	    height: { type: 'Number', label: 'Height', defaultValue: 1, minValue: 0.1, step: 0.1 },
	    radiusSegments: { label: 'Radial Segments', type: 'Integer', defaultValue: 12, minValue: 4, maxValue: 100 },
	    heightSegments: { label: 'Height Segments', type: 'Integer', defaultValue: 10, minValue: 1, maxValue: 100 }
	  },
	
	  update: function update(operator, primitive) {
	    var radius = operator.radius;
	    var height = operator.height;
	    var radiusSegments = operator.radiusSegments;
	    var heightSegments = operator.heightSegments;
	
	    primitive.mesh = (0, _Capsule2.default)(radius, height, radiusSegments, heightSegments);
	  }
	};
	
	exports.default = Capsule;

/***/ },
/* 238 */
/*!******************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Capsule.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Capsule;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _Lathe = __webpack_require__(/*! ./Lathe */ 229);
	
	var _Lathe2 = _interopRequireDefault(_Lathe);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Capsule(radius, height, radialSegments, heightSegments, thetaStart, thetaLength) {
	
	  radius = radius !== undefined ? radius : 20;
	  height = height !== undefined ? height : 100;
	
	  radialSegments = Math.max(1, Math.floor(radialSegments || 8));
	  heightSegments = Math.max(1, Math.floor(heightSegments || 8));
	
	  thetaStart = _three2.default.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = _three2.default.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);
	
	  var heightSegmentLength = height / heightSegments;
	  var halfHeight = height / 2;
	  var inverseRadialSegments = 1 / radialSegments;
	
	  var points = new _ObjectArrayView2.default(_three2.default.Vector3, heightSegments + 1 + (radialSegments + 1) * 2);
	  var norms = new _ObjectArrayView2.default(_three2.default.Vector3, heightSegments + 1 + (radialSegments + 1) * 2);
	  var pt = new _three2.default.Vector3();
	  var normPt = new _three2.default.Vector3();
	
	  //top
	  for (var i = 0, il = radialSegments; i <= il; i++) {
	
	    var theta = i * (Math.PI / 2) * inverseRadialSegments;
	
	    pt.set(radius * Math.sin(theta), -radius * Math.cos(theta) - halfHeight, 0);
	
	    normPt.set(Math.sin(theta), -Math.cos(theta), 0);
	
	    points.setAt(i, pt);
	    norms.setAt(i, normPt.normalize());
	  }
	
	  //body
	  normPt.set(1, 0, 0);
	  for (var i = 0, il = heightSegments; i <= il; i++) {
	
	    pt.set(radius, i * heightSegmentLength - halfHeight, 0);
	
	    points.setAt(i + radialSegments + 1, pt);
	    norms.setAt(i + radialSegments + 1, normPt);
	  }
	
	  //bottom
	  for (var i = 0, il = radialSegments; i <= il; i++) {
	
	    var theta = Math.PI / 2 + i * (Math.PI / 2) * inverseRadialSegments;
	
	    pt.set(radius * Math.sin(theta), -radius * Math.cos(theta) + halfHeight, 0);
	
	    normPt.set(Math.sin(theta), -Math.cos(theta), 0);
	
	    points.setAt(i + radialSegments + heightSegments + 2, pt);
	    norms.setAt(i + radialSegments + heightSegments + 2, normPt.normalize());
	  }
	
	  var latheSegments = radialSegments < 3 ? 3 : radialSegments;
	  return (0, _Lathe2.default)(points, norms, latheSegments, thetaStart, thetaLength);
	}

/***/ },
/* 239 */
/*!********************************************!*\
  !*** ./src/operators/PolyMesh/Cylinder.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Cylinder = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Cylinder */ 240);
	
	var _Cylinder2 = _interopRequireDefault(_Cylinder);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Cylinder = {
	  schema: {
	    radiusTop: { type: 'Number', label: 'Top Radius', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    radiusBottom: { type: 'Number', label: 'Bottom Radius', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    height: { type: 'Number', label: 'Height', defaultValue: 1, minValue: 0.0, step: 0.1, animatable: true },
	    radiusSegments: { label: 'Radial Segments', type: 'Integer', defaultValue: 24, minValue: 3, maxValue: 200, animatable: true },
	    heightSegments: { label: 'Height Segments', type: 'Integer', defaultValue: 1, minValue: 1, maxValue: 200, animatable: true },
	    openEnded: { label: 'Open Ended', type: 'Boolean', defaultValue: false, animatable: true }
	  },
	
	  update: function update(operator, primitive) {
	    var radiusTop = operator.radiusTop;
	    var radiusBottom = operator.radiusBottom;
	    var height = operator.height;
	    var radiusSegments = operator.radiusSegments;
	    var heightSegments = operator.heightSegments;
	    var openEnded = operator.openEnded;
	
	    primitive.mesh = (0, _Cylinder2.default)(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded);
	  }
	};
	
	exports.default = Cylinder;

/***/ },
/* 240 */
/*!*******************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Cylinder.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Cylinder;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _Lathe = __webpack_require__(/*! ./Lathe */ 229);
	
	var _Lathe2 = _interopRequireDefault(_Lathe);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Cylinder(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
	
	  radiusTop = radiusTop !== undefined ? radiusTop : 20;
	  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	  height = height !== undefined ? height : 100;
	
	  openEnded = openEnded || false;
	
	  radialSegments = Math.max(1, Math.floor(radialSegments || 8));
	  heightSegments = Math.max(1, Math.floor(heightSegments || 8));
	
	  thetaStart = _three2.default.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = _three2.default.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);
	
	  var heightSegmentLength = height / heightSegments;
	  var halfHeight = height / 2;
	  var slope = (radiusBottom - radiusTop) / height;
	
	  var radialSegmentsLengthTop = radiusTop / radialSegments;
	  var radialSegmentsLengthBottom = radiusBottom / radialSegments;
	
	  var points = undefined;
	  var norms = undefined;
	
	  if (openEnded) {
	    points = new _ObjectArrayView2.default(_three2.default.Vector3, heightSegments + 1);
	    norms = new _ObjectArrayView2.default(_three2.default.Vector3, heightSegments + 1);
	  } else {
	    points = new _ObjectArrayView2.default(_three2.default.Vector3, heightSegments + 1 + (radialSegments + 1) * 2);
	    norms = new _ObjectArrayView2.default(_three2.default.Vector3, heightSegments + 1 + (radialSegments + 1) * 2);
	  }
	
	  var pt = new _three2.default.Vector3();
	  var normPt = new _three2.default.Vector3(0, -1, 0);
	
	  if (!openEnded) {
	    //top
	    for (var i = 0, il = radialSegments; i <= il; i++) {
	
	      pt.set(i * radialSegmentsLengthTop, -1 * halfHeight, 0);
	      points.setAt(i, pt);
	      norms.setAt(i, normPt);
	    }
	  }
	
	  //body
	  normPt.set(height, radiusTop - radiusBottom, 0);
	  normPt.normalize();
	  for (var i = 0, il = heightSegments; i <= il; i++) {
	
	    pt.set(slope * i * heightSegmentLength + radiusTop, i * heightSegmentLength - halfHeight, 0);
	
	    if (openEnded) {
	      points.setAt(i, pt);
	      norms.setAt(i, normPt);
	    } else {
	      points.setAt(i + radialSegments + 1, pt);
	      norms.setAt(i + radialSegments + 1, normPt);
	    }
	  }
	
	  if (!openEnded) {
	    //bottom
	    normPt.set(0, 1, 0);
	
	    for (var i = 0, il = radialSegments; i <= il; i++) {
	
	      pt.set(radiusBottom - i * radialSegmentsLengthBottom, 1 * halfHeight, 0);
	      points.setAt(i + radialSegments + heightSegments + 2, pt);
	      norms.setAt(i + radialSegments + heightSegments + 2, normPt);
	    }
	  }
	
	  var latheSegments = radialSegments < 3 ? 3 : radialSegments;
	  return (0, _Lathe2.default)(points, norms, latheSegments, thetaStart, thetaLength);
	}

/***/ },
/* 241 */
/*!*****************************************!*\
  !*** ./src/operators/PolyMesh/Plane.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Plane = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Plane */ 242);
	
	var _Plane2 = _interopRequireDefault(_Plane);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Plane = {
	  schema: {
	    width: { label: 'Width', type: 'Number', defaultValue: 4, minValue: 0.0, step: 0.1, animatable: true },
	    height: { label: 'Height', type: 'Number', defaultValue: 4, minValue: 0.0, step: 0.1, animatable: true },
	    widthSegments: { type: 'Number', label: 'Width Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true },
	    heightSegments: { type: 'Number', label: 'Height Segments', defaultValue: 1, minValue: 1, isInteger: true, animatable: true }
	  },
	
	  update: function update(operator, primitive) {
	    var width = operator.width;
	    var height = operator.height;
	    var widthSegments = operator.widthSegments;
	    var heightSegments = operator.heightSegments;
	
	    primitive.mesh = (0, _Plane2.default)(width, height, widthSegments, heightSegments);
	  }
	};
	
	exports.default = Plane;

/***/ },
/* 242 */
/*!****************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Plane.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Plane;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _ObjectsByName = __webpack_require__(/*! ../../generic/container/ObjectsByName */ 178);
	
	var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);
	
	var _PolyMesh = __webpack_require__(/*! ../model/PolyMesh */ 186);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Plane(width, height, widthSegments, heightSegments) {
	
	  widthSegments = Math.floor(widthSegments);
	  heightSegments = Math.floor(heightSegments);
	
	  var faceRangeOffsets = new Uint32Array(widthSegments * heightSegments + 1);
	  var faceValueIndices = new Uint32Array(widthSegments * heightSegments * 4);
	  var values = new _ObjectArrayView2.default(_three2.default.Vector3, (widthSegments + 1) * (heightSegments + 1));
	  var normals = new _ObjectArrayView2.default(_three2.default.Vector3, (widthSegments + 1) * (heightSegments + 1));
	  var uvValues = new _ObjectArrayView2.default(_three2.default.Vector2, (widthSegments + 1) * (heightSegments + 1));
	
	  var segment_width = width / widthSegments;
	  var segment_height = height / heightSegments;
	
	  var width_half = width / 2;
	  var height_half = height / 2;
	
	  var iz = undefined,
	      ix = undefined;
	
	  var newValue = new _three2.default.Vector3();
	  var newNormal = new _three2.default.Vector3(0, 1, 0);
	  var newUV = new _three2.default.Vector2();
	
	  //populate FaceRangeOffsets
	  for (iz = 0, ix = 0; iz < faceRangeOffsets.length; iz++, ix += 4) {
	    faceRangeOffsets[iz] = ix; //0 4 8 12 16 20 ...
	  }
	
	  //populate faceValueIndices
	  for (iz = 0; iz < heightSegments; iz++) {
	    for (ix = 0; ix < widthSegments; ix++) {
	      faceValueIndices[(iz * widthSegments + ix) * 4] = iz * (widthSegments + 1) + ix;
	      faceValueIndices[(iz * widthSegments + ix) * 4 + 1] = iz * (widthSegments + 1) + ix + 1;
	      faceValueIndices[(iz * widthSegments + ix) * 4 + 2] = (iz + 1) * (widthSegments + 1) + ix + 1;
	      faceValueIndices[(iz * widthSegments + ix) * 4 + 3] = (iz + 1) * (widthSegments + 1) + ix;
	    }
	  }
	
	  //populate values, normals, and uv values
	  for (iz = 0; iz < heightSegments + 1; iz++) {
	
	    //calculate z coord
	    var z = iz * segment_height - height_half;
	
	    for (ix = 0; ix < widthSegments + 1; ix++) {
	      //calculate x coord
	      var x = ix * segment_width - width_half;
	
	      //set value
	      newValue.set(x, 0, -z);
	      values.setAt(iz * (widthSegments + 1) + ix, newValue);
	
	      //set normal
	      normals.setAt(iz * (widthSegments + 1) + ix, newNormal);
	
	      //set uv value
	      newUV.set(ix / widthSegments, iz / heightSegments);
	      uvValues.setAt(iz * (widthSegments + 1) + ix, newUV);
	    }
	  }
	
	  var positionsMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: values
	  });
	
	  var normalMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: normals
	  });
	
	  var uvMap = new _PolyMap2.default({
	    faceRangeOffsets: faceRangeOffsets,
	    faceValueIndices: faceValueIndices,
	    values: uvValues
	  });
	
	  var uvMapsByName = new _ObjectsByName2.default();
	  var name = "default";
	  uvMapsByName.set(name, uvMap);
	
	  var polyMesh = new _PolyMesh2.default();
	  polyMesh.faceRangeOffsets = faceRangeOffsets;
	  polyMesh.positions = positionsMap;
	  polyMesh.normalMap = normalMap;
	  polyMesh.uvMaps = uvMapsByName;
	
	  return polyMesh;
	};

/***/ },
/* 243 */
/*!*****************************************!*\
  !*** ./src/operators/PolyMesh/Torus.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Torus = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Torus */ 244);
	
	var _Torus2 = _interopRequireDefault(_Torus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Torus = {
	  schema: {
	    radius: { label: 'Radius', type: 'Number', defaultValue: 0.3, minValue: 0.0, step: 0.1, animatable: true },
	    tube: { label: 'Tube Radius', type: 'Number', defaultValue: 0.2, minValue: 0.0, step: 0.1, animatable: true },
	    radialSegments: { label: 'Longitudinal Segments', type: 'Integer', defaultValue: 24, minValue: 3, step: 1, animatable: true },
	    tubularSegments: { label: 'Latitudinal Segments', type: 'Integer', defaultValue: 24, minValue: 3, step: 1, animatable: true },
	    phiStart: { label: 'Phi Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    phiLength: { label: 'Phi Length', type: 'Number', defaultValue: 360, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    thetaStart: { label: 'Theta Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    thetaLength: { label: 'Theta Length', type: 'Number', defaultValue: 360, minValue: 0, maxValue: 360, step: 10, animatable: true }
	  },
	
	  update: function update(operator, primitive) {
	    var radius = operator.radius;
	    var tube = operator.tube;
	    var radialSegments = operator.radialSegments;
	    var tubularSegments = operator.tubularSegments;
	    var phiStart = operator.phiStart;
	    var phiLength = operator.phiLength;
	    var thetaStart = operator.thetaStart;
	    var thetalength = operator.thetalength;
	
	    primitive.mesh = (0, _Torus2.default)(radius, tube, radialSegments, tubularSegments, phiStart, phiLength, thetaStart, thetalength);
	  }
	};
	
	exports.default = Torus;

/***/ },
/* 244 */
/*!****************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Torus.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Torus;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _Lathe = __webpack_require__(/*! ./Lathe */ 229);
	
	var _Lathe2 = _interopRequireDefault(_Lathe);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Torus(radius, tube, radialSegments, tubularSegments, phiStart, phiLength, thetaStart, thetaLength) {
	
	  radialSegments = Math.floor(radialSegments) || 1;
	  tubularSegments = Math.floor(tubularSegments) || 1;
	
	  radius = radius || 100;
	  tube = tube || 40;
	
	  radialSegments = Math.max(radialSegments || 8, 3);
	  tubularSegments = Math.max(tubularSegments || 6, 3);
	
	  phiStart = _three2.default.Math.clamp(phiStart || 0, 0, Math.PI * 2);
	  phiLength = _three2.default.Math.clamp(phiLength || Math.PI * 2, 0, Math.PI * 2 - phiStart);
	
	  thetaStart = _three2.default.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = _three2.default.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);
	
	  var inverseTubularSegments = 1.0 / tubularSegments;
	  var points = new _ObjectArrayView2.default(_three2.default.Vector3, tubularSegments + 1);
	  var norms = new _ObjectArrayView2.default(_three2.default.Vector3, tubularSegments + 1);
	  var pt = new _three2.default.Vector3();
	  var normPt = new _three2.default.Vector3();
	
	  for (var i = 0, il = tubularSegments; i <= il; i++) {
	
	    var theta = thetaStart + i * inverseTubularSegments * thetaLength;
	
	    pt.set(radius + tube * Math.cos(theta), tube * Math.sin(theta), 0);
	
	    normPt.set(Math.cos(theta), Math.sin(theta), 0);
	
	    points.setAt(i, pt);
	    norms.setAt(i, normPt.normalize());
	  }
	
	  return (0, _Lathe2.default)(points, norms, radialSegments, phiStart, phiLength);
	};

/***/ },
/* 245 */
/*!****************************************!*\
  !*** ./src/operators/PolyMesh/Disk.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Disk = __webpack_require__(/*! ../../polyMesh/geometric/primitives/Disk */ 246);
	
	var _Disk2 = _interopRequireDefault(_Disk);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Disk = {
	  schema: {
	    radius: { type: 'Number', label: 'Radius', defaultValue: 0.5, minValue: 0.0, step: 0.1, animatable: true },
	    segments: { type: 'Integer', label: 'Segments', defaultValue: 12, minValue: 3, maxValue: 200, animatable: true },
	    thetaStart: { label: 'Theta Start', type: 'Number', defaultValue: 0, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    thetaLength: { label: 'Theta Length', type: 'Number', defaultValue: 360, minValue: 0, maxValue: 360, step: 10, animatable: true },
	    removeDuplicate: { label: 'Remove Duplicate Vertices', type: 'Boolean', defaultValue: false, hidden: true }
	  },
	
	  update: function update(operator, primitive) {
	    var radius = operator.radius;
	    var segments = operator.segments;
	    var thetaStart = operator.thetaStart;
	    var thetaLength = operator.thetaLength;
	
	    primitive.mesh = (0, _Disk2.default)(radius, segments, thetaStart, thetaLength);
	  }
	};
	
	exports.default = Disk;

/***/ },
/* 246 */
/*!***************************************************!*\
  !*** ./src/polyMesh/geometric/primitives/Disk.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Disk;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ObjectArrayView = __webpack_require__(/*! ../../generic/container/ObjectArrayView */ 163);
	
	var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);
	
	var _Lathe = __webpack_require__(/*! ./Lathe */ 229);
	
	var _Lathe2 = _interopRequireDefault(_Lathe);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Disk(radius, segments, thetaStart, thetaLength) {
	
	  radius = radius || 50;
	
	  segments = Math.max(1, Math.floor(segments || 8));
	  var segmentLength = radius / segments;
	
	  thetaStart = _three2.default.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
	  thetaLength = _three2.default.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);
	
	  var points = new _ObjectArrayView2.default(_three2.default.Vector3, segments + 1);
	  var norms = new _ObjectArrayView2.default(_three2.default.Vector3, segments + 1);
	  var normPt = new _three2.default.Vector3(0, 1, 0);
	  var pt = new _three2.default.Vector3();
	
	  for (var i = 0, il = segments; i <= il; i++) {
	
	    pt.set(radius - i * segmentLength, 0, 0);
	
	    points.setAt(i, pt);
	    norms.setAt(i, normPt);
	  }
	
	  var latheSegments = segments < 3 ? 3 : segments;
	  return (0, _Lathe2.default)(points, norms, latheSegments, thetaStart, thetaLength);
	}

/***/ },
/* 247 */
/*!*********************************************!*\
  !*** ./src/operators/PolyMesh/ProxyMesh.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _bingeom = __webpack_require__(/*! ../../translators/bingeom */ 154);
	
	var _assets = __webpack_require__(/*! ../../modules/assets */ 144);
	
	var ProxyMesh = {
	  schema: {
	    binary: { type: 'Binary', label: 'Binary Geometry File' },
	    reducedBinary: { type: 'Binary', label: 'Reduced Binary Geometry File' },
	    operatorDisplay: { type: "Number", defaultValue: 1, label: 'Operator Display Type' },
	    nbLevel: { type: "Number", defaultValue: 1 }, // 1 -> only binary, 2 -> level0 and binary, 3 -> level0, level1, binary, ....
	    level0: { type: 'Binary', label: 'Binary Geometry File' },
	    level1: { type: 'Binary', label: 'Binary Geometry File' },
	    level2: { type: 'Binary', label: 'Binary Geometry File' },
	    level3: { type: 'Binary', label: 'Binary Geometry File' },
	    level4: { type: 'Binary', label: 'Binary Geometry File' }
	  },
	
	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;
	    var store = _ref.store;
	    var properties = _ref.properties;
	    var previousResult = _ref.previousResult;
	    var loaded = _ref.loaded;
	
	    var visible = properties.visible;
	    var binary = operator.binary;
	    var fetch = visible || properties.prefetch && loaded;
	    var bingeom = fetch && binary && store.hasApi() && (0, _assets.getOrFetchBinary)(binary)(store);
	    var mesh = bingeom && (0, _bingeom.convertToCNSPolyMesh)(bingeom, binary);
	    //console.log('Mesh update', 'visible:', visible, 'prefetch:', properties.prefetch, 'fetch:', fetch, 'bingeom:', !!bingeom, node.name, mesh);
	    primitive.mesh = mesh;
	    primitive.previousMesh = previousResult && previousResult.mesh;
	  }
	};
	
	exports.default = ProxyMesh;

/***/ },
/* 248 */
/*!********************************************!*\
  !*** ./src/operators/PolyMesh/Instance.js ***!
  \********************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Instance = {
	  schema: {
	    geometry: { label: "Mesh", plug: 'PolyMesh', type: "Plug" }
	  },
	
	  update: function update(operator, primitive) {
	    primitive.mesh = operator.geometry && operator.geometry.mesh;
	  }
	};
	
	exports.default = Instance;

/***/ },
/* 249 */
/*!***************************************************!*\
  !*** ./src/operators/PolyMesh/SortFacesByAxis.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _sortFacesByAxis = __webpack_require__(/*! ../../polyMesh/geometric/operator/sortFacesByAxis */ 250);
	
	var _sortFacesByAxis2 = _interopRequireDefault(_sortFacesByAxis);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SortFacesByAxis = {
	  schema: {
	    axis: { label: 'Direction', type: 'Vec3', step: 0.1, defaultValue: { x: 1, y: 1, z: 0 }, animatable: true }
	  },
	
	  update: function update(operator, primitive, _ref) {
	    var store = _ref.store;
	
	    //using an import from player.js for getThreeCamera for some reason wipes the active camera
	    //const camera =  store.getIn(['player','threeCamera']);
	    //const cameraWorldMatrix = camera.matrix;
	    var axis = operator.axis.normalize();
	
	    //does not account for the local space of an object
	    //const cameraDirection = new THREE.Vector3(0,0,-1);
	    //cameraDirection.transformDirection(cameraWorldMatrix);
	
	    var polyMesh = primitive.mesh;
	    primitive.mesh = (0, _sortFacesByAxis2.default)(polyMesh, axis);
	  }
	};
	
	exports.default = SortFacesByAxis;

/***/ },
/* 250 */
/*!************************************************************!*\
  !*** ./src/polyMesh/geometric/operator/sortFacesByAxis.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = sortFacesByAxis;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _PolyMap = __webpack_require__(/*! ../model/PolyMap */ 179);
	
	var _PolyMap2 = _interopRequireDefault(_PolyMap);
	
	var _applyFunctionToPolyMap = __webpack_require__(/*! ./applyFunctionToPolyMap */ 234);
	
	var _applyFunctionToPolyMap2 = _interopRequireDefault(_applyFunctionToPolyMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function sortFacesByAxis(polyMesh, axis, withLogging) {
	
	  function reorderFacesOnPolymap(polyMap, polyMapName, additionalArguments) {
	    var newFaceRangeOffsets = additionalArguments.newFaceRangeOffsets;
	    var reMapping = additionalArguments.reMapping;
	
	    var faceRangeOffsets = polyMap.faceRangeOffsets;
	    var faceValueIndices = polyMap.faceValueIndices;
	    var newFaceValueIndices = new Uint32Array(faceValueIndices.length);
	    var newFaceValueIndicesMarker = 0;
	
	    for (var i = 0; i < reMapping.length; i++) {
	      for (var j = faceRangeOffsets[reMapping[i]]; j < faceRangeOffsets[reMapping[i] + 1]; j++) {
	        newFaceValueIndices[newFaceValueIndicesMarker++] = faceValueIndices[j];
	      }
	    }
	
	    var newPolyMap = new _PolyMap2.default({
	      faceRangeOffsets: newFaceRangeOffsets,
	      faceValueIndices: newFaceValueIndices,
	      values: polyMap.values
	    });
	
	    return newPolyMap;
	  };
	
	  var l = withLogging || false;
	  if (!axis || !polyMesh) return polyMesh;
	  if (axis.x === 0 && axis.y === 0 && axis.z === 0) return polyMesh;
	
	  var faceRangeOffsets = polyMesh.faceRangeOffsets;
	  var newFaceRangeOffsets = new Uint32Array(polyMesh.faceRangeOffsets.length);
	  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
	  var values = polyMesh.positions.values;
	
	  //create a mapping for the faces (0, 1, 2, 3, 4...)
	  var faces = [];
	  var faceDistances = [];
	
	  var centroid = new _three2.default.Vector3();
	  var tempValue = new _three2.default.Vector3();
	
	  for (var i = 0; i < faceRangeOffsets.length - 1; i++) {
	    faces[i] = i;
	
	    var faceStart = faceRangeOffsets[i];
	    var faceEnd = faceRangeOffsets[i + 1];
	
	    centroid.set(0, 0, 0);
	    for (var j = faceStart; j < faceEnd; j++) {
	      values.getAt(faceValueIndices[j], tempValue);
	      centroid.add(tempValue);
	    }
	    centroid.multiplyScalar(1 / (faceEnd - faceStart));
	
	    //projection of v1 and v2 on camera axis compare magnitudes
	    faceDistances[i] = centroid.dot(axis);
	  }
	
	  //sort the face mapping by the values of their indices
	  faces.sort(function (a, b) {
	    return faceDistances[b] - faceDistances[a];
	  });
	
	  for (var i = 0; i < faces.length; i++) {
	    newFaceRangeOffsets[i + 1] = newFaceRangeOffsets[i] + (faceRangeOffsets[faces[i] + 1] - faceRangeOffsets[faces[i]]);
	  }
	
	  if (l) {
	    //print out all the faces to compare old and new
	    console.log('Face List [old][new]:');
	    for (var i = 0; i < faces.length; i++) {
	      var face = [];
	      var newFace = [];
	      for (var j = faceRangeOffsets[i]; j < faceRangeOffsets[i + 1]; j++) {
	        face.push(faceValueIndices[j]);
	      }
	      for (var j = faceRangeOffsets[faces[i]]; j < faceRangeOffsets[faces[i] + 1]; j++) {
	        newFace.push(faceValueIndices[j]);
	      }
	      console.log(face, newFace);
	    }
	  }
	
	  var args = { newFaceRangeOffsets: newFaceRangeOffsets, reMapping: faces };
	  return (0, _applyFunctionToPolyMap2.default)(polyMesh, reorderFacesOnPolymap, args);
	};

/***/ },
/* 251 */
/*!*************************************!*\
  !*** ./src/operators/Properties.js ***!
  \*************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PolyMeshProperties = {
	  schema: {
	    visible: { label: 'Visible', type: 'Boolean', defaultValue: true, animatable: true },
	    prefetch: { label: 'Pre-fetch mesh', type: 'Boolean', defaultValue: false }
	  }
	};
	
	var MaterialProperties = {
	  schema: {
	    prefetch: { label: 'Pre-fetch Material', type: 'Boolean', defaultValue: false }
	  }
	};
	
	var ImageProperties = {
	  schema: {
	    prefetch: { label: 'Pre-fetch Image', type: 'Boolean', defaultValue: false }
	  }
	};
	
	var Default = {
	  schema: {
	    visible: { label: 'Visible', type: 'Boolean', defaultValue: true, animatable: true }
	  }
	};
	
	exports.default = { Default: Default, PolyMeshProperties: PolyMeshProperties, MaterialProperties: MaterialProperties, ImageProperties: ImageProperties };

/***/ },
/* 252 */
/*!************************************!*\
  !*** ./src/operators/Transform.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _scene = __webpack_require__(/*! ../modules/scene */ 147);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Transform = {
	  schema: {
	    translation: { label: "Translation", type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    rotation: { label: "Rotation", type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    scale: { label: "Scale", type: 'Vec3', step: 0.01, defaultValue: { x: 1, y: 1, z: 1 }, animatable: true }, // Scale's step must be 0.01 as 1 percent
	    shear: { label: "Shear", type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    rotateOrder: { label: 'Rotate Order', type: 'Options', display: 'Dropdown',
	      values: ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'], defaultValue: 'ZYX' },
	    preRotation: { label: "Pre-Rotation", type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 } },
	    rotatePivotOffset: { label: "Rotate Pivot Offset", type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 } },
	    scalePivotOffset: { label: "Scale Pivot Offset", type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 } },
	    localRotatePivot: { label: "Local Rotate Pivot", type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 } },
	    localScalePivot: { label: "Local Scale Pivot", type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 } }
	  },
	
	  update: function update(operator, primitive) {
	    primitive.transform = (0, _scene.getLocalTransform)(operator);
	  }
	};
	
	var LookAt = {
	  schema: {
	    target: { label: 'LookAt Target', type: 'Plug', plug: 'Transform' },
	    orientation: { label: 'Orientation', type: 'Vec3', defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	
	    lookAtAxis: { label: 'Look Axis', type: 'Options', display: 'Dropdown', defaultValue: 'Z',
	      labels: ['X', 'Y', 'Z'], values: ['X', 'Y', 'Z'] },
	    flipLookAtAxis: { label: 'Flip Look Axis', type: 'Boolean', defaultValue: true },
	
	    upAxis: { label: 'Up Axis', type: 'Options', display: 'Dropdown', defaultValue: 'Y',
	      labels: ['X', 'Y', 'Z'], values: ['X', 'Y', 'Z'] },
	    flipUpAxis: { label: 'Flip Up Axis', type: 'Boolean', defaultValue: false }
	  }
	};
	
	var BoneTransform = {
	  schema: {
	    translation: { label: "Translation", type: 'Vec3', step: 0.1, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    rotation: { label: "Rotation", type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 }, animatable: true },
	    scale: { label: "Scale", type: 'Vec3', step: 0.1, defaultValue: { x: 1, y: 1, z: 1 }, animatable: true },
	    rotateOrder: { label: 'Rotate Order', type: 'Options', display: 'Dropdown',
	      values: ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'], defaultValue: 'ZYX' },
	    preRotation: { label: "Pre-Rotation", type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 } }, // hidden: true
	    rotateAxis: { label: "Rotate Axis", type: 'Vec3', step: 1.0, defaultValue: { x: 0, y: 0, z: 0 } }
	  },
	
	  update: function update(operator, primitive, _ref) {
	    var node = _ref.node;
	    var translation = operator.translation;
	    var rotation = operator.rotation;
	    var scale = operator.scale;
	    var rotateOrder = operator.rotateOrder;
	    var preRotation = operator.preRotation;
	    var rotateAxis = operator.rotateAxis;
	
	    if (scale.x === 0) scale.x = 0.0000001;
	    if (scale.y === 0) scale.y = 0.0000001;
	    if (scale.z === 0) scale.z = 0.0000001;
	
	    var translationM = new _three2.default.Matrix4().makeTranslation(translation.x, translation.y, translation.z);
	    var rotationRadians = new _three2.default.Vector3().copy(rotation).multiplyScalar(Math.PI / 180);
	    var rotationM = new _three2.default.Matrix4().makeRotationFromEuler(new _three2.default.Euler(rotationRadians.x, rotationRadians.y, rotationRadians.z, 'ZYX'));
	    var shearM = new _three2.default.Matrix4();
	    var scaleM = new _three2.default.Matrix4().makeScale(scale.x, scale.y, scale.z);
	
	    var preRotationRadians = new _three2.default.Vector3().copy(preRotation).multiplyScalar(Math.PI / 180);
	    var lPreRotationM = new _three2.default.Matrix4().makeRotationFromEuler(new _three2.default.Euler(preRotationRadians.x, preRotationRadians.y, preRotationRadians.z, 'ZYX'));
	
	    var rotateAxisRadians = new _three2.default.Vector3().copy(rotateAxis).multiplyScalar(Math.PI / 180);
	    var lPostRotationM = new _three2.default.Matrix4().makeRotationFromEuler(new _three2.default.Euler(rotateAxisRadians.x, rotateAxisRadians.y, rotateAxisRadians.z, 'ZYX'));
	
	    primitive.transform = new _three2.default.Matrix4().multiplyMatricesList([translationM, lPreRotationM, rotationM, lPostRotationM, scaleM]);
	  }
	
	};
	
	exports.default = { Transform: Transform, BoneTransform: BoneTransform, LookAt: LookAt };

/***/ },
/* 253 */
/*!************************************!*\
  !*** ./src/modules/actionTypes.js ***!
  \************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	// shared:
	//
	var LOAD_SCENE = exports.LOAD_SCENE = 'LOAD_SCENE';
	var ADD_NODE = exports.ADD_NODE = 'ADDNODE';
	var ADD_VR_CAMERA = exports.ADD_VR_CAMERA = 'ADD_VR_CAMERA';
	var SET_VR_CAMERA = exports.SET_VR_CAMERA = 'SET_VR_CAMERA';
	var DELETE_NODE = exports.DELETE_NODE = 'DELETE_NODE';
	var LOADING_FILE = exports.LOADING_FILE = 'LOADING_FILE';
	var LOADED_FILE = exports.LOADED_FILE = 'LOADED_FILE';
	var LOADING_FILE_ERROR = exports.LOADING_FILE_ERROR = 'LOADING_FILE_ERROR';

/***/ },
/* 254 */
/*!*********************************************!*\
  !*** ./src/modules/utils/evalSceneGraph.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.updateReferenceList = updateReferenceList;
	exports.updateReference = updateReference;
	exports.evaluateSceneGraph = evaluateSceneGraph;
	
	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 98);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 102);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 145);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _sceneIO = __webpack_require__(/*! ../sceneIO */ 255);
	
	var _nonImmutable = __webpack_require__(/*! ../../operators/nonImmutable */ 149);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var doLog = false;
	function log() {
	  var _console;
	
	  if (doLog) (_console = console).log.apply(_console, arguments);
	}
	
	function updateReferenceList(_ref, nodeId, plugName, opIdx, key, refs) {
	  var from = _ref.from;
	  var to = _ref.to;
	
	  var refKey = (0, _stringify2.default)([nodeId, plugName, opIdx, key]);
	  var existingRefs = to[refKey];
	  if (existingRefs) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = (0, _getIterator3.default)(existingRefs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var existingRefId = _step.value;
	
	        if (refs.indexOf(existingRefId) === -1) {
	          delete from[existingRefId][refKey];
	          if (!(0, _keys2.default)(from[existingRefId]).length) {
	            delete from[existingRefId];
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;
	
	  try {
	    for (var _iterator2 = (0, _getIterator3.default)(refs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var refId = _step2.value;
	
	      if (!from[refId]) from[refId] = {};
	      from[refId][refKey] = true;
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }
	
	  to[refKey] = refs;
	};
	
	//
	// refKey = JSON.stringify([nodeId,plugName,opIdx]);
	// from: { [fileId]:  refKey },
	// from: { [refId]:  { [refKey}: refPlug } }
	// to:  { [refKey]: fileId },
	//
	function updateReference(_ref2, nodeId, plugName, opIdx, key, refId, refPlug) {
	  var from = _ref2.from;
	  var to = _ref2.to;
	
	  var refKey = (0, _stringify2.default)([nodeId, plugName, opIdx, key]);
	  var existingRef = to[refKey];
	  if (existingRef) {
	    if (existingRef !== refId) {
	      delete from[existingRef][refKey];
	      if (refId) {
	        if (!from[refId]) from[refId] = {};
	        from[refId][refKey] = refPlug || true;
	        to[refKey] = refId;
	      } else {
	        if (!(0, _keys2.default)(from[existingRef]).length) {
	          delete from[existingRef];
	        }
	        delete to[refKey];
	      }
	    }
	  } else if (refId) {
	    if (!from[refId]) from[refId] = {};
	    from[refId][refKey] = refPlug || true;
	    to[refKey] = refId;
	  }
	};
	
	function evaluateSceneGraph(store, sceneId, sceneGraph) {
	  var start = new Date();
	  var i = 0;
	  var id = null;
	
	  var sceneNodeIds = (0, _keys2.default)(sceneGraph.nodes);
	  var evaluatedNodeIds = (0, _keys2.default)(sceneGraph.evaluatedNodes);
	  var _sceneGraph$nodeRefer = sceneGraph.nodeReferences;
	  var from = _sceneGraph$nodeRefer.from;
	  var to = _sceneGraph$nodeRefer.to;
	
	  // First evaluation after sceneGraph is loaded
	
	  var transitionToLoaded = !sceneGraph.loaded && (0, _sceneIO.isSceneLoaded)(store);
	  if (!sceneGraph.loaded) sceneGraph.loaded = transitionToLoaded;
	
	  var worldTransforms = {};
	  var toUpdate = {};
	  var toDelete = {};
	  var updating = {};
	  var nodeUpdates = {};
	
	  function getEvaluated(id, plug) {
	    if (updating[id] && !nodeUpdates[id]) {
	      console.error('Circular reference, updating', sceneGraph.nodes[id].name);
	      throw new Error('Circular reference: ' + id);
	    }
	    if (toUpdate[id] && !updating[id]) updateNode(id, toUpdate[id]);
	
	    //addReference(id, {id: nodeId, sourcePlug, destPlug}, toPlugKey(destPlug, opIndex, fromKey));
	    var result = nodeUpdates[id] || sceneGraph.evaluatedNodes[id];
	    if (plug) result = result && result[plug];
	    return result;
	  }
	
	  function getWorldTransform(id) {
	    if (worldTransforms[id]) return worldTransforms[id];
	
	    if (toUpdate[id] && !updating[id]) updateNode(id, toUpdate[id]);
	    var localTransform = getEvaluated(id, 'Transform');
	    if (!localTransform) return null;
	
	    var node = sceneGraph.nodes[id];
	    var parent = node && node.parent;
	    var parentTransform = parent && getWorldTransform(parent);
	
	    worldTransforms[id] = parentTransform ? new _three2.default.Matrix4().copy(parentTransform).multiply(localTransform.transform) : new _three2.default.Matrix4().copy(localTransform.transform);
	    return worldTransforms[id];
	  }
	
	  function updateNode(id, updatePlug) {
	    var node = sceneGraph.nodes[id];
	
	    var evalNode = sceneGraph.evaluatedNodes[id];
	    if (!evalNode) {
	      evalNode = sceneGraph.evaluatedNodes[id] = { name: node.name, _ev: 0, plugs: [] };
	      if (node.plugs.Properties) evalNode.plugs.push('Properties');
	      if (node.plugs.Transform) evalNode.plugs.push('Transform');
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;
	
	      try {
	        for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var plug = _step3.value;
	
	          if (plug !== 'Properties' && plug !== 'Transform') evalNode.plugs.push(plug);
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	    }
	    nodeUpdates[id] = evalNode;
	    //console.log('evaluateSceneGraph::updateNode', node.name, updatePlug);
	    updating[id] = true;
	
	    var nodeEvaluatedVersion = 0;
	
	    function doUpdatePlug(plug) {
	      //console.log('  - ', plug);
	      var ops = node.plugs[plug];
	      var previousResult = evalNode[plug];
	      var previousVersion = previousResult ? previousResult._v : 0;
	
	      evalNode[plug] = ops.reduce(function (result, op, idx) {
	
	        var operator = (0, _nonImmutable.lookupOperator)(plug, op.type, []);
	        var _iteratorNormalCompletion4 = true;
	        var _didIteratorError4 = false;
	        var _iteratorError4 = undefined;
	
	        try {
	          for (var _iterator4 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            var key = _step4.value;
	
	            updateReference(sceneGraph.fileReferences, id, plug, idx, key, op[key]);
	          }
	        } catch (err) {
	          _didIteratorError4 = true;
	          _iteratorError4 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	              _iterator4.return();
	            }
	          } finally {
	            if (_didIteratorError4) {
	              throw _iteratorError4;
	            }
	          }
	        }
	
	        var _iteratorNormalCompletion5 = true;
	        var _didIteratorError5 = false;
	        var _iteratorError5 = undefined;
	
	        try {
	          for (var _iterator5 = (0, _getIterator3.default)(operator.nodeReferenceKeys), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	            var key = _step5.value;
	
	            updateReference(sceneGraph.nodeReferences, id, plug, idx, key, op[key]);
	          }
	        } catch (err) {
	          _didIteratorError5 = true;
	          _iteratorError5 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion5 && _iterator5.return) {
	              _iterator5.return();
	            }
	          } finally {
	            if (_didIteratorError5) {
	              throw _iteratorError5;
	            }
	          }
	        }
	
	        var plugs = {};
	        var _iteratorNormalCompletion6 = true;
	        var _didIteratorError6 = false;
	        var _iteratorError6 = undefined;
	
	        try {
	          for (var _iterator6 = (0, _getIterator3.default)((0, _keys2.default)(operator.plugReferences)), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	            var key = _step6.value;
	
	            updateReference(sceneGraph.nodeReferences, id, plug, idx, key, op[key], operator.plugReferences[key]);
	            if (op[key]) plugs[key] = getEvaluated(op[key], operator.plugReferences[key]);
	          }
	        } catch (err) {
	          _didIteratorError6 = true;
	          _iteratorError6 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion6 && _iterator6.return) {
	              _iterator6.return();
	            }
	          } finally {
	            if (_didIteratorError6) {
	              throw _iteratorError6;
	            }
	          }
	        }
	
	        var _iteratorNormalCompletion7 = true;
	        var _didIteratorError7 = false;
	        var _iteratorError7 = undefined;
	
	        try {
	          for (var _iterator7 = (0, _getIterator3.default)(operator.nodeReferenceListKeys), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	            var key = _step7.value;
	
	            updateReferenceList(sceneGraph.nodeReferences, id, plug, idx, key, op[key]);
	          }
	        } catch (err) {
	          _didIteratorError7 = true;
	          _iteratorError7 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion7 && _iterator7.return) {
	              _iterator7.return();
	            }
	          } finally {
	            if (_didIteratorError7) {
	              throw _iteratorError7;
	            }
	          }
	        }
	
	        if (operator.environment) {
	          updateReference(sceneGraph.nodeReferences, id, plug, idx, 'environment', sceneId, 'Environment');
	          plugs.environment = getEvaluated(sceneId, 'Environment');
	        }
	
	        return operator.update((0, _assign2.default)({}, op, plugs), result, {
	          sceneId: sceneId,
	          node: node,
	          store: store,
	          properties: evalNode.Properties,
	          getWorldTransform: getWorldTransform,
	          previousResult: previousResult,
	          loaded: sceneGraph.loaded
	        });
	      }, {});
	
	      evalNode[plug]._v = previousVersion + 1;
	    }
	
	    var _iteratorNormalCompletion8 = true;
	    var _didIteratorError8 = false;
	    var _iteratorError8 = undefined;
	
	    try {
	      for (var _iterator8 = (0, _getIterator3.default)(evalNode.plugs), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	        var plug = _step8.value;
	
	        if (updatePlug === true || updatePlug === plug) doUpdatePlug(plug);
	        nodeEvaluatedVersion += evalNode[plug]._v;
	      }
	    } catch (err) {
	      _didIteratorError8 = true;
	      _iteratorError8 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion8 && _iterator8.return) {
	          _iterator8.return();
	        }
	      } finally {
	        if (_didIteratorError8) {
	          throw _iteratorError8;
	        }
	      }
	    }
	
	    evalNode._v = node._v;
	    evalNode._ev = nodeEvaluatedVersion;
	
	    delete updating[id];
	    delete toUpdate[id];
	  };
	
	  var _iteratorNormalCompletion9 = true;
	  var _didIteratorError9 = false;
	  var _iteratorError9 = undefined;
	
	  try {
	    for (var _iterator9 = (0, _getIterator3.default)(sceneNodeIds), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	      var _id = _step9.value;
	
	      if (!sceneGraph.evaluatedNodes[_id] || sceneGraph.evaluatedNodes[_id]._v !== sceneGraph.nodes[_id]._v) {
	        toUpdate[_id] = true;
	      }
	    }
	  } catch (err) {
	    _didIteratorError9 = true;
	    _iteratorError9 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion9 && _iterator9.return) {
	        _iterator9.return();
	      }
	    } finally {
	      if (_didIteratorError9) {
	        throw _iteratorError9;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion10 = true;
	  var _didIteratorError10 = false;
	  var _iteratorError10 = undefined;
	
	  try {
	    for (var _iterator10 = (0, _getIterator3.default)(evaluatedNodeIds), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	      var _id2 = _step10.value;
	
	      if (!sceneGraph.nodes[_id2]) {
	        toDelete[_id2] = true;
	      }
	    }
	  } catch (err) {
	    _didIteratorError10 = true;
	    _iteratorError10 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion10 && _iterator10.return) {
	        _iterator10.return();
	      }
	    } finally {
	      if (_didIteratorError10) {
	        throw _iteratorError10;
	      }
	    }
	  }
	
	  if (transitionToLoaded) {
	    var _iteratorNormalCompletion11 = true;
	    var _didIteratorError11 = false;
	    var _iteratorError11 = undefined;
	
	    try {
	      for (var _iterator11 = (0, _getIterator3.default)(sceneNodeIds), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
	        var _id3 = _step11.value;
	
	        var evalNode = sceneGraph.evaluatedNodes[_id3];
	        if (evalNode && evalNode.Properties && evalNode.Properties.prefetch) {
	          toUpdate[_id3] = sceneGraph.nodes[_id3].type;
	        }
	      }
	    } catch (err) {
	      _didIteratorError11 = true;
	      _iteratorError11 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion11 && _iterator11.return) {
	          _iterator11.return();
	        }
	      } finally {
	        if (_didIteratorError11) {
	          throw _iteratorError11;
	        }
	      }
	    }
	  }
	
	  function needsUpdateReference(refId, fromPlug) {
	    if (from[refId]) {
	      var _iteratorNormalCompletion12 = true;
	      var _didIteratorError12 = false;
	      var _iteratorError12 = undefined;
	
	      try {
	        for (var _iterator12 = (0, _getIterator3.default)((0, _keys2.default)(from[refId])), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
	          var refKey = _step12.value;
	
	          var refPlug = from[refId][refKey];
	
	          var _JSON$parse = JSON.parse(refKey);
	
	          var _JSON$parse2 = (0, _slicedToArray3.default)(_JSON$parse, 4);
	
	          var nodeId = _JSON$parse2[0];
	          var plugName = _JSON$parse2[1];
	          var opIdx = _JSON$parse2[2];
	          var key = _JSON$parse2[3];
	          //console.log(' - ref ', sceneGraph.nodes[nodeId].name, '-', plugName, '-', key, 'fromPlug: ', toUpdate[nodeId]);
	
	          if (!fromPlug || refPlug === true || refPlug === fromPlug) {
	            if (!toUpdate[nodeId]) {
	              toUpdate[nodeId] = plugName;
	              needsUpdateReference(nodeId, plugName);
	            } else if (toUpdate[nodeId] !== plugName) {
	              toUpdate[nodeId] = true;
	              needsUpdateReference(nodeId, plugName);
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError12 = true;
	        _iteratorError12 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion12 && _iterator12.return) {
	            _iterator12.return();
	          }
	        } finally {
	          if (_didIteratorError12) {
	            throw _iteratorError12;
	          }
	        }
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion13 = true;
	  var _didIteratorError13 = false;
	  var _iteratorError13 = undefined;
	
	  try {
	    for (var _iterator13 = (0, _getIterator3.default)((0, _keys2.default)(toUpdate)), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
	      var _id4 = _step13.value;
	
	      if (from[_id4]) needsUpdateReference(_id4);
	    }
	  } catch (err) {
	    _didIteratorError13 = true;
	    _iteratorError13 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion13 && _iterator13.return) {
	        _iterator13.return();
	      }
	    } finally {
	      if (_didIteratorError13) {
	        throw _iteratorError13;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion14 = true;
	  var _didIteratorError14 = false;
	  var _iteratorError14 = undefined;
	
	  try {
	    for (var _iterator14 = (0, _getIterator3.default)((0, _keys2.default)(toDelete)), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
	      var _id5 = _step14.value;
	
	      delete sceneGraph.evaluatedNodes[_id5];
	    }
	
	    // console.log('evalSceneGraph updating: ', Object.keys(toUpdate).length);
	  } catch (err) {
	    _didIteratorError14 = true;
	    _iteratorError14 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion14 && _iterator14.return) {
	        _iterator14.return();
	      }
	    } finally {
	      if (_didIteratorError14) {
	        throw _iteratorError14;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion15 = true;
	  var _didIteratorError15 = false;
	  var _iteratorError15 = undefined;
	
	  try {
	    for (var _iterator15 = (0, _getIterator3.default)((0, _keys2.default)(toUpdate)), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
	      var _id6 = _step15.value;
	
	      if (toUpdate[_id6]) updateNode(_id6, toUpdate[_id6]);
	    }
	
	    //if (nowLoaded) evalSceneGraph.loaded = true;
	
	    // Store the current files and sceneGraph used to calculate evalSceneGraph
	    //console.log('Update scene graph in: ', new Date() - start);
	  } catch (err) {
	    _didIteratorError15 = true;
	    _iteratorError15 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion15 && _iterator15.return) {
	        _iterator15.return();
	      }
	    } finally {
	      if (_didIteratorError15) {
	        throw _iteratorError15;
	      }
	    }
	  }
	
	  sceneGraph._ev = sceneGraph._v;
	}

/***/ },
/* 255 */
/*!********************************!*\
  !*** ./src/modules/sceneIO.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createReducer;
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.reportError = reportError;
	exports.useScene = useScene;
	exports.getSceneId = getSceneId;
	exports.loadScene = loadScene;
	exports.errorLoadingScene = errorLoadingScene;
	exports.markRenderingScene = markRenderingScene;
	exports.markRenderedScene = markRenderedScene;
	exports.fetch = fetch;
	exports.savePublished = savePublished;
	exports.fetchAndUse = fetchAndUse;
	exports.loadingProgress = loadingProgress;
	exports.areAssetsLoaded = areAssetsLoaded;
	exports.areAssetsPreloaded = areAssetsPreloaded;
	exports.isSceneLoaded = isSceneLoaded;
	exports.isSceneRendered = isSceneRendered;
	exports.markPreloaded = markPreloaded;
	exports.preloadCommand = preloadCommand;
	exports.markLoaded = markLoaded;
	exports.markLoadingFile = markLoadingFile;
	exports.markLoadedFile = markLoadedFile;
	exports.convertFromJSON = convertFromJSON;
	exports.writeScene = writeScene;
	exports.exportJSON = exportJSON;
	exports.numErrors = numErrors;
	exports.getErrors = getErrors;
	
	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 113);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 145);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 141);
	
	var _createReducer3 = _interopRequireDefault(_createReducer2);
	
	var _bindActionCreators = __webpack_require__(/*! ../store/bindActionCreators */ 256);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 142);
	
	var _assets = __webpack_require__(/*! ./assets */ 144);
	
	var _animation = __webpack_require__(/*! ./animation */ 132);
	
	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 253);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Loading, reading, exporting of the scene.
	 *
	 * @module sceneIO
	 * @public
	 */
	
	var USE_SCENE = 'USE_SCENE';
	var LOADING_SCENEGRAPH = 'LOADING_SCENEGRAPH';
	var LOADED_SCENEGRAPH = 'LOADED_SCENEGRAPH';
	var ERROR_LOADING_SCENEGRAPH = 'ERROR_LOADING_SCENEGRAPH';
	var RENDERING_SCENE = 'RENDERING_SCENE';
	var RENDERED_SCENE = 'RENDERED_SCENE';
	var PRELOADED_SCENE = 'PRELOADED_SCENE';
	var LOADED_SCENE = 'LOADED_SCENE';
	var SCENE_ERROR = 'SCENE_ERROR';
	var PRELOAD_COMMAND = 'PRELOAD_COMMAND';
	
	var states = {
	  FAILED: -1,
	  UNKNOWN: 0,
	  LOADING_SCENEGRAPH: 1,
	  LOADED_SCENEGRAPH: 2,
	  RENDERING: 3,
	  PRELOADED: 4,
	  LOADED: 5,
	  RENDERED: 6
	};
	
	var initialState = (0, _immutable.Map)({
	  id: null, // Active scene id
	  errors: (0, _immutable.List)(), // List of scene errors
	  state: states.UNKNOWN,
	  progress: 0,
	  loadingFiles: (0, _immutable.Map)(),
	  loadedFiles: (0, _immutable.Map)(),
	  loaded: false,
	  preloadCommands: (0, _immutable.List)()
	});
	
	function setProgress(state, createEvent) {
	  if (state.get('state') !== states.RENDERING) return state;
	
	  var loadingFiles = state.get('loadingFiles').size;
	  var loadedFiles = state.get('loadedFiles').size;
	  var totalFiles = loadingFiles + loadedFiles;
	  var progress = totalFiles === 0 ? 1 : (1 + loadedFiles / totalFiles) / 2;
	  //console.log('progress: ', loadingFiles, loadedFiles, progress);
	
	  if (progress < 1) {
	    createEvent('loading', progress);
	    return state.set('progress', progress);
	  }
	  createEvent('loading', 1);
	  return state.set('progress', 1);
	};
	
	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, USE_SCENE, function (state, id) {
	  return state.set('id', id);
	}), (0, _defineProperty3.default)(_createReducer, LOADING_SCENEGRAPH, function (state, id) {
	  return state.get('loaded') ? state : state.set('state', states.LOADING_SCENEGRAPH).set('progress', 1 / 4);
	}), (0, _defineProperty3.default)(_createReducer, LOADED_SCENEGRAPH, function (state, id) {
	  return state.get('loaded') ? state : state.set('state', states.LOADED_SCENEGRAPH).set('progress', 1 / 2);
	}), (0, _defineProperty3.default)(_createReducer, ERROR_LOADING_SCENEGRAPH, function (state, xhr, _ref) {
	  var action = _ref.action;
	  var error = action.error;
	
	  var msg = 'Error Loading Scene: ' + error.status + ' ' + error.statusText; //' + (error && error.response ? ': '+error.response : '');
	  return state.updateIn(['errors'], (0, _immutable.List)(), function (list) {
	    return list.push(msg);
	  });
	}), (0, _defineProperty3.default)(_createReducer, RENDERING_SCENE, function (state, payload, _ref2) {
	  var createEvent = _ref2.createEvent;
	
	  return setProgress(state.set('state', states.RENDERING), createEvent);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADING_FILE, function (state, id) {
	  return state.setIn(['loadingFiles', id], true);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADED_FILE, function (state, id, _ref3) {
	  var createEvent = _ref3.createEvent;
	
	  return setProgress(state.deleteIn(['loadingFiles', id]).setIn(['loadedFiles', id], true), createEvent);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADING_FILE_ERROR, function (state, id, _ref4) {
	  var createEvent = _ref4.createEvent;
	
	  return setProgress(state.deleteIn(['loadingFiles', id]), createEvent);
	}), (0, _defineProperty3.default)(_createReducer, PRELOADED_SCENE, function (state, _, _ref5) {
	  var createEvent = _ref5.createEvent;
	
	  createEvent('preloaded');
	  return state.set('state', states.PRELOADED);
	}), (0, _defineProperty3.default)(_createReducer, PRELOAD_COMMAND, function (state, fn) {
	  return state.updateIn(['preloadCommands'], (0, _immutable.List)(), function (list) {
	    return list.push(fn);
	  });
	}), (0, _defineProperty3.default)(_createReducer, LOADED_SCENE, function (state, _, _ref6) {
	  var createEvent = _ref6.createEvent;
	
	  createEvent('loaded');
	  return state.set('loaded', true);
	}), (0, _defineProperty3.default)(_createReducer, RENDERED_SCENE, function (state, _, _ref7) {
	  var createEvent = _ref7.createEvent;
	
	  createEvent('rendered');
	  return state.set('state', states.RENDERED);
	}), (0, _defineProperty3.default)(_createReducer, SCENE_ERROR, function (state, msg) {
	  return state.updateIn(['errors'], (0, _immutable.List)(), function (list) {
	    return list.push(msg);
	  });
	}), _createReducer));
	
	var apiRoot = ("https://editor.vimarket.io") + '/api';
	
	function reportError(msg) {
	  return { type: SCENE_ERROR, payload: msg };
	}
	
	/**
	 * sets the active scene.
	 *
	 * @param {string} id the scene uuid
	 */
	function useScene(id) {
	  return { type: USE_SCENE, payload: id };
	}
	
	/**
	 * Returns the active scene Id
	 *
	 * @public
	 * @returns {uuid}
	 *
	 */
	function getSceneId(store) {
	  return store.getIn(['sceneIO', 'id']);
	};
	
	/**
	 * Loads the published scene
	 *
	 * @public
	 * @param {string} id the scene uuid.
	 * @param {string} transitString the published, exported scene
	 * @returns {Promise}
	 *
	 */
	function loadScene(id, transitString) {
	  return function (store) {
	    var payload = store.read(transitString);
	    store.logPageView('/player/v2/' + id);
	    return store.dispatch({ type: _actionTypes.LOAD_SCENE, payload: payload });
	  };
	}
	
	function errorLoadingScene(id) {
	  return reportError('Error Loading Scene');
	}
	
	function markRenderingScene() {
	  return { type: RENDERING_SCENE };
	}
	
	function markRenderedScene() {
	  return { type: RENDERED_SCENE };
	}
	
	/**
	 * Fetch the scene
	 *
	 * If `hash` is provided it will fetch directly from resources, otherwise it will fetch from
	 * `/api/scenes/:uuid/published`. By default, it will fetch the latest published version. If you
	 *  wish to ensure you are fetching the latest scene version, set `waitForPublish: true`.
	 *
	 *  @public
	 *  @param {uuid} sceneId
	 *  @param {String} hash - md5 hash of published content (Optional)
	 *  @param {Object} options
	 *  @param {Boolean} options.waitForPublish Wait for the latest scene version to be published (default false);
	 *
	 */
	function fetch(sceneId, hash) {
	  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
	  var wait = options.waitForPublish;
	
	  return function (store) {
	    if (store.getIn(['sceneGraph', sceneId])) return _promise2.default.resolve(true);
	
	    var fetch = hash ? (0, _assets.fetchText)(hash)(store) : store.callApi({
	      contentType: 'text',
	      types: [LOADING_SCENEGRAPH, LOADED_SCENEGRAPH, ERROR_LOADING_SCENEGRAPH],
	      url: apiRoot + '/scenes/' + sceneId + '/published?wait=' + (wait ? 'true' : 'false'),
	      queryKey: 'SCENE' + sceneId,
	      payload: sceneId
	    });
	
	    var promise = fetch.then(function (transit) {
	      return store.dispatch(loadScene(sceneId, transit));
	    });
	
	    return promise;
	  };
	};
	
	function savePublished() {
	  return function (store) {
	    var transit = writeScene(store);
	    var sceneId = getSceneId(store);
	
	    return store.callApi({
	      contentType: 'text',
	      url: apiRoot + '/scenes/' + sceneId + '/published',
	      method: 'PUT',
	      body: (0, _stringify2.default)({ content: transit })
	    });
	  };
	}
	
	/**
	 * Fetch, Load and Use published scene
	 *
	 * If `hash` is provided it will fetch directly from resources, otherwise it will fetch from
	 * `/api/scenes/:uuid/published`.
	 *
	 *  @public
	 *  @param {uuid} sceneId
	 *  @param {String} hash - md5 hash of published content (Optional)
	 *
	 */
	function fetchAndUse(sceneId, hash) {
	  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
	  return function (store) {
	    store.dispatch(useScene(sceneId));
	    return store.dispatch(fetch(sceneId, hash, options));
	  };
	};
	
	function loadingProgress(_ref8) {
	  var getIn = _ref8.getIn;
	  var dispatch = _ref8.dispatch;
	
	  return getIn(['sceneIO', 'progress']);
	};
	
	/*
	 * Have preloaded commands run, and are all assets loaded
	 */
	function areAssetsLoaded(store) {
	  return store.getIn(['sceneIO', 'state']) >= states.PRELOADED && store.getIn(['sceneIO', 'loadingFiles']).size === 0;
	}
	
	/*
	 * Are all assets loaded before preload commands are run
	 */
	function areAssetsPreloaded(store) {
	  return store.getIn(['sceneIO', 'state']) >= states.RENDERING && store.getIn(['sceneIO', 'loadingFiles']).size === 0;
	}
	
	function isSceneLoaded(store) {
	  return store.getIn(['sceneIO', 'loaded']);
	}
	function isSceneRendered(store) {
	  return store.getIn(['sceneIO', 'state']) >= states.RENDERED;
	}
	
	function markPreloaded() {
	  return function (store) {
	    var preloadCommands = store.getIn(['sceneIO', 'preloadCommands']);
	
	    _promise2.default.all(preloadCommands.map(function (fn) {
	      return _promise2.default.resolve(fn());
	    }).toArray()).then(function () {
	      store.dispatch({ type: PRELOADED_SCENE });
	    }).catch(function (err) {
	      console.log('Caught plugin error: ', err);
	      store.dispatch({ type: PRELOADED_SCENE });
	    });
	  };
	}
	
	function preloadCommand(fn) {
	  return { type: PRELOAD_COMMAND, payload: fn };
	}
	
	function markLoaded() {
	  return { type: LOADED_SCENE };
	}
	
	function markLoadingFile(id) {
	  return { type: _actionTypes.LOADING_FILE, payload: id };
	};
	
	function markLoadedFile(id) {
	  return { type: _actionTypes.LOADED_FILE, payload: id };
	};
	
	function convertPlugs(plugArray) {
	  var plugs = {};
	  plugArray.forEach(function (plug) {
	    plugs[plug.type] = plug.operators.map(function (op) {
	      var name = op.name;
	      var type = op.type || name;
	      return [type, (0, _ramda.omit)(['_id', 'primitive', 'name', 'type'], op), name];
	    });
	  });
	  return plugs;
	};
	
	var convertNode = (0, _ramda.curry)(function (store, sceneJSON, parent, json) {
	  var id = json._id;
	  var name = json.name;
	  var type = json.type;
	
	  var plugs = convertPlugs(json.plugs);
	
	  store.dispatch((0, _sceneGraph.addNode)({ id: id, name: name, type: type, plugs: plugs, parent: parent }));
	
	  (0, _ramda.forEach)(convertNode(store, sceneJSON, id), json.nodes);
	});
	
	function convertFiles(store, files) {
	  (0, _ramda.forEach)(function (file) {
	    store.dispatch((0, _assets.addFile)((0, _extends3.default)({ id: file._id }, (0, _ramda.omit)(['_id', '__v'], file))));
	  }, files);
	}
	
	function convertFromJSON(store, json) {
	  convertNode(store, json, null, json);
	  convertFiles(store, json.files);
	
	  (0, _ramda.mapObjIndexed)(function (clip, id) {
	    store.dispatch((0, _animation.addClip)(clip, id));
	  }, json.clips);
	};
	
	function writeScene(store) {
	  var sceneGraph = (0, _sceneGraph.getEvalSceneGraph)(store);
	
	  return store.write({
	    nodes: (0, _stringify2.default)(sceneGraph.nodes),
	    assets: (0, _assets.getActiveAssets)(store),
	    clips: store.getIn(['animation', 'clips'])
	  });
	}
	
	function exportJSON(store) {
	  return {
	    scene: store.get('sceneGraph').toJS(),
	    assets: (0, _assets.getActiveAssets)(store).toJS()
	  };
	}
	
	function numErrors(store) {
	  return store.getIn(['sceneIO', 'errors']).size;
	}
	
	function getErrors(store) {
	  return store.getIn(['sceneIO', 'errors']);
	}
	
	var publicApi = {
	  reducer: reducer,
	  actions: { fetch: fetch, fetchAndUse: fetchAndUse, loadScene: loadScene, useScene: useScene, reportError: reportError, preloadCommand: preloadCommand, savePublished: savePublished },
	  selectors: { isSceneLoaded: isSceneLoaded, isSceneRendered: isSceneRendered, loadingProgress: loadingProgress, getErrors: getErrors, numErrors: numErrors, getSceneId: getSceneId, writeScene: writeScene }
	};
	exports.default = publicApi;

/***/ },
/* 256 */
/*!*****************************************!*\
  !*** ./src/store/bindActionCreators.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = bindActionCreators;
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	function bindActionCreator(dispatch, actionCreator) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(dispatch, actionCreators) {
	  return (0, _ramda.map)((0, _ramda.map)((0, _ramda.curry)(bindActionCreator)(dispatch)), actionCreators);
	};

/***/ },
/* 257 */
/*!**********************************!*\
  !*** ./src/store/createStore.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ActionTypes = undefined;
	exports.default = createStore;
	
	var _setImmediate2 = __webpack_require__(/*! babel-runtime/core-js/set-immediate */ 258);
	
	var _setImmediate3 = _interopRequireDefault(_setImmediate2);
	
	var _isPlainObject = __webpack_require__(/*! ./isPlainObject */ 127);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _transitImmutable = __webpack_require__(/*! ./transitImmutable */ 261);
	
	var _transitImmutable2 = _interopRequireDefault(_transitImmutable);
	
	var _rsvp = __webpack_require__(/*! rsvp */ 105);
	
	var _rsvp2 = _interopRequireDefault(_rsvp);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var raf = undefined,
	    rafContext = undefined;
	
	function setRequestAnimationFrame(newRequestAnimationFrame, context) {
	  if (newRequestAnimationFrame) {
	    raf = newRequestAnimationFrame;
	    rafContext = context;
	  } else {
	    raf =  true ? requestAnimationFrame : _setImmediate3.default;
	    rafContext =  true ? window : this;
	  }
	}
	
	setRequestAnimationFrame();
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	  if (typeof enhancer === 'function') {
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  var transitInstance = undefined;
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var listeners = [];
	  var events = [];
	  var isDispatching = false;
	  var records = [];
	  var rollbar = false;
	  var currentTranslator = null;
	  var currentNavigator = null;
	  var apiFunction = null;
	
	  function createEvent(type) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }
	
	    events.push({ type: type, args: args });
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  function getIn(path) {
	    return currentState.getIn(path);
	  }
	
	  function get(key) {
	    return currentState.get(key);
	  }
	
	  function getTranslator() {
	    return currentTranslator;
	  };
	
	  function setTranslator(translator) {
	    currentTranslator = translator;
	  };
	
	  function setApi(api) {
	    apiFunction = api;
	  };
	
	  function hasApi() {
	    return !!apiFunction;
	  };
	
	  function callApi() {
	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }
	
	    return apiFunction.apply(undefined, [this].concat(args));
	  };
	
	  function logPageView(path) {
	    if (!(true) || !(undefined)) return;
	
	    var url = 'https://www.google-analytics.com/collect?v=1&tid=' + (undefined) + ('&cid=555&t=pageview&dh=' + encodeURI(window.location.hostname)) + ('&dt=' + encodeURI(document.title) + '&dp=' + encodeURI(path));
	
	    store.callApi({ contentType: 'text', method: 'POST', url: url }).catch(function (e) {
	      // console.log('Ignore api errors from ga');
	    });
	  }
	
	  /**
	   * Adds 'Record' types required for reading/writing transit format.
	   */
	  function addRecords(newRecords) {
	    records = records.concat(newRecords);
	  };
	
	  function initTransit() {
	    transitInstance = _transitImmutable2.default.withRecords(records, 'NoneNoOp');
	  };
	
	  function read(transitString) {
	    if (!transitInstance) initTransit();
	    return transitInstance.fromJSON(transitString);
	  };
	
	  function write(data) {
	    if (!transitInstance) initTransit();
	    return transitInstance.toJSON(data); //sceneGraph: Map(), files: Map()});
	  };
	
	  function useRollbar(rb) {
	    rollbar = rb;
	  };
	
	  function error(err, label) {
	    if (label) console.error(label);
	    if (rollbar) {
	      rollbar.error(err);
	    } else {
	      throw err;
	    }
	  };
	
	  _rsvp2.default.on('error', error);
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    listeners.push(listener);
	    var isSubscribed = true;
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	      var index = listeners.indexOf(listener);
	      listeners.splice(index, 1);
	    };
	  }
	
	  // Custom debounce function, lodash.debounce is bigger and slower.
	  function batchNotify() {
	    var notifying = false;
	    var requestNotify = false;
	
	    function notify() {
	      if (notifying) {
	        requestNotify = true;
	      } else {
	        notifying = true;
	        requestNotify = false;
	
	        raf.call(rafContext, function () {
	          // Actual notify code
	          try {
	            var evs = events.splice(0, events.length);
	            listeners.slice().forEach(function (listener) {
	              return listener(evs);
	            });
	          } catch (e) {
	            error(e);
	          }
	
	          notifying = false;
	          if (requestNotify) {
	            notify();
	          }
	        });
	      }
	    }
	
	    return notify;
	  }
	
	  var notifyListenersBatched = batchNotify();
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing what changed. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2.default)(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      console.error("Invalid action: ", action);
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action, createEvent);
	    } catch (e) {
	      error(e);
	    } finally {
	      isDispatching = false;
	    }
	
	    notifyListenersBatched();
	    // listeners.slice().forEach(listener => listener())
	
	    return _rsvp2.default.Promise.resolve(action.resolve ? action.resolve : action.payload);
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  var store = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    getIn: getIn,
	    get: get,
	    replaceReducer: replaceReducer,
	    setTranslator: setTranslator,
	    getTranslator: getTranslator,
	    addRecords: addRecords,
	    read: read,
	    write: write,
	    useRollbar: useRollbar,
	    error: error,
	    setApi: setApi,
	    hasApi: hasApi,
	    callApi: callApi,
	    createEvent: createEvent,
	    setRequestAnimationFrame: setRequestAnimationFrame,
	    logPageView: logPageView
	  };
	
	  return store;
	}

/***/ },
/* 258 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/set-immediate.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/set-immediate */ 259), __esModule: true };

/***/ },
/* 259 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/set-immediate.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../modules/web.immediate */ 260);
	module.exports = __webpack_require__(/*! ../modules/_core */ 13).setImmediate;

/***/ },
/* 260 */
/*!********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/web.immediate.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 11)
	  , $task   = __webpack_require__(/*! ./_task */ 93);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 261 */
/*!***************************************!*\
  !*** ./src/store/transitImmutable.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _transitJs = __webpack_require__(/*! transit-js */ 262);
	
	var _transitJs2 = _interopRequireDefault(_transitJs);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _immutable2 = _interopRequireDefault(_immutable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Modified from:
	// https://github.com/thomasboyt/transit-immutable-js/blob/records-support/index.js
	
	// With changes:
	//  * Records can't simply be serialized with 'toJS', since
	//    records may contain other composite types.
	//  * Serialize with array for efficiency.
	//  * Build records into an object first instead of using 'asMutable',
	//    due to weird bug with 'id' containing records.
	
	function createReader(recordMap, defaultRecord) {
	  return _transitJs2.default.reader('json', {
	    mapBuilder: {
	      init: function init() {
	        return {};
	      },
	      add: function add(m, k, v) {
	        m[k] = v;
	        return m;
	      },
	      finalize: function finalize(m) {
	        return m;
	      }
	    },
	    handlers: {
	      iM: function iM(v) {
	        var o = {};
	        for (var i = 0; i < v.length; i += 2) {
	          o[v[i]] = v[i + 1];
	        }
	        return new _immutable2.default.Map(o);
	      },
	      iL: function iL(v) {
	        return _immutable2.default.List(v);
	      },
	      iR: function iR(v) {
	        var Record = recordMap[v[0]];
	        if (!Record) {
	          var msg = 'Tried to deserialize Record type named `' + v[0] + '`, ' + 'but no type with that name was passed to withRecords()';
	          if (defaultRecord) {
	            if (console) console.error(msg);
	            return new recordMap[defaultRecord]();
	          } else {
	            throw new Error(msg);
	          }
	        }
	        var o = {};
	        for (var i = 1; i < v.length; i += 2) {
	          o[v[i]] = v[i + 1];
	        }
	        return new Record(o);
	      }
	    }
	  });
	}
	
	var reader = createReader([]);
	var writer = createWriter(false, []);
	
	exports.toJSON = toJSON;
	function toJSON(data) {
	  return writer.write(data);
	}
	
	exports.fromJSON = fromJSON;
	function fromJSON(data) {
	  return reader.read(data);
	}
	
	function withFilter(predicate) {
	  var filteredWriter = createWriter(predicate, []);
	  return {
	    toJSON: function toJSON(data) {
	      return filteredWriter.write(data);
	    },
	    fromJSON: fromJSON
	  };
	}
	exports.withFilter = withFilter;
	
	function withRecords(records, defaultRecord, predicate) {
	  var recordMap = {};
	
	  records.forEach(function (RecordType) {
	    var rec = new RecordType({});
	
	    if (!rec._name) {
	      throw new Error('Cannot (de)serialize Record() without a name field');
	    }
	
	    recordMap[rec._name] = RecordType;
	  });
	  var recordWriter = createWriter(predicate, recordMap);
	  var recordReader = createReader(recordMap, defaultRecord);
	
	  return {
	    toJSON: function toJSON(data) {
	      return recordWriter.write(data);
	    },
	    fromJSON: function fromJSON(data) {
	      return recordReader.read(data);
	    }
	  };
	}
	exports.withRecords = withRecords;
	
	function createWriter(predicate, recordMap) {
	  var handlers = _transitJs2.default.map([_immutable2.default.Map, _transitJs2.default.makeWriteHandler({
	    tag: function tag() {
	      return 'iM';
	    },
	    rep: function rep(m) {
	      var i = 0,
	          a = new Array(2 * m.size);
	      if (predicate) {
	        m = m.filter(predicate);
	      }
	      m.forEach(function (v, k) {
	        a[i++] = k;
	        a[i++] = v;
	      });
	      return a;
	    }
	  }), _immutable2.default.List, _transitJs2.default.makeWriteHandler({
	    tag: function tag() {
	      return "iL";
	    },
	    rep: function rep(v) {
	      if (predicate) {
	        v = v.filter(predicate);
	      }
	      return v.toArray();
	    }
	  }), Function, _transitJs2.default.makeWriteHandler({
	    tag: function tag() {
	      return '_';
	    },
	    rep: function rep() {
	      return null;
	    }
	  })]);
	
	  (0, _keys2.default)(recordMap).forEach(function (name) {
	    handlers.set(recordMap[name], makeRecordHandler(name, recordMap[name], predicate));
	  });
	
	  return _transitJs2.default.writer('json', {
	    handlers: handlers
	  });
	}
	
	function makeRecordHandler(name, Record, predicate) {
	  var rec = new Record();
	  return _transitJs2.default.makeWriteHandler({
	    tag: function tag() {
	      return 'iR';
	    },
	    rep: function rep(m) {
	      var i = 0,
	          a = new Array(); //2 * m.size + 1);
	      a.push(name); //a[i++] = name;
	      if (predicate) {
	        m = m.filter(predicate);
	      }
	      m.forEach(function (v, k) {
	        var d = rec.get(k);
	        if (d !== v && !_immutable2.default.is(d, v)) {
	          a.push(k); //a[i++] = k;
	          a.push(v); //a[i++] = v;
	        }
	      });
	      return a;
	    }
	  });
	}

/***/ },
/* 262 */
/*!***************************************!*\
  !*** ./vendor/transit-0.8.837-min.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// transit-js 0.8.837
	// http://transit-format.org
	//
	// Copyright 2014 Cognitect. All Rights Reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//      http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS-IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License..
	;(function(){var aa=this;
	function ba(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==
	b&&"undefined"==typeof a.call)return"object";return b}function k(a,b){var c=a.split("."),d=aa;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var e;c.length&&(e=c.shift());)c.length||void 0===b?d[e]?d=d[e]:d=d[e]={}:d[e]=b};function l(a,b){this.v=a|0;this.j=b|0}var ca,da,ea,fa,ga,ia,ja={};function m(a){if(-128<=a&&128>a){var b=ja[a];if(b)return b}b=new l(a|0,0>a?-1:0);-128<=a&&128>a&&(ja[a]=b);return b}function n(a){isNaN(a)||!isFinite(a)?a=p():a<=-ka?a=q():a+1>=ka?(fa||(fa=r(-1,2147483647)),a=fa):a=0>a?t(n(-a)):new l(a%v|0,a/v|0);return a}function r(a,b){return new l(a,b)}
	function la(a,b){if(0==a.length)throw Error("number format error: empty string");var c=b||10;if(2>c||36<c)throw Error("radix out of range: "+c);if("-"==a.charAt(0))return t(la(a.substring(1),c));if(0<=a.indexOf("-"))throw Error('number format error: interior "-" character: '+a);for(var d=n(Math.pow(c,8)),e=p(),f=0;f<a.length;f+=8){var g=Math.min(8,a.length-f),h=parseInt(a.substring(f,f+g),c);8>g?(g=n(Math.pow(c,g)),e=w(e,g).add(n(h))):(e=w(e,d),e=e.add(n(h)))}return e}var v=4294967296,ka=v*v/2;
	function p(){ca||(ca=m(0));return ca}function x(){da||(da=m(1));return da}function ma(){ea||(ea=m(-1));return ea}function q(){ga||(ga=r(0,-2147483648));return ga}function na(){ia||(ia=m(16777216));return ia}function y(a){return a.j*v+(0<=a.v?a.v:v+a.v)}
	l.prototype.toString=function(a){a=a||10;if(2>a||36<a)throw Error("radix out of range: "+a);if(z(this))return"0";if(0>this.j){if(A(this,q())){var b=n(a),c=B(this,b),b=oa(w(c,b),this);return c.toString(a)+b.v.toString(a)}return"-"+t(this).toString(a)}for(var c=n(Math.pow(a,6)),b=this,d="";;){var e=B(b,c),f=oa(b,w(e,c)).v.toString(a),b=e;if(z(b))return f+d;for(;6>f.length;)f="0"+f;d=""+f+d}};function z(a){return 0==a.j&&0==a.v}function A(a,b){return a.j==b.j&&a.v==b.v}
	function C(a,b){if(A(a,b))return 0;var c=0>a.j,d=0>b.j;return c&&!d?-1:!c&&d?1:0>oa(a,b).j?-1:1}function t(a){return A(a,q())?q():r(~a.v,~a.j).add(x())}l.prototype.add=function(a){var b=this.j>>>16,c=this.j&65535,d=this.v>>>16,e=a.j>>>16,f=a.j&65535,g=a.v>>>16,h;h=0+((this.v&65535)+(a.v&65535));a=0+(h>>>16);a+=d+g;d=0+(a>>>16);d+=c+f;c=0+(d>>>16);c=c+(b+e)&65535;return r((a&65535)<<16|h&65535,c<<16|d&65535)};function oa(a,b){return a.add(t(b))}
	function w(a,b){if(z(a)||z(b))return p();if(A(a,q()))return 1==(b.v&1)?q():p();if(A(b,q()))return 1==(a.v&1)?q():p();if(0>a.j)return 0>b.j?w(t(a),t(b)):t(w(t(a),b));if(0>b.j)return t(w(a,t(b)));var c=na();if(c=0>C(a,c))c=na(),c=0>C(b,c);if(c)return n(y(a)*y(b));var c=a.j>>>16,d=a.j&65535,e=a.v>>>16,f=a.v&65535,g=b.j>>>16,h=b.j&65535,Ia=b.v>>>16,ha=b.v&65535,M,u,H,Ja;Ja=0+f*ha;H=0+(Ja>>>16);H+=e*ha;u=0+(H>>>16);H=(H&65535)+f*Ia;u+=H>>>16;H&=65535;u+=d*ha;M=0+(u>>>16);u=(u&65535)+e*Ia;M+=u>>>16;u&=
	65535;u+=f*h;M+=u>>>16;u&=65535;M=M+(c*ha+d*Ia+e*h+f*g)&65535;return r(H<<16|Ja&65535,M<<16|u)}
	function B(a,b){if(z(b))throw Error("division by zero");if(z(a))return p();if(A(a,q())){if(A(b,x())||A(b,ma()))return q();if(A(b,q()))return x();var c;c=1;if(0==c)c=a;else{var d=a.j;c=32>c?r(a.v>>>c|d<<32-c,d>>c):r(d>>c-32,0<=d?0:-1)}c=pa(B(c,b),1);if(A(c,p()))return 0>b.j?x():ma();d=oa(a,w(b,c));return c.add(B(d,b))}if(A(b,q()))return p();if(0>a.j)return 0>b.j?B(t(a),t(b)):t(B(t(a),b));if(0>b.j)return t(B(a,t(b)));for(var e=p(),d=a;0<=C(d,b);){c=Math.max(1,Math.floor(y(d)/y(b)));for(var f=Math.ceil(Math.log(c)/
	Math.LN2),f=48>=f?1:Math.pow(2,f-48),g=n(c),h=w(g,b);0>h.j||0<C(h,d);)c-=f,g=n(c),h=w(g,b);z(g)&&(g=x());e=e.add(g);d=oa(d,h)}return e}function pa(a,b){b&=63;if(0==b)return a;var c=a.v;return 32>b?r(c<<b,a.j<<b|c>>>32-b):r(0,c<<b-32)}function qa(a,b){b&=63;if(0==b)return a;var c=a.j;return 32>b?r(a.v>>>b|c<<32-b,c>>>b):32==b?r(c,0):r(c>>>b-32,0)};function ra(a,b){if(3<a.length){if(b)return!0;var c=a.charAt(1);return"~"===a.charAt(0)?":"===c||"$"===c||"#"===c:!1}return!1}function sa(a){var b=Math.floor(a/44);a=String.fromCharCode(a%44+48);return 0===b?"^"+a:"^"+String.fromCharCode(b+48)+a}function ta(){this.a=this.s=0;this.g={}}ta.prototype.write=function(a,b){if(ra(a,b)){1936===this.s&&this.clear();var c=this.g[a];return null==c?(this.g[a]=[sa(this.s),this.a],this.s++,a):c[1]!=this.a?(c[1]=this.a,c[0]=sa(this.s),this.s++,a):c[0]}return a};
	ta.prototype.clear=function(){this.s=0;this.a++};function ua(){this.s=0;this.a=[]}ua.prototype.write=function(a){1936==this.s&&(this.s=0);this.a[this.s]=a;this.s++;return a};ua.prototype.P=function(a){return this.a[2===a.length?a.charCodeAt(1)-48:44*(a.charCodeAt(1)-48)+(a.charCodeAt(2)-48)]};ua.prototype.clear=function(){this.s=0};var D="undefined"!=typeof Object.keys?function(a){return Object.keys(a)}:function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b},E="undefined"!=typeof Array.isArray?function(a){return Array.isArray(a)}:function(a){return"array"===ba(a)};function F(){return Math.round(15*Math.random()).toString(16)}
	function va(){var a=(8|3&Math.round(14*Math.random())).toString(16);return F()+F()+F()+F()+F()+F()+F()+F()+"-"+F()+F()+F()+F()+"-4"+F()+F()+F()+"-"+a+F()+F()+F()+"-"+F()+F()+F()+F()+F()+F()+F()+F()+F()+F()+F()+F()};var wa=1;function G(a,b){if(null==a)return null==b;if(a===b)return!0;if("object"===typeof a){if(E(a)){if(E(b)&&a.length===b.length){for(var c=0;c<a.length;c++)if(!G(a[c],b[c]))return!1;return!0}return!1}if(a.C)return a.C(b);if(null!=b&&"object"===typeof b){if(b.C)return b.C(a);var c=0,d=D(b).length,e;for(e in a)if(a.hasOwnProperty(e)&&(c++,!b.hasOwnProperty(e)||!G(a[e],b[e])))return!1;return c===d}}return!1}function xa(a,b){return a^b+2654435769+(a<<6)+(a>>2)}var ya={},za=0;
	function Aa(a){var b=0;if(null!=a.forEach)a.forEach(function(a,c){b=(b+(I(c)^I(a)))%4503599627370496});else for(var c=D(a),d=0;d<c.length;d++)var e=c[d],f=a[e],b=(b+(I(e)^I(f)))%4503599627370496;return b}function Ba(a){var b=0;if(E(a))for(var c=0;c<a.length;c++)b=xa(b,I(a[c]));else a.forEach&&a.forEach(function(a){b=xa(b,I(a))});return b}
	function I(a){if(null==a)return 0;switch(typeof a){case "number":return a;case "boolean":return!0===a?1:0;case "string":var b=ya[a];if(null==b){for(var c=b=0;c<a.length;++c)b=31*b+a.charCodeAt(c),b%=4294967296;za++;256<=za&&(ya={},za=1);ya[a]=b}a=b;return a;case "function":if(b=a.transit$hashCode$)return b;b=wa;"undefined"!=typeof Object.defineProperty?Object.defineProperty(a,"transit$hashCode$",{value:b,enumerable:!1}):a.transit$hashCode$=b;wa++;return b;default:return a instanceof Date?a.valueOf():
	E(a)?Ba(a):a.D?a.D():Aa(a)}};var Ca="undefined"!=typeof Symbol?Symbol.iterator:"@@iterator";function J(a,b){this.tag=a;this.rep=b;this.a=-1}J.prototype.toString=function(){return"[TaggedValue: "+this.tag+", "+this.rep+"]"};J.prototype.g=function(a){return G(this,a)};J.prototype.equiv=J.prototype.g;J.prototype.C=function(a){return a instanceof J?this.tag===a.tag&&G(this.rep,a.rep):!1};J.prototype.D=function(){-1===this.a&&(this.a=xa(I(this.tag),I(this.rep)));return this.a};function K(a,b){return new J(a,b)}
	var Da=la("9007199254740991"),Ea=la("-9007199254740991");function Fa(a){if("number"===typeof a)return a;if(a instanceof l)return a;a=la(a,10);return 0<C(a,Da)||0>C(a,Ea)?a:y(a)}l.prototype.a=function(a){return G(this,a)};l.prototype.equiv=l.prototype.a;l.prototype.C=function(a){return a instanceof l&&A(this,a)};l.prototype.D=function(){return this.v};function Ga(a){return K("n",a)}function Ha(a){return K("f",a)}function L(a){this.w=a;this.a=-1}L.prototype.toString=function(){return":"+this.w};
	L.prototype.namespace=function(){var a=this.w.indexOf("/");return-1!=a?this.w.substring(0,a):null};L.prototype.name=function(){var a=this.w.indexOf("/");return-1!=a?this.w.substring(a+1,this.w.length):this.w};L.prototype.g=function(a){return G(this,a)};L.prototype.equiv=L.prototype.g;L.prototype.C=function(a){return a instanceof L&&this.w==a.w};L.prototype.D=function(){-1===this.a&&(this.a=I(this.w));return this.a};function Ka(a){return new L(a)}function N(a){this.w=a;this.a=-1}
	N.prototype.namespace=function(){var a=this.w.indexOf("/");return-1!=a?this.w.substring(0,a):null};N.prototype.name=function(){var a=this.w.indexOf("/");return-1!=a?this.w.substring(a+1,this.w.length):this.w};N.prototype.toString=function(){return this.w};N.prototype.g=function(a){return G(this,a)};N.prototype.equiv=N.prototype.g;N.prototype.C=function(a){return a instanceof N&&this.w==a.w};N.prototype.D=function(){-1===this.a&&(this.a=I(this.w));return this.a};function La(a){return new N(a)}
	function Ma(a,b,c){var d="";c=c||b+1;for(var e=8*(7-b),f=pa(m(255),e);b<c;b++,e-=8,f=qa(f,8)){var g=qa(r(a.v&f.v,a.j&f.j),e).toString(16);1==g.length&&(g="0"+g);d+=g}return d}function O(a,b){this.g=a;this.o=b;this.a=-1}O.prototype.toString=function(){var a,b=this.g,c=this.o;a=""+(Ma(b,0,4)+"-");a+=Ma(b,4,6)+"-";a+=Ma(b,6,8)+"-";a+=Ma(c,0,2)+"-";return a+=Ma(c,2,8)};O.prototype.F=function(a){return G(this,a)};O.prototype.equiv=O.prototype.F;
	O.prototype.C=function(a){return a instanceof O&&A(this.g,a.g)&&A(this.o,a.o)};O.prototype.D=function(){-1===this.a&&(this.a=I(this.toString()));return this.a};
	function Na(a){a=a.replace(/-/g,"");for(var b=null,c=null,d=c=0,e=24,f=0,f=c=0,e=24;8>f;f+=2,e-=8)c|=parseInt(a.substring(f,f+2),16)<<e;d=0;f=8;for(e=24;16>f;f+=2,e-=8)d|=parseInt(a.substring(f,f+2),16)<<e;b=r(d,c);c=0;f=16;for(e=24;24>f;f+=2,e-=8)c|=parseInt(a.substring(f,f+2),16)<<e;d=0;for(e=f=24;32>f;f+=2,e-=8)d|=parseInt(a.substring(f,f+2),16)<<e;c=r(d,c);return new O(b,c)}function Oa(a){a="number"===typeof a?a:parseInt(a,10);return new Date(a)}
	Date.prototype.C=function(a){return a instanceof Date?this.valueOf()===a.valueOf():!1};Date.prototype.D=function(){return this.valueOf()};
	function Pa(a,b){var c;if(b&&!1===b.O||"undefined"==typeof Buffer)if("undefined"!=typeof Uint8Array){if("undefined"!=typeof atob)c=atob(a);else{c=String(a).replace(/=+$/,"");if(1==c.length%4)throw Error("'atob' failed: The string to be decoded is not correctly encoded.");for(var d=0,e,f,g=0,h="";f=c.charAt(g++);~f&&(e=d%4?64*e+f:f,d++%4)?h+=String.fromCharCode(255&e>>(-2*d&6)):0)f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(f);c=h}d=c.length;e=new Uint8Array(d);for(f=
	0;f<d;f++)e[f]=c.charCodeAt(f);c=e}else c=K("b",a);else c=new Buffer(a,"base64");return c}function Qa(a){return K("r",a)}function P(a,b){this.a=a;this.type=b||0;this.s=0}P.prototype.next=function(){if(this.s<this.a.length){var a=null;0===this.type?a=this.a[this.s]:1===this.type?a=this.a[this.s+1]:a=[this.a[this.s],this.a[this.s+1]];a={value:a,done:!1};this.s+=2;return a}return{value:null,done:!0}};P.prototype.next=P.prototype.next;P.prototype[Ca]=function(){return this};
	function Q(a,b){this.map=a;this.type=b||0;this.keys=Ra(this.map);this.s=0;this.g=null;this.a=0}Q.prototype.next=function(){if(this.s<this.map.size){null!=this.g&&this.a<this.g.length||(this.g=this.map.map[this.keys[this.s]],this.a=0);var a=null;0===this.type?a=this.g[this.a]:1===this.type?a=this.g[this.a+1]:a=[this.g[this.a],this.g[this.a+1]];a={value:a,done:!1};this.s++;this.a+=2;return a}return{value:null,done:!0}};Q.prototype.next=Q.prototype.next;Q.prototype[Ca]=function(){return this};
	function Sa(a,b){if(a instanceof R&&Ta(b)){if(a.size!==b.size)return!1;for(var c in a.map)for(var d=a.map[c],e=0;e<d.length;e+=2)if(!G(d[e+1],b.get(d[e])))return!1;return!0}if(a instanceof S&&Ta(b)){if(a.size!==b.size)return!1;c=a.l;for(e=0;e<c.length;e+=2)if(!G(c[e+1],b.get(c[e])))return!1;return!0}if(null!=b&&"object"===typeof b&&(e=D(b),c=e.length,a.size===c)){for(d=0;d<c;d++){var f=e[d];if(!a.has(f)||!G(b[f],a.get(f)))return!1}return!0}return!1}
	function Ua(a){return null==a?"null":"array"==ba(a)?"["+a.toString()+"]":"string"==typeof a?'"'+a+'"':a.toString()}function Va(a){var b=0,c="TransitMap {";a.forEach(function(d,e){c+=Ua(e)+" => "+Ua(d);b<a.size-1&&(c+=", ");b++});return c+"}"}function Wa(a){var b=0,c="TransitSet {";a.forEach(function(d){c+=Ua(d);b<a.size-1&&(c+=", ");b++});return c+"}"}function S(a){this.l=a;this.h=null;this.a=-1;this.size=a.length/2;this.g=0}S.prototype.toString=function(){return Va(this)};S.prototype.inspect=function(){return this.toString()};
	function Xa(a){if(a.h)throw Error("Invalid operation, already converted");if(8>a.size)return!1;a.g++;return 32<a.g?(a.h=T(a.l,!1,!0),a.l=[],!0):!1}S.prototype.clear=function(){this.a=-1;this.h?this.h.clear():this.l=[];this.size=0};S.prototype.clear=S.prototype.clear;S.prototype.keys=function(){return this.h?this.h.keys():new P(this.l,0)};S.prototype.keys=S.prototype.keys;S.prototype.o=function(){if(this.h)return this.h.o();for(var a=[],b=0,c=0;c<this.l.length;b++,c+=2)a[b]=this.l[c];return a};
	S.prototype.keySet=S.prototype.o;S.prototype.entries=function(){return this.h?this.h.entries():new P(this.l,2)};S.prototype.entries=S.prototype.entries;S.prototype.values=function(){return this.h?this.h.values():new P(this.l,1)};S.prototype.values=S.prototype.values;S.prototype.forEach=function(a){if(this.h)this.h.forEach(a);else for(var b=0;b<this.l.length;b+=2)a(this.l[b+1],this.l[b])};S.prototype.forEach=S.prototype.forEach;
	S.prototype.get=function(a,b){if(this.h)return this.h.get(a);if(Xa(this))return this.get(a);for(var c=0;c<this.l.length;c+=2)if(G(this.l[c],a))return this.l[c+1];return b};S.prototype.get=S.prototype.get;S.prototype.has=function(a){if(this.h)return this.h.has(a);if(Xa(this))return this.has(a);for(var b=0;b<this.l.length;b+=2)if(G(this.l[b],a))return!0;return!1};S.prototype.has=S.prototype.has;
	S.prototype.set=function(a,b){this.a=-1;if(this.h)this.h.set(a,b),this.size=this.h.size;else{for(var c=0;c<this.l.length;c+=2)if(G(this.l[c],a)){this.l[c+1]=b;return}this.l.push(a);this.l.push(b);this.size++;32<this.size&&(this.h=T(this.l,!1,!0),this.l=null)}};S.prototype.set=S.prototype.set;
	S.prototype["delete"]=function(a){this.a=-1;if(this.h)return a=this.h["delete"](a),this.size=this.h.size,a;for(var b=0;b<this.l.length;b+=2)if(G(this.l[b],a))return a=this.l[b+1],this.l.splice(b,2),this.size--,a};S.prototype.clone=function(){var a=T();this.forEach(function(b,c){a.set(c,b)});return a};S.prototype.clone=S.prototype.clone;S.prototype[Ca]=function(){return this.entries()};S.prototype.D=function(){if(this.h)return this.h.D();-1===this.a&&(this.a=Aa(this));return this.a};
	S.prototype.C=function(a){return this.h?Sa(this.h,a):Sa(this,a)};function R(a,b,c){this.map=b||{};this.a=a||[];this.size=c||0;this.g=-1}R.prototype.toString=function(){return Va(this)};R.prototype.inspect=function(){return this.toString()};R.prototype.clear=function(){this.g=-1;this.map={};this.a=[];this.size=0};R.prototype.clear=R.prototype.clear;function Ra(a){return null!=a.a?a.a:D(a.map)}
	R.prototype["delete"]=function(a){this.g=-1;this.a=null;for(var b=I(a),c=this.map[b],d=0;d<c.length;d+=2)if(G(a,c[d]))return a=c[d+1],c.splice(d,2),0===c.length&&delete this.map[b],this.size--,a};R.prototype.entries=function(){return new Q(this,2)};R.prototype.entries=R.prototype.entries;R.prototype.forEach=function(a){for(var b=Ra(this),c=0;c<b.length;c++)for(var d=this.map[b[c]],e=0;e<d.length;e+=2)a(d[e+1],d[e],this)};R.prototype.forEach=R.prototype.forEach;
	R.prototype.get=function(a,b){var c=I(a),c=this.map[c];if(null!=c)for(var d=0;d<c.length;d+=2){if(G(a,c[d]))return c[d+1]}else return b};R.prototype.get=R.prototype.get;R.prototype.has=function(a){var b=I(a),b=this.map[b];if(null!=b)for(var c=0;c<b.length;c+=2)if(G(a,b[c]))return!0;return!1};R.prototype.has=R.prototype.has;R.prototype.keys=function(){return new Q(this,0)};R.prototype.keys=R.prototype.keys;
	R.prototype.o=function(){for(var a=Ra(this),b=[],c=0;c<a.length;c++)for(var d=this.map[a[c]],e=0;e<d.length;e+=2)b.push(d[e]);return b};R.prototype.keySet=R.prototype.o;R.prototype.set=function(a,b){this.g=-1;var c=I(a),d=this.map[c];if(null==d)this.a&&this.a.push(c),this.map[c]=[a,b],this.size++;else{for(var c=!0,e=0;e<d.length;e+=2)if(G(b,d[e])){c=!1;d[e]=b;break}c&&(d.push(a),d.push(b),this.size++)}};R.prototype.set=R.prototype.set;R.prototype.values=function(){return new Q(this,1)};
	R.prototype.values=R.prototype.values;R.prototype.clone=function(){var a=T();this.forEach(function(b,c){a.set(c,b)});return a};R.prototype.clone=R.prototype.clone;R.prototype[Ca]=function(){return this.entries()};R.prototype.D=function(){-1===this.g&&(this.g=Aa(this));return this.g};R.prototype.C=function(a){return Sa(this,a)};
	function T(a,b,c){a=a||[];b=!1===b?b:!0;if((!0!==c||!c)&&64>=a.length){if(b){var d=a;a=[];for(b=0;b<d.length;b+=2){var e=!1;for(c=0;c<a.length;c+=2)if(G(a[c],d[b])){a[c+1]=d[b+1];e=!0;break}e||(a.push(d[b]),a.push(d[b+1]))}}return new S(a)}var d={},e=[],f=0;for(b=0;b<a.length;b+=2){c=I(a[b]);var g=d[c];if(null==g)e.push(c),d[c]=[a[b],a[b+1]],f++;else{var h=!0;for(c=0;c<g.length;c+=2)if(G(g[c],a[b])){g[c+1]=a[b+1];h=!1;break}h&&(g.push(a[b]),g.push(a[b+1]),f++)}}return new R(e,d,f)}
	function Ta(a){return a instanceof S||a instanceof R}function U(a){this.map=a;this.size=a.size}U.prototype.toString=function(){return Wa(this)};U.prototype.inspect=function(){return this.toString()};U.prototype.add=function(a){this.map.set(a,a);this.size=this.map.size};U.prototype.add=U.prototype.add;U.prototype.clear=function(){this.map=new R;this.size=0};U.prototype.clear=U.prototype.clear;U.prototype["delete"]=function(a){a=this.map["delete"](a);this.size=this.map.size;return a};
	U.prototype.g=function(){return this.map.entries()};U.prototype.entries=U.prototype.g;U.prototype.forEach=function(a){var b=this;this.map.forEach(function(c,d){a(d,b)})};U.prototype.forEach=U.prototype.forEach;U.prototype.has=function(a){return this.map.has(a)};U.prototype.has=U.prototype.has;U.prototype.keys=function(){return this.map.keys()};U.prototype.keys=U.prototype.keys;U.prototype.o=function(){return this.map.o()};U.prototype.keySet=U.prototype.o;U.prototype.a=function(){return this.map.values()};
	U.prototype.values=U.prototype.a;U.prototype.clone=function(){var a=Ya();this.forEach(function(b){a.add(b)});return a};U.prototype.clone=U.prototype.clone;U.prototype[Ca]=function(){return this.a()};U.prototype.C=function(a){if(a instanceof U){if(this.size===a.size)return G(this.map,a.map)}else return!1};U.prototype.D=function(){return I(this.map)};
	function Ya(a){a=a||[];for(var b={},c=[],d=0,e=0;e<a.length;e++){var f=I(a[e]),g=b[f];if(null==g)c.push(f),b[f]=[a[e],a[e]],d++;else{for(var f=!0,h=0;h<g.length;h+=2)if(G(g[h],a[e])){f=!1;break}f&&(g.push(a[e]),g.push(a[e]),d++)}}return new U(new R(c,b,d))}function Za(a){return K("'",a)}function $a(a){return K("list",a)}function ab(a){return K("link",a)};var bb=0,cb="transit$guid$"+va();function db(a){if(null==a)return"null";if(a===String)return"string";if(a===Boolean)return"boolean";if(a===Number)return"number";if(a===Array)return"array";if(a===Object)return"map";var b=a[cb];null==b&&("undefined"!=typeof Object.defineProperty?(b=++bb,Object.defineProperty(a,cb,{value:b,enumerable:!1})):a[cb]=b=++bb);return b}function V(a,b){for(var c=a.toString(),d=c.length;d<b;d++)c="0"+c;return c}function eb(){}eb.prototype.tag=function(){return"_"};
	eb.prototype.rep=function(){return null};eb.prototype.B=function(){return"null"};function fb(){}fb.prototype.tag=function(){return"s"};fb.prototype.rep=function(a){return a};fb.prototype.B=function(a){return a};function gb(){}gb.prototype.tag=function(){return"i"};gb.prototype.rep=function(a){return a};gb.prototype.B=function(a){return a.toString()};function hb(){}hb.prototype.tag=function(){return"i"};hb.prototype.rep=function(a){return a.toString()};hb.prototype.B=function(a){return a.toString()};
	function ib(){}ib.prototype.tag=function(){return"?"};ib.prototype.rep=function(a){return a};ib.prototype.B=function(a){return a.toString()};function jb(){}jb.prototype.tag=function(){return"array"};jb.prototype.rep=function(a){return a};jb.prototype.B=function(){return null};function kb(){}kb.prototype.tag=function(){return"map"};kb.prototype.rep=function(a){return a};kb.prototype.B=function(){return null};function lb(){}lb.prototype.tag=function(){return"t"};
	lb.prototype.rep=function(a){return a.getUTCFullYear()+"-"+V(a.getUTCMonth()+1,2)+"-"+V(a.getUTCDate(),2)+"T"+V(a.getUTCHours(),2)+":"+V(a.getUTCMinutes(),2)+":"+V(a.getUTCSeconds(),2)+"."+V(a.getUTCMilliseconds(),3)+"Z"};lb.prototype.B=function(a,b){return b.rep(a)};function mb(){}mb.prototype.tag=function(){return"m"};mb.prototype.rep=function(a){return a.valueOf()};mb.prototype.B=function(a){return a.valueOf().toString()};mb.prototype.R=function(){return new lb};function nb(){}
	nb.prototype.tag=function(){return"u"};nb.prototype.rep=function(a){return a.toString()};nb.prototype.B=function(a){return a.toString()};function ob(){}ob.prototype.tag=function(){return":"};ob.prototype.rep=function(a){return a.w};ob.prototype.B=function(a,b){return b.rep(a)};function pb(){}pb.prototype.tag=function(){return"$"};pb.prototype.rep=function(a){return a.w};pb.prototype.B=function(a,b){return b.rep(a)};function qb(){}qb.prototype.tag=function(a){return a.tag};qb.prototype.rep=function(a){return a.rep};
	qb.prototype.B=function(){return null};function rb(){}rb.prototype.tag=function(){return"set"};rb.prototype.rep=function(a){var b=[];a.forEach(function(a){b.push(a)});return K("array",b)};rb.prototype.B=function(){return null};function sb(){}sb.prototype.tag=function(){return"map"};sb.prototype.rep=function(a){return a};sb.prototype.B=function(){return null};function tb(){}tb.prototype.tag=function(){return"map"};tb.prototype.rep=function(a){return a};tb.prototype.B=function(){return null};
	function ub(){}ub.prototype.tag=function(){return"b"};ub.prototype.rep=function(a){return a.toString("base64")};ub.prototype.B=function(){return null};function vb(){}vb.prototype.tag=function(){return"b"};
	vb.prototype.rep=function(a){for(var b=0,c=a.length,d="",e=null;b<c;)e=a.subarray(b,Math.min(b+32768,c)),d+=String.fromCharCode.apply(null,e),b+=32768;var f;if("undefined"!=typeof btoa)f=btoa(d);else{a=String(d);c=0;d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";for(e="";a.charAt(c|0)||(d="=",c%1);e+=d.charAt(63&f>>8-c%1*8)){b=a.charCodeAt(c+=.75);if(255<b)throw Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");f=f<<8|b}f=e}return f};
	vb.prototype.B=function(){return null};function wb(){this.A={};this.set(null,new eb);this.set(String,new fb);this.set(Number,new gb);this.set(l,new hb);this.set(Boolean,new ib);this.set(Array,new jb);this.set(Object,new kb);this.set(Date,new mb);this.set(O,new nb);this.set(L,new ob);this.set(N,new pb);this.set(J,new qb);this.set(U,new rb);this.set(S,new sb);this.set(R,new tb);"undefined"!=typeof Buffer&&this.set(Buffer,new ub);"undefined"!=typeof Uint8Array&&this.set(Uint8Array,new vb)}
	wb.prototype.get=function(a){var b=null,b="string"===typeof a?this.A[a]:this.A[db(a)];return null!=b?b:this.A["default"]};wb.prototype.get=wb.prototype.get;wb.prototype.set=function(a,b){var c;if(c="string"===typeof a)a:{switch(a){case "null":case "string":case "boolean":case "number":case "array":case "map":c=!1;break a}c=!0}c?this.A[a]=b:this.A[db(a)]=b};function xb(a){this.K=a}
	function W(a){this.o=a||{};this.A={};for(var b in this.G.A)this.A[b]=this.G.A[b];for(b in this.o.handlers){a:{switch(b){case "_":case "s":case "?":case "i":case "d":case "b":case "'":case "array":case "map":a=!0;break a}a=!1}if(a)throw Error('Cannot override handler for ground type "'+b+'"');this.A[b]=this.o.handlers[b]}this.J=null!=this.o.preferStrings?this.o.preferStrings:this.G.J;this.O=null!=this.o.preferBuffers?this.o.preferBuffers:this.G.O;this.M=this.o.defaultHandler||this.G.M;this.g=this.o.mapBuilder;
	this.F=this.o.arrayBuilder}
	W.prototype.G={A:{_:function(){return null},"?":function(a){return"t"===a},b:function(a,b){return Pa(a,b)},i:function(a){return Fa(a)},n:function(a){return Ga(a)},d:function(a){return parseFloat(a)},f:function(a){return Ha(a)},c:function(a){return a},":":function(a){return Ka(a)},$:function(a){return La(a)},r:function(a){return Qa(a)},z:function(a){a:switch(a){case "-INF":a=-Infinity;break a;case "INF":a=Infinity;break a;case "NaN":a=NaN;break a;default:throw Error("Invalid special double value "+a);
	}return a},"'":function(a){return a},m:function(a){return Oa(a)},t:function(a){return new Date(a)},u:function(a){return Na(a)},set:function(a){return Ya(a)},list:function(a){return $a(a)},link:function(a){return ab(a)},cmap:function(a){return T(a,!1)}},M:function(a,b){return K(a,b)},J:!0,O:!0};
	W.prototype.a=function(a,b,c,d){if(null==a)return null;switch(typeof a){case "string":return ra(a,c)?(a=yb(this,a),b&&b.write(a,c),b=a):b="^"===a.charAt(0)&&" "!==a.charAt(1)?b.P(a,c):yb(this,a),b;case "object":if(E(a))if("^ "===a[0])if(this.g)if(17>a.length&&this.g.fromArray){d=[];for(c=1;c<a.length;c+=2)d.push(this.a(a[c],b,!0,!1)),d.push(this.a(a[c+1],b,!1,!1));b=this.g.fromArray(d,a)}else{d=this.g.init(a);for(c=1;c<a.length;c+=2)d=this.g.add(d,this.a(a[c],b,!0,!1),this.a(a[c+1],b,!1,!1),a);b=
	this.g.finalize(d,a)}else{d=[];for(c=1;c<a.length;c+=2)d.push(this.a(a[c],b,!0,!1)),d.push(this.a(a[c+1],b,!1,!1));b=T(d,!1)}else b=zb(this,a,b,c,d);else{c=D(a);var e=c[0];if((d=1==c.length?this.a(e,b,!1,!1):null)&&d instanceof xb)a=a[e],c=this.A[d.K],b=null!=c?c(this.a(a,b,!1,!0),this):K(d.K,this.a(a,b,!1,!1));else if(this.g)if(16>c.length&&this.g.fromArray){var f=[];for(d=0;d<c.length;d++)e=c[d],f.push(this.a(e,b,!0,!1)),f.push(this.a(a[e],b,!1,!1));b=this.g.fromArray(f,a)}else{f=this.g.init(a);
	for(d=0;d<c.length;d++)e=c[d],f=this.g.add(f,this.a(e,b,!0,!1),this.a(a[e],b,!1,!1),a);b=this.g.finalize(f,a)}else{f=[];for(d=0;d<c.length;d++)e=c[d],f.push(this.a(e,b,!0,!1)),f.push(this.a(a[e],b,!1,!1));b=T(f,!1)}}return b}return a};W.prototype.decode=W.prototype.a;
	function zb(a,b,c,d,e){if(e){var f=[];for(e=0;e<b.length;e++)f.push(a.a(b[e],c,d,!1));return f}f=c&&c.s;if(2===b.length&&"string"===typeof b[0]&&(e=a.a(b[0],c,!1,!1))&&e instanceof xb)return b=b[1],f=a.A[e.K],null!=f?f=f(a.a(b,c,d,!0),a):K(e.K,a.a(b,c,d,!1));c&&f!=c.s&&(c.s=f);if(a.F){if(32>=b.length&&a.F.fromArray){f=[];for(e=0;e<b.length;e++)f.push(a.a(b[e],c,d,!1));return a.F.fromArray(f,b)}f=a.F.init(b);for(e=0;e<b.length;e++)f=a.F.add(f,a.a(b[e],c,d,!1),b);return a.F.finalize(f,b)}f=[];for(e=
	0;e<b.length;e++)f.push(a.a(b[e],c,d,!1));return f}function yb(a,b){if("~"===b.charAt(0)){var c=b.charAt(1);if("~"===c||"^"===c||"`"===c)return b.substring(1);if("#"===c)return new xb(b.substring(2));var d=a.A[c];return null==d?a.M(c,b.substring(2)):d(b.substring(2),a)}return b};function Ab(a){this.a=new W(a)}function Bb(a,b){this.o=a;this.g=b||{};this.a=this.g.cache?this.g.cache:new ua}Bb.prototype.P=function(a){var b=this.a;a=this.o.a.a(JSON.parse(a),b);this.a.clear();return a};Bb.prototype.read=Bb.prototype.P;function Cb(a){this.a=a||{};this.J=null!=this.a.preferStrings?this.a.preferStrings:!0;this.S=this.a.objectBuilder||null;this.A=new wb;if(a=this.a.handlers){if(E(a)||!a.forEach)throw Error('transit writer "handlers" option must be a map');var b=this;a.forEach(function(a,d){if(void 0!==d)b.A.set(d,a);else throw Error("Cannot create handler for JavaScript undefined");})}this.H=this.a.handlerForForeign;this.L=this.a.unpack||function(a){return a instanceof S&&null===a.h?a.l:!1};this.I=this.a&&this.a.verbose||
	!1}function Db(a,b){var c=a.A.get(null==b?null:b.constructor);return null!=c?c:(c=b&&b.transitTag)?a.A.get(c):null}function X(a,b,c,d,e){a=a+b+c;return e?e.write(a,d):a}function Eb(a,b,c){var d=[];if(E(b))for(var e=0;e<b.length;e++)d.push(Y(a,b[e],!1,c));else b.forEach(function(b){d.push(Y(a,b,!1,c))});return d}function Fb(a,b){if("string"!==typeof b){var c=Db(a,b);return c&&1===c.tag(b).length}return!0}
	function Gb(a,b){var c=a.L(b),d=!0;if(c){for(var e=0;e<c.length&&(d=Fb(a,c[e]),d);e+=2);return d}if(b.keys&&(c=b.keys(),e=null,c.next)){for(e=c.next();!e.done;){d=Fb(a,e.value);if(!d)break;e=c.next()}return d}if(b.forEach)return b.forEach(function(b,c){d=d&&Fb(a,c)}),d;throw Error("Cannot walk keys of object type "+(null==b?null:b.constructor).name);}
	function Hb(a){if(a.constructor.transit$isObject)return!0;var b=a.constructor.toString(),b=b.substr(9),b=b.substr(0,b.indexOf("(")),b="Object"==b;"undefined"!=typeof Object.defineProperty?Object.defineProperty(a.constructor,"transit$isObject",{value:b,enumerable:!1}):a.constructor.transit$isObject=b;return b}
	function Ib(a,b,c){if(b.constructor===Object||null!=b.forEach||a.H&&Hb(b)){if(a.I){if(null!=b.forEach){if(Gb(a,b)){var d={};b.forEach(function(b,e){d[Y(a,e,!0,!1)]=Y(a,b,!1,c)});return d}var e=a.L(b),f=[],g=X("~#","cmap","",!0,c);if(e)for(var h=0;h<e.length;h+=2)f.push(Y(a,e[h],!0,!1)),f.push(Y(a,e[h+1],!1,c));else b.forEach(function(b,d){f.push(Y(a,d,!0,!1));f.push(Y(a,b,!1,c))});d={};d[g]=f;return d}d={};e=D(b);for(h=0;h<e.length;h++)d[Y(a,e[h],!0,!1)]=Y(a,b[e[h]],!1,c);return d}if(null!=b.forEach){if(Gb(a,
	b)){e=a.L(b);d=["^ "];if(e)for(h=0;h<e.length;h+=2)d.push(Y(a,e[h],!0,c)),d.push(Y(a,e[h+1],!1,c));else b.forEach(function(b,e){d.push(Y(a,e,!0,c));d.push(Y(a,b,!1,c))});return d}e=a.L(b);f=[];g=X("~#","cmap","",!0,c);if(e)for(h=0;h<e.length;h+=2)f.push(Y(a,e[h],!0,c)),f.push(Y(a,e[h+1],!1,c));else b.forEach(function(b,d){f.push(Y(a,d,!0,c));f.push(Y(a,b,!1,c))});return[g,f]}d=["^ "];e=D(b);for(h=0;h<e.length;h++)d.push(Y(a,e[h],!0,c)),d.push(Y(a,b[e[h]],!1,c));return d}if(null!=a.S)return a.S(b,
	function(b){return Y(a,b,!0,c)},function(b){return Y(a,b,!1,c)});h=(null==b?null:b.constructor).name;e=Error("Cannot write "+h);e.data={N:b,type:h};throw e;}
	function Y(a,b,c,d){var e=Db(a,b)||(a.H?a.H(b,a.A):null),f=e?e.tag(b):null,g=e?e.rep(b):null;if(null!=e&&null!=f)switch(f){case "_":return c?X("~","_","",c,d):null;case "s":return 0<g.length?(a=g.charAt(0),a="~"===a||"^"===a||"`"===a?"~"+g:g):a=g,X("","",a,c,d);case "?":return c?X("~","?",g.toString()[0],c,d):g;case "i":return Infinity===g?X("~","z","INF",c,d):-Infinity===g?X("~","z","-INF",c,d):isNaN(g)?X("~","z","NaN",c,d):c||"string"===typeof g||g instanceof l?X("~","i",g.toString(),c,d):g;case "d":return c?
	X(g.T,"d",g,c,d):g;case "b":return X("~","b",g,c,d);case "'":return a.I?(b={},c=X("~#","'","",!0,d),b[c]=Y(a,g,!1,d),d=b):d=[X("~#","'","",!0,d),Y(a,g,!1,d)],d;case "array":return Eb(a,g,d);case "map":return Ib(a,g,d);default:a:{if(1===f.length){if("string"===typeof g){d=X("~",f,g,c,d);break a}if(c||a.J){(a=a.I&&e.R())?(f=a.tag(b),g=a.B(b,a)):g=e.B(b,e);if(null!==g){d=X("~",f,g,c,d);break a}d=Error('Tag "'+f+'" cannot be encoded as string');d.data={tag:f,rep:g,N:b};throw d;}}b=f;c=g;a.I?(g={},g[X("~#",
	b,"",!0,d)]=Y(a,c,!1,d),d=g):d=[X("~#",b,"",!0,d),Y(a,c,!1,d)]}return d}else throw d=(null==b?null:b.constructor).name,a=Error("Cannot write "+d),a.data={N:b,type:d},a;}function Jb(a,b){var c=Db(a,b)||(a.H?a.H(b,a.A):null);if(null!=c)return 1===c.tag(b).length?Za(b):b;var c=(null==b?null:b.constructor).name,d=Error("Cannot write "+c);d.data={N:b,type:c};throw d;}function Z(a,b){this.a=a;this.o=b||{};!1===this.o.cache?this.g=null:this.g=this.o.cache?this.o.cache:new ta}Z.prototype.G=function(){return this.a};
	Z.prototype.marshaller=Z.prototype.G;Z.prototype.write=function(a,b){var c=null,d=b||{},c=d.asMapKey||!1,e=this.a.I?!1:this.g;!1===d.marshalTop?c=Y(this.a,a,c,e):(d=this.a,c=JSON.stringify(Y(d,Jb(d,a),c,e)));null!=this.g&&this.g.clear();return c};Z.prototype.write=Z.prototype.write;Z.prototype.F=function(a,b){this.a.A.set(a,b)};Z.prototype.register=Z.prototype.F;var Kb=T;k("transit.reader",function(a,b){if("json"===a||"json-verbose"===a||null==a){var c=new Ab(b);return new Bb(c,b)}throw Error("Cannot create reader of type "+a);});k("transit.writer",function(a,b){if("json"===a||"json-verbose"===a||null==a){"json-verbose"===a&&(null==b&&(b={}),b.verbose=!0);var c=new Cb(b);return new Z(c,b)}c=Error('Type must be "json"');c.data={type:a};throw c;});
	k("transit.makeBuilder",function(a){function b(){}b.prototype.init=a.init;b.prototype.add=a.add;b.prototype.finalize=a.finalize;b.prototype.fromArray=a.fromArray;return new b});k("transit.makeWriteHandler",function(a){function b(){}b.prototype.tag=a.tag;b.prototype.rep=a.rep;b.prototype.B=a.stringRep;b.prototype.R=a.getVerboseHandler;return new b});k("transit.date",Oa);k("transit.integer",Fa);
	k("transit.isInteger",function(a){return a instanceof l?!0:"number"===typeof a&&!isNaN(a)&&Infinity!==a&&parseFloat(a)===parseInt(a,10)});k("transit.uuid",function(a){return Na(a)});k("transit.isUUID",function(a){return a instanceof O});k("transit.bigInt",Ga);k("transit.isBigInt",function(a){return a instanceof J&&"n"===a.tag});k("transit.bigDec",Ha);k("transit.isBigDec",function(a){return a instanceof J&&"f"===a.tag});k("transit.keyword",Ka);k("transit.isKeyword",function(a){return a instanceof L});
	k("transit.symbol",La);k("transit.isSymbol",function(a){return a instanceof N});k("transit.binary",Pa);k("transit.isBinary",function(a){return"undefined"!=typeof Buffer&&a instanceof Buffer?!0:"undefined"!=typeof Uint8Array&&a instanceof Uint8Array?!0:a instanceof J&&"b"===a.tag});k("transit.uri",Qa);k("transit.isURI",function(a){return a instanceof J&&"r"===a.tag});k("transit.map",T);k("transit.isMap",Ta);k("transit.set",Ya);k("transit.isSet",function(a){return a instanceof U});
	k("transit.list",$a);k("transit.isList",function(a){return a instanceof J&&"list"===a.tag});k("transit.quoted",Za);k("transit.isQuoted",function(a){return a instanceof J&&"'"===a.tag});k("transit.tagged",K);k("transit.isTaggedValue",function(a){return a instanceof J});k("transit.link",ab);k("transit.isLink",function(a){return a instanceof J&&"link"===a.tag});k("transit.hash",I);k("transit.hashMapLike",Aa);k("transit.hashArrayLike",Ba);k("transit.equals",G);
	k("transit.extendToEQ",function(a,b){a.D=b.hashCode;a.C=b.equals;return a});k("transit.mapToObject",function(a){var b={};a.forEach(function(a,d){if("string"!==typeof d)throw Error("Cannot convert map with non-string keys");b[d]=a});return b});k("transit.objectToMap",function(a){var b=Kb(),c;for(c in a)a.hasOwnProperty(c)&&b.set(c,a[c]);return b});k("transit.decoder",function(a){return new W(a)});k("transit.UUIDfromString",Na);k("transit.randomUUID",va);k("transit.stringableKeys",Gb);
	k("transit.readCache",function(){return new ua});k("transit.writeCache",function(){return new ta});})();
	module.exports = transit;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/buffer/index.js */ 155).Buffer))

/***/ },
/* 263 */
/*!*********************************************!*\
  !*** ./src/modules/utils/tweenFunctions.js ***!
  \*********************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	// From: https://github.com/chenglou/tween-functions/blob/master/index.js
	// t: current time, b: beginning value, _c: final value, d: total duration
	var tweenFunctions = {
	  linear: function linear(t, b, _c, d) {
	    var c = _c - b;
	    return c * t / d + b;
	  },
	  easeInQuad: function easeInQuad(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t + b;
	  },
	  easeOutQuad: function easeOutQuad(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (t /= d) * (t - 2) + b;
	  },
	  easeInOutQuad: function easeInOutQuad(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t + b;
	    } else {
	      return -c / 2 * (--t * (t - 2) - 1) + b;
	    }
	  },
	  easeInCubic: function easeInCubic(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t + b;
	  },
	  easeOutCubic: function easeOutCubic(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t + 1) + b;
	  },
	  easeInOutCubic: function easeInOutCubic(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t + 2) + b;
	    }
	  },
	  easeInQuart: function easeInQuart(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t + b;
	  },
	  easeOutQuart: function easeOutQuart(t, b, _c, d) {
	    var c = _c - b;
	    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	  },
	  easeInOutQuart: function easeInOutQuart(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t + b;
	    } else {
	      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	    }
	  },
	  easeInQuint: function easeInQuint(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t * t + b;
	  },
	  easeOutQuint: function easeOutQuint(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	  },
	  easeInOutQuint: function easeInOutQuint(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	    }
	  },
	  easeInSine: function easeInSine(t, b, _c, d) {
	    var c = _c - b;
	    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	  },
	  easeOutSine: function easeOutSine(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sin(t / d * (Math.PI / 2)) + b;
	  },
	  easeInOutSine: function easeInOutSine(t, b, _c, d) {
	    var c = _c - b;
	    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	  },
	  easeInExpo: function easeInExpo(t, b, _c, d) {
	    var c = _c - b;
	    var _ref;
	    return (_ref = t === 0) !== null ? _ref : {
	      b: c * Math.pow(2, 10 * (t / d - 1)) + b
	    };
	  },
	  easeOutExpo: function easeOutExpo(t, b, _c, d) {
	    var c = _c - b;
	    var _ref;
	    return (_ref = t === d) !== null ? _ref : b + {
	      c: c * (-Math.pow(2, -10 * t / d) + 1) + b
	    };
	  },
	  easeInOutExpo: function easeInOutExpo(t, b, _c, d) {
	    var c = _c - b;
	    if (t === 0) {
	      b;
	    }
	    if (t === d) {
	      b + c;
	    }
	    if ((t /= d / 2) < 1) {
	      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
	    } else {
	      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	    }
	  },
	  easeInCirc: function easeInCirc(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	  },
	  easeOutCirc: function easeOutCirc(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
	  },
	  easeInOutCirc: function easeInOutCirc(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
	    } else {
	      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	    }
	  },
	  easeInElastic: function easeInElastic(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      b;
	    } else if ((t /= d) === 1) {
	      b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	  },
	  easeOutElastic: function easeOutElastic(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      b;
	    } else if ((t /= d) === 1) {
	      b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
	  },
	  easeInOutElastic: function easeInOutElastic(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      b;
	    } else if ((t /= d / 2) === 2) {
	      b + c;
	    }
	    if (!p) {
	      p = d * (0.3 * 1.5);
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    if (t < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	    } else {
	      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
	    }
	  },
	  easeInBack: function easeInBack(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    return c * (t /= d) * t * ((s + 1) * t - s) + b;
	  },
	  easeOutBack: function easeOutBack(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	  },
	  easeInOutBack: function easeInOutBack(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    if ((t /= d / 2) < 1) {
	      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
	    }
	  },
	  easeInBounce: function easeInBounce(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    v = tweenFunctions.easeOutBounce(d - t, 0, c, d);
	    return c - v + b;
	  },
	  easeOutBounce: function easeOutBounce(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d) < 1 / 2.75) {
	      return c * (7.5625 * t * t) + b;
	    } else if (t < 2 / 2.75) {
	      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
	    } else if (t < 2.5 / 2.75) {
	      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
	    } else {
	      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
	    }
	  },
	  easeInOutBounce: function easeInOutBounce(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    if (t < d / 2) {
	      v = tweenFunctions.easeInBounce(t * 2, 0, c, d);
	      return v * 0.5 + b;
	    } else {
	      v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);
	      return v * 0.5 + c * 0.5 + b;
	    }
	  }
	};
	
	exports.default = tweenFunctions;

/***/ },
/* 264 */
/*!************************************!*\
  !*** ./src/modules/annotations.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createReducer;
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setAnnotationProperties = setAnnotationProperties;
	exports.openAnnotation = openAnnotation;
	exports.closeAnnotation = closeAnnotation;
	exports.useCustomAnnotationFunction = useCustomAnnotationFunction;
	exports.getCustomAnnotationFunction = getCustomAnnotationFunction;
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 141);
	
	var _createReducer3 = _interopRequireDefault(_createReducer2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SET_ANNOTATION_PROPERTIES = 'SET_ANNOTATION_PROPERTIES';
	var USE_CUSTOM_ANNOTATION_FUNCTION = 'USE_CUSTOM_ANNOTATION_FUNCTION';
	
	/**
	 * Annotations
	 *
	 * @module annotations
	 * @public
	 *
	 */
	
	var initialState = (0, _immutable.Map)({
	  customAnnotationFn: null
	});
	
	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SET_ANNOTATION_PROPERTIES, function (state, _ref) {
	  var id = _ref.id;
	  var attrs = _ref.attrs;
	
	  var props = state.get('id') || (0, _immutable.Map)();
	  return state.set(id, props.merge(attrs));
	}), (0, _defineProperty3.default)(_createReducer, USE_CUSTOM_ANNOTATION_FUNCTION, function (state, annotationFn) {
	  return state.set('customAnnotationFn', annotationFn);
	}), _createReducer));
	
	function setAnnotationProperties(id, attrs) {
	  return { type: SET_ANNOTATION_PROPERTIES, payload: { id: id, attrs: attrs } };
	};
	
	/**
	 * Open annotation node in the player.
	 * @param {String} id - id of the annotation node.
	 * @public
	 */
	function openAnnotation(id) {
	  return { type: SET_ANNOTATION_PROPERTIES, payload: { id: id, attrs: { pinned: true, open: true } } };
	};
	
	/**
	 * Close annotation node.
	 * @param {String} id - id of the annotation node.
	 * @public
	 */
	function closeAnnotation(id) {
	  return { type: SET_ANNOTATION_PROPERTIES, payload: { id: id, attrs: { pinned: false, open: false } } };
	};
	
	/**
	 * Use custom annotations. Set a custom function that will be called for every
	 * annotation on every scene update. The arguments passed to this function
	 * will be the [annotation object](global.html#Annotation), and the div that
	 * any annotations may be created under. This div has `pointer-events` set
	 * to none so that the scene below it will receive all mouse/touch events.
	 * If you wish to handle events in your annotations, make sure to set `pointer-events`.
	 *
	 * @public
	 * @param {Function} fn The function to be called for every annotation update.
	 */
	function useCustomAnnotationFunction(fn) {
	  return { type: USE_CUSTOM_ANNOTATION_FUNCTION, payload: fn };
	};
	
	function getCustomAnnotationFunction(store) {
	  return store.getIn(['annotations', 'customAnnotationFn']);
	};
	
	var publicApi = {
	  reducer: reducer,
	  actions: {
	    setAnnotationProperties: setAnnotationProperties, openAnnotation: openAnnotation, closeAnnotation: closeAnnotation,
	    useCustomAnnotationFunction: useCustomAnnotationFunction
	  },
	  selectors: { getCustomAnnotationFunction: getCustomAnnotationFunction }
	};
	
	exports.default = publicApi;

/***/ },
/* 265 */
/*!*******************************!*\
  !*** ./src/modules/player.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createReducer;
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.manipulators = exports.RENDER_MODES = undefined;
	exports.useManipulator = useManipulator;
	exports.getActiveManipulator = getActiveManipulator;
	exports.addTool = addTool;
	exports.removeTool = removeTool;
	exports.showTool = showTool;
	exports.hideTool = hideTool;
	exports.updateToolOptions = updateToolOptions;
	exports.getRect = getRect;
	exports.setRect = setRect;
	exports.setCameraAttrs = setCameraAttrs;
	exports.getCameraAttrs = getCameraAttrs;
	exports.getCameraWorldTransform = getCameraWorldTransform;
	exports.useCamera = useCamera;
	exports.useVrCamera = useVrCamera;
	exports.setCamera = setCamera;
	exports.setThreeScene = setThreeScene;
	exports.getThreeScene = getThreeScene;
	exports.getThreeCamera = getThreeCamera;
	exports.getBoundingBox = getBoundingBox;
	exports.getCamera = getCamera;
	exports.getTools = getTools;
	exports.setCameraPosition = setCameraPosition;
	exports.getInitialCameraPosition = getInitialCameraPosition;
	exports.requestFullscreen = requestFullscreen;
	exports.exitFullscreen = exitFullscreen;
	exports.toggleFullscreen = toggleFullscreen;
	exports.isFullscreen = isFullscreen;
	exports.setFullscreen = setFullscreen;
	exports.getRenderingMode = getRenderingMode;
	exports.isNormalRenderingMode = isNormalRenderingMode;
	exports.isVRMode = isVRMode;
	exports.isLenticularMode = isLenticularMode;
	exports.activateTool = activateTool;
	exports.isToolActive = isToolActive;
	exports.getActiveTools = getActiveTools;
	exports.requestLenticularMode = requestLenticularMode;
	exports.requestNormalMode = requestNormalMode;
	exports.getPrevCamera = getPrevCamera;
	exports.setRenderMode = setRenderMode;
	exports.toggleLenticularMode = toggleLenticularMode;
	exports.enableDeviceTracking = enableDeviceTracking;
	exports.disableDeviceTracking = disableDeviceTracking;
	exports.toggleDeviceTracking = toggleDeviceTracking;
	exports.isDeviceTracking = isDeviceTracking;
	exports.setPlayerElement = setPlayerElement;
	exports.setActiveColor = setActiveColor;
	exports.setHoverColor = setHoverColor;
	exports.setFullscreenBGColor = setFullscreenBGColor;
	exports.getActiveColor = getActiveColor;
	exports.getHoverColor = getHoverColor;
	exports.getFullscreenBGColor = getFullscreenBGColor;
	exports.animateCameraTo = animateCameraTo;
	exports.resize = resize;
	exports.filterNodesFromPosition = filterNodesFromPosition;
	exports.setCameraRadiusConstraint = setCameraRadiusConstraint;
	exports.getCameraRadiusConstraint = getCameraRadiusConstraint;
	exports.displayThumbnail = displayThumbnail;
	exports.shouldDisplayThumbnail = shouldDisplayThumbnail;
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 141);
	
	var _createReducer3 = _interopRequireDefault(_createReducer2);
	
	var _scene = __webpack_require__(/*! ./scene */ 147);
	
	var _animation = __webpack_require__(/*! ./animation */ 132);
	
	var _sceneGraph = __webpack_require__(/*! ./sceneGraph */ 142);
	
	var _updateCameraLookAtTarget = __webpack_require__(/*! ../translators/utils/updateCameraLookAtTarget */ 266);
	
	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);
	
	var _calculateBoundingBox = __webpack_require__(/*! ../translators/utils/calculateBoundingBox */ 267);
	
	var _calculateBoundingBox2 = _interopRequireDefault(_calculateBoundingBox);
	
	var _camera = __webpack_require__(/*! ../translators/camera */ 268);
	
	var _setMatrixOnNode = __webpack_require__(/*! ../translators/utils/setMatrixOnNode */ 271);
	
	var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);
	
	var _decompose = __webpack_require__(/*! ../translators/utils/decompose */ 272);
	
	var _decompose2 = _interopRequireDefault(_decompose);
	
	var _getTargetWorldMatrix = __webpack_require__(/*! ../translators/utils/getTargetWorldMatrix */ 269);
	
	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);
	
	var _commands = __webpack_require__(/*! ./commands */ 275);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RENDER_MODES = exports.RENDER_MODES = {
	  normal: 'normal',
	  vr: 'vr',
	  lenticular: 'lenticular'
	};
	
	/**
	 * This module supports the UI for the player.
	 *
	 * @module player
	 * @public
	 */
	
	var manipulators = exports.manipulators = {
	  orbit: 'orbit',
	  pan: 'pan',
	  zoom: 'zoom',
	  nodeRotate: 'nodeRotate',
	  nodeMove: 'nodeMove',
	  nodeScale: 'nodeScale'
	};
	
	var USE_MANIPULATOR = 'USE_MANIPULATOR';
	var SET_CAMERA = 'SET_CAMERA';
	var SET_PREV_CAMERA = 'SET_PREV_CAMERA';
	var SET_CAMERA_ATTRS = 'SET_CAMERA_ATTRS';
	var SET_CAMERA_POSITION = 'SET_CAMERA_POSITION';
	var SET_RECT = 'SET_RECT';
	var DISPLAY_THUMBNAIL = 'DISPLAY_THUMBNAIL';
	var SET_ACTIVE_COLOR = 'SET_ACTIVE_COLOR';
	var SET_HOVER_COLOR = 'SET_HOVER_COLOR';
	var SET_PLAYER_ELEMENT = 'SET_PLAYER_ELEMENT';
	var REQUEST_FULL_SCREEN = 'REQUEST_FULL_SCREEN';
	var EXIT_FULL_SCREEN = 'EXIT_FULL_SCREEN';
	var SET_FULL_SCREEN = 'SET_FULL_SCREEN';
	var SET_RENDER_MODE = 'SET_RENDER_MODE';
	
	var REQUEST_NORMAL_MODE = 'REQUEST_NORMAL_MODE';
	var REQUEST_LENTICULAR_MODE = 'REQUEST_LENTICULAR_MODE';
	var SET_DEVICE_TRACKING = 'SET_DEVICE_TRACKING';
	var SET_BACKGROUND_COLOR = 'SET_BACKGROUND_COLOR';
	var REQUEST_STEREO_MODE = 'REQUEST_STEREO_MODE';
	var REQUEST_PARALLAX_MODE = 'REQUEST_PARALLAX_MODE';
	var EXIT_STEREOPARALLAX_MODE = 'EXIT_STEREOPARALLAX_MODE';
	var SET_CONSTRAIN_CAMERA_RADIUS = 'SET_CONSTRAIN_CAMERA_RADIUS';
	var SET_THREE_SCENE = 'SET_THREE_SCENE';
	
	var initialState = (0, _immutable.Map)({
	  activeColor: '#ffc85f',
	  hoverColor: '#C08618',
	  fullscreenBackgroundColor: '#FFF',
	  activeManipulator: manipulators.orbit,
	  fullScreen: false,
	  renderingMode: RENDER_MODES.normal,
	  deviceTracking: false,
	  camera: (0, _immutable.Map)({
	    polarAngle: null, azimuthAngle: null, boundingRadius: null
	  }),
	  rect: (0, _immutable.Map)({ width: 400, height: 300 }),
	  initialCameraWorldMatrix: null,
	  initialTargetWorldMatrix: null,
	  cameraWorldMatrix: null,
	  displayThumbnail: true,
	  playerElement: null,
	  canvasElement: null,
	  activeCamera: _sceneGraph.virtualCameraId,
	  vrCamera: _sceneGraph.vrCameraId,
	  threeScene: null,
	  prevCamera: null,
	  orientationHandler: null,
	  constrainCameraRadius: null
	});
	
	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, USE_MANIPULATOR, function (state, manipulator) {
	  return state.set('activeManipulator', manipulator);
	}), (0, _defineProperty3.default)(_createReducer, SET_CAMERA, function (state, _ref) {
	  var id = _ref.id;
	  var prevCameraId = _ref.prevCameraId;
	
	  return state.set('activeCamera', id).set('prevCamera', prevCameraId);
	}), (0, _defineProperty3.default)(_createReducer, SET_CAMERA_ATTRS, function (state, attrs) {
	  return state.mergeIn(['camera'], attrs);
	}), (0, _defineProperty3.default)(_createReducer, SET_RECT, function (state, rect) {
	  return state.set('rect', rect);
	}), (0, _defineProperty3.default)(_createReducer, SET_CAMERA_POSITION, function (state, attrs) {
	  return state.merge(attrs);
	}), (0, _defineProperty3.default)(_createReducer, SET_PLAYER_ELEMENT, function (state, _ref2) {
	  var playerEl = _ref2.playerEl;
	  var canvasEl = _ref2.canvasEl;
	
	  return state.set('playerElement', playerEl).set('canvasElement', canvasEl);
	}), (0, _defineProperty3.default)(_createReducer, DISPLAY_THUMBNAIL, function (state, display) {
	  return state.set('displayThumbnail', !!display);
	}), (0, _defineProperty3.default)(_createReducer, SET_ACTIVE_COLOR, function (state, color) {
	  return state.set('activeColor', color);
	}), (0, _defineProperty3.default)(_createReducer, SET_HOVER_COLOR, function (state, color) {
	  return state.set('hoverColor', color);
	}), (0, _defineProperty3.default)(_createReducer, SET_BACKGROUND_COLOR, function (state, color) {
	  return state.set('fullscreenBackgroundColor', color);
	}), (0, _defineProperty3.default)(_createReducer, REQUEST_FULL_SCREEN, function (state) {
	  return state.set('fullScreen', true);
	}), (0, _defineProperty3.default)(_createReducer, EXIT_FULL_SCREEN, function (state) {
	  return state.set('fullScreen', false);
	}), (0, _defineProperty3.default)(_createReducer, SET_FULL_SCREEN, function (state, fullScreen) {
	  return state.set('fullScreen', fullScreen);
	}), (0, _defineProperty3.default)(_createReducer, SET_RENDER_MODE, function (state, mode) {
	  return state.set('renderingMode', mode);
	}), (0, _defineProperty3.default)(_createReducer, REQUEST_LENTICULAR_MODE, function (state, _ref3) {
	  var trackDevice = _ref3.trackDevice;
	  var cameraId = _ref3.cameraId;
	
	  return state.merge({
	    renderingMode: 'lenticular',
	    deviceTracking: trackDevice,
	    prevCamera: cameraId
	  });
	}), (0, _defineProperty3.default)(_createReducer, REQUEST_NORMAL_MODE, function (state) {
	  return state.merge({
	    renderingMode: 'normal',
	    deviceTracking: false
	  });
	}), (0, _defineProperty3.default)(_createReducer, SET_DEVICE_TRACKING, function (state, deviceTracking) {
	  return state.set('deviceTracking', deviceTracking);
	}), (0, _defineProperty3.default)(_createReducer, SET_CONSTRAIN_CAMERA_RADIUS, function (state, radius) {
	  return state.set('constrainCameraRadius', radius);
	}), (0, _defineProperty3.default)(_createReducer, SET_THREE_SCENE, function (state, _ref4) {
	  var scene = _ref4.scene;
	  var camera = _ref4.camera;
	
	  return state.set('threeScene', scene).set('threeCamera', camera);
	}), _createReducer));
	
	function useManipulator(manipulator) {
	  return { type: USE_MANIPULATOR, payload: manipulator };
	}
	
	function getActiveManipulator(store) {
	  return store.getIn(['player', 'activeManipulator']);
	}
	
	/**
	 * Add a tool (See {@tutorial sdk-Tools})
	 *
	 * @public
	 * @param {Tool} Tool
	 * @param {String} name provide a name for the tool to allow removing it.
	 * @returns {Promise}
	 *
	 */
	function addTool(tool, name) {
	  return (0, _commands.addCommand)({ tool: tool, enabled: true }, name);
	}
	
	/**
	 * Remove a tool (See {@tutorial sdk-Tools})
	 *
	 * @public
	 * @param {String} name The name of the tool to remove
	 * @returns {Promise}
	 */
	function removeTool(name) {
	  return (0, _commands.removeCommand)(name);
	}
	
	function showTool(name) {
	  return (0, _commands.updateCommand)(name, { display: { playerTools: true } });
	}
	
	function hideTool(name) {
	  return (0, _commands.updateCommand)(name, { display: { playerTools: false } });
	}
	
	function updateToolOptions(name, options) {
	  return { type: UPDATE_COMMAND_OPTIONS, payload: { name: name, options: options } };
	}
	
	function getRect(store) {
	  return store.getIn(['player', 'rect']);
	}
	
	function setRect(rect) {
	  return { type: SET_RECT, payload: rect };
	}
	
	function setCameraAttrs(attrs) {
	  return { type: SET_CAMERA_ATTRS, payload: attrs };
	}
	
	function getCameraAttrs(store) {
	  return store.getIn(['player', 'camera']);
	}
	
	/**
	 * Returns the world matrix of the active camera
	 */
	function getCameraWorldTransform(store) {
	  return (0, _scene.getWorldTransform)(store, store.getIn(['player', 'activeCamera']));
	}
	
	/**
	 * This sets the scene to use the camera.
	 */
	function useCamera(id) {
	  return function (store) {
	    // store.dispatch(setCamera(id, getCamera(store)));
	    store.dispatch((0, _scene.set)({ scene: true, plug: 'Player', property: 'camera' }, id));
	  };
	}
	
	function useVrCamera(switchToVR) {
	  return function (store) {
	    if (switchToVR) {
	      var activeCamera = store.getIn(['player', 'activeCamera']);
	      store.dispatch(setCamera(_sceneGraph.vrCameraId, activeCamera));
	    } else {
	      var prevCamera = store.getIn(['player', 'prevCamera']) || _sceneGraph.virtualCameraId;
	      store.dispatch(setCamera(prevCamera, null));
	    }
	  };
	}
	
	/**
	 * Sets the active camera for the scene
	 * @private
	 */
	function setCamera(id, prevCameraId) {
	  return function (store) {
	    var target = (0, _getTargetWorldMatrix2.default)(store, prevCameraId);
	    var oldCamData = (0, _scene.get)(store, { id: prevCameraId, evalPlug: 'Camera' });
	    var oldCameraTransform = (0, _scene.get)(store, { id: prevCameraId, evalPlug: 'Transform' });
	    if (oldCameraTransform && !oldCameraTransform.target) {
	      oldCamData.targetWorldMatrix = target;
	    }
	
	    var newCamData = (0, _scene.get)(store, { id: id, evalPlug: 'Camera' });
	    if (newCamData.targetWorldMatrix) {
	      store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(newCamData.targetWorldMatrix)));
	      newCamData.targetWorldMatrix = null;
	    }
	
	    store.dispatch({ type: SET_CAMERA, payload: { id: id, prevCameraId: prevCameraId } });
	  };
	}
	
	/**
	 * @private
	 */
	function setThreeScene(scene, camera) {
	  return { type: SET_THREE_SCENE, payload: { scene: scene, camera: camera } };
	}
	
	function getThreeScene(store) {
	  return store.getIn(['player', 'threeScene']);
	}
	
	function getThreeCamera(store) {
	  return store.getIn(['player', 'threeCamera']);
	}
	
	function getBoundingBox(store) {
	  var threeScene = getThreeScene(store);
	  return (0, _calculateBoundingBox2.default)(threeScene);
	}
	
	/**
	 * Returns the current active camera
	 * @public
	 */
	function getCamera(store) {
	  return store.getIn(['player', 'activeCamera']);
	}
	
	function getTools(store) {
	  return store.getIn(['player', 'tools']);
	}
	
	function setCameraPosition(attrs) {
	  return { type: SET_CAMERA_POSITION, payload: attrs };
	}
	
	function getInitialCameraPosition(store) {
	  return {
	    initialCameraWorldMatrix: store.getIn(['player', 'initialCameraWorldMatrix']),
	    initialTargetWorldMatrix: store.getIn(['player', 'initialTargetWorldMatrix'])
	  };
	}
	
	/**
	 *
	 * Enable fullscreen mode.
	 * @public
	 *
	 */
	function requestFullscreen() {
	  return function (store) {
	    var playerEl = store.getIn(['player', 'playerElement']);
	    ['requestFullscreen', 'webkitRequestFullscreen', 'mozRequestFullScreen', 'msRequestFullscreen'].forEach(function (fn) {
	      if (playerEl[fn]) return playerEl[fn]();
	    });
	    store.dispatch({ type: REQUEST_FULL_SCREEN });
	  };
	}
	
	/**
	 * Exit fullscreen mode
	 * @public
	 */
	function exitFullscreen() {
	  return function (store) {
	    ['exitFullscreen', 'webkitExitFullscreen', 'mozCancelFullScreen', 'msExitFullscreen'].forEach(function (fn) {
	      if (document[fn]) return document[fn]();
	    });
	    return store.dispatch({ type: EXIT_FULL_SCREEN });
	  };
	};
	
	/**
	 * Toggle fullscreen mode
	 * @public
	 *
	 */
	function toggleFullscreen() {
	  return function (store) {
	    return store.dispatch(isFullscreen(store) ? exitFullscreen() : requestFullscreen());
	  };
	};
	
	/**
	 * Check whether were in fullscreen mode.
	 * @public
	 *
	 */
	function isFullscreen(store) {
	  return store.getIn(['player', 'fullScreen']);
	};
	
	/**
	 * Set the value of fullscreen (set on an event handler, if the native
	 * browser control is used to escape full screen mode.
	 */
	function setFullscreen(fullScreen) {
	  return function (store) {
	    if (isFullscreen(store) !== fullScreen) {
	      store.dispatch({ type: SET_FULL_SCREEN, payload: fullScreen });
	    }
	    if (!fullScreen && isVRMode(store)) {
	      store.dispatch((0, _commands.deactivateCommand)('vrMode'));
	    }
	  };
	};
	
	function getRenderingMode(store) {
	  return store.getIn(['player', 'renderingMode']);
	}
	
	/**
	 * @public
	 *
	 */
	function isNormalRenderingMode(store) {
	  return store.getIn(['player', 'renderingMode']) === RENDER_MODES.normal;
	};
	
	/**
	 * Check whether we are in VR mode.
	 * @public
	 *
	 */
	function isVRMode(store) {
	  return store.getIn(['player', 'renderingMode']) === RENDER_MODES.vr;
	};
	
	/**
	 * Check whether we are in Lenticular rendering mode.
	 * @public
	 */
	function isLenticularMode(store) {
	  return store.getIn(['player', 'renderingMode']) === RENDER_MODES.lenticular;
	};
	
	function activateTool(toolName) {
	  return function (store) {
	    var tool = store.getIn(['player', 'tools', toolName]);
	    if (!tool) return;
	    if (tool.get('action')) return tool.get('action')(store);
	    var isActive = _isToolActive(store, tool);
	    if (tool.get('activate') && !isActive) return tool.get('activate')(store);
	    if (tool.get('deactivate') && isActive) return tool.get('deactivate')(store);
	    return store.dispatch(useManipulator(toolName));
	  };
	}
	
	function _isToolActive(store, tool) {
	  if (tool.get('isActive')) return tool.get('isActive')(store);
	  return store.getIn(['player', 'activeManipulator']) === tool.get('name');
	}
	
	function isToolActive(store, toolName) {
	  var tool = store.getIn(['player', 'tools', toolName]);
	  return tool && _isToolActive(store, tool);
	}
	
	function getActiveTools(store) {
	  return store.getIn(['player', 'tools']).filter(function (tool) {
	    return _isToolActive(store, tool);
	  });
	}
	
	function requestLenticularMode(_ref5) {
	  var trackDevice = _ref5.trackDevice;
	
	  return function (store) {
	    store.dispatch(requestFullscreen());
	    var cameraId = getCamera(store);
	    store.dispatch({ type: REQUEST_LENTICULAR_MODE, payload: { trackDevice: trackDevice, cameraId: cameraId } });
	  };
	};
	
	function requestNormalMode() {
	  return { type: REQUEST_NORMAL_MODE };
	};
	
	function getPrevCamera(store) {
	  return store.getIn(['player', 'prevCamera']);
	}
	
	function setRenderMode(mode) {
	  if (!RENDER_MODES[mode]) throw new Error('Invalid Render Mode: ' + mode);
	  return { type: SET_RENDER_MODE, payload: mode };
	}
	
	function toggleLenticularMode() {
	  return function (store) {
	    store.dispatch(isLenticularMode(store) ? requestNormalMode() : requestLenticularMode({}));
	  };
	};
	
	function enableDeviceTracking() {
	  return { type: SET_DEVICE_TRACKING, payload: true };
	};
	
	function disableDeviceTracking() {
	  return { type: SET_DEVICE_TRACKING, payload: false };
	};
	
	function toggleDeviceTracking() {
	  return function (store) {
	    console.log('toggle device tracking', !isDeviceTracking(store));
	    store.dispatch(isDeviceTracking(store) ? disableDeviceTracking() : enableDeviceTracking());
	  };
	};
	
	function isDeviceTracking(store) {
	  return store.getIn(['player', 'deviceTracking']);
	};
	
	/**
	 * Store the rendered player element
	 */
	function setPlayerElement(playerEl, canvasEl) {
	  return { type: SET_PLAYER_ELEMENT, payload: { playerEl: playerEl, canvasEl: canvasEl } };
	};
	
	/**
	 * Set the active color and timeline color to be used for the player css.
	 *
	 * @public
	 * @param {Color} color a valid css color (ex. '#ff0000'}.
	 * @returns {Promise}
	 *
	 */
	function setActiveColor(color) {
	  return { type: SET_ACTIVE_COLOR, payload: color };
	};
	
	/**
	 * Set the hover color to be used for the player css.
	 *
	 * @public
	 * @param {Color} color a valid css color (ex. '#ff0000'}.
	 * @returns {Promise}
	 *
	 */
	function setHoverColor(color) {
	  return { type: SET_HOVER_COLOR, payload: color };
	};
	
	/**
	 * Set the fullscreen background color to be used for the player css.
	 *
	 * @public
	 * @param {Color} color a valid css color (ex. '#ff0000'}.
	 * @returns {Promise}
	 *
	 */
	function setFullscreenBGColor(color) {
	  return { type: SET_BACKGROUND_COLOR, payload: color };
	};
	
	/**
	 * Return the active color.
	 *
	 * @public
	 */
	function getActiveColor(store) {
	  return store.getIn(['player', 'activeColor']);
	};
	
	/**
	 * Return the hover color.
	 *
	 * @public
	 */
	function getHoverColor(store) {
	  return store.getIn(['player', 'hoverColor']);
	};
	
	/**
	 * Return the fullscreen background color.
	 *
	 * @public
	 */
	function getFullscreenBGColor(store) {
	  return store.getIn(['player', 'fullscreenBackgroundColor']);
	};
	
	function slerpTween(startMatrix, endMatrix) {
	  var startPosition = new _three2.default.Vector3();
	  var startQuaternion = new _three2.default.Quaternion();
	  var scale = new _three2.default.Vector3(1, 1, 1);
	  startMatrix.decompose(startPosition, startQuaternion, scale);
	
	  var endPosition = new _three2.default.Vector3();
	  var endQuaternion = new _three2.default.Quaternion();
	  endMatrix.decompose(endPosition, endQuaternion, scale);
	
	  var position = new _three2.default.Vector3();
	  var quaternion = new _three2.default.Quaternion();
	  scale.set(1, 1, 1);
	  var matrix = new _three2.default.Matrix4();
	
	  return function (time, start, end, duration) {
	    position.lerpVectors(startPosition, endPosition, time / duration);
	    _three2.default.Quaternion.slerp(startQuaternion, endQuaternion, quaternion, time / duration);
	    matrix.compose(position, quaternion, scale);
	    return matrix;
	  };
	};
	
	/**
	 * Animate the camera to the position of another.
	 *
	 * @public
	 * @param {String} id - the id of the camera to move to.
	 * @param {Number} duration - length of the animation (ms), default 300.
	 * @returns {Promise}
	 */
	function animateCameraTo(id, duration) {
	  return function (store) {
	    var cameraId = getCamera(store);
	    if (!cameraId) return;
	
	    return store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Transform', property: 'target' }, null)).then(function () {
	      var currentCameraTransform = (0, _scene.getWorldTransform)(store, cameraId);
	      var newCameraTransform = (0, _camera.initCamera)(store, false, id);
	      var actualDuration = duration || 300;
	
	      return new _promise2.default(function (resolve, reject) {
	        store.dispatch((0, _animation.queueAnimation)({
	          autoplay: true,
	          name: 'Move Camera',
	          iterations: 1,
	          tracks: [{
	            duration: actualDuration,
	            value: newCameraTransform,
	            startValue: currentCameraTransform,
	            tween: slerpTween(currentCameraTransform, newCameraTransform),
	            set: function set(_path, to) {
	              (0, _setMatrixOnNode2.default)(store, cameraId, to);
	            }
	          }],
	          onEnd: function onEnd() {
	            resolve(store.dispatch(useCamera(id)));
	          }
	        }));
	      });
	    });
	  };
	};
	
	/**
	 * Trigger a resize event. If you manually resize the player's dom element,
	 * use this to force the player to rerender with the updated size.
	 *
	 * @public
	 */
	function resize() {
	  return function (store) {
	    var translator = store.getTranslator();
	    if (translator) translator.resize();
	  };
	};
	
	/**
	 * Given a manipulator event, return the list of node ids at that position
	 *
	 * @public
	 * @param {Event} event generated by the manipulator interface. (See {@tutorial sdk-Tools})
	 * @returns {Array} list of node ids found.
	 *
	 * @example
	 *
	 * api.player.addTool({
	 *   click: (ev) => {
	 *     var nodes = api.player.filterNodesFromPosition(ev);
	 *     console.log('Found: ', nodes.map((id) => api.scene.get({id: id, property: 'name'})));
	 *   }
	 * }, 'FindNode');
	 *
	 */
	function filterNodesFromPosition(store, event) {
	  var translator = store.getTranslator();
	  if (!translator || !translator.raycastSelect) return null;
	  var x = event.clientX / (event.rect.width / 2) - 1;
	  var y = -(event.clientY / (event.rect.height / 2) - 1);
	  var hits = translator.raycastSelect({ x: x, y: y });
	  return hits.map(function (hit) {
	    return hit.id;
	  });
	};
	
	/**
	* Will constrain the target of the camera to remain inside the bounding sphere of the scene.
	* The camera will not be allowed to enter the bounding sphere of the scene nor leave  bounding sphere defined by arguments
	*
	* @public
	* @param {Number} radius distance around the center of the scene that defineds outer bounding sphere, setting radius to null disables bounding spheres
	*/
	function setCameraRadiusConstraint(radius) {
	  return function (store) {
	    store.dispatch({ type: SET_CONSTRAIN_CAMERA_RADIUS, payload: radius });
	    var cameraId = getCamera(store);
	    if (!cameraId) return;
	
	    // Store the radius constraint in the camera data, and touch the cameraNode
	    // to rerender
	    var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	    if (cameraData) {
	      if (!cameraData.radiusConstraint || cameraData.radiusConstraint.radius !== radius) {
	        cameraData.newRadiusConstraint = radius;
	      }
	    }
	    store.dispatch((0, _sceneGraph.touch)(cameraId));
	  };
	}
	
	function getCameraRadiusConstraint(store) {
	  return store.getIn(['player', 'constrainCameraRadius']);
	};
	
	/**
	 * Turn thumbnail display on or off
	 * @public
	 * @param {Boolean} display - Display thumbnail (default true)
	 */
	function displayThumbnail(display) {
	  return { type: DISPLAY_THUMBNAIL, payload: display };
	};
	
	function shouldDisplayThumbnail(store) {
	  return store.getIn(['player', 'displayThumbnail']);
	};
	
	var publicApi = {
	  reducer: reducer,
	  actions: { addTool: addTool, removeTool: removeTool, showTool: showTool, hideTool: hideTool, useManipulator: useManipulator,
	    setCameraAttrs: setCameraAttrs, useCamera: useCamera, setCameraPosition: setCameraPosition, animateCameraTo: animateCameraTo, resize: resize,
	    displayThumbnail: displayThumbnail, setActiveColor: setActiveColor, requestFullscreen: requestFullscreen, exitFullscreen: exitFullscreen, setFullscreen: setFullscreen,
	    toggleFullscreen: toggleFullscreen, setHoverColor: setHoverColor, requestLenticularMode: requestLenticularMode,
	    enableDeviceTracking: enableDeviceTracking, disableDeviceTracking: disableDeviceTracking, toggleDeviceTracking: toggleDeviceTracking,
	    requestNormalMode: requestNormalMode, setFullscreenBGColor: setFullscreenBGColor,
	    setCameraRadiusConstraint: setCameraRadiusConstraint, updateToolOptions: updateToolOptions
	  },
	  selectors: { getCamera: getCamera, getCameraAttrs: getCameraAttrs, getInitialCameraPosition: getInitialCameraPosition, getCameraWorldTransform: getCameraWorldTransform,
	    getActiveColor: getActiveColor, isFullscreen: isFullscreen, isVRMode: isVRMode, isLenticularMode: isLenticularMode, getFullscreenBGColor: getFullscreenBGColor,
	    isDeviceTracking: isDeviceTracking, shouldDisplayThumbnail: shouldDisplayThumbnail, filterNodesFromPosition: filterNodesFromPosition,
	    getThreeScene: getThreeScene, getThreeCamera: getThreeCamera
	  }
	};
	exports.default = publicApi;

/***/ },
/* 266 */
/*!***********************************************************!*\
  !*** ./src/translators/utils/updateCameraLookAtTarget.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = updateCameraLookAtTarget;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var targetPosition = new _three2.default.Vector3();
	var cameraPosition = new _three2.default.Vector3();
	var targetUp = new _three2.default.Vector3(0, 1, 1);
	var lookAtMatrix = new _three2.default.Matrix4();
	var lookAtPosition = new _three2.default.Vector3();
	var lookAtScale = new _three2.default.Vector3();
	var lookAtRotation = new _three2.default.Quaternion();
	var cameraScale = new _three2.default.Vector3();
	var cameraRotation = new _three2.default.Quaternion();
	
	function updateCameraLookAtTarget(cameraWorldMatrix, targetWorldMatrix, upPosition) {
	  // console.trace('navigator.updateCameraLookAtTarget');
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	  targetPosition.setFromMatrixPosition(targetWorldMatrix);
	  // var te = targetWorldMatrix.elements;
	  //targetUp.set(0, 1, 0); // .applyMatrix4( targetWorldMatrix );
	  // console.log( "targetUp", JSON.stringify( targetUp ) );
	  //console.log(upPosition);
	  lookAtMatrix.makeTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z);
	  lookAtMatrix.lookAt(cameraPosition, targetPosition, upPosition || targetUp);
	  lookAtMatrix.decompose(lookAtPosition, lookAtRotation, lookAtScale);
	
	  cameraWorldMatrix.decompose(cameraPosition, cameraRotation, cameraScale);
	  cameraWorldMatrix.compose(cameraPosition, lookAtRotation, cameraScale);
	}

/***/ },
/* 267 */
/*!*******************************************************!*\
  !*** ./src/translators/utils/calculateBoundingBox.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = calculateBoundingBox;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function calculateBoundingBox(object) {
	  var box = new _three2.default.Box3();
	  var result = new _three2.default.Box3();
	
	  var objectsRoot = object;
	  object.children.forEach(function (child) {
	    if (child.type === "Object3D" && child.name === "Objects") objectsRoot = child;
	  });
	
	  result.makeEmpty();
	
	  object.updateMatrixWorld(true);
	
	  objectsRoot.traverse(function (node) {
	    if (!node.visible) return;
	    if (!node.geometry) return;
	
	    var geometry = node.geometry;
	
	    if (geometry.boundingBox === null) {
	      geometry.computeBoundingBox();
	    }
	
	    if (geometry.boundingBox.isEmpty() === false) {
	      box.copy(geometry.boundingBox);
	      node.matrix.compose(node.position, node.quaternion, node.scale);
	      node.updateMatrixWorld(true);
	      box.applyMatrix4(node.matrixWorld);
	      result.union(box);
	    }
	  });
	
	  return result;
	}

/***/ },
/* 268 */
/*!***********************************!*\
  !*** ./src/translators/camera.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.resizeCamera = resizeCamera;
	exports.updateLookatTarget = updateLookatTarget;
	exports.initCamera = initCamera;
	exports.initCameraRadiusConstraint = initCameraRadiusConstraint;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _scene = __webpack_require__(/*! ../modules/scene */ 147);
	
	var _getTargetWorldMatrix = __webpack_require__(/*! ./utils/getTargetWorldMatrix */ 269);
	
	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);
	
	var _updateCameraLookAtTarget = __webpack_require__(/*! ./utils/updateCameraLookAtTarget */ 266);
	
	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);
	
	var _player = __webpack_require__(/*! ../modules/player */ 265);
	
	var _sceneGraph = __webpack_require__(/*! ../modules/sceneGraph */ 142);
	
	var _clamp = __webpack_require__(/*! ./utils/clamp */ 270);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _setMatrixOnNode = __webpack_require__(/*! ./utils/setMatrixOnNode */ 271);
	
	var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);
	
	var _orbit = __webpack_require__(/*! ./tools/orbit */ 273);
	
	var _zoom = __webpack_require__(/*! ./tools/zoom */ 274);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _THREE$Math = _three2.default.Math;
	var degToRad = _THREE$Math.degToRad;
	var radToDeg = _THREE$Math.radToDeg;
	var _Math = Math;
	var tan = _Math.tan;
	var cos = _Math.cos;
	var atan = _Math.atan;
	var acos = _Math.acos;
	var min = _Math.min;
	var max = _Math.max;
	var pow = _Math.pow;
	var PI = _Math.PI;
	var sqrt = _Math.sqrt;
	
	// Temporary variables for intermediate calculations
	
	var t_cameraPosition = new _three2.default.Vector3();
	var t_oldTargetPosition = new _three2.default.Vector3();
	var t_targetPosition = new _three2.default.Vector3();
	var t_sphericalCamera = new _three2.default.Spherical();
	var t_sphericalTarget = new _three2.default.Spherical();
	var t_invTargetWorldMatrix = new _three2.default.Matrix4();
	var t_invPivotMatrix = new _three2.default.Matrix4();
	var t_changeQuaternion = new _three2.default.Quaternion();
	
	function resizeCamera(store, cameraId, rect) {
	  var aspectRatio = rect.x / rect.y;
	  store.dispatch((0, _player.setRect)(rect));
	  var name = (0, _sceneGraph.get)(store, [cameraId, 'name']);
	  if (name) store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Camera', property: 'aspectRatio' }, aspectRatio));
	}
	
	function updateLookatTarget(store, cameraId, transformData, cameraData) {
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
	  var oldTargetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId, transformData);
	
	  if (playerData.orbitMode === 'trackball') {
	    t_cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	    t_oldTargetPosition.setFromMatrixPosition(oldTargetWorldMatrix).sub(t_cameraPosition).normalize();
	    t_targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(t_cameraPosition).normalize();
	
	    t_changeQuaternion.setFromUnitVectors(t_targetPosition, t_oldTargetPosition);
	    cameraData.upPosition.applyQuaternion(t_changeQuaternion);
	  }
	
	  t_targetPosition.setFromMatrixPosition(targetWorldMatrix);
	  cameraData.pivotMatrix.setPosition(t_targetPosition.sub(cameraData.offset));
	
	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	  return cameraWorldMatrix;
	}
	
	function initCamera(store, dispatch, fromCameraId, toCameraId, fromRect) {
	  var toId = toCameraId || _sceneGraph.virtualCameraId;
	  var fromId = fromCameraId || _sceneGraph.virtualCameraId;
	  var boundingBox = (0, _player.getBoundingBox)(store);
	  var rect = fromRect || (0, _player.getRect)(store);
	  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, fromId);
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, fromId);
	  var cameraPosition = new _three2.default.Vector3().setFromMatrixPosition(cameraWorldMatrix);
	
	  resizeCamera(store, toId, rect);
	
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var fromCameraData = (0, _scene.get)(store, { id: fromId, evalPlug: 'Camera' });
	  var toCameraData = fromId === toId ? fromCameraData : (0, _scene.get)(store, { id: toId, evalPlug: 'Camera' });
	
	  var pivotMatrix = targetWorldMatrix.clone();
	  var pivotPosition = new _three2.default.Vector3().setFromMatrixPosition(pivotMatrix);
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix).sub(pivotPosition);
	
	  var upPosition = new _three2.default.Vector3(0, 1, 0);
	  if (playerData.orbitMode === 'trackball') {
	    upPosition.transformDirection(cameraWorldMatrix);
	
	    var normal = new _three2.default.Vector3().copy(cameraPosition).normalize();
	    var cameraViewPlane = new _three2.default.Plane(normal, 0);
	    upPosition.copy(cameraViewPlane.projectPoint(upPosition).normalize());
	  }
	
	  var pivY = pivotMatrix.elements[13];
	  if (pivY + cameraPosition.length() < 0 && playerData.constraintCameraY) {
	    cameraPosition.normalize().multiplyScalar(pivY);
	  }
	  cameraWorldMatrix.setPosition(cameraPosition.add(pivotPosition));
	
	  toCameraData.upPosition = upPosition;
	  toCameraData.pivotMatrix = pivotMatrix;
	  toCameraData.offset = new _three2.default.Vector3(0, 0, 0);
	
	  adjustAngleAndRadius(store, fromId, cameraWorldMatrix, targetWorldMatrix, fromCameraData, boundingBox);
	
	  if (playerData.constraintCameraY) (0, _orbit.updateSphericalRotation)(store, toId, cameraWorldMatrix, targetWorldMatrix, new _three2.default.Vector2(0, 0));
	
	  var radiusConstraint = (0, _player.getCameraRadiusConstraint)(store);
	  if (radiusConstraint) {
	    initCameraRadiusConstraint(store, toId, toCameraData, radiusConstraint, cameraWorldMatrix, targetWorldMatrix);
	  }
	
	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, upPosition);
	  if (dispatch) (0, _setMatrixOnNode2.default)(store, toId, cameraWorldMatrix);
	  return cameraWorldMatrix;
	}
	
	function initCameraRadiusConstraint(store, cameraId, cameraData, outerRadius, initCameraWorldMatrix, initTargetWorldMatrix) {
	  var boundingBox = (0, _player.getBoundingBox)(store);
	  var minBoundingSphere = new _three2.default.Sphere();
	  var cameraWorldMatrix = initCameraWorldMatrix || (0, _scene.getWorldTransform)(store, cameraId);
	  var targetWorldMatrix = initTargetWorldMatrix || (0, _getTargetWorldMatrix2.default)(store, cameraId);
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	
	  boundingBox.getBoundingSphere(minBoundingSphere);
	  if (outerRadius <= minBoundingSphere.radius) {
	    return;
	  }
	  var maxBoundingSphere = new _three2.default.Sphere(minBoundingSphere.center, outerRadius);
	
	  t_targetPosition.setFromMatrixPosition(targetWorldMatrix);
	  t_cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	  var targetToCamera = new _three2.default.Vector3().subVectors(t_cameraPosition, t_targetPosition);
	
	  var thirdVector = new _three2.default.Vector3().crossVectors(targetToCamera, cameraData.upPosition).normalize();
	  var newTargetPosition = minBoundingSphere.clampPoint(t_targetPosition);
	  var newCameraPosition = maxBoundingSphere.clampPoint(t_cameraPosition);
	  cameraWorldMatrix.setPosition(newCameraPosition);
	  targetWorldMatrix.setPosition(newTargetPosition);
	
	  if (playerData.orbitMode === 'trackball') {
	    var newTargetToCamera = new _three2.default.Vector3().subVectors(newCameraPosition, newTargetPosition);
	    cameraData.upPosition.crossVectors(thirdVector, newTargetToCamera).normalize();
	  }
	
	  cameraData.radiusConstraint = { outerRadius: outerRadius, maxBoundingSphere: maxBoundingSphere, minBoundingSphere: minBoundingSphere };
	  cameraData.newRadiusConstraint = null;
	  (0, _zoom.updateZoom)(store, 0, cameraId, cameraWorldMatrix);
	
	  if (!initCameraWorldMatrix) (0, _setMatrixOnNode2.default)(store, cameraId, cameraWorldMatrix);
	}
	
	/*
	 * Set the camera angle and radius.
	 */
	function adjustAngleAndRadius(store, cameraId, cameraWorldMatrix, targetWorldMatrix, cameraData, boundingBox) {
	  var _getCameraAttrs$toJS = (0, _player.getCameraAttrs)(store).toJS();
	
	  var azimuthAngle = _getCameraAttrs$toJS.azimuthAngle;
	  var polarAngle = _getCameraAttrs$toJS.polarAngle;
	  var boundingRadius = _getCameraAttrs$toJS.boundingRadius;
	
	  var initialMinPolarAngle = 0;
	  var initialMaxPolarAngle = PI;
	  var minPolarAngle = 0;
	  var maxPolarAngle = PI;
	
	  if (cameraId === _sceneGraph.virtualCameraId) {
	    // Use defaults for the virtual camera only
	    if (azimuthAngle == null) azimuthAngle = 45;
	    if (polarAngle == null) polarAngle = 20;
	    if (boundingRadius == null) boundingRadius = 1;
	  }
	
	  if (azimuthAngle == null && polarAngle == null) {
	    return;
	  }
	
	  t_invTargetWorldMatrix.getInverse(targetWorldMatrix, true);
	  // world to relative
	  t_cameraPosition.setFromMatrixPosition(cameraWorldMatrix).applyMatrix4(t_invTargetWorldMatrix);
	
	  t_sphericalCamera.setFromVector3(t_cameraPosition);
	  t_sphericalCamera.theta = degToRad(azimuthAngle);
	  t_sphericalCamera.phi = degToRad(90 - polarAngle);
	
	  minPolarAngle = max(minPolarAngle || 0, initialMinPolarAngle); // radians
	  maxPolarAngle = min(maxPolarAngle || PI, initialMaxPolarAngle); // radians
	
	  t_sphericalCamera.phi = (0, _clamp2.default)(t_sphericalCamera.phi, minPolarAngle, maxPolarAngle);
	
	  if (boundingRadius != null) {
	    var fixRadius = boundingRadius * boundingBox.getBoundingSphere().radius;
	    t_sphericalCamera.radius = (fixRadius <= 0 ? 1 : fixRadius) / tan(degToRad(cameraData.fieldOfView * 0.5));
	    t_sphericalCamera.radius = (fixRadius <= 0 || fixRadius === Infinity ? 1 : fixRadius) / tan(degToRad(cameraData.fieldOfView * 0.5));
	  }
	
	  t_sphericalCamera.makeSafe();
	
	  t_cameraPosition.setFromSpherical(t_sphericalCamera);
	  t_sphericalCamera.setFromVector3(t_cameraPosition);
	
	  // relative to world
	  t_cameraPosition.applyMatrix4(targetWorldMatrix);
	  cameraWorldMatrix.setPosition(t_cameraPosition);
	}

/***/ },
/* 269 */
/*!*******************************************************!*\
  !*** ./src/translators/utils/getTargetWorldMatrix.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getTargetWorldMatrix;
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 142);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var position = new _three2.default.Vector3();
	var rotation = new _three2.default.Quaternion();
	var scale = new _three2.default.Vector3();
	/**
	 * If the Camera has a look at attached, return that, otherwise the
	 * virtual target transform
	 * @returns {Matrix4}
	 */
	function getTargetWorldMatrix(store, cameraId, initCameraTransform) {
	  var cameraTransform = initCameraTransform || (0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' });
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	  if (cameraTransform && cameraTransform.target) {
	    var lookAtTarget = (0, _scene.getWorldTransform)(store, cameraTransform.target.nodeId);
	    var offset = cameraData.offset;
	    lookAtTarget.decompose(position, rotation, scale);
	    return !offset ? lookAtTarget : lookAtTarget.compose(position.add(offset), rotation, scale);
	  } else {
	    return (0, _scene.getWorldTransform)(store, _sceneGraph.virtualTargetId);
	  }
	}

/***/ },
/* 270 */
/*!****************************************!*\
  !*** ./src/translators/utils/clamp.js ***!
  \****************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = clamp;
	function clamp(value, min, max) {
	  return Math.max(Math.min(value, max), min);
	}

/***/ },
/* 271 */
/*!**************************************************!*\
  !*** ./src/translators/utils/setMatrixOnNode.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = setMatrixOnNode;
	
	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 142);
	
	var _decompose = __webpack_require__(/*! ./decompose */ 272);
	
	var _decompose2 = _interopRequireDefault(_decompose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function setMatrixOnNode(store, nodeId, matrix4) {
	  store.dispatch((0, _sceneGraph.merge)([nodeId, 'Transform', 0], (0, _decompose2.default)(matrix4)));
	}

/***/ },
/* 272 */
/*!********************************************!*\
  !*** ./src/translators/utils/decompose.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = decompose;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function decompose(matrix4) {
	  var translation = new _three2.default.Vector3();
	  var rotQuat = new _three2.default.Quaternion();
	  var scale = new _three2.default.Vector3();
	  matrix4.decompose(translation, rotQuat, scale);
	  var rotation = new _three2.default.Vector3().copy(new _three2.default.Euler().setFromQuaternion(rotQuat, 'ZYX'));
	  rotation.multiplyScalar(180 / Math.PI); // convert to degrees
	  return { translation: translation, rotation: rotation };
	};

/***/ },
/* 273 */
/*!****************************************!*\
  !*** ./src/translators/tools/orbit.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.updateSphericalRotation = updateSphericalRotation;
	exports.default = orbit;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _clamp = __webpack_require__(/*! ../utils/clamp */ 270);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _decompose = __webpack_require__(/*! ../utils/decompose */ 272);
	
	var _decompose2 = _interopRequireDefault(_decompose);
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 142);
	
	var _updateCameraLookAtTarget = __webpack_require__(/*! ../utils/updateCameraLookAtTarget */ 266);
	
	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);
	
	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 269);
	
	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _Math = Math;
	var tan = _Math.tan;
	var cos = _Math.cos;
	var atan = _Math.atan;
	var acos = _Math.acos;
	var min = _Math.min;
	var max = _Math.max;
	var pow = _Math.pow;
	var PI = _Math.PI;
	var sqrt = _Math.sqrt;
	function updateSphericalRotation(store, cameraId, cameraWorldMatrix, targetWorldMatrix, mouseDelta) {
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	
	  var rect = (0, _player.getRect)(store);
	
	  var updateFns = { trackball: trackballUpdate, firstPerson: firstPersonUpdate };
	  var updateFn = updateFns[playerData.orbitMode] || gyroscopeUpdate;
	  updateFn(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, mouseDelta);
	}
	
	function orbit(store, translator) {
	  return {
	    label: 'Orbit',
	    active: true,
	    enabled: true,
	
	    display: {
	      playerTools: true
	    },
	    options: {},
	
	    tool: {
	      drag: function drag(ev) {
	        if (ev.which !== 1 || !(this.active || ev.metaKey)) return false;
	
	        return {
	          momentum: true,
	
	          handle: function handle(_ref) {
	            var deltaX = _ref.deltaX;
	            var deltaY = _ref.deltaY;
	
	            var cameraId = (0, _player.getCamera)(store);
	            var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	            var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
	
	            updateSphericalRotation(store, cameraId, cameraWorldMatrix, targetWorldMatrix, new _three2.default.Vector2(deltaX, deltaY));
	            store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
	
	            if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
	              store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
	            }
	          }
	        };
	      }
	    }
	  };
	}
	
	var cameraPosition = new _three2.default.Vector3();
	var targetPosition = new _three2.default.Vector3();
	var sphericalCamera = new _three2.default.Spherical();
	var sphericalTarget = new _three2.default.Spherical();
	var invTargetWorldMatrix = new _three2.default.Matrix4();
	var invPivotMatrix = new _three2.default.Matrix4();
	
	// changes cameraWorldMatrix by rotating by delta
	function gyroscopeUpdate(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, _ref2) {
	  var x = _ref2.x;
	  var y = _ref2.y;
	
	  //to target space
	  targetPosition.setFromMatrixPosition(targetWorldMatrix);
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix).sub(targetPosition);
	
	  var cameraSpherical = new _three2.default.Spherical().setFromVector3(cameraPosition);
	
	  var azimuthalAngle = 2 * PI * (-x / rect.x);
	  cameraSpherical.theta += azimuthalAngle;
	
	  var polarAngle = 2 * PI * (-y / rect.y);
	  cameraSpherical.phi += polarAngle;
	  var maxPolarAngle = undefined;
	  if (targetPosition.y / cameraPosition.length() <= 1) {
	    maxPolarAngle = playerData.constraintCameraY ? acos(-targetPosition.y / cameraPosition.length()) : PI;
	  } else {
	    maxPolarAngle = PI;
	  }
	  cameraSpherical.phi = (0, _clamp2.default)(cameraSpherical.phi, 0, maxPolarAngle);
	
	  cameraSpherical.makeSafe();
	  cameraPosition.setFromSpherical(cameraSpherical).add(targetPosition);
	
	  if (cameraData.radiusConstraint) {
	    var _cameraData$radiusCon = cameraData.radiusConstraint;
	    var maxBoundingSphere = _cameraData$radiusCon.maxBoundingSphere;
	    var minBoundingSphere = _cameraData$radiusCon.minBoundingSphere;
	
	    var camToTarg = new _three2.default.Vector3().subVectors(targetPosition, cameraPosition);
	    if (minBoundingSphere.containsPoint(cameraPosition)) {
	      var backwardRay = new _three2.default.Ray(cameraPosition, camToTarg.multiplyScalar(-1));
	      var newPosition = backwardRay.intersectSphere(minBoundingSphere).addScaledVector(camToTarg, (0.001));
	      cameraPosition.copy(newPosition);
	    } else if (!maxBoundingSphere.containsPoint(cameraPosition)) {
	      var forwardRay = new _three2.default.Ray(cameraPosition, camToTarg);
	      var newPosition = forwardRay.intersectSphere(maxBoundingSphere).addScaledVector(camToTarg, (0.001));
	      cameraPosition.copy(newPosition);
	    } else {}
	  }
	
	  cameraWorldMatrix.setPosition(cameraPosition);
	
	  // update orientation
	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	}
	
	// changes cameraWorldMatrix by rotating by delta
	function trackballUpdate(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, _ref3) {
	  var x = _ref3.x;
	  var y = _ref3.y;
	
	  var radius = min(rect.x, rect.y);
	
	  var pivotMatrix = cameraData.pivotMatrix;
	  var pivotPosition = new _three2.default.Vector3().setFromMatrixPosition(pivotMatrix);
	
	  var relativeDelta = new _three2.default.Vector3().set(-2 * x / radius, 2 * y / radius, 0);
	  if (relativeDelta.length() > 1) relativeDelta.normalize();
	  if (relativeDelta.x === 0 && relativeDelta.y === 0) return;
	  var delta = relativeDelta.length();
	
	  //world to relative pivot space
	  relativeDelta.transformDirection(cameraWorldMatrix).multiplyScalar(delta);
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix).sub(pivotPosition);
	  targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(pivotPosition);
	  //upPosition.transformDirection(invPivotMatrix);
	  var camNorm = new _three2.default.Vector3().copy(cameraPosition).normalize();
	  //create rotational Quaternion
	  var scaleFactor = sqrt(1 - relativeDelta.lengthSq());
	  relativeDelta.addScaledVector(camNorm, scaleFactor).normalize();
	
	  var rotationalAxis = new _three2.default.Vector3().crossVectors(camNorm, relativeDelta).normalize();
	  var rotationalAngle = camNorm.angleTo(relativeDelta);
	  var rotationalQuaternion = new _three2.default.Quaternion().setFromAxisAngle(rotationalAxis, rotationalAngle);
	
	  //pivot relative to world space
	  cameraPosition.applyQuaternion(rotationalQuaternion).add(pivotPosition);
	  targetPosition.applyQuaternion(rotationalQuaternion).add(pivotPosition);
	  cameraData.upPosition.applyQuaternion(rotationalQuaternion); //.transformDirection(pivotMatrix);
	  cameraData.offset.applyQuaternion(rotationalQuaternion);
	
	  //bounding box constraining
	  if (cameraData.radiusConstraint) {
	    var _cameraData$radiusCon2 = cameraData.radiusConstraint;
	    var maxBoundingSphere = _cameraData$radiusCon2.maxBoundingSphere;
	    var minBoundingSphere = _cameraData$radiusCon2.minBoundingSphere;
	
	    var camToTarg = new _three2.default.Vector3().subVectors(targetPosition, cameraPosition);
	
	    if (minBoundingSphere.containsPoint(cameraPosition)) {
	      var backwardRay = new _three2.default.Ray(cameraPosition, new _three2.default.Vector3().copy(camToTarg).multiplyScalar(-1));
	
	      var newPosition = backwardRay.intersectSphere(minBoundingSphere).addScaledVector(camToTarg, -(0.001));
	
	      cameraPosition.copy(newPosition);
	    } else if (!maxBoundingSphere.containsPoint(cameraPosition)) {
	      var forwardRay = new _three2.default.Ray(cameraPosition, camToTarg);
	
	      var newPosition = forwardRay.intersectSphere(maxBoundingSphere).addScaledVector(camToTarg, (0.001));
	
	      cameraPosition.copy(newPosition);
	    } else {}
	
	    if (!minBoundingSphere.containsPoint(targetPosition)) {
	      var thirdVector = new _three2.default.Vector3().crossVectors(camToTarg, cameraData.upPosition);
	      var newPosition = minBoundingSphere.clampPoint(targetPosition);
	
	      var posChange = new _three2.default.Vector3().subVectors(newPosition, targetPosition);
	      newPosition.addScaledVector(posChange, (0.001));
	
	      cameraData.upPosition.crossVectors(thirdVector, camToTarg.subVectors(newPosition, cameraPosition)).normalize();
	      targetPosition.copy(newPosition);
	    }
	  }
	
	  cameraWorldMatrix.setPosition(cameraPosition);
	  targetWorldMatrix.setPosition(targetPosition);
	
	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	}
	
	function firstPersonUpdate(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, _ref4) {
	  var x = _ref4.x;
	  var y = _ref4.y;
	
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	  targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(cameraPosition);
	
	  var targetSpherical = new _three2.default.Spherical().setFromVector3(targetPosition);
	
	  var azimuthalAngle = 2 * PI * (-x / rect.x);
	  targetSpherical.theta += azimuthalAngle;
	
	  var polarAngle = 2 * PI * (y / rect.y);
	  targetSpherical.phi += polarAngle;
	
	  targetSpherical.makeSafe();
	  targetPosition.setFromSpherical(targetSpherical).add(cameraPosition);
	
	  targetWorldMatrix.setPosition(targetPosition);
	
	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	}

/***/ },
/* 274 */
/*!***************************************!*\
  !*** ./src/translators/tools/zoom.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = zoom;
	exports.updateZoom = updateZoom;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _clamp = __webpack_require__(/*! ../utils/clamp */ 270);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _decompose = __webpack_require__(/*! ../utils/decompose */ 272);
	
	var _decompose2 = _interopRequireDefault(_decompose);
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 142);
	
	var _updateCameraLookAtTarget = __webpack_require__(/*! ../utils/updateCameraLookAtTarget */ 266);
	
	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);
	
	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 269);
	
	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _Math = Math;
	var tan = _Math.tan;
	var cos = _Math.cos;
	var atan = _Math.atan;
	var acos = _Math.acos;
	var min = _Math.min;
	var max = _Math.max;
	var pow = _Math.pow;
	var PI = _Math.PI;
	var sqrt = _Math.sqrt;
	
	var EPS = 0.000001;
	var cameraPosition = new _three2.default.Vector3();
	var targetPosition = new _three2.default.Vector3();
	var targetToCamera = new _three2.default.Vector3();
	
	function zoom(store, translator) {
	  function zoomBy(_ref) {
	    var delta = _ref.delta;
	    var deltaX = _ref.deltaX;
	    var deltaY = _ref.deltaY;
	
	    var d = delta !== undefined ? delta : deltaX / 30 + -deltaY / 30;
	    var cameraId = (0, _player.getCamera)(store);
	    var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
	    updateZoom(store, -d, cameraId, cameraWorldMatrix);
	    store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
	  }
	
	  return {
	    label: 'Zoom',
	    enabled: true,
	    display: {
	      playerTools: true
	    },
	    options: {},
	
	    tool: {
	      drag: function drag(ev) {
	        if (!this.active) return false;
	
	        return {
	          momentum: true,
	          handle: function handle(ev) {
	            var newEv = { delta: ev.delta !== undefined ? ev.delta : ev.deltaX / 30 + -ev.deltaY / 30 };
	            zoomBy(newEv);
	          }
	        };
	      },
	
	      pinch: function pinch(ev) {
	        zoomBy(ev);
	      },
	
	      scroll: function scroll(ev) {
	        zoomBy(ev);
	      }
	    }
	  };
	}
	
	function updateZoom(store, mouseDelta, cameraId, cameraWorldMatrix) {
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
	  var rect = (0, _player.getRect)(store);
	
	  var deltaZoom = mouseDelta / rect.y;
	  var decayZoomFactor = pow(2, deltaZoom * 100); // this ensures the zoom has consistent speed no matter the size
	
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	  targetPosition.setFromMatrixPosition(targetWorldMatrix);
	
	  targetToCamera.copy(cameraPosition).sub(targetPosition);
	  var targetToCameraDistance = max(targetToCamera.length(), EPS);
	  var newTargetToCameraDistance = targetToCameraDistance * decayZoomFactor;
	
	  if (cameraData.radiusConstraint) {
	    var _cameraData$radiusCon = cameraData.radiusConstraint;
	    var maxBoundingSphere = _cameraData$radiusCon.maxBoundingSphere;
	    var minBoundingSphere = _cameraData$radiusCon.minBoundingSphere;
	
	    var camToTargetBackward = new _three2.default.Vector3().copy(targetToCamera).normalize();
	    var camToTargetForward = new _three2.default.Vector3().copy(camToTargetBackward).multiplyScalar(-1);
	
	    var forwardRay = new _three2.default.Ray(cameraPosition, camToTargetForward);
	    var backwardRay = new _three2.default.Ray(cameraPosition, camToTargetBackward);
	
	    var lowerBound = new _three2.default.Vector3(),
	        upperBound = new _three2.default.Vector3();
	
	    forwardRay.intersectSphere(minBoundingSphere, lowerBound);
	    backwardRay.intersectSphere(maxBoundingSphere, upperBound);
	
	    var minZoom = lowerBound.sub(targetPosition).length();
	    var maxZoom = upperBound.sub(targetPosition).length();
	
	    newTargetToCameraDistance = (0, _clamp2.default)(newTargetToCameraDistance, minZoom + (0.001), maxZoom - (0.001));
	  }
	
	  targetToCamera.multiplyScalar(newTargetToCameraDistance / targetToCameraDistance);
	  cameraPosition.copy(targetPosition).add(targetToCamera);
	  if (cameraPosition.y < 0 && playerData.constraintCameraY && playerData.orbitMode !== 'trackball') {
	    var thirdVector = new _three2.default.Vector3().crossVectors(targetToCamera, cameraData.upPosition).normalize();
	    cameraPosition.y = 0;
	    targetToCamera.copy(cameraPosition).sub(targetPosition);
	  }
	  cameraWorldMatrix.setPosition(cameraPosition);
	
	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	};

/***/ },
/* 275 */
/*!*********************************!*\
  !*** ./src/modules/commands.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createReducer;
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MOUSE_CONTROLS = undefined;
	exports.addCommand = addCommand;
	exports.removeCommand = removeCommand;
	exports.updateCommand = updateCommand;
	exports.setCommandOptions = setCommandOptions;
	exports.getTools = getTools;
	exports.getCommands = getCommands;
	exports.isCommandActive = isCommandActive;
	exports.getActiveCommandsWithWidgets = getActiveCommandsWithWidgets;
	exports.activateCommand = activateCommand;
	exports.deactivateCommand = deactivateCommand;
	exports.runCommand = runCommand;
	exports.updateCommands = updateCommands;
	
	var _values = __webpack_require__(/*! babel-runtime/core-js/object/values */ 276);
	
	var _values2 = _interopRequireDefault(_values);
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 141);
	
	var _createReducer3 = _interopRequireDefault(_createReducer2);
	
	var _player = __webpack_require__(/*! ./player */ 265);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MOUSE_CONTROLS = exports.MOUSE_CONTROLS = ['orbit', 'pan', 'zoom'];
	
	/**
	 * This module manages commands and tools of the player
	 *
	 * @module commands
	 * @public
	 */
	
	var ADD_COMMAND = 'ADD_COMMAND';
	var REMOVE_COMMAND = 'REMOVE_COMMAND';
	var UPDATE_COMMAND = 'UPDATE_COMMAND';
	var FAIL_COMMAND = 'FAIL_COMMAND';
	var FINISH_COMMAND = 'FINISH_COMMAND';
	var RUN_COMMAND = 'RUN_COMMAND';
	var UPDATE_COMMAND_OPTIONS = 'UPDATE_COMMAND_OPTIONS;';
	
	var defaultCommand = {
	  enabled: true,
	  display: {},
	  options: {},
	
	  isEnabled: function isEnabled(store, command) {
	    return command.enabled;
	  },
	  isVisible: function isVisible(store, command) {
	    return command.display;
	  },
	
	  command: null,
	  widget: null
	};
	
	function makeCommand(state, command) {
	  return state.set(command.name, command);
	}
	
	var initialState = (0, _immutable.Map)({
	  all: {},
	  allCommands: (0, _immutable.List)(),
	  tools: (0, _immutable.List)(),
	  activeCommand: null
	});
	
	function initCommand(attrs, name) {
	  var cmd = (0, _assign2.default)({}, defaultCommand, attrs, { name: name });
	  if (cmd.display === true) cmd.display = { playerTools: true };
	  return cmd;
	}
	
	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, ADD_COMMAND, function (state, _ref) {
	  var command = _ref.command;
	  var name = _ref.name;
	
	  var cmd = initCommand(command, name);
	  var commands = state.get('all');
	  commands[name] = cmd;
	  var newState = state.updateIn(['allCommands'], (0, _immutable.List)(), function (list) {
	    return list.push(name);
	  });
	  if (cmd.tool) newState = newState.updateIn(['tools'], (0, _immutable.List)(), function (list) {
	    return list.push(name);
	  });
	  return newState;
	}), (0, _defineProperty3.default)(_createReducer, REMOVE_COMMAND, function (state, commandName) {
	  var commands = state.get('all');
	  delete commands[commandName];
	  var idx = state.getIn(['tools']).indexOf(commandName);
	  var idx2 = state.getIn(['allCommands']).indexOf(commandName);
	  return state.deleteIn(['tools', idx]).deleteIn(['allCommands', idx2]);
	  // FIXME: remove from commands/widgets
	}), (0, _defineProperty3.default)(_createReducer, UPDATE_COMMAND, function (state, _ref2) {
	  var name = _ref2.name;
	  var opts = _ref2.opts;
	
	  var command = state.get('all')[name];
	  if (command) (0, _assign2.default)(command, opts);
	  return state;
	}), (0, _defineProperty3.default)(_createReducer, UPDATE_COMMAND_OPTIONS, function (state, _ref3) {
	  var name = _ref3.name;
	  var opts = _ref3.opts;
	
	  var command = state.get('all')[name];
	  if (command) (0, _assign2.default)(command.options, opts);
	  return state;
	}), _createReducer));
	
	/**
	 * Add a command
	 *
	 * @public
	 * @param {Command} command Command to be added
	 * @param {String} name provide a name for the tool to allow removing it.
	 * @returns {Promise}
	 *
	 */
	function addCommand(command, name) {
	  return { type: ADD_COMMAND, payload: { command: command, name: name } };
	}
	
	/**
	 * Remove a command
	 *
	 * @public
	 * @param {String} name The name of the command to remove
	 * @returns {Promise}
	 */
	function removeCommand(commandName) {
	  return { type: REMOVE_COMMAND, payload: commandName };
	}
	
	/**
	 * Updates Atributes of Command
	 *
	 * @public
	 * @param {String} name The name of the command to be updated
	 * @param {Object} opts Attributes to set in the command
	 * @returns {Promise}
	 *
	 */
	function updateCommand(name, opts) {
	  return { type: UPDATE_COMMAND, payload: { name: name, opts: opts } };
	}
	
	/**
	 * Updates Options object of Command
	 *
	 * @public
	 * @param {String} name The name of the command to be updated
	 * @param {Object} opts Options to be set in the command
	 * @returns {Promise}
	 *
	 */
	function setCommandOptions(name, opts) {
	  return { type: UPDATE_COMMAND_OPTIONS, payload: { name: name, opts: opts } };
	}
	
	function getTools(store) {
	  return store.getIn(['commands', 'tools']);
	}
	
	function getCommands(store, displayLocation) {
	  var commands = store.getIn(['commands', 'all']);
	  return !displayLocation ? commands : (0, _ramda.reduce)(function (cmds, key) {
	    var cmd = commands[key];
	    if (cmd.enabled && cmd.display[displayLocation]) cmds[key] = cmd;
	    return cmds;
	  }, {}, (0, _keys2.default)(commands));
	}
	
	function _isCommandActive(store, command) {
	  if (command.active) return true;
	  if (command.isActive) return command.isActive(store);
	  return false;
	}
	
	function isCommandActive(store, commandName) {
	  var command = store.getIn(['commands', 'all'])[commandName];
	  return command && _isCommandActive(store, command);
	}
	
	function getActiveCommandsWithWidgets(store) {
	  var commands = getCommands(store);
	  var result = {};
	  (0, _values2.default)(commands).forEach(function (command) {
	    if (command.widget && _isCommandActive(store, command)) result[command.name] = command;
	  });
	  return result;
	}
	
	function activateCommand(commandName) {
	  return function (store) {
	    var tools = getTools(store);
	    var commands = getCommands(store);
	    var command = commands[commandName];
	
	    if (command.activate) {
	      if (!_isCommandActive(store, command)) {
	        command.activate();
	        store.dispatch(updateCommand(commandName, { active: true }));
	      }
	    } else {
	      tools.forEach(function (toolName) {
	        var command = commands[toolName];
	        if (command.active && command.name !== commandName) {
	          store.dispatch(updateCommand(command.name, { active: false }));
	        }
	        if (command.name === commandName) {
	          store.dispatch(updateCommand(command.name, { active: true }));
	        }
	      });
	    }
	  };
	}
	
	function deactivateCommand(commandName) {
	  return function (store) {
	    var commands = getCommands(store);
	    var command = commands[commandName];
	    if (!command) return;
	
	    if (command.active) store.dispatch(updateCommand(command.name, { active: false }));
	    if (command.deactivate) command.deactivate.call(command);
	  };
	}
	
	/**
	 * Executes, Activates/Deactivates, or makes Command Active
	 *
	 * @public
	 * @param {String} commandName The name of the command to be run
	 * @returns {Promise}
	 *
	 */
	function runCommand(commandName) {
	  return function (store) {
	    var command = store.getIn(['commands', 'all'])[commandName];
	    if (!command || !command.enabled) return;
	
	    if (command.execute) return command.execute(store);
	    var isActive = _isCommandActive(store, command);
	    if (command.deactivate && isActive) return store.dispatch(deactivateCommand(commandName));
	    return store.dispatch(activateCommand(commandName));
	  };
	}
	
	/**
	 * Updates multiple commands with given Attributes
	 *
	 * @public
	 * @param {String} commandList The name of the command to be run
	 * @params {Object} attrs Attributes to be set in the command
	 * @returns {Promise}
	 *
	 */
	function updateCommands(commandList, attrs) {
	  return function (store) {
	    commandList.forEach(function (name) {
	      store.dispatch(updateCommand(name, attrs));
	    });
	  };
	}
	
	/**
	 * Return a Map with the command commands.
	 *
	 * @private
	 */
	// export function getcommands(store) {
	//   return store.get(['commands']).map((command) => command.get('command'));
	// }
	
	var publicApi = {
	  reducer: reducer,
	  actions: { activateCommand: activateCommand, addCommand: addCommand, deactivateCommand: deactivateCommand, runCommand: runCommand, setCommandOptions: setCommandOptions, updateCommand: updateCommand, updateCommands: updateCommands, removeCommand: removeCommand },
	  selectors: {}
	};
	
	exports.default = publicApi;

/***/ },
/* 276 */
/*!**************************************************!*\
  !*** ./~/babel-runtime/core-js/object/values.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/values */ 277), __esModule: true };

/***/ },
/* 277 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/values.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es7.object.values */ 278);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.values;

/***/ },
/* 278 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es7.object.values.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(/*! ./_export */ 11)
	  , $values = __webpack_require__(/*! ./_object-to-array */ 279)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 279 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/_object-to-array.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(/*! ./_object-keys */ 32)
	  , toIObject = __webpack_require__(/*! ./_to-iobject */ 34)
	  , isEnum    = __webpack_require__(/*! ./_object-pie */ 61).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 280 */
/*!********************************!*\
  !*** ./src/modules/plugins.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createReducer;
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.get = get;
	exports.setApi = setApi;
	exports.getSetupCommand = getSetupCommand;
	
	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 98);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 141);
	
	var _createReducer3 = _interopRequireDefault(_createReducer2);
	
	var _rsvp = __webpack_require__(/*! rsvp */ 105);
	
	var _rsvp2 = _interopRequireDefault(_rsvp);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Plugins: loading, running
	 *
	 * @module plugins
	 * @private
	 */
	
	var SET_API = 'SET_API';
	var LOAD_PLUGIN = 'LOAD_PLUGIN';
	var LOADING_PLUGIN = 'LOADING_PLUGIN';
	var LOADED_PLUGIN = 'LOADED_PLUGIN';
	var SET_PLUGIN = 'SET_PLUGIN';
	var LOADING_PLUGIN_ERROR = 'LOADING_PLUGIN_ERROR';
	
	var initialState = (0, _immutable.Map)({
	  api: null,
	  plugins: (0, _immutable.Map)(),
	  loading: (0, _immutable.Map)()
	});
	
	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SET_API, function (state, api) {
	  return state.set('api', api);
	}), (0, _defineProperty3.default)(_createReducer, LOADING_PLUGIN, function (state, name) {
	  return state.setIn(['loading', name], true);
	}), (0, _defineProperty3.default)(_createReducer, LOADED_PLUGIN, function (state, name, _ref) {
	  var action = _ref.action;
	
	  return state.setIn(['loading', name], false);
	}), (0, _defineProperty3.default)(_createReducer, SET_PLUGIN, function (state, _ref2) {
	  var name = _ref2.name;
	  var plugin = _ref2.plugin;
	
	  return state.setIn(['plugins', name], plugin);
	}), _createReducer));
	
	function initPlugin(store, name, response) {
	  try {
	    var _ret = (function () {
	      var buildPluginFn = function buildPluginFn(content) {
	        var fn = new Function('api', content || '');
	        return fn(store.getIn(['plugins', 'api']));
	      };
	
	      var content = response.content;
	      var loadFromServer = response.loadFromServer;
	      var url = response.url;
	
	      if (!loadFromServer) return {
	          v: _promise2.default.resolve(buildPluginFn(content))
	        };
	
	      console.log('Load plugin from server', url);
	      return {
	        v: new _rsvp2.default.Promise(function (resolve, reject) {
	          store.callApi({
	            types: [LOADING_PLUGIN, LOADED_PLUGIN, LOADING_PLUGIN_ERROR],
	            url: url,
	            payload: name,
	            queryKey: 'PLUGINexternal' + name,
	            contentType: 'external'
	          }).then(function (content) {
	            resolve(buildPluginFn(content));
	          }).catch(function (e) {
	            console.log('Error loading external plugin!', url);
	            resolve({});
	          });
	        })
	      };
	    })();
	
	    if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
	  } catch (e) {
	    console.log('error', e);
	  }
	};
	
	function loadPlugin(name) {
	  return function (store) {
	    var sceneId = store.getIn(['sceneIO', 'id']);
	    if (!sceneId) return _promise2.default.reject('No scene attached');
	
	    var api = store.getIn(['plugins', 'api']);
	    if (api && api[name]) return _promise2.default.resolve(api[name]);
	
	    return store.callApi({
	      types: [LOADING_PLUGIN, LOADED_PLUGIN, LOADING_PLUGIN_ERROR],
	      url: ("https://editor.vimarket.io/api") + '/scenes/' + sceneId + '/plugins/' + name,
	      payload: name,
	      queryKey: 'PLUGIN' + name
	    }).then(function (response) {
	      return initPlugin(store, name, response).then(function (plugin) {
	        store.dispatch({ type: SET_PLUGIN, payload: { name: name, plugin: plugin } });
	        return plugin;
	      });
	    });
	  };
	}
	
	function get(store, name) {
	  var plugin = store.getIn(['plugins', 'plugins', name]);
	  return plugin ? _promise2.default.resolve(plugin) : store.dispatch(loadPlugin(name));
	}
	
	function setApi(api) {
	  return { type: SET_API, payload: api };
	}
	
	/**
	 * Returns a function that will run the setup command
	 */
	function getSetupCommand(store, cmd, data) {
	  try {
	    var _ret2 = (function () {
	      var err = function err(msg) {
	        console.log('Error getting plugin: ' + pluginName);
	        return _promise2.default.resolve(true);
	      };
	
	      var _cmd$split = cmd.split('/');
	
	      var _cmd$split2 = (0, _slicedToArray3.default)(_cmd$split, 2);
	
	      var pluginName = _cmd$split2[0];
	      var command = _cmd$split2[1];
	
	      var setupData = typeof data === 'string' ? JSON.parse(data) : data;
	      return {
	        v: function v() {
	          return get(store, pluginName).then(function (plugin) {
	            if (!plugin) return err('Error getting plugin: ' + pluginName);
	            if (!plugin[command]) return err('Unknown command: ' + command + ' for plugin: ' + pluginName);
	            if (typeof plugin[command] !== 'function') return err('Command: ' + command + ' in plugin: ' + pluginName + ' is not a function');
	
	            if (Array.isArray(setupData)) {
	              return _promise2.default.resolve(plugin[command].apply(plugin, setupData));
	            } else {
	              return _promise2.default.resolve(plugin[command](setupData));
	            }
	          });
	        }
	      };
	    })();
	
	    if ((typeof _ret2 === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret2)) === "object") return _ret2.v;
	  } catch (e) {
	    return function () {
	      console.error(e);
	    };
	  }
	}
	
	var publicApi = {
	  reducer: reducer,
	  actions: { loadPlugin: loadPlugin },
	  selectors: { get: get, getSetupCommand: getSetupCommand }
	};
	
	exports.default = publicApi;

/***/ },
/* 281 */
/*!**************************************!*\
  !*** ./src/modules/configuration.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.show = show;
	exports.hide = hide;
	exports.setMaterial = setMaterial;
	exports.mate = mate;
	exports.setImage = setImage;
	exports.setDefaultColor = setDefaultColor;
	exports.moveCamera = moveCamera;
	exports.openAnnotation = openAnnotation;
	exports.closeAnnotation = closeAnnotation;
	exports.set = set;
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _scene = __webpack_require__(/*! ./scene */ 147);
	
	var _sceneIO = __webpack_require__(/*! ./sceneIO */ 255);
	
	var _annotations = __webpack_require__(/*! ./annotations */ 264);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//export availableActions = {
	//  show: { args: [{key: 'name', type: 'String'}], description: 'Show nodes' },
	//  hide: { args: [{key: 'name', type: 'String'}], description: 'Hide nodes' },
	//};
	
	function show(_ref, _ref2) {
	  var name = _ref.name;
	  var from = _ref2.from;
	
	  return function (store) {
	    return (0, _scene.setAll)(store, { from: from, name: name, plug: 'Properties', property: 'visible' }, true);
	  };
	}
	
	function hide(_ref3, _ref4) {
	  var name = _ref3.name;
	  var from = _ref4.from;
	
	  return function (store) {
	    return (0, _scene.setAll)(store, { from: from, name: name, plug: 'Properties', property: 'visible' }, false);
	  };
	}
	
	/**
	 * setMaterial will assign a `materialName`, `to` a node. It will optionally `clone`
	 * the material, and optionally fetch `fromSceneId`.
	 *
	 * @param {Object} attrs
	 * @param {String} attrs.to
	 * @param {String} attrs.materialName
	 * @param {String?} attrs.fromSceneId
	 * @param {Boolean?} attrs.clone
	 * @param {Object} options
	 * @param {String?} options.from Optionally, a `from` base query to use to resolve the node
	 */
	function setMaterial(_ref5, _ref6) {
	  var to = _ref5.to;
	  var materialName = _ref5.materialName;
	  var fromSceneId = _ref5.fromSceneId;
	  var clone = _ref5.clone;
	  var from = _ref6.from;
	
	  return function (store) {
	    return (fromSceneId ? store.dispatch((0, _sceneIO.fetch)(fromSceneId)) : _promise2.default.resolve(true)).then(function () {
	      var matId = (0, _scene.find)(store, {
	        from: fromSceneId ? { id: fromSceneId } : null,
	        name: materialName
	      });
	      (clone && matId ? store.dispatch((0, _scene.clone)([matId])) : _promise2.default.resolve((0, _defineProperty3.default)({}, matId, matId))).then(function (cloned) {
	        var path = (0, _scene.find)(store, { from: from, name: to, plug: 'Material', property: 'reference' });
	        return store.dispatch((0, _scene.setAll)({ from: from, name: to, plug: 'Material', property: 'reference' }, cloned[matId]));
	      });
	    });
	  };
	}
	
	/**
	 * mate a `parentNode` to `targetNode`: Will align the transform of the `parentNode` to
	 * that of `targetNode`. Set `translationOnly` to only set translation (must be previously aligned).
	 *
	 * @param {Object} attrs
	 * @param {String} attrs.parentNode name of the node to move
	 * @param {String} attrs.targetNode name of the target node
	 * @param {Boolean?} attrs.translationOnly change translation only, not complete transform.
	 * @param {Object} options
	 * @param {String?} options.from Optionally, a `from` base query to use to resolve the parent node
	 *
	 */
	function mate(_ref7, _ref8) {
	  var parentNode = _ref7.parentNode;
	  var targetNode = _ref7.targetNode;
	  var translationOnly = _ref7.translationOnly;
	  var from = _ref8.from;
	
	  return function (store) {
	    var targetTranslation = (0, _scene.get)(store, { name: targetNode, evalPlug: 'Transform', property: 'translation' });
	    var parentTranslation = (0, _scene.get)(store, { from: from, name: parentNode, evalPlug: 'Transform', property: 'translation' });
	
	    if (targetTranslation && parentTranslation) {
	      var diff = targetTranslation.clone().sub(parentTranslation);
	      //console.log('diff?', parentNode, parentTranslation, 'to', targetNode, targetTranslation);
	      //console.log('set', get(store, {id: from.id, property: 'name'}), diff);
	      return store.dispatch((0, _scene.set)({ id: from.id, plug: 'Transform', property: 'translation' }, diff));
	    }
	    return _promise2.default.resolve(true);
	  };
	}
	
	function setImage(query, reference) {
	  return function (store) {
	    var ref = scene.find(reference);
	    if (!ref) return _promise2.default.resolve(true);
	    return (0, _scene.setAll)(store, { name: query, plug: 'Material', property: 'baseMap' }, ref);
	  };
	}
	
	function setDefaultColor(query, value) {
	  return function (store) {
	    return (0, _scene.setAll)({ name: query, plug: 'Material', property: 'defaultColor' }, value);
	  };
	}
	
	function moveCamera(query, value) {
	  return function (store) {
	    var duration = Number(value) || 500;
	    var camera = scene.find(query);
	    if (camera) return animateCameraTo(camera, duration);
	    return _promise2.default.resolve(true);
	  };
	}
	
	function openAnnotation(query) {
	  return function (store) {
	    return _promise2.default.all((0, _scene.filter)(query).map(function (path) {
	      return (0, _annotations.openAnnotation)(store, path);
	    }));
	  };
	}
	
	function closeAnnotation(query) {
	  return function (store) {
	    return _promise2.default.all((0, _scene.filter)(query).map(function (path) {
	      return (0, _annotations.closeAnnotation)(store, path);
	    }));
	  };
	}
	
	function set(query, value) {
	  return function (store) {
	    return (0, _scene.setAll)(store, query, value);
	  };
	}
	
	var publicApi = {
	  actions: { show: show, hide: hide, mate: mate, setMaterial: setMaterial, setImage: setImage, setDefaultColor: setDefaultColor, moveCamera: moveCamera,
	    openAnnotation: openAnnotation, closeAnnotation: closeAnnotation, set: set },
	  selectors: {}
	};
	
	exports.default = publicApi;

/***/ },
/* 282 */
/*!**********************************!*\
  !*** ./src/modules/selection.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createReducer;
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.selectNode = selectNode;
	exports.isSelected = isSelected;
	exports.lastSelectedNode = lastSelectedNode;
	exports.getSelectedNodes = getSelectedNodes;
	exports.deselectAll = deselectAll;
	exports.setHighlighting = setHighlighting;
	exports.isHighlighting = isHighlighting;
	
	var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ 136);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _createReducer2 = __webpack_require__(/*! ./utils/createReducer */ 141);
	
	var _createReducer3 = _interopRequireDefault(_createReducer2);
	
	var _actionTypes = __webpack_require__(/*! ./actionTypes */ 253);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SELECT_NODE = 'SELECT_NODE';
	var DESELECT_ALL = 'DESELECT_ALL';
	var SET_HIGHLIGHTING = 'SET_HIGHLIGHTING';
	
	/**
	 * Controls selection
	 *
	 * @module selection
	 * @public
	 */
	
	var initialState = (0, _immutable.Map)({
	  nodes: (0, _immutable.List)(),
	  highlightNodes: false
	});
	
	var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SELECT_NODE, function (state, nodeId) {
	  var nodes = state.get('nodes');
	  return state.set('nodes', !nodes.includes(nodeId) ? nodes.clear().push(nodeId) : nodes);
	}), (0, _defineProperty3.default)(_createReducer, _actionTypes.DELETE_NODE, function (state, nodeId) {
	  var idx = state.get('nodes').indexOf(nodeId);
	  return idx === -1 ? state : state.deleteIn(['nodes', idx]);
	}), (0, _defineProperty3.default)(_createReducer, DESELECT_ALL, function (state) {
	  return state.set('nodes', state.get('nodes').clear());
	}), (0, _defineProperty3.default)(_createReducer, SET_HIGHLIGHTING, function (state, highlight) {
	  return state.set('highlightNodes', highlight);
	}), _createReducer));
	
	function selectNode(nodeId) {
	  return { type: SELECT_NODE, payload: nodeId };
	};
	
	function isSelected(store, nodeId) {
	  return store.getIn(['selection', 'nodes']).includes(nodeId);
	};
	
	function lastSelectedNode(store) {
	  return store.getIn(['selection', 'nodes']).last();
	};
	
	function getSelectedNodes(store) {
	  return store.getIn(['selection', 'nodes']).toArray();
	};
	
	function deselectAll() {
	  return { type: DESELECT_ALL };
	};
	
	function setHighlighting(highlight) {
	  return { type: SET_HIGHLIGHTING, payload: highlight };
	};
	
	function isHighlighting(store) {
	  return store.getIn(['selection', 'highlightNodes']);
	}
	
	var publicApi = {
	  reducer: reducer,
	  actions: { selectNode: selectNode, deselectAll: deselectAll, setHighlighting: setHighlighting },
	  selectors: { isSelected: isSelected, lastSelectedNode: lastSelectedNode }
	};
	exports.default = publicApi;

/***/ },
/* 283 */
/*!********************************!*\
  !*** ./src/operators/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _makeAllOperators = __webpack_require__(/*! ./makeAllOperators */ 284);

	var _makeAllOperators2 = _interopRequireDefault(_makeAllOperators);

	var _minimal = __webpack_require__(/*! ./minimal */ 296);

	var _minimal2 = _interopRequireDefault(_minimal);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _minimal2.default;

/***/ },
/* 284 */
/*!*******************************************!*\
  !*** ./src/operators/makeAllOperators.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = makeAllOperators;
	
	var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ 128);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ 285);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ 286);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ 287);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(/*! babel-runtime/helpers/get */ 288);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ 292);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _keys2 = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys3 = _interopRequireDefault(_keys2);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _schemaTypes = __webpack_require__(/*! ./schemaTypes */ 151);
	
	var _schemaTypes2 = _interopRequireDefault(_schemaTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function makeAllOperators(hierarchy, _ref) {
	  var withNone = _ref.withNone;
	
	  var records = (0, _ramda.mapObjIndexed)(function (ops, plug) {
	    return (0, _ramda.mapObjIndexed)(function (op, name) {
	      return makeOperator(plug, op, name);
	    }, ops);
	  }, hierarchy);
	  if (withNone) records.None = { NoOp: makeOperator('None', { schema: {} }, 'NoOp') };
	  return records;
	};
	
	// export const Operator = Record({type: '', name: '', attributes: null});
	
	function makeOperator(plug, op, name) {
	  var props = (0, _ramda.map)(function (info, key) {
	    if (_schemaTypes2.default[info.type]) return (0, _assign2.default)({ type: info.type, schema: info }, _schemaTypes2.default[info.type](info));
	    return {
	      set: function set(v) {
	        return v;
	      },
	      get: function get(v) {
	        return v;
	      }
	    };
	  }, op.schema);
	
	  var _keys = (0, _keys3.default)(props);
	
	  var defaults = (0, _ramda.map)(function (prop, key) {
	    return prop.defaultValue;
	  }, props);
	  defaults.type = name;
	  defaults.name = name;
	
	  var references = (0, _ramda.pickBy)(function (prop, key) {
	    return prop.isReference;
	  }, props);
	  var fileReferences = (0, _ramda.pickBy)(function (prop, key) {
	    return prop.isFileReference;
	  }, props);
	
	  var Operator = (function (_Record) {
	    (0, _inherits3.default)(R, _Record);
	
	    function R() {
	      (0, _classCallCheck3.default)(this, R);
	      return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(R).apply(this, arguments));
	    }
	
	    (0, _createClass3.default)(R, [{
	      key: 'keys',
	      value: function keys() {
	        return _keys;
	      }
	    }, {
	      key: 'getProperties',
	      value: function getProperties() {
	        return props;
	      }
	    }, {
	      key: 'getReferences',
	      value: function getReferences() {
	        var _this2 = this;
	
	        return (0, _immutable.Map)((0, _ramda.pickBy)(function (v) {
	          return !!v;
	        }, (0, _ramda.mapObjIndexed)(function (schema, key) {
	          return _this2.get(key);
	        }, references)));
	      }
	    }, {
	      key: 'getFileReferences',
	      value: function getFileReferences() {
	        var _this3 = this;
	
	        return (0, _immutable.Map)((0, _ramda.pickBy)(function (v) {
	          return !!v;
	        }, (0, _ramda.mapObjIndexed)(function (schema, key) {
	          return _this3.get(key);
	        }, fileReferences)));
	      }
	    }, {
	      key: 'typeOf',
	      value: function typeOf(key) {
	        return op.schema[key] && op.schema[key].type;
	      }
	    }, {
	      key: 'set',
	      value: function set(key, val) {
	        var newVal = props[key] ? props[key].set(val) : val;
	        return (0, _get3.default)((0, _getPrototypeOf2.default)(R.prototype), 'set', this).call(this, key, newVal);
	      }
	    }, {
	      key: 'export',
	      value: function _export() {
	        var _this4 = this;
	
	        var op = (0, _ramda.mapObjIndexed)(function (prop, key) {
	          var v = _this4.get(key);
	          return fileReferences[key] || references[key] ? v ? v.get('id') : null : v;
	        }, props);
	        op.name = name;
	        op.primitive = plug;
	        return op;
	      }
	    }, {
	      key: 'doUpdate',
	      value: function doUpdate(operator, primitive, sceneId) {
	        var result = op.update ? op.update.call(op, operator, primitive, sceneId) : operator.mergeInto(operator, primitive);
	        if (!result) {
	          console.error('Operator not returning its result: ', name, op);
	        }
	        return result || (0, _immutable.Map)();
	      }
	    }], [{
	      key: 'keys',
	      value: function keys() {
	        return _keys;
	      }
	    }]);
	    return R;
	  })((0, _immutable.Record)(defaults, plug + name));
	  return Operator;
	}

/***/ },
/* 285 */
/*!***************************************************!*\
  !*** ./~/babel-runtime/helpers/classCallCheck.js ***!
  \***************************************************/
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 286 */
/*!************************************************!*\
  !*** ./~/babel-runtime/helpers/createClass.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(/*! babel-runtime/core-js/object/define-property */ 137);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 287 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 288 */
/*!****************************************!*\
  !*** ./~/babel-runtime/helpers/get.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ 128);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _getOwnPropertyDescriptor = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-descriptor */ 289);
	
	var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function get(object, property, receiver) {
	  if (object === null) object = Function.prototype;
	  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);
	
	  if (desc === undefined) {
	    var parent = (0, _getPrototypeOf2.default)(object);
	
	    if (parent === null) {
	      return undefined;
	    } else {
	      return get(parent, property, receiver);
	    }
	  } else if ("value" in desc) {
	    return desc.value;
	  } else {
	    var getter = desc.get;
	
	    if (getter === undefined) {
	      return undefined;
	    }
	
	    return getter.call(receiver);
	  }
	};

/***/ },
/* 289 */
/*!***********************************************************************!*\
  !*** ./~/babel-runtime/core-js/object/get-own-property-descriptor.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-own-property-descriptor */ 290), __esModule: true };

/***/ },
/* 290 */
/*!************************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/get-own-property-descriptor.js ***!
  \************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.get-own-property-descriptor */ 291);
	var $Object = __webpack_require__(/*! ../../modules/_core */ 13).Object;
	module.exports = function getOwnPropertyDescriptor(it, key){
	  return $Object.getOwnPropertyDescriptor(it, key);
	};

/***/ },
/* 291 */
/*!*********************************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.get-own-property-descriptor.js ***!
  \*********************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(/*! ./_to-iobject */ 34)
	  , $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ 91).f;
	
	__webpack_require__(/*! ./_object-sap */ 131)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 292 */
/*!*********************************************!*\
  !*** ./~/babel-runtime/helpers/inherits.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/set-prototype-of */ 293);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 164);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 115);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 293 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/core-js/object/set-prototype-of.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/set-prototype-of */ 294), __esModule: true };

/***/ },
/* 294 */
/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/set-prototype-of.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.set-prototype-of */ 295);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 13).Object.setPrototypeOf;

/***/ },
/* 295 */
/*!**********************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.set-prototype-of.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(/*! ./_export */ 11);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(/*! ./_set-proto */ 90).set});

/***/ },
/* 296 */
/*!**********************************!*\
  !*** ./src/operators/minimal.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _makeAllOperators = __webpack_require__(/*! ./makeAllOperators */ 284);
	
	var _makeAllOperators2 = _interopRequireDefault(_makeAllOperators);
	
	var _Annotation = __webpack_require__(/*! ./Annotation */ 152);
	
	var _Annotation2 = _interopRequireDefault(_Annotation);
	
	var _BinMesh = __webpack_require__(/*! ./BinMesh */ 153);
	
	var _BinMesh2 = _interopRequireDefault(_BinMesh);
	
	var _Camera = __webpack_require__(/*! ./Camera */ 200);
	
	var _Camera2 = _interopRequireDefault(_Camera);
	
	var _Environment = __webpack_require__(/*! ./Environment */ 201);
	
	var _Environment2 = _interopRequireDefault(_Environment);
	
	var _Image = __webpack_require__(/*! ./Image */ 202);
	
	var _Image2 = _interopRequireDefault(_Image);
	
	var _Light = __webpack_require__(/*! ./Light */ 204);
	
	var _Light2 = _interopRequireDefault(_Light);
	
	var _Material = __webpack_require__(/*! ./Material */ 205);
	
	var _Material2 = _interopRequireDefault(_Material);
	
	var _Player = __webpack_require__(/*! ./Player */ 206);
	
	var _Player2 = _interopRequireDefault(_Player);
	
	var _PolyMesh = __webpack_require__(/*! ./PolyMesh */ 207);
	
	var _PolyMesh2 = _interopRequireDefault(_PolyMesh);
	
	var _Properties = __webpack_require__(/*! ./Properties */ 251);
	
	var _Properties2 = _interopRequireDefault(_Properties);
	
	var _Transform = __webpack_require__(/*! ./Transform */ 252);
	
	var _Transform2 = _interopRequireDefault(_Transform);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NoOp = { schema: {} };
	
	var Bone = { Bone: NoOp };
	var Null = { Null: NoOp };
	var Pass = { Pass: NoOp };
	var Mixer = { Action: NoOp, Mixer: NoOp };
	var Renderer = { 'vray/create': NoOp, WebGLRenderer: NoOp };
	var Timeline = { Timeline: NoOp };
	var GeneralRenderer = { GeneralRenderer: NoOp };
	var Viewport = { Viewport: NoOp };
	
	var records = (0, _makeAllOperators2.default)({
	  Annotation: _Annotation2.default, BinMesh: _BinMesh2.default, Bone: Bone, Camera: _Camera2.default, Environment: _Environment2.default, GeneralRenderer: GeneralRenderer, Light: _Light2.default, Material: _Material2.default,
	  Mixer: Mixer, Null: Null, Pass: Pass, Player: _Player2.default, PolyMesh: _PolyMesh2.default, Properties: _Properties2.default,
	  Renderer: Renderer, Timeline: Timeline, Transform: _Transform2.default, Image: _Image2.default, Viewport: Viewport
	}, { withNone: true });
	
	exports.default = records;

/***/ },
/* 297 */
/*!*************************************!*\
  !*** ./src/operators/primitives.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Color = exports.Vec3 = exports.Vec2 = exports.OperatorReference = exports.PlugReference = exports.NodeReference = exports.FileReference = undefined;
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var FileReference = exports.FileReference = (0, _immutable.Record)({ id: '' }, 'FileReference');
	var NodeReference = exports.NodeReference = (0, _immutable.Record)({ id: '' }, 'NodeReference');
	var PlugReference = exports.PlugReference = (0, _immutable.Record)({ id: '', plug: '' }, 'PlugReference');
	var OperatorReference = exports.OperatorReference = (0, _immutable.Record)({ id: '', plug: '', index: 0 }, 'OperatorReference');
	
	var Vec2 = exports.Vec2 = (0, _immutable.Record)({ x: 0, y: 0 }, 'Vec2');
	var Vec3 = exports.Vec3 = (0, _immutable.Record)({ x: 0, y: 0, z: 0 }, 'Vec3');
	var Color = exports.Color = (0, _immutable.Record)({ r: 0, g: 0, b: 0, a: 0 }, 'Color');
	
	exports.default = {
	  FileReference: FileReference, NodeReference: NodeReference, PlugReference: PlugReference, OperatorReference: OperatorReference,
	  Vec2: Vec2, Vec3: Vec3, Color: Color
	};

/***/ },
/* 298 */
/*!****************************!*\
  !*** ./src/store/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = buildStore;
	
	var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ 2);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _createReducer = __webpack_require__(/*! ./createReducer */ 299);
	
	var _createReducer2 = _interopRequireDefault(_createReducer);
	
	var _applyMiddleware = __webpack_require__(/*! ./applyMiddleware */ 300);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _createStore = __webpack_require__(/*! ./createStore */ 257);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function buildStore(reducers, operatorRecords, primitives, middleware) {
	  var reducer = (0, _createReducer2.default)(reducers, operatorRecords);
	  var records = (0, _ramda.chain)(_ramda.values, (0, _ramda.values)(operatorRecords)).concat((0, _ramda.values)(primitives));
	  var store = (0, _createStore2.default)(reducer, _applyMiddleware2.default.apply(undefined, (0, _toConsumableArray3.default)(middleware)));
	  store.addRecords(records);
	  return store;
	}

/***/ },
/* 299 */
/*!************************************!*\
  !*** ./src/store/createReducer.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (reducers, operatorRecords) {
	  var keys = (0, _keys2.default)(reducers);
	
	  var defaultState = (0, _ramda.reduce)(function (state, key) {
	    return state.set(key, reducers[key]());
	  }, (0, _immutable.Map)(), keys);
	
	  return function reducer() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? defaultState : arguments[0];
	    var action = arguments[1];
	    var createEvent = arguments[2];
	
	    return (0, _ramda.reduce)(function (state, key) {
	      var previousStateForKey = state.get(key);
	      var nextStateForKey = reducers[key](previousStateForKey, action, state, createEvent);
	      if (false) {
	        if (!nextStateForKey) {
	          throw new Error('Reducer: ' + key + ' failed to return state');
	        }
	      }
	      return (0, _immutable.is)(previousStateForKey, nextStateForKey) ? state : state.set(key, nextStateForKey);
	    }, state, keys);
	  };
	};
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 300 */
/*!**************************************!*\
  !*** ./src/store/applyMiddleware.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = applyMiddleware;
	
	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 113);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ 2);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	
	      var chain = [];
	
	      var middlewareAPI = {
	        get: store.get,
	        getIn: store.getIn,
	        getState: store.getState,
	        getTranslator: store.getTranslator,
	        getDerived: store.getDerived,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        },
	        read: store.read,
	        write: store.write,
	        hasApi: store.hasApi,
	        callApi: store.callApi,
	        logPageView: store.logPageView
	      };
	
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _ramda.compose.apply(undefined, (0, _toConsumableArray3.default)(chain))(store.dispatch);
	
	      return (0, _extends3.default)({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 301 */
/*!*****************************************************!*\
  !*** ./src/store/bindActionCreatorsAndSelectors.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = bindActionCreatorsAndSelectors;
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function bindActionCreators(dispatch, actionCreators) {
	  return (0, _ramda.map)(function (actionCreator) {
	    return function () {
	      return dispatch(actionCreator.apply(undefined, arguments));
	    };
	  }, actionCreators);
	};
	
	function bindSelectors(store, selectors) {
	  return (0, _ramda.map)(function (selector) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      return selector.apply(undefined, [store].concat(args));
	    };
	  }, selectors);
	};
	
	/**
	 * Iterate over modules,
	 */
	function bindActionCreatorsAndSelectors(store, modules) {
	  return (0, _ramda.map)(function (module) {
	    return (0, _assign2.default)({}, bindActionCreators(store.dispatch, module.actions), bindSelectors(store, module.selectors));
	  }, modules);
	};

/***/ },
/* 302 */,
/* 303 */
/*!**********************************!*\
  !*** ./src/components/styles.js ***!
  \**********************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var headerFont = '-apple-system,".SFNSDisplay-Bold","Helvetica Neue","Roboto","Segoe UI",sans-serif';
	var bodyFont = "'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', Verdana, Tahoma, sans-serif";
	var colors = {
	  gray: '#999',
	  black: '#333',
	  lightBg: '#eee',
	  border: '#ccc',
	  white: '#fff'
	};
	
	exports.default = {
	  root: {
	    height: '100%',
	    fontSize: '14px',
	    fontFamily: bodyFont,
	    position: 'absolute',
	    top: 0, left: 0, right: 0, bottom: 0
	  },
	  absoluteMaxCentered: {
	    position: 'absolute',
	    top: 0, left: 0, right: 0, bottom: 0,
	    display: 'flex',
	    alignItems: 'center',
	    justifyContent: 'center'
	  },
	  header: {
	    display: 'flex',
	    flex: '0 0 auto',
	    justifyContent: 'center',
	    margin: '0',
	    backgroundColor: colors.lightBg,
	    fontFamily: headerFont
	  },
	  mainRow: {
	    display: 'flex',
	    flex: '1 1 100px',
	    justifyContent: 'center'
	  },
	  commandsRow: {
	    flex: '0 0 auto'
	  },
	  statsRow: {
	    flex: '0 0 auto',
	    backgroundColor: colors.gray,
	    color: colors.lightBg,
	    padding: '5px'
	  },
	  player: {
	    position: 'relative',
	    top: 0, left: 0, right: 0, bottom: 0,
	    height: '100%',
	    width: '100%'
	  },
	  maxRow: {
	    flex: '1 1 auto'
	  },
	  leftCol: {
	    flex: '1 1 200px',
	    maxWidth: '300px',
	    overflow: 'scroll'
	  },
	  centerCol: {
	    flex: '2 2 500px',
	    border: '1px solid ' + colors.border
	  },
	  rightCol: {
	    flex: '1 1 200px',
	    maxWidth: '300px',
	    overflow: 'scroll'
	  },
	  footer: {
	    flex: '0 0 auto',
	    padding: '5px',
	    backgroundColor: colors.lightBg,
	    margin: '0'
	  },
	  explorerSelected: {
	    backgroundColor: colors.gray
	  },
	  explorerNotSelected: {
	    backgroundColor: colors.white,
	    cursor: 'pointer'
	  }
	};

/***/ },
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */
/*!*********************************!*\
  !*** ./src/components/error.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = error;
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _styles = __webpack_require__(/*! ./styles */ 303);
	
	var _styles2 = _interopRequireDefault(_styles);
	
	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 255);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function error(store) {
	  return (0, _h2.default)('div', { key: 'error', style: _styles2.default.absoluteMaxCentered }, [(0, _h2.default)('div', { style: { flex: '0 0 100%' } }, (0, _sceneIO.getErrors)(store).map(function (err) {
	    return (0, _h2.default)('h2', err);
	  }).toArray())]);
	};

/***/ },
/* 314 */
/*!************************************!*\
  !*** ./src/components/progress.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = progress;
	
	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 113);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	var _styles = __webpack_require__(/*! ./styles */ 303);
	
	var _styles2 = _interopRequireDefault(_styles);
	
	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 255);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var stats = statsReporter();
	
	function statsReporter() {
	  var pageLoadTime, toRenderedTime;
	  if (typeof performace === 'undefined') return function () {};
	
	  return function (store, pct) {
	    if (pageLoadTime && toRenderedTime) return;
	    if (!pageLoadTime) pageLoadTime = new Date().getTime() - performance.timing.navigationStart;
	    if (pct < 1) return;
	    toRenderedTime = new Date().getTime() - performance.timing.navigationStart;
	    console.log('Page loaded in ' + pageLoadTime + 'ms and rendered in ' + toRenderedTime + 'ms');
	  };
	};
	
	//
	var spinnerColor = '#646766';
	
	var circleDiv = {
	  flex: '0 0 25%'
	};
	
	var r = 90;
	var PIR2 = Math.PI * r * 2;
	
	var outer = {
	  r: r, cx: 100, cy: 100,
	  fill: 'transparent',
	  'stroke-dasharray': PIR2,
	  'stroke-dashoffset': 0,
	  'stroke-width': '1em',
	  stroke: '#eee'
	};
	var inner = {
	  r: r, cx: 100, cy: 100,
	  fill: 'transparent',
	  stroke: spinnerColor,
	  transition: 'stroke-dashoffset 1s linear',
	  'stroke-width': '1em',
	  'stroke-dashoffset': PIR2,
	  'stroke-dasharray': PIR2
	};
	var svg = {
	  height: '100%',
	  width: '100%',
	  viewport: '0 0 100 100',
	  viewBox: '0 0 200 200'
	};
	
	function progress(store) {
	  var pct = (0, _sceneIO.loadingProgress)(store);
	  var degrees = PIR2 * (1 - pct);
	  stats(store, pct);
	
	  return (0, _h2.default)('div', { style: (0, _extends3.default)({}, _styles2.default.absoluteMaxCentered, { backgroundColor: 'transparent', boxSizing: 'border-box' }) }, [(0, _h2.default)('div', { style: circleDiv }, [(0, _h2.default)('svg', { attrs: svg }, [(0, _h2.default)('circle', { attrs: outer }), (0, _h2.default)('circle', { props: { id: 'bar' }, attrs: (0, _extends3.default)({}, inner, { 'stroke-dashoffset': degrees }) })])])]);
	}

/***/ },
/* 315 */
/*!**********************************!*\
  !*** ./src/components/canvas.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = canvas;
	
	var _values = __webpack_require__(/*! babel-runtime/core-js/object/values */ 276);
	
	var _values2 = _interopRequireDefault(_values);
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _annotation = __webpack_require__(/*! ./annotation */ 316);
	
	var _annotation2 = _interopRequireDefault(_annotation);
	
	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 255);
	
	var _annotations = __webpack_require__(/*! ../modules/annotations */ 264);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var attachTranslator = function attachTranslator(store, translator) {
	  return function (info) {
	    translator.attach(info.elm);
	
	    function onResize() {
	      translator.resize();
	    }
	    window.addEventListener('resize', onResize);
	  };
	};
	
	function ignoreRightClick(ev) {
	  ev.preventDefault();
	};
	
	function canvas(store) {
	  var translator = store.getTranslator();
	  var rendered = (0, _sceneIO.isSceneRendered)(store);
	
	  translator.update();
	
	  var annotationFn = (0, _annotations.getCustomAnnotationFunction)(store);
	
	  var annotations = (0, _ramda.filter)(function (a) {
	    return !!a;
	  }, (0, _ramda.map)(function (obj) {
	    return (0, _annotation.getAnnotationProperties)(store, obj);
	  }, (0, _values2.default)(translator.getAnnotations())));
	
	  function callCustomAnnotationFn(vnode) {
	    annotations.forEach(function (annotation) {
	      return annotationFn(annotation, vnode.elm);
	    });
	  }
	
	  var children = annotationFn ? [(0, _h2.default)('div.annotations', {
	    style: { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, pointerEvents: 'none' },
	    hook: {
	      insert: callCustomAnnotationFn,
	      update: callCustomAnnotationFn
	    }
	  })] : (0, _ramda.map)((0, _annotation2.default)(store), annotations);
	
	  return (0, _h2.default)('div', {
	    style: { position: 'relative', display: rendered ? 'block' : 'none' },
	    on: { contextmenu: ignoreRightClick },
	    hook: { insert: attachTranslator(store, translator) }
	  }, children);
	};

/***/ },
/* 316 */
/*!**************************************!*\
  !*** ./src/components/annotation.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getAnnotationProperties = getAnnotationProperties;
	
	exports.default = function (store) {
	  var rect = (0, _player.getRect)(store);
	  var compact = (0, _ramda.filter)(function (n) {
	    return n;
	  });
	
	  return function (annotation) {
	    var id = annotation.id;
	    var text = annotation.text;
	    var left = annotation.left;
	    var bottom = annotation.bottom;
	    var visible = annotation.visible;
	    var position = annotation.position;
	    var normal = annotation.normal;
	    var alpha = annotation.alpha; //data.position(store);
	
	    if (position === undefined) return (0, _h2.default)('span');
	
	    var state = store.getIn(['annotations', id]) || (0, _immutable.Map)({ open: annotation.open, pinned: annotation.open });
	    var open = state.get('open');
	    var pinned = state.get('pinned');
	
	    var tb = position.y > 0.5 ? 't' : 'b';
	    var lr = position.x < 0.6 ? 'l' : 'r';
	    var side = [tb, lr].join('');
	
	    function click(ev) {
	      ev.preventDefault();
	      store.dispatch((0, _annotations.setAnnotationProperties)(id, {
	        open: !pinned ? true : !open,
	        pinned: !pinned
	      }));
	    }
	
	    function mouseover(ev) {
	      if (!pinned) store.dispatch((0, _annotations.setAnnotationProperties)(id, { open: true }));
	    }
	
	    function mouseout(ev) {
	      if (!pinned) store.dispatch((0, _annotations.setAnnotationProperties)(id, { open: false }));
	    };
	
	    var children = [(0, _h2.default)('img', { style: { cursor: 'pointer' }, props: {
	        width: 24,
	        height: 24,
	        src: ("https://editor.vimarket.io") + '/img/annotation-' + (open ? 'open' : 'closed') + '.svg'
	      } })];
	
	    if (open) {
	      var textCss = {
	        fontSize: '12px', padding: '10px', color: '#fff', backgroundColor: '#000',
	        borderRadius: '3px', opacity: '0.8', cursor: 'pointer', lineHeight: 1.3,
	        width: text.length > 10 ? text.length > 50 ? '200px' : '150px' : '100px'
	      };
	
	      children.push((0, _h2.default)('div', { style: popupCsses[side] }, compact([lr === 'l' && (0, _h2.default)('div', { key: side, style: arrows[side] }), (0, _h2.default)('div', { key: 'text', style: textCss, on: { click: click } }, text), lr === 'r' && (0, _h2.default)('div', { key: side, style: arrows[side] })])));
	    }
	
	    return (0, _h2.default)('div', {
	      key: id,
	      style: {
	        visibility: visible ? 'visible' : 'hidden',
	        opacity: alpha,
	        position: 'absolute',
	        left: Math.round(left) + 'px',
	        bottom: Math.round(bottom) + 'px'
	      },
	      on: { click: click, mouseover: mouseover, mouseout: mouseout }
	    }, children);
	  };
	};
	
	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 113);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _player = __webpack_require__(/*! ../modules/player */ 265);
	
	var _annotations = __webpack_require__(/*! ../modules/annotations */ 264);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var imgStyle = { cursor: 'pointer' };
	
	var initialAnnotationState = (0, _immutable.Map)({ open: false, pinned: false });
	
	var bs = '5px solid #333';
	var bi = '5px solid transparent';
	
	var arrowCss = {
	  position: 'absolute',
	  display: 'inline-block',
	  borderTop: bi, borderLeft: bi, borderRight: bi, borderBottom: bi,
	  height: 0,
	  width: 0,
	  top: '', bottom: '', right: '', left: ''
	};
	
	var arrows = {
	  tl: (0, _extends3.default)({}, arrowCss, { borderRight: bs, top: '12px', left: '-10px', marginTop: '-5px' }),
	  bl: (0, _extends3.default)({}, arrowCss, { borderRight: bs, bottom: '8px', left: '-10px', marginTop: '-5px' }),
	  tr: (0, _extends3.default)({}, arrowCss, { borderLeft: bs, top: '12px', right: '-10px', marginTop: '-5px' }),
	  br: (0, _extends3.default)({}, arrowCss, { borderLeft: bs, bottom: '8px', right: '-10px', marginTop: '-5px' })
	};
	
	var popupCss = { position: 'absolute', textAlign: 'left',
	  left: '', top: '', bottom: '', right: '',
	  transition: 'opacity 0.3s ease-out', webkitTransition: 'opacity 0.3s ease-out',
	  fontFamily: 'sans-serif', delayed: { opacity: 1 }, remove: { opacity: 0 }
	};
	
	var popupCsses = {
	  tl: (0, _extends3.default)({}, popupCss, { left: '30px', top: '0' }),
	  bl: (0, _extends3.default)({}, popupCss, { left: '30px', bottom: '0' }),
	  tr: (0, _extends3.default)({}, popupCss, { right: '30px', top: '0' }),
	  br: (0, _extends3.default)({}, popupCss, { right: '30px', bottom: '0' })
	};
	
	function getAnnotationProperties(store, data) {
	  var rect = (0, _player.getRect)(store);
	
	  var _data$position = data.position(store);
	
	  var position = _data$position.position;
	  var normal = _data$position.normal;
	  var alpha = _data$position.alpha;
	
	  if (!position) return false;
	
	  var left = rect.width * position.x;
	  var bottom = rect.height * position.y;
	  var visible = !(left < 0 || left > rect.width - 24 || bottom < 0 || bottom > rect.height - 24) && data.visible;
	
	  return (0, _extends3.default)({}, data.annotation, {
	    id: data.id,
	    alpha: alpha,
	    normal: normal,
	    position: position,
	    top: rect.height - bottom,
	    right: rect.width - left,
	    bottom: bottom,
	    left: left,
	    visible: visible
	  });
	};

/***/ },
/* 317 */
/*!********************************************!*\
  !*** ./src/components/manipulatorTools.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.hoverStyle = hoverStyle;
	exports.default = manipulatorTools;
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _icons = __webpack_require__(/*! ./icons */ 318);
	
	var svgIcons = _interopRequireWildcard(_icons);
	
	var _player = __webpack_require__(/*! ../modules/player */ 265);
	
	var _commands = __webpack_require__(/*! ../modules/commands */ 275);
	
	var _timeline = __webpack_require__(/*! ./timeline */ 319);
	
	var _timeline2 = _interopRequireDefault(_timeline);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var isTouch = (true) && (!!("ontouchstart" in window) || window.navigator.msMaxTouchPoints > 0);
	
	function hoverStyle(store) {
	  var hoverColor = (0, _player.getHoverColor)(store);
	
	  var hoverStyle = isTouch ? '' : '\ndiv.claraplayer ul.tools li:not(.active):hover svg path {\n  fill: ' + hoverColor + ';\n}\n';
	  return (0, _h2.default)('style', { props: { innerHTML: hoverStyle } });
	}
	
	function manipulatorTools(store) {
	  var tools = (0, _commands.getCommands)(store, 'playerTools');
	  var activeColor = (0, _player.getActiveColor)(store);
	
	  function click(what) {
	    return function (ev) {
	      store.dispatch((0, _commands.runCommand)(what));
	      if (true) document.getElementsByClassName('claraplayer')[0].getElementsByTagName('canvas')[0].focus();
	    };
	  }
	
	  var toolChildren = [hoverStyle(store), (0, _h2.default)('ul.tools', { style: {
	      position: 'relative',
	      bottom: 0,
	      left: 0,
	      listStyleType: 'none',
	      padding: '0 5px',
	      margin: 0,
	      zIndex: 2147483647
	    } }, [svgIcons.glowFilter()].concat((0, _ramda.map)(function (key) {
	    var command = tools[key];
	    var active = command.isActive ? command.isActive(store) : command.active;
	    var label = command.active && command.activeLabel ? command.activeLabel : command.label;
	    var svgIcon = svgIcons[command.options.icon || key];
	    var iconChildren = [];
	
	    if (typeof svgIcon === 'function') {
	      iconChildren.push(svgIcon({ width: 34, height: 34, title: label }, { active: active, activeColor: activeColor }));
	    } else {
	      iconChildren.push((0, _h2.default)('span', { style: { color: active ? activeColor : '#fff' } }, label));
	    }
	
	    return (0, _h2.default)('li' + (active ? '.active' : ''), {
	      attrs: { title: label },
	      on: { click: click(key) },
	      style: {
	        cursor: 'pointer',
	        float: 'left',
	        borderRadius: '5px',
	        padding: '5px',
	        boxSizing: 'border-box'
	      }
	    }, iconChildren);
	  }, (0, _keys2.default)(tools))))];
	
	  var tLine = (0, _timeline2.default)(store);
	  if (tLine) toolChildren.push(tLine);
	
	  return (0, _h2.default)('span', { style: {
	      position: 'absolute',
	      left: '5px',
	      right: '5px',
	      bottom: '5px',
	      display: 'flex',
	      flexWrap: 'nowrap',
	      height: '54px'
	    } }, toolChildren);
	};

/***/ },
/* 318 */
/*!*********************************!*\
  !*** ./src/components/icons.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.glowFilter = glowFilter;
	exports.home = home;
	exports.orbit = orbit;
	exports.pan = pan;
	exports.zoom = zoom;
	exports.fullscreen = fullscreen;
	exports.vrMode = vrMode;
	exports.lenticularMode = lenticularMode;
	exports.deviceTracking = deviceTracking;
	exports.nodeRotate = nodeRotate;
	exports.nodeMove = nodeMove;
	exports.nodeScale = nodeScale;
	exports.pause = pause;
	exports.play = play;
	exports.select = select;
	
	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 113);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var filter = 'url(#glowfilter)';
	var activeColor = '#ffc85f';
	var blurColor = '#000';
	var color = '#fff';
	var padding = '0';
	var boxSizing = 'border-box';
	var viewBox = '-300 -300 1624 1624';
	var panViewBox = '-150 -150 812 812';
	
	function glowFilter() {
	  return (0, _h2.default)('svg', { attrs: { width: 0, height: 0 } }, [(0, _h2.default)('filter', { attrs: { id: 'glowfilter' } }, [(0, _h2.default)('feGaussianBlur', { attrs: { in: 'SourceAlpha', stdDeviation: 50, result: 'blur' } }), (0, _h2.default)('feOffset', { attrs: { in: 'blur', dx: 0, dy: 0, result: 'offsetBlur' } }), (0, _h2.default)('feFlood', { attrs: { 'flood-color': blurColor, 'flood-opacity': 1, result: 'offsetColor' } }), (0, _h2.default)('feComposite', { attrs: { in: 'offsetColor', in2: 'offsetBlur', operator: 'in', result: 'offsetBlurComposed' } }), (0, _h2.default)('feMerge', [(0, _h2.default)('feMergeNode', { attrs: { in: 'offsetBlurComposed' } }), (0, _h2.default)('feMergeNode', { attrs: { in: 'SourceGraphic' } })])])]);
	}
	
	// icomoon free svg icons
	
	function home(attrs, options) {
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [
	  //blurFilter('homefilter'),
	  (0, _h2.default)('path', { attrs: { fill: color, filter: filter, d: "M1024 608l-192-192v-288h-128v160l-192-192-512 512v32h128v320h320v-192h128v192h320v-320h128z" } })]);
	};
	
	function orbit(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M1024 384h-384l143.53-143.53c-72.53-72.526-168.96-112.47-271.53-112.47s-199 39.944-271.53 112.47c-72.526 72.53-112.47 168.96-112.47 271.53s39.944 199 112.47 271.53c72.53 72.526 168.96 112.47 271.53 112.47s199-39.944 271.528-112.472c6.056-6.054 11.86-12.292 17.456-18.668l96.32 84.282c-93.846 107.166-231.664 174.858-385.304 174.858-282.77 0-512-229.23-512-512s229.23-512 512-512c141.386 0 269.368 57.326 362.016 149.984l149.984-149.984v384z" } })]);
	}
	
	function pan(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: panViewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('g', { attrs: { transform: 'matrix(0.49680763,0.49680763,-0.49680763,0.49680763,255.01217,2.6223229)' } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M -0.49680099,-1.4900844 -0.49680795,206.9137 79.659562,126.75733 207.90699,255.00476 79.657586,383.25416 -0.49680795,303.09977 l 4.41e-6,208.40379 208.40379354,0 -80.15637,-80.15637 128.2494,-128.2494 c 43.4197,43.41971 90.25956,90.25956 128.2494,128.2494 l -80.15637,80.15637 208.4038,0 0,-208.40379 -80.1544,80.15439 -128.2494,-128.2494 c 42.74914,-42.74914 85.49828,-85.49828 128.24743,-128.24743 l 80.15637,80.15637 -10e-6,-208.4037813 -208.40379,-1e-5 80.1544,80.1543943 C 341.4983,121.41344 298.74916,164.16259 256.00002,206.91173 L 127.75259,78.664303 207.90699,-1.4900913 Z' } })])]);
	}
	
	// paths for diagonal arrows
	//h('path', { attrs: { fill, filter, d: "M1024 0h-416l160 160-192 192 96 96 192-192 160 160z"} }),
	//h('path', { attrs: { fill, filter, d: "M1024 1024v-416l-160 160-192-192-96 96 192 192-160 160z" } }),
	//h('path', { attrs: { fill, filter, d: "M0 1024h416l-160-160 192-192-96-96-192 192-160-160z" } }),
	//h('path', { attrs: { fill, filter, d: "M0 0v416l160-160 192 192 96-96-192-192 160-160z" } }),
	
	function zoom(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M992.262 871.396l-242.552-206.294c-25.074-22.566-51.89-32.926-73.552-31.926 57.256-67.068 91.842-154.078 91.842-249.176 0-212.078-171.922-384-384-384-212.076 0-384 171.922-384 384s171.922 384 384 384c95.098 0 182.108-34.586 249.176-91.844-1 21.662 9.36 48.478 31.926 73.552l206.294 242.552c35.322 39.246 93.022 42.554 128.22 7.356s31.892-92.898-7.354-128.22zM384 640c-141.384 0-256-114.616-256-256s114.616-256 256-256 256 114.616 256 256-114.614 256-256 256z" } })]);
	}
	
	function fullscreen(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [options.active ? (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M448 576v416l-160-160-192 192-96-96 192-192-160-160zM1024 96l-192 192 160 160h-416v-416l160 160 192-192z" } }) : (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M1024 0v416l-160-160-192 192-96-96 192-192-160-160zM448 672l-192 192 160 160h-416v-416l160 160 192-192z" } })]);
	}
	
	function vrMode(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M884.907 256h-748.373c-27.733 0-51.2 24.32-51.2 54.187v446.293c0 29.867 23.467 54.187 52.48 54.187h203.52c23.040 0 42.667-13.653 49.493-33.707l59.307-148.053c10.24-24.747 34.133-42.24 61.867-42.24s51.627 17.493 61.867 42.24l59.307 148.053c8.107 20.053 26.453 33.707 47.36 33.707h204.373c30.293 0 53.76-24.32 53.76-54.187v-446.293c0-29.867-23.467-54.187-53.76-54.187zM308.053 622.080c-52.053 0-94.72-43.947-94.72-97.707 0-55.040 42.667-97.707 94.72-97.707s94.293 42.667 94.293 97.707c0 53.76-42.24 97.707-94.293 97.707zM715.947 622.080c-52.053 0-94.293-43.947-94.293-97.707s42.24-97.707 94.293-97.707c52.053 0 94.72 43.947 94.72 97.707s-42.667 97.707-94.72 97.707z" } })]);
	}
	
	function lenticularMode(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [options.active ? (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M317.143 762.857l44.571-80.571q-49.714-36-77.714-90.857t-28-116q0-69.143 34.857-128.571-130.857 66.857-217.714 201.714 95.429 147.429 244 214.286zM539.429 329.143q0-11.429-8-19.429t-19.429-8q-71.429 0-122.571 51.143t-51.143 122.571q0 11.429 8 19.429t19.429 8 19.429-8 8-19.429q0-49.143 34.857-84t84-34.857q11.429 0 19.429-8t8-19.429zM746.857 220q0 4-0.571 5.143-60 107.429-180 323.429t-180.571 324l-28 50.857q-5.714 9.143-16 9.143-6.857 0-76.571-40-9.143-5.714-9.143-16 0-6.857 25.143-49.714-81.714-37.143-150.571-98.857t-119.143-140q-11.429-17.714-11.429-39.429t11.429-39.429q87.429-134.286 217.143-212t283.429-77.714q50.857 0 102.857 9.714l30.857-55.429q5.714-9.143 16-9.143 2.857 0 10.286 3.429t17.714 8.857 18.857 10.571 18 10.571 11.143 6.571q9.143 5.714 9.143 15.429zM768 475.429q0 79.429-45.143 144.857t-119.429 94l160-286.857q4.571 25.714 4.571 48zM1024 548.571q0 20-11.429 39.429-22.286 36.571-62.286 82.857-85.714 98.286-198.571 152.571t-239.714 54.286l42.286-75.429q121.143-10.286 224.286-78.286t172.286-175.429q-65.714-102.286-161.143-168l36-64q54.286 36.571 104.286 87.429t82.571 105.143q11.429 19.429 11.429 39.429z" } }) : (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M950.857 548.571q-86.857-134.857-217.714-201.714 34.857 59.429 34.857 128.571 0 105.714-75.143 180.857t-180.857 75.143-180.857-75.143-75.143-180.857q0-69.143 34.857-128.571-130.857 66.857-217.714 201.714 76 117.143 190.571 186.571t248.286 69.429 248.286-69.429 190.571-186.571zM539.429 329.143q0-11.429-8-19.429t-19.429-8q-71.429 0-122.571 51.143t-51.143 122.571q0 11.429 8 19.429t19.429 8 19.429-8 8-19.429q0-49.143 34.857-84t84-34.857q11.429 0 19.429-8t8-19.429zM1024 548.571q0 19.429-11.429 39.429-80 131.429-215.143 210.571t-285.429 79.143-285.429-79.429-215.143-210.286q-11.429-20-11.429-39.429t11.429-39.429q80-130.857 215.143-210.286t285.429-79.429 285.429 79.429 215.143 210.286q11.429 20 11.429 39.429z" } })]);
	}
	
	//export function enableParallaxmode(attrs, options) {
	//  const fill = options.active ? options.activeColor : color;
	
	//  return h('svg', { attrs: { viewBox, ...attrs }, style: { padding: boxSizing }}, [
	//    h('path', { attrs: { fill, filter, d: "M494.464 96.192l-427.584 184.224 428 182.784 432.416-183.2-432.832-183.808zM512 486.208v441.6l415.84-197.408v-420.832l-415.84 176.64zM64.16 730.4l417.248 197.408v-441.6l-417.248-176.64v420.832z" } }),
	//  ]);
	//}
	
	//export function disableParallaxmode(attrs, options) {
	//  const fill = '#000';
	
	//  return h('svg', { attrs: { viewBox, ...attrs }, style: { padding: boxSizing }}, [
	//    h('path', { attrs: { fill, filter, d: "M494.464 96.192l-427.584 184.224 428 182.784 432.416-183.2-432.832-183.808zM512 486.208v441.6l415.84-197.408v-420.832l-415.84 176.64zM64.16 730.4l417.248 197.408v-441.6l-417.248-176.64v420.832z" } }),
	//  ]);
	//}
	//
	function deviceTracking(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M395 37.2c-24.2 1.4-50.2 3.6-57.8 4.8-28.2 4.4-60.2 22.8-77.4 44.4-7.8 9.8-23.4 39-21.6 40.4 1.2 1 26.4 9.2 26.6 8.6 0.2-0.2 3.2-6.4 7-13.8 11.6-23.6 38.8-44 65.4-49.6 9.2-1.8 59.8-6 74.4-6h6.4v85.6l-16.4 1.2c-9.2 0.6-38.2 2-64.6 3.2-52.8 2.4-92.6 6.4-108 11-13 3.8-24.6 11.4-31.4 20.8-5 7-15.6 38.6-21.6 64l-2.6 10.6-8.2-1.2c-4.4-0.8-11.4-1.8-15.2-2.4l-7-1.2-17.6 88.4c-12.8 63.6-17 89-15.4 90 1.2 0.8 8.4 2.4 15.8 3.8l13.4 2.4-1.8 13.4c-1 7.4-1.8 31-2 52.4-0.2 34.6 0.2 40.4 4 51.4 15.2 45.6 59.8 72 133 78.6 24 2.2 25.2 2.2 42.6-3 62.8-18.2 121.4-24.2 219-22.4 79 1.6 130.2 8 175.6 22.4 15 4.8 17 5 38.6 3.2 73.4-6.2 118.6-32.2 134.8-77.2 4.6-13.2 6.4-64.6 3.2-95.2-1.4-12.2-2-22.6-1.6-23s6.8-2 14.2-3.6c7.4-1.4 13.8-3.2 14.4-3.6 0.4-0.6-7-40.4-16.8-88.8l-17.6-87.8-5.8 0.2c-3.4 0-10.2 0.8-15.2 1.6l-9.2 1.6-6.2-25c-9-35.4-13.2-45.8-22.2-54-8.8-8-30-18.4-43.6-21.6-15.4-3.4-63.8-7.4-120-10.2l-52.6-2.4v-85.6l5.6 1.2c3 0.6 18 1.6 33.4 2.2 15.4 0.8 34 2.6 41.6 4 28.2 5.8 54.4 26 67 51.6 3.8 7.6 7.8 13.2 9 12.8 1.4-0.4 7.2-2.4 13-4.2 5.6-2 10.4-4.6 10.4-6 0-1.6-3.4-9.4-7.4-17.4-10.6-21.4-32.6-43-54.4-53.6-9.2-4.4-23-9.4-31-11-38.2-8.2-203.8-11.6-296.2-6zM592 186c68.4 3.2 106 9 132.2 20.2 12 5.2 16.8 11.8 34.2 46.8 37.6 75 76.8 210.6 72.6 250.6-0.8 7.4-2.6 15.6-4 18.6-3.6 6.8-18.4 20.2-32.4 29.2-12.4 7.8-61.8 32-76.6 37.4-8.6 3-8.8 3-4-0.4 49.6-35 63.4-45.6 76.6-58.4 17.8-17.6 17.4-16 12.4-56-4.8-39-20-94.8-40.4-149-11-29.4-36.4-82.4-42.4-88.4-7.4-7.8-43.2-16.4-86.2-20.6-34.4-3.4-158.2-4.8-206.8-2.2-60.4 3.2-89.4 7.4-112.2 16.4-12 4.6-16.8 11.6-33.6 49.8-38 86.6-61.4 172.2-61.4 224.4v15.4l13.2 13.2c12.8 12.6 43.4 35.6 67.4 50.4 6.2 4 11.2 7.6 10.6 8-1.2 1.4-40.4-15-62.8-26.2-24.8-12.4-45-26.6-49-34.6-1.6-3-4-15.6-5.4-27.6-2.2-20-2-24.2 1.8-46.4 8-46.4 22.4-94.6 45.6-153.6 13.4-34 32-73 40.2-84.2 7.8-10.6 21.2-17 46.4-22.4 19.2-4.2 70.6-10 98-11 38.6-1.6 127.2-1.2 166 0.6zM194 656.8c0 6.4 6 33 10 45.2 21.6 63.6 98.4 169.8 171 236.8 28 25.8 44 37.4 60.8 44.2 25.2 10.4 69 15 103.6 11.2 52.2-6 69.8-16 125.6-71 90-89.2 156-193 163.8-257.8l1.4-11.4h-30.2v7.6c0 19.8-18 63.4-41.8 101.4-38 60.2-102 134.8-150 174.8-25.4 21-49.8 28.2-96.2 28.2-41.2 0-63.6-5.4-85.6-20.4-15.8-10.8-56-49.2-79-75.6-73.4-83.8-117.8-157.2-124.4-205.6l-1.4-10.4h-13.8c-10.6 0-13.8 0.6-13.8 2.8zM407.2 770.6c-1.8 7.4-3.2 13.6-3.2 14.2 0 1.6 28 7.4 55 11.4 43.2 6.4 79.6 4.6 136-6.2 12.2-2.4 22.2-4.6 22.6-5 0.4-0.2-1-6.6-2.8-14l-3.4-13.4-7.2 1c-4 0.6-17.6 3.2-30.2 5.6-33.6 6.6-93.2 6.6-126 0.2-12.6-2.6-26.2-5.2-30.2-5.8l-7.2-1-3.4 13z" } })]);
	}
	
	function nodeRotate(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M1024 384h-384l143.53-143.53c-72.53-72.526-168.96-112.47-271.53-112.47s-199 39.944-271.53 112.47c-72.526 72.53-112.47 168.96-112.47 271.53s39.944 199 112.47 271.53c72.53 72.526 168.96 112.47 271.53 112.47s199-39.944 271.528-112.472c6.056-6.054 11.86-12.292 17.456-18.668l96.32 84.282c-93.846 107.166-231.664 174.858-385.304 174.858-282.77 0-512-229.23-512-512s229.23-512 512-512c141.386 0 269.368 57.326 362.016 149.984l149.984-149.984v384z" } }), (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M512 250l262 262-262 262-262-262z" } })]);
	}
	
	function nodeMove(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: panViewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('g', { attrs: { transform: 'matrix(0.49680763,0.49680763,-0.49680763,0.49680763,255.01217,2.6223229)' } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M -0.49680099,-1.4900844 -0.49680795,206.9137 79.659562,126.75733 207.90699,255.00476 79.657586,383.25416 -0.49680795,303.09977 l 4.41e-6,208.40379 208.40379354,0 -80.15637,-80.15637 128.2494,-128.2494 c 43.4197,43.41971 90.25956,90.25956 128.2494,128.2494 l -80.15637,80.15637 208.4038,0 0,-208.40379 -80.1544,80.15439 -128.2494,-128.2494 c 42.74914,-42.74914 85.49828,-85.49828 128.24743,-128.24743 l 80.15637,80.15637 -10e-6,-208.4037813 -208.40379,-1e-5 80.1544,80.1543943 C 341.4983,121.41344 298.74916,164.16259 256.00002,206.91173 L 127.75259,78.664303 207.90699,-1.4900913 Z' } }), (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M256 0l256 256-256 256-256-256z" } })])]);
	}
	
	function nodeScale(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M992.262 871.396l-242.552-206.294c-25.074-22.566-51.89-32.926-73.552-31.926 57.256-67.068 91.842-154.078 91.842-249.176 0-212.078-171.922-384-384-384-212.076 0-384 171.922-384 384s171.922 384 384 384c95.098 0 182.108-34.586 249.176-91.844-1 21.662 9.36 48.478 31.926 73.552l206.294 242.552c35.322 39.246 93.022 42.554 128.22 7.356s31.892-92.898-7.354-128.22zM384 640c-141.384 0-256-114.616-256-256s114.616-256 256-256 256 114.616 256 256-114.614 256-256 256z" } }), (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M375 181l200 200-200 200-200-200z" } })]);
	}
	
	function pause(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M64 0h384v1024h-384z' } }), (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M576 0h384v1024h-384z' } })]);
	}
	
	function play(attrs, options) {
	  var fill = options.active ? options.activeColor : color;
	
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M138 0L1024 512L138 1024z' } })]);
	}
	
	function select(attrs, options) {
	  var fill = options.active ? options.activeColor : '#000'; // FIXME white default not displayed?
	  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: '0 0 32 32' }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: "M16 0c-8.837 0-16 7.163-16 16s7.163 16 16 16 16-7.163 16-16-7.163-16-16-16zM16 28c-6.627 0-12-5.373-12-12s5.373-12 12-12c6.627 0 12 5.373 12 12s-5.373 12-12 12zM10 16c0-3.314 2.686-6 6-6s6 2.686 6 6c0 3.314-2.686 6-6 6s-6-2.686-6-6z" } })]);
	}

/***/ },
/* 319 */
/*!************************************!*\
  !*** ./src/components/timeline.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = timeline;
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	var _icons = __webpack_require__(/*! ./icons */ 318);
	
	var _marker = __webpack_require__(/*! ./marker */ 320);
	
	var _marker2 = _interopRequireDefault(_marker);
	
	var _player = __webpack_require__(/*! ../modules/player */ 265);
	
	var _animation = __webpack_require__(/*! ../modules/animation */ 132);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var dragHandler = null;
	var timeoutHandler = null;
	var visible = false;
	
	function timeline(store) {
	  var timelineStyle = {
	    flex: '1 1 auto',
	    position: 'relative',
	    bottom: 0,
	    right: 0,
	    borderRadius: '5px',
	    padding: '0 20px'
	  };
	
	  var rulerStyle = {
	    boxSizing: 'border-box',
	    backgroundColor: 'rgba(0, 0, 0, 0.2)',
	    border: '1px solid #ccc',
	    position: 'relative',
	    top: '17px',
	    left: '56px',
	    height: '10px',
	    width: 'calc(100% - 55px)',
	    cursor: 'pointer'
	  };
	
	  var activeColor = (0, _player.getActiveColor)(store);
	  var hoverColor = (0, _player.getHoverColor)(store);
	  var iconAttrs = { width: 34, height: 34, title: 'play' };
	  var iconOptions = { active: false, activeColor: activeColor };
	
	  var timeAnimation = (0, _animation.getTimelineAnimation)(store);
	  if (!timeAnimation) return null;
	  var startTime = timeAnimation.start;
	  var duration = timeAnimation.duration / Math.abs(timeAnimation.playSpeed);
	  var played = Math.max(Math.min(((0, _animation.getTime)(store) - startTime) / duration, 1), 0) * 100;
	
	  var playedStyle = {
	    backgroundColor: activeColor,
	    width: 'calc(' + played + '% - 2px)',
	    height: '6px',
	    position: 'absolute',
	    left: '1px',
	    top: '1px',
	    cursor: 'pointer'
	  };
	
	  var buttonStyle = {
	    position: 'relative',
	    display: 'inline-block',
	    verticalAlign: 'middle',
	    top: '-5px',
	    cursor: 'pointer'
	  };
	
	  var hoverStyle = '\n    div.claraplayer div div svg:hover path {\n    fill: ' + hoverColor + ';\n  }';
	
	  function createHandleDrag(_ref, touch) {
	    var width = _ref.width;
	    var left = _ref.left;
	
	    return function (ev) {
	      visible = true;
	      if (timeoutHandler) {
	        window.clearTimeout(timeoutHandler);
	      }
	      timeoutHandler = window.setTimeout(function () {
	        visible = false;
	        store.dispatch({ type: 'POKE' });
	      }, 2000);
	
	      var evX = touch ? ev.touches[0].pageX : ev.pageX;
	      var percentTime = Math.max(Math.min((evX - left) / width, 1), 0);
	      var time = percentTime * duration + startTime;
	      store.dispatch((0, _animation.setTime)(time));
	    };
	  }
	
	  function handleClick(ev) {
	    //console.log(ev.target.parentNode);
	    visible = true;
	    if (timeoutHandler) {
	      window.clearTimeout(timeoutHandler);
	    }
	    timeoutHandler = window.setTimeout(function () {
	      visible = false;
	      store.dispatch({ type: 'POKE' });
	    }, 2000);
	
	    if (dragHandler !== null) {
	      window.removeEventListener('mousemove', dragHandler);
	      window.removeEventListener('mouseup', endDrag);
	      window.removeEventListener('touchmove', dragHandler);
	      window.removeEventListener('touchend', endDrag);
	    }
	
	    var touch = !!ev.touches;
	    var evX = touch ? ev.touches[0].clientX : ev.clientX;
	
	    var rectElement = ev.target.className === 'ruler' ? ev.target : ev.target.parentNode;
	    var rect = rectElement.getBoundingClientRect();
	
	    var time = (evX - rect.left) / rect.width * duration + startTime;
	    store.dispatch((0, _animation.setTime)(time));
	
	    dragHandler = createHandleDrag(rect, touch);
	    if (!touch) {
	      window.addEventListener('mousemove', dragHandler);
	      window.addEventListener('mouseup', endDrag);
	    } else {
	      window.addEventListener('touchmove', dragHandler);
	      window.addEventListener('touchend', endDrag);
	    }
	  }
	
	  function endDrag(ev) {
	    window.removeEventListener('mousemove', dragHandler);
	    window.removeEventListener('mouseup', endDrag);
	    window.removeEventListener('touchmove', dragHandler);
	    window.removeEventListener('touchend', endDrag);
	    dragHandler = null;
	  }
	
	  var icon = (0, _animation.isPlaying)(store) ? (0, _icons.pause)(iconAttrs, iconOptions) : (0, _icons.play)(iconAttrs, iconOptions);
	  var clickAction = (0, _animation.isPlaying)(store) ? function () {
	    return store.dispatch((0, _animation.stopPlaying)());
	  } : function () {
	    return store.dispatch((0, _animation.startPlaying)());
	  };
	
	  return (0, _h2.default)('div', { style: timelineStyle }, [(0, _h2.default)('style', { props: { innerHTML: hoverStyle } }), (0, _h2.default)('div.ruler', { style: rulerStyle, on: { mousedown: handleClick, touchstart: handleClick } }, [(0, _h2.default)('div.played', { style: playedStyle }), (0, _marker2.default)(store, played, duration, visible)]), (0, _h2.default)('div', { style: buttonStyle, on: { click: clickAction } }, [icon])]);
	}

/***/ },
/* 320 */
/*!**********************************!*\
  !*** ./src/components/marker.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = marker;
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function marker(store, percentPlayed, duration, visible) {
	
	  var markerStyle = {
	    width: '0',
	    height: '100%',
	    position: 'absolute',
	    left: percentPlayed + '%',
	    top: '0',
	    pointerEvents: 'auto',
	    cursor: 'pointer'
	  };
	
	  var toolTipStyle = {
	    boxSizing: 'border-box',
	    position: 'absolute',
	    zIndex: '1070',
	    display: 'block',
	    visibility: 'visible',
	    fontSize: '12px',
	    fontWeight: 'normal',
	    lineHeight: '1.4',
	    top: '-32px',
	    left: '-25px',
	    width: '50px',
	    height: '22px',
	    marginTop: '-3px',
	    padding: '5px 0',
	    opacity: '1'
	  };
	  if (!visible) {
	    toolTipStyle.opacity = '0';
	    toolTipStyle.transition = 'opacity 0.15s linear';
	  }
	
	  var innerStyle = {
	    maxWidth: '200px',
	    padding: '3px 8px',
	    color: '#ffffff',
	    textAlign: 'center',
	    textDecoration: 'none',
	    backgroundColor: '#000000',
	    borderRadius: '4px',
	    boxShadow: '#000 0 0 5px',
	    margin: '0 auto',
	    userSelect: 'none',
	    WebkitUserSelect: 'none',
	    MozUserSelect: 'none'
	  };
	
	  var arrowStyle = {
	    boxSizing: 'border-box',
	    position: 'absolute',
	    width: '0',
	    height: '0',
	    bottom: '-10px',
	    left: '50%',
	    marginLeft: '-5px',
	    borderWidth: '5px 5px 0',
	    borderTopColor: '#000000',
	    borderRightColor: 'transparent',
	    borderBottomColor: 'transparent',
	    borderLeftColor: 'transparent',
	    borderStyle: 'solid'
	  };
	
	  function stopEvent(ev) {
	    ev.stopPropagation();
	  }
	
	  return (0, _h2.default)('div.marker', { style: markerStyle, on: { mousedown: stopEvent, touchstart: stopEvent } }, [(0, _h2.default)('div.tooltip', { style: toolTipStyle }, [(0, _h2.default)('div.tooltip-arrow', { style: arrowStyle }), (0, _h2.default)('div.tooltip-inner', { style: innerStyle }, (duration * percentPlayed / 100000).toFixed(1))])]);
	}

/***/ },
/* 321 */,
/* 322 */,
/* 323 */
/*!****************************************!*\
  !*** ./src/translators/tools/index.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _orbit = __webpack_require__(/*! ./orbit */ 273);
	
	var _orbit2 = _interopRequireDefault(_orbit);
	
	var _pan = __webpack_require__(/*! ./pan */ 324);
	
	var _pan2 = _interopRequireDefault(_pan);
	
	var _zoom = __webpack_require__(/*! ./zoom */ 274);
	
	var _zoom2 = _interopRequireDefault(_zoom);
	
	var _nodeMove = __webpack_require__(/*! ./nodeMove */ 326);
	
	var _nodeMove2 = _interopRequireDefault(_nodeMove);
	
	var _nodeRotate = __webpack_require__(/*! ./nodeRotate */ 329);
	
	var _nodeRotate2 = _interopRequireDefault(_nodeRotate);
	
	var _nodeScale = __webpack_require__(/*! ./nodeScale */ 331);
	
	var _nodeScale2 = _interopRequireDefault(_nodeScale);
	
	var _select = __webpack_require__(/*! ./select */ 332);
	
	var _select2 = _interopRequireDefault(_select);
	
	var _fullscreen = __webpack_require__(/*! ./fullscreen */ 333);
	
	var _fullscreen2 = _interopRequireDefault(_fullscreen);
	
	var _home = __webpack_require__(/*! ./home */ 334);
	
	var _home2 = _interopRequireDefault(_home);
	
	var _vrMode = __webpack_require__(/*! ./vrMode */ 335);
	
	var _vrMode2 = _interopRequireDefault(_vrMode);
	
	var _firstPersonMode = __webpack_require__(/*! ./firstPersonMode */ 342);
	
	var _firstPersonMode2 = _interopRequireDefault(_firstPersonMode);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var tools = {
	  orbit: _orbit2.default,
	  pan: _pan2.default,
	  zoom: _zoom2.default,
	  home: _home2.default,
	  nodeMove: _nodeMove2.default,
	  nodeRotate: _nodeRotate2.default,
	  nodeScale: _nodeScale2.default,
	  select: _select2.default,
	  fullscreen: _fullscreen2.default,
	  vrMode: _vrMode2.default,
	  firstPersonMode: _firstPersonMode2.default
	};
	
	exports.default = tools;

/***/ },
/* 324 */
/*!**************************************!*\
  !*** ./src/translators/tools/pan.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = pan;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _decompose = __webpack_require__(/*! ../utils/decompose */ 272);
	
	var _decompose2 = _interopRequireDefault(_decompose);
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 142);
	
	var _updateCameraLookAtTarget = __webpack_require__(/*! ../utils/updateCameraLookAtTarget */ 266);
	
	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);
	
	var _getProjectionMatrix = __webpack_require__(/*! ../utils/getProjectionMatrix */ 325);
	
	var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);
	
	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 269);
	
	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _Math = Math;
	var tan = _Math.tan;
	var cos = _Math.cos;
	var atan = _Math.atan;
	var acos = _Math.acos;
	var min = _Math.min;
	var max = _Math.max;
	var pow = _Math.pow;
	var PI = _Math.PI;
	var sqrt = _Math.sqrt;
	
	var cameraProjectMatrix = new _three2.default.Matrix4();
	var cameraUnprojectMatrix = new _three2.default.Matrix4();
	var ndcReferencePoint = new _three2.default.Vector3();
	var worldRelative = new _three2.default.Vector3();
	var deltaReferencePoint = new _three2.default.Vector3();
	var referencePoint = new _three2.default.Vector3();
	var translationMatrix = new _three2.default.Matrix4();
	
	var cameraPosition = new _three2.default.Vector3();
	var targetPosition = new _three2.default.Vector3();
	var offset = new _three2.default.Vector3();
	
	function pan(store, translator) {
	  function move(_ref) {
	    var deltaX = _ref.deltaX;
	    var deltaY = _ref.deltaY;
	
	    updatePan(store, new _three2.default.Vector2(deltaX, deltaY));
	  }
	
	  return {
	    label: 'Pan',
	    enabled: true,
	    display: {
	      playerTools: true
	    },
	    options: {},
	
	    tool: {
	      drag: function drag(ev) {
	        if (!this.active && ev.which !== 2 && ev.which !== 3) return false;
	
	        return {
	          momentum: true,
	          handle: function handle(ev) {
	            move(ev);
	          }
	        };
	      },
	      swipe: function swipe(ev) {
	        move(ev);
	      }
	    }
	  };
	}
	
	function updatePan(store, mouseDelta) {
	  var cameraId = (0, _player.getCamera)(store);
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
	  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
	  var rect = (0, _player.getRect)(store);
	
	  var projectionMatrix = (0, _getProjectionMatrix2.default)((0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' }));
	  var relativeDelta = new _three2.default.Vector2().copy(mouseDelta).divide(rect).multiplyScalar(2.0);
	  relativeDelta.x *= -1;
	
	  var invCameraWorldMatrix = new _three2.default.Matrix4().getInverse(cameraWorldMatrix, true);
	  cameraProjectMatrix.copy(projectionMatrix).multiply(invCameraWorldMatrix);
	
	  ndcReferencePoint.setFromMatrixPosition(targetWorldMatrix).applyProjection(cameraProjectMatrix);
	  cameraUnprojectMatrix.getInverse(cameraProjectMatrix, true);
	
	  referencePoint.set(0, 0, ndcReferencePoint.z).applyProjection(cameraUnprojectMatrix);
	  deltaReferencePoint.set(relativeDelta.x, relativeDelta.y, ndcReferencePoint.z).applyProjection(cameraUnprojectMatrix);
	
	  // ensure that NDC has the same layout as mouseDelta coordinate space
	  worldRelative.copy(deltaReferencePoint).sub(referencePoint);
	
	  //bounding box constraining
	  if (cameraData.radiusConstraint && worldRelative.length() > 0) {
	    var _cameraData$radiusCon = cameraData.radiusConstraint;
	    var maxBoundingSphere = _cameraData$radiusCon.maxBoundingSphere;
	    var minBoundingSphere = _cameraData$radiusCon.minBoundingSphere;
	
	    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	    targetPosition.setFromMatrixPosition(targetWorldMatrix);
	
	    var directionNorm = new _three2.default.Vector3().copy(worldRelative).normalize();
	    var camRay = new _three2.default.Ray(cameraPosition, directionNorm);
	    var targRay = new _three2.default.Ray(targetPosition, directionNorm);
	
	    var targHit = targRay.intersectSphere(minBoundingSphere).sub(targetPosition).length() - (0.001);
	
	    var inCamHit = camRay.intersectSphere(minBoundingSphere);
	    if (inCamHit) inCamHit = inCamHit.sub(cameraPosition).length() - (0.001);else inCamHit = Infinity;
	
	    var outCamHit = camRay.intersectSphere(maxBoundingSphere).sub(cameraPosition).length() - (0.001);
	
	    var moveLength = Math.min(worldRelative.length(), targHit, inCamHit, outCamHit);
	    worldRelative.normalize().multiplyScalar(moveLength);
	  }
	
	  translationMatrix.makeTranslation(worldRelative.x, worldRelative.y, worldRelative.z);
	  offset.addVectors(cameraData.offset, worldRelative);
	  cameraData.offset = offset;
	
	  targetWorldMatrix.multiplyMatrices(translationMatrix, targetWorldMatrix);
	  cameraWorldMatrix.multiplyMatrices(translationMatrix, cameraWorldMatrix);
	
	  if (playerData.constraintCameraY && playerData.orbitMode !== 'trackball') {
	    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	    targetPosition.setFromMatrixPosition(targetWorldMatrix);
	
	    if (cameraPosition.y < 0) {
	      targetPosition.y -= cameraPosition.y;
	      cameraPosition.y = 0;
	    }
	    targetWorldMatrix.setPosition(targetPosition);
	    cameraWorldMatrix.setPosition(cameraPosition);
	  }
	
	  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	
	  store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
	  store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
	  //store.dispatch(merge([cameraId, 'Camera', 0], {offset}));
	}

/***/ },
/* 325 */
/*!******************************************************!*\
  !*** ./src/translators/utils/getProjectionMatrix.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getProjectionMatrix;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getProjectionMatrix(cameraData) {
	  var projectionMatrix = new _three2.default.Matrix4();
	  if (cameraData.projection === 'Orthographic') {
	    var size = /* this.computeCameraSize(true) ||*/{ width: 1, height: 1 };
	    projectionMatrix.makeOrthographic(-size.width, size.width, -size.height, size.height, cameraData.nearClip, cameraData.farClip);
	  } else {
	    // const filmSizeVec = new THREE.Vector2(cameraData.get('filmSize'),
	    //     cameraData.get('filmSize') * cameraData.get('aspectRatio'));
	    //  console.log(navigator.getProjectionMatrix:, data.fieldOfView, data.aspectRatio);
	    projectionMatrix.makePerspective(cameraData.fieldOfView, cameraData.aspectRatio, cameraData.nearClip, cameraData.farClip);
	  }
	  return projectionMatrix;
	}

/***/ },
/* 326 */
/*!*******************************************!*\
  !*** ./src/translators/tools/nodeMove.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = nodeMove;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _getProjectionMatrix = __webpack_require__(/*! ../utils/getProjectionMatrix */ 325);
	
	var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	var _selection = __webpack_require__(/*! ../../modules/selection */ 282);
	
	var _gizmos = __webpack_require__(/*! ./gizmos */ 327);
	
	var _getProjectedPoint = __webpack_require__(/*! ./utils/getProjectedPoint */ 328);
	
	var _getProjectedPoint2 = _interopRequireDefault(_getProjectedPoint);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _Math = Math;
	var PI = _Math.PI;
	var sin = _Math.sin;
	
	var invCameraWorldMatrix = new _three2.default.Matrix4();
	var cameraProjectMatrix = new _three2.default.Matrix4();
	var cameraUnprojectMatrix = new _three2.default.Matrix4();
	var inverseParent = new _three2.default.Matrix4();
	var referencePoint = new _three2.default.Vector3();
	var deltaReferencePoint = new _three2.default.Vector3();
	
	//const defaultOptions = {
	//  displayGizmo: true,
	//  useXAxis: true,
	//  useYAxis: true,
	//  useZAxis: true,
	//  defaultPlane: { x: 0, y: 0 },
	//}
	
	//updateTool('nodeMove', { displayGizmo: false });
	
	function nodeMove(store, translator) {
	  var activeAxis = false;
	
	  return {
	    label: 'Move Node',
	    enabled: true,
	    display: {
	      playerTools: false
	    },
	
	    options: {
	      displayGizmo: true,
	      mode: 'free',
	      plane: {
	        normal: { x: 0, y: 1, z: 0 },
	        constant: 0
	      }
	    },
	
	    tool: {
	      hover: function hover(ev) {
	        if (!this.active) return;
	        activeAxis = (0, _gizmos.highlightAxis)(translator, ev, activeAxis);
	      },
	
	      drag: function drag(ev) {
	        if (ev.which !== 1 || !this.active || ev.metaKey) return false;
	        var self = this;
	        return {
	          momentum: !activeAxis,
	          handle: function handle(ev) {
	            switch (self.options.mode) {
	              case 'plane':
	                moveNodeOnPlane(store, ev.deltaX, ev.deltaY, self.options.plane);
	                break;
	              case 'objects':
	                moveNodeOnObjects(store, ev.clientX, ev.clientY, self.options.objects);
	                break;
	              default:
	                moveNodeFree(store, ev.deltaX, ev.deltaY, activeAxis);
	                break;
	            }
	          }
	        };
	      }
	    },
	
	    widget: {
	      draw: function draw(manipulatorsObject) {
	        manipulatorsObject.add((0, _gizmos.drawMoveGizmo)());
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      },
	
	      position: function position(manipulatorsObject) {
	        var selectedNodes = (0, _selection.getSelectedNodes)(store);
	        if (!selectedNodes.length) {
	          manipulatorsObject.visible = false;
	          return;
	        }
	
	        manipulatorsObject.visible = true;
	        var manipId = selectedNodes[0];
	        var worldTransform = (0, _scene.getWorldTransform)(store, manipId);
	        var position = new _three2.default.Vector3();
	        position.setFromMatrixPosition(worldTransform);
	        manipulatorsObject.position.set(position.x, position.y, position.z);
	        //manipulatorsObject.scale.set(2,2,2);
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      }
	    }
	  };
	}
	
	function moveNodeFree(store, x, y, restrictToAxis) {
	  var selectedNodes = (0, _selection.getSelectedNodes)(store);
	  if (!selectedNodes.length) return;
	  var manipId = selectedNodes[0];
	
	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	  var nodeMatrix = (0, _scene.getWorldTransform)(store, manipId);
	  if (!nodeMatrix) return;
	
	  var parentMatrix = (0, _scene.getWorldTransform)(store, (0, _scene.find)(store, { id: manipId, parent: true }));
	  var nodePosition = new _three2.default.Vector3().setFromMatrixPosition(nodeMatrix);
	  deltaReferencePoint.copy((0, _getProjectedPoint2.default)(store, manipId, x, y));
	
	  if (restrictToAxis) {
	    var projVector = new _three2.default.Vector3(0, 0, 0);
	    projVector[restrictToAxis] = 1;
	
	    var targToCam = new _three2.default.Vector3().setFromMatrixPosition(cameraWorldMatrix).sub(nodePosition);
	    var origin = new _three2.default.Vector3(0, 0, 0);
	    var plane = new _three2.default.Plane().setFromCoplanarPoints(targToCam, projVector, origin);
	    deltaReferencePoint.projectOnPlane(plane.normal);
	
	    var camToMove = new _three2.default.Vector3().subVectors(deltaReferencePoint, targToCam);
	    deltaReferencePoint.projectOnVector(projVector).normalize();
	    var alpha = targToCam.angleTo(deltaReferencePoint);
	    var beta = PI - targToCam.angleTo(camToMove);
	    var gamma = PI - alpha - beta;
	    var axis = targToCam.length() * sin(beta) / sin(gamma);
	    deltaReferencePoint.multiplyScalar(axis);
	  }
	
	  nodePosition.add(deltaReferencePoint);
	
	  nodeMatrix.setPosition(nodePosition);
	  if (parentMatrix) nodeMatrix.premultiply(inverseParent.getInverse(parentMatrix));
	
	  nodePosition.setFromMatrixPosition(nodeMatrix);
	
	  // FIXME: Restrict to axis:
	  //if (restrictToAxis) console.log('restrict to axis: ', restrictToAxis);
	
	  store.dispatch((0, _scene.set)({ id: manipId, plug: 'Transform', property: 'translation' }, nodePosition));
	}
	
	var upVector = new _three2.default.Vector3(0, 1, 0);
	
	var stripParentTransform = (function () {
	  var newLocalTransform = new _three2.default.Matrix4();
	  var invParentTransform = new _three2.default.Matrix4();
	
	  return function (store, nodeId, position, quaternion, scale) {
	    newLocalTransform.compose(position, quaternion, scale);
	
	    var parentId = (0, _scene.find)(store, { id: nodeId, parent: true });
	    var parentTransform = (0, _scene.getWorldTransform)(store, parentId);
	    if (parentTransform) {
	      invParentTransform.getInverse(parentTransform, true);
	      newLocalTransform.premultiply(invParentTransform);
	      newLocalTransform.decompose(position, quaternion, scale);
	    }
	  };
	})();
	
	var setNodePosition = (function () {
	  var scale = new _three2.default.Vector3();
	  var quaternion = new _three2.default.Quaternion();
	  var euler = new _three2.default.Euler();
	
	  return function (store, nodeId, position) {
	    var scaleNode = (0, _scene.get)(store, { id: nodeId, plug: 'Transform', property: 'scale' });
	    var rotateNode = (0, _scene.get)(store, { id: nodeId, plug: 'Transform', property: 'rotation' });
	    var rotateOrder = (0, _scene.get)(store, { id: nodeId, plug: 'Transform', property: 'rotateOrder' });
	    scale.set(scaleNode.x, scaleNode.y, scaleNode.z);
	    euler.set(rotateNode, rotateOrder);
	    quaternion.setFromEuler(euler);
	
	    stripParentTransform(store, nodeId, position, quaternion, scale);
	
	    //store.dispatch(set({id:nodeId, plug:'Transform', property:'rotation'}, newEuler.toVector3().multiplyScalar(180/Math.PI)));
	    store.dispatch((0, _scene.set)({ id: nodeId, plug: 'Transform', property: 'translation' }, position));
	  };
	})();
	
	var getNodeNdc = (function () {
	  var oldPosition = new _three2.default.Vector3();
	  var inverseCameraMatrix = new _three2.default.Matrix4();
	
	  return function (store, nodeId) {
	    oldPosition.setFromMatrixPosition((0, _scene.getWorldTransform)(store, nodeId));
	    var camera = (0, _player.getThreeCamera)(store);
	    inverseCameraMatrix.getInverse(camera.matrix, true).premultiply(camera.projectionMatrix);
	    oldPosition.applyProjection(inverseCameraMatrix);
	    return oldPosition;
	  };
	})();
	
	var moveNodeOnObjects = (function () {
	  var newQuaternion = new _three2.default.Quaternion();
	
	  return function (store, x, y, objects) {
	    var rect = (0, _player.getRect)(store);
	    var nodeId = (0, _selection.getSelectedNodes)(store)[0];
	    if (!nodeId) return;
	
	    var ndc = { x: 2 * x / rect.width - 1, y: -2 * y / rect.height + 1 };
	    var hits = store.getTranslator().raycastSelect(ndc);
	    var nodeChildren = (0, _scene.filter)(store, { from: { id: nodeId } });
	    var nodeHit = hits.find(function (hit) {
	      var foundIndex = objects.findIndex(function (id) {
	        return id === hit.id && id !== nodeId && nodeChildren.indexOf(id) < 0;
	      });
	      return foundIndex >= 0;
	    });
	
	    if (!nodeHit) return;
	
	    var newPosition = nodeHit.data[0].point;
	
	    setNodePosition(store, nodeId, newPosition);
	  };
	})();
	
	var moveNodeOnPlane = (function () {
	  var newPosition = new _three2.default.Vector3();
	  var newQuaternion = new _three2.default.Quaternion();
	  var moveOnPlane = new _three2.default.Plane();
	  var moveOnNormal = new _three2.default.Vector3();
	
	  return function (store, x, y, plane) {
	    var rect = (0, _player.getRect)(store);
	    var nodeId = (0, _selection.getSelectedNodes)(store)[0];
	    if (!nodeId) return;
	    var oldNdc = getNodeNdc(store, nodeId);
	
	    //const plane = store.getIn(['selection', 'collisionPlane']);
	    var normal = plane.normal;
	
	    moveOnNormal.set(normal.x, normal.y, normal.z);
	    moveOnPlane.set(moveOnNormal, plane.constant);
	
	    var ndc = { x: oldNdc.x + 2 * x / rect.width, y: oldNdc.y - 2 * y / rect.height };
	    var ray = store.getTranslator().getCameraMouseRay(ndc).ray;
	    if (!ray.intersectsPlane(moveOnPlane)) return;
	    ray.intersectPlane(moveOnPlane, newPosition);
	
	    store.dispatch((0, _scene.set)({ id: nodeId }));
	    setNodePosition(store, nodeId, newPosition);
	  };
	})();

/***/ },
/* 327 */
/*!*****************************************!*\
  !*** ./src/translators/tools/gizmos.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getViewScale = getViewScale;
	exports.drawMoveGizmo = drawMoveGizmo;
	exports.drawRotateGizmo = drawRotateGizmo;
	exports.drawScaleGizmo = drawScaleGizmo;
	exports.highlightAxis = highlightAxis;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _selection = __webpack_require__(/*! ../../modules/selection */ 282);
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var axisColors = { x: 0xff0000, y: 0x00ff00, z: 0x0000ff };
	
	var materials = {
	  x: new _three2.default.MeshStandardMaterial({ color: axisColors.x, depthTest: false }),
	  y: new _three2.default.MeshStandardMaterial({ color: axisColors.y, depthTest: false }),
	  z: new _three2.default.MeshStandardMaterial({ color: axisColors.z, depthTest: false })
	};
	
	var lineRadius = 0.02;
	
	function cancelAxis(axis) {
	  materials[axis].color = new _three2.default.Color(axisColors[axis]);
	  materials[axis].needsUpdate = true;
	}
	
	function resetMaterials() {
	  ['x', 'y', 'z'].forEach(cancelAxis);
	}
	
	function getViewScale(store) {
	  var viewRect = (0, _player.getRect)(store);
	  var posObj = new _three2.default.Vector3().copy(viewRect.height < viewRect.width ? { x: 0, y: 0.4, z: 0 } : { x: 0.4, y: 0, z: 0 });
	
	  var node = (0, _selection.getSelectedNodes)(store)[0];
	  if (!node) return 0;
	  var nodePosition = new _three2.default.Vector3().setFromMatrixPosition((0, _scene.getWorldTransform)(store, node));
	
	  var camera = (0, _player.getThreeCamera)(store);
	  var cameraPosition = new _three2.default.Vector3().setFromMatrixPosition(camera.matrix);
	
	  var inverseProjectionMatrix = new _three2.default.Matrix4().getInverse(camera.projectionMatrix, true);
	  var referencePoint = new _three2.default.Vector3().copy(nodePosition).applyMatrix4(camera.matrixWorldInverse).applyProjection(camera.projectionMatrix);
	  referencePoint.add(posObj).applyProjection(inverseProjectionMatrix).applyMatrix4(camera.matrix);
	
	  var scale = referencePoint.sub(nodePosition).length();
	  return scale;
	}
	
	function drawMoveGizmo() {
	  resetMaterials();
	  var coneRadius = 0.08;
	  var cone = new _three2.default.ConeGeometry(coneRadius, 0.25, 25);
	  var yArrow = new _three2.default.CylinderGeometry(lineRadius, lineRadius, 2, 32);
	  var cone2 = cone.clone();
	  cone.translate(0, 1, 0);
	  cone2.rotateX(Math.PI);
	  cone2.translate(0, -1, 0);
	  yArrow.merge(cone);
	  yArrow.merge(cone2);
	
	  var zArrow = yArrow.clone();
	  var xArrow = yArrow.clone();
	
	  var yMesh = new _three2.default.Mesh(yArrow, materials.y);
	  yMesh.axis = "y";
	
	  zArrow.rotateX(Math.PI / 2);
	  var zMesh = new _three2.default.Mesh(zArrow, materials.z);
	  zMesh.axis = "z";
	
	  xArrow.rotateZ(Math.PI / 2);
	  var xMesh = new _three2.default.Mesh(xArrow, materials.x);
	  xMesh.axis = "x";
	
	  var moveGizmo = new _three2.default.Object3D();
	  moveGizmo.add(xMesh);
	  moveGizmo.add(yMesh);
	  moveGizmo.add(zMesh);
	
	  return moveGizmo;
	};
	
	function drawRotateGizmo() {
	  resetMaterials();
	  var xRotation = new _three2.default.TorusGeometry(1, lineRadius, 16, 100);
	  var yRotation = xRotation.clone();
	  var zRotation = xRotation.clone();
	
	  xRotation.rotateY(Math.PI / 2);
	  yRotation.rotateX(Math.PI / 2);
	
	  var rotateGizmo = new _three2.default.Object3D();
	  var xMesh = new _three2.default.Mesh(xRotation, materials.x);
	  xMesh.axis = "x";
	  var yMesh = new _three2.default.Mesh(yRotation, materials.y);
	  yMesh.axis = "y";
	  var zMesh = new _three2.default.Mesh(zRotation, materials.z);
	  zMesh.axis = "z";
	  rotateGizmo.add(xMesh);
	  rotateGizmo.add(yMesh);
	  rotateGizmo.add(zMesh);
	
	  return rotateGizmo;
	};
	
	function drawScaleGizmo() {
	  resetMaterials();
	  var boxWidth = 0.2;
	  var box = new _three2.default.BoxGeometry(boxWidth, boxWidth, boxWidth);
	  var yArrow = new _three2.default.CylinderGeometry(lineRadius, lineRadius, 1, 32);
	  yArrow.translate(0, 0.5, 0);
	  //const box2 = box.clone();
	  box.translate(0, 1, 0);
	  //box2.rotateX(Math.PI);
	  //box2.translate(0, -1, 0);
	  yArrow.merge(box);
	  //yArrow.merge(box2);
	
	  var zArrow = yArrow.clone();
	  var xArrow = yArrow.clone();
	
	  var yMesh = new _three2.default.Mesh(yArrow, materials.y);
	  yMesh.axis = "y";
	
	  zArrow.rotateX(Math.PI / 2);
	  var zMesh = new _three2.default.Mesh(zArrow, materials.z);
	  zMesh.axis = "z";
	
	  xArrow.rotateZ(-Math.PI / 2);
	  var xMesh = new _three2.default.Mesh(xArrow, materials.x);
	  xMesh.axis = "x";
	
	  var scaleGizmo = new _three2.default.Object3D();
	  scaleGizmo.add(xMesh);
	  scaleGizmo.add(yMesh);
	  scaleGizmo.add(zMesh);
	
	  return scaleGizmo;
	};
	
	function highlightAxis(translator, ev, activeAxis) {
	  var axis = null;
	  var x = ev.clientX / (ev.rect.width / 2) - 1;
	  var y = -(ev.clientY / (ev.rect.height / 2) - 1);
	  var hits = translator.raycastSelect({ x: x, y: y }, 'Widgets');
	
	  if (hits && hits[0] && hits[0].node && hits[0].node.axis) {
	    if (activeAxis) cancelAxis(activeAxis);
	    axis = hits[0].node.axis;
	    materials[axis].color = new _three2.default.Color(1, 1, 0);
	    materials[axis].needsUpdate = true;
	    translator.postTranslate('normal', true);
	  } else if (activeAxis) {
	    cancelAxis(activeAxis);
	    translator.postTranslate('normal', true);
	  }
	
	  return axis;
	};

/***/ },
/* 328 */
/*!**********************************************************!*\
  !*** ./src/translators/tools/utils/getProjectedPoint.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getProjectedPoint;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _getProjectionMatrix = __webpack_require__(/*! ../../utils/getProjectionMatrix */ 325);
	
	var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);
	
	var _player = __webpack_require__(/*! ../../../modules/player */ 265);
	
	var _scene = __webpack_require__(/*! ../../../modules/scene */ 147);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var invCameraWorldMatrix = new _three2.default.Matrix4();
	var cameraProjectMatrix = new _three2.default.Matrix4();
	var cameraUnprojectMatrix = new _three2.default.Matrix4();
	
	var nodePosition = new _three2.default.Vector3();
	var referencePoint = new _three2.default.Vector3();
	var relativeDelta = new _three2.default.Vector2();
	var deltaReferencePoint = new _three2.default.Vector3();
	
	function getProjectedPoint(store, nodeId, x, y) {
	  var cameraId = (0, _player.getCamera)(store);
	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	  var projectionMatrix = (0, _getProjectionMatrix2.default)((0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' }));
	  invCameraWorldMatrix.getInverse(cameraWorldMatrix, true);
	  cameraProjectMatrix.copy(projectionMatrix).multiply(invCameraWorldMatrix);
	
	  var nodeMatrix = (0, _scene.getWorldTransform)(store, nodeId);
	  if (!nodeMatrix) return;
	
	  var rect = (0, _player.getRect)(store);
	  var parentMatrix = (0, _scene.getWorldTransform)(store, (0, _scene.find)(store, { id: nodeId, parent: true }));
	  nodePosition.setFromMatrixPosition(nodeMatrix);
	  relativeDelta.set(x, -y).divide(rect).multiplyScalar(2.0);
	
	  referencePoint.copy(nodePosition).applyProjection(cameraProjectMatrix);
	  referencePoint.x = 0;
	  referencePoint.y = 0;
	  deltaReferencePoint.set(relativeDelta.x, relativeDelta.y, referencePoint.z);
	
	  cameraUnprojectMatrix.getInverse(cameraProjectMatrix, true);
	  referencePoint.applyProjection(cameraUnprojectMatrix);
	  deltaReferencePoint.applyProjection(cameraUnprojectMatrix).sub(referencePoint);
	
	  return deltaReferencePoint;
	};

/***/ },
/* 329 */
/*!*********************************************!*\
  !*** ./src/translators/tools/nodeRotate.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = nodeRotate;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	var _selection = __webpack_require__(/*! ../../modules/selection */ 282);
	
	var _gizmos = __webpack_require__(/*! ./gizmos */ 327);
	
	var _getBoundingRadius = __webpack_require__(/*! ./utils/getBoundingRadius */ 330);
	
	var _getBoundingRadius2 = _interopRequireDefault(_getBoundingRadius);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _Math = Math;
	var min = _Math.min;
	var PI = _Math.PI;
	var sqrt = _Math.sqrt;
	
	var parentInvMatrix = new _three2.default.Matrix4();
	var nodeRotationQuaternion = new _three2.default.Quaternion();
	var nodePosition = new _three2.default.Vector3();
	var nodeScale = new _three2.default.Vector3();
	var nodeRotationEuler = new _three2.default.Euler();
	var cameraPosition = new _three2.default.Vector3();
	
	function nodeRotate(store, translator) {
	  var activeAxis = false;
	
	  return {
	    label: 'Rotate Node',
	    enabled: true,
	    display: {
	      playerTools: false
	    },
	    options: {},
	
	    tool: {
	      hover: function hover(ev) {
	        if (!this.active) return;
	        activeAxis = (0, _gizmos.highlightAxis)(translator, ev, activeAxis);
	      },
	
	      drag: function drag(ev) {
	        if (ev.which !== 1 || !this.active || ev.metaKey) return false;
	
	        return {
	          momentum: !activeAxis,
	          handle: function handle(ev) {
	            rotateNode(store, ev.deltaX, ev.deltaY, activeAxis);
	          }
	        };
	      }
	    },
	
	    widget: {
	      draw: function draw(manipulatorsObject) {
	        manipulatorsObject.add((0, _gizmos.drawRotateGizmo)());
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      },
	
	      position: function position(manipulatorsObject) {
	        var selectedNodes = (0, _selection.getSelectedNodes)(store);
	        if (!selectedNodes.length) {
	          manipulatorsObject.visible = false;
	          return;
	        }
	        manipulatorsObject.visible = true;
	        var manipId = selectedNodes[0];
	        var worldTransform = (0, _scene.getWorldTransform)(store, manipId);
	        var position = new _three2.default.Vector3();
	        position.setFromMatrixPosition(worldTransform);
	        manipulatorsObject.position.set(position.x, position.y, position.z);
	
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      }
	    }
	  };
	}
	
	function rotateNode(store, x, y, restrictToAxis) {
	  var rect = (0, _player.getRect)(store);
	  var selectedNodes = (0, _selection.getSelectedNodes)(store);
	  if (!selectedNodes.length) return;
	  var manipId = selectedNodes[0];
	  var nodeTransform = (0, _scene.getWorldTransform)(store, manipId);
	  if (!nodeTransform) return;
	
	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	  nodeTransform.decompose(nodePosition, nodeRotationQuaternion, nodeScale);
	  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	
	  var radius = (0, _getBoundingRadius2.default)(store, manipId);
	
	  var relativeDelta = new _three2.default.Vector3().set(2 * x / rect.x / radius, -2 * y / rect.y / radius, 0);
	
	  if (relativeDelta.length() > 1) relativeDelta.normalize();else if (relativeDelta.length() === 0) return;
	
	  var delta = relativeDelta.length();
	  relativeDelta.transformDirection(cameraWorldMatrix).multiplyScalar(delta);
	
	  var objNormal = new _three2.default.Vector3().subVectors(cameraPosition, nodePosition).normalize();
	
	  if (restrictToAxis) {
	    var projVector = new _three2.default.Vector3(0, 0, 0);
	    projVector[restrictToAxis] = 1;
	    relativeDelta.projectOnPlane(projVector);
	    objNormal.projectOnPlane(projVector);
	  }
	
	  var scaleFactor = sqrt(1 - relativeDelta.lengthSq());
	  relativeDelta.addScaledVector(objNormal, scaleFactor).normalize();
	  var modifyQuaternion = new _three2.default.Quaternion().setFromUnitVectors(objNormal, relativeDelta);
	  nodeRotationQuaternion.premultiply(modifyQuaternion);
	
	  nodeTransform.compose(nodePosition, nodeRotationQuaternion, nodeScale);
	  var parentMatrix = (0, _scene.getWorldTransform)(store, (0, _scene.find)(store, { id: manipId, parent: true }));
	  if (parentMatrix) {
	    parentInvMatrix.getInverse(parentMatrix, true);
	    nodeTransform.premultiply(parentInvMatrix);
	  }
	  nodeTransform.decompose(nodePosition, nodeRotationQuaternion, nodeScale);
	
	  // FIXME: resrictToAxis
	  // console.log('restrictToAxis: ', restrictToAxis);
	
	  nodeRotationEuler.setFromQuaternion(nodeRotationQuaternion, 'ZYX');
	  store.dispatch((0, _scene.set)({ id: manipId, plug: 'Transform', property: 'rotation' }, nodeRotationEuler.toVector3().multiplyScalar(180 / PI)));
	}

/***/ },
/* 330 */
/*!**********************************************************!*\
  !*** ./src/translators/tools/utils/getBoundingRadius.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getBoundingRadius;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _scene = __webpack_require__(/*! ../../../modules/scene */ 147);
	
	var _player = __webpack_require__(/*! ../../../modules/player */ 265);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var cameraPosition = new _three2.default.Vector3();
	var nodePosition = new _three2.default.Vector3();
	var boundingVector = new _three2.default.Vector3();
	var boundingSphere = new _three2.default.Sphere();
	
	function getBoundingRadius(store, nodeId) {
	  var camera = (0, _player.getThreeCamera)(store);
	  var nodeTransform = (0, _scene.getWorldTransform)(store, nodeId);
	  cameraPosition.setFromMatrixPosition(camera.matrix);
	
	  var boundingRadius = store.getTranslator().getNodeBoundingBox(nodeId).getBoundingSphere(boundingSphere).radius;
	  boundingVector.subVectors(cameraPosition, nodePosition);
	  boundingVector.z = -boundingVector.length();
	  boundingVector.y = boundingRadius;
	  boundingVector.x = 0;
	
	  boundingVector.applyProjection(camera.projectionMatrix);
	  boundingVector.z = 0;
	  return boundingVector.length();
	}

/***/ },
/* 331 */
/*!********************************************!*\
  !*** ./src/translators/tools/nodeScale.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = nodeScale;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	var _selection = __webpack_require__(/*! ../../modules/selection */ 282);
	
	var _gizmos = __webpack_require__(/*! ./gizmos */ 327);
	
	var _getProjectedPoint = __webpack_require__(/*! ./utils/getProjectedPoint */ 328);
	
	var _getProjectedPoint2 = _interopRequireDefault(_getProjectedPoint);
	
	var _getBoundingRadius = __webpack_require__(/*! ./utils/getBoundingRadius */ 330);
	
	var _getBoundingRadius2 = _interopRequireDefault(_getBoundingRadius);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _Math = Math;
	var max = _Math.max;
	var pow = _Math.pow;
	var PI = _Math.PI;
	var sin = _Math.sin;
	var min = _Math.min;
	var sqrt = _Math.sqrt;
	
	var EPS = 0.000001;
	
	function nodeScale(store, translator) {
	  var activeAxis = false;
	
	  return {
	    label: 'Scale Node',
	    enabled: true,
	    display: {
	      playerTools: false
	    },
	    options: {},
	
	    tool: {
	      hover: function hover(ev) {
	        if (!this.active) return;
	
	        activeAxis = (0, _gizmos.highlightAxis)(translator, ev, activeAxis);
	      },
	
	      drag: function drag(ev) {
	        if (ev.which !== 1 || !this.active || ev.metaKey) return false;
	
	        return {
	          momentum: !activeAxis,
	          handle: function handle(ev) {
	            scaleNode(store, ev, activeAxis);
	          }
	        };
	      }
	    },
	
	    widget: {
	      draw: function draw(manipulatorsObject) {
	        manipulatorsObject.add((0, _gizmos.drawScaleGizmo)());
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      },
	
	      position: function position(manipulatorsObject) {
	        var selectedNodes = (0, _selection.getSelectedNodes)(store);
	        if (!selectedNodes.length) {
	          manipulatorsObject.visible = false;
	          return;
	        }
	        manipulatorsObject.visible = true;
	        var manipId = selectedNodes[0];
	        var worldTransform = (0, _scene.getWorldTransform)(store, manipId);
	        var position = new _three2.default.Vector3();
	        position.setFromMatrixPosition(worldTransform);
	        manipulatorsObject.position.set(position.x, position.y, position.z);
	
	        var scale = (0, _gizmos.getViewScale)(store);
	        manipulatorsObject.scale.set(scale, scale, scale);
	      }
	    }
	  };
	}
	
	function scaleNode(store, ev, restrictToAxis) {
	  var rect = (0, _player.getRect)(store);
	  var selectedNodes = (0, _selection.getSelectedNodes)(store);
	  if (!selectedNodes.length) return;
	  var id = selectedNodes[0];
	
	  var nodeGraphScale = (0, _scene.get)(store, { id: id, plug: 'Transform', property: 'scale' });
	  if (!nodeGraphScale) return;
	  var radius = max((0, _getBoundingRadius2.default)(store, id), EPS) || EPS;
	
	  var delta = ev.delta || ev.deltaX / 30 - ev.deltaY / 30;
	  var deltaZoom = max(min(2 * delta / rect.y / radius, 0.001), -0.001);
	  var decayZoomFactor = pow(2, deltaZoom * 100);
	
	  var nodeMatrix = (0, _scene.getWorldTransform)(store, id);
	  var nodePosition = new _three2.default.Vector3().setFromMatrixPosition(nodeMatrix);
	  var nodeScale = new _three2.default.Vector3().copy(nodeGraphScale);
	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	
	  if (!restrictToAxis) {
	    var oldScale = max(nodeScale.length(), EPS);
	    nodeScale.setLength(oldScale * decayZoomFactor);
	  } else {
	    var projVector = new _three2.default.Vector3(0, 0, 0);
	    projVector[restrictToAxis] = 1;
	    var projectedMouse = (0, _getProjectedPoint2.default)(store, id, ev.deltaX, ev.deltaY);
	    projectedMouse.projectOnVector(projVector);
	
	    var targToCam = new _three2.default.Vector3().setFromMatrixPosition(cameraWorldMatrix).sub(nodePosition);
	    var origin = new _three2.default.Vector3(0, 0, 0);
	    var plane = new _three2.default.Plane().setFromCoplanarPoints(targToCam, projVector, origin);
	    projectedMouse.projectOnPlane(plane.normal);
	
	    var camToMove = new _three2.default.Vector3().subVectors(projectedMouse, targToCam);
	    projectedMouse.projectOnVector(projVector).normalize();
	    var alpha = targToCam.angleTo(projectedMouse);
	    var beta = PI - targToCam.angleTo(camToMove);
	    var gamma = PI - alpha - beta;
	    var axis = targToCam.length() * sin(beta) / sin(gamma);
	    projectedMouse.multiplyScalar(axis);
	
	    projVector.set(1, 1, 1);
	
	    projVector[restrictToAxis] = 1 + 2 * projectedMouse[restrictToAxis] / nodeScale[restrictToAxis];
	    nodeScale.multiply(projVector);
	  }
	
	  // FIXME: restrict axis
	  //console.log('scaleToAxis', restrictToAxis);
	  store.dispatch((0, _scene.set)({ id: id, plug: 'Transform', property: 'scale' }, nodeScale));
	}

/***/ },
/* 332 */
/*!*****************************************!*\
  !*** ./src/translators/tools/select.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = select;
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _selection = __webpack_require__(/*! ../../modules/selection */ 282);
	
	function select(store, translator) {
	  return {
	    label: 'Select',
	    enabled: true,
	    display: {
	      playerTools: false
	    },
	    options: {},
	
	    tool: {
	      click: function click(ev) {
	        var nodes = (0, _player.filterNodesFromPosition)(store, ev);
	        if (nodes.length) store.dispatch((0, _selection.selectNode)(nodes[0]));
	      },
	
	      drag: function drag(ev) {
	        if (ev.which !== 1 || !this.active) return false;
	
	        return {
	          momentum: false,
	
	          handle: function handle(ev) {
	            //console.log('drag select', ev.deltaX, ev.deltaY);
	          }
	        };
	      }
	    }
	  };
	};

/***/ },
/* 333 */
/*!*********************************************!*\
  !*** ./src/translators/tools/fullscreen.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = fullscreen;
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	function fullscreen(store, translator) {
	  return {
	    enabled: true,
	    display: true,
	    options: {},
	
	    isActive: _player.isFullscreen,
	
	    activate: function activate() {
	      var playerEl = store.getIn(['player', 'playerElement']);
	      ['requestFullscreen', 'webkitRequestFullscreen', 'mozRequestFullScreen', 'msRequestFullscreen'].forEach(function (fn) {
	        if (playerEl[fn]) return playerEl[fn]();
	      });
	      store.dispatch((0, _player.setFullscreen)(true));
	    },
	
	    deactivate: function deactivate() {
	      ['exitFullscreen', 'webkitExitFullscreen', 'mozCancelFullScreen', 'msExitFullscreen'].forEach(function (fn) {
	        if (document[fn]) return document[fn]();
	      });
	      store.dispatch((0, _player.setFullscreen)(false));
	    }
	  };
	}

/***/ },
/* 334 */
/*!***************************************!*\
  !*** ./src/translators/tools/home.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = home;
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	var _camera = __webpack_require__(/*! ../camera */ 268);
	
	function home(store, translator) {
	  return {
	    label: 'Home',
	    enabled: true,
	    display: {
	      playerTools: true
	    },
	    options: {},
	
	    execute: function execute() {
	      var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	      (0, _camera.initCamera)(store, true, playerData && playerData.camera);
	    }
	  };
	}

/***/ },
/* 335 */
/*!*****************************************!*\
  !*** ./src/translators/tools/vrMode.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (store, translator) {
	  var vrEffect = undefined,
	      vrDisplay = undefined,
	      vrReticle = undefined,
	      vrFloor = undefined,
	      vrControls = undefined,
	      hasExternalDisplay = undefined,
	      controller1 = undefined,
	      controller2 = undefined,
	      viveHandler = undefined,
	      mobileNavHandler = undefined,
	      threeVrCamera = undefined,
	      prevMoveMode = undefined;
	
	  var scene = translator.scene;
	  var camera = translator.camera;
	
	  var vrCapable = false;
	  if (true) {
	    window.navigator.getVRDisplays().then(function (displays) {
	      if (!displays.length) return;
	      vrCapable = displays[0].capabilities.canPresent;
	      store.dispatch((0, _commands.updateCommand)('vrMode', { enabled: vrCapable }));
	    });
	  }
	
	  function viveNavHandle(manipulatorsObject) {
	    return function (ev) {
	      console.log('viveNavHandle', !!vrReticle.armObject);
	      if (!vrReticle.armObject) return;
	
	      var pos = vrReticle.getReticlePosition().clone();
	      pos.y = 0;
	      var vrdpPos = threeVrCamera.position.clone();
	      var offset = pos.addScaledVector(vrControls.offset, 2).sub(vrdpPos);
	      offset.y = 0;
	      vrControls.setOffset(offset);
	    };
	  }
	
	  function navHandle(manipulatorsObject) {
	    return function (ev) {
	      if (!vrReticle.armObject) return;
	
	      var cameraId = (0, _player.getCamera)(store);
	      var pos = vrReticle.getReticlePosition().clone();
	      pos.y = 0;
	      manipulatorsObject.position.add(pos);
	      manipulatorsObject.updateMatrix();
	
	      var newCameraPosition = new _three2.default.Matrix4().setPosition(manipulatorsObject.position);
	      newCameraPosition.elements[13] = 1.6;
	      store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(newCameraPosition)));
	    };
	  }
	
	  return {
	    label: 'VR mode',
	    activeLabel: 'Exit VR Mode',
	
	    enabled: vrCapable,
	    display: {
	      playerTools: true
	    },
	    options: {
	      planeEnabled: true
	    },
	
	    isActive: _player.isVRMode,
	
	    widget: {
	      draw: function draw(manipulatorsObject) {
	        var cbgeometry = new _three2.default.PlaneGeometry(20, 20, 1, 1);
	        var mat = new _three2.default.MeshBasicMaterial({ color: 0x666666 });
	        mat.transparent = !this.options.planeEnabled;
	        mat.opacity = this.options.planeEnabled ? 1.0 : 0.0;
	        vrFloor = new _three2.default.Mesh(cbgeometry, mat);
	        vrFloor.rotation.x = -Math.PI * 0.5;
	
	        vrReticle = new _three2.default.Reticle(camera);
	        vrReticle.addCollider(vrFloor);
	
	        manipulatorsObject.add(vrReticle.armObject);
	        manipulatorsObject.add(vrReticle.dot);
	        manipulatorsObject.add(vrFloor);
	
	        // This floor grid is __UGLY__!
	        // manipulatorsObject.add(floorGrid());
	
	        if (!hasExternalDisplay) {
	          //scene.add(camera);
	          mobileNavHandler = navHandle(manipulatorsObject);
	          window.addEventListener('touchend', mobileNavHandler);
	        } else {
	          //------Add vive controllers-----------
	          controller1 = new _three2.default.ViveController(0);
	          controller1.standingMatrix = vrControls.getStandingMatrix();
	
	          manipulatorsObject.add(controller1);
	
	          controller2 = new _three2.default.ViveController(1);
	          controller2.standingMatrix = vrControls.getStandingMatrix();
	
	          manipulatorsObject.add(controller2);
	
	          var loader = new _three2.default.OBJLoader();
	          loader.setPath('models/');
	          loader.load('vr_controller_vive_1_5.obj', function (object) {
	            var loader = new _three2.default.TextureLoader();
	            loader.setPath('models/');
	
	            var controller = object.children[0];
	            var material = new _three2.default.MeshBasicMaterial();
	            material.map = loader.load('onepointfive_texture.png');
	            material.specularMap = loader.load('onepointfive_spec.png');
	            controller.material = material;
	
	            controller1.add(object.clone());
	            controller2.add(object.clone());
	          });
	          viveHandler = viveNavHandle(manipulatorsObject);
	          window.addEventListener("thumbpadup", viveHandler);
	        }
	      },
	
	      remove: function remove(manipulatorsObject) {
	        if (!hasExternalDisplay) {
	          scene.remove(camera);
	          window.removeEventListener("touchend", mobileNavHandler);
	        } else {
	          window.removeEventListener("thumbpadup", viveHandler);
	        }
	      },
	
	      position: function position(manipulatorsObject) {
	        vrControls.update();
	        manipulatorsObject.position.copy(vrControls.offset);
	
	        threeVrCamera.updateMatrix();
	        matchToCamera(store, threeVrCamera);
	
	        vrReticle.update(manipulatorsObject);
	        if (hasExternalDisplay) {
	          controller1.update();
	          controller2.update();
	        }
	
	        manipulatorsObject.updateMatrix();
	      }
	    },
	
	    activate: function activate() {
	      var translator = store.getTranslator();
	
	      return window.navigator.getVRDisplays().then(function (displays) {
	        if (displays.length <= 0) throw new Error('No VR Displays');
	
	        if (displays.length > 0) {
	          vrDisplay = displays[0];
	          vrEffect = new _three2.default.VREffect(translator.renderer, vrDisplay);
	          translator.externals.vrEffect = vrEffect;
	
	          hasExternalDisplay = vrDisplay.capabilities.hasExternalDisplay;
	          if (!vrDisplay.capabilities.canPresent) return;
	
	          store.dispatch((0, _player.useVrCamera)(true));
	          // If we have external display, then use vive controls?
	          return vrEffect.requestPresent().then(function () {
	            store.dispatch((0, _commands.activateCommand)('firstPersonMode'));
	            prevMoveMode = (0, _commands.getCommands)(store).firstPersonMode.options.movementMode;
	            store.dispatch((0, _commands.setCommandOptions)('firstPersonMode', { movementMode: 'plane' }));
	
	            threeVrCamera = translator.camera.clone();
	            vrControls = new _three2.default.VRControls(threeVrCamera);
	            translator.externals.vrControls = vrControls;
	            if (hasExternalDisplay) vrControls.standing = true;
	            vrControls.resetPose(); // zero orientation controls
	
	            store.dispatch((0, _player.setRenderMode)(_player.RENDER_MODES.vr));
	            store.dispatch((0, _commands.updateCommands)(_commands.MOUSE_CONTROLS, { enabled: false }));
	
	            store.setRequestAnimationFrame(vrDisplay.requestAnimationFrame, vrDisplay);
	
	            return vrDisplay;
	          }).catch(function (err) {
	            console.log('Error Activating VR');
	            throw err;
	          });
	        }
	      });
	    },
	
	    deactivate: function deactivate() {
	      var translator = store.getTranslator();
	
	      vrEffect.exitPresent();
	      store.setRequestAnimationFrame();
	
	      store.dispatch((0, _commands.deactivateCommand)('firstPersonMode'));
	      store.dispatch((0, _commands.setCommandOptions)('firstPersonMode', { movementMode: prevMoveMode }));
	
	      store.dispatch((0, _player.setRenderMode)(_player.RENDER_MODES.normal));
	      store.dispatch((0, _commands.updateCommands)(_commands.MOUSE_CONTROLS, { enabled: true }));
	      store.dispatch((0, _player.useVrCamera)(false));
	
	      vrDisplay = null;
	
	      /*const prevCameraId = getPrevCamera(store);
	      if (prevCameraId) store.dispatch(useCamera(prevCameraId));*/
	
	      if (!hasExternalDisplay) {
	        //scene.remove(camera);
	        window.removeEventListener("touchend", navHandle);
	      } else {
	        controller1 = null;
	        controller2 = null;
	        //scene.position.set(0, 0, 0);
	        //vrElements.position.set(0, 0, 0);
	        window.removeEventListener("thumbpadup", viveHandler);
	      }
	      vrControls.standing = false;
	      vrReticle.removeCollider(vrFloor);
	      translator.renderer.setScissorTest(false);
	      //vrElements.children = [];
	      //scene.remove(vrElements);
	    }
	  };
	};
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	__webpack_require__(/*! webvr-polyfill */ 336);
	
	__webpack_require__(/*! ../utils/vrEffect */ 337);
	
	__webpack_require__(/*! ../utils/viveController */ 338);
	
	__webpack_require__(/*! ../utils/objLoader */ 339);
	
	__webpack_require__(/*! ../utils/reticle */ 340);
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _commands = __webpack_require__(/*! ../../modules/commands */ 275);
	
	var _decompose = __webpack_require__(/*! ../utils/decompose */ 272);
	
	var _decompose2 = _interopRequireDefault(_decompose);
	
	__webpack_require__(/*! ../utils/vrControls */ 341);
	
	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 269);
	
	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);
	
	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 142);
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// extend three with VRControls
	
	function floorGrid() {
	  // Materials
	  var mat = new _three2.default.LineBasicMaterial({ color: 0xffffff, linewidth: 10 });
	
	  var lineGeometry = new _three2.default.BufferGeometry();
	  var positions = new Float32Array(80 * 2 * 3);
	
	  for (var x = -10, i = 0; x < 10; x += 0.5, i++) {
	    positions[i * 6 + 0] = x;
	    positions[i * 6 + 1] = 0;
	    positions[i * 6 + 2] = -10;
	    positions[i * 6 + 3 + 0] = x;
	    positions[i * 6 + 3 + 1] = 0;
	    positions[i * 6 + 3 + 2] = 10;
	  }
	  for (var z = -10, i = 40; z < 10; z += 0.5, i++) {
	    positions[i * 6 + 0] = -10;
	    positions[i * 6 + 1] = 0;
	    positions[i * 6 + 2] = z;
	    positions[i * 6 + 3 + 0] = 10;
	    positions[i * 6 + 3 + 1] = 0;
	    positions[i * 6 + 3 + 2] = z;
	  }
	
	  lineGeometry.addAttribute('position', new _three2.default.BufferAttribute(positions, 3));
	
	  var mesh = new _three2.default.LineSegments(lineGeometry, mat);
	  mesh.mode = _three2.default.LineSegments;
	
	  return mesh;
	} // Extend three with VREffect
	
	function matchToCamera(store, threeCamera) {
	  var cameraId = (0, _player.getCamera)(store);
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store);
	  var targetPosition = new _three2.default.Vector3().setFromMatrixPosition(targetWorldMatrix);
	
	  var length = targetPosition.sub(threeCamera.position).length();
	  targetPosition.set(0, 0, -length).applyQuaternion(threeCamera.quaternion).add(threeCamera.position);
	  var upPosition = new _three2.default.Vector3(0, 1, 0).applyQuaternion(threeCamera.quaternion);
	
	  targetWorldMatrix.setPosition(targetPosition);
	  var camData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	  camData.upPosition = upPosition;
	  store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(threeCamera.matrix.clone())));
	  if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
	    store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
	  }
	}

/***/ },
/* 336 */
/*!**************************************************!*\
  !*** ./~/webvr-polyfill/build/webvr-polyfill.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};
	
	},{}],2:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var Util = _dereq_('./util.js');
	var WakeLock = _dereq_('./wakelock.js');
	
	// Start at a higher number to reduce chance of conflict.
	var nextDisplayId = 1000;
	var hasShowDeprecationWarning = false;
	
	var defaultLeftBounds = [0, 0, 0.5, 1];
	var defaultRightBounds = [0.5, 0, 0.5, 1];
	
	/**
	 * The base class for all VR frame data.
	 */
	
	function VRFrameData() {
	  this.leftProjectionMatrix = new Float32Array(16);
	  this.leftViewMatrix = new Float32Array(16);
	  this.rightProjectionMatrix = new Float32Array(16);
	  this.rightViewMatrix = new Float32Array(16);
	  this.pose = null;
	};
	
	/**
	 * The base class for all VR displays.
	 */
	function VRDisplay() {
	  this.isPolyfilled = true;
	  this.displayId = nextDisplayId++;
	  this.displayName = 'webvr-polyfill displayName';
	
	  this.depthNear = 0.01;
	  this.depthFar = 10000.0;
	
	  this.isConnected = true;
	  this.isPresenting = false;
	  this.capabilities = {
	    hasPosition: false,
	    hasOrientation: false,
	    hasExternalDisplay: false,
	    canPresent: false,
	    maxLayers: 1
	  };
	  this.stageParameters = null;
	
	  // "Private" members.
	  this.waitingForPresent_ = false;
	  this.layer_ = null;
	
	  this.fullscreenElement_ = null;
	  this.fullscreenWrapper_ = null;
	  this.fullscreenElementCachedStyle_ = null;
	
	  this.fullscreenEventTarget_ = null;
	  this.fullscreenChangeHandler_ = null;
	  this.fullscreenErrorHandler_ = null;
	
	  this.wakelock_ = new WakeLock();
	}
	
	VRDisplay.prototype.getFrameData = function(frameData) {
	  // TODO: Technically this should retain it's value for the duration of a frame
	  // but I doubt that's practical to do in javascript.
	  return Util.frameDataFromPose(frameData, this.getPose(), this);
	};
	
	VRDisplay.prototype.getPose = function() {
	  // TODO: Technically this should retain it's value for the duration of a frame
	  // but I doubt that's practical to do in javascript.
	  return this.getImmediatePose();
	};
	
	VRDisplay.prototype.requestAnimationFrame = function(callback) {
	  return window.requestAnimationFrame(callback);
	};
	
	VRDisplay.prototype.cancelAnimationFrame = function(id) {
	  return window.cancelAnimationFrame(id);
	};
	
	VRDisplay.prototype.wrapForFullscreen = function(element) {
	  // Don't wrap in iOS.
	  if (Util.isIOS()) {
	    return element;
	  }
	  if (!this.fullscreenWrapper_) {
	    this.fullscreenWrapper_ = document.createElement('div');
	    var cssProperties = [
	      'height: ' + Math.min(screen.height, screen.width) + 'px !important',
	      'top: 0 !important',
	      'left: 0 !important',
	      'right: 0 !important',
	      'border: 0',
	      'margin: 0',
	      'padding: 0',
	      'z-index: 999999 !important',
	      'position: fixed',
	    ];
	    this.fullscreenWrapper_.setAttribute('style', cssProperties.join('; ') + ';');
	    this.fullscreenWrapper_.classList.add('webvr-polyfill-fullscreen-wrapper');
	  }
	
	  if (this.fullscreenElement_ == element) {
	    return this.fullscreenWrapper_;
	  }
	
	  // Remove any previously applied wrappers
	  this.removeFullscreenWrapper();
	
	  this.fullscreenElement_ = element;
	  var parent = this.fullscreenElement_.parentElement;
	  parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
	  parent.removeChild(this.fullscreenElement_);
	  this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
	  this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute('style');
	
	  var self = this;
	  function applyFullscreenElementStyle() {
	    if (!self.fullscreenElement_) {
	      return;
	    }
	
	    var cssProperties = [
	      'position: absolute',
	      'top: 0',
	      'left: 0',
	      'width: ' + Math.max(screen.width, screen.height) + 'px',
	      'height: ' + Math.min(screen.height, screen.width) + 'px',
	      'border: 0',
	      'margin: 0',
	      'padding: 0',
	    ];
	    self.fullscreenElement_.setAttribute('style', cssProperties.join('; ') + ';');
	  }
	
	  applyFullscreenElementStyle();
	
	  return this.fullscreenWrapper_;
	};
	
	VRDisplay.prototype.removeFullscreenWrapper = function() {
	  if (!this.fullscreenElement_) {
	    return;
	  }
	
	  var element = this.fullscreenElement_;
	  if (this.fullscreenElementCachedStyle_) {
	    element.setAttribute('style', this.fullscreenElementCachedStyle_);
	  } else {
	    element.removeAttribute('style');
	  }
	  this.fullscreenElement_ = null;
	  this.fullscreenElementCachedStyle_ = null;
	
	  var parent = this.fullscreenWrapper_.parentElement;
	  this.fullscreenWrapper_.removeChild(element);
	  parent.insertBefore(element, this.fullscreenWrapper_);
	  parent.removeChild(this.fullscreenWrapper_);
	
	  return element;
	};
	
	VRDisplay.prototype.requestPresent = function(layers) {
	  var wasPresenting = this.isPresenting;
	  var self = this;
	
	  if (!(layers instanceof Array)) {
	    if (!hasShowDeprecationWarning) {
	      console.warn("Using a deprecated form of requestPresent. Should pass in an array of VRLayers.");
	      hasShowDeprecationWarning = true;
	    }
	    layers = [layers];
	  }
	
	  return new Promise(function(resolve, reject) {
	    if (!self.capabilities.canPresent) {
	      reject(new Error('VRDisplay is not capable of presenting.'));
	      return;
	    }
	
	    if (layers.length == 0 || layers.length > self.capabilities.maxLayers) {
	      reject(new Error('Invalid number of layers.'));
	      return;
	    }
	
	    var incomingLayer = layers[0];
	    if (!incomingLayer.source) {
	      /*
	      todo: figure out the correct behavior if the source is not provided.
	      see https://github.com/w3c/webvr/issues/58
	      */
	      resolve();
	      return;
	    }
	
	    var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
	    var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
	    if (wasPresenting) {
	      // Already presenting, just changing configuration
	      var layer = self.layer_;
	      if (layer.source !== incomingLayer.source) {
	        layer.source = incomingLayer.source;
	      }
	
	      for (var i = 0; i < 4; i++) {
	        if (layer.leftBounds[i] !== leftBounds[i]) {
	          layer.leftBounds[i] = leftBounds[i];
	        }
	        if (layer.rightBounds[i] !== rightBounds[i]) {
	          layer.rightBounds[i] = rightBounds[i];
	        }
	      }
	
	      resolve();
	      return;
	    }
	
	    // Was not already presenting.
	    self.layer_ = {
	      predistorted: incomingLayer.predistorted,
	      source: incomingLayer.source,
	      leftBounds: leftBounds.slice(0),
	      rightBounds: rightBounds.slice(0)
	    };
	
	    self.waitingForPresent_ = false;
	    if (self.layer_ && self.layer_.source) {
	      var fullscreenElement = self.wrapForFullscreen(self.layer_.source);
	
	      function onFullscreenChange() {
	        var actualFullscreenElement = Util.getFullscreenElement();
	
	        self.isPresenting = (fullscreenElement === actualFullscreenElement);
	        if (self.isPresenting) {
	          if (screen.orientation && screen.orientation.lock) {
	            screen.orientation.lock('landscape-primary').catch(function(error){
	                    console.error('screen.orientation.lock() failed due to', error.message)
	            });
	          }
	          self.waitingForPresent_ = false;
	          self.beginPresent_();
	          resolve();
	        } else {
	          if (screen.orientation && screen.orientation.unlock) {
	            screen.orientation.unlock();
	          }
	          self.removeFullscreenWrapper();
	          self.wakelock_.release();
	          self.endPresent_();
	          self.removeFullscreenListeners_();
	        }
	        self.fireVRDisplayPresentChange_();
	      }
	      function onFullscreenError() {
	        if (!self.waitingForPresent_) {
	          return;
	        }
	
	        self.removeFullscreenWrapper();
	        self.removeFullscreenListeners_();
	
	        self.wakelock_.release();
	        self.waitingForPresent_ = false;
	        self.isPresenting = false;
	
	        reject(new Error('Unable to present.'));
	      }
	
	      self.addFullscreenListeners_(fullscreenElement,
	          onFullscreenChange, onFullscreenError);
	
	      if (Util.requestFullscreen(fullscreenElement)) {
	        self.wakelock_.request();
	        self.waitingForPresent_ = true;
	      } else if (Util.isIOS()) {
	        // *sigh* Just fake it.
	        self.wakelock_.request();
	        self.isPresenting = true;
	        self.beginPresent_();
	        self.fireVRDisplayPresentChange_();
	        resolve();
	      }
	    }
	
	    if (!self.waitingForPresent_ && !Util.isIOS()) {
	      Util.exitFullscreen();
	      reject(new Error('Unable to present.'));
	    }
	  });
	};
	
	VRDisplay.prototype.exitPresent = function() {
	  var wasPresenting = this.isPresenting;
	  var self = this;
	  this.isPresenting = false;
	  this.layer_ = null;
	  this.wakelock_.release();
	
	  return new Promise(function(resolve, reject) {
	    if (wasPresenting) {
	      if (!Util.exitFullscreen() && Util.isIOS()) {
	        self.endPresent_();
	        self.fireVRDisplayPresentChange_();
	      }
	
	      resolve();
	    } else {
	      reject(new Error('Was not presenting to VRDisplay.'));
	    }
	  });
	};
	
	VRDisplay.prototype.getLayers = function() {
	  if (this.layer_) {
	    return [this.layer_];
	  }
	  return [];
	};
	
	VRDisplay.prototype.fireVRDisplayPresentChange_ = function() {
	  var event = new CustomEvent('vrdisplaypresentchange', {detail: {display: this}});
	  window.dispatchEvent(event);
	};
	
	VRDisplay.prototype.addFullscreenListeners_ = function(element, changeHandler, errorHandler) {
	  this.removeFullscreenListeners_();
	
	  this.fullscreenEventTarget_ = element;
	  this.fullscreenChangeHandler_ = changeHandler;
	  this.fullscreenErrorHandler_ = errorHandler;
	
	  if (changeHandler) {
	    if (document.fullscreenEnabled) {
	      element.addEventListener('fullscreenchange', changeHandler, false);
	    } else if (document.webkitFullscreenEnabled) {
	      element.addEventListener('webkitfullscreenchange', changeHandler, false);
	    } else if (document.mozFullScreenEnabled) {
	      document.addEventListener('mozfullscreenchange', changeHandler, false);
	    } else if (document.msFullscreenEnabled) {
	      element.addEventListener('msfullscreenchange', changeHandler, false);
	    }
	  }
	
	  if (errorHandler) {
	    if (document.fullscreenEnabled) {
	      element.addEventListener('fullscreenerror', errorHandler, false);
	    } else if (document.webkitFullscreenEnabled) {
	      element.addEventListener('webkitfullscreenerror', errorHandler, false);
	    } else if (document.mozFullScreenEnabled) {
	      document.addEventListener('mozfullscreenerror', errorHandler, false);
	    } else if (document.msFullscreenEnabled) {
	      element.addEventListener('msfullscreenerror', errorHandler, false);
	    }
	  }
	};
	
	VRDisplay.prototype.removeFullscreenListeners_ = function() {
	  if (!this.fullscreenEventTarget_)
	    return;
	
	  var element = this.fullscreenEventTarget_;
	
	  if (this.fullscreenChangeHandler_) {
	    var changeHandler = this.fullscreenChangeHandler_;
	    element.removeEventListener('fullscreenchange', changeHandler, false);
	    element.removeEventListener('webkitfullscreenchange', changeHandler, false);
	    document.removeEventListener('mozfullscreenchange', changeHandler, false);
	    element.removeEventListener('msfullscreenchange', changeHandler, false);
	  }
	
	  if (this.fullscreenErrorHandler_) {
	    var errorHandler = this.fullscreenErrorHandler_;
	    element.removeEventListener('fullscreenerror', errorHandler, false);
	    element.removeEventListener('webkitfullscreenerror', errorHandler, false);
	    document.removeEventListener('mozfullscreenerror', errorHandler, false);
	    element.removeEventListener('msfullscreenerror', errorHandler, false);
	  }
	
	  this.fullscreenEventTarget_ = null;
	  this.fullscreenChangeHandler_ = null;
	  this.fullscreenErrorHandler_ = null;
	};
	
	VRDisplay.prototype.beginPresent_ = function() {
	  // Override to add custom behavior when presentation begins.
	};
	
	VRDisplay.prototype.endPresent_ = function() {
	  // Override to add custom behavior when presentation ends.
	};
	
	VRDisplay.prototype.submitFrame = function(pose) {
	  // Override to add custom behavior for frame submission.
	};
	
	VRDisplay.prototype.getEyeParameters = function(whichEye) {
	  // Override to return accurate eye parameters if canPresent is true.
	  return null;
	};
	
	/*
	 * Deprecated classes
	 */
	
	/**
	 * The base class for all VR devices. (Deprecated)
	 */
	function VRDevice() {
	  this.isPolyfilled = true;
	  this.hardwareUnitId = 'webvr-polyfill hardwareUnitId';
	  this.deviceId = 'webvr-polyfill deviceId';
	  this.deviceName = 'webvr-polyfill deviceName';
	}
	
	/**
	 * The base class for all VR HMD devices. (Deprecated)
	 */
	function HMDVRDevice() {
	}
	HMDVRDevice.prototype = new VRDevice();
	
	/**
	 * The base class for all VR position sensor devices. (Deprecated)
	 */
	function PositionSensorVRDevice() {
	}
	PositionSensorVRDevice.prototype = new VRDevice();
	
	module.exports.VRFrameData = VRFrameData;
	module.exports.VRDisplay = VRDisplay;
	module.exports.VRDevice = VRDevice;
	module.exports.HMDVRDevice = HMDVRDevice;
	module.exports.PositionSensorVRDevice = PositionSensorVRDevice;
	
	},{"./util.js":22,"./wakelock.js":24}],3:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var CardboardUI = _dereq_('./cardboard-ui.js');
	var Util = _dereq_('./util.js');
	var WGLUPreserveGLState = _dereq_('./deps/wglu-preserve-state.js');
	
	var distortionVS = [
	  'attribute vec2 position;',
	  'attribute vec3 texCoord;',
	
	  'varying vec2 vTexCoord;',
	
	  'uniform vec4 viewportOffsetScale[2];',
	
	  'void main() {',
	  '  vec4 viewport = viewportOffsetScale[int(texCoord.z)];',
	  '  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;',
	  '  gl_Position = vec4( position, 1.0, 1.0 );',
	  '}',
	].join('\n');
	
	var distortionFS = [
	  'precision mediump float;',
	  'uniform sampler2D diffuse;',
	
	  'varying vec2 vTexCoord;',
	
	  'void main() {',
	  '  gl_FragColor = texture2D(diffuse, vTexCoord);',
	  '}',
	].join('\n');
	
	/**
	 * A mesh-based distorter.
	 */
	function CardboardDistorter(gl) {
	  this.gl = gl;
	  this.ctxAttribs = gl.getContextAttributes();
	
	  this.meshWidth = 20;
	  this.meshHeight = 20;
	
	  this.bufferScale = WebVRConfig.BUFFER_SCALE;
	
	  this.bufferWidth = gl.drawingBufferWidth;
	  this.bufferHeight = gl.drawingBufferHeight;
	
	  // Patching support
	  this.realBindFramebuffer = gl.bindFramebuffer;
	  this.realEnable = gl.enable;
	  this.realDisable = gl.disable;
	  this.realColorMask = gl.colorMask;
	  this.realClearColor = gl.clearColor;
	  this.realViewport = gl.viewport;
	
	  if (!Util.isIOS()) {
	    this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'width');
	    this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'height');
	  }
	
	  this.isPatched = false;
	
	  // State tracking
	  this.lastBoundFramebuffer = null;
	  this.cullFace = false;
	  this.depthTest = false;
	  this.blend = false;
	  this.scissorTest = false;
	  this.stencilTest = false;
	  this.viewport = [0, 0, 0, 0];
	  this.colorMask = [true, true, true, true];
	  this.clearColor = [0, 0, 0, 0];
	
	  this.attribs = {
	    position: 0,
	    texCoord: 1
	  };
	  this.program = Util.linkProgram(gl, distortionVS, distortionFS, this.attribs);
	  this.uniforms = Util.getProgramUniforms(gl, this.program);
	
	  this.viewportOffsetScale = new Float32Array(8);
	  this.setTextureBounds();
	
	  this.vertexBuffer = gl.createBuffer();
	  this.indexBuffer = gl.createBuffer();
	  this.indexCount = 0;
	
	  this.renderTarget = gl.createTexture();
	  this.framebuffer = gl.createFramebuffer();
	
	  this.depthStencilBuffer = null;
	  this.depthBuffer = null;
	  this.stencilBuffer = null;
	
	  if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
	    this.depthStencilBuffer = gl.createRenderbuffer();
	  } else if (this.ctxAttribs.depth) {
	    this.depthBuffer = gl.createRenderbuffer();
	  } else if (this.ctxAttribs.stencil) {
	    this.stencilBuffer = gl.createRenderbuffer();
	  }
	
	  this.patch();
	
	  this.onResize();
	
	  if (!WebVRConfig.CARDBOARD_UI_DISABLED) {
	    this.cardboardUI = new CardboardUI(gl);
	  }
	};
	
	/**
	 * Tears down all the resources created by the distorter and removes any
	 * patches.
	 */
	CardboardDistorter.prototype.destroy = function() {
	  var gl = this.gl;
	
	  this.unpatch();
	
	  gl.deleteProgram(this.program);
	  gl.deleteBuffer(this.vertexBuffer);
	  gl.deleteBuffer(this.indexBuffer);
	  gl.deleteTexture(this.renderTarget);
	  gl.deleteFramebuffer(this.framebuffer);
	  if (this.depthStencilBuffer) {
	    gl.deleteRenderbuffer(this.depthStencilBuffer);
	  }
	  if (this.depthBuffer) {
	    gl.deleteRenderbuffer(this.depthBuffer);
	  }
	  if (this.stencilBuffer) {
	    gl.deleteRenderbuffer(this.stencilBuffer);
	  }
	
	  if (this.cardboardUI) {
	    this.cardboardUI.destroy();
	  }
	};
	
	
	/**
	 * Resizes the backbuffer to match the canvas width and height.
	 */
	CardboardDistorter.prototype.onResize = function() {
	  var gl = this.gl;
	  var self = this;
	
	  var glState = [
	    gl.RENDERBUFFER_BINDING,
	    gl.TEXTURE_BINDING_2D, gl.TEXTURE0
	  ];
	
	  WGLUPreserveGLState(gl, glState, function(gl) {
	    // Bind real backbuffer and clear it once. We don't need to clear it again
	    // after that because we're overwriting the same area every frame.
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);
	
	    // Put things in a good state
	    if (self.scissorTest) { self.realDisable.call(gl, gl.SCISSOR_TEST); }
	    self.realColorMask.call(gl, true, true, true, true);
	    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	    self.realClearColor.call(gl, 0, 0, 0, 1);
	
	    gl.clear(gl.COLOR_BUFFER_BIT);
	
	    // Now bind and resize the fake backbuffer
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.framebuffer);
	
	    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
	    gl.texImage2D(gl.TEXTURE_2D, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB,
	        self.bufferWidth, self.bufferHeight, 0,
	        self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, gl.UNSIGNED_BYTE, null);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, self.renderTarget, 0);
	
	    if (self.ctxAttribs.depth && self.ctxAttribs.stencil) {
	      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthStencilBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,
	          self.bufferWidth, self.bufferHeight);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT,
	          gl.RENDERBUFFER, self.depthStencilBuffer);
	    } else if (self.ctxAttribs.depth) {
	      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
	          self.bufferWidth, self.bufferHeight);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
	          gl.RENDERBUFFER, self.depthBuffer);
	    } else if (self.ctxAttribs.stencil) {
	      gl.bindRenderbuffer(gl.RENDERBUFFER, self.stencilBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8,
	          self.bufferWidth, self.bufferHeight);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT,
	          gl.RENDERBUFFER, self.stencilBuffer);
	    }
	
	    if (!gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
	      console.error('Framebuffer incomplete!');
	    }
	
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
	
	    if (self.scissorTest) { self.realEnable.call(gl, gl.SCISSOR_TEST); }
	
	    self.realColorMask.apply(gl, self.colorMask);
	    self.realViewport.apply(gl, self.viewport);
	    self.realClearColor.apply(gl, self.clearColor);
	  });
	
	  if (this.cardboardUI) {
	    this.cardboardUI.onResize();
	  }
	};
	
	CardboardDistorter.prototype.patch = function() {
	  if (this.isPatched) {
	    return;
	  }
	
	  var self = this;
	  var canvas = this.gl.canvas;
	  var gl = this.gl;
	
	  if (!Util.isIOS()) {
	    canvas.width = Util.getScreenWidth() * this.bufferScale;
	    canvas.height = Util.getScreenHeight() * this.bufferScale;
	
	    Object.defineProperty(canvas, 'width', {
	      configurable: true,
	      enumerable: true,
	      get: function() {
	        return self.bufferWidth;
	      },
	      set: function(value) {
	        self.bufferWidth = value;
	        self.realCanvasWidth.set.call(canvas, value);
	        self.onResize();
	      }
	    });
	
	    Object.defineProperty(canvas, 'height', {
	      configurable: true,
	      enumerable: true,
	      get: function() {
	        return self.bufferHeight;
	      },
	      set: function(value) {
	        self.bufferHeight = value;
	        self.realCanvasHeight.set.call(canvas, value);
	        self.onResize();
	      }
	    });
	  }
	
	  this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
	
	  if (this.lastBoundFramebuffer == null) {
	    this.lastBoundFramebuffer = this.framebuffer;
	    this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
	  }
	
	  this.gl.bindFramebuffer = function(target, framebuffer) {
	    self.lastBoundFramebuffer = framebuffer ? framebuffer : self.framebuffer;
	    // Silently make calls to bind the default framebuffer bind ours instead.
	    self.realBindFramebuffer.call(gl, target, self.lastBoundFramebuffer);
	  };
	
	  this.cullFace = gl.getParameter(gl.CULL_FACE);
	  this.depthTest = gl.getParameter(gl.DEPTH_TEST);
	  this.blend = gl.getParameter(gl.BLEND);
	  this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
	  this.stencilTest = gl.getParameter(gl.STENCIL_TEST);
	
	  gl.enable = function(pname) {
	    switch (pname) {
	      case gl.CULL_FACE: self.cullFace = true; break;
	      case gl.DEPTH_TEST: self.depthTest = true; break;
	      case gl.BLEND: self.blend = true; break;
	      case gl.SCISSOR_TEST: self.scissorTest = true; break;
	      case gl.STENCIL_TEST: self.stencilTest = true; break;
	    }
	    self.realEnable.call(gl, pname);
	  };
	
	  gl.disable = function(pname) {
	    switch (pname) {
	      case gl.CULL_FACE: self.cullFace = false; break;
	      case gl.DEPTH_TEST: self.depthTest = false; break;
	      case gl.BLEND: self.blend = false; break;
	      case gl.SCISSOR_TEST: self.scissorTest = false; break;
	      case gl.STENCIL_TEST: self.stencilTest = false; break;
	    }
	    self.realDisable.call(gl, pname);
	  };
	
	  this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
	  gl.colorMask = function(r, g, b, a) {
	    self.colorMask[0] = r;
	    self.colorMask[1] = g;
	    self.colorMask[2] = b;
	    self.colorMask[3] = a;
	    self.realColorMask.call(gl, r, g, b, a);
	  };
	
	  this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
	  gl.clearColor = function(r, g, b, a) {
	    self.clearColor[0] = r;
	    self.clearColor[1] = g;
	    self.clearColor[2] = b;
	    self.clearColor[3] = a;
	    self.realClearColor.call(gl, r, g, b, a);
	  };
	
	  this.viewport = gl.getParameter(gl.VIEWPORT);
	  gl.viewport = function(x, y, w, h) {
	    self.viewport[0] = x;
	    self.viewport[1] = y;
	    self.viewport[2] = w;
	    self.viewport[3] = h;
	    self.realViewport.call(gl, x, y, w, h);
	  };
	
	  this.isPatched = true;
	  Util.safariCssSizeWorkaround(canvas);
	};
	
	CardboardDistorter.prototype.unpatch = function() {
	  if (!this.isPatched) {
	    return;
	  }
	
	  var gl = this.gl;
	  var canvas = this.gl.canvas;
	
	  if (!Util.isIOS()) {
	    Object.defineProperty(canvas, 'width', this.realCanvasWidth);
	    Object.defineProperty(canvas, 'height', this.realCanvasHeight);
	  }
	  canvas.width = this.bufferWidth;
	  canvas.height = this.bufferHeight;
	
	  gl.bindFramebuffer = this.realBindFramebuffer;
	  gl.enable = this.realEnable;
	  gl.disable = this.realDisable;
	  gl.colorMask = this.realColorMask;
	  gl.clearColor = this.realClearColor;
	  gl.viewport = this.realViewport;
	
	  // Check to see if our fake backbuffer is bound and bind the real backbuffer
	  // if that's the case.
	  if (this.lastBoundFramebuffer == this.framebuffer) {
	    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	  }
	
	  this.isPatched = false;
	
	  setTimeout(function() {
	    Util.safariCssSizeWorkaround(canvas);
	  }, 1);
	};
	
	CardboardDistorter.prototype.setTextureBounds = function(leftBounds, rightBounds) {
	  if (!leftBounds) {
	    leftBounds = [0, 0, 0.5, 1];
	  }
	
	  if (!rightBounds) {
	    rightBounds = [0.5, 0, 0.5, 1];
	  }
	
	  // Left eye
	  this.viewportOffsetScale[0] = leftBounds[0]; // X
	  this.viewportOffsetScale[1] = leftBounds[1]; // Y
	  this.viewportOffsetScale[2] = leftBounds[2]; // Width
	  this.viewportOffsetScale[3] = leftBounds[3]; // Height
	
	  // Right eye
	  this.viewportOffsetScale[4] = rightBounds[0]; // X
	  this.viewportOffsetScale[5] = rightBounds[1]; // Y
	  this.viewportOffsetScale[6] = rightBounds[2]; // Width
	  this.viewportOffsetScale[7] = rightBounds[3]; // Height
	};
	
	/**
	 * Performs distortion pass on the injected backbuffer, rendering it to the real
	 * backbuffer.
	 */
	CardboardDistorter.prototype.submitFrame = function() {
	  var gl = this.gl;
	  var self = this;
	
	  var glState = [];
	
	  if (!WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
	    glState.push(
	      gl.CURRENT_PROGRAM,
	      gl.ARRAY_BUFFER_BINDING,
	      gl.ELEMENT_ARRAY_BUFFER_BINDING,
	      gl.TEXTURE_BINDING_2D, gl.TEXTURE0
	    );
	  }
	
	  WGLUPreserveGLState(gl, glState, function(gl) {
	    // Bind the real default framebuffer
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);
	
	    // Make sure the GL state is in a good place
	    if (self.cullFace) { self.realDisable.call(gl, gl.CULL_FACE); }
	    if (self.depthTest) { self.realDisable.call(gl, gl.DEPTH_TEST); }
	    if (self.blend) { self.realDisable.call(gl, gl.BLEND); }
	    if (self.scissorTest) { self.realDisable.call(gl, gl.SCISSOR_TEST); }
	    if (self.stencilTest) { self.realDisable.call(gl, gl.STENCIL_TEST); }
	    self.realColorMask.call(gl, true, true, true, true);
	    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	
	    // If the backbuffer has an alpha channel clear every frame so the page
	    // doesn't show through.
	    if (self.ctxAttribs.alpha || Util.isIOS()) {
	      self.realClearColor.call(gl, 0, 0, 0, 1);
	      gl.clear(gl.COLOR_BUFFER_BIT);
	    }
	
	    // Bind distortion program and mesh
	    gl.useProgram(self.program);
	
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
	    gl.enableVertexAttribArray(self.attribs.position);
	    gl.enableVertexAttribArray(self.attribs.texCoord);
	    gl.vertexAttribPointer(self.attribs.position, 2, gl.FLOAT, false, 20, 0);
	    gl.vertexAttribPointer(self.attribs.texCoord, 3, gl.FLOAT, false, 20, 8);
	
	    gl.activeTexture(gl.TEXTURE0);
	    gl.uniform1i(self.uniforms.diffuse, 0);
	    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
	
	    gl.uniform4fv(self.uniforms.viewportOffsetScale, self.viewportOffsetScale);
	
	    // Draws both eyes
	    gl.drawElements(gl.TRIANGLES, self.indexCount, gl.UNSIGNED_SHORT, 0);
	
	    if (self.cardboardUI) {
	      self.cardboardUI.renderNoState();
	    }
	
	    // Bind the fake default framebuffer again
	    self.realBindFramebuffer.call(self.gl, gl.FRAMEBUFFER, self.framebuffer);
	
	    // If preserveDrawingBuffer == false clear the framebuffer
	    if (!self.ctxAttribs.preserveDrawingBuffer) {
	      self.realClearColor.call(gl, 0, 0, 0, 0);
	      gl.clear(gl.COLOR_BUFFER_BIT);
	    }
	
	    if (!WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
	      self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
	    }
	
	    // Restore state
	    if (self.cullFace) { self.realEnable.call(gl, gl.CULL_FACE); }
	    if (self.depthTest) { self.realEnable.call(gl, gl.DEPTH_TEST); }
	    if (self.blend) { self.realEnable.call(gl, gl.BLEND); }
	    if (self.scissorTest) { self.realEnable.call(gl, gl.SCISSOR_TEST); }
	    if (self.stencilTest) { self.realEnable.call(gl, gl.STENCIL_TEST); }
	
	    self.realColorMask.apply(gl, self.colorMask);
	    self.realViewport.apply(gl, self.viewport);
	    if (self.ctxAttribs.alpha || !self.ctxAttribs.preserveDrawingBuffer) {
	      self.realClearColor.apply(gl, self.clearColor);
	    }
	  });
	
	  // Workaround for the fact that Safari doesn't allow us to patch the canvas
	  // width and height correctly. After each submit frame check to see what the
	  // real backbuffer size has been set to and resize the fake backbuffer size
	  // to match.
	  if (Util.isIOS()) {
	    var canvas = gl.canvas;
	    if (canvas.width != self.bufferWidth || canvas.height != self.bufferHeight) {
	      self.bufferWidth = canvas.width;
	      self.bufferHeight = canvas.height;
	      self.onResize();
	    }
	  }
	};
	
	/**
	 * Call when the deviceInfo has changed. At this point we need
	 * to re-calculate the distortion mesh.
	 */
	CardboardDistorter.prototype.updateDeviceInfo = function(deviceInfo) {
	  var gl = this.gl;
	  var self = this;
	
	  var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
	  WGLUPreserveGLState(gl, glState, function(gl) {
	    var vertices = self.computeMeshVertices_(self.meshWidth, self.meshHeight, deviceInfo);
	    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
	
	    // Indices don't change based on device parameters, so only compute once.
	    if (!self.indexCount) {
	      var indices = self.computeMeshIndices_(self.meshWidth, self.meshHeight);
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
	      self.indexCount = indices.length;
	    }
	  });
	};
	
	/**
	 * Build the distortion mesh vertices.
	 * Based on code from the Unity cardboard plugin.
	 */
	CardboardDistorter.prototype.computeMeshVertices_ = function(width, height, deviceInfo) {
	  var vertices = new Float32Array(2 * width * height * 5);
	
	  var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
	  var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
	  var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
	  var vidx = 0;
	  var iidx = 0;
	  for (var e = 0; e < 2; e++) {
	    for (var j = 0; j < height; j++) {
	      for (var i = 0; i < width; i++, vidx++) {
	        var u = i / (width - 1);
	        var v = j / (height - 1);
	
	        // Grid points regularly spaced in StreoScreen, and barrel distorted in
	        // the mesh.
	        var s = u;
	        var t = v;
	        var x = Util.lerp(lensFrustum[0], lensFrustum[2], u);
	        var y = Util.lerp(lensFrustum[3], lensFrustum[1], v);
	        var d = Math.sqrt(x * x + y * y);
	        var r = deviceInfo.distortion.distortInverse(d);
	        var p = x * r / d;
	        var q = y * r / d;
	        u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
	        v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);
	
	        // Convert u,v to mesh screen coordinates.
	        var aspect = deviceInfo.device.widthMeters / deviceInfo.device.heightMeters;
	
	        // FIXME: The original Unity plugin multiplied U by the aspect ratio
	        // and didn't multiply either value by 2, but that seems to get it
	        // really close to correct looking for me. I hate this kind of "Don't
	        // know why it works" code though, and wold love a more logical
	        // explanation of what needs to happen here.
	        u = (viewport.x + u * viewport.width - 0.5) * 2.0; //* aspect;
	        v = (viewport.y + v * viewport.height - 0.5) * 2.0;
	
	        vertices[(vidx * 5) + 0] = u; // position.x
	        vertices[(vidx * 5) + 1] = v; // position.y
	        vertices[(vidx * 5) + 2] = s; // texCoord.x
	        vertices[(vidx * 5) + 3] = t; // texCoord.y
	        vertices[(vidx * 5) + 4] = e; // texCoord.z (viewport index)
	      }
	    }
	    var w = lensFrustum[2] - lensFrustum[0];
	    lensFrustum[0] = -(w + lensFrustum[0]);
	    lensFrustum[2] = w - lensFrustum[2];
	    w = noLensFrustum[2] - noLensFrustum[0];
	    noLensFrustum[0] = -(w + noLensFrustum[0]);
	    noLensFrustum[2] = w - noLensFrustum[2];
	    viewport.x = 1 - (viewport.x + viewport.width);
	  }
	  return vertices;
	}
	
	/**
	 * Build the distortion mesh indices.
	 * Based on code from the Unity cardboard plugin.
	 */
	CardboardDistorter.prototype.computeMeshIndices_ = function(width, height) {
	  var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
	  var halfwidth = width / 2;
	  var halfheight = height / 2;
	  var vidx = 0;
	  var iidx = 0;
	  for (var e = 0; e < 2; e++) {
	    for (var j = 0; j < height; j++) {
	      for (var i = 0; i < width; i++, vidx++) {
	        if (i == 0 || j == 0)
	          continue;
	        // Build a quad.  Lower right and upper left quadrants have quads with
	        // the triangle diagonal flipped to get the vignette to interpolate
	        // correctly.
	        if ((i <= halfwidth) == (j <= halfheight)) {
	          // Quad diagonal lower left to upper right.
	          indices[iidx++] = vidx;
	          indices[iidx++] = vidx - width - 1;
	          indices[iidx++] = vidx - width;
	          indices[iidx++] = vidx - width - 1;
	          indices[iidx++] = vidx;
	          indices[iidx++] = vidx - 1;
	        } else {
	          // Quad diagonal upper left to lower right.
	          indices[iidx++] = vidx - 1;
	          indices[iidx++] = vidx - width;
	          indices[iidx++] = vidx;
	          indices[iidx++] = vidx - width;
	          indices[iidx++] = vidx - 1;
	          indices[iidx++] = vidx - width - 1;
	        }
	      }
	    }
	  }
	  return indices;
	};
	
	CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function(proto, attrName) {
	  var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
	  // In some cases (ahem... Safari), the descriptor returns undefined get and
	  // set fields. In this case, we need to create a synthetic property
	  // descriptor. This works around some of the issues in
	  // https://github.com/borismus/webvr-polyfill/issues/46
	  if (descriptor.get === undefined || descriptor.set === undefined) {
	    descriptor.configurable = true;
	    descriptor.enumerable = true;
	    descriptor.get = function() {
	      return this.getAttribute(attrName);
	    };
	    descriptor.set = function(val) {
	      this.setAttribute(attrName, val);
	    };
	  }
	  return descriptor;
	};
	
	module.exports = CardboardDistorter;
	
	},{"./cardboard-ui.js":4,"./deps/wglu-preserve-state.js":6,"./util.js":22}],4:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var Util = _dereq_('./util.js');
	var WGLUPreserveGLState = _dereq_('./deps/wglu-preserve-state.js');
	
	var uiVS = [
	  'attribute vec2 position;',
	
	  'uniform mat4 projectionMat;',
	
	  'void main() {',
	  '  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );',
	  '}',
	].join('\n');
	
	var uiFS = [
	  'precision mediump float;',
	
	  'uniform vec4 color;',
	
	  'void main() {',
	  '  gl_FragColor = color;',
	  '}',
	].join('\n');
	
	var DEG2RAD = Math.PI/180.0;
	
	// The gear has 6 identical sections, each spanning 60 degrees.
	var kAnglePerGearSection = 60;
	
	// Half-angle of the span of the outer rim.
	var kOuterRimEndAngle = 12;
	
	// Angle between the middle of the outer rim and the start of the inner rim.
	var kInnerRimBeginAngle = 20;
	
	// Distance from center to outer rim, normalized so that the entire model
	// fits in a [-1, 1] x [-1, 1] square.
	var kOuterRadius = 1;
	
	// Distance from center to depressed rim, in model units.
	var kMiddleRadius = 0.75;
	
	// Radius of the inner hollow circle, in model units.
	var kInnerRadius = 0.3125;
	
	// Center line thickness in DP.
	var kCenterLineThicknessDp = 4;
	
	// Button width in DP.
	var kButtonWidthDp = 28;
	
	// Factor to scale the touch area that responds to the touch.
	var kTouchSlopFactor = 1.5;
	
	var Angles = [
	  0, kOuterRimEndAngle, kInnerRimBeginAngle,
	  kAnglePerGearSection - kInnerRimBeginAngle,
	  kAnglePerGearSection - kOuterRimEndAngle
	];
	
	/**
	 * Renders the alignment line and "options" gear. It is assumed that the canvas
	 * this is rendered into covers the entire screen (or close to it.)
	 */
	function CardboardUI(gl) {
	  this.gl = gl;
	
	  this.attribs = {
	    position: 0
	  };
	  this.program = Util.linkProgram(gl, uiVS, uiFS, this.attribs);
	  this.uniforms = Util.getProgramUniforms(gl, this.program);
	
	  this.vertexBuffer = gl.createBuffer();
	  this.gearOffset = 0;
	  this.gearVertexCount = 0;
	  this.arrowOffset = 0;
	  this.arrowVertexCount = 0;
	
	  this.projMat = new Float32Array(16);
	
	  this.listener = null;
	
	  this.onResize();
	};
	
	/**
	 * Tears down all the resources created by the UI renderer.
	 */
	CardboardUI.prototype.destroy = function() {
	  var gl = this.gl;
	
	  if (this.listener) {
	    gl.canvas.removeEventListener('click', this.listener, false);
	  }
	
	  gl.deleteProgram(this.program);
	  gl.deleteBuffer(this.vertexBuffer);
	};
	
	/**
	 * Adds a listener to clicks on the gear and back icons
	 */
	CardboardUI.prototype.listen = function(optionsCallback, backCallback) {
	  var canvas = this.gl.canvas;
	  this.listener = function(event) {
	    var midline = canvas.clientWidth / 2;
	    var buttonSize = kButtonWidthDp * kTouchSlopFactor;
	    // Check to see if the user clicked on (or around) the gear icon
	    if (event.clientX > midline - buttonSize &&
	        event.clientX < midline + buttonSize &&
	        event.clientY > canvas.clientHeight - buttonSize) {
	      optionsCallback(event);
	    }
	    // Check to see if the user clicked on (or around) the back icon
	    else if (event.clientX < buttonSize && event.clientY < buttonSize) {
	      backCallback(event);
	    }
	  };
	  canvas.addEventListener('click', this.listener, false);
	};
	
	/**
	 * Builds the UI mesh.
	 */
	CardboardUI.prototype.onResize = function() {
	  var gl = this.gl;
	  var self = this;
	
	  var glState = [
	    gl.ARRAY_BUFFER_BINDING
	  ];
	
	  WGLUPreserveGLState(gl, glState, function(gl) {
	    var vertices = [];
	
	    var midline = gl.drawingBufferWidth / 2;
	
	    // Assumes your canvas width and height is scaled proportionately.
	    // TODO(smus): The following causes buttons to become huge on iOS, but seems
	    // like the right thing to do. For now, added a hack. But really, investigate why.
	    var dps = (gl.drawingBufferWidth / (screen.width * window.devicePixelRatio));
	    if (!Util.isIOS()) {
	      dps *= window.devicePixelRatio;
	    }
	
	    var lineWidth = kCenterLineThicknessDp * dps / 2;
	    var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
	    var buttonScale = kButtonWidthDp * dps / 2;
	    var buttonBorder = ((kButtonWidthDp * kTouchSlopFactor) - kButtonWidthDp) * dps;
	
	    // Build centerline
	    vertices.push(midline - lineWidth, buttonSize);
	    vertices.push(midline - lineWidth, gl.drawingBufferHeight);
	    vertices.push(midline + lineWidth, buttonSize);
	    vertices.push(midline + lineWidth, gl.drawingBufferHeight);
	
	    // Build gear
	    self.gearOffset = (vertices.length / 2);
	
	    function addGearSegment(theta, r) {
	      var angle = (90 - theta) * DEG2RAD;
	      var x = Math.cos(angle);
	      var y = Math.sin(angle);
	      vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
	      vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
	    }
	
	    for (var i = 0; i <= 6; i++) {
	      var segmentTheta = i * kAnglePerGearSection;
	
	      addGearSegment(segmentTheta, kOuterRadius);
	      addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
	      addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
	      addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
	      addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
	    }
	
	    self.gearVertexCount = (vertices.length / 2) - self.gearOffset;
	
	    // Build back arrow
	    self.arrowOffset = (vertices.length / 2);
	
	    function addArrowVertex(x, y) {
	      vertices.push(buttonBorder + x, gl.drawingBufferHeight - buttonBorder - y);
	    }
	
	    var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);
	
	    addArrowVertex(0, buttonScale);
	    addArrowVertex(buttonScale, 0);
	    addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
	    addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);
	
	    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
	    addArrowVertex(0, buttonScale);
	    addArrowVertex(buttonScale, buttonScale * 2);
	    addArrowVertex(buttonScale + angledLineWidth, (buttonScale * 2) - angledLineWidth);
	
	    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
	    addArrowVertex(0, buttonScale);
	
	    addArrowVertex(angledLineWidth, buttonScale - lineWidth);
	    addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
	    addArrowVertex(angledLineWidth, buttonScale + lineWidth);
	    addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);
	
	    self.arrowVertexCount = (vertices.length / 2) - self.arrowOffset;
	
	    // Buffer data
	    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	  });
	};
	
	/**
	 * Performs distortion pass on the injected backbuffer, rendering it to the real
	 * backbuffer.
	 */
	CardboardUI.prototype.render = function() {
	  var gl = this.gl;
	  var self = this;
	
	  var glState = [
	    gl.CULL_FACE,
	    gl.DEPTH_TEST,
	    gl.BLEND,
	    gl.SCISSOR_TEST,
	    gl.STENCIL_TEST,
	    gl.COLOR_WRITEMASK,
	    gl.VIEWPORT,
	
	    gl.CURRENT_PROGRAM,
	    gl.ARRAY_BUFFER_BINDING
	  ];
	
	  WGLUPreserveGLState(gl, glState, function(gl) {
	    // Make sure the GL state is in a good place
	    gl.disable(gl.CULL_FACE);
	    gl.disable(gl.DEPTH_TEST);
	    gl.disable(gl.BLEND);
	    gl.disable(gl.SCISSOR_TEST);
	    gl.disable(gl.STENCIL_TEST);
	    gl.colorMask(true, true, true, true);
	    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	
	    self.renderNoState();
	  });
	};
	
	CardboardUI.prototype.renderNoState = function() {
	  var gl = this.gl;
	
	  // Bind distortion program and mesh
	  gl.useProgram(this.program);
	
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	  gl.enableVertexAttribArray(this.attribs.position);
	  gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);
	
	  gl.uniform4f(this.uniforms.color, 1.0, 1.0, 1.0, 1.0);
	
	  Util.orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024.0);
	  gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);
	
	  // Draws UI element
	  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	  gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
	  gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
	};
	
	module.exports = CardboardUI;
	
	},{"./deps/wglu-preserve-state.js":6,"./util.js":22}],5:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var CardboardDistorter = _dereq_('./cardboard-distorter.js');
	var CardboardUI = _dereq_('./cardboard-ui.js');
	var DeviceInfo = _dereq_('./device-info.js');
	var Dpdb = _dereq_('./dpdb/dpdb.js');
	var FusionPoseSensor = _dereq_('./sensor-fusion/fusion-pose-sensor.js');
	var RotateInstructions = _dereq_('./rotate-instructions.js');
	var ViewerSelector = _dereq_('./viewer-selector.js');
	var VRDisplay = _dereq_('./base.js').VRDisplay;
	var Util = _dereq_('./util.js');
	
	var Eye = {
	  LEFT: 'left',
	  RIGHT: 'right'
	};
	
	/**
	 * VRDisplay based on mobile device parameters and DeviceMotion APIs.
	 */
	function CardboardVRDisplay() {
	  this.displayName = 'Cardboard VRDisplay (webvr-polyfill)';
	
	  this.capabilities.hasOrientation = true;
	  this.capabilities.canPresent = true;
	
	  // "Private" members.
	  this.bufferScale_ = WebVRConfig.BUFFER_SCALE;
	  this.poseSensor_ = new FusionPoseSensor();
	  this.distorter_ = null;
	  this.cardboardUI_ = null;
	
	  this.dpdb_ = new Dpdb(true, this.onDeviceParamsUpdated_.bind(this));
	  this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams());
	
	  this.viewerSelector_ = new ViewerSelector();
	  this.viewerSelector_.on('change', this.onViewerChanged_.bind(this));
	
	  // Set the correct initial viewer.
	  this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());
	
	  if (!WebVRConfig.ROTATE_INSTRUCTIONS_DISABLED) {
	    this.rotateInstructions_ = new RotateInstructions();
	  }
	
	  if (Util.isIOS()) {
	    // Listen for resize events to workaround this awful Safari bug.
	    window.addEventListener('resize', this.onResize_.bind(this));
	  }
	}
	CardboardVRDisplay.prototype = new VRDisplay();
	
	CardboardVRDisplay.prototype.getImmediatePose = function() {
	  return {
	    position: this.poseSensor_.getPosition(),
	    orientation: this.poseSensor_.getOrientation(),
	    linearVelocity: null,
	    linearAcceleration: null,
	    angularVelocity: null,
	    angularAcceleration: null
	  };
	};
	
	CardboardVRDisplay.prototype.resetPose = function() {
	  this.poseSensor_.resetPose();
	};
	
	CardboardVRDisplay.prototype.getEyeParameters = function(whichEye) {
	  var offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0.0, 0.0];
	  var fieldOfView;
	
	  // TODO: FoV can be a little expensive to compute. Cache when device params change.
	  if (whichEye == Eye.LEFT) {
	    offset[0] *= -1.0;
	    fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
	  } else if (whichEye == Eye.RIGHT) {
	    fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
	  } else {
	    console.error('Invalid eye provided: %s', whichEye);
	    return null;
	  }
	
	  return {
	    fieldOfView: fieldOfView,
	    offset: offset,
	    // TODO: Should be able to provide better values than these.
	    renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
	    renderHeight: this.deviceInfo_.device.height * this.bufferScale_,
	  };
	};
	
	CardboardVRDisplay.prototype.onDeviceParamsUpdated_ = function(newParams) {
	  console.log('DPDB reported that device params were updated.');
	  this.deviceInfo_.updateDeviceParams(newParams);
	
	  if (this.distorter_) {
	    this.distorter_.updateDeviceInfo(this.deviceInfo_);
	  }
	};
	
	CardboardVRDisplay.prototype.updateBounds_ = function () {
	  if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
	    this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
	  }
	};
	
	CardboardVRDisplay.prototype.beginPresent_ = function() {
	  var gl = this.layer_.source.getContext('webgl');
	  if (!gl)
	    gl = this.layer_.source.getContext('experimental-webgl');
	  if (!gl)
	    gl = this.layer_.source.getContext('webgl2');
	
	  if (!gl)
	    return; // Can't do distortion without a WebGL context.
	
	  // Provides a way to opt out of distortion
	  if (this.layer_.predistorted) {
	    if (!WebVRConfig.CARDBOARD_UI_DISABLED) {
	      gl.canvas.width = Util.getScreenWidth() * this.bufferScale_;
	      gl.canvas.height = Util.getScreenHeight() * this.bufferScale_;
	      this.cardboardUI_ = new CardboardUI(gl);
	    }
	  } else {
	    // Create a new distorter for the target context
	    this.distorter_ = new CardboardDistorter(gl);
	    this.distorter_.updateDeviceInfo(this.deviceInfo_);
	    this.cardboardUI_ = this.distorter_.cardboardUI;
	  }
	
	  if (this.cardboardUI_) {
	    this.cardboardUI_.listen(function(e) {
	      // Options clicked.
	      this.viewerSelector_.show(this.layer_.source.parentElement);
	      e.stopPropagation();
	      e.preventDefault();
	    }.bind(this), function(e) {
	      // Back clicked.
	      this.exitPresent();
	      e.stopPropagation();
	      e.preventDefault();
	    }.bind(this));
	  }
	
	  if (this.rotateInstructions_) {
	    if (Util.isLandscapeMode() && Util.isMobile()) {
	      // In landscape mode, temporarily show the "put into Cardboard"
	      // interstitial. Otherwise, do the default thing.
	      this.rotateInstructions_.showTemporarily(3000, this.layer_.source.parentElement);
	    } else {
	      this.rotateInstructions_.update();
	    }
	  }
	
	  // Listen for orientation change events in order to show interstitial.
	  this.orientationHandler = this.onOrientationChange_.bind(this);
	  window.addEventListener('orientationchange', this.orientationHandler);
	
	  // Listen for present display change events in order to update distorter dimensions
	  this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
	  window.addEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
	
	  // Fire this event initially, to give geometry-distortion clients the chance
	  // to do something custom.
	  this.fireVRDisplayDeviceParamsChange_();
	};
	
	CardboardVRDisplay.prototype.endPresent_ = function() {
	  if (this.distorter_) {
	    this.distorter_.destroy();
	    this.distorter_ = null;
	  }
	  if (this.cardboardUI_) {
	    this.cardboardUI_.destroy();
	    this.cardboardUI_ = null;
	  }
	
	  if (this.rotateInstructions_) {
	    this.rotateInstructions_.hide();
	  }
	  this.viewerSelector_.hide();
	
	  window.removeEventListener('orientationchange', this.orientationHandler);
	  window.removeEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
	};
	
	CardboardVRDisplay.prototype.submitFrame = function(pose) {
	  if (this.distorter_) {
	    this.distorter_.submitFrame();
	  } else if (this.cardboardUI_ && this.layer_) {
	    // Hack for predistorted: true.
	    var canvas = this.layer_.source.getContext('webgl').canvas;
	    if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
	      this.cardboardUI_.onResize();
	    }
	    this.lastWidth = canvas.width;
	    this.lastHeight = canvas.height;
	
	    // Render the Cardboard UI.
	    this.cardboardUI_.render();
	  }
	};
	
	CardboardVRDisplay.prototype.onOrientationChange_ = function(e) {
	  console.log('onOrientationChange_');
	
	  // Hide the viewer selector.
	  this.viewerSelector_.hide();
	
	  // Update the rotate instructions.
	  if (this.rotateInstructions_) {
	    this.rotateInstructions_.update();
	  }
	
	  this.onResize_();
	};
	
	CardboardVRDisplay.prototype.onResize_ = function(e) {
	  if (this.layer_) {
	    var gl = this.layer_.source.getContext('webgl');
	    // Size the CSS canvas.
	    // Added padding on right and bottom because iPhone 5 will not
	    // hide the URL bar unless content is bigger than the screen.
	    // This will not be visible as long as the container element (e.g. body)
	    // is set to 'overflow: hidden'.
	    var cssProperties = [
	      'position: absolute',
	      'top: 0',
	      'left: 0',
	      'width: ' + Math.max(screen.width, screen.height) + 'px',
	      'height: ' + Math.min(screen.height, screen.width) + 'px',
	      'border: 0',
	      'margin: 0',
	      'padding: 0 10px 10px 0',
	    ];
	    gl.canvas.setAttribute('style', cssProperties.join('; ') + ';');
	
	    Util.safariCssSizeWorkaround(gl.canvas);
	  }
	};
	
	CardboardVRDisplay.prototype.onViewerChanged_ = function(viewer) {
	  this.deviceInfo_.setViewer(viewer);
	
	  if (this.distorter_) {
	    // Update the distortion appropriately.
	    this.distorter_.updateDeviceInfo(this.deviceInfo_);
	  }
	
	  // Fire a new event containing viewer and device parameters for clients that
	  // want to implement their own geometry-based distortion.
	  this.fireVRDisplayDeviceParamsChange_();
	};
	
	CardboardVRDisplay.prototype.fireVRDisplayDeviceParamsChange_ = function() {
	  var event = new CustomEvent('vrdisplaydeviceparamschange', {
	    detail: {
	      vrdisplay: this,
	      deviceInfo: this.deviceInfo_,
	    }
	  });
	  window.dispatchEvent(event);
	};
	
	module.exports = CardboardVRDisplay;
	
	},{"./base.js":2,"./cardboard-distorter.js":3,"./cardboard-ui.js":4,"./device-info.js":7,"./dpdb/dpdb.js":11,"./rotate-instructions.js":16,"./sensor-fusion/fusion-pose-sensor.js":18,"./util.js":22,"./viewer-selector.js":23}],6:[function(_dereq_,module,exports){
	/*
	Copyright (c) 2016, Brandon Jones.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/
	
	/*
	Caches specified GL state, runs a callback, and restores the cached state when
	done.
	
	Example usage:
	
	var savedState = [
	  gl.ARRAY_BUFFER_BINDING,
	
	  // TEXTURE_BINDING_2D or _CUBE_MAP must always be followed by the texure unit.
	  gl.TEXTURE_BINDING_2D, gl.TEXTURE0,
	
	  gl.CLEAR_COLOR,
	];
	// After this call the array buffer, texture unit 0, active texture, and clear
	// color will be restored. The viewport will remain changed, however, because
	// gl.VIEWPORT was not included in the savedState list.
	WGLUPreserveGLState(gl, savedState, function(gl) {
	  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ARRAY_BUFFER, ....);
	
	  gl.activeTexture(gl.TEXTURE0);
	  gl.bindTexture(gl.TEXTURE_2D, texture);
	  gl.texImage2D(gl.TEXTURE_2D, ...);
	
	  gl.clearColor(1, 0, 0, 1);
	  gl.clear(gl.COLOR_BUFFER_BIT);
	});
	
	Note that this is not intended to be fast. Managing state in your own code to
	avoid redundant state setting and querying will always be faster. This function
	is most useful for cases where you may not have full control over the WebGL
	calls being made, such as tooling or effect injectors.
	*/
	
	function WGLUPreserveGLState(gl, bindings, callback) {
	  if (!bindings) {
	    callback(gl);
	    return;
	  }
	
	  var boundValues = [];
	
	  var activeTexture = null;
	  for (var i = 0; i < bindings.length; ++i) {
	    var binding = bindings[i];
	    switch (binding) {
	      case gl.TEXTURE_BINDING_2D:
	      case gl.TEXTURE_BINDING_CUBE_MAP:
	        var textureUnit = bindings[++i];
	        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
	          console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
	          boundValues.push(null, null);
	          break;
	        }
	        if (!activeTexture) {
	          activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
	        }
	        gl.activeTexture(textureUnit);
	        boundValues.push(gl.getParameter(binding), null);
	        break;
	      case gl.ACTIVE_TEXTURE:
	        activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
	        boundValues.push(null);
	        break;
	      default:
	        boundValues.push(gl.getParameter(binding));
	        break;
	    }
	  }
	
	  callback(gl);
	
	  for (var i = 0; i < bindings.length; ++i) {
	    var binding = bindings[i];
	    var boundValue = boundValues[i];
	    switch (binding) {
	      case gl.ACTIVE_TEXTURE:
	        break; // Ignore this binding, since we special-case it to happen last.
	      case gl.ARRAY_BUFFER_BINDING:
	        gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
	        break;
	      case gl.COLOR_CLEAR_VALUE:
	        gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
	        break;
	      case gl.COLOR_WRITEMASK:
	        gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
	        break;
	      case gl.CURRENT_PROGRAM:
	        gl.useProgram(boundValue);
	        break;
	      case gl.ELEMENT_ARRAY_BUFFER_BINDING:
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
	        break;
	      case gl.FRAMEBUFFER_BINDING:
	        gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
	        break;
	      case gl.RENDERBUFFER_BINDING:
	        gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
	        break;
	      case gl.TEXTURE_BINDING_2D:
	        var textureUnit = bindings[++i];
	        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
	          break;
	        gl.activeTexture(textureUnit);
	        gl.bindTexture(gl.TEXTURE_2D, boundValue);
	        break;
	      case gl.TEXTURE_BINDING_CUBE_MAP:
	        var textureUnit = bindings[++i];
	        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
	          break;
	        gl.activeTexture(textureUnit);
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
	        break;
	      case gl.VIEWPORT:
	        gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
	        break;
	      case gl.BLEND:
	      case gl.CULL_FACE:
	      case gl.DEPTH_TEST:
	      case gl.SCISSOR_TEST:
	      case gl.STENCIL_TEST:
	        if (boundValue) {
	          gl.enable(binding);
	        } else {
	          gl.disable(binding);
	        }
	        break;
	      default:
	        console.log("No GL restore behavior for 0x" + binding.toString(16));
	        break;
	    }
	
	    if (activeTexture) {
	      gl.activeTexture(activeTexture);
	    }
	  }
	}
	
	module.exports = WGLUPreserveGLState;
	},{}],7:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var Distortion = _dereq_('./distortion/distortion.js');
	var MathUtil = _dereq_('./math-util.js');
	var Util = _dereq_('./util.js');
	
	function Device(params) {
	  this.width = params.width || Util.getScreenWidth();
	  this.height = params.height || Util.getScreenHeight();
	  this.widthMeters = params.widthMeters;
	  this.heightMeters = params.heightMeters;
	  this.bevelMeters = params.bevelMeters;
	}
	
	
	// Fallback Android device (based on Nexus 5 measurements) for use when
	// we can't recognize an Android device.
	var DEFAULT_ANDROID = new Device({
	  widthMeters: 0.110,
	  heightMeters: 0.062,
	  bevelMeters: 0.004
	});
	
	// Fallback iOS device (based on iPhone6) for use when
	// we can't recognize an Android device.
	var DEFAULT_IOS = new Device({
	  widthMeters: 0.1038,
	  heightMeters: 0.0584,
	  bevelMeters: 0.004
	});
	
	
	var Viewers = {
	  CardboardV1: new CardboardViewer({
	    id: 'CardboardV1',
	    label: 'Cardboard I/O 2014',
	    fov: 40,
	    interLensDistance: 0.060,
	    baselineLensDistance: 0.035,
	    screenLensDistance: 0.042,
	    distortionCoefficients: [0.441, 0.156],
	    inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139,
	      -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841,
	      0.0651772, -0.01488963, 0.001559834]
	  }),
	  CardboardV2: new CardboardViewer({
	    id: 'CardboardV2',
	    label: 'Cardboard I/O 2015',
	    fov: 60,
	    interLensDistance: 0.064,
	    baselineLensDistance: 0.035,
	    screenLensDistance: 0.039,
	    distortionCoefficients: [0.34, 0.55],
	    inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051,
	      1.0560602, -0.58208317, 0.21609078, -0.05444823, 0.009177956,
	      -9.904169E-4, 6.183535E-5, -1.6981803E-6]
	  })
	};
	
	
	var DEFAULT_LEFT_CENTER = {x: 0.5, y: 0.5};
	var DEFAULT_RIGHT_CENTER = {x: 0.5, y: 0.5};
	
	/**
	 * Manages information about the device and the viewer.
	 *
	 * deviceParams indicates the parameters of the device to use (generally
	 * obtained from dpdb.getDeviceParams()). Can be null to mean no device
	 * params were found.
	 */
	function DeviceInfo(deviceParams) {
	  this.viewer = Viewers.CardboardV2;
	  this.updateDeviceParams(deviceParams);
	  this.distortion = new Distortion(this.viewer.distortionCoefficients);
	}
	
	DeviceInfo.prototype.updateDeviceParams = function(deviceParams) {
	  this.device = this.determineDevice_(deviceParams) || this.device;
	};
	
	DeviceInfo.prototype.getDevice = function() {
	  return this.device;
	};
	
	DeviceInfo.prototype.setViewer = function(viewer) {
	  this.viewer = viewer;
	  this.distortion = new Distortion(this.viewer.distortionCoefficients);
	};
	
	DeviceInfo.prototype.determineDevice_ = function(deviceParams) {
	  if (!deviceParams) {
	    // No parameters, so use a default.
	    if (Util.isIOS()) {
	      console.warn('Using fallback iOS device measurements.');
	      return DEFAULT_IOS;
	    } else {
	      console.warn('Using fallback Android device measurements.');
	      return DEFAULT_ANDROID;
	    }
	  }
	
	  // Compute device screen dimensions based on deviceParams.
	  var METERS_PER_INCH = 0.0254;
	  var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
	  var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
	  var width = Util.getScreenWidth();
	  var height = Util.getScreenHeight();
	  return new Device({
	    widthMeters: metersPerPixelX * width,
	    heightMeters: metersPerPixelY * height,
	    bevelMeters: deviceParams.bevelMm * 0.001,
	  });
	};
	
	/**
	 * Calculates field of view for the left eye.
	 */
	DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function() {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;
	
	  // Device.height and device.width for device in portrait mode, so transpose.
	  var eyeToScreenDistance = viewer.screenLensDistance;
	
	  var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
	  var innerDist = viewer.interLensDistance / 2;
	  var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
	  var topDist = device.heightMeters - bottomDist;
	
	  var outerAngle = MathUtil.radToDeg * Math.atan(
	      distortion.distort(outerDist / eyeToScreenDistance));
	  var innerAngle = MathUtil.radToDeg * Math.atan(
	      distortion.distort(innerDist / eyeToScreenDistance));
	  var bottomAngle = MathUtil.radToDeg * Math.atan(
	      distortion.distort(bottomDist / eyeToScreenDistance));
	  var topAngle = MathUtil.radToDeg * Math.atan(
	      distortion.distort(topDist / eyeToScreenDistance));
	
	  return {
	    leftDegrees: Math.min(outerAngle, viewer.fov),
	    rightDegrees: Math.min(innerAngle, viewer.fov),
	    downDegrees: Math.min(bottomAngle, viewer.fov),
	    upDegrees: Math.min(topAngle, viewer.fov)
	  };
	};
	
	/**
	 * Calculates the tan-angles from the maximum FOV for the left eye for the
	 * current device and screen parameters.
	 */
	DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function() {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;
	
	  // Tan-angles from the max FOV.
	  var fovLeft = Math.tan(-MathUtil.degToRad * viewer.fov);
	  var fovTop = Math.tan(MathUtil.degToRad * viewer.fov);
	  var fovRight = Math.tan(MathUtil.degToRad * viewer.fov);
	  var fovBottom = Math.tan(-MathUtil.degToRad * viewer.fov);
	  // Viewport size.
	  var halfWidth = device.widthMeters / 4;
	  var halfHeight = device.heightMeters / 2;
	  // Viewport center, measured from left lens position.
	  var verticalLensOffset = (viewer.baselineLensDistance - device.bevelMeters - halfHeight);
	  var centerX = viewer.interLensDistance / 2 - halfWidth;
	  var centerY = -verticalLensOffset;
	  var centerZ = viewer.screenLensDistance;
	  // Tan-angles of the viewport edges, as seen through the lens.
	  var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
	  var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
	  var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
	  var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
	  // Compare the two sets of tan-angles and take the value closer to zero on each side.
	  var result = new Float32Array(4);
	  result[0] = Math.max(fovLeft, screenLeft);
	  result[1] = Math.min(fovTop, screenTop);
	  result[2] = Math.min(fovRight, screenRight);
	  result[3] = Math.max(fovBottom, screenBottom);
	  return result;
	};
	
	/**
	 * Calculates the tan-angles from the maximum FOV for the left eye for the
	 * current device and screen parameters, assuming no lenses.
	 */
	DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function() {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;
	
	  var result = new Float32Array(4);
	  // Tan-angles from the max FOV.
	  var fovLeft = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
	  var fovTop = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
	  var fovRight = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
	  var fovBottom = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
	  // Viewport size.
	  var halfWidth = device.widthMeters / 4;
	  var halfHeight = device.heightMeters / 2;
	  // Viewport center, measured from left lens position.
	  var verticalLensOffset = (viewer.baselineLensDistance - device.bevelMeters - halfHeight);
	  var centerX = viewer.interLensDistance / 2 - halfWidth;
	  var centerY = -verticalLensOffset;
	  var centerZ = viewer.screenLensDistance;
	  // Tan-angles of the viewport edges, as seen through the lens.
	  var screenLeft = (centerX - halfWidth) / centerZ;
	  var screenTop = (centerY + halfHeight) / centerZ;
	  var screenRight = (centerX + halfWidth) / centerZ;
	  var screenBottom = (centerY - halfHeight) / centerZ;
	  // Compare the two sets of tan-angles and take the value closer to zero on each side.
	  result[0] = Math.max(fovLeft, screenLeft);
	  result[1] = Math.min(fovTop, screenTop);
	  result[2] = Math.min(fovRight, screenRight);
	  result[3] = Math.max(fovBottom, screenBottom);
	  return result;
	};
	
	/**
	 * Calculates the screen rectangle visible from the left eye for the
	 * current device and screen parameters.
	 */
	DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function(undistortedFrustum) {
	  var viewer = this.viewer;
	  var device = this.device;
	
	  var dist = viewer.screenLensDistance;
	  var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
	  var eyeY = viewer.baselineLensDistance - device.bevelMeters;
	  var left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters;
	  var top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters;
	  var right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters;
	  var bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
	  return {
	    x: left,
	    y: bottom,
	    width: right - left,
	    height: top - bottom
	  };
	};
	
	DeviceInfo.prototype.getFieldOfViewLeftEye = function(opt_isUndistorted) {
	  return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() :
	      this.getDistortedFieldOfViewLeftEye();
	};
	
	DeviceInfo.prototype.getFieldOfViewRightEye = function(opt_isUndistorted) {
	  var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
	  return {
	    leftDegrees: fov.rightDegrees,
	    rightDegrees: fov.leftDegrees,
	    upDegrees: fov.upDegrees,
	    downDegrees: fov.downDegrees
	  };
	};
	
	/**
	 * Calculates undistorted field of view for the left eye.
	 */
	DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function() {
	  var p = this.getUndistortedParams_();
	
	  return {
	    leftDegrees: MathUtil.radToDeg * Math.atan(p.outerDist),
	    rightDegrees: MathUtil.radToDeg * Math.atan(p.innerDist),
	    downDegrees: MathUtil.radToDeg * Math.atan(p.bottomDist),
	    upDegrees: MathUtil.radToDeg * Math.atan(p.topDist)
	  };
	};
	
	DeviceInfo.prototype.getUndistortedViewportLeftEye = function() {
	  var p = this.getUndistortedParams_();
	  var viewer = this.viewer;
	  var device = this.device;
	
	  // Distances stored in local variables are in tan-angle units unless otherwise
	  // noted.
	  var eyeToScreenDistance = viewer.screenLensDistance;
	  var screenWidth = device.widthMeters / eyeToScreenDistance;
	  var screenHeight = device.heightMeters / eyeToScreenDistance;
	  var xPxPerTanAngle = device.width / screenWidth;
	  var yPxPerTanAngle = device.height / screenHeight;
	
	  var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
	  var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
	  return {
	    x: x,
	    y: y,
	    width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
	    height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
	  };
	};
	
	DeviceInfo.prototype.getUndistortedParams_ = function() {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;
	
	  // Most of these variables in tan-angle units.
	  var eyeToScreenDistance = viewer.screenLensDistance;
	  var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
	  var screenWidth = device.widthMeters / eyeToScreenDistance;
	  var screenHeight = device.heightMeters / eyeToScreenDistance;
	
	  var eyePosX = screenWidth / 2 - halfLensDistance;
	  var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;
	
	  var maxFov = viewer.fov;
	  var viewerMax = distortion.distortInverse(Math.tan(MathUtil.degToRad * maxFov));
	  var outerDist = Math.min(eyePosX, viewerMax);
	  var innerDist = Math.min(halfLensDistance, viewerMax);
	  var bottomDist = Math.min(eyePosY, viewerMax);
	  var topDist = Math.min(screenHeight - eyePosY, viewerMax);
	
	  return {
	    outerDist: outerDist,
	    innerDist: innerDist,
	    topDist: topDist,
	    bottomDist: bottomDist,
	    eyePosX: eyePosX,
	    eyePosY: eyePosY
	  };
	};
	
	
	function CardboardViewer(params) {
	  // A machine readable ID.
	  this.id = params.id;
	  // A human readable label.
	  this.label = params.label;
	
	  // Field of view in degrees (per side).
	  this.fov = params.fov;
	
	  // Distance between lens centers in meters.
	  this.interLensDistance = params.interLensDistance;
	  // Distance between viewer baseline and lens center in meters.
	  this.baselineLensDistance = params.baselineLensDistance;
	  // Screen-to-lens distance in meters.
	  this.screenLensDistance = params.screenLensDistance;
	
	  // Distortion coefficients.
	  this.distortionCoefficients = params.distortionCoefficients;
	  // Inverse distortion coefficients.
	  // TODO: Calculate these from distortionCoefficients in the future.
	  this.inverseCoefficients = params.inverseCoefficients;
	}
	
	// Export viewer information.
	DeviceInfo.Viewers = Viewers;
	module.exports = DeviceInfo;
	
	},{"./distortion/distortion.js":9,"./math-util.js":14,"./util.js":22}],8:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var VRDisplay = _dereq_('./base.js').VRDisplay;
	var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;
	var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;
	
	/**
	 * Wraps a VRDisplay and exposes it as a HMDVRDevice
	 */
	function VRDisplayHMDDevice(display) {
	  this.display = display;
	
	  this.hardwareUnitId = display.displayId;
	  this.deviceId = 'webvr-polyfill:HMD:' + display.displayId;
	  this.deviceName = display.displayName + ' (HMD)';
	}
	VRDisplayHMDDevice.prototype = new HMDVRDevice();
	
	VRDisplayHMDDevice.prototype.getEyeParameters = function(whichEye) {
	  var eyeParameters = this.display.getEyeParameters(whichEye);
	
	  return {
	    currentFieldOfView: eyeParameters.fieldOfView,
	    maximumFieldOfView: eyeParameters.fieldOfView,
	    minimumFieldOfView: eyeParameters.fieldOfView,
	    recommendedFieldOfView: eyeParameters.fieldOfView,
	    eyeTranslation: { x: eyeParameters.offset[0], y: eyeParameters.offset[1], z: eyeParameters.offset[2] },
	    renderRect: {
	      x: (whichEye == 'right') ? eyeParameters.renderWidth : 0,
	      y: 0,
	      width: eyeParameters.renderWidth,
	      height: eyeParameters.renderHeight
	    }
	  };
	};
	
	VRDisplayHMDDevice.prototype.setFieldOfView =
	    function(opt_fovLeft, opt_fovRight, opt_zNear, opt_zFar) {
	  // Not supported. getEyeParameters reports that the min, max, and recommended
	  // FoV is all the same, so no adjustment can be made.
	};
	
	// TODO: Need to hook requestFullscreen to see if a wrapped VRDisplay was passed
	// in as an option. If so we should prevent the default fullscreen behavior and
	// call VRDisplay.requestPresent instead.
	
	/**
	 * Wraps a VRDisplay and exposes it as a PositionSensorVRDevice
	 */
	function VRDisplayPositionSensorDevice(display) {
	  this.display = display;
	
	  this.hardwareUnitId = display.displayId;
	  this.deviceId = 'webvr-polyfill:PositionSensor: ' + display.displayId;
	  this.deviceName = display.displayName + ' (PositionSensor)';
	}
	VRDisplayPositionSensorDevice.prototype = new PositionSensorVRDevice();
	
	VRDisplayPositionSensorDevice.prototype.getState = function() {
	  var pose = this.display.getPose();
	  return {
	    position: pose.position ? { x: pose.position[0], y: pose.position[1], z: pose.position[2] } : null,
	    orientation: pose.orientation ? { x: pose.orientation[0], y: pose.orientation[1], z: pose.orientation[2], w: pose.orientation[3] } : null,
	    linearVelocity: null,
	    linearAcceleration: null,
	    angularVelocity: null,
	    angularAcceleration: null
	  };
	};
	
	VRDisplayPositionSensorDevice.prototype.resetState = function() {
	  return this.positionDevice.resetPose();
	};
	
	
	module.exports.VRDisplayHMDDevice = VRDisplayHMDDevice;
	module.exports.VRDisplayPositionSensorDevice = VRDisplayPositionSensorDevice;
	
	
	},{"./base.js":2}],9:[function(_dereq_,module,exports){
	/**
	 * TODO(smus): Implement coefficient inversion.
	 */
	function Distortion(coefficients) {
	  this.coefficients = coefficients;
	}
	
	/**
	 * Calculates the inverse distortion for a radius.
	 * </p><p>
	 * Allows to compute the original undistorted radius from a distorted one.
	 * See also getApproximateInverseDistortion() for a faster but potentially
	 * less accurate method.
	 *
	 * @param {Number} radius Distorted radius from the lens center in tan-angle units.
	 * @return {Number} The undistorted radius in tan-angle units.
	 */
	Distortion.prototype.distortInverse = function(radius) {
	  // Secant method.
	  var r0 = 0;
	  var r1 = 1;
	  var dr0 = radius - this.distort(r0);
	  while (Math.abs(r1 - r0) > 0.0001 /** 0.1mm */) {
	    var dr1 = radius - this.distort(r1);
	    var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
	    r0 = r1;
	    r1 = r2;
	    dr0 = dr1;
	  }
	  return r1;
	};
	
	/**
	 * Distorts a radius by its distortion factor from the center of the lenses.
	 *
	 * @param {Number} radius Radius from the lens center in tan-angle units.
	 * @return {Number} The distorted radius in tan-angle units.
	 */
	Distortion.prototype.distort = function(radius) {
	  var r2 = radius * radius;
	  var ret = 0;
	  for (var i = 0; i < this.coefficients.length; i++) {
	    ret = r2 * (ret + this.coefficients[i]);
	  }
	  return (ret + 1) * radius;
	};
	
	// Functions below roughly ported from
	// https://github.com/googlesamples/cardboard-unity/blob/master/Cardboard/Scripts/CardboardProfile.cs#L412
	
	// Solves a small linear equation via destructive gaussian
	// elimination and back substitution.  This isn't generic numeric
	// code, it's just a quick hack to work with the generally
	// well-behaved symmetric matrices for least-squares fitting.
	// Not intended for reuse.
	//
	// @param a Input positive definite symmetrical matrix. Destroyed
	//     during calculation.
	// @param y Input right-hand-side values. Destroyed during calculation.
	// @return Resulting x value vector.
	//
	Distortion.prototype.solveLinear_ = function(a, y) {
	  var n = a.length;
	
	  // Gaussian elimination (no row exchange) to triangular matrix.
	  // The input matrix is a A^T A product which should be a positive
	  // definite symmetrical matrix, and if I remember my linear
	  // algebra right this implies that the pivots will be nonzero and
	  // calculations sufficiently accurate without needing row
	  // exchange.
	  for (var j = 0; j < n - 1; ++j) {
	    for (var k = j + 1; k < n; ++k) {
	      var p = a[j][k] / a[j][j];
	      for (var i = j + 1; i < n; ++i) {
	        a[i][k] -= p * a[i][j];
	      }
	      y[k] -= p * y[j];
	    }
	  }
	  // From this point on, only the matrix elements a[j][i] with i>=j are
	  // valid. The elimination doesn't fill in eliminated 0 values.
	
	  var x = new Array(n);
	
	  // Back substitution.
	  for (var j = n - 1; j >= 0; --j) {
	    var v = y[j];
	    for (var i = j + 1; i < n; ++i) {
	      v -= a[i][j] * x[i];
	    }
	    x[j] = v / a[j][j];
	  }
	
	  return x;
	};
	
	// Solves a least-squares matrix equation.  Given the equation A * x = y, calculate the
	// least-square fit x = inverse(A * transpose(A)) * transpose(A) * y.  The way this works
	// is that, while A is typically not a square matrix (and hence not invertible), A * transpose(A)
	// is always square.  That is:
	//   A * x = y
	//   transpose(A) * (A * x) = transpose(A) * y   <- multiply both sides by transpose(A)
	//   (transpose(A) * A) * x = transpose(A) * y   <- associativity
	//   x = inverse(transpose(A) * A) * transpose(A) * y  <- solve for x
	// Matrix A's row count (first index) must match y's value count.  A's column count (second index)
	// determines the length of the result vector x.
	Distortion.prototype.solveLeastSquares_ = function(matA, vecY) {
	  var i, j, k, sum;
	  var numSamples = matA.length;
	  var numCoefficients = matA[0].length;
	  if (numSamples != vecY.Length) {
	    throw new Error("Matrix / vector dimension mismatch");
	  }
	
	  // Calculate transpose(A) * A
	  var matATA = new Array(numCoefficients);
	  for (k = 0; k < numCoefficients; ++k) {
	    matATA[k] = new Array(numCoefficients);
	    for (j = 0; j < numCoefficients; ++j) {
	      sum = 0;
	      for (i = 0; i < numSamples; ++i) {
	        sum += matA[j][i] * matA[k][i];
	      }
	      matATA[k][j] = sum;
	    }
	  }
	
	  // Calculate transpose(A) * y
	  var vecATY = new Array(numCoefficients);
	  for (j = 0; j < numCoefficients; ++j) {
	    sum = 0;
	    for (i = 0; i < numSamples; ++i) {
	      sum += matA[j][i] * vecY[i];
	    }
	    vecATY[j] = sum;
	  }
	
	  // Now solve (A * transpose(A)) * x = transpose(A) * y.
	  return this.solveLinear_(matATA, vecATY);
	};
	
	/// Calculates an approximate inverse to the given radial distortion parameters.
	Distortion.prototype.approximateInverse = function(maxRadius, numSamples) {
	  maxRadius = maxRadius || 1;
	  numSamples = numSamples || 100;
	  var numCoefficients = 6;
	  var i, j;
	
	  // R + K1*R^3 + K2*R^5 = r, with R = rp = distort(r)
	  // Repeating for numSamples:
	  //   [ R0^3, R0^5 ] * [ K1 ] = [ r0 - R0 ]
	  //   [ R1^3, R1^5 ]   [ K2 ]   [ r1 - R1 ]
	  //   [ R2^3, R2^5 ]            [ r2 - R2 ]
	  //   [ etc... ]                [ etc... ]
	  // That is:
	  //   matA * [K1, K2] = y
	  // Solve:
	  //   [K1, K2] = inverse(transpose(matA) * matA) * transpose(matA) * y
	  var matA = new Array(numCoefficients);
	  for (j = 0; j < numCoefficients; ++j) {
	    matA[j] = new Array(numSamples);
	  }
	  var vecY = new Array(numSamples);
	
	  for (i = 0; i < numSamples; ++i) {
	    var r = maxRadius * (i + 1) / numSamples;
	    var rp = this.distort(r);
	    var v = rp;
	    for (j = 0; j < numCoefficients; ++j) {
	      v *= rp * rp;
	      matA[j][i] = v;
	    }
	    vecY[i] = r - rp;
	  }
	
	  var inverseCoefficients = this.solveLeastSquares_(matA, vecY);
	
	  return new Distortion(inverseCoefficients);
	};
	
	module.exports = Distortion;
	
	},{}],10:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * DPDB cache.
	 */
	var DPDB_CACHE = {
	  "format": 1,
	  "last_updated": "2016-01-20T00:18:35Z",
	  "devices": [
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "asus/*/Nexus 7/*" },
	      { "ua": "Nexus 7" }
	    ],
	    "dpi": [ 320.8, 323.0 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "asus/*/ASUS_Z00AD/*" },
	      { "ua": "ASUS_Z00AD" }
	    ],
	    "dpi": [ 403.0, 404.6 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC6435LVW/*" },
	      { "ua": "HTC6435LVW" }
	    ],
	    "dpi": [ 449.7, 443.3 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC One XL/*" },
	      { "ua": "HTC One XL" }
	    ],
	    "dpi": [ 315.3, 314.6 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "htc/*/Nexus 9/*" },
	      { "ua": "Nexus 9" }
	    ],
	    "dpi": 289.0,
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC One M9/*" },
	      { "ua": "HTC One M9" }
	    ],
	    "dpi": [ 442.5, 443.3 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC One_M8/*" },
	      { "ua": "HTC One_M8" }
	    ],
	    "dpi": [ 449.7, 447.4 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "HTC/*/HTC One/*" },
	      { "ua": "HTC One" }
	    ],
	    "dpi": 472.8,
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Huawei/*/Nexus 6P/*" },
	      { "ua": "Nexus 6P" }
	    ],
	    "dpi": [ 515.1, 518.0 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/Nexus 5X/*" },
	      { "ua": "Nexus 5X" }
	    ],
	    "dpi": [ 422.0, 419.9 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LGMS345/*" },
	      { "ua": "LGMS345" }
	    ],
	    "dpi": [ 221.7, 219.1 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LG-D800/*" },
	      { "ua": "LG-D800" }
	    ],
	    "dpi": [ 422.0, 424.1 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LG-D850/*" },
	      { "ua": "LG-D850" }
	    ],
	    "dpi": [ 537.9, 541.9 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/VS985 4G/*" },
	      { "ua": "VS985 4G" }
	    ],
	    "dpi": [ 537.9, 535.6 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/Nexus 5/*" },
	      { "ua": "Nexus 5 " }
	    ],
	    "dpi": [ 442.4, 444.8 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/Nexus 4/*" },
	      { "ua": "Nexus 4" }
	    ],
	    "dpi": [ 319.8, 318.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LG-P769/*" },
	      { "ua": "LG-P769" }
	    ],
	    "dpi": [ 240.6, 247.5 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LGMS323/*" },
	      { "ua": "LGMS323" }
	    ],
	    "dpi": [ 206.6, 204.6 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "LGE/*/LGLS996/*" },
	      { "ua": "LGLS996" }
	    ],
	    "dpi": [ 403.4, 401.5 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Micromax/*/4560MMX/*" },
	      { "ua": "4560MMX" }
	    ],
	    "dpi": [ 240.0, 219.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Micromax/*/A250/*" },
	      { "ua": "Micromax A250" }
	    ],
	    "dpi": [ 480.0, 446.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Micromax/*/Micromax AQ4501/*" },
	      { "ua": "Micromax AQ4501" }
	    ],
	    "dpi": 240.0,
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/DROID RAZR/*" },
	      { "ua": "DROID RAZR" }
	    ],
	    "dpi": [ 368.1, 256.7 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT830C/*" },
	      { "ua": "XT830C" }
	    ],
	    "dpi": [ 254.0, 255.9 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1021/*" },
	      { "ua": "XT1021" }
	    ],
	    "dpi": [ 254.0, 256.7 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1023/*" },
	      { "ua": "XT1023" }
	    ],
	    "dpi": [ 254.0, 256.7 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1028/*" },
	      { "ua": "XT1028" }
	    ],
	    "dpi": [ 326.6, 327.6 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1034/*" },
	      { "ua": "XT1034" }
	    ],
	    "dpi": [ 326.6, 328.4 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1053/*" },
	      { "ua": "XT1053" }
	    ],
	    "dpi": [ 315.3, 316.1 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1562/*" },
	      { "ua": "XT1562" }
	    ],
	    "dpi": [ 403.4, 402.7 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/Nexus 6/*" },
	      { "ua": "Nexus 6 " }
	    ],
	    "dpi": [ 494.3, 489.7 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1063/*" },
	      { "ua": "XT1063" }
	    ],
	    "dpi": [ 295.0, 296.6 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1064/*" },
	      { "ua": "XT1064" }
	    ],
	    "dpi": [ 295.0, 295.6 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1092/*" },
	      { "ua": "XT1092" }
	    ],
	    "dpi": [ 422.0, 424.1 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "motorola/*/XT1095/*" },
	      { "ua": "XT1095" }
	    ],
	    "dpi": [ 422.0, 423.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "OnePlus/*/A0001/*" },
	      { "ua": "A0001" }
	    ],
	    "dpi": [ 403.4, 401.0 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "OnePlus/*/ONE E1005/*" },
	      { "ua": "ONE E1005" }
	    ],
	    "dpi": [ 442.4, 441.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "OnePlus/*/ONE A2005/*" },
	      { "ua": "ONE A2005" }
	    ],
	    "dpi": [ 391.9, 405.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "OPPO/*/X909/*" },
	      { "ua": "X909" }
	    ],
	    "dpi": [ 442.4, 444.1 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9082/*" },
	      { "ua": "GT-I9082" }
	    ],
	    "dpi": [ 184.7, 185.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G360P/*" },
	      { "ua": "SM-G360P" }
	    ],
	    "dpi": [ 196.7, 205.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/Nexus S/*" },
	      { "ua": "Nexus S" }
	    ],
	    "dpi": [ 234.5, 229.8 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9300/*" },
	      { "ua": "GT-I9300" }
	    ],
	    "dpi": [ 304.8, 303.9 ],
	    "bw": 5,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-T230NU/*" },
	      { "ua": "SM-T230NU" }
	    ],
	    "dpi": 216.0,
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SGH-T399/*" },
	      { "ua": "SGH-T399" }
	    ],
	    "dpi": [ 217.7, 231.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-N9005/*" },
	      { "ua": "SM-N9005" }
	    ],
	    "dpi": [ 386.4, 387.0 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SAMSUNG-SM-N900A/*" },
	      { "ua": "SAMSUNG-SM-N900A" }
	    ],
	    "dpi": [ 386.4, 387.7 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9500/*" },
	      { "ua": "GT-I9500" }
	    ],
	    "dpi": [ 442.5, 443.3 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9505/*" },
	      { "ua": "GT-I9505" }
	    ],
	    "dpi": 439.4,
	    "bw": 4,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G900F/*" },
	      { "ua": "SM-G900F" }
	    ],
	    "dpi": [ 415.6, 431.6 ],
	    "bw": 5,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G900M/*" },
	      { "ua": "SM-G900M" }
	    ],
	    "dpi": [ 415.6, 431.6 ],
	    "bw": 5,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G800F/*" },
	      { "ua": "SM-G800F" }
	    ],
	    "dpi": 326.8,
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G906S/*" },
	      { "ua": "SM-G906S" }
	    ],
	    "dpi": [ 562.7, 572.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9300/*" },
	      { "ua": "GT-I9300" }
	    ],
	    "dpi": [ 306.7, 304.8 ],
	    "bw": 5,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-T535/*" },
	      { "ua": "SM-T535" }
	    ],
	    "dpi": [ 142.6, 136.4 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-N920C/*" },
	      { "ua": "SM-N920C" }
	    ],
	    "dpi": [ 515.1, 518.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9300I/*" },
	      { "ua": "GT-I9300I" }
	    ],
	    "dpi": [ 304.8, 305.8 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-I9195/*" },
	      { "ua": "GT-I9195" }
	    ],
	    "dpi": [ 249.4, 256.7 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SPH-L520/*" },
	      { "ua": "SPH-L520" }
	    ],
	    "dpi": [ 249.4, 255.9 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SAMSUNG-SGH-I717/*" },
	      { "ua": "SAMSUNG-SGH-I717" }
	    ],
	    "dpi": 285.8,
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SPH-D710/*" },
	      { "ua": "SPH-D710" }
	    ],
	    "dpi": [ 217.7, 204.2 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/GT-N7100/*" },
	      { "ua": "GT-N7100" }
	    ],
	    "dpi": 265.1,
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SCH-I605/*" },
	      { "ua": "SCH-I605" }
	    ],
	    "dpi": 265.1,
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/Galaxy Nexus/*" },
	      { "ua": "Galaxy Nexus" }
	    ],
	    "dpi": [ 315.3, 314.2 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-N910H/*" },
	      { "ua": "SM-N910H" }
	    ],
	    "dpi": [ 515.1, 518.0 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-N910C/*" },
	      { "ua": "SM-N910C" }
	    ],
	    "dpi": [ 515.2, 520.2 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G130M/*" },
	      { "ua": "SM-G130M" }
	    ],
	    "dpi": [ 165.9, 164.8 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G928I/*" },
	      { "ua": "SM-G928I" }
	    ],
	    "dpi": [ 515.1, 518.4 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G920F/*" },
	      { "ua": "SM-G920F" }
	    ],
	    "dpi": 580.6,
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G920P/*" },
	      { "ua": "SM-G920P" }
	    ],
	    "dpi": [ 522.5, 577.0 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G925F/*" },
	      { "ua": "SM-G925F" }
	    ],
	    "dpi": 580.6,
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "samsung/*/SM-G925V/*" },
	      { "ua": "SM-G925V" }
	    ],
	    "dpi": [ 522.5, 576.6 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/C6903/*" },
	      { "ua": "C6903" }
	    ],
	    "dpi": [ 442.5, 443.3 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/D6653/*" },
	      { "ua": "D6653" }
	    ],
	    "dpi": [ 428.6, 427.6 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/E6653/*" },
	      { "ua": "E6653" }
	    ],
	    "dpi": [ 428.6, 425.7 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/E6853/*" },
	      { "ua": "E6853" }
	    ],
	    "dpi": [ 403.4, 401.9 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "Sony/*/SGP321/*" },
	      { "ua": "SGP321" }
	    ],
	    "dpi": [ 224.7, 224.1 ],
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "TCT/*/ALCATEL ONE TOUCH Fierce/*" },
	      { "ua": "ALCATEL ONE TOUCH Fierce" }
	    ],
	    "dpi": [ 240.0, 247.5 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "THL/*/thl 5000/*" },
	      { "ua": "thl 5000" }
	    ],
	    "dpi": [ 480.0, 443.3 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "android",
	    "rules": [
	      { "mdmh": "ZTE/*/ZTE Blade L2/*" },
	      { "ua": "ZTE Blade L2" }
	    ],
	    "dpi": 240.0,
	    "bw": 3,
	    "ac": 500
	  },
	
	  {
	    "type": "ios",
	    "rules": [ { "res": [ 640, 960 ] } ],
	    "dpi": [ 325.1, 328.4 ],
	    "bw": 4,
	    "ac": 1000
	  },
	
	  {
	    "type": "ios",
	    "rules": [ { "res": [ 640, 960 ] } ],
	    "dpi": [ 325.1, 328.4 ],
	    "bw": 4,
	    "ac": 1000
	  },
	
	  {
	    "type": "ios",
	    "rules": [ { "res": [ 640, 1136 ] } ],
	    "dpi": [ 317.1, 320.2 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "ios",
	    "rules": [ { "res": [ 640, 1136 ] } ],
	    "dpi": [ 317.1, 320.2 ],
	    "bw": 3,
	    "ac": 1000
	  },
	
	  {
	    "type": "ios",
	    "rules": [ { "res": [ 750, 1334 ] } ],
	    "dpi": 326.4,
	    "bw": 4,
	    "ac": 1000
	  },
	
	  {
	    "type": "ios",
	    "rules": [ { "res": [ 750, 1334 ] } ],
	    "dpi": 326.4,
	    "bw": 4,
	    "ac": 1000
	  },
	
	  {
	    "type": "ios",
	    "rules": [ { "res": [ 1242, 2208 ] } ],
	    "dpi": [ 453.6, 458.4 ],
	    "bw": 4,
	    "ac": 1000
	  },
	
	  {
	    "type": "ios",
	    "rules": [ { "res": [ 1242, 2208 ] } ],
	    "dpi": [ 453.6, 458.4 ],
	    "bw": 4,
	    "ac": 1000
	  }
	]};
	
	module.exports = DPDB_CACHE;
	
	},{}],11:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	// Offline cache of the DPDB, to be used until we load the online one (and
	// as a fallback in case we can't load the online one).
	var DPDB_CACHE = _dereq_('./dpdb-cache.js');
	var Util = _dereq_('../util.js');
	
	// Online DPDB URL.
	var ONLINE_DPDB_URL = 'https://storage.googleapis.com/cardboard-dpdb/dpdb.json';
	
	/**
	 * Calculates device parameters based on the DPDB (Device Parameter Database).
	 * Initially, uses the cached DPDB values.
	 *
	 * If fetchOnline == true, then this object tries to fetch the online version
	 * of the DPDB and updates the device info if a better match is found.
	 * Calls the onDeviceParamsUpdated callback when there is an update to the
	 * device information.
	 */
	function Dpdb(fetchOnline, onDeviceParamsUpdated) {
	  // Start with the offline DPDB cache while we are loading the real one.
	  this.dpdb = DPDB_CACHE;
	
	  // Calculate device params based on the offline version of the DPDB.
	  this.recalculateDeviceParams_();
	
	  // XHR to fetch online DPDB file, if requested.
	  if (fetchOnline) {
	    // Set the callback.
	    this.onDeviceParamsUpdated = onDeviceParamsUpdated;
	
	    console.log('Fetching DPDB...');
	    var xhr = new XMLHttpRequest();
	    var obj = this;
	    xhr.open('GET', ONLINE_DPDB_URL, true);
	    xhr.addEventListener('load', function() {
	      obj.loading = false;
	      if (xhr.status >= 200 && xhr.status <= 299) {
	        // Success.
	        console.log('Successfully loaded online DPDB.');
	        obj.dpdb = JSON.parse(xhr.response);
	        obj.recalculateDeviceParams_();
	      } else {
	        // Error loading the DPDB.
	        console.error('Error loading online DPDB!');
	      }
	    });
	    xhr.send();
	  }
	}
	
	// Returns the current device parameters.
	Dpdb.prototype.getDeviceParams = function() {
	  return this.deviceParams;
	};
	
	// Recalculates this device's parameters based on the DPDB.
	Dpdb.prototype.recalculateDeviceParams_ = function() {
	  console.log('Recalculating device params.');
	  var newDeviceParams = this.calcDeviceParams_();
	  console.log('New device parameters:');
	  console.log(newDeviceParams);
	  if (newDeviceParams) {
	    this.deviceParams = newDeviceParams;
	    // Invoke callback, if it is set.
	    if (this.onDeviceParamsUpdated) {
	      this.onDeviceParamsUpdated(this.deviceParams);
	    }
	  } else {
	    console.error('Failed to recalculate device parameters.');
	  }
	};
	
	// Returns a DeviceParams object that represents the best guess as to this
	// device's parameters. Can return null if the device does not match any
	// known devices.
	Dpdb.prototype.calcDeviceParams_ = function() {
	  var db = this.dpdb; // shorthand
	  if (!db) {
	    console.error('DPDB not available.');
	    return null;
	  }
	  if (db.format != 1) {
	    console.error('DPDB has unexpected format version.');
	    return null;
	  }
	  if (!db.devices || !db.devices.length) {
	    console.error('DPDB does not have a devices section.');
	    return null;
	  }
	
	  // Get the actual user agent and screen dimensions in pixels.
	  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
	  var width = Util.getScreenWidth();
	  var height = Util.getScreenHeight();
	  console.log('User agent: ' + userAgent);
	  console.log('Pixel width: ' + width);
	  console.log('Pixel height: ' + height);
	
	  if (!db.devices) {
	    console.error('DPDB has no devices section.');
	    return null;
	  }
	
	  for (var i = 0; i < db.devices.length; i++) {
	    var device = db.devices[i];
	    if (!device.rules) {
	      console.warn('Device[' + i + '] has no rules section.');
	      continue;
	    }
	
	    if (device.type != 'ios' && device.type != 'android') {
	      console.warn('Device[' + i + '] has invalid type.');
	      continue;
	    }
	
	    // See if this device is of the appropriate type.
	    if (Util.isIOS() != (device.type == 'ios')) continue;
	
	    // See if this device matches any of the rules:
	    var matched = false;
	    for (var j = 0; j < device.rules.length; j++) {
	      var rule = device.rules[j];
	      if (this.matchRule_(rule, userAgent, width, height)) {
	        console.log('Rule matched:');
	        console.log(rule);
	        matched = true;
	        break;
	      }
	    }
	    if (!matched) continue;
	
	    // device.dpi might be an array of [ xdpi, ydpi] or just a scalar.
	    var xdpi = device.dpi[0] || device.dpi;
	    var ydpi = device.dpi[1] || device.dpi;
	
	    return new DeviceParams({ xdpi: xdpi, ydpi: ydpi, bevelMm: device.bw });
	  }
	
	  console.warn('No DPDB device match.');
	  return null;
	};
	
	Dpdb.prototype.matchRule_ = function(rule, ua, screenWidth, screenHeight) {
	  // We can only match 'ua' and 'res' rules, not other types like 'mdmh'
	  // (which are meant for native platforms).
	  if (!rule.ua && !rule.res) return false;
	
	  // If our user agent string doesn't contain the indicated user agent string,
	  // the match fails.
	  if (rule.ua && ua.indexOf(rule.ua) < 0) return false;
	
	  // If the rule specifies screen dimensions that don't correspond to ours,
	  // the match fails.
	  if (rule.res) {
	    if (!rule.res[0] || !rule.res[1]) return false;
	    var resX = rule.res[0];
	    var resY = rule.res[1];
	    // Compare min and max so as to make the order not matter, i.e., it should
	    // be true that 640x480 == 480x640.
	    if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) ||
	        (Math.max(screenWidth, screenHeight) != Math.max(resX, resY))) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	function DeviceParams(params) {
	  this.xdpi = params.xdpi;
	  this.ydpi = params.ydpi;
	  this.bevelMm = params.bevelMm;
	}
	
	module.exports = Dpdb;
	},{"../util.js":22,"./dpdb-cache.js":10}],12:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	function Emitter() {
	  this.callbacks = {};
	}
	
	Emitter.prototype.emit = function(eventName) {
	  var callbacks = this.callbacks[eventName];
	  if (!callbacks) {
	    //console.log('No valid callback specified.');
	    return;
	  }
	  var args = [].slice.call(arguments);
	  // Eliminate the first param (the callback).
	  args.shift();
	  for (var i = 0; i < callbacks.length; i++) {
	    callbacks[i].apply(this, args);
	  }
	};
	
	Emitter.prototype.on = function(eventName, callback) {
	  if (eventName in this.callbacks) {
	    this.callbacks[eventName].push(callback);
	  } else {
	    this.callbacks[eventName] = [callback];
	  }
	};
	
	module.exports = Emitter;
	
	},{}],13:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var Util = _dereq_('./util.js');
	var WebVRPolyfill = _dereq_('./webvr-polyfill.js').WebVRPolyfill;
	
	// Initialize a WebVRConfig just in case.
	window.WebVRConfig = Util.extend({
	  // Forces availability of VR mode, even for non-mobile devices.
	  FORCE_ENABLE_VR: false,
	
	  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
	  K_FILTER: 0.98,
	
	  // How far into the future to predict during fast motion (in seconds).
	  PREDICTION_TIME_S: 0.040,
	
	  // Flag to enable touch panner. In case you have your own touch controls.
	  TOUCH_PANNER_DISABLED: true,
	
	  // Flag to disabled the UI in VR Mode.
	  CARDBOARD_UI_DISABLED: false, // Default: false
	
	  // Flag to disable the instructions to rotate your device.
	  ROTATE_INSTRUCTIONS_DISABLED: false, // Default: false.
	
	  // Enable yaw panning only, disabling roll and pitch. This can be useful
	  // for panoramas with nothing interesting above or below.
	  YAW_ONLY: false,
	
	  // To disable keyboard and mouse controls, if you want to use your own
	  // implementation.
	  MOUSE_KEYBOARD_CONTROLS_DISABLED: false,
	
	  // Prevent the polyfill from initializing immediately. Requires the app
	  // to call InitializeWebVRPolyfill() before it can be used.
	  DEFER_INITIALIZATION: false,
	
	  // Enable the deprecated version of the API (navigator.getVRDevices).
	  ENABLE_DEPRECATED_API: false,
	
	  // Scales the recommended buffer size reported by WebVR, which can improve
	  // performance.
	  // UPDATE(2016-05-03): Setting this to 0.5 by default since 1.0 does not
	  // perform well on many mobile devices.
	  BUFFER_SCALE: 0.5,
	
	  // Allow VRDisplay.submitFrame to change gl bindings, which is more
	  // efficient if the application code will re-bind its resources on the
	  // next frame anyway. This has been seen to cause rendering glitches with
	  // THREE.js.
	  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
	  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
	  // and gl.TEXTURE_BINDING_2D for texture unit 0.
	  DIRTY_SUBMIT_FRAME_BINDINGS: false
	}, window.WebVRConfig);
	
	if (!window.WebVRConfig.DEFER_INITIALIZATION) {
	  new WebVRPolyfill();
	} else {
	  window.InitializeWebVRPolyfill = function() {
	    new WebVRPolyfill();
	  }
	}
	
	},{"./util.js":22,"./webvr-polyfill.js":25}],14:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var MathUtil = window.MathUtil || {};
	
	MathUtil.degToRad = Math.PI / 180;
	MathUtil.radToDeg = 180 / Math.PI;
	
	// Some minimal math functionality borrowed from THREE.Math and stripped down
	// for the purposes of this library.
	
	
	MathUtil.Vector2 = function ( x, y ) {
	  this.x = x || 0;
	  this.y = y || 0;
	};
	
	MathUtil.Vector2.prototype = {
	  constructor: MathUtil.Vector2,
	
	  set: function ( x, y ) {
	    this.x = x;
	    this.y = y;
	
	    return this;
	  },
	
	  copy: function ( v ) {
	    this.x = v.x;
	    this.y = v.y;
	
	    return this;
	  },
	
	  subVectors: function ( a, b ) {
	    this.x = a.x - b.x;
	    this.y = a.y - b.y;
	
	    return this;
	  },
	};
	
	MathUtil.Vector3 = function ( x, y, z ) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	};
	
	MathUtil.Vector3.prototype = {
	  constructor: MathUtil.Vector3,
	
	  set: function ( x, y, z ) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	
	    return this;
	  },
	
	  copy: function ( v ) {
	    this.x = v.x;
	    this.y = v.y;
	    this.z = v.z;
	
	    return this;
	  },
	
	  length: function () {
	    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	  },
	
	  normalize: function () {
	    var scalar = this.length();
	
	    if ( scalar !== 0 ) {
	      var invScalar = 1 / scalar;
	
	      this.multiplyScalar(invScalar);
	    } else {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	    }
	
	    return this;
	  },
	
	  multiplyScalar: function ( scalar ) {
	    this.x *= scalar;
	    this.y *= scalar;
	    this.z *= scalar;
	  },
	
	  applyQuaternion: function ( q ) {
	    var x = this.x;
	    var y = this.y;
	    var z = this.z;
	
	    var qx = q.x;
	    var qy = q.y;
	    var qz = q.z;
	    var qw = q.w;
	
	    // calculate quat * vector
	    var ix =  qw * x + qy * z - qz * y;
	    var iy =  qw * y + qz * x - qx * z;
	    var iz =  qw * z + qx * y - qy * x;
	    var iw = - qx * x - qy * y - qz * z;
	
	    // calculate result * inverse quat
	    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
	    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
	    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
	    return this;
	  },
	
	  dot: function ( v ) {
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	  },
	
	  crossVectors: function ( a, b ) {
	    var ax = a.x, ay = a.y, az = a.z;
	    var bx = b.x, by = b.y, bz = b.z;
	
	    this.x = ay * bz - az * by;
	    this.y = az * bx - ax * bz;
	    this.z = ax * by - ay * bx;
	
	    return this;
	  },
	};
	
	MathUtil.Quaternion = function ( x, y, z, w ) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	  this.w = ( w !== undefined ) ? w : 1;
	};
	
	MathUtil.Quaternion.prototype = {
	  constructor: MathUtil.Quaternion,
	
	  set: function ( x, y, z, w ) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;
	
	    return this;
	  },
	
	  copy: function ( quaternion ) {
	    this.x = quaternion.x;
	    this.y = quaternion.y;
	    this.z = quaternion.z;
	    this.w = quaternion.w;
	
	    return this;
	  },
	
	  setFromEulerXYZ: function( x, y, z ) {
	    var c1 = Math.cos( x / 2 );
	    var c2 = Math.cos( y / 2 );
	    var c3 = Math.cos( z / 2 );
	    var s1 = Math.sin( x / 2 );
	    var s2 = Math.sin( y / 2 );
	    var s3 = Math.sin( z / 2 );
	
	    this.x = s1 * c2 * c3 + c1 * s2 * s3;
	    this.y = c1 * s2 * c3 - s1 * c2 * s3;
	    this.z = c1 * c2 * s3 + s1 * s2 * c3;
	    this.w = c1 * c2 * c3 - s1 * s2 * s3;
	
	    return this;
	  },
	
	  setFromEulerYXZ: function( x, y, z ) {
	    var c1 = Math.cos( x / 2 );
	    var c2 = Math.cos( y / 2 );
	    var c3 = Math.cos( z / 2 );
	    var s1 = Math.sin( x / 2 );
	    var s2 = Math.sin( y / 2 );
	    var s3 = Math.sin( z / 2 );
	
	    this.x = s1 * c2 * c3 + c1 * s2 * s3;
	    this.y = c1 * s2 * c3 - s1 * c2 * s3;
	    this.z = c1 * c2 * s3 - s1 * s2 * c3;
	    this.w = c1 * c2 * c3 + s1 * s2 * s3;
	
	    return this;
	  },
	
	  setFromAxisAngle: function ( axis, angle ) {
	    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	    // assumes axis is normalized
	
	    var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
	    this.x = axis.x * s;
	    this.y = axis.y * s;
	    this.z = axis.z * s;
	    this.w = Math.cos( halfAngle );
	
	    return this;
	  },
	
	  multiply: function ( q ) {
	    return this.multiplyQuaternions( this, q );
	  },
	
	  multiplyQuaternions: function ( a, b ) {
	    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
	    var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
	    var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
	
	    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
	    return this;
	  },
	
	  inverse: function () {
	    this.x *= -1;
	    this.y *= -1;
	    this.z *= -1;
	
	    this.normalize();
	
	    return this;
	  },
	
	  normalize: function () {
	    var l = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
	    if ( l === 0 ) {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	      this.w = 1;
	    } else {
	      l = 1 / l;
	
	      this.x = this.x * l;
	      this.y = this.y * l;
	      this.z = this.z * l;
	      this.w = this.w * l;
	    }
	
	    return this;
	  },
	
	  slerp: function ( qb, t ) {
	    if ( t === 0 ) return this;
	    if ( t === 1 ) return this.copy( qb );
	
	    var x = this.x, y = this.y, z = this.z, w = this.w;
	
	    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
	    var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
	
	    if ( cosHalfTheta < 0 ) {
	      this.w = - qb.w;
	      this.x = - qb.x;
	      this.y = - qb.y;
	      this.z = - qb.z;
	
	      cosHalfTheta = - cosHalfTheta;
	    } else {
	      this.copy( qb );
	    }
	
	    if ( cosHalfTheta >= 1.0 ) {
	      this.w = w;
	      this.x = x;
	      this.y = y;
	      this.z = z;
	
	      return this;
	    }
	
	    var halfTheta = Math.acos( cosHalfTheta );
	    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
	    if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	      this.w = 0.5 * ( w + this.w );
	      this.x = 0.5 * ( x + this.x );
	      this.y = 0.5 * ( y + this.y );
	      this.z = 0.5 * ( z + this.z );
	
	      return this;
	    }
	
	    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
	    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
	    this.w = ( w * ratioA + this.w * ratioB );
	    this.x = ( x * ratioA + this.x * ratioB );
	    this.y = ( y * ratioA + this.y * ratioB );
	    this.z = ( z * ratioA + this.z * ratioB );
	
	    return this;
	  },
	
	  setFromUnitVectors: function () {
	    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	    // assumes direction vectors vFrom and vTo are normalized
	
	    var v1, r;
	    var EPS = 0.000001;
	
	    return function ( vFrom, vTo ) {
	      if ( v1 === undefined ) v1 = new MathUtil.Vector3();
	
	      r = vFrom.dot( vTo ) + 1;
	
	      if ( r < EPS ) {
	        r = 0;
	
	        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	          v1.set( - vFrom.y, vFrom.x, 0 );
	        } else {
	          v1.set( 0, - vFrom.z, vFrom.y );
	        }
	      } else {
	        v1.crossVectors( vFrom, vTo );
	      }
	
	      this.x = v1.x;
	      this.y = v1.y;
	      this.z = v1.z;
	      this.w = r;
	
	      this.normalize();
	
	      return this;
	    }
	  }(),
	};
	
	module.exports = MathUtil;
	
	},{}],15:[function(_dereq_,module,exports){
	/*
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var VRDisplay = _dereq_('./base.js').VRDisplay;
	var MathUtil = _dereq_('./math-util.js');
	var Util = _dereq_('./util.js');
	
	// How much to rotate per key stroke.
	var KEY_SPEED = 0.15;
	var KEY_ANIMATION_DURATION = 80;
	
	// How much to rotate for mouse events.
	var MOUSE_SPEED_X = 0.5;
	var MOUSE_SPEED_Y = 0.3;
	
	/**
	 * VRDisplay based on mouse and keyboard input. Designed for desktops/laptops
	 * where orientation events aren't supported. Cannot present.
	 */
	function MouseKeyboardVRDisplay() {
	  this.displayName = 'Mouse and Keyboard VRDisplay (webvr-polyfill)';
	
	  this.capabilities.hasOrientation = true;
	
	  // Attach to mouse and keyboard events.
	  window.addEventListener('keydown', this.onKeyDown_.bind(this));
	  window.addEventListener('mousemove', this.onMouseMove_.bind(this));
	  window.addEventListener('mousedown', this.onMouseDown_.bind(this));
	  window.addEventListener('mouseup', this.onMouseUp_.bind(this));
	
	  // "Private" members.
	  this.phi_ = 0;
	  this.theta_ = 0;
	
	  // Variables for keyboard-based rotation animation.
	  this.targetAngle_ = null;
	  this.angleAnimation_ = null;
	
	  // State variables for calculations.
	  this.orientation_ = new MathUtil.Quaternion();
	
	  // Variables for mouse-based rotation.
	  this.rotateStart_ = new MathUtil.Vector2();
	  this.rotateEnd_ = new MathUtil.Vector2();
	  this.rotateDelta_ = new MathUtil.Vector2();
	  this.isDragging_ = false;
	
	  this.orientationOut_ = new Float32Array(4);
	}
	MouseKeyboardVRDisplay.prototype = new VRDisplay();
	
	MouseKeyboardVRDisplay.prototype.getImmediatePose = function() {
	  this.orientation_.setFromEulerYXZ(this.phi_, this.theta_, 0);
	
	  this.orientationOut_[0] = this.orientation_.x;
	  this.orientationOut_[1] = this.orientation_.y;
	  this.orientationOut_[2] = this.orientation_.z;
	  this.orientationOut_[3] = this.orientation_.w;
	
	  return {
	    position: null,
	    orientation: this.orientationOut_,
	    linearVelocity: null,
	    linearAcceleration: null,
	    angularVelocity: null,
	    angularAcceleration: null
	  };
	};
	
	MouseKeyboardVRDisplay.prototype.onKeyDown_ = function(e) {
	  // Track WASD and arrow keys.
	  if (e.keyCode == 38) { // Up key.
	    this.animatePhi_(this.phi_ + KEY_SPEED);
	  } else if (e.keyCode == 39) { // Right key.
	    this.animateTheta_(this.theta_ - KEY_SPEED);
	  } else if (e.keyCode == 40) { // Down key.
	    this.animatePhi_(this.phi_ - KEY_SPEED);
	  } else if (e.keyCode == 37) { // Left key.
	    this.animateTheta_(this.theta_ + KEY_SPEED);
	  }
	};
	
	MouseKeyboardVRDisplay.prototype.animateTheta_ = function(targetAngle) {
	  this.animateKeyTransitions_('theta_', targetAngle);
	};
	
	MouseKeyboardVRDisplay.prototype.animatePhi_ = function(targetAngle) {
	  // Prevent looking too far up or down.
	  targetAngle = Util.clamp(targetAngle, -Math.PI/2, Math.PI/2);
	  this.animateKeyTransitions_('phi_', targetAngle);
	};
	
	/**
	 * Start an animation to transition an angle from one value to another.
	 */
	MouseKeyboardVRDisplay.prototype.animateKeyTransitions_ = function(angleName, targetAngle) {
	  // If an animation is currently running, cancel it.
	  if (this.angleAnimation_) {
	    cancelAnimationFrame(this.angleAnimation_);
	  }
	  var startAngle = this[angleName];
	  var startTime = new Date();
	  // Set up an interval timer to perform the animation.
	  this.angleAnimation_ = requestAnimationFrame(function animate() {
	    // Once we're finished the animation, we're done.
	    var elapsed = new Date() - startTime;
	    if (elapsed >= KEY_ANIMATION_DURATION) {
	      this[angleName] = targetAngle;
	      cancelAnimationFrame(this.angleAnimation_);
	      return;
	    }
	    // loop with requestAnimationFrame
	    this.angleAnimation_ = requestAnimationFrame(animate.bind(this))
	    // Linearly interpolate the angle some amount.
	    var percent = elapsed / KEY_ANIMATION_DURATION;
	    this[angleName] = startAngle + (targetAngle - startAngle) * percent;
	  }.bind(this));
	};
	
	MouseKeyboardVRDisplay.prototype.onMouseDown_ = function(e) {
	  this.rotateStart_.set(e.clientX, e.clientY);
	  this.isDragging_ = true;
	};
	
	// Very similar to https://gist.github.com/mrflix/8351020
	MouseKeyboardVRDisplay.prototype.onMouseMove_ = function(e) {
	  if (!this.isDragging_ && !this.isPointerLocked_()) {
	    return;
	  }
	  // Support pointer lock API.
	  if (this.isPointerLocked_()) {
	    var movementX = e.movementX || e.mozMovementX || 0;
	    var movementY = e.movementY || e.mozMovementY || 0;
	    this.rotateEnd_.set(this.rotateStart_.x - movementX, this.rotateStart_.y - movementY);
	  } else {
	    this.rotateEnd_.set(e.clientX, e.clientY);
	  }
	  // Calculate how much we moved in mouse space.
	  this.rotateDelta_.subVectors(this.rotateEnd_, this.rotateStart_);
	  this.rotateStart_.copy(this.rotateEnd_);
	
	  // Keep track of the cumulative euler angles.
	  this.phi_ += 2 * Math.PI * this.rotateDelta_.y / screen.height * MOUSE_SPEED_Y;
	  this.theta_ += 2 * Math.PI * this.rotateDelta_.x / screen.width * MOUSE_SPEED_X;
	
	  // Prevent looking too far up or down.
	  this.phi_ = Util.clamp(this.phi_, -Math.PI/2, Math.PI/2);
	};
	
	MouseKeyboardVRDisplay.prototype.onMouseUp_ = function(e) {
	  this.isDragging_ = false;
	};
	
	MouseKeyboardVRDisplay.prototype.isPointerLocked_ = function() {
	  var el = document.pointerLockElement || document.mozPointerLockElement ||
	      document.webkitPointerLockElement;
	  return el !== undefined;
	};
	
	MouseKeyboardVRDisplay.prototype.resetPose = function() {
	  this.phi_ = 0;
	  this.theta_ = 0;
	};
	
	module.exports = MouseKeyboardVRDisplay;
	
	},{"./base.js":2,"./math-util.js":14,"./util.js":22}],16:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var Util = _dereq_('./util.js');
	
	function RotateInstructions() {
	  this.loadIcon_();
	
	  var overlay = document.createElement('div');
	  var s = overlay.style;
	  s.position = 'fixed';
	  s.top = 0;
	  s.right = 0;
	  s.bottom = 0;
	  s.left = 0;
	  s.backgroundColor = 'gray';
	  s.fontFamily = 'sans-serif';
	  // Force this to be above the fullscreen canvas, which is at zIndex: 999999.
	  s.zIndex = 1000000;
	
	  var img = document.createElement('img');
	  img.src = this.icon;
	  var s = img.style;
	  s.marginLeft = '25%';
	  s.marginTop = '25%';
	  s.width = '50%';
	  overlay.appendChild(img);
	
	  var text = document.createElement('div');
	  var s = text.style;
	  s.textAlign = 'center';
	  s.fontSize = '16px';
	  s.lineHeight = '24px';
	  s.margin = '24px 25%';
	  s.width = '50%';
	  text.innerHTML = 'Place your phone into your Cardboard viewer.';
	  overlay.appendChild(text);
	
	  var snackbar = document.createElement('div');
	  var s = snackbar.style;
	  s.backgroundColor = '#CFD8DC';
	  s.position = 'fixed';
	  s.bottom = 0;
	  s.width = '100%';
	  s.height = '48px';
	  s.padding = '14px 24px';
	  s.boxSizing = 'border-box';
	  s.color = '#656A6B';
	  overlay.appendChild(snackbar);
	
	  var snackbarText = document.createElement('div');
	  snackbarText.style.float = 'left';
	  snackbarText.innerHTML = 'No Cardboard viewer?';
	
	  var snackbarButton = document.createElement('a');
	  snackbarButton.href = 'https://www.google.com/get/cardboard/get-cardboard/';
	  snackbarButton.innerHTML = 'get one';
	  snackbarButton.target = '_blank';
	  var s = snackbarButton.style;
	  s.float = 'right';
	  s.fontWeight = 600;
	  s.textTransform = 'uppercase';
	  s.borderLeft = '1px solid gray';
	  s.paddingLeft = '24px';
	  s.textDecoration = 'none';
	  s.color = '#656A6B';
	
	  snackbar.appendChild(snackbarText);
	  snackbar.appendChild(snackbarButton);
	
	  this.overlay = overlay;
	  this.text = text;
	
	  this.hide();
	}
	
	RotateInstructions.prototype.show = function(parent) {
	  if (!parent && !this.overlay.parentElement) {
	    document.body.appendChild(this.overlay);
	  } else if (parent) {
	    if (this.overlay.parentElement && this.overlay.parentElement != parent)
	      this.overlay.parentElement.removeChild(this.overlay);
	
	    parent.appendChild(this.overlay);
	  }
	
	  this.overlay.style.display = 'block';
	
	  var img = this.overlay.querySelector('img');
	  var s = img.style;
	
	  if (Util.isLandscapeMode()) {
	    s.width = '20%';
	    s.marginLeft = '40%';
	    s.marginTop = '3%';
	  } else {
	    s.width = '50%';
	    s.marginLeft = '25%';
	    s.marginTop = '25%';
	  }
	};
	
	RotateInstructions.prototype.hide = function() {
	  this.overlay.style.display = 'none';
	};
	
	RotateInstructions.prototype.showTemporarily = function(ms, parent) {
	  this.show(parent);
	  this.timer = setTimeout(this.hide.bind(this), ms);
	};
	
	RotateInstructions.prototype.disableShowTemporarily = function() {
	  clearTimeout(this.timer);
	};
	
	RotateInstructions.prototype.update = function() {
	  this.disableShowTemporarily();
	  // In portrait VR mode, tell the user to rotate to landscape. Otherwise, hide
	  // the instructions.
	  if (!Util.isLandscapeMode() && Util.isMobile()) {
	    this.show();
	  } else {
	    this.hide();
	  }
	};
	
	RotateInstructions.prototype.loadIcon_ = function() {
	  // Encoded asset_src/rotate-instructions.svg
	  this.icon = Util.base64('image/svg+xml', 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5OHB4IiBoZWlnaHQ9IjI0MHB4IiB2aWV3Qm94PSIwIDAgMTk4IDI0MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpza2V0Y2g9Imh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9ucyI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDMuMy4zICgxMjA4MSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dHJhbnNpdGlvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHNrZXRjaDp0eXBlPSJNU1BhZ2UiPgogICAgICAgIDxnIGlkPSJ0cmFuc2l0aW9uIiBza2V0Y2g6dHlwZT0iTVNBcnRib2FyZEdyb3VwIj4KICAgICAgICAgICAgPGcgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTQtKy1JbXBvcnRlZC1MYXllcnMtQ29weS0rLUltcG9ydGVkLUxheWVycy1Db3B5LTItQ29weSIgc2tldGNoOnR5cGU9Ik1TTGF5ZXJHcm91cCI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHktNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwNy4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjYyNSwyLjUyNyBDMTQ5LjYyNSwyLjUyNyAxNTUuODA1LDYuMDk2IDE1Ni4zNjIsNi40MTggTDE1Ni4zNjIsNy4zMDQgQzE1Ni4zNjIsNy40ODEgMTU2LjM3NSw3LjY2NCAxNTYuNCw3Ljg1MyBDMTU2LjQxLDcuOTM0IDE1Ni40Miw4LjAxNSAxNTYuNDI3LDguMDk1IEMxNTYuNTY3LDkuNTEgMTU3LjQwMSwxMS4wOTMgMTU4LjUzMiwxMi4wOTQgTDE2NC4yNTIsMTcuMTU2IEwxNjQuMzMzLDE3LjA2NiBDMTY0LjMzMywxNy4wNjYgMTY4LjcxNSwxNC41MzYgMTY5LjU2OCwxNC4wNDIgQzE3MS4wMjUsMTQuODgzIDE5NS41MzgsMjkuMDM1IDE5NS41MzgsMjkuMDM1IEwxOTUuNTM4LDgzLjAzNiBDMTk1LjUzOCw4My44MDcgMTk1LjE1Miw4NC4yNTMgMTk0LjU5LDg0LjI1MyBDMTk0LjM1Nyw4NC4yNTMgMTk0LjA5NSw4NC4xNzcgMTkzLjgxOCw4NC4wMTcgTDE2OS44NTEsNzAuMTc5IEwxNjkuODM3LDcwLjIwMyBMMTQyLjUxNSw4NS45NzggTDE0MS42NjUsODQuNjU1IEMxMzYuOTM0LDgzLjEyNiAxMzEuOTE3LDgxLjkxNSAxMjYuNzE0LDgxLjA0NSBDMTI2LjcwOSw4MS4wNiAxMjYuNzA3LDgxLjA2OSAxMjYuNzA3LDgxLjA2OSBMMTIxLjY0LDk4LjAzIEwxMTMuNzQ5LDEwMi41ODYgTDExMy43MTIsMTAyLjUyMyBMMTEzLjcxMiwxMzAuMTEzIEMxMTMuNzEyLDEzMC44ODUgMTEzLjMyNiwxMzEuMzMgMTEyLjc2NCwxMzEuMzMgQzExMi41MzIsMTMxLjMzIDExMi4yNjksMTMxLjI1NCAxMTEuOTkyLDEzMS4wOTQgTDY5LjUxOSwxMDYuNTcyIEM2OC41NjksMTA2LjAyMyA2Ny43OTksMTA0LjY5NSA2Ny43OTksMTAzLjYwNSBMNjcuNzk5LDEwMi41NyBMNjcuNzc4LDEwMi42MTcgQzY3LjI3LDEwMi4zOTMgNjYuNjQ4LDEwMi4yNDkgNjUuOTYyLDEwMi4yMTggQzY1Ljg3NSwxMDIuMjE0IDY1Ljc4OCwxMDIuMjEyIDY1LjcwMSwxMDIuMjEyIEM2NS42MDYsMTAyLjIxMiA2NS41MTEsMTAyLjIxNSA2NS40MTYsMTAyLjIxOSBDNjUuMTk1LDEwMi4yMjkgNjQuOTc0LDEwMi4yMzUgNjQuNzU0LDEwMi4yMzUgQzY0LjMzMSwxMDIuMjM1IDYzLjkxMSwxMDIuMjE2IDYzLjQ5OCwxMDIuMTc4IEM2MS44NDMsMTAyLjAyNSA2MC4yOTgsMTAxLjU3OCA1OS4wOTQsMTAwLjg4MiBMMTIuNTE4LDczLjk5MiBMMTIuNTIzLDc0LjAwNCBMMi4yNDUsNTUuMjU0IEMxLjI0NCw1My40MjcgMi4wMDQsNTEuMDM4IDMuOTQzLDQ5LjkxOCBMNTkuOTU0LDE3LjU3MyBDNjAuNjI2LDE3LjE4NSA2MS4zNSwxNy4wMDEgNjIuMDUzLDE3LjAwMSBDNjMuMzc5LDE3LjAwMSA2NC42MjUsMTcuNjYgNjUuMjgsMTguODU0IEw2NS4yODUsMTguODUxIEw2NS41MTIsMTkuMjY0IEw2NS41MDYsMTkuMjY4IEM2NS45MDksMjAuMDAzIDY2LjQwNSwyMC42OCA2Ni45ODMsMjEuMjg2IEw2Ny4yNiwyMS41NTYgQzY5LjE3NCwyMy40MDYgNzEuNzI4LDI0LjM1NyA3NC4zNzMsMjQuMzU3IEM3Ni4zMjIsMjQuMzU3IDc4LjMyMSwyMy44NCA4MC4xNDgsMjIuNzg1IEM4MC4xNjEsMjIuNzg1IDg3LjQ2NywxOC41NjYgODcuNDY3LDE4LjU2NiBDODguMTM5LDE4LjE3OCA4OC44NjMsMTcuOTk0IDg5LjU2NiwxNy45OTQgQzkwLjg5MiwxNy45OTQgOTIuMTM4LDE4LjY1MiA5Mi43OTIsMTkuODQ3IEw5Ni4wNDIsMjUuNzc1IEw5Ni4wNjQsMjUuNzU3IEwxMDIuODQ5LDI5LjY3NCBMMTAyLjc0NCwyOS40OTIgTDE0OS42MjUsMi41MjcgTTE0OS42MjUsMC44OTIgQzE0OS4zNDMsMC44OTIgMTQ5LjA2MiwwLjk2NSAxNDguODEsMS4xMSBMMTAyLjY0MSwyNy42NjYgTDk3LjIzMSwyNC41NDIgTDk0LjIyNiwxOS4wNjEgQzkzLjMxMywxNy4zOTQgOTEuNTI3LDE2LjM1OSA4OS41NjYsMTYuMzU4IEM4OC41NTUsMTYuMzU4IDg3LjU0NiwxNi42MzIgODYuNjQ5LDE3LjE1IEM4My44NzgsMTguNzUgNzkuNjg3LDIxLjE2OSA3OS4zNzQsMjEuMzQ1IEM3OS4zNTksMjEuMzUzIDc5LjM0NSwyMS4zNjEgNzkuMzMsMjEuMzY5IEM3Ny43OTgsMjIuMjU0IDc2LjA4NCwyMi43MjIgNzQuMzczLDIyLjcyMiBDNzIuMDgxLDIyLjcyMiA2OS45NTksMjEuODkgNjguMzk3LDIwLjM4IEw2OC4xNDUsMjAuMTM1IEM2Ny43MDYsMTkuNjcyIDY3LjMyMywxOS4xNTYgNjcuMDA2LDE4LjYwMSBDNjYuOTg4LDE4LjU1OSA2Ni45NjgsMTguNTE5IDY2Ljk0NiwxOC40NzkgTDY2LjcxOSwxOC4wNjUgQzY2LjY5LDE4LjAxMiA2Ni42NTgsMTcuOTYgNjYuNjI0LDE3LjkxMSBDNjUuNjg2LDE2LjMzNyA2My45NTEsMTUuMzY2IDYyLjA1MywxNS4zNjYgQzYxLjA0MiwxNS4zNjYgNjAuMDMzLDE1LjY0IDU5LjEzNiwxNi4xNTggTDMuMTI1LDQ4LjUwMiBDMC40MjYsNTAuMDYxIC0wLjYxMyw1My40NDIgMC44MTEsNTYuMDQgTDExLjA4OSw3NC43OSBDMTEuMjY2LDc1LjExMyAxMS41MzcsNzUuMzUzIDExLjg1LDc1LjQ5NCBMNTguMjc2LDEwMi4yOTggQzU5LjY3OSwxMDMuMTA4IDYxLjQzMywxMDMuNjMgNjMuMzQ4LDEwMy44MDYgQzYzLjgxMiwxMDMuODQ4IDY0LjI4NSwxMDMuODcgNjQuNzU0LDEwMy44NyBDNjUsMTAzLjg3IDY1LjI0OSwxMDMuODY0IDY1LjQ5NCwxMDMuODUyIEM2NS41NjMsMTAzLjg0OSA2NS42MzIsMTAzLjg0NyA2NS43MDEsMTAzLjg0NyBDNjUuNzY0LDEwMy44NDcgNjUuODI4LDEwMy44NDkgNjUuODksMTAzLjg1MiBDNjUuOTg2LDEwMy44NTYgNjYuMDgsMTAzLjg2MyA2Ni4xNzMsMTAzLjg3NCBDNjYuMjgyLDEwNS40NjcgNjcuMzMyLDEwNy4xOTcgNjguNzAyLDEwNy45ODggTDExMS4xNzQsMTMyLjUxIEMxMTEuNjk4LDEzMi44MTIgMTEyLjIzMiwxMzIuOTY1IDExMi43NjQsMTMyLjk2NSBDMTE0LjI2MSwxMzIuOTY1IDExNS4zNDcsMTMxLjc2NSAxMTUuMzQ3LDEzMC4xMTMgTDExNS4zNDcsMTAzLjU1MSBMMTIyLjQ1OCw5OS40NDYgQzEyMi44MTksOTkuMjM3IDEyMy4wODcsOTguODk4IDEyMy4yMDcsOTguNDk4IEwxMjcuODY1LDgyLjkwNSBDMTMyLjI3OSw4My43MDIgMTM2LjU1Nyw4NC43NTMgMTQwLjYwNyw4Ni4wMzMgTDE0MS4xNCw4Ni44NjIgQzE0MS40NTEsODcuMzQ2IDE0MS45NzcsODcuNjEzIDE0Mi41MTYsODcuNjEzIEMxNDIuNzk0LDg3LjYxMyAxNDMuMDc2LDg3LjU0MiAxNDMuMzMzLDg3LjM5MyBMMTY5Ljg2NSw3Mi4wNzYgTDE5Myw4NS40MzMgQzE5My41MjMsODUuNzM1IDE5NC4wNTgsODUuODg4IDE5NC41OSw4NS44ODggQzE5Ni4wODcsODUuODg4IDE5Ny4xNzMsODQuNjg5IDE5Ny4xNzMsODMuMDM2IEwxOTcuMTczLDI5LjAzNSBDMTk3LjE3MywyOC40NTEgMTk2Ljg2MSwyNy45MTEgMTk2LjM1NSwyNy42MTkgQzE5Ni4zNTUsMjcuNjE5IDE3MS44NDMsMTMuNDY3IDE3MC4zODUsMTIuNjI2IEMxNzAuMTMyLDEyLjQ4IDE2OS44NSwxMi40MDcgMTY5LjU2OCwxMi40MDcgQzE2OS4yODUsMTIuNDA3IDE2OS4wMDIsMTIuNDgxIDE2OC43NDksMTIuNjI3IEMxNjguMTQzLDEyLjk3OCAxNjUuNzU2LDE0LjM1NyAxNjQuNDI0LDE1LjEyNSBMMTU5LjYxNSwxMC44NyBDMTU4Ljc5NiwxMC4xNDUgMTU4LjE1NCw4LjkzNyAxNTguMDU0LDcuOTM0IEMxNTguMDQ1LDcuODM3IDE1OC4wMzQsNy43MzkgMTU4LjAyMSw3LjY0IEMxNTguMDA1LDcuNTIzIDE1Ny45OTgsNy40MSAxNTcuOTk4LDcuMzA0IEwxNTcuOTk4LDYuNDE4IEMxNTcuOTk4LDUuODM0IDE1Ny42ODYsNS4yOTUgMTU3LjE4MSw1LjAwMiBDMTU2LjYyNCw0LjY4IDE1MC40NDIsMS4xMTEgMTUwLjQ0MiwxLjExMSBDMTUwLjE4OSwwLjk2NSAxNDkuOTA3LDAuODkyIDE0OS42MjUsMC44OTIiIGlkPSJGaWxsLTEiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTYuMDI3LDI1LjYzNiBMMTQyLjYwMyw1Mi41MjcgQzE0My44MDcsNTMuMjIyIDE0NC41ODIsNTQuMTE0IDE0NC44NDUsNTUuMDY4IEwxNDQuODM1LDU1LjA3NSBMNjMuNDYxLDEwMi4wNTcgTDYzLjQ2LDEwMi4wNTcgQzYxLjgwNiwxMDEuOTA1IDYwLjI2MSwxMDEuNDU3IDU5LjA1NywxMDAuNzYyIEwxMi40ODEsNzMuODcxIEw5Ni4wMjcsMjUuNjM2IiBpZD0iRmlsbC0yIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYzLjQ2MSwxMDIuMTc0IEM2My40NTMsMTAyLjE3NCA2My40NDYsMTAyLjE3NCA2My40MzksMTAyLjE3MiBDNjEuNzQ2LDEwMi4wMTYgNjAuMjExLDEwMS41NjMgNTguOTk4LDEwMC44NjMgTDEyLjQyMiw3My45NzMgQzEyLjM4Niw3My45NTIgMTIuMzY0LDczLjkxNCAxMi4zNjQsNzMuODcxIEMxMi4zNjQsNzMuODMgMTIuMzg2LDczLjc5MSAxMi40MjIsNzMuNzcgTDk1Ljk2OCwyNS41MzUgQzk2LjAwNCwyNS41MTQgOTYuMDQ5LDI1LjUxNCA5Ni4wODUsMjUuNTM1IEwxNDIuNjYxLDUyLjQyNiBDMTQzLjg4OCw1My4xMzQgMTQ0LjY4Miw1NC4wMzggMTQ0Ljk1Nyw1NS4wMzcgQzE0NC45Nyw1NS4wODMgMTQ0Ljk1Myw1NS4xMzMgMTQ0LjkxNSw1NS4xNjEgQzE0NC45MTEsNTUuMTY1IDE0NC44OTgsNTUuMTc0IDE0NC44OTQsNTUuMTc3IEw2My41MTksMTAyLjE1OCBDNjMuNTAxLDEwMi4xNjkgNjMuNDgxLDEwMi4xNzQgNjMuNDYxLDEwMi4xNzQgTDYzLjQ2MSwxMDIuMTc0IFogTTEyLjcxNCw3My44NzEgTDU5LjExNSwxMDAuNjYxIEM2MC4yOTMsMTAxLjM0MSA2MS43ODYsMTAxLjc4MiA2My40MzUsMTAxLjkzNyBMMTQ0LjcwNyw1NS4wMTUgQzE0NC40MjgsNTQuMTA4IDE0My42ODIsNTMuMjg1IDE0Mi41NDQsNTIuNjI4IEw5Ni4wMjcsMjUuNzcxIEwxMi43MTQsNzMuODcxIEwxMi43MTQsNzMuODcxIFoiIGlkPSJGaWxsLTMiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ4LjMyNyw1OC40NzEgQzE0OC4xNDUsNTguNDggMTQ3Ljk2Miw1OC40OCAxNDcuNzgxLDU4LjQ3MiBDMTQ1Ljg4Nyw1OC4zODkgMTQ0LjQ3OSw1Ny40MzQgMTQ0LjYzNiw1Ni4zNCBDMTQ0LjY4OSw1NS45NjcgMTQ0LjY2NCw1NS41OTcgMTQ0LjU2NCw1NS4yMzUgTDYzLjQ2MSwxMDIuMDU3IEM2NC4wODksMTAyLjExNSA2NC43MzMsMTAyLjEzIDY1LjM3OSwxMDIuMDk5IEM2NS41NjEsMTAyLjA5IDY1Ljc0MywxMDIuMDkgNjUuOTI1LDEwMi4wOTggQzY3LjgxOSwxMDIuMTgxIDY5LjIyNywxMDMuMTM2IDY5LjA3LDEwNC4yMyBMMTQ4LjMyNyw1OC40NzEiIGlkPSJGaWxsLTQiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjkuMDcsMTA0LjM0NyBDNjkuMDQ4LDEwNC4zNDcgNjkuMDI1LDEwNC4zNCA2OS4wMDUsMTA0LjMyNyBDNjguOTY4LDEwNC4zMDEgNjguOTQ4LDEwNC4yNTcgNjguOTU1LDEwNC4yMTMgQzY5LDEwMy44OTYgNjguODk4LDEwMy41NzYgNjguNjU4LDEwMy4yODggQzY4LjE1MywxMDIuNjc4IDY3LjEwMywxMDIuMjY2IDY1LjkyLDEwMi4yMTQgQzY1Ljc0MiwxMDIuMjA2IDY1LjU2MywxMDIuMjA3IDY1LjM4NSwxMDIuMjE1IEM2NC43NDIsMTAyLjI0NiA2NC4wODcsMTAyLjIzMiA2My40NSwxMDIuMTc0IEM2My4zOTksMTAyLjE2OSA2My4zNTgsMTAyLjEzMiA2My4zNDcsMTAyLjA4MiBDNjMuMzM2LDEwMi4wMzMgNjMuMzU4LDEwMS45ODEgNjMuNDAyLDEwMS45NTYgTDE0NC41MDYsNTUuMTM0IEMxNDQuNTM3LDU1LjExNiAxNDQuNTc1LDU1LjExMyAxNDQuNjA5LDU1LjEyNyBDMTQ0LjY0Miw1NS4xNDEgMTQ0LjY2OCw1NS4xNyAxNDQuNjc3LDU1LjIwNCBDMTQ0Ljc4MSw1NS41ODUgMTQ0LjgwNiw1NS45NzIgMTQ0Ljc1MSw1Ni4zNTcgQzE0NC43MDYsNTYuNjczIDE0NC44MDgsNTYuOTk0IDE0NS4wNDcsNTcuMjgyIEMxNDUuNTUzLDU3Ljg5MiAxNDYuNjAyLDU4LjMwMyAxNDcuNzg2LDU4LjM1NSBDMTQ3Ljk2NCw1OC4zNjMgMTQ4LjE0Myw1OC4zNjMgMTQ4LjMyMSw1OC4zNTQgQzE0OC4zNzcsNTguMzUyIDE0OC40MjQsNTguMzg3IDE0OC40MzksNTguNDM4IEMxNDguNDU0LDU4LjQ5IDE0OC40MzIsNTguNTQ1IDE0OC4zODUsNTguNTcyIEw2OS4xMjksMTA0LjMzMSBDNjkuMTExLDEwNC4zNDIgNjkuMDksMTA0LjM0NyA2OS4wNywxMDQuMzQ3IEw2OS4wNywxMDQuMzQ3IFogTTY1LjY2NSwxMDEuOTc1IEM2NS43NTQsMTAxLjk3NSA2NS44NDIsMTAxLjk3NyA2NS45MywxMDEuOTgxIEM2Ny4xOTYsMTAyLjAzNyA2OC4yODMsMTAyLjQ2OSA2OC44MzgsMTAzLjEzOSBDNjkuMDY1LDEwMy40MTMgNjkuMTg4LDEwMy43MTQgNjkuMTk4LDEwNC4wMjEgTDE0Ny44ODMsNTguNTkyIEMxNDcuODQ3LDU4LjU5MiAxNDcuODExLDU4LjU5MSAxNDcuNzc2LDU4LjU4OSBDMTQ2LjUwOSw1OC41MzMgMTQ1LjQyMiw1OC4xIDE0NC44NjcsNTcuNDMxIEMxNDQuNTg1LDU3LjA5MSAxNDQuNDY1LDU2LjcwNyAxNDQuNTIsNTYuMzI0IEMxNDQuNTYzLDU2LjAyMSAxNDQuNTUyLDU1LjcxNiAxNDQuNDg4LDU1LjQxNCBMNjMuODQ2LDEwMS45NyBDNjQuMzUzLDEwMi4wMDIgNjQuODY3LDEwMi4wMDYgNjUuMzc0LDEwMS45ODIgQzY1LjQ3MSwxMDEuOTc3IDY1LjU2OCwxMDEuOTc1IDY1LjY2NSwxMDEuOTc1IEw2NS42NjUsMTAxLjk3NSBaIiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIuMjA4LDU1LjEzNCBDMS4yMDcsNTMuMzA3IDEuOTY3LDUwLjkxNyAzLjkwNiw0OS43OTcgTDU5LjkxNywxNy40NTMgQzYxLjg1NiwxNi4zMzMgNjQuMjQxLDE2LjkwNyA2NS4yNDMsMTguNzM0IEw2NS40NzUsMTkuMTQ0IEM2NS44NzIsMTkuODgyIDY2LjM2OCwyMC41NiA2Ni45NDUsMjEuMTY1IEw2Ny4yMjMsMjEuNDM1IEM3MC41NDgsMjQuNjQ5IDc1LjgwNiwyNS4xNTEgODAuMTExLDIyLjY2NSBMODcuNDMsMTguNDQ1IEM4OS4zNywxNy4zMjYgOTEuNzU0LDE3Ljg5OSA5Mi43NTUsMTkuNzI3IEw5Ni4wMDUsMjUuNjU1IEwxMi40ODYsNzMuODg0IEwyLjIwOCw1NS4xMzQgWiIgaWQ9IkZpbGwtNiIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi40ODYsNzQuMDAxIEMxMi40NzYsNzQuMDAxIDEyLjQ2NSw3My45OTkgMTIuNDU1LDczLjk5NiBDMTIuNDI0LDczLjk4OCAxMi4zOTksNzMuOTY3IDEyLjM4NCw3My45NCBMMi4xMDYsNTUuMTkgQzEuMDc1LDUzLjMxIDEuODU3LDUwLjg0NSAzLjg0OCw0OS42OTYgTDU5Ljg1OCwxNy4zNTIgQzYwLjUyNSwxNi45NjcgNjEuMjcxLDE2Ljc2NCA2Mi4wMTYsMTYuNzY0IEM2My40MzEsMTYuNzY0IDY0LjY2NiwxNy40NjYgNjUuMzI3LDE4LjY0NiBDNjUuMzM3LDE4LjY1NCA2NS4zNDUsMTguNjYzIDY1LjM1MSwxOC42NzQgTDY1LjU3OCwxOS4wODggQzY1LjU4NCwxOS4xIDY1LjU4OSwxOS4xMTIgNjUuNTkxLDE5LjEyNiBDNjUuOTg1LDE5LjgzOCA2Ni40NjksMjAuNDk3IDY3LjAzLDIxLjA4NSBMNjcuMzA1LDIxLjM1MSBDNjkuMTUxLDIzLjEzNyA3MS42NDksMjQuMTIgNzQuMzM2LDI0LjEyIEM3Ni4zMTMsMjQuMTIgNzguMjksMjMuNTgyIDgwLjA1MywyMi41NjMgQzgwLjA2NCwyMi41NTcgODAuMDc2LDIyLjU1MyA4MC4wODgsMjIuNTUgTDg3LjM3MiwxOC4zNDQgQzg4LjAzOCwxNy45NTkgODguNzg0LDE3Ljc1NiA4OS41MjksMTcuNzU2IEM5MC45NTYsMTcuNzU2IDkyLjIwMSwxOC40NzIgOTIuODU4LDE5LjY3IEw5Ni4xMDcsMjUuNTk5IEM5Ni4xMzgsMjUuNjU0IDk2LjExOCwyNS43MjQgOTYuMDYzLDI1Ljc1NiBMMTIuNTQ1LDczLjk4NSBDMTIuNTI2LDczLjk5NiAxMi41MDYsNzQuMDAxIDEyLjQ4Niw3NC4wMDEgTDEyLjQ4Niw3NC4wMDEgWiBNNjIuMDE2LDE2Ljk5NyBDNjEuMzEyLDE2Ljk5NyA2MC42MDYsMTcuMTkgNTkuOTc1LDE3LjU1NCBMMy45NjUsNDkuODk5IEMyLjA4Myw1MC45ODUgMS4zNDEsNTMuMzA4IDIuMzEsNTUuMDc4IEwxMi41MzEsNzMuNzIzIEw5NS44NDgsMjUuNjExIEw5Mi42NTMsMTkuNzgyIEM5Mi4wMzgsMTguNjYgOTAuODcsMTcuOTkgODkuNTI5LDE3Ljk5IEM4OC44MjUsMTcuOTkgODguMTE5LDE4LjE4MiA4Ny40ODksMTguNTQ3IEw4MC4xNzIsMjIuNzcyIEM4MC4xNjEsMjIuNzc4IDgwLjE0OSwyMi43ODIgODAuMTM3LDIyLjc4NSBDNzguMzQ2LDIzLjgxMSA3Ni4zNDEsMjQuMzU0IDc0LjMzNiwyNC4zNTQgQzcxLjU4OCwyNC4zNTQgNjkuMDMzLDIzLjM0NyA2Ny4xNDIsMjEuNTE5IEw2Ni44NjQsMjEuMjQ5IEM2Ni4yNzcsMjAuNjM0IDY1Ljc3NCwxOS45NDcgNjUuMzY3LDE5LjIwMyBDNjUuMzYsMTkuMTkyIDY1LjM1NiwxOS4xNzkgNjUuMzU0LDE5LjE2NiBMNjUuMTYzLDE4LjgxOSBDNjUuMTU0LDE4LjgxMSA2NS4xNDYsMTguODAxIDY1LjE0LDE4Ljc5IEM2NC41MjUsMTcuNjY3IDYzLjM1NywxNi45OTcgNjIuMDE2LDE2Ljk5NyBMNjIuMDE2LDE2Ljk5NyBaIiBpZD0iRmlsbC03IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQyLjQzNCw0OC44MDggTDQyLjQzNCw0OC44MDggQzM5LjkyNCw0OC44MDcgMzcuNzM3LDQ3LjU1IDM2LjU4Miw0NS40NDMgQzM0Ljc3MSw0Mi4xMzkgMzYuMTQ0LDM3LjgwOSAzOS42NDEsMzUuNzg5IEw1MS45MzIsMjguNjkxIEM1My4xMDMsMjguMDE1IDU0LjQxMywyNy42NTggNTUuNzIxLDI3LjY1OCBDNTguMjMxLDI3LjY1OCA2MC40MTgsMjguOTE2IDYxLjU3MywzMS4wMjMgQzYzLjM4NCwzNC4zMjcgNjIuMDEyLDM4LjY1NyA1OC41MTQsNDAuNjc3IEw0Ni4yMjMsNDcuNzc1IEM0NS4wNTMsNDguNDUgNDMuNzQyLDQ4LjgwOCA0Mi40MzQsNDguODA4IEw0Mi40MzQsNDguODA4IFogTTU1LjcyMSwyOC4xMjUgQzU0LjQ5NSwyOC4xMjUgNTMuMjY1LDI4LjQ2MSA1Mi4xNjYsMjkuMDk2IEwzOS44NzUsMzYuMTk0IEMzNi41OTYsMzguMDg3IDM1LjMwMiw0Mi4xMzYgMzYuOTkyLDQ1LjIxOCBDMzguMDYzLDQ3LjE3MyA0MC4wOTgsNDguMzQgNDIuNDM0LDQ4LjM0IEM0My42NjEsNDguMzQgNDQuODksNDguMDA1IDQ1Ljk5LDQ3LjM3IEw1OC4yODEsNDAuMjcyIEM2MS41NiwzOC4zNzkgNjIuODUzLDM0LjMzIDYxLjE2NCwzMS4yNDggQzYwLjA5MiwyOS4yOTMgNTguMDU4LDI4LjEyNSA1NS43MjEsMjguMTI1IEw1NS43MjEsMjguMTI1IFoiIGlkPSJGaWxsLTgiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjU4OCwyLjQwNyBDMTQ5LjU4OCwyLjQwNyAxNTUuNzY4LDUuOTc1IDE1Ni4zMjUsNi4yOTcgTDE1Ni4zMjUsNy4xODQgQzE1Ni4zMjUsNy4zNiAxNTYuMzM4LDcuNTQ0IDE1Ni4zNjIsNy43MzMgQzE1Ni4zNzMsNy44MTQgMTU2LjM4Miw3Ljg5NCAxNTYuMzksNy45NzUgQzE1Ni41Myw5LjM5IDE1Ny4zNjMsMTAuOTczIDE1OC40OTUsMTEuOTc0IEwxNjUuODkxLDE4LjUxOSBDMTY2LjA2OCwxOC42NzUgMTY2LjI0OSwxOC44MTQgMTY2LjQzMiwxOC45MzQgQzE2OC4wMTEsMTkuOTc0IDE2OS4zODIsMTkuNCAxNjkuNDk0LDE3LjY1MiBDMTY5LjU0MywxNi44NjggMTY5LjU1MSwxNi4wNTcgMTY5LjUxNywxNS4yMjMgTDE2OS41MTQsMTUuMDYzIEwxNjkuNTE0LDEzLjkxMiBDMTcwLjc4LDE0LjY0MiAxOTUuNTAxLDI4LjkxNSAxOTUuNTAxLDI4LjkxNSBMMTk1LjUwMSw4Mi45MTUgQzE5NS41MDEsODQuMDA1IDE5NC43MzEsODQuNDQ1IDE5My43ODEsODMuODk3IEwxNTEuMzA4LDU5LjM3NCBDMTUwLjM1OCw1OC44MjYgMTQ5LjU4OCw1Ny40OTcgMTQ5LjU4OCw1Ni40MDggTDE0OS41ODgsMjIuMzc1IiBpZD0iRmlsbC05IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE5NC41NTMsODQuMjUgQzE5NC4yOTYsODQuMjUgMTk0LjAxMyw4NC4xNjUgMTkzLjcyMiw4My45OTcgTDE1MS4yNSw1OS40NzYgQzE1MC4yNjksNTguOTA5IDE0OS40NzEsNTcuNTMzIDE0OS40NzEsNTYuNDA4IEwxNDkuNDcxLDIyLjM3NSBMMTQ5LjcwNSwyMi4zNzUgTDE0OS43MDUsNTYuNDA4IEMxNDkuNzA1LDU3LjQ1OSAxNTAuNDUsNTguNzQ0IDE1MS4zNjYsNTkuMjc0IEwxOTMuODM5LDgzLjc5NSBDMTk0LjI2Myw4NC4wNCAxOTQuNjU1LDg0LjA4MyAxOTQuOTQyLDgzLjkxNyBDMTk1LjIyNyw4My43NTMgMTk1LjM4NCw4My4zOTcgMTk1LjM4NCw4Mi45MTUgTDE5NS4zODQsMjguOTgyIEMxOTQuMTAyLDI4LjI0MiAxNzIuMTA0LDE1LjU0MiAxNjkuNjMxLDE0LjExNCBMMTY5LjYzNCwxNS4yMiBDMTY5LjY2OCwxNi4wNTIgMTY5LjY2LDE2Ljg3NCAxNjkuNjEsMTcuNjU5IEMxNjkuNTU2LDE4LjUwMyAxNjkuMjE0LDE5LjEyMyAxNjguNjQ3LDE5LjQwNSBDMTY4LjAyOCwxOS43MTQgMTY3LjE5NywxOS41NzggMTY2LjM2NywxOS4wMzIgQzE2Ni4xODEsMTguOTA5IDE2NS45OTUsMTguNzY2IDE2NS44MTQsMTguNjA2IEwxNTguNDE3LDEyLjA2MiBDMTU3LjI1OSwxMS4wMzYgMTU2LjQxOCw5LjQzNyAxNTYuMjc0LDcuOTg2IEMxNTYuMjY2LDcuOTA3IDE1Ni4yNTcsNy44MjcgMTU2LjI0Nyw3Ljc0OCBDMTU2LjIyMSw3LjU1NSAxNTYuMjA5LDcuMzY1IDE1Ni4yMDksNy4xODQgTDE1Ni4yMDksNi4zNjQgQzE1NS4zNzUsNS44ODMgMTQ5LjUyOSwyLjUwOCAxNDkuNTI5LDIuNTA4IEwxNDkuNjQ2LDIuMzA2IEMxNDkuNjQ2LDIuMzA2IDE1NS44MjcsNS44NzQgMTU2LjM4NCw2LjE5NiBMMTU2LjQ0Miw2LjIzIEwxNTYuNDQyLDcuMTg0IEMxNTYuNDQyLDcuMzU1IDE1Ni40NTQsNy41MzUgMTU2LjQ3OCw3LjcxNyBDMTU2LjQ4OSw3LjggMTU2LjQ5OSw3Ljg4MiAxNTYuNTA3LDcuOTYzIEMxNTYuNjQ1LDkuMzU4IDE1Ny40NTUsMTAuODk4IDE1OC41NzIsMTEuODg2IEwxNjUuOTY5LDE4LjQzMSBDMTY2LjE0MiwxOC41ODQgMTY2LjMxOSwxOC43MiAxNjYuNDk2LDE4LjgzNyBDMTY3LjI1NCwxOS4zMzYgMTY4LDE5LjQ2NyAxNjguNTQzLDE5LjE5NiBDMTY5LjAzMywxOC45NTMgMTY5LjMyOSwxOC40MDEgMTY5LjM3NywxNy42NDUgQzE2OS40MjcsMTYuODY3IDE2OS40MzQsMTYuMDU0IDE2OS40MDEsMTUuMjI4IEwxNjkuMzk3LDE1LjA2NSBMMTY5LjM5NywxMy43MSBMMTY5LjU3MiwxMy44MSBDMTcwLjgzOSwxNC41NDEgMTk1LjU1OSwyOC44MTQgMTk1LjU1OSwyOC44MTQgTDE5NS42MTgsMjguODQ3IEwxOTUuNjE4LDgyLjkxNSBDMTk1LjYxOCw4My40ODQgMTk1LjQyLDgzLjkxMSAxOTUuMDU5LDg0LjExOSBDMTk0LjkwOCw4NC4yMDYgMTk0LjczNyw4NC4yNSAxOTQuNTUzLDg0LjI1IiBpZD0iRmlsbC0xMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDUuNjg1LDU2LjE2MSBMMTY5LjgsNzAuMDgzIEwxNDMuODIyLDg1LjA4MSBMMTQyLjM2LDg0Ljc3NCBDMTM1LjgyNiw4Mi42MDQgMTI4LjczMiw4MS4wNDYgMTIxLjM0MSw4MC4xNTggQzExNi45NzYsNzkuNjM0IDExMi42NzgsODEuMjU0IDExMS43NDMsODMuNzc4IEMxMTEuNTA2LDg0LjQxNCAxMTEuNTAzLDg1LjA3MSAxMTEuNzMyLDg1LjcwNiBDMTEzLjI3LDg5Ljk3MyAxMTUuOTY4LDk0LjA2OSAxMTkuNzI3LDk3Ljg0MSBMMTIwLjI1OSw5OC42ODYgQzEyMC4yNiw5OC42ODUgOTQuMjgyLDExMy42ODMgOTQuMjgyLDExMy42ODMgTDcwLjE2Nyw5OS43NjEgTDE0NS42ODUsNTYuMTYxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05NC4yODIsMTEzLjgxOCBMOTQuMjIzLDExMy43ODUgTDY5LjkzMyw5OS43NjEgTDcwLjEwOCw5OS42NiBMMTQ1LjY4NSw1Ni4wMjYgTDE0NS43NDMsNTYuMDU5IEwxNzAuMDMzLDcwLjA4MyBMMTQzLjg0Miw4NS4yMDUgTDE0My43OTcsODUuMTk1IEMxNDMuNzcyLDg1LjE5IDE0Mi4zMzYsODQuODg4IDE0Mi4zMzYsODQuODg4IEMxMzUuNzg3LDgyLjcxNCAxMjguNzIzLDgxLjE2MyAxMjEuMzI3LDgwLjI3NCBDMTIwLjc4OCw4MC4yMDkgMTIwLjIzNiw4MC4xNzcgMTE5LjY4OSw4MC4xNzcgQzExNS45MzEsODAuMTc3IDExMi42MzUsODEuNzA4IDExMS44NTIsODMuODE5IEMxMTEuNjI0LDg0LjQzMiAxMTEuNjIxLDg1LjA1MyAxMTEuODQyLDg1LjY2NyBDMTEzLjM3Nyw4OS45MjUgMTE2LjA1OCw5My45OTMgMTE5LjgxLDk3Ljc1OCBMMTE5LjgyNiw5Ny43NzkgTDEyMC4zNTIsOTguNjE0IEMxMjAuMzU0LDk4LjYxNyAxMjAuMzU2LDk4LjYyIDEyMC4zNTgsOTguNjI0IEwxMjAuNDIyLDk4LjcyNiBMMTIwLjMxNyw5OC43ODcgQzEyMC4yNjQsOTguODE4IDk0LjU5OSwxMTMuNjM1IDk0LjM0LDExMy43ODUgTDk0LjI4MiwxMTMuODE4IEw5NC4yODIsMTEzLjgxOCBaIE03MC40MDEsOTkuNzYxIEw5NC4yODIsMTEzLjU0OSBMMTE5LjA4NCw5OS4yMjkgQzExOS42Myw5OC45MTQgMTE5LjkzLDk4Ljc0IDEyMC4xMDEsOTguNjU0IEwxMTkuNjM1LDk3LjkxNCBDMTE1Ljg2NCw5NC4xMjcgMTEzLjE2OCw5MC4wMzMgMTExLjYyMiw4NS43NDYgQzExMS4zODIsODUuMDc5IDExMS4zODYsODQuNDA0IDExMS42MzMsODMuNzM4IEMxMTIuNDQ4LDgxLjUzOSAxMTUuODM2LDc5Ljk0MyAxMTkuNjg5LDc5Ljk0MyBDMTIwLjI0Niw3OS45NDMgMTIwLjgwNiw3OS45NzYgMTIxLjM1NSw4MC4wNDIgQzEyOC43NjcsODAuOTMzIDEzNS44NDYsODIuNDg3IDE0Mi4zOTYsODQuNjYzIEMxNDMuMjMyLDg0LjgzOCAxNDMuNjExLDg0LjkxNyAxNDMuNzg2LDg0Ljk2NyBMMTY5LjU2Niw3MC4wODMgTDE0NS42ODUsNTYuMjk1IEw3MC40MDEsOTkuNzYxIEw3MC40MDEsOTkuNzYxIFoiIGlkPSJGaWxsLTEyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2Ny4yMywxOC45NzkgTDE2Ny4yMyw2OS44NSBMMTM5LjkwOSw4NS42MjMgTDEzMy40NDgsNzEuNDU2IEMxMzIuNTM4LDY5LjQ2IDEzMC4wMiw2OS43MTggMTI3LjgyNCw3Mi4wMyBDMTI2Ljc2OSw3My4xNCAxMjUuOTMxLDc0LjU4NSAxMjUuNDk0LDc2LjA0OCBMMTE5LjAzNCw5Ny42NzYgTDkxLjcxMiwxMTMuNDUgTDkxLjcxMiw2Mi41NzkgTDE2Ny4yMywxOC45NzkiIGlkPSJGaWxsLTEzIiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTkxLjcxMiwxMTMuNTY3IEM5MS42OTIsMTEzLjU2NyA5MS42NzIsMTEzLjU2MSA5MS42NTMsMTEzLjU1MSBDOTEuNjE4LDExMy41MyA5MS41OTUsMTEzLjQ5MiA5MS41OTUsMTEzLjQ1IEw5MS41OTUsNjIuNTc5IEM5MS41OTUsNjIuNTM3IDkxLjYxOCw2Mi40OTkgOTEuNjUzLDYyLjQ3OCBMMTY3LjE3MiwxOC44NzggQzE2Ny4yMDgsMTguODU3IDE2Ny4yNTIsMTguODU3IDE2Ny4yODgsMTguODc4IEMxNjcuMzI0LDE4Ljg5OSAxNjcuMzQ3LDE4LjkzNyAxNjcuMzQ3LDE4Ljk3OSBMMTY3LjM0Nyw2OS44NSBDMTY3LjM0Nyw2OS44OTEgMTY3LjMyNCw2OS45MyAxNjcuMjg4LDY5Ljk1IEwxMzkuOTY3LDg1LjcyNSBDMTM5LjkzOSw4NS43NDEgMTM5LjkwNSw4NS43NDUgMTM5Ljg3Myw4NS43MzUgQzEzOS44NDIsODUuNzI1IDEzOS44MTYsODUuNzAyIDEzOS44MDIsODUuNjcyIEwxMzMuMzQyLDcxLjUwNCBDMTMyLjk2Nyw3MC42ODIgMTMyLjI4LDcwLjIyOSAxMzEuNDA4LDcwLjIyOSBDMTMwLjMxOSw3MC4yMjkgMTI5LjA0NCw3MC45MTUgMTI3LjkwOCw3Mi4xMSBDMTI2Ljg3NCw3My4yIDEyNi4wMzQsNzQuNjQ3IDEyNS42MDYsNzYuMDgyIEwxMTkuMTQ2LDk3LjcwOSBDMTE5LjEzNyw5Ny43MzggMTE5LjExOCw5Ny43NjIgMTE5LjA5Miw5Ny43NzcgTDkxLjc3LDExMy41NTEgQzkxLjc1MiwxMTMuNTYxIDkxLjczMiwxMTMuNTY3IDkxLjcxMiwxMTMuNTY3IEw5MS43MTIsMTEzLjU2NyBaIE05MS44MjksNjIuNjQ3IEw5MS44MjksMTEzLjI0OCBMMTE4LjkzNSw5Ny41OTggTDEyNS4zODIsNzYuMDE1IEMxMjUuODI3LDc0LjUyNSAxMjYuNjY0LDczLjA4MSAxMjcuNzM5LDcxLjk1IEMxMjguOTE5LDcwLjcwOCAxMzAuMjU2LDY5Ljk5NiAxMzEuNDA4LDY5Ljk5NiBDMTMyLjM3Nyw2OS45OTYgMTMzLjEzOSw3MC40OTcgMTMzLjU1NCw3MS40MDcgTDEzOS45NjEsODUuNDU4IEwxNjcuMTEzLDY5Ljc4MiBMMTY3LjExMywxOS4xODEgTDkxLjgyOSw2Mi42NDcgTDkxLjgyOSw2Mi42NDcgWiIgaWQ9IkZpbGwtMTQiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTY4LjU0MywxOS4yMTMgTDE2OC41NDMsNzAuMDgzIEwxNDEuMjIxLDg1Ljg1NyBMMTM0Ljc2MSw3MS42ODkgQzEzMy44NTEsNjkuNjk0IDEzMS4zMzMsNjkuOTUxIDEyOS4xMzcsNzIuMjYzIEMxMjguMDgyLDczLjM3NCAxMjcuMjQ0LDc0LjgxOSAxMjYuODA3LDc2LjI4MiBMMTIwLjM0Niw5Ny45MDkgTDkzLjAyNSwxMTMuNjgzIEw5My4wMjUsNjIuODEzIEwxNjguNTQzLDE5LjIxMyIgaWQ9IkZpbGwtMTUiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTMuMDI1LDExMy44IEM5My4wMDUsMTEzLjggOTIuOTg0LDExMy43OTUgOTIuOTY2LDExMy43ODUgQzkyLjkzMSwxMTMuNzY0IDkyLjkwOCwxMTMuNzI1IDkyLjkwOCwxMTMuNjg0IEw5Mi45MDgsNjIuODEzIEM5Mi45MDgsNjIuNzcxIDkyLjkzMSw2Mi43MzMgOTIuOTY2LDYyLjcxMiBMMTY4LjQ4NCwxOS4xMTIgQzE2OC41MiwxOS4wOSAxNjguNTY1LDE5LjA5IDE2OC42MDEsMTkuMTEyIEMxNjguNjM3LDE5LjEzMiAxNjguNjYsMTkuMTcxIDE2OC42NiwxOS4yMTIgTDE2OC42Niw3MC4wODMgQzE2OC42Niw3MC4xMjUgMTY4LjYzNyw3MC4xNjQgMTY4LjYwMSw3MC4xODQgTDE0MS4yOCw4NS45NTggQzE0MS4yNTEsODUuOTc1IDE0MS4yMTcsODUuOTc5IDE0MS4xODYsODUuOTY4IEMxNDEuMTU0LDg1Ljk1OCAxNDEuMTI5LDg1LjkzNiAxNDEuMTE1LDg1LjkwNiBMMTM0LjY1NSw3MS43MzggQzEzNC4yOCw3MC45MTUgMTMzLjU5Myw3MC40NjMgMTMyLjcyLDcwLjQ2MyBDMTMxLjYzMiw3MC40NjMgMTMwLjM1Nyw3MS4xNDggMTI5LjIyMSw3Mi4zNDQgQzEyOC4xODYsNzMuNDMzIDEyNy4zNDcsNzQuODgxIDEyNi45MTksNzYuMzE1IEwxMjAuNDU4LDk3Ljk0MyBDMTIwLjQ1LDk3Ljk3MiAxMjAuNDMxLDk3Ljk5NiAxMjAuNDA1LDk4LjAxIEw5My4wODMsMTEzLjc4NSBDOTMuMDY1LDExMy43OTUgOTMuMDQ1LDExMy44IDkzLjAyNSwxMTMuOCBMOTMuMDI1LDExMy44IFogTTkzLjE0Miw2Mi44ODEgTDkzLjE0MiwxMTMuNDgxIEwxMjAuMjQ4LDk3LjgzMiBMMTI2LjY5NSw3Ni4yNDggQzEyNy4xNCw3NC43NTggMTI3Ljk3Nyw3My4zMTUgMTI5LjA1Miw3Mi4xODMgQzEzMC4yMzEsNzAuOTQyIDEzMS41NjgsNzAuMjI5IDEzMi43Miw3MC4yMjkgQzEzMy42ODksNzAuMjI5IDEzNC40NTIsNzAuNzMxIDEzNC44NjcsNzEuNjQxIEwxNDEuMjc0LDg1LjY5MiBMMTY4LjQyNiw3MC4wMTYgTDE2OC40MjYsMTkuNDE1IEw5My4xNDIsNjIuODgxIEw5My4xNDIsNjIuODgxIFoiIGlkPSJGaWxsLTE2IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS44LDcwLjA4MyBMMTQyLjQ3OCw4NS44NTcgTDEzNi4wMTgsNzEuNjg5IEMxMzUuMTA4LDY5LjY5NCAxMzIuNTksNjkuOTUxIDEzMC4zOTMsNzIuMjYzIEMxMjkuMzM5LDczLjM3NCAxMjguNSw3NC44MTkgMTI4LjA2NCw3Ni4yODIgTDEyMS42MDMsOTcuOTA5IEw5NC4yODIsMTEzLjY4MyBMOTQuMjgyLDYyLjgxMyBMMTY5LjgsMTkuMjEzIEwxNjkuOCw3MC4wODMgWiIgaWQ9IkZpbGwtMTciIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTQuMjgyLDExMy45MTcgQzk0LjI0MSwxMTMuOTE3IDk0LjIwMSwxMTMuOTA3IDk0LjE2NSwxMTMuODg2IEM5NC4wOTMsMTEzLjg0NSA5NC4wNDgsMTEzLjc2NyA5NC4wNDgsMTEzLjY4NCBMOTQuMDQ4LDYyLjgxMyBDOTQuMDQ4LDYyLjczIDk0LjA5Myw2Mi42NTIgOTQuMTY1LDYyLjYxMSBMMTY5LjY4MywxOS4wMSBDMTY5Ljc1NSwxOC45NjkgMTY5Ljg0NCwxOC45NjkgMTY5LjkxNywxOS4wMSBDMTY5Ljk4OSwxOS4wNTIgMTcwLjAzMywxOS4xMjkgMTcwLjAzMywxOS4yMTIgTDE3MC4wMzMsNzAuMDgzIEMxNzAuMDMzLDcwLjE2NiAxNjkuOTg5LDcwLjI0NCAxNjkuOTE3LDcwLjI4NSBMMTQyLjU5NSw4Ni4wNiBDMTQyLjUzOCw4Ni4wOTIgMTQyLjQ2OSw4Ni4xIDE0Mi40MDcsODYuMDggQzE0Mi4zNDQsODYuMDYgMTQyLjI5Myw4Ni4wMTQgMTQyLjI2Niw4NS45NTQgTDEzNS44MDUsNzEuNzg2IEMxMzUuNDQ1LDcwLjk5NyAxMzQuODEzLDcwLjU4IDEzMy45NzcsNzAuNTggQzEzMi45MjEsNzAuNTggMTMxLjY3Niw3MS4yNTIgMTMwLjU2Miw3Mi40MjQgQzEyOS41NCw3My41MDEgMTI4LjcxMSw3NC45MzEgMTI4LjI4Nyw3Ni4zNDggTDEyMS44MjcsOTcuOTc2IEMxMjEuODEsOTguMDM0IDEyMS43NzEsOTguMDgyIDEyMS43Miw5OC4xMTIgTDk0LjM5OCwxMTMuODg2IEM5NC4zNjIsMTEzLjkwNyA5NC4zMjIsMTEzLjkxNyA5NC4yODIsMTEzLjkxNyBMOTQuMjgyLDExMy45MTcgWiBNOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDExMy4yNzkgTDEyMS40MDYsOTcuNzU0IEwxMjcuODQsNzYuMjE1IEMxMjguMjksNzQuNzA4IDEyOS4xMzcsNzMuMjQ3IDEzMC4yMjQsNzIuMTAzIEMxMzEuNDI1LDcwLjgzOCAxMzIuNzkzLDcwLjExMiAxMzMuOTc3LDcwLjExMiBDMTM0Ljk5NSw3MC4xMTIgMTM1Ljc5NSw3MC42MzggMTM2LjIzLDcxLjU5MiBMMTQyLjU4NCw4NS41MjYgTDE2OS41NjYsNjkuOTQ4IEwxNjkuNTY2LDE5LjYxNyBMOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDYyLjk0OCBaIiBpZD0iRmlsbC0xOCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMDkuODk0LDkyLjk0MyBMMTA5Ljg5NCw5Mi45NDMgQzEwOC4xMiw5Mi45NDMgMTA2LjY1Myw5Mi4yMTggMTA1LjY1LDkwLjgyMyBDMTA1LjU4Myw5MC43MzEgMTA1LjU5Myw5MC42MSAxMDUuNjczLDkwLjUyOSBDMTA1Ljc1Myw5MC40NDggMTA1Ljg4LDkwLjQ0IDEwNS45NzQsOTAuNTA2IEMxMDYuNzU0LDkxLjA1MyAxMDcuNjc5LDkxLjMzMyAxMDguNzI0LDkxLjMzMyBDMTEwLjA0Nyw5MS4zMzMgMTExLjQ3OCw5MC44OTQgMTEyLjk4LDkwLjAyNyBDMTE4LjI5MSw4Ni45NiAxMjIuNjExLDc5LjUwOSAxMjIuNjExLDczLjQxNiBDMTIyLjYxMSw3MS40ODkgMTIyLjE2OSw2OS44NTYgMTIxLjMzMyw2OC42OTIgQzEyMS4yNjYsNjguNiAxMjEuMjc2LDY4LjQ3MyAxMjEuMzU2LDY4LjM5MiBDMTIxLjQzNiw2OC4zMTEgMTIxLjU2Myw2OC4yOTkgMTIxLjY1Niw2OC4zNjUgQzEyMy4zMjcsNjkuNTM3IDEyNC4yNDcsNzEuNzQ2IDEyNC4yNDcsNzQuNTg0IEMxMjQuMjQ3LDgwLjgyNiAxMTkuODIxLDg4LjQ0NyAxMTQuMzgyLDkxLjU4NyBDMTEyLjgwOCw5Mi40OTUgMTExLjI5OCw5Mi45NDMgMTA5Ljg5NCw5Mi45NDMgTDEwOS44OTQsOTIuOTQzIFogTTEwNi45MjUsOTEuNDAxIEMxMDcuNzM4LDkyLjA1MiAxMDguNzQ1LDkyLjI3OCAxMDkuODkzLDkyLjI3OCBMMTA5Ljg5NCw5Mi4yNzggQzExMS4yMTUsOTIuMjc4IDExMi42NDcsOTEuOTUxIDExNC4xNDgsOTEuMDg0IEMxMTkuNDU5LDg4LjAxNyAxMjMuNzgsODAuNjIxIDEyMy43OCw3NC41MjggQzEyMy43OCw3Mi41NDkgMTIzLjMxNyw3MC45MjkgMTIyLjQ1NCw2OS43NjcgQzEyMi44NjUsNzAuODAyIDEyMy4wNzksNzIuMDQyIDEyMy4wNzksNzMuNDAyIEMxMjMuMDc5LDc5LjY0NSAxMTguNjUzLDg3LjI4NSAxMTMuMjE0LDkwLjQyNSBDMTExLjY0LDkxLjMzNCAxMTAuMTMsOTEuNzQyIDEwOC43MjQsOTEuNzQyIEMxMDguMDgzLDkxLjc0MiAxMDcuNDgxLDkxLjU5MyAxMDYuOTI1LDkxLjQwMSBMMTA2LjkyNSw5MS40MDEgWiIgaWQ9IkZpbGwtMTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjA5Nyw5MC4yMyBDMTE4LjQ4MSw4Ny4xMjIgMTIyLjg0NSw3OS41OTQgMTIyLjg0NSw3My40MTYgQzEyMi44NDUsNzEuMzY1IDEyMi4zNjIsNjkuNzI0IDEyMS41MjIsNjguNTU2IEMxMTkuNzM4LDY3LjMwNCAxMTcuMTQ4LDY3LjM2MiAxMTQuMjY1LDY5LjAyNiBDMTA4Ljg4MSw3Mi4xMzQgMTA0LjUxNyw3OS42NjIgMTA0LjUxNyw4NS44NCBDMTA0LjUxNyw4Ny44OTEgMTA1LDg5LjUzMiAxMDUuODQsOTAuNyBDMTA3LjYyNCw5MS45NTIgMTEwLjIxNCw5MS44OTQgMTEzLjA5Nyw5MC4yMyIgaWQ9IkZpbGwtMjAiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTA4LjcyNCw5MS42MTQgTDEwOC43MjQsOTEuNjE0IEMxMDcuNTgyLDkxLjYxNCAxMDYuNTY2LDkxLjQwMSAxMDUuNzA1LDkwLjc5NyBDMTA1LjY4NCw5MC43ODMgMTA1LjY2NSw5MC44MTEgMTA1LjY1LDkwLjc5IEMxMDQuNzU2LDg5LjU0NiAxMDQuMjgzLDg3Ljg0MiAxMDQuMjgzLDg1LjgxNyBDMTA0LjI4Myw3OS41NzUgMTA4LjcwOSw3MS45NTMgMTE0LjE0OCw2OC44MTIgQzExNS43MjIsNjcuOTA0IDExNy4yMzIsNjcuNDQ5IDExOC42MzgsNjcuNDQ5IEMxMTkuNzgsNjcuNDQ5IDEyMC43OTYsNjcuNzU4IDEyMS42NTYsNjguMzYyIEMxMjEuNjc4LDY4LjM3NyAxMjEuNjk3LDY4LjM5NyAxMjEuNzEyLDY4LjQxOCBDMTIyLjYwNiw2OS42NjIgMTIzLjA3OSw3MS4zOSAxMjMuMDc5LDczLjQxNSBDMTIzLjA3OSw3OS42NTggMTE4LjY1Myw4Ny4xOTggMTEzLjIxNCw5MC4zMzggQzExMS42NCw5MS4yNDcgMTEwLjEzLDkxLjYxNCAxMDguNzI0LDkxLjYxNCBMMTA4LjcyNCw5MS42MTQgWiBNMTA2LjAwNiw5MC41MDUgQzEwNi43OCw5MS4wMzcgMTA3LjY5NCw5MS4yODEgMTA4LjcyNCw5MS4yODEgQzExMC4wNDcsOTEuMjgxIDExMS40NzgsOTAuODY4IDExMi45OCw5MC4wMDEgQzExOC4yOTEsODYuOTM1IDEyMi42MTEsNzkuNDk2IDEyMi42MTEsNzMuNDAzIEMxMjIuNjExLDcxLjQ5NCAxMjIuMTc3LDY5Ljg4IDEyMS4zNTYsNjguNzE4IEMxMjAuNTgyLDY4LjE4NSAxMTkuNjY4LDY3LjkxOSAxMTguNjM4LDY3LjkxOSBDMTE3LjMxNSw2Ny45MTkgMTE1Ljg4Myw2OC4zNiAxMTQuMzgyLDY5LjIyNyBDMTA5LjA3MSw3Mi4yOTMgMTA0Ljc1MSw3OS43MzMgMTA0Ljc1MSw4NS44MjYgQzEwNC43NTEsODcuNzM1IDEwNS4xODUsODkuMzQzIDEwNi4wMDYsOTAuNTA1IEwxMDYuMDA2LDkwLjUwNSBaIiBpZD0iRmlsbC0yMSIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDkuMzE4LDcuMjYyIEwxMzkuMzM0LDE2LjE0IEwxNTUuMjI3LDI3LjE3MSBMMTYwLjgxNiwyMS4wNTkgTDE0OS4zMTgsNy4yNjIiIGlkPSJGaWxsLTIyIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS42NzYsMTMuODQgTDE1OS45MjgsMTkuNDY3IEMxNTYuMjg2LDIxLjU3IDE1MC40LDIxLjU4IDE0Ni43ODEsMTkuNDkxIEMxNDMuMTYxLDE3LjQwMiAxNDMuMTgsMTQuMDAzIDE0Ni44MjIsMTEuOSBMMTU2LjMxNyw2LjI5MiBMMTQ5LjU4OCwyLjQwNyBMNjcuNzUyLDQ5LjQ3OCBMMTEzLjY3NSw3NS45OTIgTDExNi43NTYsNzQuMjEzIEMxMTcuMzg3LDczLjg0OCAxMTcuNjI1LDczLjMxNSAxMTcuMzc0LDcyLjgyMyBDMTE1LjAxNyw2OC4xOTEgMTE0Ljc4MSw2My4yNzcgMTE2LjY5MSw1OC41NjEgQzEyMi4zMjksNDQuNjQxIDE0MS4yLDMzLjc0NiAxNjUuMzA5LDMwLjQ5MSBDMTczLjQ3OCwyOS4zODggMTgxLjk4OSwyOS41MjQgMTkwLjAxMywzMC44ODUgQzE5MC44NjUsMzEuMDMgMTkxLjc4OSwzMC44OTMgMTkyLjQyLDMwLjUyOCBMMTk1LjUwMSwyOC43NSBMMTY5LjY3NiwxMy44NCIgaWQ9IkZpbGwtMjMiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3Ni40NTkgQzExMy41OTQsNzYuNDU5IDExMy41MTQsNzYuNDM4IDExMy40NDIsNzYuMzk3IEw2Ny41MTgsNDkuODgyIEM2Ny4zNzQsNDkuNzk5IDY3LjI4NCw0OS42NDUgNjcuMjg1LDQ5LjQ3OCBDNjcuMjg1LDQ5LjMxMSA2Ny4zNzQsNDkuMTU3IDY3LjUxOSw0OS4wNzMgTDE0OS4zNTUsMi4wMDIgQzE0OS40OTksMS45MTkgMTQ5LjY3NywxLjkxOSAxNDkuODIxLDIuMDAyIEwxNTYuNTUsNS44ODcgQzE1Ni43NzQsNi4wMTcgMTU2Ljg1LDYuMzAyIDE1Ni43MjIsNi41MjYgQzE1Ni41OTIsNi43NDkgMTU2LjMwNyw2LjgyNiAxNTYuMDgzLDYuNjk2IEwxNDkuNTg3LDIuOTQ2IEw2OC42ODcsNDkuNDc5IEwxMTMuNjc1LDc1LjQ1MiBMMTE2LjUyMyw3My44MDggQzExNi43MTUsNzMuNjk3IDExNy4xNDMsNzMuMzk5IDExNi45NTgsNzMuMDM1IEMxMTQuNTQyLDY4LjI4NyAxMTQuMyw2My4yMjEgMTE2LjI1OCw1OC4zODUgQzExOS4wNjQsNTEuNDU4IDEyNS4xNDMsNDUuMTQzIDEzMy44NCw0MC4xMjIgQzE0Mi40OTcsMzUuMTI0IDE1My4zNTgsMzEuNjMzIDE2NS4yNDcsMzAuMDI4IEMxNzMuNDQ1LDI4LjkyMSAxODIuMDM3LDI5LjA1OCAxOTAuMDkxLDMwLjQyNSBDMTkwLjgzLDMwLjU1IDE5MS42NTIsMzAuNDMyIDE5Mi4xODYsMzAuMTI0IEwxOTQuNTY3LDI4Ljc1IEwxNjkuNDQyLDE0LjI0NCBDMTY5LjIxOSwxNC4xMTUgMTY5LjE0MiwxMy44MjkgMTY5LjI3MSwxMy42MDYgQzE2OS40LDEzLjM4MiAxNjkuNjg1LDEzLjMwNiAxNjkuOTA5LDEzLjQzNSBMMTk1LjczNCwyOC4zNDUgQzE5NS44NzksMjguNDI4IDE5NS45NjgsMjguNTgzIDE5NS45NjgsMjguNzUgQzE5NS45NjgsMjguOTE2IDE5NS44NzksMjkuMDcxIDE5NS43MzQsMjkuMTU0IEwxOTIuNjUzLDMwLjkzMyBDMTkxLjkzMiwzMS4zNSAxOTAuODksMzEuNTA4IDE4OS45MzUsMzEuMzQ2IEMxODEuOTcyLDI5Ljk5NSAxNzMuNDc4LDI5Ljg2IDE2NS4zNzIsMzAuOTU0IEMxNTMuNjAyLDMyLjU0MyAxNDIuODYsMzUuOTkzIDEzNC4zMDcsNDAuOTMxIEMxMjUuNzkzLDQ1Ljg0NyAxMTkuODUxLDUyLjAwNCAxMTcuMTI0LDU4LjczNiBDMTE1LjI3LDYzLjMxNCAxMTUuNTAxLDY4LjExMiAxMTcuNzksNzIuNjExIEMxMTguMTYsNzMuMzM2IDExNy44NDUsNzQuMTI0IDExNi45OSw3NC42MTcgTDExMy45MDksNzYuMzk3IEMxMTMuODM2LDc2LjQzOCAxMTMuNzU2LDc2LjQ1OSAxMTMuNjc1LDc2LjQ1OSIgaWQ9IkZpbGwtMjQiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUzLjMxNiwyMS4yNzkgQzE1MC45MDMsMjEuMjc5IDE0OC40OTUsMjAuNzUxIDE0Ni42NjQsMTkuNjkzIEMxNDQuODQ2LDE4LjY0NCAxNDMuODQ0LDE3LjIzMiAxNDMuODQ0LDE1LjcxOCBDMTQzLjg0NCwxNC4xOTEgMTQ0Ljg2LDEyLjc2MyAxNDYuNzA1LDExLjY5OCBMMTU2LjE5OCw2LjA5MSBDMTU2LjMwOSw2LjAyNSAxNTYuNDUyLDYuMDYyIDE1Ni41MTgsNi4xNzMgQzE1Ni41ODMsNi4yODQgMTU2LjU0Nyw2LjQyNyAxNTYuNDM2LDYuNDkzIEwxNDYuOTQsMTIuMTAyIEMxNDUuMjQ0LDEzLjA4MSAxNDQuMzEyLDE0LjM2NSAxNDQuMzEyLDE1LjcxOCBDMTQ0LjMxMiwxNy4wNTggMTQ1LjIzLDE4LjMyNiAxNDYuODk3LDE5LjI4OSBDMTUwLjQ0NiwyMS4zMzggMTU2LjI0LDIxLjMyNyAxNTkuODExLDE5LjI2NSBMMTY5LjU1OSwxMy42MzcgQzE2OS42NywxMy41NzMgMTY5LjgxMywxMy42MTEgMTY5Ljg3OCwxMy43MjMgQzE2OS45NDMsMTMuODM0IDE2OS45MDQsMTMuOTc3IDE2OS43OTMsMTQuMDQyIEwxNjAuMDQ1LDE5LjY3IEMxNTguMTg3LDIwLjc0MiAxNTUuNzQ5LDIxLjI3OSAxNTMuMzE2LDIxLjI3OSIgaWQ9IkZpbGwtMjUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3NS45OTIgTDY3Ljc2Miw0OS40ODQiIGlkPSJGaWxsLTI2IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMy42NzUsNzYuMzQyIEMxMTMuNjE1LDc2LjM0MiAxMTMuNTU1LDc2LjMyNyAxMTMuNSw3Ni4yOTUgTDY3LjU4Nyw0OS43ODcgQzY3LjQxOSw0OS42OSA2Ny4zNjIsNDkuNDc2IDY3LjQ1OSw0OS4zMDkgQzY3LjU1Niw0OS4xNDEgNjcuNzcsNDkuMDgzIDY3LjkzNyw0OS4xOCBMMTEzLjg1LDc1LjY4OCBDMTE0LjAxOCw3NS43ODUgMTE0LjA3NSw3NiAxMTMuOTc4LDc2LjE2NyBDMTEzLjkxNCw3Ni4yNzkgMTEzLjc5Niw3Ni4zNDIgMTEzLjY3NSw3Ni4zNDIiIGlkPSJGaWxsLTI3IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY3Ljc2Miw0OS40ODQgTDY3Ljc2MiwxMDMuNDg1IEM2Ny43NjIsMTA0LjU3NSA2OC41MzIsMTA1LjkwMyA2OS40ODIsMTA2LjQ1MiBMMTExLjk1NSwxMzAuOTczIEMxMTIuOTA1LDEzMS41MjIgMTEzLjY3NSwxMzEuMDgzIDExMy42NzUsMTI5Ljk5MyBMMTEzLjY3NSw3NS45OTIiIGlkPSJGaWxsLTI4IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMi43MjcsMTMxLjU2MSBDMTEyLjQzLDEzMS41NjEgMTEyLjEwNywxMzEuNDY2IDExMS43OCwxMzEuMjc2IEw2OS4zMDcsMTA2Ljc1NSBDNjguMjQ0LDEwNi4xNDIgNjcuNDEyLDEwNC43MDUgNjcuNDEyLDEwMy40ODUgTDY3LjQxMiw0OS40ODQgQzY3LjQxMiw0OS4yOSA2Ny41NjksNDkuMTM0IDY3Ljc2Miw0OS4xMzQgQzY3Ljk1Niw0OS4xMzQgNjguMTEzLDQ5LjI5IDY4LjExMyw0OS40ODQgTDY4LjExMywxMDMuNDg1IEM2OC4xMTMsMTA0LjQ0NSA2OC44MiwxMDUuNjY1IDY5LjY1NywxMDYuMTQ4IEwxMTIuMTMsMTMwLjY3IEMxMTIuNDc0LDEzMC44NjggMTEyLjc5MSwxMzAuOTEzIDExMywxMzAuNzkyIEMxMTMuMjA2LDEzMC42NzMgMTEzLjMyNSwxMzAuMzgxIDExMy4zMjUsMTI5Ljk5MyBMMTEzLjMyNSw3NS45OTIgQzExMy4zMjUsNzUuNzk4IDExMy40ODIsNzUuNjQxIDExMy42NzUsNzUuNjQxIEMxMTMuODY5LDc1LjY0MSAxMTQuMDI1LDc1Ljc5OCAxMTQuMDI1LDc1Ljk5MiBMMTE0LjAyNSwxMjkuOTkzIEMxMTQuMDI1LDEzMC42NDggMTEzLjc4NiwxMzEuMTQ3IDExMy4zNSwxMzEuMzk5IEMxMTMuMTYyLDEzMS41MDcgMTEyLjk1MiwxMzEuNTYxIDExMi43MjcsMTMxLjU2MSIgaWQ9IkZpbGwtMjkiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEyLjg2LDQwLjUxMiBDMTEyLjg2LDQwLjUxMiAxMTIuODYsNDAuNTEyIDExMi44NTksNDAuNTEyIEMxMTAuNTQxLDQwLjUxMiAxMDguMzYsMzkuOTkgMTA2LjcxNywzOS4wNDEgQzEwNS4wMTIsMzguMDU3IDEwNC4wNzQsMzYuNzI2IDEwNC4wNzQsMzUuMjkyIEMxMDQuMDc0LDMzLjg0NyAxMDUuMDI2LDMyLjUwMSAxMDYuNzU0LDMxLjUwNCBMMTE4Ljc5NSwyNC41NTEgQzEyMC40NjMsMjMuNTg5IDEyMi42NjksMjMuMDU4IDEyNS4wMDcsMjMuMDU4IEMxMjcuMzI1LDIzLjA1OCAxMjkuNTA2LDIzLjU4MSAxMzEuMTUsMjQuNTMgQzEzMi44NTQsMjUuNTE0IDEzMy43OTMsMjYuODQ1IDEzMy43OTMsMjguMjc4IEMxMzMuNzkzLDI5LjcyNCAxMzIuODQxLDMxLjA2OSAxMzEuMTEzLDMyLjA2NyBMMTE5LjA3MSwzOS4wMTkgQzExNy40MDMsMzkuOTgyIDExNS4xOTcsNDAuNTEyIDExMi44Niw0MC41MTIgTDExMi44Niw0MC41MTIgWiBNMTI1LjAwNywyMy43NTkgQzEyMi43OSwyMy43NTkgMTIwLjcwOSwyNC4yNTYgMTE5LjE0NiwyNS4xNTggTDEwNy4xMDQsMzIuMTEgQzEwNS42MDIsMzIuOTc4IDEwNC43NzQsMzQuMTA4IDEwNC43NzQsMzUuMjkyIEMxMDQuNzc0LDM2LjQ2NSAxMDUuNTg5LDM3LjU4MSAxMDcuMDY3LDM4LjQzNCBDMTA4LjYwNSwzOS4zMjMgMTEwLjY2MywzOS44MTIgMTEyLjg1OSwzOS44MTIgTDExMi44NiwzOS44MTIgQzExNS4wNzYsMzkuODEyIDExNy4xNTgsMzkuMzE1IDExOC43MjEsMzguNDEzIEwxMzAuNzYyLDMxLjQ2IEMxMzIuMjY0LDMwLjU5MyAxMzMuMDkyLDI5LjQ2MyAxMzMuMDkyLDI4LjI3OCBDMTMzLjA5MiwyNy4xMDYgMTMyLjI3OCwyNS45OSAxMzAuOCwyNS4xMzYgQzEyOS4yNjEsMjQuMjQ4IDEyNy4yMDQsMjMuNzU5IDEyNS4wMDcsMjMuNzU5IEwxMjUuMDA3LDIzLjc1OSBaIiBpZD0iRmlsbC0zMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNjUuNjMsMTYuMjE5IEwxNTkuODk2LDE5LjUzIEMxNTYuNzI5LDIxLjM1OCAxNTEuNjEsMjEuMzY3IDE0OC40NjMsMTkuNTUgQzE0NS4zMTYsMTcuNzMzIDE0NS4zMzIsMTQuNzc4IDE0OC40OTksMTIuOTQ5IEwxNTQuMjMzLDkuNjM5IEwxNjUuNjMsMTYuMjE5IiBpZD0iRmlsbC0zMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNTQuMjMzLDEwLjQ0OCBMMTY0LjIyOCwxNi4yMTkgTDE1OS41NDYsMTguOTIzIEMxNTguMTEyLDE5Ljc1IDE1Ni4xOTQsMjAuMjA2IDE1NC4xNDcsMjAuMjA2IEMxNTIuMTE4LDIwLjIwNiAxNTAuMjI0LDE5Ljc1NyAxNDguODE0LDE4Ljk0MyBDMTQ3LjUyNCwxOC4xOTkgMTQ2LjgxNCwxNy4yNDkgMTQ2LjgxNCwxNi4yNjkgQzE0Ni44MTQsMTUuMjc4IDE0Ny41MzcsMTQuMzE0IDE0OC44NSwxMy41NTYgTDE1NC4yMzMsMTAuNDQ4IE0xNTQuMjMzLDkuNjM5IEwxNDguNDk5LDEyLjk0OSBDMTQ1LjMzMiwxNC43NzggMTQ1LjMxNiwxNy43MzMgMTQ4LjQ2MywxOS41NSBDMTUwLjAzMSwyMC40NTUgMTUyLjA4NiwyMC45MDcgMTU0LjE0NywyMC45MDcgQzE1Ni4yMjQsMjAuOTA3IDE1OC4zMDYsMjAuNDQ3IDE1OS44OTYsMTkuNTMgTDE2NS42MywxNi4yMTkgTDE1NC4yMzMsOS42MzkiIGlkPSJGaWxsLTMyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NS40NDUsNzIuNjY3IEwxNDUuNDQ1LDcyLjY2NyBDMTQzLjY3Miw3Mi42NjcgMTQyLjIwNCw3MS44MTcgMTQxLjIwMiw3MC40MjIgQzE0MS4xMzUsNzAuMzMgMTQxLjE0NSw3MC4xNDcgMTQxLjIyNSw3MC4wNjYgQzE0MS4zMDUsNjkuOTg1IDE0MS40MzIsNjkuOTQ2IDE0MS41MjUsNzAuMDExIEMxNDIuMzA2LDcwLjU1OSAxNDMuMjMxLDcwLjgyMyAxNDQuMjc2LDcwLjgyMiBDMTQ1LjU5OCw3MC44MjIgMTQ3LjAzLDcwLjM3NiAxNDguNTMyLDY5LjUwOSBDMTUzLjg0Miw2Ni40NDMgMTU4LjE2Myw1OC45ODcgMTU4LjE2Myw1Mi44OTQgQzE1OC4xNjMsNTAuOTY3IDE1Ny43MjEsNDkuMzMyIDE1Ni44ODQsNDguMTY4IEMxNTYuODE4LDQ4LjA3NiAxNTYuODI4LDQ3Ljk0OCAxNTYuOTA4LDQ3Ljg2NyBDMTU2Ljk4OCw0Ny43ODYgMTU3LjExNCw0Ny43NzQgMTU3LjIwOCw0Ny44NCBDMTU4Ljg3OCw0OS4wMTIgMTU5Ljc5OCw1MS4yMiAxNTkuNzk4LDU0LjA1OSBDMTU5Ljc5OCw2MC4zMDEgMTU1LjM3Myw2OC4wNDYgMTQ5LjkzMyw3MS4xODYgQzE0OC4zNiw3Mi4wOTQgMTQ2Ljg1LDcyLjY2NyAxNDUuNDQ1LDcyLjY2NyBMMTQ1LjQ0NSw3Mi42NjcgWiBNMTQyLjQ3Niw3MSBDMTQzLjI5LDcxLjY1MSAxNDQuMjk2LDcyLjAwMiAxNDUuNDQ1LDcyLjAwMiBDMTQ2Ljc2Nyw3Mi4wMDIgMTQ4LjE5OCw3MS41NSAxNDkuNyw3MC42ODIgQzE1NS4wMSw2Ny42MTcgMTU5LjMzMSw2MC4xNTkgMTU5LjMzMSw1NC4wNjUgQzE1OS4zMzEsNTIuMDg1IDE1OC44NjgsNTAuNDM1IDE1OC4wMDYsNDkuMjcyIEMxNTguNDE3LDUwLjMwNyAxNTguNjMsNTEuNTMyIDE1OC42Myw1Mi44OTIgQzE1OC42Myw1OS4xMzQgMTU0LjIwNSw2Ni43NjcgMTQ4Ljc2NSw2OS45MDcgQzE0Ny4xOTIsNzAuODE2IDE0NS42ODEsNzEuMjgzIDE0NC4yNzYsNzEuMjgzIEMxNDMuNjM0LDcxLjI4MyAxNDMuMDMzLDcxLjE5MiAxNDIuNDc2LDcxIEwxNDIuNDc2LDcxIFoiIGlkPSJGaWxsLTMzIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0OC42NDgsNjkuNzA0IEMxNTQuMDMyLDY2LjU5NiAxNTguMzk2LDU5LjA2OCAxNTguMzk2LDUyLjg5MSBDMTU4LjM5Niw1MC44MzkgMTU3LjkxMyw0OS4xOTggMTU3LjA3NCw0OC4wMyBDMTU1LjI4OSw0Ni43NzggMTUyLjY5OSw0Ni44MzYgMTQ5LjgxNiw0OC41MDEgQzE0NC40MzMsNTEuNjA5IDE0MC4wNjgsNTkuMTM3IDE0MC4wNjgsNjUuMzE0IEMxNDAuMDY4LDY3LjM2NSAxNDAuNTUyLDY5LjAwNiAxNDEuMzkxLDcwLjE3NCBDMTQzLjE3Niw3MS40MjcgMTQ1Ljc2NSw3MS4zNjkgMTQ4LjY0OCw2OS43MDQiIGlkPSJGaWxsLTM0IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NC4yNzYsNzEuMjc2IEwxNDQuMjc2LDcxLjI3NiBDMTQzLjEzMyw3MS4yNzYgMTQyLjExOCw3MC45NjkgMTQxLjI1Nyw3MC4zNjUgQzE0MS4yMzYsNzAuMzUxIDE0MS4yMTcsNzAuMzMyIDE0MS4yMDIsNzAuMzExIEMxNDAuMzA3LDY5LjA2NyAxMzkuODM1LDY3LjMzOSAxMzkuODM1LDY1LjMxNCBDMTM5LjgzNSw1OS4wNzMgMTQ0LjI2LDUxLjQzOSAxNDkuNyw0OC4yOTggQzE1MS4yNzMsNDcuMzkgMTUyLjc4NCw0Ni45MjkgMTU0LjE4OSw0Ni45MjkgQzE1NS4zMzIsNDYuOTI5IDE1Ni4zNDcsNDcuMjM2IDE1Ny4yMDgsNDcuODM5IEMxNTcuMjI5LDQ3Ljg1NCAxNTcuMjQ4LDQ3Ljg3MyAxNTcuMjYzLDQ3Ljg5NCBDMTU4LjE1Nyw0OS4xMzggMTU4LjYzLDUwLjg2NSAxNTguNjMsNTIuODkxIEMxNTguNjMsNTkuMTMyIDE1NC4yMDUsNjYuNzY2IDE0OC43NjUsNjkuOTA3IEMxNDcuMTkyLDcwLjgxNSAxNDUuNjgxLDcxLjI3NiAxNDQuMjc2LDcxLjI3NiBMMTQ0LjI3Niw3MS4yNzYgWiBNMTQxLjU1OCw3MC4xMDQgQzE0Mi4zMzEsNzAuNjM3IDE0My4yNDUsNzEuMDA1IDE0NC4yNzYsNzEuMDA1IEMxNDUuNTk4LDcxLjAwNSAxNDcuMDMsNzAuNDY3IDE0OC41MzIsNjkuNiBDMTUzLjg0Miw2Ni41MzQgMTU4LjE2Myw1OS4wMzMgMTU4LjE2Myw1Mi45MzkgQzE1OC4xNjMsNTEuMDMxIDE1Ny43MjksNDkuMzg1IDE1Ni45MDcsNDguMjIzIEMxNTYuMTMzLDQ3LjY5MSAxNTUuMjE5LDQ3LjQwOSAxNTQuMTg5LDQ3LjQwOSBDMTUyLjg2Nyw0Ny40MDkgMTUxLjQzNSw0Ny44NDIgMTQ5LjkzMyw0OC43MDkgQzE0NC42MjMsNTEuNzc1IDE0MC4zMDIsNTkuMjczIDE0MC4zMDIsNjUuMzY2IEMxNDAuMzAyLDY3LjI3NiAxNDAuNzM2LDY4Ljk0MiAxNDEuNTU4LDcwLjEwNCBMMTQxLjU1OCw3MC4xMDQgWiIgaWQ9IkZpbGwtMzUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUwLjcyLDY1LjM2MSBMMTUwLjM1Nyw2NS4wNjYgQzE1MS4xNDcsNjQuMDkyIDE1MS44NjksNjMuMDQgMTUyLjUwNSw2MS45MzggQzE1My4zMTMsNjAuNTM5IDE1My45NzgsNTkuMDY3IDE1NC40ODIsNTcuNTYzIEwxNTQuOTI1LDU3LjcxMiBDMTU0LjQxMiw1OS4yNDUgMTUzLjczMyw2MC43NDUgMTUyLjkxLDYyLjE3MiBDMTUyLjI2Miw2My4yOTUgMTUxLjUyNSw2NC4zNjggMTUwLjcyLDY1LjM2MSIgaWQ9IkZpbGwtMzYiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE1LjkxNyw4NC41MTQgTDExNS41NTQsODQuMjIgQzExNi4zNDQsODMuMjQ1IDExNy4wNjYsODIuMTk0IDExNy43MDIsODEuMDkyIEMxMTguNTEsNzkuNjkyIDExOS4xNzUsNzguMjIgMTE5LjY3OCw3Ni43MTcgTDEyMC4xMjEsNzYuODY1IEMxMTkuNjA4LDc4LjM5OCAxMTguOTMsNzkuODk5IDExOC4xMDYsODEuMzI2IEMxMTcuNDU4LDgyLjQ0OCAxMTYuNzIyLDgzLjUyMSAxMTUuOTE3LDg0LjUxNCIgaWQ9IkZpbGwtMzciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE0LDEzMC40NzYgTDExNCwxMzAuMDA4IEwxMTQsNzYuMDUyIEwxMTQsNzUuNTg0IEwxMTQsNzYuMDUyIEwxMTQsMTMwLjAwOCBMMTE0LDEzMC40NzYiIGlkPSJGaWxsLTM4IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYyLjAwMDAwMCwgMC4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTkuODIyLDM3LjQ3NCBDMTkuODM5LDM3LjMzOSAxOS43NDcsMzcuMTk0IDE5LjU1NSwzNy4wODIgQzE5LjIyOCwzNi44OTQgMTguNzI5LDM2Ljg3MiAxOC40NDYsMzcuMDM3IEwxMi40MzQsNDAuNTA4IEMxMi4zMDMsNDAuNTg0IDEyLjI0LDQwLjY4NiAxMi4yNDMsNDAuNzkzIEMxMi4yNDUsNDAuOTI1IDEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQxLjM3MSBMMTIuMjQ1LDQxLjQxNCBMMTIuMjM4LDQxLjU0MiBDOC4xNDgsNDMuODg3IDUuNjQ3LDQ1LjMyMSA1LjY0Nyw0NS4zMjEgQzUuNjQ2LDQ1LjMyMSAzLjU3LDQ2LjM2NyAyLjg2LDUwLjUxMyBDMi44Niw1MC41MTMgMS45NDgsNTcuNDc0IDEuOTYyLDcwLjI1OCBDMS45NzcsODIuODI4IDIuNTY4LDg3LjMyOCAzLjEyOSw5MS42MDkgQzMuMzQ5LDkzLjI5MyA2LjEzLDkzLjczNCA2LjEzLDkzLjczNCBDNi40NjEsOTMuNzc0IDYuODI4LDkzLjcwNyA3LjIxLDkzLjQ4NiBMODIuNDgzLDQ5LjkzNSBDODQuMjkxLDQ4Ljg2NiA4NS4xNSw0Ni4yMTYgODUuNTM5LDQzLjY1MSBDODYuNzUyLDM1LjY2MSA4Ny4yMTQsMTAuNjczIDg1LjI2NCwzLjc3MyBDODUuMDY4LDMuMDggODQuNzU0LDIuNjkgODQuMzk2LDIuNDkxIEw4Mi4zMSwxLjcwMSBDODEuNTgzLDEuNzI5IDgwLjg5NCwyLjE2OCA4MC43NzYsMi4yMzYgQzgwLjYzNiwyLjMxNyA0MS44MDcsMjQuNTg1IDIwLjAzMiwzNy4wNzIgTDE5LjgyMiwzNy40NzQiIGlkPSJGaWxsLTEiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNODIuMzExLDEuNzAxIEw4NC4zOTYsMi40OTEgQzg0Ljc1NCwyLjY5IDg1LjA2OCwzLjA4IDg1LjI2NCwzLjc3MyBDODcuMjEzLDEwLjY3MyA4Ni43NTEsMzUuNjYgODUuNTM5LDQzLjY1MSBDODUuMTQ5LDQ2LjIxNiA4NC4yOSw0OC44NjYgODIuNDgzLDQ5LjkzNSBMNy4yMSw5My40ODYgQzYuODk3LDkzLjY2NyA2LjU5NSw5My43NDQgNi4zMTQsOTMuNzQ0IEw2LjEzMSw5My43MzMgQzYuMTMxLDkzLjczNCAzLjM0OSw5My4yOTMgMy4xMjgsOTEuNjA5IEMyLjU2OCw4Ny4zMjcgMS45NzcsODIuODI4IDEuOTYzLDcwLjI1OCBDMS45NDgsNTcuNDc0IDIuODYsNTAuNTEzIDIuODYsNTAuNTEzIEMzLjU3LDQ2LjM2NyA1LjY0Nyw0NS4zMjEgNS42NDcsNDUuMzIxIEM1LjY0Nyw0NS4zMjEgOC4xNDgsNDMuODg3IDEyLjIzOCw0MS41NDIgTDEyLjI0NSw0MS40MTQgTDEyLjI0NSw0MS4zNzEgQzEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQwLjkyNSAxMi4yNDMsNDAuNzkzIEMxMi4yNCw0MC42ODYgMTIuMzAyLDQwLjU4MyAxMi40MzQsNDAuNTA4IEwxOC40NDYsMzcuMDM2IEMxOC41NzQsMzYuOTYyIDE4Ljc0NiwzNi45MjYgMTguOTI3LDM2LjkyNiBDMTkuMTQ1LDM2LjkyNiAxOS4zNzYsMzYuOTc5IDE5LjU1NCwzNy4wODIgQzE5Ljc0NywzNy4xOTQgMTkuODM5LDM3LjM0IDE5LjgyMiwzNy40NzQgTDIwLjAzMywzNy4wNzIgQzQxLjgwNiwyNC41ODUgODAuNjM2LDIuMzE4IDgwLjc3NywyLjIzNiBDODAuODk0LDIuMTY4IDgxLjU4MywxLjcyOSA4Mi4zMTEsMS43MDEgTTgyLjMxMSwwLjcwNCBMODIuMjcyLDAuNzA1IEM4MS42NTQsMC43MjggODAuOTg5LDAuOTQ5IDgwLjI5OCwxLjM2MSBMODAuMjc3LDEuMzczIEM4MC4xMjksMS40NTggNTkuNzY4LDEzLjEzNSAxOS43NTgsMzYuMDc5IEMxOS41LDM1Ljk4MSAxOS4yMTQsMzUuOTI5IDE4LjkyNywzNS45MjkgQzE4LjU2MiwzNS45MjkgMTguMjIzLDM2LjAxMyAxNy45NDcsMzYuMTczIEwxMS45MzUsMzkuNjQ0IEMxMS40OTMsMzkuODk5IDExLjIzNiw0MC4zMzQgMTEuMjQ2LDQwLjgxIEwxMS4yNDcsNDAuOTYgTDUuMTY3LDQ0LjQ0NyBDNC43OTQsNDQuNjQ2IDIuNjI1LDQ1Ljk3OCAxLjg3Nyw1MC4zNDUgTDEuODcxLDUwLjM4NCBDMS44NjIsNTAuNDU0IDAuOTUxLDU3LjU1NyAwLjk2NSw3MC4yNTkgQzAuOTc5LDgyLjg3OSAxLjU2OCw4Ny4zNzUgMi4xMzcsOTEuNzI0IEwyLjEzOSw5MS43MzkgQzIuNDQ3LDk0LjA5NCA1LjYxNCw5NC42NjIgNS45NzUsOTQuNzE5IEw2LjAwOSw5NC43MjMgQzYuMTEsOTQuNzM2IDYuMjEzLDk0Ljc0MiA2LjMxNCw5NC43NDIgQzYuNzksOTQuNzQyIDcuMjYsOTQuNjEgNy43MSw5NC4zNSBMODIuOTgzLDUwLjc5OCBDODQuNzk0LDQ5LjcyNyA4NS45ODIsNDcuMzc1IDg2LjUyNSw0My44MDEgQzg3LjcxMSwzNS45ODcgODguMjU5LDEwLjcwNSA4Ni4yMjQsMy41MDIgQzg1Ljk3MSwyLjYwOSA4NS41MiwxLjk3NSA4NC44ODEsMS42MiBMODQuNzQ5LDEuNTU4IEw4Mi42NjQsMC43NjkgQzgyLjU1MSwwLjcyNSA4Mi40MzEsMC43MDQgODIuMzExLDAuNzA0IiBpZD0iRmlsbC0yIiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY2LjI2NywxMS41NjUgTDY3Ljc2MiwxMS45OTkgTDExLjQyMyw0NC4zMjUiIGlkPSJGaWxsLTMiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMjAyLDkwLjU0NSBDMTIuMDI5LDkwLjU0NSAxMS44NjIsOTAuNDU1IDExLjc2OSw5MC4yOTUgQzExLjYzMiw5MC4wNTcgMTEuNzEzLDg5Ljc1MiAxMS45NTIsODkuNjE0IEwzMC4zODksNzguOTY5IEMzMC42MjgsNzguODMxIDMwLjkzMyw3OC45MTMgMzEuMDcxLDc5LjE1MiBDMzEuMjA4LDc5LjM5IDMxLjEyNyw3OS42OTYgMzAuODg4LDc5LjgzMyBMMTIuNDUxLDkwLjQ3OCBMMTIuMjAyLDkwLjU0NSIgaWQ9IkZpbGwtNCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMy43NjQsNDIuNjU0IEwxMy42NTYsNDIuNTkyIEwxMy43MDIsNDIuNDIxIEwxOC44MzcsMzkuNDU3IEwxOS4wMDcsMzkuNTAyIEwxOC45NjIsMzkuNjczIEwxMy44MjcsNDIuNjM3IEwxMy43NjQsNDIuNjU0IiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTguNTIsOTAuMzc1IEw4LjUyLDQ2LjQyMSBMOC41ODMsNDYuMzg1IEw3NS44NCw3LjU1NCBMNzUuODQsNTEuNTA4IEw3NS43NzgsNTEuNTQ0IEw4LjUyLDkwLjM3NSBMOC41Miw5MC4zNzUgWiBNOC43Nyw0Ni41NjQgTDguNzcsODkuOTQ0IEw3NS41OTEsNTEuMzY1IEw3NS41OTEsNy45ODUgTDguNzcsNDYuNTY0IEw4Ljc3LDQ2LjU2NCBaIiBpZD0iRmlsbC02IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI0Ljk4Niw4My4xODIgQzI0Ljc1Niw4My4zMzEgMjQuMzc0LDgzLjU2NiAyNC4xMzcsODMuNzA1IEwxMi42MzIsOTAuNDA2IEMxMi4zOTUsOTAuNTQ1IDEyLjQyNiw5MC42NTggMTIuNyw5MC42NTggTDEzLjI2NSw5MC42NTggQzEzLjU0LDkwLjY1OCAxMy45NTgsOTAuNTQ1IDE0LjE5NSw5MC40MDYgTDI1LjcsODMuNzA1IEMyNS45MzcsODMuNTY2IDI2LjEyOCw4My40NTIgMjYuMTI1LDgzLjQ0OSBDMjYuMTIyLDgzLjQ0NyAyNi4xMTksODMuMjIgMjYuMTE5LDgyLjk0NiBDMjYuMTE5LDgyLjY3MiAyNS45MzEsODIuNTY5IDI1LjcwMSw4Mi43MTkgTDI0Ljk4Niw4My4xODIiIGlkPSJGaWxsLTciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuMjY2LDkwLjc4MiBMMTIuNyw5MC43ODIgQzEyLjUsOTAuNzgyIDEyLjM4NCw5MC43MjYgMTIuMzU0LDkwLjYxNiBDMTIuMzI0LDkwLjUwNiAxMi4zOTcsOTAuMzk5IDEyLjU2OSw5MC4yOTkgTDI0LjA3NCw4My41OTcgQzI0LjMxLDgzLjQ1OSAyNC42ODksODMuMjI2IDI0LjkxOCw4My4wNzggTDI1LjYzMyw4Mi42MTQgQzI1LjcyMyw4Mi41NTUgMjUuODEzLDgyLjUyNSAyNS44OTksODIuNTI1IEMyNi4wNzEsODIuNTI1IDI2LjI0NCw4Mi42NTUgMjYuMjQ0LDgyLjk0NiBDMjYuMjQ0LDgzLjE2IDI2LjI0NSw4My4zMDkgMjYuMjQ3LDgzLjM4MyBMMjYuMjUzLDgzLjM4NyBMMjYuMjQ5LDgzLjQ1NiBDMjYuMjQ2LDgzLjUzMSAyNi4yNDYsODMuNTMxIDI1Ljc2Myw4My44MTIgTDE0LjI1OCw5MC41MTQgQzE0LDkwLjY2NSAxMy41NjQsOTAuNzgyIDEzLjI2Niw5MC43ODIgTDEzLjI2Niw5MC43ODIgWiBNMTIuNjY2LDkwLjUzMiBMMTIuNyw5MC41MzMgTDEzLjI2Niw5MC41MzMgQzEzLjUxOCw5MC41MzMgMTMuOTE1LDkwLjQyNSAxNC4xMzIsOTAuMjk5IEwyNS42MzcsODMuNTk3IEMyNS44MDUsODMuNDk5IDI1LjkzMSw4My40MjQgMjUuOTk4LDgzLjM4MyBDMjUuOTk0LDgzLjI5OSAyNS45OTQsODMuMTY1IDI1Ljk5NCw4Mi45NDYgTDI1Ljg5OSw4Mi43NzUgTDI1Ljc2OCw4Mi44MjQgTDI1LjA1NCw4My4yODcgQzI0LjgyMiw4My40MzcgMjQuNDM4LDgzLjY3MyAyNC4yLDgzLjgxMiBMMTIuNjk1LDkwLjUxNCBMMTIuNjY2LDkwLjUzMiBMMTIuNjY2LDkwLjUzMiBaIiBpZD0iRmlsbC04IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzLjI2Niw4OS44NzEgTDEyLjcsODkuODcxIEMxMi41LDg5Ljg3MSAxMi4zODQsODkuODE1IDEyLjM1NCw4OS43MDUgQzEyLjMyNCw4OS41OTUgMTIuMzk3LDg5LjQ4OCAxMi41NjksODkuMzg4IEwyNC4wNzQsODIuNjg2IEMyNC4zMzIsODIuNTM1IDI0Ljc2OCw4Mi40MTggMjUuMDY3LDgyLjQxOCBMMjUuNjMyLDgyLjQxOCBDMjUuODMyLDgyLjQxOCAyNS45NDgsODIuNDc0IDI1Ljk3OCw4Mi41ODQgQzI2LjAwOCw4Mi42OTQgMjUuOTM1LDgyLjgwMSAyNS43NjMsODIuOTAxIEwxNC4yNTgsODkuNjAzIEMxNCw4OS43NTQgMTMuNTY0LDg5Ljg3MSAxMy4yNjYsODkuODcxIEwxMy4yNjYsODkuODcxIFogTTEyLjY2Niw4OS42MjEgTDEyLjcsODkuNjIyIEwxMy4yNjYsODkuNjIyIEMxMy41MTgsODkuNjIyIDEzLjkxNSw4OS41MTUgMTQuMTMyLDg5LjM4OCBMMjUuNjM3LDgyLjY4NiBMMjUuNjY3LDgyLjY2OCBMMjUuNjMyLDgyLjY2NyBMMjUuMDY3LDgyLjY2NyBDMjQuODE1LDgyLjY2NyAyNC40MTgsODIuNzc1IDI0LjIsODIuOTAxIEwxMi42OTUsODkuNjAzIEwxMi42NjYsODkuNjIxIEwxMi42NjYsODkuNjIxIFoiIGlkPSJGaWxsLTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzcsOTAuODAxIEwxMi4zNyw4OS41NTQgTDEyLjM3LDkwLjgwMSIgaWQ9IkZpbGwtMTAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi4xMyw5My45MDEgQzUuMzc5LDkzLjgwOCA0LjgxNiw5My4xNjQgNC42OTEsOTIuNTI1IEMzLjg2LDg4LjI4NyAzLjU0LDgzLjc0MyAzLjUyNiw3MS4xNzMgQzMuNTExLDU4LjM4OSA0LjQyMyw1MS40MjggNC40MjMsNTEuNDI4IEM1LjEzNCw0Ny4yODIgNy4yMSw0Ni4yMzYgNy4yMSw0Ni4yMzYgQzcuMjEsNDYuMjM2IDgxLjY2NywzLjI1IDgyLjA2OSwzLjAxNyBDODIuMjkyLDIuODg4IDg0LjU1NiwxLjQzMyA4NS4yNjQsMy45NCBDODcuMjE0LDEwLjg0IDg2Ljc1MiwzNS44MjcgODUuNTM5LDQzLjgxOCBDODUuMTUsNDYuMzgzIDg0LjI5MSw0OS4wMzMgODIuNDgzLDUwLjEwMSBMNy4yMSw5My42NTMgQzYuODI4LDkzLjg3NCA2LjQ2MSw5My45NDEgNi4xMyw5My45MDEgQzYuMTMsOTMuOTAxIDMuMzQ5LDkzLjQ2IDMuMTI5LDkxLjc3NiBDMi41NjgsODcuNDk1IDEuOTc3LDgyLjk5NSAxLjk2Miw3MC40MjUgQzEuOTQ4LDU3LjY0MSAyLjg2LDUwLjY4IDIuODYsNTAuNjggQzMuNTcsNDYuNTM0IDUuNjQ3LDQ1LjQ4OSA1LjY0Nyw0NS40ODkgQzUuNjQ2LDQ1LjQ4OSA4LjA2NSw0NC4wOTIgMTIuMjQ1LDQxLjY3OSBMMTMuMTE2LDQxLjU2IEwxOS43MTUsMzcuNzMgTDE5Ljc2MSwzNy4yNjkgTDYuMTMsOTMuOTAxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjMxNyw5NC4xNjEgTDYuMTAyLDk0LjE0OCBMNi4xMDEsOTQuMTQ4IEw1Ljg1Nyw5NC4xMDEgQzUuMTM4LDkzLjk0NSAzLjA4NSw5My4zNjUgMi44ODEsOTEuODA5IEMyLjMxMyw4Ny40NjkgMS43MjcsODIuOTk2IDEuNzEzLDcwLjQyNSBDMS42OTksNTcuNzcxIDIuNjA0LDUwLjcxOCAyLjYxMyw1MC42NDggQzMuMzM4LDQ2LjQxNyA1LjQ0NSw0NS4zMSA1LjUzNSw0NS4yNjYgTDEyLjE2Myw0MS40MzkgTDEzLjAzMyw0MS4zMiBMMTkuNDc5LDM3LjU3OCBMMTkuNTEzLDM3LjI0NCBDMTkuNTI2LDM3LjEwNyAxOS42NDcsMzcuMDA4IDE5Ljc4NiwzNy4wMjEgQzE5LjkyMiwzNy4wMzQgMjAuMDIzLDM3LjE1NiAyMC4wMDksMzcuMjkzIEwxOS45NSwzNy44ODIgTDEzLjE5OCw0MS44MDEgTDEyLjMyOCw0MS45MTkgTDUuNzcyLDQ1LjcwNCBDNS43NDEsNDUuNzIgMy43ODIsNDYuNzcyIDMuMTA2LDUwLjcyMiBDMy4wOTksNTAuNzgyIDIuMTk4LDU3LjgwOCAyLjIxMiw3MC40MjQgQzIuMjI2LDgyLjk2MyAyLjgwOSw4Ny40MiAzLjM3Myw5MS43MjkgQzMuNDY0LDkyLjQyIDQuMDYyLDkyLjg4MyA0LjY4Miw5My4xODEgQzQuNTY2LDkyLjk4NCA0LjQ4Niw5Mi43NzYgNC40NDYsOTIuNTcyIEMzLjY2NSw4OC41ODggMy4yOTEsODQuMzcgMy4yNzYsNzEuMTczIEMzLjI2Miw1OC41MiA0LjE2Nyw1MS40NjYgNC4xNzYsNTEuMzk2IEM0LjkwMSw0Ny4xNjUgNy4wMDgsNDYuMDU5IDcuMDk4LDQ2LjAxNCBDNy4wOTQsNDYuMDE1IDgxLjU0MiwzLjAzNCA4MS45NDQsMi44MDIgTDgxLjk3MiwyLjc4NSBDODIuODc2LDIuMjQ3IDgzLjY5MiwyLjA5NyA4NC4zMzIsMi4zNTIgQzg0Ljg4NywyLjU3MyA4NS4yODEsMy4wODUgODUuNTA0LDMuODcyIEM4Ny41MTgsMTEgODYuOTY0LDM2LjA5MSA4NS43ODUsNDMuODU1IEM4NS4yNzgsNDcuMTk2IDg0LjIxLDQ5LjM3IDgyLjYxLDUwLjMxNyBMNy4zMzUsOTMuODY5IEM2Ljk5OSw5NC4wNjMgNi42NTgsOTQuMTYxIDYuMzE3LDk0LjE2MSBMNi4zMTcsOTQuMTYxIFogTTYuMTcsOTMuNjU0IEM2LjQ2Myw5My42OSA2Ljc3NCw5My42MTcgNy4wODUsOTMuNDM3IEw4Mi4zNTgsNDkuODg2IEM4NC4xODEsNDguODA4IDg0Ljk2LDQ1Ljk3MSA4NS4yOTIsNDMuNzggQzg2LjQ2NiwzNi4wNDkgODcuMDIzLDExLjA4NSA4NS4wMjQsNC4wMDggQzg0Ljg0NiwzLjM3NyA4NC41NTEsMi45NzYgODQuMTQ4LDIuODE2IEM4My42NjQsMi42MjMgODIuOTgyLDIuNzY0IDgyLjIyNywzLjIxMyBMODIuMTkzLDMuMjM0IEM4MS43OTEsMy40NjYgNy4zMzUsNDYuNDUyIDcuMzM1LDQ2LjQ1MiBDNy4zMDQsNDYuNDY5IDUuMzQ2LDQ3LjUyMSA0LjY2OSw1MS40NzEgQzQuNjYyLDUxLjUzIDMuNzYxLDU4LjU1NiAzLjc3NSw3MS4xNzMgQzMuNzksODQuMzI4IDQuMTYxLDg4LjUyNCA0LjkzNiw5Mi40NzYgQzUuMDI2LDkyLjkzNyA1LjQxMiw5My40NTkgNS45NzMsOTMuNjE1IEM2LjA4Nyw5My42NCA2LjE1OCw5My42NTIgNi4xNjksOTMuNjU0IEw2LjE3LDkzLjY1NCBMNi4xNyw5My42NTQgWiIgaWQ9IkZpbGwtMTIiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4zMTcsNjguOTgyIEM3LjgwNiw2OC43MDEgOC4yMDIsNjguOTI2IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNi44MjksNzEuMjk0IDYuNDMzLDcxLjA2OSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIiBpZD0iRmlsbC0xMyIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjkyLDcxLjEzMyBDNi42MzEsNzEuMTMzIDYuNDMzLDcwLjkwNSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIEM3LjQ2LDY4LjkgNy41OTUsNjguODYxIDcuNzE0LDY4Ljg2MSBDOC4wMDMsNjguODYxIDguMjAyLDY5LjA5IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNy4xNzQsNzEuMDk0IDcuMDM5LDcxLjEzMyA2LjkyLDcxLjEzMyBNNy43MTQsNjguNjc0IEM3LjU1Nyw2OC42NzQgNy4zOTIsNjguNzIzIDcuMjI0LDY4LjgyMSBDNi42NzYsNjkuMTM4IDYuMjQ2LDY5Ljg3OSA2LjI0Niw3MC41MDggQzYuMjQ2LDcwLjk5NCA2LjUxNyw3MS4zMiA2LjkyLDcxLjMyIEM3LjA3OCw3MS4zMiA3LjI0Myw3MS4yNzEgNy40MTEsNzEuMTc0IEM3Ljk1OSw3MC44NTcgOC4zODksNzAuMTE3IDguMzg5LDY5LjQ4NyBDOC4zODksNjkuMDAxIDguMTE3LDY4LjY3NCA3LjcxNCw2OC42NzQiIGlkPSJGaWxsLTE0IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYuOTIsNzAuOTQ3IEM2LjY0OSw3MC45NDcgNi42MjEsNzAuNjQgNi42MjEsNzAuNTA4IEM2LjYyMSw3MC4wMTcgNi45ODIsNjkuMzkyIDcuNDExLDY5LjE0NSBDNy41MjEsNjkuMDgyIDcuNjI1LDY5LjA0OSA3LjcxNCw2OS4wNDkgQzcuOTg2LDY5LjA0OSA4LjAxNSw2OS4zNTUgOC4wMTUsNjkuNDg3IEM4LjAxNSw2OS45NzggNy42NTIsNzAuNjAzIDcuMjI0LDcwLjg1MSBDNy4xMTUsNzAuOTE0IDcuMDEsNzAuOTQ3IDYuOTIsNzAuOTQ3IE03LjcxNCw2OC44NjEgQzcuNTk1LDY4Ljg2MSA3LjQ2LDY4LjkgNy4zMTcsNjguOTgyIEM2LjgyOSw2OS4yNjUgNi40MzMsNjkuOTQ4IDYuNDMzLDcwLjUwOCBDNi40MzMsNzAuOTA1IDYuNjMxLDcxLjEzMyA2LjkyLDcxLjEzMyBDNy4wMzksNzEuMTMzIDcuMTc0LDcxLjA5NCA3LjMxNyw3MS4wMTIgQzcuODA2LDcwLjczIDguMjAyLDcwLjA0NyA4LjIwMiw2OS40ODcgQzguMjAyLDY5LjA5IDguMDAzLDY4Ljg2MSA3LjcxNCw2OC44NjEiIGlkPSJGaWxsLTE1IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcuNDQ0LDg1LjM1IEM3LjcwOCw4NS4xOTggNy45MjEsODUuMzE5IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuOTI1IDcuNzA4LDg2LjI5MiA3LjQ0NCw4Ni40NDQgQzcuMTgxLDg2LjU5NyA2Ljk2Nyw4Ni40NzUgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IiBpZD0iRmlsbC0xNiIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik03LjIzLDg2LjUxIEM3LjA3NCw4Ni41MSA2Ljk2Nyw4Ni4zODcgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IEM3LjUyMSw4NS4zMDUgNy41OTQsODUuMjg0IDcuNjU4LDg1LjI4NCBDNy44MTQsODUuMjg0IDcuOTIxLDg1LjQwOCA3LjkyMSw4NS42MjIgQzcuOTIxLDg1LjkyNSA3LjcwOCw4Ni4yOTIgNy40NDQsODYuNDQ0IEM3LjM2Nyw4Ni40ODkgNy4yOTQsODYuNTEgNy4yMyw4Ni41MSBNNy42NTgsODUuMDk4IEM3LjU1OCw4NS4wOTggNy40NTUsODUuMTI3IDcuMzUxLDg1LjE4OCBDNy4wMzEsODUuMzczIDYuNzgxLDg1LjgwNiA2Ljc4MSw4Ni4xNzMgQzYuNzgxLDg2LjQ4MiA2Ljk2Niw4Ni42OTcgNy4yMyw4Ni42OTcgQzcuMzMsODYuNjk3IDcuNDMzLDg2LjY2NiA3LjUzOCw4Ni42MDcgQzcuODU4LDg2LjQyMiA4LjEwOCw4NS45ODkgOC4xMDgsODUuNjIyIEM4LjEwOCw4NS4zMTMgNy45MjMsODUuMDk4IDcuNjU4LDg1LjA5OCIgaWQ9IkZpbGwtMTciIGZpbGw9IiM4MDk3QTIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4yMyw4Ni4zMjIgTDcuMTU0LDg2LjE3MyBDNy4xNTQsODUuOTM4IDcuMzMzLDg1LjYyOSA3LjUzOCw4NS41MTIgTDcuNjU4LDg1LjQ3MSBMNy43MzQsODUuNjIyIEM3LjczNCw4NS44NTYgNy41NTUsODYuMTY0IDcuMzUxLDg2LjI4MiBMNy4yMyw4Ni4zMjIgTTcuNjU4LDg1LjI4NCBDNy41OTQsODUuMjg0IDcuNTIxLDg1LjMwNSA3LjQ0NCw4NS4zNSBDNy4xODEsODUuNTAyIDYuOTY3LDg1Ljg3MSA2Ljk2Nyw4Ni4xNzMgQzYuOTY3LDg2LjM4NyA3LjA3NCw4Ni41MSA3LjIzLDg2LjUxIEM3LjI5NCw4Ni41MSA3LjM2Nyw4Ni40ODkgNy40NDQsODYuNDQ0IEM3LjcwOCw4Ni4yOTIgNy45MjEsODUuOTI1IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuNDA4IDcuODE0LDg1LjI4NCA3LjY1OCw4NS4yODQiIGlkPSJGaWxsLTE4IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTc3LjI3OCw3Ljc2OSBMNzcuMjc4LDUxLjQzNiBMMTAuMjA4LDkwLjE2IEwxMC4yMDgsNDYuNDkzIEw3Ny4yNzgsNy43NjkiIGlkPSJGaWxsLTE5IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwLjA4Myw5MC4zNzUgTDEwLjA4Myw0Ni40MjEgTDEwLjE0Niw0Ni4zODUgTDc3LjQwMyw3LjU1NCBMNzcuNDAzLDUxLjUwOCBMNzcuMzQxLDUxLjU0NCBMMTAuMDgzLDkwLjM3NSBMMTAuMDgzLDkwLjM3NSBaIE0xMC4zMzMsNDYuNTY0IEwxMC4zMzMsODkuOTQ0IEw3Ny4xNTQsNTEuMzY1IEw3Ny4xNTQsNy45ODUgTDEwLjMzMyw0Ni41NjQgTDEwLjMzMyw0Ni41NjQgWiIgaWQ9IkZpbGwtMjAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMjUuNzM3LDg4LjY0NyBMMTE4LjA5OCw5MS45ODEgTDExOC4wOTgsODQgTDEwNi42MzksODguNzEzIEwxMDYuNjM5LDk2Ljk4MiBMOTksMTAwLjMxNSBMMTEyLjM2OSwxMDMuOTYxIEwxMjUuNzM3LDg4LjY0NyIgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTIiIGZpbGw9IiM0NTVBNjQiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+');
	};
	
	module.exports = RotateInstructions;
	
	},{"./util.js":22}],17:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var SensorSample = _dereq_('./sensor-sample.js');
	var MathUtil = _dereq_('../math-util.js');
	var Util = _dereq_('../util.js');
	
	var DEBUG = false;
	
	/**
	 * An implementation of a simple complementary filter, which fuses gyroscope and
	 * accelerometer data from the 'devicemotion' event.
	 *
	 * Accelerometer data is very noisy, but stable over the long term.
	 * Gyroscope data is smooth, but tends to drift over the long term.
	 *
	 * This fusion is relatively simple:
	 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
	 *    on that data.
	 * 2. Get orientation estimates from gyroscope by integrating over time.
	 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
	 *    short term.
	 */
	function ComplementaryFilter(kFilter) {
	  this.kFilter = kFilter;
	
	  // Raw sensor measurements.
	  this.currentAccelMeasurement = new SensorSample();
	  this.currentGyroMeasurement = new SensorSample();
	  this.previousGyroMeasurement = new SensorSample();
	
	  // Set default look direction to be in the correct direction.
	  if (Util.isIOS()) {
	    this.filterQ = new MathUtil.Quaternion(-1, 0, 0, 1);
	  } else {
	    this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1);
	  }
	  this.previousFilterQ = new MathUtil.Quaternion();
	  this.previousFilterQ.copy(this.filterQ);
	
	  // Orientation based on the accelerometer.
	  this.accelQ = new MathUtil.Quaternion();
	  // Whether or not the orientation has been initialized.
	  this.isOrientationInitialized = false;
	  // Running estimate of gravity based on the current orientation.
	  this.estimatedGravity = new MathUtil.Vector3();
	  // Measured gravity based on accelerometer.
	  this.measuredGravity = new MathUtil.Vector3();
	
	  // Debug only quaternion of gyro-based orientation.
	  this.gyroIntegralQ = new MathUtil.Quaternion();
	}
	
	ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
	  this.currentAccelMeasurement.set(vector, timestampS);
	};
	
	ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
	  this.currentGyroMeasurement.set(vector, timestampS);
	
	  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
	  if (Util.isTimestampDeltaValid(deltaT)) {
	    this.run_();
	  }
	
	  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
	};
	
	ComplementaryFilter.prototype.run_ = function() {
	
	  if (!this.isOrientationInitialized) {
	    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
	    this.previousFilterQ.copy(this.accelQ);
	    this.isOrientationInitialized = true;
	    return;
	  }
	
	  var deltaT = this.currentGyroMeasurement.timestampS -
	      this.previousGyroMeasurement.timestampS;
	
	  // Convert gyro rotation vector to a quaternion delta.
	  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
	  this.gyroIntegralQ.multiply(gyroDeltaQ);
	
	  // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
	  this.filterQ.copy(this.previousFilterQ);
	  this.filterQ.multiply(gyroDeltaQ);
	
	  // Calculate the delta between the current estimated gravity and the real
	  // gravity vector from accelerometer.
	  var invFilterQ = new MathUtil.Quaternion();
	  invFilterQ.copy(this.filterQ);
	  invFilterQ.inverse();
	
	  this.estimatedGravity.set(0, 0, -1);
	  this.estimatedGravity.applyQuaternion(invFilterQ);
	  this.estimatedGravity.normalize();
	
	  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
	  this.measuredGravity.normalize();
	
	  // Compare estimated gravity with measured gravity, get the delta quaternion
	  // between the two.
	  var deltaQ = new MathUtil.Quaternion();
	  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
	  deltaQ.inverse();
	
	  if (DEBUG) {
	    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
	                MathUtil.radToDeg * Util.getQuaternionAngle(deltaQ),
	                (this.estimatedGravity.x).toFixed(1),
	                (this.estimatedGravity.y).toFixed(1),
	                (this.estimatedGravity.z).toFixed(1),
	                (this.measuredGravity.x).toFixed(1),
	                (this.measuredGravity.y).toFixed(1),
	                (this.measuredGravity.z).toFixed(1));
	  }
	
	  // Calculate the SLERP target: current orientation plus the measured-estimated
	  // quaternion delta.
	  var targetQ = new MathUtil.Quaternion();
	  targetQ.copy(this.filterQ);
	  targetQ.multiply(deltaQ);
	
	  // SLERP factor: 0 is pure gyro, 1 is pure accel.
	  this.filterQ.slerp(targetQ, 1 - this.kFilter);
	
	  this.previousFilterQ.copy(this.filterQ);
	};
	
	ComplementaryFilter.prototype.getOrientation = function() {
	  return this.filterQ;
	};
	
	ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
	  var normAccel = new MathUtil.Vector3();
	  normAccel.copy(accel);
	  normAccel.normalize();
	  var quat = new MathUtil.Quaternion();
	  quat.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), normAccel);
	  quat.inverse();
	  return quat;
	};
	
	ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
	  // Extract axis and angle from the gyroscope data.
	  var quat = new MathUtil.Quaternion();
	  var axis = new MathUtil.Vector3();
	  axis.copy(gyro);
	  axis.normalize();
	  quat.setFromAxisAngle(axis, gyro.length() * dt);
	  return quat;
	};
	
	
	module.exports = ComplementaryFilter;
	
	},{"../math-util.js":14,"../util.js":22,"./sensor-sample.js":20}],18:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var ComplementaryFilter = _dereq_('./complementary-filter.js');
	var PosePredictor = _dereq_('./pose-predictor.js');
	var TouchPanner = _dereq_('../touch-panner.js');
	var MathUtil = _dereq_('../math-util.js');
	var Util = _dereq_('../util.js');
	
	/**
	 * The pose sensor, implemented using DeviceMotion APIs.
	 */
	function FusionPoseSensor() {
	  this.deviceId = 'webvr-polyfill:fused';
	  this.deviceName = 'VR Position Device (webvr-polyfill:fused)';
	
	  this.accelerometer = new MathUtil.Vector3();
	  this.gyroscope = new MathUtil.Vector3();
	
	  window.addEventListener('devicemotion', this.onDeviceMotionChange_.bind(this));
	  window.addEventListener('orientationchange', this.onScreenOrientationChange_.bind(this));
	
	  this.filter = new ComplementaryFilter(WebVRConfig.K_FILTER);
	  this.posePredictor = new PosePredictor(WebVRConfig.PREDICTION_TIME_S);
	  this.touchPanner = new TouchPanner();
	
	  this.filterToWorldQ = new MathUtil.Quaternion();
	
	  // Set the filter to world transform, depending on OS.
	  if (Util.isIOS()) {
	    this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), Math.PI / 2);
	  } else {
	    this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), -Math.PI / 2);
	  }
	
	  this.inverseWorldToScreenQ = new MathUtil.Quaternion();
	  this.worldToScreenQ = new MathUtil.Quaternion();
	  this.originalPoseAdjustQ = new MathUtil.Quaternion();
	  this.originalPoseAdjustQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1),
	                                           -window.orientation * Math.PI / 180);
	
	  this.setScreenTransform_();
	  // Adjust this filter for being in landscape mode.
	  if (Util.isLandscapeMode()) {
	    this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
	  }
	
	  // Keep track of a reset transform for resetSensor.
	  this.resetQ = new MathUtil.Quaternion();
	
	  this.isFirefoxAndroid = Util.isFirefoxAndroid();
	  this.isIOS = Util.isIOS();
	
	  this.orientationOut_ = new Float32Array(4);
	}
	
	FusionPoseSensor.prototype.getPosition = function() {
	  // This PoseSensor doesn't support position
	  return null;
	};
	
	FusionPoseSensor.prototype.getOrientation = function() {
	  // Convert from filter space to the the same system used by the
	  // deviceorientation event.
	  var orientation = this.filter.getOrientation();
	
	  // Predict orientation.
	  this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);
	
	  // Convert to THREE coordinate system: -Z forward, Y up, X right.
	  var out = new MathUtil.Quaternion();
	  out.copy(this.filterToWorldQ);
	  out.multiply(this.resetQ);
	  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
	    out.multiply(this.touchPanner.getOrientation());
	  }
	  out.multiply(this.predictedQ);
	  out.multiply(this.worldToScreenQ);
	
	  // Handle the yaw-only case.
	  if (WebVRConfig.YAW_ONLY) {
	    // Make a quaternion that only turns around the Y-axis.
	    out.x = 0;
	    out.z = 0;
	    out.normalize();
	  }
	
	  this.orientationOut_[0] = out.x;
	  this.orientationOut_[1] = out.y;
	  this.orientationOut_[2] = out.z;
	  this.orientationOut_[3] = out.w;
	  return this.orientationOut_;
	};
	
	FusionPoseSensor.prototype.resetPose = function() {
	  // Reduce to inverted yaw-only.
	  this.resetQ.copy(this.filter.getOrientation());
	  this.resetQ.x = 0;
	  this.resetQ.y = 0;
	  this.resetQ.z *= -1;
	  this.resetQ.normalize();
	
	  // Take into account extra transformations in landscape mode.
	  if (Util.isLandscapeMode()) {
	    this.resetQ.multiply(this.inverseWorldToScreenQ);
	  }
	
	  // Take into account original pose.
	  this.resetQ.multiply(this.originalPoseAdjustQ);
	
	  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
	    this.touchPanner.resetSensor();
	  }
	};
	
	FusionPoseSensor.prototype.onDeviceMotionChange_ = function(deviceMotion) {
	  var accGravity = deviceMotion.accelerationIncludingGravity;
	  var rotRate = deviceMotion.rotationRate;
	  var timestampS = deviceMotion.timeStamp / 1000;
	
	  // Firefox Android timeStamp returns one thousandth of a millisecond.
	  if (this.isFirefoxAndroid) {
	    timestampS /= 1000;
	  }
	
	  var deltaS = timestampS - this.previousTimestampS;
	  if (deltaS <= Util.MIN_TIMESTEP || deltaS > Util.MAX_TIMESTEP) {
	    console.warn('Invalid timestamps detected. Time step between successive ' +
	                 'gyroscope sensor samples is very small or not monotonic');
	    this.previousTimestampS = timestampS;
	    return;
	  }
	  this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
	  this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);
	
	  // With iOS and Firefox Android, rotationRate is reported in degrees,
	  // so we first convert to radians.
	  if (this.isIOS || this.isFirefoxAndroid) {
	    this.gyroscope.multiplyScalar(Math.PI / 180);
	  }
	
	  this.filter.addAccelMeasurement(this.accelerometer, timestampS);
	  this.filter.addGyroMeasurement(this.gyroscope, timestampS);
	
	  this.previousTimestampS = timestampS;
	};
	
	FusionPoseSensor.prototype.onScreenOrientationChange_ =
	    function(screenOrientation) {
	  this.setScreenTransform_();
	};
	
	FusionPoseSensor.prototype.setScreenTransform_ = function() {
	  this.worldToScreenQ.set(0, 0, 0, 1);
	  switch (window.orientation) {
	    case 0:
	      break;
	    case 90:
	      this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), -Math.PI / 2);
	      break;
	    case -90:
	      this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), Math.PI / 2);
	      break;
	    case 180:
	      // TODO.
	      break;
	  }
	  this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
	  this.inverseWorldToScreenQ.inverse();
	};
	
	module.exports = FusionPoseSensor;
	
	},{"../math-util.js":14,"../touch-panner.js":21,"../util.js":22,"./complementary-filter.js":17,"./pose-predictor.js":19}],19:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var MathUtil = _dereq_('../math-util.js');
	var DEBUG = false;
	
	/**
	 * Given an orientation and the gyroscope data, predicts the future orientation
	 * of the head. This makes rendering appear faster.
	 *
	 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
	 *
	 * @param {Number} predictionTimeS time from head movement to the appearance of
	 * the corresponding image.
	 */
	function PosePredictor(predictionTimeS) {
	  this.predictionTimeS = predictionTimeS;
	
	  // The quaternion corresponding to the previous state.
	  this.previousQ = new MathUtil.Quaternion();
	  // Previous time a prediction occurred.
	  this.previousTimestampS = null;
	
	  // The delta quaternion that adjusts the current pose.
	  this.deltaQ = new MathUtil.Quaternion();
	  // The output quaternion.
	  this.outQ = new MathUtil.Quaternion();
	}
	
	PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
	  if (!this.previousTimestampS) {
	    this.previousQ.copy(currentQ);
	    this.previousTimestampS = timestampS;
	    return currentQ;
	  }
	
	  // Calculate axis and angle based on gyroscope rotation rate data.
	  var axis = new MathUtil.Vector3();
	  axis.copy(gyro);
	  axis.normalize();
	
	  var angularSpeed = gyro.length();
	
	  // If we're rotating slowly, don't do prediction.
	  if (angularSpeed < MathUtil.degToRad * 20) {
	    if (DEBUG) {
	      console.log('Moving slowly, at %s deg/s: no prediction',
	                  (MathUtil.radToDeg * angularSpeed).toFixed(1));
	    }
	    this.outQ.copy(currentQ);
	    this.previousQ.copy(currentQ);
	    return this.outQ;
	  }
	
	  // Get the predicted angle based on the time delta and latency.
	  var deltaT = timestampS - this.previousTimestampS;
	  var predictAngle = angularSpeed * this.predictionTimeS;
	
	  this.deltaQ.setFromAxisAngle(axis, predictAngle);
	  this.outQ.copy(this.previousQ);
	  this.outQ.multiply(this.deltaQ);
	
	  this.previousQ.copy(currentQ);
	  this.previousTimestampS = timestampS;
	
	  return this.outQ;
	};
	
	
	module.exports = PosePredictor;
	
	},{"../math-util.js":14}],20:[function(_dereq_,module,exports){
	function SensorSample(sample, timestampS) {
	  this.set(sample, timestampS);
	};
	
	SensorSample.prototype.set = function(sample, timestampS) {
	  this.sample = sample;
	  this.timestampS = timestampS;
	};
	
	SensorSample.prototype.copy = function(sensorSample) {
	  this.set(sensorSample.sample, sensorSample.timestampS);
	};
	
	module.exports = SensorSample;
	
	},{}],21:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var MathUtil = _dereq_('./math-util.js');
	var Util = _dereq_('./util.js');
	
	var ROTATE_SPEED = 0.5;
	/**
	 * Provides a quaternion responsible for pre-panning the scene before further
	 * transformations due to device sensors.
	 */
	function TouchPanner() {
	  window.addEventListener('touchstart', this.onTouchStart_.bind(this));
	  window.addEventListener('touchmove', this.onTouchMove_.bind(this));
	  window.addEventListener('touchend', this.onTouchEnd_.bind(this));
	
	  this.isTouching = false;
	  this.rotateStart = new MathUtil.Vector2();
	  this.rotateEnd = new MathUtil.Vector2();
	  this.rotateDelta = new MathUtil.Vector2();
	
	  this.theta = 0;
	  this.orientation = new MathUtil.Quaternion();
	}
	
	TouchPanner.prototype.getOrientation = function() {
	  this.orientation.setFromEulerXYZ(0, 0, this.theta);
	  return this.orientation;
	};
	
	TouchPanner.prototype.resetSensor = function() {
	  this.theta = 0;
	};
	
	TouchPanner.prototype.onTouchStart_ = function(e) {
	  // Only respond if there is exactly one touch.
	  if (e.touches.length != 1) {
	    return;
	  }
	  this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);
	  this.isTouching = true;
	};
	
	TouchPanner.prototype.onTouchMove_ = function(e) {
	  if (!this.isTouching) {
	    return;
	  }
	  this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY);
	  this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
	  this.rotateStart.copy(this.rotateEnd);
	
	  // On iOS, direction is inverted.
	  if (Util.isIOS()) {
	    this.rotateDelta.x *= -1;
	  }
	
	  var element = document.body;
	  this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * ROTATE_SPEED;
	};
	
	TouchPanner.prototype.onTouchEnd_ = function(e) {
	  this.isTouching = false;
	};
	
	module.exports = TouchPanner;
	
	},{"./math-util.js":14,"./util.js":22}],22:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var objectAssign = _dereq_('object-assign');
	
	var Util = window.Util || {};
	
	Util.MIN_TIMESTEP = 0.001;
	Util.MAX_TIMESTEP = 1;
	
	Util.base64 = function(mimeType, base64) {
	  return 'data:' + mimeType + ';base64,' + base64;
	};
	
	Util.clamp = function(value, min, max) {
	  return Math.min(Math.max(min, value), max);
	};
	
	Util.lerp = function(a, b, t) {
	  return a + ((b - a) * t);
	};
	
	Util.isIOS = (function() {
	  var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
	  return function() {
	    return isIOS;
	  };
	})();
	
	Util.isSafari = (function() {
	  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	  return function() {
	    return isSafari;
	  };
	})();
	
	Util.isFirefoxAndroid = (function() {
	  var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 &&
	      navigator.userAgent.indexOf('Android') !== -1;
	  return function() {
	    return isFirefoxAndroid;
	  };
	})();
	
	Util.isLandscapeMode = function() {
	  return (window.orientation == 90 || window.orientation == -90);
	};
	
	// Helper method to validate the time steps of sensor timestamps.
	Util.isTimestampDeltaValid = function(timestampDeltaS) {
	  if (isNaN(timestampDeltaS)) {
	    return false;
	  }
	  if (timestampDeltaS <= Util.MIN_TIMESTEP) {
	    return false;
	  }
	  if (timestampDeltaS > Util.MAX_TIMESTEP) {
	    return false;
	  }
	  return true;
	};
	
	Util.getScreenWidth = function() {
	  return Math.max(window.screen.width, window.screen.height) *
	      window.devicePixelRatio;
	};
	
	Util.getScreenHeight = function() {
	  return Math.min(window.screen.width, window.screen.height) *
	      window.devicePixelRatio;
	};
	
	Util.requestFullscreen = function(element) {
	  if (element.requestFullscreen) {
	    element.requestFullscreen();
	  } else if (element.webkitRequestFullscreen) {
	    element.webkitRequestFullscreen();
	  } else if (element.mozRequestFullScreen) {
	    element.mozRequestFullScreen();
	  } else if (element.msRequestFullscreen) {
	    element.msRequestFullscreen();
	  } else {
	    return false;
	  }
	
	  return true;
	};
	
	Util.exitFullscreen = function() {
	  if (document.exitFullscreen) {
	    document.exitFullscreen();
	  } else if (document.webkitExitFullscreen) {
	    document.webkitExitFullscreen();
	  } else if (document.mozCancelFullScreen) {
	    document.mozCancelFullScreen();
	  } else if (document.msExitFullscreen) {
	    document.msExitFullscreen();
	  } else {
	    return false;
	  }
	
	  return true;
	};
	
	Util.getFullscreenElement = function() {
	  return document.fullscreenElement ||
	      document.webkitFullscreenElement ||
	      document.mozFullScreenElement ||
	      document.msFullscreenElement;
	};
	
	Util.linkProgram = function(gl, vertexSource, fragmentSource, attribLocationMap) {
	  // No error checking for brevity.
	  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	  gl.shaderSource(vertexShader, vertexSource);
	  gl.compileShader(vertexShader);
	
	  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	  gl.shaderSource(fragmentShader, fragmentSource);
	  gl.compileShader(fragmentShader);
	
	  var program = gl.createProgram();
	  gl.attachShader(program, vertexShader);
	  gl.attachShader(program, fragmentShader);
	
	  for (var attribName in attribLocationMap)
	    gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);
	
	  gl.linkProgram(program);
	
	  gl.deleteShader(vertexShader);
	  gl.deleteShader(fragmentShader);
	
	  return program;
	};
	
	Util.getProgramUniforms = function(gl, program) {
	  var uniforms = {};
	  var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
	  var uniformName = '';
	  for (var i = 0; i < uniformCount; i++) {
	    var uniformInfo = gl.getActiveUniform(program, i);
	    uniformName = uniformInfo.name.replace('[0]', '');
	    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
	  }
	  return uniforms;
	};
	
	Util.orthoMatrix = function (out, left, right, bottom, top, near, far) {
	  var lr = 1 / (left - right),
	      bt = 1 / (bottom - top),
	      nf = 1 / (near - far);
	  out[0] = -2 * lr;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = -2 * bt;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 2 * nf;
	  out[11] = 0;
	  out[12] = (left + right) * lr;
	  out[13] = (top + bottom) * bt;
	  out[14] = (far + near) * nf;
	  out[15] = 1;
	  return out;
	};
	
	Util.isMobile = function() {
	  var check = false;
	  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
	  return check;
	};
	
	Util.extend = objectAssign;
	
	Util.safariCssSizeWorkaround = function(canvas) {
	  // TODO(smus): Remove this workaround when Safari for iOS is fixed.
	  // iOS only workaround (for https://bugs.webkit.org/show_bug.cgi?id=152556).
	  //
	  // "To the last I grapple with thee;
	  //  from hell's heart I stab at thee;
	  //  for hate's sake I spit my last breath at thee."
	  // -- Moby Dick, by Herman Melville
	  if (Util.isIOS()) {
	    var width = canvas.style.width;
	    var height = canvas.style.height;
	    canvas.style.width = (parseInt(width) + 1) + 'px';
	    canvas.style.height = (parseInt(height)) + 'px';
	    console.log('Resetting width to...', width);
	    setTimeout(function() {
	      console.log('Done. Width is now', width);
	      canvas.style.width = width;
	      canvas.style.height = height;
	    }, 100);
	  }
	
	  // Debug only.
	  window.Util = Util;
	  window.canvas = canvas;
	};
	
	Util.frameDataFromPose = (function() {
	  var piOver180 = Math.PI / 180.0;
	  var rad45 = Math.PI * 0.25;
	
	  // Borrowed from glMatrix.
	  function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
	    var upTan = Math.tan(fov ? (fov.upDegrees * piOver180) : rad45),
	    downTan = Math.tan(fov ? (fov.downDegrees * piOver180) : rad45),
	    leftTan = Math.tan(fov ? (fov.leftDegrees * piOver180) : rad45),
	    rightTan = Math.tan(fov ? (fov.rightDegrees * piOver180) : rad45),
	    xScale = 2.0 / (leftTan + rightTan),
	    yScale = 2.0 / (upTan + downTan);
	
	    out[0] = xScale;
	    out[1] = 0.0;
	    out[2] = 0.0;
	    out[3] = 0.0;
	    out[4] = 0.0;
	    out[5] = yScale;
	    out[6] = 0.0;
	    out[7] = 0.0;
	    out[8] = -((leftTan - rightTan) * xScale * 0.5);
	    out[9] = ((upTan - downTan) * yScale * 0.5);
	    out[10] = far / (near - far);
	    out[11] = -1.0;
	    out[12] = 0.0;
	    out[13] = 0.0;
	    out[14] = (far * near) / (near - far);
	    out[15] = 0.0;
	    return out;
	  }
	
	  function mat4_fromRotationTranslation(out, q, v) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,
	
	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;
	
	    out[0] = 1 - (yy + zz);
	    out[1] = xy + wz;
	    out[2] = xz - wy;
	    out[3] = 0;
	    out[4] = xy - wz;
	    out[5] = 1 - (xx + zz);
	    out[6] = yz + wx;
	    out[7] = 0;
	    out[8] = xz + wy;
	    out[9] = yz - wx;
	    out[10] = 1 - (xx + yy);
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	
	    return out;
	  };
	
	  function mat4_translate(out, a, v) {
	    var x = v[0], y = v[1], z = v[2],
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23;
	
	    if (a === out) {
	      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	      a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	      a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	      a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];
	
	      out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
	      out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
	      out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;
	
	      out[12] = a00 * x + a10 * y + a20 * z + a[12];
	      out[13] = a01 * x + a11 * y + a21 * z + a[13];
	      out[14] = a02 * x + a12 * y + a22 * z + a[14];
	      out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }
	
	    return out;
	  };
	
	  mat4_invert = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],
	
	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,
	
	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	
	    if (!det) {
	      return null;
	    }
	    det = 1.0 / det;
	
	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	
	    return out;
	  };
	
	  var defaultOrientation = new Float32Array([0, 0, 0, 1]);
	  var defaultPosition = new Float32Array([0, 0, 0]);
	
	  function updateEyeMatrices(projection, view, pose, parameters, vrDisplay) {
	    mat4_perspectiveFromFieldOfView(projection, parameters ? parameters.fieldOfView : null, vrDisplay.depthNear, vrDisplay.depthFar);
	
	    var orientation = pose.orientation || defaultOrientation;
	    var position = pose.position || defaultPosition;
	
	    mat4_fromRotationTranslation(view, orientation, position);
	    if (parameters)
	      mat4_translate(view, view, parameters.offset);
	    mat4_invert(view, view);
	  }
	
	  return function(frameData, pose, vrDisplay) {
	    if (!frameData || !pose)
	      return false;
	
	    frameData.pose = pose;
	    frameData.timestamp = pose.timestamp;
	
	    updateEyeMatrices(
	        frameData.leftProjectionMatrix, frameData.leftViewMatrix,
	        pose, vrDisplay.getEyeParameters("left"), vrDisplay);
	    updateEyeMatrices(
	        frameData.rightProjectionMatrix, frameData.rightViewMatrix,
	        pose, vrDisplay.getEyeParameters("right"), vrDisplay);
	
	    return true;
	  };
	})();
	
	module.exports = Util;
	
	},{"object-assign":1}],23:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var Emitter = _dereq_('./emitter.js');
	var Util = _dereq_('./util.js');
	var DeviceInfo = _dereq_('./device-info.js');
	
	var DEFAULT_VIEWER = 'CardboardV1';
	var VIEWER_KEY = 'WEBVR_CARDBOARD_VIEWER';
	var CLASS_NAME = 'webvr-polyfill-viewer-selector';
	
	/**
	 * Creates a viewer selector with the options specified. Supports being shown
	 * and hidden. Generates events when viewer parameters change. Also supports
	 * saving the currently selected index in localStorage.
	 */
	function ViewerSelector() {
	  // Try to load the selected key from local storage. If none exists, use the
	  // default key.
	  try {
	    this.selectedKey = localStorage.getItem(VIEWER_KEY) || DEFAULT_VIEWER;
	  } catch (error) {
	    console.error('Failed to load viewer profile: %s', error);
	  }
	  this.dialog = this.createDialog_(DeviceInfo.Viewers);
	  this.root = null;
	}
	ViewerSelector.prototype = new Emitter();
	
	ViewerSelector.prototype.show = function(root) {
	  this.root = root;
	
	  root.appendChild(this.dialog);
	  //console.log('ViewerSelector.show');
	
	  // Ensure the currently selected item is checked.
	  var selected = this.dialog.querySelector('#' + this.selectedKey);
	  selected.checked = true;
	
	  // Show the UI.
	  this.dialog.style.display = 'block';
	};
	
	ViewerSelector.prototype.hide = function() {
	  if (this.root && this.root.contains(this.dialog)) {
	    this.root.removeChild(this.dialog);
	  }
	  //console.log('ViewerSelector.hide');
	  this.dialog.style.display = 'none';
	};
	
	ViewerSelector.prototype.getCurrentViewer = function() {
	  return DeviceInfo.Viewers[this.selectedKey];
	};
	
	ViewerSelector.prototype.getSelectedKey_ = function() {
	  var input = this.dialog.querySelector('input[name=field]:checked');
	  if (input) {
	    return input.id;
	  }
	  return null;
	};
	
	ViewerSelector.prototype.onSave_ = function() {
	  this.selectedKey = this.getSelectedKey_();
	  if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
	    console.error('ViewerSelector.onSave_: this should never happen!');
	    return;
	  }
	
	  this.emit('change', DeviceInfo.Viewers[this.selectedKey]);
	
	  // Attempt to save the viewer profile, but fails in private mode.
	  try {
	    localStorage.setItem(VIEWER_KEY, this.selectedKey);
	  } catch(error) {
	    console.error('Failed to save viewer profile: %s', error);
	  }
	  this.hide();
	};
	
	/**
	 * Creates the dialog.
	 */
	ViewerSelector.prototype.createDialog_ = function(options) {
	  var container = document.createElement('div');
	  container.classList.add(CLASS_NAME);
	  container.style.display = 'none';
	  // Create an overlay that dims the background, and which goes away when you
	  // tap it.
	  var overlay = document.createElement('div');
	  var s = overlay.style;
	  s.position = 'fixed';
	  s.left = 0;
	  s.top = 0;
	  s.width = '100%';
	  s.height = '100%';
	  s.background = 'rgba(0, 0, 0, 0.3)';
	  overlay.addEventListener('click', this.hide.bind(this));
	
	  var width = 280;
	  var dialog = document.createElement('div');
	  var s = dialog.style;
	  s.boxSizing = 'border-box';
	  s.position = 'fixed';
	  s.top = '24px';
	  s.left = '50%';
	  s.marginLeft = (-width/2) + 'px';
	  s.width = width + 'px';
	  s.padding = '24px';
	  s.overflow = 'hidden';
	  s.background = '#fafafa';
	  s.fontFamily = "'Roboto', sans-serif";
	  s.boxShadow = '0px 5px 20px #666';
	
	  dialog.appendChild(this.createH1_('Select your viewer'));
	  for (var id in options) {
	    dialog.appendChild(this.createChoice_(id, options[id].label));
	  }
	  dialog.appendChild(this.createButton_('Save', this.onSave_.bind(this)));
	
	  container.appendChild(overlay);
	  container.appendChild(dialog);
	
	  return container;
	};
	
	ViewerSelector.prototype.createH1_ = function(name) {
	  var h1 = document.createElement('h1');
	  var s = h1.style;
	  s.color = 'black';
	  s.fontSize = '20px';
	  s.fontWeight = 'bold';
	  s.marginTop = 0;
	  s.marginBottom = '24px';
	  h1.innerHTML = name;
	  return h1;
	};
	
	ViewerSelector.prototype.createChoice_ = function(id, name) {
	  /*
	  <div class="choice">
	  <input id="v1" type="radio" name="field" value="v1">
	  <label for="v1">Cardboard V1</label>
	  </div>
	  */
	  var div = document.createElement('div');
	  div.style.marginTop = '8px';
	  div.style.color = 'black';
	
	  var input = document.createElement('input');
	  input.style.fontSize = '30px';
	  input.setAttribute('id', id);
	  input.setAttribute('type', 'radio');
	  input.setAttribute('value', id);
	  input.setAttribute('name', 'field');
	
	  var label = document.createElement('label');
	  label.style.marginLeft = '4px';
	  label.setAttribute('for', id);
	  label.innerHTML = name;
	
	  div.appendChild(input);
	  div.appendChild(label);
	
	  return div;
	};
	
	ViewerSelector.prototype.createButton_ = function(label, onclick) {
	  var button = document.createElement('button');
	  button.innerHTML = label;
	  var s = button.style;
	  s.float = 'right';
	  s.textTransform = 'uppercase';
	  s.color = '#1094f7';
	  s.fontSize = '14px';
	  s.letterSpacing = 0;
	  s.border = 0;
	  s.background = 'none';
	  s.marginTop = '16px';
	
	  button.addEventListener('click', onclick);
	
	  return button;
	};
	
	module.exports = ViewerSelector;
	
	},{"./device-info.js":7,"./emitter.js":12,"./util.js":22}],24:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var Util = _dereq_('./util.js');
	
	/**
	 * Android and iOS compatible wakelock implementation.
	 *
	 * Refactored thanks to dkovalev@.
	 */
	function AndroidWakeLock() {
	  var video = document.createElement('video');
	
	  video.addEventListener('ended', function() {
	    video.play();
	  });
	
	  this.request = function() {
	    if (video.paused) {
	      // Base64 version of videos_src/no-sleep-120s.mp4.
	      video.src = Util.base64('video/mp4', 'AAAAGGZ0eXBpc29tAAAAAG1wNDFhdmMxAAAIA21vb3YAAABsbXZoZAAAAADSa9v60mvb+gABX5AAlw/gAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAdkdHJhawAAAFx0a2hkAAAAAdJr2/rSa9v6AAAAAQAAAAAAlw/gAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAQAAAAHAAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAJcP4AAAAAAAAQAAAAAG3G1kaWEAAAAgbWRoZAAAAADSa9v60mvb+gAPQkAGjneAFccAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAABodtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAZHc3RibAAAAJdzdHNkAAAAAAAAAAEAAACHYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAMABwASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAADFhdmNDAWQAC//hABlnZAALrNlfllw4QAAAAwBAAAADAKPFCmWAAQAFaOvssiwAAAAYc3R0cwAAAAAAAAABAAAAbgAPQkAAAAAUc3RzcwAAAAAAAAABAAAAAQAAA4BjdHRzAAAAAAAAAG4AAAABAD0JAAAAAAEAehIAAAAAAQA9CQAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEALcbAAAAAHHN0c2MAAAAAAAAAAQAAAAEAAABuAAAAAQAAAcxzdHN6AAAAAAAAAAAAAABuAAADCQAAABgAAAAOAAAADgAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABMAAAAUc3RjbwAAAAAAAAABAAAIKwAAACt1ZHRhAAAAI6llbmMAFwAAdmxjIDIuMi4xIHN0cmVhbSBvdXRwdXQAAAAId2lkZQAACRRtZGF0AAACrgX//6vcRem95tlIt5Ys2CDZI+7veDI2NCAtIGNvcmUgMTQyIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDEzIG1lPWhleCBzdWJtZT03IHBzeT0xIHBzeV9yZD0xLjAwOjAuMDAgbWl4ZWRfcmVmPTEgbWVfcmFuZ2U9MTYgY2hyb21hX21lPTEgdHJlbGxpcz0xIDh4OGRjdD0xIGNxbT0wIGRlYWR6b25lPTIxLDExIGZhc3RfcHNraXA9MSBjaHJvbWFfcXBfb2Zmc2V0PS0yIHRocmVhZHM9MTIgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTEgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD00MCByYz1hYnIgbWJ0cmVlPTEgYml0cmF0ZT0xMDAgcmF0ZXRvbD0xLjAgcWNvbXA9MC42MCBxcG1pbj0xMCBxcG1heD01MSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAU2WIhAAQ/8ltlOe+cTZuGkKg+aRtuivcDZ0pBsfsEi9p/i1yU9DxS2lq4dXTinViF1URBKXgnzKBd/Uh1bkhHtMrwrRcOJslD01UB+fyaL6ef+DBAAAAFEGaJGxBD5B+v+a+4QqF3MgBXz9MAAAACkGeQniH/+94r6EAAAAKAZ5hdEN/8QytwAAAAAgBnmNqQ3/EgQAAAA5BmmhJqEFomUwIIf/+4QAAAApBnoZFESw//76BAAAACAGepXRDf8SBAAAACAGep2pDf8SAAAAADkGarEmoQWyZTAgh//7gAAAACkGeykUVLD//voEAAAAIAZ7pdEN/xIAAAAAIAZ7rakN/xIAAAAAOQZrwSahBbJlMCCH//uEAAAAKQZ8ORRUsP/++gQAAAAgBny10Q3/EgQAAAAgBny9qQ3/EgAAAAA5BmzRJqEFsmUwIIf/+4AAAAApBn1JFFSw//76BAAAACAGfcXRDf8SAAAAACAGfc2pDf8SAAAAADkGbeEmoQWyZTAgh//7hAAAACkGflkUVLD//voAAAAAIAZ+1dEN/xIEAAAAIAZ+3akN/xIEAAAAOQZu8SahBbJlMCCH//uAAAAAKQZ/aRRUsP/++gQAAAAgBn/l0Q3/EgAAAAAgBn/tqQ3/EgQAAAA5Bm+BJqEFsmUwIIf/+4QAAAApBnh5FFSw//76AAAAACAGePXRDf8SAAAAACAGeP2pDf8SBAAAADkGaJEmoQWyZTAgh//7gAAAACkGeQkUVLD//voEAAAAIAZ5hdEN/xIAAAAAIAZ5jakN/xIEAAAAOQZpoSahBbJlMCCH//uEAAAAKQZ6GRRUsP/++gQAAAAgBnqV0Q3/EgQAAAAgBnqdqQ3/EgAAAAA5BmqxJqEFsmUwIIf/+4AAAAApBnspFFSw//76BAAAACAGe6XRDf8SAAAAACAGe62pDf8SAAAAADkGa8EmoQWyZTAgh//7hAAAACkGfDkUVLD//voEAAAAIAZ8tdEN/xIEAAAAIAZ8vakN/xIAAAAAOQZs0SahBbJlMCCH//uAAAAAKQZ9SRRUsP/++gQAAAAgBn3F0Q3/EgAAAAAgBn3NqQ3/EgAAAAA5Bm3hJqEFsmUwIIf/+4QAAAApBn5ZFFSw//76AAAAACAGftXRDf8SBAAAACAGft2pDf8SBAAAADkGbvEmoQWyZTAgh//7gAAAACkGf2kUVLD//voEAAAAIAZ/5dEN/xIAAAAAIAZ/7akN/xIEAAAAOQZvgSahBbJlMCCH//uEAAAAKQZ4eRRUsP/++gAAAAAgBnj10Q3/EgAAAAAgBnj9qQ3/EgQAAAA5BmiRJqEFsmUwIIf/+4AAAAApBnkJFFSw//76BAAAACAGeYXRDf8SAAAAACAGeY2pDf8SBAAAADkGaaEmoQWyZTAgh//7hAAAACkGehkUVLD//voEAAAAIAZ6ldEN/xIEAAAAIAZ6nakN/xIAAAAAOQZqsSahBbJlMCCH//uAAAAAKQZ7KRRUsP/++gQAAAAgBnul0Q3/EgAAAAAgBnutqQ3/EgAAAAA5BmvBJqEFsmUwIIf/+4QAAAApBnw5FFSw//76BAAAACAGfLXRDf8SBAAAACAGfL2pDf8SAAAAADkGbNEmoQWyZTAgh//7gAAAACkGfUkUVLD//voEAAAAIAZ9xdEN/xIAAAAAIAZ9zakN/xIAAAAAOQZt4SahBbJlMCCH//uEAAAAKQZ+WRRUsP/++gAAAAAgBn7V0Q3/EgQAAAAgBn7dqQ3/EgQAAAA5Bm7xJqEFsmUwIIf/+4AAAAApBn9pFFSw//76BAAAACAGf+XRDf8SAAAAACAGf+2pDf8SBAAAADkGb4EmoQWyZTAgh//7hAAAACkGeHkUVLD//voAAAAAIAZ49dEN/xIAAAAAIAZ4/akN/xIEAAAAOQZokSahBbJlMCCH//uAAAAAKQZ5CRRUsP/++gQAAAAgBnmF0Q3/EgAAAAAgBnmNqQ3/EgQAAAA5BmmhJqEFsmUwIIf/+4QAAAApBnoZFFSw//76BAAAACAGepXRDf8SBAAAACAGep2pDf8SAAAAADkGarEmoQWyZTAgh//7gAAAACkGeykUVLD//voEAAAAIAZ7pdEN/xIAAAAAIAZ7rakN/xIAAAAAPQZruSahBbJlMFEw3//7B');
	      video.play();
	    }
	  };
	
	  this.release = function() {
	    video.pause();
	    video.src = '';
	  };
	}
	
	function iOSWakeLock() {
	  var timer = null;
	
	  this.request = function() {
	    if (!timer) {
	      timer = setInterval(function() {
	        window.location = window.location;
	        setTimeout(window.stop, 0);
	      }, 30000);
	    }
	  }
	
	  this.release = function() {
	    if (timer) {
	      clearInterval(timer);
	      timer = null;
	    }
	  }
	}
	
	
	function getWakeLock() {
	  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
	  if (userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
	    return iOSWakeLock;
	  } else {
	    return AndroidWakeLock;
	  }
	}
	
	module.exports = getWakeLock();
	},{"./util.js":22}],25:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var Util = _dereq_('./util.js');
	var CardboardVRDisplay = _dereq_('./cardboard-vr-display.js');
	var MouseKeyboardVRDisplay = _dereq_('./mouse-keyboard-vr-display.js');
	// Uncomment to add positional tracking via webcam.
	//var WebcamPositionSensorVRDevice = require('./webcam-position-sensor-vr-device.js');
	var VRDisplay = _dereq_('./base.js').VRDisplay;
	var VRFrameData = _dereq_('./base.js').VRFrameData;
	var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;
	var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;
	var VRDisplayHMDDevice = _dereq_('./display-wrappers.js').VRDisplayHMDDevice;
	var VRDisplayPositionSensorDevice = _dereq_('./display-wrappers.js').VRDisplayPositionSensorDevice;
	
	function WebVRPolyfill() {
	  this.displays = [];
	  this.devices = []; // For deprecated objects
	  this.devicesPopulated = false;
	  this.nativeWebVRAvailable = this.isWebVRAvailable();
	  this.nativeLegacyWebVRAvailable = this.isDeprecatedWebVRAvailable();
	
	  if (!this.nativeLegacyWebVRAvailable) {
	    if (!this.nativeWebVRAvailable) {
	      this.enablePolyfill();
	    }
	    if (WebVRConfig.ENABLE_DEPRECATED_API) {
	      this.enableDeprecatedPolyfill();
	    }
	  }
	
	  // Put a shim in place to update the API to 1.1 if needed.
	  InstallWebVRSpecShim();
	}
	
	WebVRPolyfill.prototype.isWebVRAvailable = function() {
	  return ('getVRDisplays' in navigator);
	};
	
	WebVRPolyfill.prototype.isDeprecatedWebVRAvailable = function() {
	  return ('getVRDevices' in navigator) || ('mozGetVRDevices' in navigator);
	};
	
	WebVRPolyfill.prototype.populateDevices = function() {
	  if (this.devicesPopulated) {
	    return;
	  }
	
	  // Initialize our virtual VR devices.
	  var vrDisplay = null;
	
	  // Add a Cardboard VRDisplay on compatible mobile devices
	  if (this.isCardboardCompatible()) {
	    vrDisplay = new CardboardVRDisplay();
	    this.displays.push(vrDisplay);
	
	    // For backwards compatibility
	    if (WebVRConfig.ENABLE_DEPRECATED_API) {
	      this.devices.push(new VRDisplayHMDDevice(vrDisplay));
	      this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
	    }
	  }
	
	  // Add a Mouse and Keyboard driven VRDisplay for desktops/laptops
	  if (!this.isMobile() && !WebVRConfig.MOUSE_KEYBOARD_CONTROLS_DISABLED) {
	    vrDisplay = new MouseKeyboardVRDisplay();
	    this.displays.push(vrDisplay);
	
	    // For backwards compatibility
	    if (WebVRConfig.ENABLE_DEPRECATED_API) {
	      this.devices.push(new VRDisplayHMDDevice(vrDisplay));
	      this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
	    }
	  }
	
	  // Uncomment to add positional tracking via webcam.
	  //if (!this.isMobile() && WebVRConfig.ENABLE_DEPRECATED_API) {
	  //  positionDevice = new WebcamPositionSensorVRDevice();
	  //  this.devices.push(positionDevice);
	  //}
	
	  this.devicesPopulated = true;
	};
	
	WebVRPolyfill.prototype.enablePolyfill = function() {
	  // Provide navigator.getVRDisplays.
	  navigator.getVRDisplays = this.getVRDisplays.bind(this);
	
	  // Provide the VRDisplay object.
	  window.VRDisplay = VRDisplay;
	
	  // Provide navigator.vrEnabled.
	  var self = this;
	  Object.defineProperty(navigator, 'vrEnabled', {
	    get: function () {
	      return self.isCardboardCompatible() &&
	        (document.fullscreenEnabled ||
	          document.mozFullScreenEnabled ||
	          document.webkitFullscreenEnabled ||
	          false);
	    }
	  });
	
	  // Provide the VRFrameData object.
	  window.VRFrameData = VRFrameData;
	};
	
	WebVRPolyfill.prototype.enableDeprecatedPolyfill = function() {
	  // Provide navigator.getVRDevices.
	  navigator.getVRDevices = this.getVRDevices.bind(this);
	
	  // Provide the CardboardHMDVRDevice and PositionSensorVRDevice objects.
	  window.HMDVRDevice = HMDVRDevice;
	  window.PositionSensorVRDevice = PositionSensorVRDevice;
	};
	
	WebVRPolyfill.prototype.getVRDisplays = function() {
	  this.populateDevices();
	  var displays = this.displays;
	  return new Promise(function(resolve, reject) {
	    try {
	      resolve(displays);
	    } catch (e) {
	      reject(e);
	    }
	  });
	};
	
	WebVRPolyfill.prototype.getVRDevices = function() {
	  console.warn('getVRDevices is deprecated. Please update your code to use getVRDisplays instead.');
	  var self = this;
	  return new Promise(function(resolve, reject) {
	    try {
	      if (!self.devicesPopulated) {
	        if (self.nativeWebVRAvailable) {
	          return navigator.getVRDisplays(function(displays) {
	            for (var i = 0; i < displays.length; ++i) {
	              self.devices.push(new VRDisplayHMDDevice(displays[i]));
	              self.devices.push(new VRDisplayPositionSensorDevice(displays[i]));
	            }
	            self.devicesPopulated = true;
	            resolve(self.devices);
	          }, reject);
	        }
	
	        if (self.nativeLegacyWebVRAvailable) {
	          return (navigator.getVRDDevices || navigator.mozGetVRDevices)(function(devices) {
	            for (var i = 0; i < devices.length; ++i) {
	              if (devices[i] instanceof HMDVRDevice) {
	                self.devices.push(devices[i]);
	              }
	              if (devices[i] instanceof PositionSensorVRDevice) {
	                self.devices.push(devices[i]);
	              }
	            }
	            self.devicesPopulated = true;
	            resolve(self.devices);
	          }, reject);
	        }
	      }
	
	      self.populateDevices();
	      resolve(self.devices);
	    } catch (e) {
	      reject(e);
	    }
	  });
	};
	
	/**
	 * Determine if a device is mobile.
	 */
	WebVRPolyfill.prototype.isMobile = function() {
	  return /Android/i.test(navigator.userAgent) ||
	      /iPhone|iPad|iPod/i.test(navigator.userAgent);
	};
	
	WebVRPolyfill.prototype.isCardboardCompatible = function() {
	  // For now, support all iOS and Android devices.
	  // Also enable the WebVRConfig.FORCE_VR flag for debugging.
	  return this.isMobile() || WebVRConfig.FORCE_ENABLE_VR;
	};
	
	// Installs a shim that updates a WebVR 1.0 spec implementation to WebVR 1.1
	function InstallWebVRSpecShim() {
	  if ('VRDisplay' in window && !('VRFrameData' in window)) {
	    // Provide the VRFrameData object.
	    window.VRFrameData = VRFrameData;
	
	    // A lot of Chrome builds don't have depthNear and depthFar, even
	    // though they're in the WebVR 1.0 spec. Patch them in if they're not present.
	    if(!('depthNear' in window.VRDisplay.prototype)) {
	      window.VRDisplay.prototype.depthNear = 0.01;
	    }
	
	    if(!('depthFar' in window.VRDisplay.prototype)) {
	      window.VRDisplay.prototype.depthFar = 10000.0;
	    }
	
	    window.VRDisplay.prototype.getFrameData = function(frameData) {
	      return Util.frameDataFromPose(frameData, this.getPose(), this);
	    }
	  }
	};
	
	module.exports.WebVRPolyfill = WebVRPolyfill;
	
	},{"./base.js":2,"./cardboard-vr-display.js":5,"./display-wrappers.js":8,"./mouse-keyboard-vr-display.js":15,"./util.js":22}]},{},[13]);


/***/ },
/* 337 */
/*!*******************************************!*\
  !*** ./src/translators/utils/vrEffect.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 80);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	__webpack_require__(/*! webvr-polyfill */ 336);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @author dmarcos / https://github.com/dmarcos
	 * @author mrdoob / http://mrdoob.com
	 *
	 * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html
	 *
	 * Firefox: http://mozvr.com/downloads/
	 * Chromium: https://drive.google.com/folderview?id=0BzudLt22BqGRbW9WTHMtOWMzNjQ&usp=sharing#list
	 *
	 */
	
	_three2.default.VREffect = function (renderer, vrDisplay, onError) {
	
		var isWebVR1 = true;
	
		var eyeTranslationL = new _three2.default.Vector3();
		var eyeTranslationR = new _three2.default.Vector3();
		var renderRectL, renderRectR;
		var eyeFOVL, eyeFOVR;
	
		this.isPresenting = false;
		this.scale = 1;
	
		var scope = this;
	
		var rendererSize = renderer.getSize();
		var rendererPixelRatio = renderer.getPixelRatio();
	
		this.getVRDisplay = function () {
	
			return vrDisplay;
		};
	
		this.setSize = function (width, height) {
	
			rendererSize = { width: width, height: height };
	
			if (scope.isPresenting) {
	
				var eyeParamsL = vrDisplay.getEyeParameters('left');
				renderer.setPixelRatio(1);
	
				if (isWebVR1) {
	
					renderer.setSize(eyeParamsL.renderWidth * 2, eyeParamsL.renderHeight, false);
				} else {
	
					renderer.setSize(eyeParamsL.renderRect.width * 2, eyeParamsL.renderRect.height, false);
				}
			} else {
	
				renderer.setPixelRatio(rendererPixelRatio);
				renderer.setSize(width, height);
			}
		};
	
		// fullscreen
	
		var canvas = renderer.domElement;
		var requestFullscreen;
		var exitFullscreen;
		var fullscreenElement;
		var leftBounds = [0.0, 0.0, 0.5, 1.0];
		var rightBounds = [0.5, 0.0, 0.5, 1.0];
	
		function onFullscreenChange() {
			var wasPresenting = scope.isPresenting;
			scope.isPresenting = vrDisplay !== undefined && (vrDisplay.isPresenting || !isWebVR1 && document[fullscreenElement] instanceof window.HTMLElement);
	
			if (scope.isPresenting) {
	
				var eyeParamsL = vrDisplay.getEyeParameters('left');
				var eyeWidth, eyeHeight;
	
				if (isWebVR1) {
	
					eyeWidth = eyeParamsL.renderWidth;
					eyeHeight = eyeParamsL.renderHeight;
	
					if (vrDisplay.getLayers) {
	
						var layers = vrDisplay.getLayers();
						if (layers.length) {
	
							leftBounds = layers[0].leftBounds || [0.0, 0.0, 0.5, 1.0];
							rightBounds = layers[0].rightBounds || [0.5, 0.0, 0.5, 1.0];
						}
					}
				} else {
	
					eyeWidth = eyeParamsL.renderRect.width;
					eyeHeight = eyeParamsL.renderRect.height;
				}
	
				if (!wasPresenting) {
	
					rendererPixelRatio = renderer.getPixelRatio();
					rendererSize = renderer.getSize();
	
					renderer.setPixelRatio(1);
					renderer.setSize(eyeWidth * 2, eyeHeight, false);
				}
			} else if (wasPresenting) {
	
				renderer.setPixelRatio(rendererPixelRatio);
				renderer.setSize(rendererSize.width, rendererSize.height);
			}
		}
	
		if (canvas.requestFullscreen) {
	
			requestFullscreen = 'requestFullscreen';
			fullscreenElement = 'fullscreenElement';
			exitFullscreen = 'exitFullscreen';
			document.addEventListener('fullscreenchange', onFullscreenChange, false);
		} else if (canvas.mozRequestFullScreen) {
	
			requestFullscreen = 'mozRequestFullScreen';
			fullscreenElement = 'mozFullScreenElement';
			exitFullscreen = 'mozCancelFullScreen';
			document.addEventListener('mozfullscreenchange', onFullscreenChange, false);
		} else {
	
			requestFullscreen = 'webkitRequestFullscreen';
			fullscreenElement = 'webkitFullscreenElement';
			exitFullscreen = 'webkitExitFullscreen';
			document.addEventListener('webkitfullscreenchange', onFullscreenChange, false);
		}
	
		window.addEventListener('vrdisplaypresentchange', onFullscreenChange, false);
	
		this.setFullScreen = function (boolean) {
	
			return new _promise2.default(function (resolve, reject) {
	
				if (vrDisplay === undefined) {
	
					reject(new Error('No VR hardware found.'));
					return;
				}
	
				if (scope.isPresenting === boolean) {
	
					resolve();
					return;
				}
	
				if (isWebVR1) {
	
					if (boolean) {
	
						resolve(vrDisplay.requestPresent([{ source: canvas }]));
					} else {
	
						resolve(vrDisplay.exitPresent());
					}
				} else {
	
					if (canvas[requestFullscreen]) {
	
						canvas[boolean ? requestFullscreen : exitFullscreen]({ vrDisplay: vrDisplay });
						resolve();
					} else {
	
						console.error('No compatible requestFullscreen method found.');
						reject(new Error('No compatible requestFullscreen method found.'));
					}
				}
			});
		};
	
		this.requestPresent = function () {
	
			return this.setFullScreen(true);
		};
	
		this.exitPresent = function () {
	
			return this.setFullScreen(false);
		};
	
		this.requestAnimationFrame = function (f) {
	
			if (isWebVR1 && vrDisplay !== undefined) {
	
				return vrDisplay.requestAnimationFrame(f);
			} else {
	
				return window.requestAnimationFrame(f);
			}
		};
	
		this.cancelAnimationFrame = function (h) {
	
			if (isWebVR1 && vrDisplay !== undefined) {
	
				vrDisplay.cancelAnimationFrame(h);
			} else {
	
				window.cancelAnimationFrame(h);
			}
		};
	
		this.submitFrame = function () {
	
			if (isWebVR1 && vrDisplay !== undefined && scope.isPresenting) {
	
				vrDisplay.submitFrame();
			}
		};
	
		this.autoSubmitFrame = true;
	
		// render
	
		var cameraL = new _three2.default.PerspectiveCamera();
		cameraL.layers.enable(1);
	
		var cameraR = new _three2.default.PerspectiveCamera();
		cameraR.layers.enable(2);
	
		this.render = function (scene, camera, renderTarget, forceClear) {
	
			if (vrDisplay && scope.isPresenting) {
	
				var autoUpdate = scene.autoUpdate;
	
				if (autoUpdate) {
	
					scene.updateMatrixWorld();
					scene.autoUpdate = false;
				}
	
				var eyeParamsL = vrDisplay.getEyeParameters('left');
				var eyeParamsR = vrDisplay.getEyeParameters('right');
	
				if (isWebVR1) {
	
					eyeTranslationL.fromArray(eyeParamsL.offset);
					eyeTranslationR.fromArray(eyeParamsR.offset);
					eyeFOVL = eyeParamsL.fieldOfView;
					eyeFOVR = eyeParamsR.fieldOfView;
				} else {
	
					eyeTranslationL.copy(eyeParamsL.eyeTranslation);
					eyeTranslationR.copy(eyeParamsR.eyeTranslation);
					eyeFOVL = eyeParamsL.recommendedFieldOfView;
					eyeFOVR = eyeParamsR.recommendedFieldOfView;
				}
	
				if (Array.isArray(scene)) {
	
					console.warn('THREE.VREffect.render() no longer supports arrays. Use object.layers instead.');
					scene = scene[0];
				}
	
				// When rendering we don't care what the recommended size is, only what the actual size
				// of the backbuffer is.
				var size = renderer.getSize();
				renderRectL = {
					x: Math.round(size.width * leftBounds[0]),
					y: Math.round(size.height * leftBounds[1]),
					width: Math.round(size.width * leftBounds[2]),
					height: Math.round(size.height * leftBounds[3])
				};
				renderRectR = {
					x: Math.round(size.width * rightBounds[0]),
					y: Math.round(size.height * rightBounds[1]),
					width: Math.round(size.width * rightBounds[2]),
					height: Math.round(size.height * rightBounds[3])
				};
	
				if (renderTarget) {
	
					renderer.setRenderTarget(renderTarget);
					renderTarget.scissorTest = true;
				} else {
	
					renderer.setScissorTest(true);
				}
	
				if (renderer.autoClear || forceClear) renderer.clear();
	
				if (camera.parent === null) camera.updateMatrixWorld();
	
				cameraL.projectionMatrix = fovToProjection(eyeFOVL, true, camera.near, camera.far);
				cameraR.projectionMatrix = fovToProjection(eyeFOVR, true, camera.near, camera.far);
	
				camera.matrixWorld.decompose(cameraL.position, cameraL.quaternion, cameraL.scale);
				camera.matrixWorld.decompose(cameraR.position, cameraR.quaternion, cameraR.scale);
	
				var scale = this.scale;
				cameraL.translateOnAxis(eyeTranslationL, scale);
				cameraR.translateOnAxis(eyeTranslationR, scale);
	
				// render left eye
				if (renderTarget) {
	
					renderTarget.viewport.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
					renderTarget.scissor.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
				} else {
	
					renderer.setViewport(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
					renderer.setScissor(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
				}
				renderer.render(scene, cameraL, renderTarget, forceClear);
	
				// render right eye
				if (renderTarget) {
	
					renderTarget.viewport.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
					renderTarget.scissor.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
				} else {
	
					renderer.setViewport(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
					renderer.setScissor(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
				}
				renderer.render(scene, cameraR, renderTarget, forceClear);
	
				if (renderTarget) {
	
					renderTarget.viewport.set(0, 0, size.width, size.height);
					renderTarget.scissor.set(0, 0, size.width, size.height);
					renderTarget.scissorTest = false;
					renderer.setRenderTarget(null);
				} else {
	
					renderer.setScissorTest(false);
				}
	
				if (autoUpdate) {
	
					scene.autoUpdate = true;
				}
	
				if (scope.autoSubmitFrame) {
	
					scope.submitFrame();
				}
	
				return;
			}
	
			// Regular render mode if not HMD
	
			renderer.render(scene, camera, renderTarget, forceClear);
		};
	
		//
	
		function fovToNDCScaleOffset(fov) {
	
			var pxscale = 2.0 / (fov.leftTan + fov.rightTan);
			var pxoffset = (fov.leftTan - fov.rightTan) * pxscale * 0.5;
			var pyscale = 2.0 / (fov.upTan + fov.downTan);
			var pyoffset = (fov.upTan - fov.downTan) * pyscale * 0.5;
			return { scale: [pxscale, pyscale], offset: [pxoffset, pyoffset] };
		}
	
		function fovPortToProjection(fov, rightHanded, zNear, zFar) {
	
			rightHanded = rightHanded === undefined ? true : rightHanded;
			zNear = zNear === undefined ? 0.01 : zNear;
			zFar = zFar === undefined ? 10000.0 : zFar;
	
			var handednessScale = rightHanded ? -1.0 : 1.0;
	
			// start with an identity matrix
			var mobj = new _three2.default.Matrix4();
			var m = mobj.elements;
	
			// and with scale/offset info for normalized device coords
			var scaleAndOffset = fovToNDCScaleOffset(fov);
	
			// X result, map clip edges to [-w,+w]
			m[0 * 4 + 0] = scaleAndOffset.scale[0];
			m[0 * 4 + 1] = 0.0;
			m[0 * 4 + 2] = scaleAndOffset.offset[0] * handednessScale;
			m[0 * 4 + 3] = 0.0;
	
			// Y result, map clip edges to [-w,+w]
			// Y offset is negated because this proj matrix transforms from world coords with Y=up,
			// but the NDC scaling has Y=down (thanks D3D?)
			m[1 * 4 + 0] = 0.0;
			m[1 * 4 + 1] = scaleAndOffset.scale[1];
			m[1 * 4 + 2] = -scaleAndOffset.offset[1] * handednessScale;
			m[1 * 4 + 3] = 0.0;
	
			// Z result (up to the app)
			m[2 * 4 + 0] = 0.0;
			m[2 * 4 + 1] = 0.0;
			m[2 * 4 + 2] = zFar / (zNear - zFar) * -handednessScale;
			m[2 * 4 + 3] = zFar * zNear / (zNear - zFar);
	
			// W result (= Z in)
			m[3 * 4 + 0] = 0.0;
			m[3 * 4 + 1] = 0.0;
			m[3 * 4 + 2] = handednessScale;
			m[3 * 4 + 3] = 0.0;
	
			mobj.transpose();
	
			return mobj;
		}
	
		function fovToProjection(fov, rightHanded, zNear, zFar) {
	
			var DEG2RAD = Math.PI / 180.0;
	
			var fovPort = {
				upTan: Math.tan(fov.upDegrees * DEG2RAD),
				downTan: Math.tan(fov.downDegrees * DEG2RAD),
				leftTan: Math.tan(fov.leftDegrees * DEG2RAD),
				rightTan: Math.tan(fov.rightDegrees * DEG2RAD)
			};
	
			return fovPortToProjection(fovPort, rightHanded, zNear, zFar);
		}
	};

/***/ },
/* 338 */
/*!*************************************************!*\
  !*** ./src/translators/utils/viveController.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 164);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @author mrdoob / http://mrdoob.com
	 * @author stewdio / http://stewd.io
	 */
	
	_three2.default.ViveController = function (id) {
	
		_three2.default.Object3D.call(this);
	
		var scope = this;
		var gamepad;
	
		var axes = [0, 0];
		var thumbpadIsPressed = false;
		var triggerIsPressed = false;
		var gripsArePressed = false;
		var menuIsPressed = false;
	
		function findGamepad(id) {
	
			// Iterate across gamepads as Vive Controllers may not be
			// in position 0 and 1.
	
			var gamepads = navigator.getGamepads();
	
			for (var i = 0, j = 0; i < 4; i++) {
	
				var gamepad = gamepads[i];
	
				if (gamepad && gamepad.id === 'OpenVR Gamepad') {
	
					if (j === id) return gamepad;
	
					j++;
				}
			}
		}
	
		this.matrixAutoUpdate = false;
		this.standingMatrix = new _three2.default.Matrix4();
	
		this.getGamepad = function () {
	
			return gamepad;
		};
	
		this.getButtonState = function (button) {
	
			if (button === 'thumbpad') return thumbpadIsPressed;
			if (button === 'trigger') return triggerIsPressed;
			if (button === 'grips') return gripsArePressed;
			if (button === 'menu') return menuIsPressed;
		};
	
		this.update = function () {
	
			gamepad = findGamepad(id);
	
			if (gamepad !== undefined && gamepad.pose.position !== null && gamepad.pose.orientation !== null) {
	
				//  Position and orientation.
	
				var pose = gamepad.pose;
	
				scope.position.fromArray(pose.position);
				scope.quaternion.fromArray(pose.orientation);
				scope.matrix.compose(scope.position, scope.quaternion, scope.scale);
				scope.matrix.multiplyMatrices(scope.standingMatrix, scope.matrix);
				scope.matrixWorldNeedsUpdate = true;
				scope.visible = true;
	
				//  Thumbpad and Buttons.
	
				if (axes[0] !== gamepad.axes[0] || axes[1] !== gamepad.axes[1]) {
	
					axes[0] = gamepad.axes[0]; //  X axis: -1 = Left, +1 = Right.
					axes[1] = gamepad.axes[1]; //  Y axis: -1 = Bottom, +1 = Top.
					scope.dispatchEvent({ type: 'axischanged', axes: axes });
				}
	
				if (thumbpadIsPressed !== gamepad.buttons[0].pressed) {
	
					thumbpadIsPressed = gamepad.buttons[0].pressed;
					var event = new Event(thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup');
					//window.dispatchEvent( { type: thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup' } );
					window.dispatchEvent(event);
				}
	
				if (triggerIsPressed !== gamepad.buttons[1].pressed) {
	
					triggerIsPressed = gamepad.buttons[1].pressed;
					//scope.dispatchEvent( { type: triggerIsPressed ? 'triggerdown' : 'triggerup' } );
					var event = new Event(triggerIsPressed ? 'triggerdown' : 'triggerup');
					window.dispatchEvent(event);
				}
	
				if (gripsArePressed !== gamepad.buttons[2].pressed) {
	
					gripsArePressed = gamepad.buttons[2].pressed;
					//scope.dispatchEvent( { type: gripsArePressed ? 'gripsdown' : 'gripsup' } );
					var event = new Event(gripsArePressed ? 'gripsdown' : 'gripsup');
					window.dispatchEvent(event);
				}
	
				if (menuIsPressed !== gamepad.buttons[3].pressed) {
	
					menuIsPressed = gamepad.buttons[3].pressed;
					//scope.dispatchEvent( { type: menuIsPressed ? 'menudown' : 'menuup' } );
					var event = new Event(menuIsPressed ? 'menudown' : 'menuup');
					window.dispatchEvent(event);
				}
			} else {
	
				scope.visible = false;
			}
		};
	};
	
	_three2.default.ViveController.prototype = (0, _create2.default)(_three2.default.Object3D.prototype);
	_three2.default.ViveController.prototype.constructor = _three2.default.ViveController;

/***/ },
/* 339 */
/*!********************************************!*\
  !*** ./src/translators/utils/objLoader.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	_three2.default.OBJLoader = function (manager) {
	
		this.manager = manager !== undefined ? manager : _three2.default.DefaultLoadingManager;
	
		this.materials = null;
	
		this.regexp = {
			// v float float float
			vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
			// vn float float float
			normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
			// vt float float
			uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
			// f vertex vertex vertex
			face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
			// f vertex/uv vertex/uv vertex/uv
			face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
			// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
			face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
			// f vertex//normal vertex//normal vertex//normal
			face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
			// o object_name | g group_name
			object_pattern: /^[og]\s*(.+)?/,
			// s boolean
			smoothing_pattern: /^s\s+(\d+|on|off)/,
			// mtllib file_reference
			material_library_pattern: /^mtllib /,
			// usemtl material_name
			material_use_pattern: /^usemtl /
		};
	};
	
	_three2.default.OBJLoader.prototype = {
	
		constructor: _three2.default.OBJLoader,
	
		load: function load(url, onLoad, onProgress, onError) {
	
			var scope = this;
	
			var loader = new _three2.default.XHRLoader(scope.manager);
			loader.setPath(this.path);
			loader.load(url, function (text) {
	
				onLoad(scope.parse(text));
			}, onProgress, onError);
		},
	
		setPath: function setPath(value) {
	
			this.path = value;
		},
	
		setMaterials: function setMaterials(materials) {
	
			this.materials = materials;
		},
	
		_createParserState: function _createParserState() {
	
			var state = {
				objects: [],
				object: {},
	
				vertices: [],
				normals: [],
				uvs: [],
	
				materialLibraries: [],
	
				startObject: function startObject(name, fromDeclaration) {
	
					// If the current object (initial from reset) is not from a g/o declaration in the parsed
					// file. We need to use it for the first parsed g/o to keep things in sync.
					if (this.object && this.object.fromDeclaration === false) {
	
						this.object.name = name;
						this.object.fromDeclaration = fromDeclaration !== false;
						return;
					}
	
					if (this.object && typeof this.object._finalize === 'function') {
	
						this.object._finalize();
					}
	
					var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;
	
					this.object = {
						name: name || '',
						fromDeclaration: fromDeclaration !== false,
	
						geometry: {
							vertices: [],
							normals: [],
							uvs: []
						},
						materials: [],
						smooth: true,
	
						startMaterial: function startMaterial(name, libraries) {
	
							var previous = this._finalize(false);
	
							// New usemtl declaration overwrites an inherited material, except if faces were declared
							// after the material, then it must be preserved for proper MultiMaterial continuation.
							if (previous && (previous.inherited || previous.groupCount <= 0)) {
	
								this.materials.splice(previous.index, 1);
							}
	
							var material = {
								index: this.materials.length,
								name: name || '',
								mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
								smooth: previous !== undefined ? previous.smooth : this.smooth,
								groupStart: previous !== undefined ? previous.groupEnd : 0,
								groupEnd: -1,
								groupCount: -1,
								inherited: false,
	
								clone: function clone(index) {
									return {
										index: typeof index === 'number' ? index : this.index,
										name: this.name,
										mtllib: this.mtllib,
										smooth: this.smooth,
										groupStart: this.groupEnd,
										groupEnd: -1,
										groupCount: -1,
										inherited: false
									};
								}
							};
	
							this.materials.push(material);
	
							return material;
						},
	
						currentMaterial: function currentMaterial() {
	
							if (this.materials.length > 0) {
								return this.materials[this.materials.length - 1];
							}
	
							return undefined;
						},
	
						_finalize: function _finalize(end) {
	
							var lastMultiMaterial = this.currentMaterial();
							if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
	
								lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
								lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
								lastMultiMaterial.inherited = false;
							}
	
							// Guarantee at least one empty material, this makes the creation later more straight forward.
							if (end !== false && this.materials.length === 0) {
								this.materials.push({
									name: '',
									smooth: this.smooth
								});
							}
	
							return lastMultiMaterial;
						}
					};
	
					// Inherit previous objects material.
					// Spec tells us that a declared material must be set to all objects until a new material is declared.
					// If a usemtl declaration is encountered while this new object is being parsed, it will
					// overwrite the inherited material. Exception being that there was already face declarations
					// to the inherited material, then it will be preserved for proper MultiMaterial continuation.
	
					if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
	
						var declared = previousMaterial.clone(0);
						declared.inherited = true;
						this.object.materials.push(declared);
					}
	
					this.objects.push(this.object);
				},
	
				finalize: function finalize() {
	
					if (this.object && typeof this.object._finalize === 'function') {
	
						this.object._finalize();
					}
				},
	
				parseVertexIndex: function parseVertexIndex(value, len) {
	
					var index = parseInt(value, 10);
					return (index >= 0 ? index - 1 : index + len / 3) * 3;
				},
	
				parseNormalIndex: function parseNormalIndex(value, len) {
	
					var index = parseInt(value, 10);
					return (index >= 0 ? index - 1 : index + len / 3) * 3;
				},
	
				parseUVIndex: function parseUVIndex(value, len) {
	
					var index = parseInt(value, 10);
					return (index >= 0 ? index - 1 : index + len / 2) * 2;
				},
	
				addVertex: function addVertex(a, b, c) {
	
					var src = this.vertices;
					var dst = this.object.geometry.vertices;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[a + 2]);
					dst.push(src[b + 0]);
					dst.push(src[b + 1]);
					dst.push(src[b + 2]);
					dst.push(src[c + 0]);
					dst.push(src[c + 1]);
					dst.push(src[c + 2]);
				},
	
				addVertexLine: function addVertexLine(a) {
	
					var src = this.vertices;
					var dst = this.object.geometry.vertices;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[a + 2]);
				},
	
				addNormal: function addNormal(a, b, c) {
	
					var src = this.normals;
					var dst = this.object.geometry.normals;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[a + 2]);
					dst.push(src[b + 0]);
					dst.push(src[b + 1]);
					dst.push(src[b + 2]);
					dst.push(src[c + 0]);
					dst.push(src[c + 1]);
					dst.push(src[c + 2]);
				},
	
				addUV: function addUV(a, b, c) {
	
					var src = this.uvs;
					var dst = this.object.geometry.uvs;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[b + 0]);
					dst.push(src[b + 1]);
					dst.push(src[c + 0]);
					dst.push(src[c + 1]);
				},
	
				addUVLine: function addUVLine(a) {
	
					var src = this.uvs;
					var dst = this.object.geometry.uvs;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
				},
	
				addFace: function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
	
					var vLen = this.vertices.length;
	
					var ia = this.parseVertexIndex(a, vLen);
					var ib = this.parseVertexIndex(b, vLen);
					var ic = this.parseVertexIndex(c, vLen);
					var id;
	
					if (d === undefined) {
	
						this.addVertex(ia, ib, ic);
					} else {
	
						id = this.parseVertexIndex(d, vLen);
	
						this.addVertex(ia, ib, id);
						this.addVertex(ib, ic, id);
					}
	
					if (ua !== undefined) {
	
						var uvLen = this.uvs.length;
	
						ia = this.parseUVIndex(ua, uvLen);
						ib = this.parseUVIndex(ub, uvLen);
						ic = this.parseUVIndex(uc, uvLen);
	
						if (d === undefined) {
	
							this.addUV(ia, ib, ic);
						} else {
	
							id = this.parseUVIndex(ud, uvLen);
	
							this.addUV(ia, ib, id);
							this.addUV(ib, ic, id);
						}
					}
	
					if (na !== undefined) {
	
						// Normals are many times the same. If so, skip function call and parseInt.
						var nLen = this.normals.length;
						ia = this.parseNormalIndex(na, nLen);
	
						ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
						ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
	
						if (d === undefined) {
	
							this.addNormal(ia, ib, ic);
						} else {
	
							id = this.parseNormalIndex(nd, nLen);
	
							this.addNormal(ia, ib, id);
							this.addNormal(ib, ic, id);
						}
					}
				},
	
				addLineGeometry: function addLineGeometry(vertices, uvs) {
	
					this.object.geometry.type = 'Line';
	
					var vLen = this.vertices.length;
					var uvLen = this.uvs.length;
	
					for (var vi = 0, l = vertices.length; vi < l; vi++) {
	
						this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
					}
	
					for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {
	
						this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
					}
				}
	
			};
	
			state.startObject('', false);
	
			return state;
		},
	
		parse: function parse(text) {
	
			console.time('OBJLoader');
	
			var state = this._createParserState();
	
			if (text.indexOf('\r\n') !== -1) {
	
				// This is faster than String.split with regex that splits on both
				text = text.replace('\r\n', '\n');
			}
	
			var lines = text.split('\n');
			var line = '',
			    lineFirstChar = '',
			    lineSecondChar = '';
			var lineLength = 0;
			var result = [];
	
			// Faster to just trim left side of the line. Use if available.
			var trimLeft = typeof ''.trimLeft === 'function';
	
			for (var i = 0, l = lines.length; i < l; i++) {
	
				line = lines[i];
	
				line = trimLeft ? line.trimLeft() : line.trim();
	
				lineLength = line.length;
	
				if (lineLength === 0) continue;
	
				lineFirstChar = line.charAt(0);
	
				// @todo invoke passed in handler if any
				if (lineFirstChar === '#') continue;
	
				if (lineFirstChar === 'v') {
	
					lineSecondChar = line.charAt(1);
	
					if (lineSecondChar === ' ' && (result = this.regexp.vertex_pattern.exec(line)) !== null) {
	
						// 0                  1      2      3
						// ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
	
						state.vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
					} else if (lineSecondChar === 'n' && (result = this.regexp.normal_pattern.exec(line)) !== null) {
	
						// 0                   1      2      3
						// ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
	
						state.normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
					} else if (lineSecondChar === 't' && (result = this.regexp.uv_pattern.exec(line)) !== null) {
	
						// 0               1      2
						// ["vt 0.1 0.2", "0.1", "0.2"]
	
						state.uvs.push(parseFloat(result[1]), parseFloat(result[2]));
					} else {
	
						throw new Error("Unexpected vertex/normal/uv line: '" + line + "'");
					}
				} else if (lineFirstChar === "f") {
	
					if ((result = this.regexp.face_vertex_uv_normal.exec(line)) !== null) {
	
						// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
						// 0                        1    2    3    4    5    6    7    8    9   10         11         12
						// ["f 1/1/1 2/2/2 3/3/3", "1", "1", "1", "2", "2", "2", "3", "3", "3", undefined, undefined, undefined]
	
						state.addFace(result[1], result[4], result[7], result[10], result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
					} else if ((result = this.regexp.face_vertex_uv.exec(line)) !== null) {
	
						// f vertex/uv vertex/uv vertex/uv
						// 0                  1    2    3    4    5    6   7          8
						// ["f 1/1 2/2 3/3", "1", "1", "2", "2", "3", "3", undefined, undefined]
	
						state.addFace(result[1], result[3], result[5], result[7], result[2], result[4], result[6], result[8]);
					} else if ((result = this.regexp.face_vertex_normal.exec(line)) !== null) {
	
						// f vertex//normal vertex//normal vertex//normal
						// 0                     1    2    3    4    5    6   7          8
						// ["f 1//1 2//2 3//3", "1", "1", "2", "2", "3", "3", undefined, undefined]
	
						state.addFace(result[1], result[3], result[5], result[7], undefined, undefined, undefined, undefined, result[2], result[4], result[6], result[8]);
					} else if ((result = this.regexp.face_vertex.exec(line)) !== null) {
	
						// f vertex vertex vertex
						// 0            1    2    3   4
						// ["f 1 2 3", "1", "2", "3", undefined]
	
						state.addFace(result[1], result[2], result[3], result[4]);
					} else {
	
						throw new Error("Unexpected face line: '" + line + "'");
					}
				} else if (lineFirstChar === "l") {
	
					var lineParts = line.substring(1).trim().split(" ");
					var lineVertices = [],
					    lineUVs = [];
	
					if (line.indexOf("/") === -1) {
	
						lineVertices = lineParts;
					} else {
	
						for (var li = 0, llen = lineParts.length; li < llen; li++) {
	
							var parts = lineParts[li].split("/");
	
							if (parts[0] !== "") lineVertices.push(parts[0]);
							if (parts[1] !== "") lineUVs.push(parts[1]);
						}
					}
					state.addLineGeometry(lineVertices, lineUVs);
				} else if ((result = this.regexp.object_pattern.exec(line)) !== null) {
	
					// o object_name
					// or
					// g group_name
	
					var name = result[0].substr(1).trim();
					state.startObject(name);
				} else if (this.regexp.material_use_pattern.test(line)) {
	
					// material
	
					state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
				} else if (this.regexp.material_library_pattern.test(line)) {
	
					// mtl file
	
					state.materialLibraries.push(line.substring(7).trim());
				} else if ((result = this.regexp.smoothing_pattern.exec(line)) !== null) {
	
					// smooth shading
	
					// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
					// but does not define a usemtl for each face set.
					// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
					// This requires some care to not create extra material on each smooth value for "normal" obj files.
					// where explicit usemtl defines geometry groups.
					// Example asset: examples/models/obj/cerberus/Cerberus.obj
	
					var value = result[1].trim().toLowerCase();
					state.object.smooth = value === '1' || value === 'on';
	
					var material = state.object.currentMaterial();
					if (material) {
	
						material.smooth = state.object.smooth;
					}
				} else {
	
					// Handle null terminated files without exception
					if (line === '\0') continue;
	
					throw new Error("Unexpected line: '" + line + "'");
				}
			}
	
			state.finalize();
	
			var container = new _three2.default.Group();
			container.materialLibraries = [].concat(state.materialLibraries);
	
			for (var i = 0, l = state.objects.length; i < l; i++) {
	
				var object = state.objects[i];
				var geometry = object.geometry;
				var materials = object.materials;
				var isLine = geometry.type === 'Line';
	
				// Skip o/g line declarations that did not follow with any faces
				if (geometry.vertices.length === 0) continue;
	
				var buffergeometry = new _three2.default.BufferGeometry();
	
				buffergeometry.addAttribute('position', new _three2.default.BufferAttribute(new Float32Array(geometry.vertices), 3));
	
				if (geometry.normals.length > 0) {
	
					buffergeometry.addAttribute('normal', new _three2.default.BufferAttribute(new Float32Array(geometry.normals), 3));
				} else {
	
					buffergeometry.computeVertexNormals();
				}
	
				if (geometry.uvs.length > 0) {
	
					buffergeometry.addAttribute('uv', new _three2.default.BufferAttribute(new Float32Array(geometry.uvs), 2));
				}
	
				// Create materials
	
				var createdMaterials = [];
	
				for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
	
					var sourceMaterial = materials[mi];
					var material = undefined;
	
					if (this.materials !== null) {
	
						material = this.materials.create(sourceMaterial.name);
	
						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if (isLine && material && !(material instanceof _three2.default.LineBasicMaterial)) {
	
							var materialLine = new _three2.default.LineBasicMaterial();
							materialLine.copy(material);
							material = materialLine;
						}
					}
	
					if (!material) {
	
						material = !isLine ? new _three2.default.MeshPhongMaterial() : new _three2.default.LineBasicMaterial();
						material.name = sourceMaterial.name;
					}
	
					material.shading = sourceMaterial.smooth ? _three2.default.SmoothShading : _three2.default.FlatShading;
	
					createdMaterials.push(material);
				}
	
				// Create mesh
	
				var mesh;
	
				if (createdMaterials.length > 1) {
	
					for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
	
						var sourceMaterial = materials[mi];
						buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
					}
	
					var multiMaterial = new _three2.default.MultiMaterial(createdMaterials);
					mesh = !isLine ? new _three2.default.Mesh(buffergeometry, multiMaterial) : new _three2.default.LineSegments(buffergeometry, multiMaterial);
				} else {
	
					mesh = !isLine ? new _three2.default.Mesh(buffergeometry, createdMaterials[0]) : new _three2.default.LineSegments(buffergeometry, createdMaterials[0]);
				}
	
				mesh.name = object.name;
	
				container.add(mesh);
			}
	
			console.timeEnd('OBJLoader');
	
			return container;
		}
	
	};

/***/ },
/* 340 */
/*!******************************************!*\
  !*** ./src/translators/utils/reticle.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_three2.default.Reticle = function (camera) {
	
	    var reticle = {};
	
	    reticle.armObject = null;
	    reticle.reticleObject = null;
	    reticle.dot = null;
	    reticle.intersection = null;
	    reticle.colliders = [];
	
	    var defaultMaterial = new _three2.default.MeshBasicMaterial({ color: '#a9a9a9', transparent: true, opacity: 0 });
	    var hitMaterial = new _three2.default.MeshBasicMaterial({ color: '#ff0000', transparent: true, opacity: 0.7 });
	
	    reticle.createDefaultObject = function (position, length, isDot) {
	        if (isDot) {
	            var defaultGeometry = new _three2.default.SphereGeometry(0.007, 32, length);
	        } else {
	            var defaultGeometry = new _three2.default.TorusGeometry(0.2, 0.04, 16, 100);
	        }
	        var defaultObject = new _three2.default.Mesh(defaultGeometry, defaultMaterial);
	        defaultObject.position.copy(position);
	        defaultObject.rotation.x = -Math.PI * 0.5;
	        return defaultObject;
	    };
	
	    reticle.init = function (camera) {
	        this.camera = camera;
	        this.armObject = new _three2.default.Object3D();
	        this.reticleObject = this.createDefaultObject(new _three2.default.Vector3(0, 0, -0.5), .01, false);
	        this.armObject.add(this.reticleObject);
	
	        this.dot = this.createDefaultObject(new _three2.default.Vector3(0, 0, -0.5), .01, true);
	        this.camera.add(this.armObject);
	        this.camera.add(this.dot);
	        this.startClock();
	    };
	
	    reticle.getReticlePosition = function () {
	        return reticle.reticleObject.position;
	    };
	
	    reticle.remvoeFromList = function (object_in, list_in) {
	        var index = list_in.indexOf(object_in);
	        if (index > -1) {
	            list_in.splice(index, 1);
	        }
	    };
	
	    reticle.addCollider = function (threeObject) {
	        this.colliders.push(threeObject);
	    };
	
	    reticle.removeCollider = function (threeObject) {
	        this.remvoeFromList(threeObject, reticle.colliders);
	    };
	
	    reticle.update = function (parent) {
	        var camDirection = new _three2.default.Vector3();
	        this.camera.getWorldDirection(camDirection);
	        var ray = new _three2.default.Raycaster(this.camera.position, camDirection);
	
	        var intersects = ray.intersectObjects(this.colliders);
	        if (intersects.length > 0) {
	            //save the new hit object and time
	            this.intersection = intersects[0];
	            this.reticleObject.position.copy(this.intersection.point);
	            if (parent) this.reticleObject.position.sub(parent.position);
	
	            this.reticleObject.material = hitMaterial;
	            this.dot.material.opacity = 0;
	        } else {
	            this.dot.material.opacity = 1;
	            this.reticleObject.material = defaultMaterial;
	        }
	    };
	
	    reticle.startClock = function () {
	        this.clock = new _three2.default.Clock(true);
	    };
	
	    reticle.init(camera);
	
	    return reticle;
	};

/***/ },
/* 341 */
/*!*********************************************!*\
  !*** ./src/translators/utils/vrControls.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @author dmarcos / https://github.com/dmarcos
	 * @author mrdoob / http://mrdoob.com
	 */
	
	_three2.default.VRControls = function (object, onError) {
	
		var scope = this;
	
		var vrDisplay, vrDisplays;
	
		var standingMatrix = new _three2.default.Matrix4();
	
		function gotVRDisplays(displays) {
	
			vrDisplays = displays;
	
			for (var i = 0; i < displays.length; i++) {
	
				if ('VRDisplay' in window && displays[i] instanceof VRDisplay || 'PositionSensorVRDevice' in window && displays[i] instanceof PositionSensorVRDevice) {
	
					vrDisplay = displays[i];
					break; // We keep the first we encounter
				}
			}
	
			if (vrDisplay === undefined) {
	
				if (onError) onError('VR input not available.');
			}
		}
	
		if (navigator.getVRDisplays) {
	
			navigator.getVRDisplays().then(gotVRDisplays);
		} else if (navigator.getVRDevices) {
	
			// Deprecated API.
			navigator.getVRDevices().then(gotVRDisplays);
		}
	
		// the Rift SDK returns the position in meters
		// this scale factor allows the user to define how meters
		// are converted to scene units.
	
		this.scale = 1;
	
		// If true will use "standing space" coordinate system where y=0 is the
		// floor and x=0, z=0 is the center of the room.
		this.standing = false;
	
		// Distance from the users eyes to the floor in meters. Used when
		// standing=true but the VRDisplay doesn't provide stageParameters.
		this.userHeight = 1.6;
	
		this.offset = new _three2.default.Vector3(0, 0, 0);
	
		this.getVRDisplay = function () {
	
			return vrDisplay;
		};
	
		this.getVRDisplays = function () {
	
			return vrDisplays;
		};
	
		this.getStandingMatrix = function () {
	
			return standingMatrix;
		};
	
		this.update = function () {
	
			if (vrDisplay) {
	
				if (vrDisplay.getPose) {
	
					var pose = vrDisplay.getPose();
					if (pose.orientation !== null) {
	
						object.quaternion.fromArray(pose.orientation);
					}
	
					if (pose.position !== null) {
	
						object.position.fromArray(pose.position);
					} else {
						if (vrDisplay.capabilities.hasExternalDisplay) {
							object.position.set(0, 1.6, 1.5);
							object.quaternion.set(0, 0, 0, 1);
						}
					}
				} else {
	
					// Deprecated API.
					var state = vrDisplay.getState();
	
					if (state.orientation !== null) {
	
						object.quaternion.copy(state.orientation);
					}
	
					if (state.position !== null) {
	
						object.position.copy(state.position);
					} else {
	
						//object.position.set( 0, 0, 0 );
	
					}
				}
	
				if (this.standing) {
	
					if (vrDisplay.stageParameters) {
	
						object.updateMatrix();
	
						standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
						object.applyMatrix(standingMatrix);
					} else {
	
						object.position.setY(object.position.y + this.userHeight);
					}
				}
	
				object.position.multiplyScalar(scope.scale);
				object.position.add(this.offset);
			}
		};
	
		this.resetPose = function () {
	
			if (vrDisplay) {
	
				if (vrDisplay.resetPose !== undefined) {
	
					vrDisplay.resetPose();
				} else if (vrDisplay.resetSensor !== undefined) {
	
					// Deprecated API.
					vrDisplay.resetSensor();
				} else if (vrDisplay.zeroSensor !== undefined) {
	
					// Really deprecated API.
					vrDisplay.zeroSensor();
				}
			}
		};
	
		this.resetSensor = function () {
	
			console.warn('THREE.VRControls: .resetSensor() is now .resetPose().');
			this.resetPose();
		};
	
		this.zeroSensor = function () {
	
			console.warn('THREE.VRControls: .zeroSensor() is now .resetPose().');
			this.resetPose();
		};
	
		this.dispose = function () {
	
			vrDisplay = null;
		};
	
		this.setOffset = function (v) {
			this.offset.copy(v);
		};
	};

/***/ },
/* 342 */
/*!**************************************************!*\
  !*** ./src/translators/tools/firstPersonMode.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = firstPersonMode;
	
	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 98);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _camera = __webpack_require__(/*! ../camera */ 268);
	
	var _decompose = __webpack_require__(/*! ../utils/decompose */ 272);
	
	var _decompose2 = _interopRequireDefault(_decompose);
	
	var _player = __webpack_require__(/*! ../../modules/player */ 265);
	
	var _scene = __webpack_require__(/*! ../../modules/scene */ 147);
	
	var _updateCameraLookAtTarget = __webpack_require__(/*! ../utils/updateCameraLookAtTarget */ 266);
	
	var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);
	
	var _getTargetWorldMatrix = __webpack_require__(/*! ../utils/getTargetWorldMatrix */ 269);
	
	var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);
	
	var _sceneGraph = __webpack_require__(/*! ../../modules/sceneGraph */ 142);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _Math = Math;
	var tan = _Math.tan;
	var cos = _Math.cos;
	var atan = _Math.atan;
	var acos = _Math.acos;
	var min = _Math.min;
	var max = _Math.max;
	var pow = _Math.pow;
	var PI = _Math.PI;
	var sqrt = _Math.sqrt;
	
	var directionKeys = {
	  'w': 'FORWARD',
	  'a': 'LEFT',
	  's': 'BACKWARD',
	  'd': 'RIGHT',
	  'ArrowUp': 'FORWARD',
	  'ArrowLeft': 'LEFT',
	  'ArrowDown': 'BACKWARD',
	  'ArrowRight': 'RIGHT'
	};
	
	var directions = {
	  FORWARD: ['y', 1],
	  BACKWARD: ['y', -1],
	  LEFT: ['x', -1],
	  RIGHT: ['x', 1]
	};
	
	var SPEED = 0.2;
	function firstPersonMode(store, translator) {
	  var oldOrbitMode = '';
	  var velocity = new _three2.default.Vector3(0, 0, 0);
	  var axes = { x: 0, y: 0, z: 0 };
	
	  function setVelocity(axis, factor) {
	    axes[axis] += factor;
	    velocity = new _three2.default.Vector3(axes.x, axes.y, axes.z).normalize().multiplyScalar(SPEED);
	  }
	
	  return {
	    name: 'firstPersonMode',
	    active: false,
	    enabled: true,
	    options: {
	      movementMode: 'fly',
	      keyboardEnabled: true
	    },
	    display: {
	      playerTools: false
	    },
	
	    heldKeys: [],
	
	    tool: {
	
	      keydown: function keydown(ev) {
	        var direction = directionKeys[ev.key];
	        if (direction && this.active) {
	          this.heldKeys.push(ev.key);
	
	          var _directions$direction = (0, _slicedToArray3.default)(directions[direction], 2);
	
	          var axis = _directions$direction[0];
	          var factor = _directions$direction[1];
	
	          setVelocity(axis, factor);
	        }
	      },
	
	      keyup: function keyup(ev) {
	        var direction = directionKeys[ev.key];
	        if (direction && this.active) {
	          var idx = this.heldKeys.indexOf(ev.key);
	          this.heldKeys.splice(idx, 1);
	
	          var _directions$direction2 = (0, _slicedToArray3.default)(directions[direction], 2);
	
	          var axis = _directions$direction2[0];
	          var factor = _directions$direction2[1];
	
	          setVelocity(axis, -factor);
	        }
	      },
	
	      keyheld: function keyheld(ev) {
	        var firstKey = this.heldKeys[0];
	        if (ev.key === firstKey && this.options.keyboardEnabled) {
	          var movement = firstPersonMovement(store, velocity, this.options.movementMode);
	          if (movement && translator.externals.vrControls) {
	            translator.externals.vrControls.offset.add(movement);
	          }
	        }
	      }
	    },
	
	    activate: function activate() {
	      oldOrbitMode = (0, _scene.get)(store, { scene: true, plug: 'Player', property: 'orbitMode' });
	      store.dispatch((0, _scene.set)({ scene: true, plug: 'Player', property: 'orbitMode' }, 'firstPerson'));
	    },
	
	    deactivate: function deactivate() {
	      store.dispatch((0, _scene.set)({ scene: true, plug: 'Player', property: 'orbitMode' }, oldOrbitMode));
	    }
	
	  };
	}
	
	var UP_POSITION = new _three2.default.Vector3(0, 1, 0);
	
	function firstPersonMovement(store, direction, movementMode) {
	  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var cameraId = (0, _player.getCamera)(store);
	  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
	  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
	  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	
	  if (targetWorldMatrix && cameraWorldMatrix && cameraData.upPosition) {
	    var cameraPosition = new _three2.default.Vector3();
	    var targetPosition = new _three2.default.Vector3();
	    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
	    targetPosition.setFromMatrixPosition(targetWorldMatrix);
	
	    var forward = new _three2.default.Vector3().subVectors(targetPosition, cameraPosition).normalize();
	    if (movementMode === 'plane') forward.projectOnPlane(UP_POSITION).normalize();
	
	    var right = new _three2.default.Vector3().crossVectors(forward, UP_POSITION).normalize();
	
	    var movement = new _three2.default.Vector3().addScaledVector(forward, direction.y).addScaledVector(right, direction.x);
	    if (movement.y < -cameraPosition.y && playerData.constraintCameraY) movement.y = -cameraPosition.y;
	
	    cameraPosition.add(movement);
	    targetPosition.add(movement);
	
	    cameraWorldMatrix.setPosition(cameraPosition);
	    targetWorldMatrix.setPosition(targetPosition);
	
	    (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
	
	    store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
	    if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
	      store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
	    }
	    return movement;
	  }
	}

/***/ },
/* 343 */
/*!**********************************!*\
  !*** ./src/translators/three.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = threeTranslator;
	
	var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 98);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 102);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _values = __webpack_require__(/*! babel-runtime/core-js/object/values */ 276);
	
	var _values2 = _interopRequireDefault(_values);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _translator = __webpack_require__(/*! ./translator */ 344);
	
	var _bingeom = __webpack_require__(/*! ./bingeom */ 154);
	
	var _materials = __webpack_require__(/*! ./materials */ 345);
	
	var _polyMesh = __webpack_require__(/*! ./polyMesh */ 346);
	
	var _light = __webpack_require__(/*! ./light */ 347);
	
	var _transform = __webpack_require__(/*! ./transform */ 348);
	
	var _camera = __webpack_require__(/*! ./camera */ 268);
	
	var _manipulators = __webpack_require__(/*! ./manipulators */ 349);
	
	var _setMatrixOnNode = __webpack_require__(/*! ./utils/setMatrixOnNode */ 271);
	
	var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);
	
	var _annotation = __webpack_require__(/*! ./annotation */ 351);
	
	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 255);
	
	var _sceneGraph = __webpack_require__(/*! ../modules/sceneGraph */ 142);
	
	var _scene = __webpack_require__(/*! ../modules/scene */ 147);
	
	var _player = __webpack_require__(/*! ../modules/player */ 265);
	
	var _commands = __webpack_require__(/*! ../modules/commands */ 275);
	
	var _selection = __webpack_require__(/*! ../modules/selection */ 282);
	
	var _calculateBoundingBox = __webpack_require__(/*! ./utils/calculateBoundingBox */ 267);
	
	var _calculateBoundingBox2 = _interopRequireDefault(_calculateBoundingBox);
	
	__webpack_require__(/*! ./utils/outlinePass */ 352);
	
	__webpack_require__(/*! ./utils/FXAAShader */ 353);
	
	__webpack_require__(/*! ./utils/parallaxBarrierEffect */ 354);
	
	__webpack_require__(/*! ./utils/vrControls */ 341);
	
	var _polyMesh2 = __webpack_require__(/*! ../polyMesh */ 159);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// extend three with StereoEffect
	
	var BACKGROUND_STYLE_DEFAULT = 0;
	var BACKGROUND_STYLE_COLOR = 1;
	var BACKGROUND_STYLE_IMAGE = 2;
	var BACKGROUND_STYLE_CUBEMAP = 3;
	var BACKGROUND_STYLE_ENVIRONMENT = 4;
	
	function initTranslator(store, context, translator) {
	  var sceneGraph = store.get('sceneGraph');
	
	  var scene = new _three2.default.Scene();
	  var camera = new _three2.default.PerspectiveCamera(75, 4 / 3, 0.1, 1000);
	
	  var rendererAttrs = {
	    antialias: false,
	    precision: 'highp',
	    alpha: true,
	    preserveDrawingBuffer: true
	  };
	  if (context) {
	    rendererAttrs.canvas = { style: {} };
	    rendererAttrs.context = context;
	  }
	  var isIOS = false;
	  var renderer = new _three2.default.WebGLRenderer(rendererAttrs);
	  renderer.setClearColor(0xffffff);
	  renderer.autoResizeTextures = false;
	  renderer.gammaInput = true;
	  renderer.gammaOutput = true;
	  renderer.toneMapping = _three2.default.ReinhardToneMapping;
	  renderer.physicallyCorrectLights = true;
	  if (true) {
	    var pixelRatio = window.devicePixelRatio / Math.round(window.devicePixelRatio);
	    renderer.setPixelRatio(pixelRatio);
	    isIOS = window.navigator ? /iPad|iPhone|iPod/.test(window.navigator.userAgent) && !window.MSStream : false;
	  }
	
	  store.dispatch((0, _player.setThreeScene)(scene, camera, renderer));
	
	  var el = null;
	  var playerEl = null; // This is the parent element that we control (div.claraplayer)
	
	  var nodes = {};
	  var translated = {
	    // [ nodeId ]: { [PlugName]: _v }
	  };
	  var annotations = {};
	  var rect = new _three2.default.Vector2(400, 300);
	  var tools = [];
	  var interactionHandler = null;
	  var cameraId = _sceneGraph.virtualCameraId; // The camera we want to move
	  var fromCameraId = _sceneGraph.virtualCameraId; // The camera we want to use to initialize camera position
	  var translatedCameraId = null; // The camera that we initialized from
	  var pivotId = null;
	  var loaded = null;
	  var reflectiveFloorMaterial = null;
	  var reflectiveFloorMesh = null;
	
	  var vrControls = undefined;
	
	  var externals = {};
	
	  var translatorState = {};
	
	  function getContext() {
	    return renderer.getContext();
	  }
	
	  var selectedNodes = (0, _selection.getSelectedNodes)(store);
	
	  // use msaa on the server
	  var serverRenderingMode = !!context;
	
	  var composer = new _three2.default.EffectComposer(renderer);
	
	  var clearPass = new _three2.default.ClearPass();
	  clearPass.enabled = true;
	  clearPass.renderToScreen = true;
	  composer.addPass(clearPass);
	
	  var texturePass = new _three2.default.TexturePass();
	  texturePass.clear = false;
	  texturePass.enabled = false;
	  texturePass.renderToScreen = true;
	  composer.addPass(texturePass);
	
	  var cubeTexturePass = new _three2.default.CubeTexturePass(scene, camera);
	  cubeTexturePass.clear = false;
	  cubeTexturePass.enabled = false;
	  cubeTexturePass.renderToScreen = true;
	  composer.addPass(cubeTexturePass);
	
	  var msaaRenderPass = new _three2.default.ManualMSAARenderPass(scene, camera);
	  msaaRenderPass.clear = false;
	  msaaRenderPass.renderToScreen = true;
	  msaaRenderPass.sampleLevel = serverRenderingMode ? 3 : 1;
	  msaaRenderPass.unbiased = true;
	  msaaRenderPass.enabled = true;
	  composer.addPass(msaaRenderPass);
	
	  var renderPass = new _three2.default.RenderPass(scene, camera, null, 0xffffff);
	  //renderPass.clear = true;
	  renderPass.renderToScreen = true;
	  //renderPass.enabled = ! msaaRenderPass.enabled;
	  composer.addPass(renderPass);
	
	  var fullWidth =  true ? window.innerWidth : 400;
	  var fullHeight =  true ? window.innerHeight : 300;
	
	  var outlinePass = new _three2.default.OutlinePass(new _three2.default.Vector2(fullWidth, fullHeight), scene, camera);
	  outlinePass.edgeStrength = 10;
	  outlinePass.edgeGlow = 0;
	  outlinePass.edgeThickness = 1;
	  outlinePass.pulsePeriod = 0;
	  outlinePass.visibleEdgeColor = new _three2.default.Color(0, 1, 0);
	  outlinePass.hiddenEdgeColor = new _three2.default.Color(0, 1, 0);
	  outlinePass.renderToScreen = true;
	  composer.addPass(outlinePass);
	
	  var effectFXAA = new _three2.default.ShaderPass(_three2.default.FXAAShader);
	  effectFXAA.uniforms['resolution'].value.set(1 / fullWidth, 1 / fullHeight);
	  effectFXAA.renderToScreen = true;
	
	  composer.addPass(effectFXAA);
	
	  var saoPass = new _three2.default.SAOPass(scene, camera);
	  saoPass.downSamplingRatio = serverRenderingMode ? 1 : 1; // fast enough if not full screen (I think.)
	  saoPass.intensity = 3;
	  saoPass.occlusionSphereWorldRadius = 2;
	  saoPass.renderToScreen = true;
	  saoPass.blurEnabled = true;
	  saoPass.outputOverride = null; //"sao";
	  saoPass.manualCompositing = false;
	  saoPass.blurKernelSize = (saoPass.downSamplingrendererRatio === 1 ? 6 : 6) + (serverRenderingMode ? 2 : 0);
	  saoPass.enabled = true;
	  composer.addPass(saoPass);
	
	  var stereoEffect = new _three2.default.ParallaxBarrierEffect(renderer);
	
	  function resize(width, height) {
	    if (el) {
	      var elRect = el.parentNode.getBoundingClientRect();
	      width = elRect.width;
	      height = elRect.height;
	    }
	
	    if (width < 10 || height < 10) return;
	
	    rect.set(width, height);
	
	    (0, _camera.resizeCamera)(store, cameraId, rect);
	    renderer.setSize(rect.width, rect.height);
	
	    var pixelRatio = renderer.getPixelRatio();
	    composer.setSize(rect.width * pixelRatio, rect.height * pixelRatio);
	    if (interactionHandler) interactionHandler.resize(rect);
	
	    if (height && height !== 0) {
	      camera.aspect = width / height;
	      camera.updateProjectionMatrix();
	    }
	
	    effectFXAA.uniforms['resolution'].value.set(1 / width, 1 / height);
	  }
	
	  /*
	   * Attach the renderer's canvas element to the DOM?.
	   */
	  function attach(element) {
	    el = element;
	    el.insertBefore(renderer.domElement, el.firstChild);
	    renderer.domElement.tabIndex = 1;
	
	    playerEl = el.parentElement;
	    store.dispatch((0, _player.setPlayerElement)(playerEl, renderer.domElement));
	    resize();
	  }
	
	  function orientHandle() {
	    console.log('orientHandle', !!vrControls);
	    if (vrControls) vrControls.update();
	    store.dispatch({ type: 'POKE' });
	  }
	
	  function deviceTrackingTransition(enabled) {
	    vrControls = enabled ? new _three2.default.VRControls(camera) : null;
	    window[enabled ? 'addEventListener' : 'removeEventListener']('deviceorientation', orientHandle);
	  }
	
	  function handleStateChanges() {
	    // TODO: only do this if the player has changed. Requires moving the cameraWorldMatrix
	    // out of the player state.
	    //
	
	    function stateChange(key, handler) {
	      var newState = store.getIn(['player', key]);
	      if (translatorState[key] !== newState) {
	        handler(newState, translatorState[key]);
	        translatorState[key] = newState;
	      }
	    }
	    if (true) stateChange('deviceTracking', deviceTrackingTransition);
	  }
	
	  function highlightSelection(rootNodeId) {
	    var node = rootNodeId && nodes[rootNodeId];
	    outlinePass.selectedObjects = node ? [node] : [];
	  }
	
	  /*
	   * After all nodes have been translated.
	   */
	  var renderDisplaySceneTimeout = null;
	  var lastRenderStartTime = -1;
	  var lastRenderDeltaTime = -1;
	
	  function updateRenderTime() {
	    var currentRenderStartTime = Date.now();
	    if (lastRenderStartTime > 0) {
	      lastRenderDeltaTime = currentRenderStartTime - lastRenderStartTime;
	    } else {
	      lastRenderDeltaTime = -1;
	    }
	    lastRenderStartTime = currentRenderStartTime;
	  }
	
	  function postTranslate() {
	    var renderingMode = (0, _player.getRenderingMode)(store);
	
	    if (renderDisplaySceneTimeout) {
	      clearTimeout(renderDisplaySceneTimeout);
	    }
	
	    updateRenderTime();
	
	    var playerCameraId = (0, _player.getCamera)(store);
	
	    // If we are switching the threejs camera, it should already be initialized
	    // (from VR controls, or previous camera, so just directly translate it)
	    if (cameraId !== playerCameraId) {
	      cameraId = playerCameraId;
	      fromCameraId = cameraId;
	      translatedCameraId = cameraId;
	      translate(cameraId, sceneGraph.evaluatedNodes[cameraId], sceneGraph.nodes[cameraId], true);
	    }
	
	    if (fromCameraId !== translatedCameraId) {
	      // Translate the new camera
	      translate(cameraId, sceneGraph.evaluatedNodes[cameraId], sceneGraph.nodes[cameraId], true);
	    }
	
	    handleStateChanges();
	
	    if (interactionHandler) {
	      updateTools();
	      updateWidgets();
	    }
	
	    selectedNodes = (0, _selection.getSelectedNodes)(store);
	    if ((0, _selection.isHighlighting)(store) && selectedNodes.length) {
	      highlightSelection(selectedNodes[0]);
	    } else {
	      highlightSelection(null);
	    }
	
	    if (reflectiveFloorMesh && reflectiveFloorMesh.data.reflectiveFloor) {
	      reflectiveFloorMaterial.distanceFade = reflectiveFloorMesh.data.reflectiveFloorFade * 0.0001;
	      reflectiveFloorMaterial.roughness = reflectiveFloorMesh.data.reflectiveFloorRoughness;
	      reflectiveFloorMaterial.metalness = reflectiveFloorMesh.data.reflectiveFloorMetallic;
	      reflectiveFloorMaterial.opacity = reflectiveFloorMesh.data.reflectiveFloorOpacity;
	      reflectiveFloorMaterial.fresnelStrength = reflectiveFloorMesh.data.reflectiveFloorFresnel;
	      reflectiveFloorMaterial.reflectivity = 0.5;
	
	      renderer.setClearColor(renderPass.clearColor, renderPass.clearAlpha);
	      reflectiveFloorMaterial.render(renderer, scene, camera);
	
	      //reflectiveFloorMesh.material = new THREE.MeshStandardMaterial( { emissive: 0xff00ff, emissiveMap: reflectiveFloorMaterial.material.uniforms.tReflection.value } );
	    }
	    //renderer.setClearColor( renderPass.clearColor, renderPass.clearAlpha );
	
	    cubeTexturePass.camera = camera;
	
	    if (renderingMode === _player.RENDER_MODES.normal) {
	      //renderer.autoClear = true;
	      renderer.setClearColor(0xffffff);
	      renderPass.enabled = false;
	      effectFXAA.enabled = false;
	      msaaRenderPass.enabled = true;
	      //renderer.setClearAlpha( 0.9 );
	      composer.render();
	    } else if (renderingMode === _player.RENDER_MODES.vr) {
	      renderPass.enabled = true;
	      effectFXAA.enabled = true;
	      msaaRenderPass.enabled = false;
	      if (!externals.vrEffect) {
	        throw new Error('Expect vr mode to initialize vrEffect');
	      }
	      externals.vrEffect.render(scene, camera, null, true);
	    } else if (renderingMode === _player.RENDER_MODES.lenticular) {
	      stereoEffect.render(scene, camera);
	    }
	
	    if (!serverRenderingMode || lastRenderDeltaTime > 0) {
	      renderDisplaySceneTimeout = setTimeout(function () {
	
	        updateRenderTime();
	
	        msaaRenderPass.sampleLevel = 2;
	        composer.render();
	        msaaRenderPass.sampleLevel = 1;
	
	        renderDisplaySceneTimeout = setTimeout(function () {
	
	          updateRenderTime();
	
	          msaaRenderPass.sampleLevel = 3;
	          composer.render();
	          msaaRenderPass.sampleLevel = 1;
	          lastRenderStartTime = -1;
	        }, Math.max(lastRenderDeltaTime, 100) * 4);
	      }, Math.max(lastRenderDeltaTime, 100) * 4);
	    }
	  }
	
	  function updateTools() {
	    var commands = (0, _commands.getCommands)(store);
	    if (tools !== (0, _commands.getTools)(store)) {
	      tools = (0, _commands.getTools)(store);
	      interactionHandler.updateTools(tools.map(function (n) {
	        return commands[n];
	      }).toArray());
	    }
	  }
	
	  function initWidgets(command, name, rootName) {
	    nodes[rootName] = new _three2.default.Object3D();
	    nodes[rootName].name = name;
	    nodes.widgets.add(nodes[rootName]);
	    if (command.options.displayGizmo !== false) command.widget.draw.call(command, nodes[rootName]);
	  }
	
	  function removeWidgets(command, threeObject, name, rootName) {
	    var widget = command.widget;
	    if (widget && widget.remove) {
	      widget.remove.call(command, threeObject);
	    }
	    nodes.widgets.remove(threeObject);
	    delete nodes[rootName];
	  }
	
	  function updateWidgets() {
	    var commands = (0, _commands.getCommands)(store);
	    var activeCommandsWithWidgets = (0, _commands.getActiveCommandsWithWidgets)(store);
	
	    nodes.widgets.children.forEach(function (child) {
	      if (!activeCommandsWithWidgets[child.name]) {
	        removeWidgets(commands[child.name], child, child.name, 'widgetsRoot-' + child.name);
	      }
	    });
	
	    (0, _values2.default)(activeCommandsWithWidgets).forEach(function (command) {
	      var name = command.name;
	      var widget = command.widget;
	
	      var rootName = 'widgetsRoot-' + name;
	      if (!nodes[rootName]) initWidgets(command, name, rootName);
	      if (widget && widget.position) widget.position.call(command, nodes[rootName]);
	    });
	  }
	
	  /*
	   * Scene is loaded.
	   */
	  function onLoad() {
	    loaded = true;
	    var playerData = sceneGraph.evaluatedNodes[(0, _sceneIO.getSceneId)(store)].Player;
	
	    if (!playerData.orbitTarget) {
	      var bbCenter = (0, _calculateBoundingBox2.default)(scene).center();
	      if (isNaN(bbCenter.x) || isNaN(bbCenter.y) || isNaN(bbCenter.z)) bbCenter.set(0, 0, 0);
	      (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualTargetId, new _three2.default.Matrix4().makeTranslation(bbCenter.x, bbCenter.y, bbCenter.z));
	    }
	
	    if (!context) {
	      interactionHandler = (0, _manipulators.initManipulators)(store, this, renderer.domElement);
	      interactionHandler.resize(rect);
	    }
	
	    nodes.widgets = new _three2.default.Object3D();
	    nodes.widgets.name = "Widgets";
	    scene.add(nodes.widgets);
	  }
	
	  function getAnnotations() {
	    return annotations;
	  }
	
	  function addToParent(id, node, obj, skipReplace) {
	    // console.log('Add toParent: ', node && node.get('parent'), obj);
	    var parentId = node && node.parent;
	    var parent = parentId && nodes[parentId] || scene;
	    obj.name = node.name; // eslint-disable-line no-param-reassign
	    obj.nodeId = id;
	
	    if (nodes[id]) {
	      if (skipReplace) return;
	
	      var children = [].concat(nodes[id].children);
	      for (var i = 0; i < children.length; i++) {
	        nodes[id].remove(children[i]);
	        obj.add(children[i]);
	      }
	      parent.remove(nodes[id]);
	      if (nodes[id].geometry) nodes[id].geometry.dispose();
	    }
	
	    nodes[id] = obj;
	    parent.add(nodes[id]);
	  }
	
	  var plugs = {
	    PolyMesh: function PolyMesh(id, data, node, properties) {
	      var visible = properties.visible;
	      var mesh = data.mesh;
	      var previousMesh = data.previousMesh;
	
	      //const collapseMaps = true;
	
	      var indexingMode = renderer.extensions.get('OES_element_index_uint') ? _polyMesh2.ThreeExport.CompactIndices : _polyMesh2.ThreeExport.NoIndices;
	      var interleaved = false;
	      var oldMesh = nodes[id];
	      var prevTriangulation = oldMesh && oldMesh.userData.triangulation;
	      var prevIndexing = oldMesh && oldMesh.userData.renderIndexing;
	      var prevValueMap = oldMesh && oldMesh.userData.valueMap;
	      var bufferInfo = mesh && _polyMesh2.ThreeExport.exportBufferGeometry(mesh, indexingMode, interleaved, null, previousMesh, prevTriangulation, prevIndexing, prevValueMap);
	
	      var geometry = undefined,
	          triangulation = undefined,
	          triangulationChanged = undefined,
	          renderIndexing = undefined,
	          valueMap = undefined;
	      if (bufferInfo) {
	        geometry = bufferInfo.geometry;
	        triangulation = bufferInfo.triangulation;
	        triangulationChanged = bufferInfo.triangulationChanged;
	        renderIndexing = bufferInfo.renderIndexing;
	        valueMap = bufferInfo.valueMap;
	      }
	
	      var obj = undefined;
	
	      if (triangulationChanged || !oldMesh) {
	        obj = geometry && new _three2.default.Mesh(geometry, (0, _materials.primitiveToMaterial)(store));
	      } else {
	        obj = oldMesh;
	        if (geometry) {
	          obj.geometry.dispose();
	          obj.geometry = geometry;
	        }
	        //obj.material.dispose();
	        //obj.material = primitiveToMaterial(store);
	      }
	
	      if (obj) {
	        obj.visible = visible;
	        obj.userData.triangulation = triangulation;
	        obj.userData.renderIndexing = renderIndexing;
	        obj.userData.valueMap = valueMap;
	      }
	
	      addToParent(id, node, obj || new _three2.default.Object3D());
	    },
	
	    Light: function Light(id, data, node) {
	      var obj = nodes[id];
	      if (!obj) {
	        obj = (0, _light.createLight)(data);
	        if (obj) addToParent(id, node, obj);
	      } else {
	        (0, _light.updateLight)(data, obj);
	      }
	    },
	
	    Bone: function Bone(id, data, node) {
	      if (!nodes[id]) addToParent(id, node, new _three2.default.Object3D());
	    },
	
	    Null: function Null(id, data, node) {
	      if (!nodes[id]) addToParent(id, node, new _three2.default.Object3D());
	    },
	
	    PrefetchMaterialNull: function PrefetchMaterialNull(id, data, node, properties) {
	      if (loaded && properties.prefetch && !nodes[id]) {
	        //console.log('Add a node for prefetch of material: ', node.name);
	        addToParent(id, node, new _three2.default.Object3D());
	      }
	    },
	
	    Transform: function Transform(id, data, node) {
	      if (!data || !data.transform) return;
	      if (nodes[id]) (0, _transform.setMatrixOn)(nodes[id], data.transform);
	    },
	
	    Material: function Material(id, data) {
	      if (!nodes[id]) return;
	      nodes[id].material = (0, _materials.primitiveToMaterial)(store, renderer, data, nodes[id].material);
	    },
	
	    Image: function Image(id, data, node, properties) {
	      if (loaded && properties.prefetch) (0, _materials.getTextureImage)(store, data);
	    },
	
	    Environment: function Environment(id, data) {
	      //console.log(data.toJS());
	      var backgroundStyle = data.backgroundStyle;
	      clearPass.enabled = false;
	      cubeTexturePass.enabled = false;
	
	      switch (backgroundStyle) {
	
	        case BACKGROUND_STYLE_COLOR:
	          clearPass.enabled = true;
	          clearPass.clearColor = data.backgroundColor;
	          clearPass.clearAlpha = data.backgroundOpacity;
	          break;
	        case BACKGROUND_STYLE_IMAGE:
	          texturePass.enabled = true;
	          texturePass.map = (0, _materials.assignTexture)(store, renderer, data.background);
	          break;
	        case BACKGROUND_STYLE_CUBEMAP:
	        case BACKGROUND_STYLE_ENVIRONMENT:
	          {
	
	            clearPass.enabled = true;
	            clearPass.clearColor = 0x000000;
	            clearPass.clearAlpha = 0.0;
	
	            cubeTexturePass.enabled = true;
	
	            var cubeMapNode = undefined;
	            var cubeMapBlurring = undefined;
	
	            if (backgroundStyle === BACKGROUND_STYLE_ENVIRONMENT) {
	              cubeMapNode = data.environmentMap;
	              if (cubeMapNode) {
	                cubeMapNode = cubeMapNode.specularCubeMap;
	              }
	              cubeMapBlurring = data.environmentMapBlurring;
	            } else {
	              cubeMapNode = data.cubeMap;
	              cubeMapBlurring = data.cubeMapBlurring;
	            }
	
	            if (cubeMapNode) {
	              cubeTexturePass.envMap = (0, _materials.getCubeMapTexture)(store, renderer, cubeMapNode, true);
	              cubeTexturePass.envMapIntensity = 1.0;
	              cubeTexturePass.opacity = data.backgroundOpacity;
	              cubeTexturePass.roughness = data.cubeMapBlurring;
	            } else {
	              cubeTexturePass.enabled = false;
	            }
	          }
	
	          break;
	
	        default:
	          clearPass.enabled = true;
	          clearPass.clearColor = new _three2.default.Color(1, 1, 1);
	          clearPass.clearAlpha = 0;
	          break;
	      }
	    },
	
	    Player: function Player(id, data, node) {
	      if (data.camera && data.camera !== fromCameraId && sceneGraph.nodes[data.camera]) {
	        var fromNode = sceneGraph.nodes[data.camera];
	        var cameraNode = sceneGraph.nodes[cameraId];
	        var copiedNode = (0, _sceneGraph.initNode)(fromNode);
	        store.dispatch((0, _sceneGraph.replace)(cameraId, (0, _assign2.default)(cameraNode, { plugs: copiedNode.plugs })));
	        fromCameraId = data.camera;
	      }
	      if (data.orbitTarget && data.orbitTarget !== pivotId) {
	        pivotId = data.orbitTarget;
	        // FIXME: remove scale here?
	        (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualTargetId, (0, _scene.getWorldTransform)(store, pivotId));
	      }
	
	      var styleToToneMapping = {
	        Linear: _three2.default.LinearToneMapping,
	        Reinhard: _three2.default.ReinhardToneMapping,
	        Cineon: _three2.default.CineonToneMapping,
	        Filmic: _three2.default.Uncharted2ToneMapping
	      };
	
	      renderer.toneMapping = styleToToneMapping[data.toneMapStyle];
	      renderer.toneMappingExposure = data.toneMapExposureGain;
	      renderer.toneMappingWhitePoint = data.toneMapWhitePoint;
	      renderer.gammaInput = true;
	      renderer.gammaOutput = true;
	      renderer.autoClear = false;
	
	      saoPass.enabled = data.saoPass;
	      saoPass.intensity = data.saoIntensity;
	      saoPass.occlusionSphereWorldRadius = data.saoScale;
	
	      if (data.reflectiveFloor && (!data.reflectiveFloorExcludeServer || (true))) {
	
	        if (!reflectiveFloorMaterial) {
	          var mirrorGeo = new _three2.default.PlaneBufferGeometry(1, 1);
	          reflectiveFloorMaterial = new _three2.default.GlossyMirror({ clipBias: 0.003, textureWidth: 1024, textureHeight: 1024, color: 0x777777, localMirrorNormal: new _three2.default.Vector3(0, 1, 0) });
	          reflectiveFloorMesh = new _three2.default.Mesh(mirrorGeo, reflectiveFloorMaterial.material);
	        }
	
	        reflectiveFloorMaterial.specularColor = new _three2.default.Color(0xffffff);
	        reflectiveFloorMaterial.specularColor = new _three2.default.Color(0xffffff);
	
	        reflectiveFloorMesh.scale.x = data.reflectiveFloorWidth;
	        reflectiveFloorMesh.scale.y = data.reflectiveFloorWidth;
	        reflectiveFloorMesh.rotation.x = -Math.PI * 0.5;
	        reflectiveFloorMesh.position.y = data.reflectiveFloorHeight;
	
	        reflectiveFloorMesh.data = data;
	
	        if (!reflectiveFloorMesh.parent) {
	          scene.add(reflectiveFloorMesh);
	        }
	      } else {
	        if (reflectiveFloorMesh && reflectiveFloorMesh.parent) {
	          scene.remove(reflectiveFloorMesh);
	        }
	      }
	    },
	
	    CameraTransform: function CameraTransform(id, data, node, Properties, nodeData) {
	      if (id === cameraId && loaded) {
	        if (translatedCameraId !== fromCameraId || !nodeData.Camera.upPosition) {
	          (0, _camera.initCamera)(store, true, fromCameraId, id, rect);
	
	          translatedCameraId = fromCameraId;
	        }
	
	        var cameraData = nodeData.Camera;
	        var matrix = data.target && cameraData.upPosition ? (0, _camera.updateLookatTarget)(store, id, data, cameraData) : data.transform;
	        (0, _transform.setMatrixOn)(camera, matrix);
	      }
	    },
	
	    Camera: function Camera(id, data, node) {
	      if (id === cameraId && loaded) {
	        camera.fov = data.fieldOfView;
	        camera.aspect = data.aspectRatio;
	        camera.near = data.nearClip;
	        camera.far = data.farClip;
	        camera.updateProjectionMatrix();
	      }
	      if (data.newRadiusConstraint) (0, _camera.initCameraRadiusConstraint)(store, id, data, data.newRadiusConstraint);
	    },
	
	    Annotation: function Annotation(id, data, node, properties) {
	      var calcDirection = data.directionMode === 'awayFromOrigin';
	      annotations[id] = {
	        id: id,
	        annotation: data,
	        position: (0, _annotation.getScreenPositionNormalAlpha)(id, calcDirection, data.directionTarget),
	        visible: properties.visible
	      };
	    }
	  };
	
	  plugs.BinMesh = plugs.PolyMesh;
	
	  var order = {
	    Scene: ['Player', 'Environment'],
	    BinMesh: ['BinMesh', 'Transform', 'Material'],
	    PolyMesh: ['PolyMesh', 'Transform', 'Material'],
	    Light: ['Light', 'Transform'],
	    Camera: [['Transform', 'CameraTransform'], 'Camera'],
	    Null: ['Null', 'Transform'],
	    Model: ['Null', 'Transform'],
	    Objects: ['Null'],
	    MaterialLibrary: ['Null'],
	    Material: ['PrefetchMaterialNull', 'Material'], // for prefetch of material
	    Image: ['Image'], // for prefetch of image
	    Renderers: [],
	    Passes: [],
	    Pass: [],
	    Renderer: [],
	    Bone: ['Bone', 'Transform'],
	    Annotation: ['Annotation']
	  };
	
	  var forceDeps = {
	    // When the mesh has changed, we need to run material translator again
	    PolyMesh: { Material: true, Transform: true },
	    BinMesh: { Material: true, Transform: true }
	  };
	
	  /*
	   * Translate a node, either create or update
	   */
	  function translate(id, data, node, force) {
	    var type = node.type;
	    var processPlugs = order[type] || [];
	    if (!translated[id]) translated[id] = {};
	    var translateAnyway = {};
	    var plug = undefined;
	    var plugFunction = undefined;
	
	    //console.log('translate: ', type, node.name, translated[id]);
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = (0, _getIterator3.default)(processPlugs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var nextPlug = _step.value;
	
	        var _ref = Array.isArray(nextPlug) ? nextPlug : [nextPlug, nextPlug];
	
	        var _ref2 = (0, _slicedToArray3.default)(_ref, 2);
	
	        plug = _ref2[0];
	        plugFunction = _ref2[1];
	
	        var plugData = data[plug];
	        if (force || !plugData || plugData._v !== translated[id][plug] || translateAnyway[plug]) {
	          if (forceDeps[plug]) translateAnyway = forceDeps[plug];
	          //console.log(' - ', plug);
	          if (plugs[plugFunction]) {
	            plugs[plugFunction](id, plugData, node, data.Properties, data);
	            translated[id][plug] = plugData && plugData._v;
	          } else {
	            console.warn('Unknown plug translator for: ', plug, node.name);
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }
	
	  /*
	   * Delete a node
	   */
	  function deleteNode(id) {
	    var obj = nodes[id];
	    if (obj) {
	      delete nodes[id];
	      obj.parent.remove(obj);
	    }
	  }
	
	  function getNodeBoundingBox(id) {
	    return (0, _calculateBoundingBox2.default)(nodes[id]);
	  }
	
	  function getCameraMouseRay(ndc) {
	    var ray = new _three2.default.Raycaster();
	    ray.setFromCamera(ndc, camera);
	    return ray;
	  }
	
	  function raycastSelect(mousePosition) {
	    var rootNode = arguments.length <= 1 || arguments[1] === undefined ? "Objects" : arguments[1];
	
	    var hits = [];
	    var selectedObjects = [];
	    var ray = getCameraMouseRay(mousePosition);
	    var objectsRoot = scene;
	    scene.children.forEach(function (child) {
	      if (child.type === "Object3D" && child.name === rootNode) objectsRoot = child;
	    });
	
	    objectsRoot.traverse(function (node) {
	      if (!node.visible) return;
	      if (!node.geometry) return;
	
	      if (node.geometry.boundingBox === null) {
	        node.geometry.computeBoundingBox();
	      }
	
	      var geometry = node.geometry;
	
	      if (geometry.boundingBox.isEmpty() === false) {
	        node.matrix.compose(node.position, node.quaternion, node.scale);
	        node.updateMatrixWorld(true);
	        var inter = ray.intersectObject(node);
	        if (inter.length > 0) {
	          hits.push({ id: node.nodeId, node: node, data: inter });
	        }
	      }
	    });
	    hits.sort(function (a, b) {
	      return a.data[0].distance - b.data[0].distance;
	    });
	
	    return hits;
	  }
	  function getObjectRoot(nodeId) {
	    var id = null;
	
	    if (nodeId !== null) {
	      var rootNode = nodes[nodeId];
	      rootNode.traverse(function (node) {
	        if (node.name === "Fbx_Root") {
	          //Need to find the first child node of Import_Null
	          id = node.nodeId;
	        }
	      });
	    }
	    return id;
	  }
	
	  function toScreenPosition(rootNodeId) {
	    if (rootNodeId) {
	      var obj = nodes[rootNodeId];
	      if (obj) {
	        var vector = new _three2.default.Vector3();
	
	        var widthHalf = 0.5 * renderer.context.canvas.width;
	        var heightHalf = 0.5 * renderer.context.canvas.height;
	
	        obj.updateMatrixWorld();
	        var bbox = (0, _calculateBoundingBox2.default)(obj);
	        var height = bbox.max.y - bbox.min.y;
	        obj.updateMatrixWorld();
	        vector.setFromMatrixPosition(obj.matrixWorld);
	        vector.y += height;
	        vector.project(camera);
	
	        vector.x = vector.x * widthHalf + widthHalf;
	        vector.y = -(vector.y * heightHalf) + heightHalf;
	
	        return {
	          x: vector.x,
	          y: vector.y
	        };
	      }
	    }
	  };
	
	  return {
	    attach: attach,
	    resize: resize,
	    translate: translate,
	    deleteNode: deleteNode,
	    raycastSelect: raycastSelect,
	    getCameraMouseRay: getCameraMouseRay,
	    getNodeBoundingBox: getNodeBoundingBox,
	    toScreenPosition: toScreenPosition,
	    getObjectRoot: getObjectRoot,
	    postTranslate: postTranslate,
	    onLoad: onLoad,
	    getAnnotations: getAnnotations,
	    getContext: getContext,
	    scene: scene,
	    camera: camera,
	    renderer: renderer,
	    externals: externals
	  };
	}
	
	function threeTranslator(store, context) {
	  return (0, _translator.createTranslator)(store, initTranslator, context);
	}

/***/ },
/* 344 */
/*!***************************************!*\
  !*** ./src/translators/translator.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createTranslator = createTranslator;
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 102);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 255);
	
	var _sceneGraph = __webpack_require__(/*! ../modules/sceneGraph */ 142);
	
	var _animation = __webpack_require__(/*! ../modules/animation */ 132);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultNodeFilter = function defaultNodeFilter(n) {
	  return true;
	};
	
	var defaultFns = {
	  onLoad: function onLoad() {},
	  postTranslate: function postTranslate() {},
	  handleStateChanges: function handleStateChanges() {}
	};
	
	function createTranslator(store, initTranslator, context) {
	  var api = {};
	  var translator = initTranslator(store, context, api);
	  var nodeFilter = defaultNodeFilter;
	
	  var rendered = false;
	  var preloaded = false;
	  var loaded = false;
	  var view = null;
	  var player = store.get('player');
	
	  var translatedVersion = null;
	  var translatedNodes = {};
	  var renderingMode = store.getIn(['player', 'renderingMode']);
	  var vrDisplay = undefined;
	
	  function translateNodes() {
	    var sceneId = (0, _sceneIO.getSceneId)(store);
	    if (!sceneId) return 0;
	
	    var sceneGraph = (0, _sceneGraph.getEvalSceneGraph)(store);
	
	    if (translatedVersion === sceneGraph._ev) return 0;
	
	    var newTranslatedNodes = {};
	
	    //console.log('translate from', translatedVersion, 'to', sceneGraph._ev); //, translatedNodes);
	
	    var numUpdated = 0;
	
	    function translateNode(id) {
	      var node = sceneGraph.nodes[id];
	      if (!node) return;
	      var result = sceneGraph.evaluatedNodes[id];
	      var translated = translatedNodes[id];
	
	      if (!translated || translated._v !== result._v || translated._ev !== result._ev) {
	        //console.log('translate: ', translatedNodes[id], {_v: result._v, _ev: result._ev}, node.name);
	        translator.translate(id, result, node);
	        numUpdated += 1;
	      }
	      newTranslatedNodes[id] = { _v: result._v, _ev: result._ev };
	
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = (0, _getIterator3.default)(node.children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var childId = _step.value;
	
	          translateNode(childId);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	
	    translateNode(sceneId);
	    if (sceneGraph.nodes[_sceneGraph.virtualCameraId]) translateNode(_sceneGraph.virtualCameraId);
	    if (sceneGraph.nodes[_sceneGraph.vrCameraId]) translateNode(_sceneGraph.vrCameraId);
	
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(translatedNodes)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var id = _step2.value;
	
	        if (!newTranslatedNodes[id]) {
	          translator.deleteNode(id);
	        }
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	
	    translatedNodes = newTranslatedNodes;
	    translatedVersion = sceneGraph._ev;
	
	    return numUpdated;
	  }
	
	  function doUpdate() {}
	
	  return (0, _assign2.default)({}, defaultFns, translator, {
	    update: function update() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      // console.log('translator do update');
	      var numUpdated = translateNodes();
	      //console.log('numUpdated: ', numUpdated);
	      var renderedAndLoaded = false;
	
	      if (!rendered && numUpdated) {
	        rendered = true;
	        store.dispatch((0, _sceneIO.markRenderingScene)());
	      }
	
	      if (!loaded && preloaded && (0, _sceneIO.areAssetsLoaded)(store)) {
	        loaded = true;
	        translator.onLoad();
	        store.dispatch((0, _sceneIO.markLoaded)());
	        renderedAndLoaded = true;
	      }
	
	      if (!preloaded && (0, _sceneIO.areAssetsPreloaded)(store)) {
	        preloaded = true;
	        store.dispatch((0, _sceneIO.markPreloaded)());
	      }
	
	      if (loaded) translator.postTranslate();
	
	      if (renderedAndLoaded) {
	        store.dispatch((0, _sceneIO.markRenderedScene)());
	      }
	
	      store.dispatch((0, _animation.incrementTime)());
	    }
	  });
	};

/***/ },
/* 345 */
/*!**************************************!*\
  !*** ./src/translators/materials.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getCubeMapTexture = getCubeMapTexture;
	exports.getTextureImage = getTextureImage;
	exports.assignTexture = assignTexture;
	exports.primitiveToMaterial = primitiveToMaterial;
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 102);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _asset = __webpack_require__(/*! ./asset */ 203);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var textures = {};
	function checkTextureCache(id, image) {
	  var cachedImage = textures[id] && textures[id].image;
	
	  if (cachedImage && cachedImage._v === image._v) {
	    return textures[id].value;
	  }
	}
	
	function cacheTexture(id, image, value) {
	  textures[id] = { image: image, value: value };
	  return value;
	}
	
	function getCubeMapTexture(store, renderer, image, textureCubeOnly) {
	  var maps = image.maps;
	  var nodeId = image.nodeId;
	
	  var texture = checkTextureCache(nodeId, image);
	  if (texture) return texture;
	
	  var images = (0, _ramda.map)((0, _ramda.curry)(_asset.getImageFromNode)(store), maps);
	  if (!(0, _ramda.all)(function (img) {
	    return !!img;
	  }, images)) return null;
	
	  var textureCube = new _three2.default.CubeTexture();
	  textureCube.images = images;
	
	  //  texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
	  //  texture.anisotropy = 16;
	  textureCube.flipY = false;
	  textureCube.needsUpdate = true;
	  if (maps[0].preferHDR) {
	
	    textureCube.encoding = maps[0].hdrEncoding;
	    textureCube.generateMipMaps = false;
	  }
	
	  if (textureCubeOnly) return cacheTexture(nodeId, image, textureCube);
	
	  //console.warn( "skipping PMREM generation because one needs to get the WebGLRenderer here." );
	  //return textureCube;
	  var pmremGenerator = new _three2.default.PMREMGenerator(textureCube);
	  pmremGenerator.update(renderer);
	
	  pmremGenerator.cubeLods[0].texture.magFilter = _three2.default.LinearFilter;
	  pmremGenerator.cubeLods[0].texture.minFilter = _three2.default.LinearFilter;
	
	  var pmremCubeUVPacker = new _three2.default.PMREMCubeUVPacker(pmremGenerator.cubeLods);
	  pmremCubeUVPacker.update(renderer);
	
	  pmremCubeUVPacker.CubeUVRenderTarget.texture.magFilter = _three2.default.LinearFilter;
	  pmremCubeUVPacker.CubeUVRenderTarget.texture.minFilter = _three2.default.LinearFilter;
	  pmremCubeUVPacker.CubeUVRenderTarget.texture.needsUpdate = true;
	
	  return cacheTexture(nodeId, image, pmremCubeUVPacker.CubeUVRenderTarget.texture);
	}
	
	function getTextureImage(store, image) {
	  if (!image) return null;
	  var nodeId = image.nodeId;
	
	  if (!checkTextureCache(nodeId, image)) {
	    if (image.maps) {
	      (0, _ramda.map)((0, _ramda.curry)(_asset.getImageFromNode)(store), image.maps);
	    } else {
	      (0, _asset.fetchTextureImage)(store, image);
	    }
	  }
	}
	
	/*
	 * Modifies the map being passed in.
	 */
	function assignTexture(store, renderer, image, optionalThreemap, slot, node) {
	  if (!image) {
	    if (optionalThreemap) optionalThreemap.texture = null;
	    return null;
	  }
	
	  if (image.maps) {
	    return getCubeMapTexture(store, renderer, image, node);
	  }
	
	  var uvOptions = (0, _assign2.default)({}, image);
	  var nodeId = image.nodeId;
	  var texture = checkTextureCache(nodeId, image);
	
	  if (!texture) {
	    texture = new _three2.default.Texture();
	    texture.meta = { nodeId: nodeId };
	    if (image.canvasOperations) {
	      (function () {
	        texture.meta.source = "canvas operator";
	        var ops = image.canvasOperations;
	
	        var canvas = document.createElement('canvas');
	        canvas.width = image.width;
	        canvas.height = image.height;
	        var context = canvas.getContext('2d');
	
	        var ok = ops.reduce(function (ok, op) {
	          context.save();
	          var ret = ok && op(context, store);
	          context.restore();
	          return ret;
	        }, true);
	
	        if (ok) texture.image = canvas;
	      })();
	    } else {
	      texture.meta.source = "image fetch";
	      texture.image = (0, _asset.fetchTextureImage)(store, image);
	    }
	
	    if (!texture.image) {
	      if (optionalThreemap) optionalThreemap.texture = null;
	      return null;
	    }
	    texture.transparent = true;
	
	    var textureWraps = {
	      0: _three2.default.ClampToEdgeWrapping,
	      1: _three2.default.RepeatWrapping,
	      2: _three2.default.MirroredRepeatWrapping
	    };
	
	    texture.wrapS = textureWraps[uvOptions.wrapU];
	    texture.wrapT = textureWraps[uvOptions.wrapV];
	
	    texture.generateMipMaps = uvOptions.generateMipMaps;
	    texture.anisotropy = texture.generateMipMaps ? 16 : 1;
	    texture.magFilter = uvOptions.magFilter;
	    texture.minFilter = uvOptions.minFilter;
	    texture.encoding = _three2.default.sRGBEncoding;
	
	    if (_three2.default.Math.nearestPowerOfTwo(texture.image.width) !== texture.image.width || _three2.default.Math.nearestPowerOfTwo(texture.image.height) !== texture.image.height) {
	      texture.wrapS = _three2.default.ClampToEdgeWrapping;
	      texture.wrapT = _three2.default.ClampToEdgeWrapping;
	      texture.generateMipMaps = false;
	      texture.anisotropy = 1;
	      texture.anisotropy = 1;
	      texture.magFilter = _three2.default.LinearFilter;
	      texture.minFilter = _three2.default.LinearFilter;
	    }
	
	    texture.needsUpdate = true;
	
	    cacheTexture(nodeId, image, texture);
	  };
	
	  if (!optionalThreemap) {
	    return texture;
	  }
	  optionalThreemap.texture = texture;
	
	  optionalThreemap.uvTransform = true;
	  optionalThreemap.uvOffset = new _three2.default.Vector2(uvOptions.uOffset, uvOptions.vOffset);
	  optionalThreemap.uvRepeat = new _three2.default.Vector2(uvOptions.uTile, uvOptions.vTile);
	
	  optionalThreemap.texelTransform = true;
	  optionalThreemap.texelInvert = uvOptions.invert;
	  optionalThreemap.texelScale = uvOptions.gain;
	  optionalThreemap.texelOffset = uvOptions.brightness;
	  //texture.gainPivot = uvOptions.gainPivot;
	  //texture.gain = uvOptions.gain;
	  //texture.brightness = uvOptions.brightness;
	
	  //console.log('texture with image', texture);
	  //textures[id] = texture;
	  return optionalThreemap;
	};
	
	var initialStandardDefaults = {
	  "side": 2,
	  "emissive": { "r": 0, "g": 0, "b": 0 },
	  "ambient": { "r": 0, "g": 0, "b": 0 },
	  "vertexColors": 0,
	  "opacity": 1,
	  "transparent": false,
	  "specular": { "r": 1, "g": 1, "b": 1 },
	  "normalScale": { "x": 1, "y": 1 },
	  "envMap": null,
	  "combine": 0,
	  "color": { "r": 0.1803921568627451, "g": 0.4, "b": 0.8274509803921568 },
	  "metal": false,
	  "gloss": false,
	  "reflectivity": 1,
	  "refractionRatio": 0.98,
	  "shininess": 50
	};
	
	function primitiveToMaterial(store, renderer, data, previousMaterial) {
	  var mat = {};
	
	  var material = previousMaterial && previousMaterial instanceof _three2.default.MeshPhysicalMaterial ? previousMaterial : new _three2.default.MeshPhysicalMaterial({});
	
	  if (!data) return material;
	
	  // TODO: vertexColors, blend/combine?
	  // FIXME: envMapScale??
	
	  if (data.defaultColor) {
	    material.color = data.defaultColor;
	    return material;
	  }
	
	  if (!data.baseColor) {
	    //console.log('Expected physical material, received: ', data.toJS());
	    if (data.diffuseColor) material.color = data.diffuseColor;
	    return material;
	  }
	
	  //side?
	  //
	  //name mapping
	  //three.js: clara.io
	  var propertyMap = {
	    color: 'baseColor',
	    //ambient: 'ambientColor2',
	    bumpScale: 'bumpFactor',
	    emissive: 'emissiveColor',
	    falloff: 'baseFalloff',
	    falloffColor: 'baseFalloffColor',
	    metalness: 'metallic',
	    roughness: 'roughness',
	    clearCoat: 'clearCoat',
	    clearCoatRoughness: 'clearCoatRoughness',
	    opacity: 'opacityFactor', // opacityMap and opacityColor are not supported in Three.js
	    falloffOpacity: 'opacityFalloffFactor',
	    //specular: 'specularColor',
	    //translucency: 'translucencyColor',
	    transparent: 'baseMapTransparent'
	  };
	
	  var keys = ['depthTest', 'depthWrite' //,'roughness',
	  ];
	
	  // 'anisotropyMap','anisotropyRotationMap','--diffuseEnvMap','falloffMap', '+-metallicMap','+-opacityMap','reflectivityMap','specularMap','translucencyMap',
	  // '--ambient','falloff','falloffColor','specular','translucency'
	  //  'anisotropy','anisotropyRotation', 'clearCoat','clearCoatRoughness','+-metallic', 'translucencyNormalAlpha','translucencyNormalPower', 'translucencyViewAlpha','translucencyViewPower'
	
	  //name mapping
	  //three.js: clara.io
	  var imageMaps = {
	    map: 'baseMap',
	    bumpMap: 'bumpMap',
	    emissiveMap: 'emissiveMap',
	    lightMap: 'lightMap',
	    metalnessMap: 'metallicMap',
	    normalMap: 'normalMap',
	    alphaMap: 'opacityMap',
	    roughnessMap: 'roughnessMap',
	    falloffMap: 'baseFalloffMap',
	    falloffAlphaMap: 'opacityFalloffMap'
	  };
	
	  function updateTexture(image, slot) {
	    var map = assignTexture(store, renderer, image, material[slot] || new _three2.default.Map());
	    if (map && !material[slot]) material[slot] = map;
	  };
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(imageMaps)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var image = _step.value;
	
	      updateTexture(data[imageMaps[image]], image + 'Slot');
	    }
	
	    //must be after updateTexture
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;
	
	  try {
	    for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(propertyMap)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var to = _step2.value;
	
	      material[to] = data[propertyMap[to]];
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = (0, _getIterator3.default)(keys), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var key = _step3.value;
	
	      material[key] = data[key];
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	
	  if (data.emissiveScale) {
	    material.emissive = material.emissive.clone();
	    material.emissive.multiplyScalar(data.emissiveScale);
	  }
	
	  material.transparent = material.opacity < 1.0 || !!data.opacityMap || data.baseMapTransparent || data.opacityFalloffFactor < 1.0 || !!data.opacityFalloffMap;
	
	  var specular = data.specularColor;
	  material.reflectivity = (specular.r + specular.g + specular.b) * 0.33333;
	  material.clearCoat *= 0.25;
	  var normalFactor = data.normalFactor;
	  material.normalScale = new _three2.default.Vector2(normalFactor, normalFactor);
	
	  material.blending = _three2.default.NormalBlending;
	  material.premultipliedAlpha = true;
	  material.side = _three2.default.DoubleSide;
	
	  var envMap = data.environment && data.environment.environmentMap;
	  if (envMap) updateTexture(envMap.specularCubeMap, 'envMap');
	
	  //updateTexture(data.getIn(['envMap', 'specularCubeMap']), 'envMap');
	  material.needsUpdate = true;
	
	  //mat.envMapIntensity = 10;
	  //mat.diffuseEnvMap = getTexture(store,  data.getIn(['envMap', 'irradianceCubeMap']));
	  //console.log( 'mat', mat );
	  //const standardMaterial =  new THREE.MeshStandardMaterial(mat);
	  ////console.log( 'standardMaterial', standardMaterial );
	  //return standardMaterial;
	  return material;
	}
	
	//function multiIDMaterial(store, renderer, data, previousMaterial) {
	//  const materials = reduce((list, i) => {
	//    const mat = data.material${i};
	//    if (mat) list.push(primitiveToMaterial(store, renderer, mat));
	//    return list;
	//  }, [], [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]);
	
	//  return new THREE.MultiMaterial(materials);
	//};

/***/ },
/* 346 */
/*!*************************************!*\
  !*** ./src/translators/polyMesh.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.polyMeshToBufferGeometry = polyMeshToBufferGeometry;
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function flattenBuffer(klass, elementBuffer, numElementsPerValue, indicesBuffer) {
	  var flattenedBuffer = new klass(indicesBuffer.length * numElementsPerValue);
	
	  var sourceIndex, destIndex;
	  for (var v = 0; v < indicesBuffer.length; v++) {
	    sourceIndex = indicesBuffer[v] * numElementsPerValue;
	    destIndex = v * numElementsPerValue;
	    for (var e = 0; e < numElementsPerValue; e++) {
	      flattenedBuffer[destIndex + e] = elementBuffer[sourceIndex + e];
	    }
	  }
	
	  return new _three2.default.BufferAttribute(flattenedBuffer, numElementsPerValue);
	}
	
	function polyMeshToBufferGeometry(_ref) {
	  var faces = _ref.faces;
	  var positions = _ref.positions;
	  var normalMap = _ref.normalMap;
	  var uvs = _ref.uvs;
	
	  var geom = new _three2.default.BufferGeometry();
	
	  geom.addAttribute('position', flattenBuffer(Float32Array, positions, 3, faces));
	
	  if (normalMap) {
	    geom.addAttribute('normal', flattenBuffer(Float32Array, normalMap.values, 3, normalMap.faces)); //normalMap.faces.length));
	  }
	
	  if (uvs) {
	    var uvNames = (0, _keys2.default)(uvs);
	    uvNames.sort();
	
	    // uv
	    if (uvNames.length >= 1) {
	      var uvMap = uvs[uvNames[0]];
	      geom.addAttribute('uv', flattenBuffer(Float32Array, uvMap.values, 2, uvMap.faces)); // uvMap.faces.length));
	    }
	
	    // uv2
	    if (uvNames.length >= 2) {
	      var uvMap = uvs[uvNames[1]];
	      geom.addAttribute('uv2', flattenBuffer(Float32Array, uvMap.values, 2, uvMap.faces)); //uvMap.faces.length));
	    }
	  }
	
	  return geom;
	}

/***/ },
/* 347 */
/*!**********************************!*\
  !*** ./src/translators/light.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createLight = createLight;
	exports.updateLight = updateLight;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialLightDefaults = {
	  castShadow: true,
	  color: { r: 1, g: 1, b: 1 },
	  intensity: 0.85,
	  lightType: 'DirectionalLight',
	  radius: 0,
	  shadowBias: 0,
	  shadowCameraSize: 1.7321,
	  shadowDarkness: 0.1,
	  shadowFarClip: 40,
	  shadowFrustumColor: { r: 1, g: 1, b: 1 },
	  shadowNearClip: 10,
	  shadowSize: 1024,
	  showShadowCamera: false
	};
	
	function createLight(data, light) {
	  var type = data.lightType;
	  // Skip AreaLight without crashing for now
	  if (type === 'AreaLight') return;
	  if (!_three2.default[type]) throw new Error('Unknown light type: ' + type);
	  if (type === 'HemisphereLight') {
	    return new _three2.default[type](data.color.getHex(), data.gndColor.getHex(), data.intensity);
	  }
	  return new _three2.default[type](data.color.getHex(), data.intensity);
	}
	
	function updateLight(data, light) {
	  light.intensity = data.intensity;
	}

/***/ },
/* 348 */
/*!**************************************!*\
  !*** ./src/translators/transform.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setMatrixOn = setMatrixOn;
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var rotationFactor = 3.14 / 180;
	
	// Set transalation, rotation, scale on Object3D
	function setTRS(object3d, t, r, s) {
	  object3d.position.set(t.x, t.y, t.z);
	  object3d.rotation.set(r.x, r.y, r.z, 'ZYX');
	  object3d.scale.set(s.x, s.y, s.z);
	};
	
	function setTRSDegrees(object3d, t, r, s) {
	  object3d.position.set(t.x, t.y, t.z);
	  object3d.rotation.set(r.x * rotationFactor, r.y * rotationFactor, r.z * rotationFactor, 'ZYX');
	  object3d.scale.set(s.x, s.y, s.z);
	};
	
	/* Apply matrix4 to threejs node.
	 */
	function setMatrixOn(object3d, matrix4) {
	  var translation = new _three2.default.Vector3();
	  var rotQuat = new _three2.default.Quaternion();
	  var scale = new _three2.default.Vector3();
	  matrix4.decompose(translation, rotQuat, scale);
	  var rotation = new _three2.default.Vector3().copy(new _three2.default.Euler().setFromQuaternion(rotQuat, 'ZYX'));
	  setTRS(object3d, translation, rotation, scale);
	}

/***/ },
/* 349 */
/*!*****************************************!*\
  !*** ./src/translators/manipulators.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.initManipulators = initManipulators;
	
	var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 133);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 113);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _flyd = __webpack_require__(/*! flyd */ 350);
	
	var _flyd2 = _interopRequireDefault(_flyd);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function mapStream(el, eventName, fn) {
	  var stream = _flyd2.default.stream();
	  el.addEventListener(eventName, stream);
	  return fn ? _flyd2.default.map(fn, stream) : stream;
	};
	
	function transduceStream(el, eventName, fn) {
	  var stream = _flyd2.default.stream();
	  el.addEventListener(eventName, stream);
	  return _flyd2.default.transduce(fn, stream);
	};
	
	function isSingleTouch(e) {
	  return e.touches && e.touches.length === 1;
	};
	function isDoubleTouch(e) {
	  return e.touches && e.touches.length === 2;
	};
	
	function toMouseEvent(e) {
	  if (!e.touches || !e.touches.length) return e;
	  e.preventDefault();
	  return {
	    which: 1,
	    clientX: e.touches[0].clientX,
	    clientY: e.touches[0].clientY,
	    originalEvent: e
	  };
	};
	
	function addMomentum(toStream, endStream) {
	  var momentumStream = _flyd2.default.stream()(0);
	
	  var result = _flyd2.default.combine(function (to, momentum) {
	    return to.end() ? momentum() : to();
	  }, [toStream, momentumStream]);
	
	  var decay = 1;
	
	  _flyd2.default.on(function () {
	    var timer = every(1000 / 60);
	    var momentumStart = new Date();
	    var momentumDecay = 0.2;
	    if (!toStream()) {
	      return momentumStream.end(true);
	    }
	
	    var _toStream = toStream();
	
	    var deltaX = _toStream.deltaX;
	    var deltaY = _toStream.deltaY;
	
	    _flyd2.default.map(function (i) {
	      if (decay <= 0.005) {
	        momentumStream.end(true);
	        timer.end(true);
	      } else {
	        decay = Math.exp(-(1 - momentumDecay) * 10 * (Date.now() - momentumStart) / 1000);
	        //console.log('decay: ', decay, deltaX, deltaY);
	        momentumStream({ deltaX: deltaX * decay, deltaY: deltaY * decay });
	      }
	    }, timer);
	  }, toStream.end);
	
	  return result;
	};
	
	function initManipulators(store, translator, el) {
	  var playerEl = el.parentNode.parentNode;
	  var offset = { x: 0, y: 0 };
	  var rect = { width: 0, height: 0 };
	  var commands = [];
	  var hasEvents = {};
	
	  var dragging = false;
	  var lastMousedown = false;
	
	  function resize(newRect) {
	    var playerRect = playerEl.getBoundingClientRect();
	    offset = {
	      x: playerRect.left,
	      y: playerRect.top
	    };
	    rect = newRect;
	  }
	
	  function touchLastMove(ev) {
	    if (dragging) dragging.lastMove = new Date();
	    return ev;
	  }
	
	  function callTool(which) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	    return function (ev) {
	      if (!hasEvents[which]) return;
	
	      var command, tool, result;
	
	      for (var i = commands.length - 1; i >= 0; i--) {
	        command = commands[i];
	        tool = command.tool;
	        if (!command.enabled || !tool[which]) continue;
	
	        result = tool[which].call(command, ev);
	
	        if (options.findFirst) {
	          if (result !== false) break;
	        } else if (!options.doAll) {
	          if (result === false) break;
	        }
	      }
	      return result;
	    };
	  };
	
	  function toCoordsBubble(ev) {
	    return {
	      rect: rect,
	      clientX: ev.clientX - offset.x,
	      clientY: ev.clientY - offset.y,
	      deltaX: ev.movementX,
	      deltaY: ev.movementY,
	      originalEvent: ev,
	      which: ev.which,
	      altKey: ev.altKey,
	      ctrlKey: ev.ctrlKey,
	      metaKey: ev.metaKey,
	      shiftKey: ev.shiftKey
	    };
	  };
	
	  function toCoords(ev) {
	    ev.preventDefault();
	    return {
	      rect: rect,
	      clientX: ev.clientX - offset.x,
	      clientY: ev.clientY - offset.y,
	      deltaX: ev.movementX,
	      deltaY: ev.movementY,
	      originalEvent: ev,
	      which: ev.which,
	      altKey: ev.altKey,
	      ctrlKey: ev.ctrlKey,
	      metaKey: ev.metaKey,
	      shiftKey: ev.shiftKey
	    };
	  };
	
	  function toMouseEvent(e) {
	    if (!e.touches || !e.touches.length) return e;
	    e.preventDefault();
	    var elRect = e.srcElement.getBoundingClientRect();
	    return {
	      which: 1,
	      rect: rect,
	      clientX: e.touches[0].clientX - elRect.left,
	      clientY: e.touches[0].clientY - elRect.top,
	      originalEvent: e
	    };
	  };
	
	  _flyd2.default.on(callTool('dragenter'), mapStream(el, 'dragenter'));
	  _flyd2.default.on(callTool('dragover'), mapStream(el, 'dragover'));
	  _flyd2.default.on(callTool('dragleave'), mapStream(el, 'dragleave'));
	  _flyd2.default.on(callTool('dblclick'), mapStream(el, 'dblclick'));
	
	  var keysdown = {};
	  _flyd2.default.on(function (kd) {
	    if (!keysdown[kd.key]) {
	      callTool('keydown')(kd);
	      keysdown[kd.key] = setInterval(function () {
	        return callTool('keyheld')(kd);
	      }, 17);
	    }
	  }, mapStream(el, 'keydown'));
	
	  _flyd2.default.on(function (ku) {
	    if (keysdown[ku.key]) {
	      clearInterval(keysdown[ku.key]);
	      delete keysdown[ku.key];
	    }
	    callTool('keyup')(ku);
	  }, mapStream(el, 'keyup'));
	
	  var clickStream = mapStream(el, 'click', toCoords);
	  var mousedownStream = mapStream(el, 'mousedown', toCoords);
	  var mousemoveStream = mapStream(el, 'mousemove', toCoords);
	  var mouseupStream = mapStream(window, 'mouseup', toCoordsBubble);
	  var moveStream = _flyd2.default.stream();
	  var dragStream = _flyd2.default.stream();
	
	  var touchstartStream = transduceStream(el, 'touchstart', (0, _ramda.compose)((0, _ramda.filter)(isSingleTouch), (0, _ramda.map)(toMouseEvent)));
	  var touchendStream = mapStream(el, 'touchend', toMouseEvent);
	
	  _flyd2.default.on(function (md) {
	    md.originalEvent.target.focus();
	    callTool('mousedown')(md);
	    lastMousedown = { start: new Date(), event: md };
	
	    var tool = callTool('drag', { findFirst: true })(md);
	    if (!tool) return;
	
	    dragging = { lastMove: new Date() };
	
	    var clientX = null;
	    var clientY = null;
	
	    function toDeltaCoords(ev) {
	      ev.preventDefault();
	      var newEv = {
	        rect: rect,
	        clientX: ev.clientX - offset.x,
	        clientY: ev.clientY - offset.y,
	        originalEvent: ev,
	        which: ev.which,
	        altKey: ev.altKey,
	        ctrlKey: ev.ctrlKey,
	        metaKey: ev.metaKey,
	        shiftKey: ev.shiftKey
	      };
	      if (ev.movementX === undefined) {
	        newEv.deltaX = clientX === null ? 0 : ev.clientX - clientX;
	        newEv.deltaY = clientX === null ? 0 : ev.clientY - clientY;
	      } else {
	        newEv.deltaX = ev.movementX;
	        newEv.deltaY = ev.movementY;
	      }
	      clientX = ev.clientX;
	      clientY = ev.clientY;
	      return newEv;
	    }
	
	    moveStream = transduceStream(window, 'mousemove', (0, _ramda.compose)((0, _ramda.map)(touchLastMove), (0, _ramda.map)(toDeltaCoords)));
	
	    dragStream.end(true);
	    dragStream = tool.momentum ? addMomentum(moveStream, mouseupStream) : moveStream;
	    dragStream.map(tool.handle);
	  }, mousedownStream);
	
	  _flyd2.default.on(function (ts) {
	    callTool('mousedown')(ts);
	    lastMousedown = { start: new Date(), event: ts };
	
	    var tool = callTool('drag', { findFirst: true })(ts);
	    if (!tool) return;
	
	    dragging = { lastMove: new Date() };
	
	    var clientX = ts.clientX;
	    var clientY = ts.clientY;
	
	    function toDelta(e) {
	      var newE = (0, _extends3.default)({}, e, {
	        deltaX: e.clientX - clientX,
	        deltaY: e.clientY - clientY
	      });
	      clientX = e.clientX;
	      clientY = e.clientY;
	      return newE;
	    };
	
	    moveStream = transduceStream(el, 'touchmove', (0, _ramda.compose)((0, _ramda.filter)(isSingleTouch), (0, _ramda.map)(touchLastMove), (0, _ramda.map)(toMouseEvent), (0, _ramda.map)(toDelta)));
	
	    dragStream.end(true);
	    dragStream = tool.momentum ? addMomentum(moveStream, touchendStream) : moveStream;
	    dragStream.map(tool.handle);
	  }, touchstartStream);
	
	  var endingStream = _flyd2.default.merge(touchendStream, mouseupStream);
	  // If we are in an iframe, we can't handle mouseup events on parent window, so use mouseout instead
	  if (window.parent !== window) endingStream = _flyd2.default.merge(endingStream, mapStream(window, 'mouseout'));
	
	  _flyd2.default.on(function (mu) {
	    if (dragging) {
	      moveStream.end(true);
	      // End momentum if last mousemove event is gt 200ms from mouseup.
	      if (new Date() - dragging.lastMove > 200) {
	        dragStream.end(true);
	      }
	    }
	
	    //console.log('mu', new Date() - lastMousedown.start, lastMousedown.event, mu, muX, muY);
	
	    callTool('mouseup')(mu);
	
	    if (lastMousedown && new Date() - lastMousedown.start < 300) {
	      var muX = Math.abs(mu.clientX - lastMousedown.event.clientX);
	      var muY = Math.abs(mu.clientY - lastMousedown.event.clientY);
	
	      if (isNaN(muX)) {
	        callTool('click')(lastMousedown.event);
	      } else if (muX <= 5 && muY <= 5) {
	        callTool('click')(mu);
	      }
	    }
	
	    dragging = false;
	    lastMousedown = false;
	  }, endingStream);
	
	  _flyd2.default.on(callTool('hover'), _flyd2.default.transduce((0, _ramda.filter)(function () {
	    return !dragging && hasEvents['hover'];
	  }), mousemoveStream));
	
	  //flyd.map((scroll) => {
	  //  console.log('scroll?', scroll);
	  var scrollHandler = callTool('scroll');
	  mapStream(el, 'wheel', function (ev) {
	    if (hasEvents['scroll']) {
	      ev.preventDefault();
	      scrollHandler({
	        delta: -ev.deltaY / (ev.wheelDelta ? 200 : 10),
	        originalEvent: ev
	      });
	    }
	  });
	
	  function extractTouches(e) {
	    e.preventDefault();
	    return {
	      a: { x: e.touches[0].clientX, y: e.touches[0].clientY },
	      b: { x: e.touches[1].clientX, y: e.touches[1].clientY }
	    };
	  };
	
	  var zoom = flatMap(function (ts) {
	    var f = ts;
	    var moveStream = transduceStream(el, 'touchmove', (0, _ramda.compose)((0, _ramda.filter)(isDoubleTouch), (0, _ramda.map)(extractTouches), (0, _ramda.map)(function (g) {
	      var result = {
	        pinchX: g.b.x - f.b.x - (g.a.x - f.a.x),
	        pinchY: f.a.y - g.a.y - (f.b.y - g.b.y),
	        dragX: (g.a.x - f.a.x + (g.b.x - f.b.x)) / 2,
	        dragY: (g.a.y - f.a.y + (g.b.y - f.b.y)) / 2,
	        a: g.a, b: g.b
	      };
	      f = g;
	      return result;
	    })));
	    _flyd2.default.endsOn(touchendStream, moveStream);
	    return moveStream;
	  }, transduceStream(el, 'touchstart', (0, _ramda.compose)((0, _ramda.filter)(isDoubleTouch), (0, _ramda.map)(extractTouches))));
	
	  _flyd2.default.on(function (z) {
	    var pinchX = z.pinchX;
	    var pinchY = z.pinchY;
	    var dragX = z.dragX;
	    var dragY = z.dragY;
	    var a = z.a;
	    var b = z.b;
	
	    if (Math.abs(pinchX) + Math.abs(pinchY) > Math.abs(dragX) + Math.abs(dragY)) {
	      // pinch
	      callTool('pinch')({
	        deltaX: a.x > b.x ? -pinchX : pinchX,
	        deltaY: a.y > b.y ? pinchY : -pinchY
	      });
	    } else {
	      // swipe
	      callTool('swipe')({ deltaX: dragX, deltaY: dragY });
	    }
	  }, zoom);
	
	  return {
	    resize: resize,
	
	    updateTools: function updateTools(newCommands) {
	      commands = newCommands;
	      hasEvents = {};
	
	      (0, _ramda.forEach)(function (command) {
	        (0, _keys2.default)(command.tool).forEach(function (k) {
	          return hasEvents[k] = true;
	        });
	      }, commands);
	    }
	  };
	}
	
	function every(dur) {
	  var s = _flyd2.default.stream();
	  var target = Date.now();
	  function timer() {
	    if (s.end()) return;
	    var now = Date.now();
	    target += dur;
	    s(now);
	    setTimeout(timer, target - now);
	  }
	  timer();
	  return s;
	};
	
	function flatMap(f, s) {
	  return _flyd2.default.combine(function (s, own) {
	    _flyd2.default.map(own, f(s()));
	  }, [s]);
	};

/***/ },
/* 350 */
/*!************************!*\
  !*** ./vendor/flyd.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var curryN = __webpack_require__(/*! ramda */ 77).curryN;
	
	'use strict';
	
	function isFunction(obj) {
	  return !!(obj && obj.constructor && obj.call && obj.apply);
	}
	
	// Globals
	var toUpdate = [];
	var inStream;
	
	// Library functions use self callback to accept (null, undefined) update triggers.
	function map(f, s) {
	  return combine(function(s, self) { self(f(s.val)); }, [s]);
	}
	
	function on(f, s) {
	  return combine(function(s) { f(s.val); }, [s]);
	}
	
	function boundMap(f) { return map(f, this); }
	
	var scan = curryN(3, function(f, acc, s) {
	  var ns = combine(function(s, self) {
	    self(acc = f(acc, s.val));
	  }, [s]);
	  if (!ns.hasVal) ns(acc);
	  return ns;
	});
	
	var merge = curryN(2, function(s1, s2) {
	  var s = immediate(combine(function(s1, s2, self, changed) {
	    if (changed[0]) {
	      self(changed[0]());
	    } else if (s1.hasVal) {
	      self(s1.val);
	    } else if (s2.hasVal) {
	      self(s2.val);
	    }
	  }, [s1, s2]));
	  endsOn(combine(function() {
	    return true;
	  }, [s1.end, s2.end]), s);
	  return s;
	});
	
	function ap(s2) {
	  var s1 = this;
	  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);
	}
	
	function initialDepsNotMet(stream) {
	  stream.depsMet = stream.deps.every(function(s) {
	    return s.hasVal;
	  });
	  return !stream.depsMet;
	}
	
	function updateStream(s) {
	  if ((s.depsMet !== true && initialDepsNotMet(s)) ||
	      (s.end !== undefined && s.end.val === true)) return;
	  if (inStream !== undefined) {
	    toUpdate.push(s);
	    return;
	  }
	  inStream = s;
	  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;
	  var returnVal = s.fn.apply(s.fn, s.fnArgs);
	  if (returnVal !== undefined) {
	    s(returnVal);
	  }
	  inStream = undefined;
	  if (s.depsChanged !== undefined) s.depsChanged = [];
	  s.shouldUpdate = false;
	  if (flushing === false) flushUpdate();
	}
	
	var order = [];
	var orderNextIdx = -1;
	
	function findDeps(s) {
	  var i, listeners = s.listeners;
	  if (s.queued === false) {
	    s.queued = true;
	    for (i = 0; i < listeners.length; ++i) {
	      findDeps(listeners[i]);
	    }
	    order[++orderNextIdx] = s;
	  }
	}
	
	function updateDeps(s) {
	  var i, o, list, listeners = s.listeners;
	  for (i = 0; i < listeners.length; ++i) {
	    list = listeners[i];
	    if (list.end === s) {
	      endStream(list);
	    } else {
	      if (list.depsChanged !== undefined) list.depsChanged.push(s);
	      list.shouldUpdate = true;
	      findDeps(list);
	    }
	  }
	  for (; orderNextIdx >= 0; --orderNextIdx) {
	    o = order[orderNextIdx];
	    if (o.shouldUpdate === true) updateStream(o);
	    o.queued = false;
	  }
	}
	
	var flushing = false;
	
	function flushUpdate() {
	  flushing = true;
	  while (toUpdate.length > 0) {
	    var s = toUpdate.shift();
	    if (s.vals.length > 0) s.val = s.vals.shift();
	    updateDeps(s);
	  }
	  flushing = false;
	}
	
	function isStream(stream) {
	  return isFunction(stream) && 'hasVal' in stream;
	}
	
	function streamToString() {
	  return 'stream(' + this.val + ')';
	}
	
	function updateStreamValue(s, n) {
	  if (n !== undefined && n !== null && isFunction(n.then)) {
	    n.then(s);
	    return;
	  }
	  s.val = n;
	  s.hasVal = true;
	  if (inStream === undefined) {
	    flushing = true;
	    updateDeps(s);
	    if (toUpdate.length > 0) flushUpdate(); else flushing = false;
	  } else if (inStream === s) {
	    markListeners(s, s.listeners);
	  } else {
	    s.vals.push(n);
	    toUpdate.push(s);
	  }
	}
	
	function markListeners(s, lists) {
	  var i, list;
	  for (i = 0; i < lists.length; ++i) {
	    list = lists[i];
	    if (list.end !== s) {
	      if (list.depsChanged !== undefined) {
	        list.depsChanged.push(s);
	      }
	      list.shouldUpdate = true;
	    } else {
	      endStream(list);
	    }
	  }
	}
	
	function createStream() {
	  function s(n) {
	    return arguments.length > 0 ? (updateStreamValue(s, n), s)
	                                : s.val;
	  }
	  s.hasVal = false;
	  s.val = undefined;
	  s.vals = [];
	  s.listeners = [];
	  s.queued = false;
	  s.end = undefined;
	
	  s.map = boundMap;
	  s.ap = ap;
	  s.of = stream;
	  s.toString = streamToString;
	
	  return s;
	}
	
	function addListeners(deps, s) {
	  for (var i = 0; i < deps.length; ++i) {
	    deps[i].listeners.push(s);
	  }
	}
	
	function createDependentStream(deps, fn) {
	  var s = createStream();
	  s.fn = fn;
	  s.deps = deps;
	  s.depsMet = false;
	  s.depsChanged = deps.length > 0 ? [] : undefined;
	  s.shouldUpdate = false;
	  addListeners(deps, s);
	  return s;
	}
	
	function immediate(s) {
	  if (s.depsMet === false) {
	    s.depsMet = true;
	    updateStream(s);
	  }
	  return s;
	}
	
	function removeListener(s, listeners) {
	  var idx = listeners.indexOf(s);
	  listeners[idx] = listeners[listeners.length - 1];
	  listeners.length--;
	}
	
	function detachDeps(s) {
	  for (var i = 0; i < s.deps.length; ++i) {
	    removeListener(s, s.deps[i].listeners);
	  }
	  s.deps.length = 0;
	}
	
	function endStream(s) {
	  if (s.deps !== undefined) detachDeps(s);
	  if (s.end !== undefined) detachDeps(s.end);
	}
	
	function endsOn(endS, s) {
	  detachDeps(s.end);
	  endS.listeners.push(s.end);
	  s.end.deps.push(endS);
	  return s;
	}
	
	function trueFn() { return true; }
	
	function stream(initialValue) {
	  var endStream = createDependentStream([], trueFn);
	  var s = createStream();
	  s.end = endStream;
	  s.fnArgs = [];
	  endStream.listeners.push(s);
	  if (arguments.length > 0) s(initialValue);
	  return s;
	}
	
	function combine(fn, streams) {
	  var i, s, deps, depEndStreams;
	  var endStream = createDependentStream([], trueFn);
	  deps = []; depEndStreams = [];
	  for (i = 0; i < streams.length; ++i) {
	    if (streams[i] !== undefined) {
	      deps.push(streams[i]);
	      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);
	    }
	  }
	  s = createDependentStream(deps, fn);
	  s.depsChanged = [];
	  s.fnArgs = s.deps.concat([s, s.depsChanged]);
	  s.end = endStream;
	  endStream.listeners.push(s);
	  addListeners(depEndStreams, endStream);
	  endStream.deps = depEndStreams;
	  updateStream(s);
	  return s;
	}
	
	var transduce = curryN(2, function(xform, source) {
	  xform = xform(new StreamTransformer());
	  return combine(function(source, self) {
	    var res = xform['@@transducer/step'](undefined, source.val);
	    if (res && res['@@transducer/reduced'] === true) {
	      self.end(true);
	      return res['@@transducer/value'];
	    } else {
	      return res;
	    }
	  }, [source]);
	});
	
	function StreamTransformer() { }
	StreamTransformer.prototype['@@transducer/init'] = function() { };
	StreamTransformer.prototype['@@transducer/result'] = function() { };
	StreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };
	
	module.exports = {
	  stream: stream,
	  combine: curryN(2, combine),
	  isStream: isStream,
	  transduce: transduce,
	  merge: merge,
	  scan: scan,
	  endsOn: endsOn,
	  map: curryN(2, map),
	  on: curryN(2, on),
	  curryN: curryN,
	  immediate: immediate,
	};


/***/ },
/* 351 */
/*!***************************************!*\
  !*** ./src/translators/annotation.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getScreenPositionNormalAlpha = getScreenPositionNormalAlpha;
	
	var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ 113);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _scene = __webpack_require__(/*! ../modules/scene */ 147);
	
	var _player = __webpack_require__(/*! ../modules/player */ 265);
	
	var _getProjectionMatrix = __webpack_require__(/*! ./utils/getProjectionMatrix */ 325);
	
	var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getScreenPositionNormal(nodeWorldMatrix, cameraWorldMatrix, cameraProjection, optionalLocalDirection) {
	
	  var cameraInverseWorldMatrix = new _three2.default.Matrix4().getInverse(cameraWorldMatrix);
	
	  var combinedCameraSpaceMatrix = new _three2.default.Matrix4().multiplyList([cameraInverseWorldMatrix, nodeWorldMatrix]);
	  var combinedProjectionMatrix = new _three2.default.Matrix4().multiplyList([cameraProjection, cameraInverseWorldMatrix, nodeWorldMatrix]);
	
	  var nodeLocalPosition = new _three2.default.Vector3(0, 0, 0);
	  var nodeLocalDirectionOffset = optionalLocalDirection || new _three2.default.Vector3(0, 0, -1);
	
	  var nodeCameraPosition = nodeLocalPosition.clone().applyProjection(combinedCameraSpaceMatrix);
	  var nodeCameraDirectionOffset = nodeLocalDirectionOffset.clone().applyProjection(combinedCameraSpaceMatrix);
	
	  var nodeCameraNormal = new _three2.default.Vector3().subVectors(nodeCameraDirectionOffset, nodeCameraPosition).normalize();
	
	  var nodeScreenPosition = nodeLocalPosition.clone().applyProjection(combinedProjectionMatrix);
	  nodeScreenPosition.addScalar(1.0).multiplyScalar(0.5);
	
	  return {
	    position: nodeScreenPosition,
	    normal: nodeCameraNormal
	  };
	}
	
	function getScreenPositionNormalAlpha(id, calcDirection, directionTarget) {
	  return function (store) {
	    var nodeWorldTransform = (0, _scene.getWorldTransform)(store, id);
	    var cameraId = (0, _player.getCamera)(store);
	    var cameraPlug = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
	
	    var cameraWorldTransform = (0, _scene.getWorldTransform)(store, cameraId);
	    if (!cameraWorldTransform) return {};
	
	    var cameraProjection = (0, _getProjectionMatrix2.default)(cameraPlug);
	
	    var positionNormal = getScreenPositionNormal(nodeWorldTransform, cameraWorldTransform, cameraProjection, calcDirection && getDirection(store, id, directionTarget));
	
	    var annotation = (0, _scene.get)(store, { id: id, evalPlug: 'Annotation' });
	
	    var alpha = 1.0;
	
	    // mis-spelled visibility property.
	    if (annotation.limitVisilibility) {
	      var visibilityAngle = Math.min(annotation.visibilityAngle * 0.5, 90);
	      var cameraWorldDirection = new _three2.default.Vector3(0, 0, -1);
	      var dotResult = cameraWorldDirection.dot(positionNormal.normal);
	      if (dotResult < 0.0) {
	        alpha = 0.0;
	      } else {
	        var theta = _three2.default.Math.radToDeg(Math.acos(cameraWorldDirection.dot(positionNormal.normal)));
	
	        if (theta > visibilityAngle) {
	          alpha = 0.0;
	        } else if (theta > visibilityAngle * 0.75) {
	          alpha = (visibilityAngle - theta) / (visibilityAngle * 0.25);
	        }
	      }
	    }
	
	    return (0, _extends3.default)({ alpha: alpha }, positionNormal);
	  };
	}
	
	function getDirection(store, id, directionTarget) {
	  var targetPosition = new _three2.default.Vector3(0, 0, 0);
	  if (directionTarget) {
	    targetPosition = new _three2.default.Vector3().setFromMatrixPosition((0, _scene.getWorldTransform)(store, directionTarget));
	  }
	  var currentTransform = (0, _scene.getWorldTransform)(store, id);
	  var currentPosition = new _three2.default.Vector3().setFromMatrixPosition(currentTransform);
	  var direction = targetPosition.clone().sub(currentPosition).normalize();
	  var inverseWorldMatrix = new _three2.default.Matrix4();
	  inverseWorldMatrix.getInverse(currentTransform);
	  direction.applyMatrix4(inverseWorldMatrix).normalize();
	  return direction;
	}

/***/ },
/* 352 */
/*!**********************************************!*\
  !*** ./src/translators/utils/outlinePass.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ 164);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @author spidersharma / http://eduperiment.com/
	 */
	
	_three2.default.OutlinePass = function (resolution, scene, camera, selectedObjects) {
	
		this.renderScene = scene;
		this.renderCamera = camera;
		this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];
		this.visibleEdgeColor = new _three2.default.Color(1, 1, 1);
		this.hiddenEdgeColor = new _three2.default.Color(0.1, 0.04, 0.02);
		this.edgeGlow = 0.0;
		this.usePatternTexture = false;
		this.edgeThickness = 1.0;
		this.edgeStrength = 3.0;
		this.downSampleRatio = 2;
		this.pulsePeriod = 0;
	
		_three2.default.Pass.call(this);
	
		this.resolution = resolution !== undefined ? new _three2.default.Vector2(resolution.x, resolution.y) : new _three2.default.Vector2(256, 256);
	
		var pars = { minFilter: _three2.default.LinearFilter, magFilter: _three2.default.LinearFilter, format: _three2.default.RGBAFormat };
	
		var resx = Math.round(this.resolution.x / this.downSampleRatio);
		var resy = Math.round(this.resolution.y / this.downSampleRatio);
	
		this.maskBufferMaterial = new _three2.default.MeshBasicMaterial({ color: 0xffffff });
		this.maskBufferMaterial.side = _three2.default.DoubleSide;
		this.renderTargetMaskBuffer = new _three2.default.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);
		this.renderTargetMaskBuffer.texture.generateMipmaps = false;
	
		this.depthMaterial = new _three2.default.MeshDepthMaterial();
		this.depthMaterial.side = _three2.default.DoubleSide;
		this.depthMaterial.depthPacking = _three2.default.RGBADepthPacking;
		this.depthMaterial.blending = _three2.default.NoBlending;
	
		this.prepareMaskMaterial = this.getPrepareMaskMaterial();
		this.prepareMaskMaterial.side = _three2.default.DoubleSide;
	
		this.renderTargetDepthBuffer = new _three2.default.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);
		this.renderTargetDepthBuffer.texture.generateMipmaps = false;
	
		this.renderTargetMaskDownSampleBuffer = new _three2.default.WebGLRenderTarget(resx, resy, pars);
		this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;
	
		this.renderTargetBlurBuffer1 = new _three2.default.WebGLRenderTarget(resx, resy, pars);
		this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
		this.renderTargetBlurBuffer2 = new _three2.default.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
		this.renderTargetBlurBuffer2.texture.generateMipmaps = false;
	
		this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
		this.renderTargetEdgeBuffer1 = new _three2.default.WebGLRenderTarget(resx, resy, pars);
		this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
		this.renderTargetEdgeBuffer2 = new _three2.default.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
		this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;
	
		var MAX_EDGE_THICKNESS = 4;
		var MAX_EDGE_GLOW = 4;
	
		this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);
		this.separableBlurMaterial1.uniforms["texSize"].value = new _three2.default.Vector2(resx, resy);
		this.separableBlurMaterial1.uniforms["kernelRadius"].value = 1;
		this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);
		this.separableBlurMaterial2.uniforms["texSize"].value = new _three2.default.Vector2(Math.round(resx / 2), Math.round(resy / 2));
		this.separableBlurMaterial2.uniforms["kernelRadius"].value = MAX_EDGE_GLOW;
	
		// Overlay material
		this.overlayMaterial = this.getOverlayMaterial();
	
		// copy material
		if (_three2.default.CopyShader === undefined) console.error("THREE.OutlinePass relies on THREE.CopyShader");
	
		var copyShader = _three2.default.CopyShader;
	
		this.copyUniforms = _three2.default.UniformsUtils.clone(copyShader.uniforms);
		this.copyUniforms["opacity"].value = 1.0;
	
		this.materialCopy = new _three2.default.ShaderMaterial({
			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: _three2.default.NoBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		});
	
		this.enabled = true;
		this.needsSwap = false;
	
		this.oldClearColor = new _three2.default.Color();
		this.oldClearAlpha = 1;
	
		this.camera = new _three2.default.OrthographicCamera(-1, 1, 1, -1, 0, 1);
		this.scene = new _three2.default.Scene();
	
		this.quad = new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(2, 2), null);
		this.scene.add(this.quad);
	
		this.tempPulseColor1 = new _three2.default.Color();
		this.tempPulseColor2 = new _three2.default.Color();
		this.textureMatrix = new _three2.default.Matrix4();
	};
	
	_three2.default.OutlinePass.prototype = (0, _assign2.default)((0, _create2.default)(_three2.default.Pass.prototype), {
	
		constructor: _three2.default.OutlinePass,
	
		dispose: function dispose() {
			this.renderTargetMaskBuffer.dispose();
			this.renderTargetDepthBuffer.dispose();
			this.renderTargetMaskDownSampleBuffer.dispose();
			this.renderTargetBlurBuffer1.dispose();
			this.renderTargetBlurBuffer2.dispose();
			this.renderTargetEdgeBuffer1.dispose();
			this.renderTargetEdgeBuffer2.dispose();
		},
	
		setSize: function setSize(width, height) {
	
			this.renderTargetMaskBuffer.setSize(width, height);
	
			var resx = Math.round(width / this.downSampleRatio);
			var resy = Math.round(height / this.downSampleRatio);
			this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);
			this.renderTargetBlurBuffer1.setSize(resx, resy);
			this.renderTargetEdgeBuffer1.setSize(resx, resy);
			this.separableBlurMaterial1.uniforms["texSize"].value = new _three2.default.Vector2(resx, resy);
	
			resx = Math.round(resx / 2);
			resy = Math.round(resy / 2);
	
			this.renderTargetBlurBuffer2.setSize(resx, resy);
			this.renderTargetEdgeBuffer2.setSize(resx, resy);
	
			this.separableBlurMaterial2.uniforms["texSize"].value = new _three2.default.Vector2(resx, resy);
		},
	
		changeVisibilityOfSelectedObjects: function changeVisibilityOfSelectedObjects(bVisible) {
	
			var gatherSelectedMeshesCallBack = function gatherSelectedMeshesCallBack(object) {
	
				if (object instanceof _three2.default.Mesh) {
					var visibility = object.visible;
					if (!bVisible || object.bVisible) object.visible = bVisible;
					object.bVisible = visibility;
				}
			};
	
			for (var i = 0; i < this.selectedObjects.length; i++) {
	
				var selectedObject = this.selectedObjects[i];
	
				selectedObject.traverse(gatherSelectedMeshesCallBack);
			}
		},
	
		changeVisibilityOfNonSelectedObjects: function changeVisibilityOfNonSelectedObjects(bVisible) {
	
			var selectedMeshes = [];
	
			var gatherSelectedMeshesCallBack = function gatherSelectedMeshesCallBack(object) {
	
				if (object instanceof _three2.default.Mesh) {
	
					selectedMeshes.push(object);
				}
			};
	
			for (var i = 0; i < this.selectedObjects.length; i++) {
	
				var selectedObject = this.selectedObjects[i];
	
				selectedObject.traverse(gatherSelectedMeshesCallBack);
			}
	
			var VisibilityChangeCallBack = function VisibilityChangeCallBack(object) {
	
				if (object instanceof _three2.default.Mesh) {
	
					var bFound = false;
	
					for (var i = 0; i < selectedMeshes.length; i++) {
	
						var selectedObjectId = selectedMeshes[i].id;
	
						if (selectedObjectId === object.id) {
							bFound = true;
							break;
						}
					}
					if (!bFound) {
						var visibility = object.visible;
						if (!bVisible || object.bVisible) object.visible = bVisible;
						object.bVisible = visibility;
					}
				}
			};
			this.renderScene.traverse(VisibilityChangeCallBack);
		},
	
		updateTextureMatrix: function updateTextureMatrix() {
	
			this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
			this.textureMatrix.multiply(this.renderCamera.projectionMatrix);
			this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
		},
	
		render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {
	
			if (this.selectedObjects.length === 0) return;
	
			this.oldClearColor.copy(renderer.getClearColor());
			this.oldClearAlpha = renderer.getClearAlpha();
			var oldAutoClear = renderer.autoClear;
	
			renderer.autoClear = false;
	
			if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);
	
			renderer.setClearColor(0xffffff, 1);
	
			// Make selected objects invisible
			this.changeVisibilityOfSelectedObjects(false);
	
			// 1. Draw Non Selected objects in the depth buffer
			this.renderScene.overrideMaterial = this.depthMaterial;
			renderer.render(this.renderScene, this.renderCamera, this.renderTargetDepthBuffer, true);
	
			// Make selected objects visible
			this.changeVisibilityOfSelectedObjects(true);
	
			// Update Texture Matrix for Depth compare
			this.updateTextureMatrix();
	
			// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
			this.changeVisibilityOfNonSelectedObjects(false);
			this.renderScene.overrideMaterial = this.prepareMaskMaterial;
			this.prepareMaskMaterial.uniforms["cameraNearFar"].value = new _three2.default.Vector2(this.renderCamera.near, this.renderCamera.far);
			this.prepareMaskMaterial.uniforms["depthTexture"].value = this.renderTargetDepthBuffer.texture;
			this.prepareMaskMaterial.uniforms["textureMatrix"].value = this.textureMatrix;
			renderer.render(this.renderScene, this.renderCamera, this.renderTargetMaskBuffer, true);
			this.renderScene.overrideMaterial = null;
			this.changeVisibilityOfNonSelectedObjects(true);
	
			// 2. Downsample to Half resolution
			this.quad.material = this.materialCopy;
			this.copyUniforms["tDiffuse"].value = this.renderTargetMaskBuffer.texture;
			renderer.render(this.scene, this.camera, this.renderTargetMaskDownSampleBuffer, true);
	
			this.tempPulseColor1.copy(this.visibleEdgeColor);
			this.tempPulseColor2.copy(this.hiddenEdgeColor);
			if (this.pulsePeriod > 0) {
				var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;
				this.tempPulseColor1.multiplyScalar(scalar);
				this.tempPulseColor2.multiplyScalar(scalar);
			}
	
			// 3. Apply Edge Detection Pass
			this.quad.material = this.edgeDetectionMaterial;
			this.edgeDetectionMaterial.uniforms["maskTexture"].value = this.renderTargetMaskDownSampleBuffer.texture;
			this.edgeDetectionMaterial.uniforms["texSize"].value = new _three2.default.Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
			this.edgeDetectionMaterial.uniforms["visibleEdgeColor"].value = this.tempPulseColor1;
			this.edgeDetectionMaterial.uniforms["hiddenEdgeColor"].value = this.tempPulseColor2;
			renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, true);
	
			// 4. Apply Blur on Half res
			this.quad.material = this.separableBlurMaterial1;
			this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial1.uniforms["direction"].value = _three2.default.OutlinePass.BlurDirectionX;
			this.separableBlurMaterial1.uniforms["kernelRadius"].value = this.edgeThickness;
			renderer.render(this.scene, this.camera, this.renderTargetBlurBuffer1, true);
			this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetBlurBuffer1.texture;
			this.separableBlurMaterial1.uniforms["direction"].value = _three2.default.OutlinePass.BlurDirectionY;
			//renderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer1, false );
	
			// Apply Blur on quarter res
			this.quad.material = this.separableBlurMaterial2;
			this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial2.uniforms["direction"].value = _three2.default.OutlinePass.BlurDirectionX;
			renderer.render(this.scene, this.camera, this.renderTargetBlurBuffer2, true);
			this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetBlurBuffer2.texture;
			this.separableBlurMaterial2.uniforms["direction"].value = _three2.default.OutlinePass.BlurDirectionY;
			renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer2, true);
	
			// Blend it additively over the input texture
			this.quad.material = this.overlayMaterial;
			this.overlayMaterial.uniforms["maskTexture"].value = this.renderTargetMaskBuffer.texture;
			this.overlayMaterial.uniforms["edgeTexture1"].value = this.renderTargetEdgeBuffer1.texture;
			this.overlayMaterial.uniforms["edgeTexture2"].value = this.renderTargetEdgeBuffer2.texture;
			this.overlayMaterial.uniforms["patternTexture"].value = this.patternTexture;
			this.overlayMaterial.uniforms["edgeStrength"].value = this.edgeStrength;
			this.overlayMaterial.uniforms["edgeGlow"].value = this.edgeGlow;
			this.overlayMaterial.uniforms["usePatternTexture"].value = this.usePatternTexture;
	
			if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);
	
			renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, false);
	
			renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
			renderer.autoClear = oldAutoClear;
		},
	
		getPrepareMaskMaterial: function getPrepareMaskMaterial() {
	
			return new _three2.default.ShaderMaterial({
	
				uniforms: {
					"depthTexture": { value: null },
					"cameraNearFar": { value: new _three2.default.Vector2(0.5, 0.5) },
					"textureMatrix": { value: new _three2.default.Matrix4() }
				},
	
				vertexShader: "varying vec2 vUv;\
					varying vec4 projTexCoord;\
					varying vec4 vPosition;\
					uniform mat4 textureMatrix;\
					void main() {\
						vUv = uv;\
						vPosition = modelViewMatrix * vec4( position, 1.0 );\
						vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\
						projTexCoord = textureMatrix * worldPosition;\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",
	
				fragmentShader: "#include <packing>\
					varying vec2 vUv;\
					varying vec4 vPosition;\
					varying vec4 projTexCoord;\
					uniform sampler2D depthTexture;\
					uniform vec2 cameraNearFar;\
					\
					void main() {\
						float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\
						float viewZ = -perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );\
						float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\
						gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\
					}"
			});
		},
	
		getEdgeDetectionMaterial: function getEdgeDetectionMaterial() {
	
			return new _three2.default.ShaderMaterial({
	
				uniforms: {
					"maskTexture": { value: null },
					"texSize": { value: new _three2.default.Vector2(0.5, 0.5) },
					"visibleEdgeColor": { value: new _three2.default.Vector3(1.0, 1.0, 1.0) },
					"hiddenEdgeColor": { value: new _three2.default.Vector3(1.0, 1.0, 1.0) }
				},
	
				vertexShader: "varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",
	
				fragmentShader: "varying vec2 vUv;\
					uniform sampler2D maskTexture;\
					uniform vec2 texSize;\
					uniform vec3 visibleEdgeColor;\
					uniform vec3 hiddenEdgeColor;\
					\
					void main() {\n\
						vec2 invSize = 1.0 / texSize;\
						vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\
						vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\
						vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\
						vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\
						vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\
						float diff1 = (c1.r - c2.r)*0.5;\
						float diff2 = (c3.r - c4.r)*0.5;\
						float d = length( vec2(diff1, diff2) );\
						float a1 = min(c1.g, c2.g);\
						float a2 = min(c3.g, c4.g);\
						float visibilityFactor = min(a1, a2);\
						vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\
						gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\
					}"
			});
		},
	
		getSeperableBlurMaterial: function getSeperableBlurMaterial(maxRadius) {
	
			return new _three2.default.ShaderMaterial({
	
				defines: {
					"MAX_RADIUS": maxRadius
				},
	
				uniforms: {
					"colorTexture": { value: null },
					"texSize": { value: new _three2.default.Vector2(0.5, 0.5) },
					"direction": { value: new _three2.default.Vector2(0.5, 0.5) },
					"kernelRadius": { value: 1.0 }
				},
	
				vertexShader: "varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",
	
				fragmentShader: "#include <common>\
					varying vec2 vUv;\
					uniform sampler2D colorTexture;\
					uniform vec2 texSize;\
					uniform vec2 direction;\
					uniform float kernelRadius;\
					\
					float gaussianPdf2(in float x, in float sigma) {\
						return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
					}\
					void main() {\
						vec2 invSize = 1.0 / texSize;\
						float weightSum = gaussianPdf2(0.0, kernelRadius);\
						vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
						vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\
						vec2 uvOffset = delta;\
						for( int i = 1; i <= MAX_RADIUS; i ++ ) {\
							float w = gaussianPdf2(uvOffset.x, kernelRadius);\
							vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
							vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
							diffuseSum += ((sample1 + sample2) * w);\
							weightSum += (2.0 * w);\
							uvOffset += delta;\
						}\
						gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\
					}"
			});
		},
	
		getOverlayMaterial: function getOverlayMaterial() {
	
			return new _three2.default.ShaderMaterial({
	
				uniforms: {
					"maskTexture": { value: null },
					"edgeTexture1": { value: null },
					"edgeTexture2": { value: null },
					"patternTexture": { value: null },
					"edgeStrength": { value: 1.0 },
					"edgeGlow": { value: 1.0 },
					"usePatternTexture": { value: 0.0 }
				},
	
				vertexShader: "varying vec2 vUv;\n\
					void main() {\n\
						vUv = uv;\n\
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
					}",
	
				fragmentShader: "varying vec2 vUv;\
					uniform sampler2D maskTexture;\
					uniform sampler2D edgeTexture1;\
					uniform sampler2D edgeTexture2;\
					uniform sampler2D patternTexture;\
					uniform float edgeStrength;\
					uniform float edgeGlow;\
					uniform bool usePatternTexture;\
					\
					void main() {\
						vec4 edgeValue1 = texture2D(edgeTexture1, vUv);\
						vec4 edgeValue2 = texture2D(edgeTexture2, vUv);\
						vec4 maskColor = texture2D(maskTexture, vUv);\
						vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\
						float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\
						vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\
						vec4 finalColor = edgeStrength * maskColor.r * edgeValue;\
						if(usePatternTexture)\
							finalColor += visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\
						gl_FragColor = finalColor;\
					}",
	
				blending: _three2.default.AdditiveBlending,
				depthTest: false,
				depthWrite: false,
				transparent: true
			});
		}
	
	});
	
	_three2.default.OutlinePass.BlurDirectionX = new _three2.default.Vector2(1.0, 0.0);
	_three2.default.OutlinePass.BlurDirectionY = new _three2.default.Vector2(0.0, 1.0);

/***/ },
/* 353 */
/*!*********************************************!*\
  !*** ./src/translators/utils/FXAAShader.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author davidedc / http://www.sketchpatch.net/
	 *
	 * NVIDIA FXAA by Timothy Lottes
	 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
	 * - WebGL port by @supereggbert
	 * http://www.glge.org/demos/fxaa/
	 */
	
	_three2.default.FXAAShader = {
	
		uniforms: {
	
			"tDiffuse": { value: null },
			"resolution": { value: new _three2.default.Vector2(1 / 1024, 1 / 512) }
	
		},
	
		vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
	
		fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "#define FXAA_REDUCE_MIN   (1.0/128.0)", "#define FXAA_REDUCE_MUL   (1.0/8.0)", "#define FXAA_SPAN_MAX     8.0", "void main() {", "vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;", "vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;", "vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );", "vec3 rgbM  = rgbaM.xyz;", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float lumaNW = dot( rgbNW, luma );", "float lumaNE = dot( rgbNE, luma );", "float lumaSW = dot( rgbSW, luma );", "float lumaSE = dot( rgbSE, luma );", "float lumaM  = dot( rgbM,  luma );", "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );", "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );", "vec2 dir;", "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));", "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));", "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );", "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );", "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),", "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),", "dir * rcpDirMin)) * resolution;", "vec4 rgbA = (1.0/2.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));", "vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));", "float lumaB = dot(rgbB, vec4(luma, 0.0));", "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {", "gl_FragColor = rgbA;", "} else {", "gl_FragColor = rgbB;", "}", "}"].join("\n")
	
	};

/***/ },
/* 354 */
/*!********************************************************!*\
  !*** ./src/translators/utils/parallaxBarrierEffect.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author marklundin / http://mark-lundin.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	_three2.default.ParallaxBarrierEffect = function (renderer) {
	
	  var _camera = new _three2.default.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	
	  var _scene = new _three2.default.Scene();
	
	  var _stereo = new _three2.default.StereoCamera();
	
	  var _params = { minFilter: _three2.default.LinearFilter, magFilter: _three2.default.NearestFilter, format: _three2.default.RGBAFormat };
	
	  var _renderTargetL = new _three2.default.WebGLRenderTarget(512, 512, _params);
	  var _renderTargetR = new _three2.default.WebGLRenderTarget(512, 512, _params);
	
	  var _material = new _three2.default.ShaderMaterial({
	
	    uniforms: {
	
	      "mapLeft": { value: _renderTargetL.texture },
	      "mapRight": { value: _renderTargetR.texture }
	
	    },
	
	    vertexShader: ["varying vec2 vUv;", "void main() {", " vUv = vec2( uv.x, uv.y );", " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
	
	    fragmentShader: ["uniform sampler2D mapLeft;", "uniform sampler2D mapRight;", "varying vec2 vUv;", "void main() {", " vec2 uv = vUv;", " if ( ( mod( gl_FragCoord.x, 2.0 ) ) > 1.00 ) {", "   gl_FragColor = texture2D( mapLeft, uv );", " } else {", "   gl_FragColor = texture2D( mapRight, uv );", " }", "}"].join("\n")
	
	  });
	
	  var mesh = new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(2, 2), _material);
	  _scene.add(mesh);
	
	  this.setSize = function (width, height) {
	
	    renderer.setSize(width, height);
	
	    var pixelRatio = renderer.getPixelRatio();
	
	    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);
	    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);
	  };
	
	  this.render = function (scene, camera) {
	
	    scene.updateMatrixWorld();
	
	    if (camera.parent === null) camera.updateMatrixWorld();
	
	    _stereo.update(camera);
	
	    renderer.render(scene, _stereo.cameraL, _renderTargetL, true);
	    renderer.render(scene, _stereo.cameraR, _renderTargetR, true);
	    renderer.render(_scene, _camera);
	  };
	};

/***/ },
/* 355 */
/*!***************************!*\
  !*** ./src/autoRotate.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.startAutoRotate = startAutoRotate;
	exports.stopAutoRotate = stopAutoRotate;
	exports.autoRotateTool = autoRotateTool;
	
	var _scene = __webpack_require__(/*! ./modules/scene */ 147);
	
	var _animation = __webpack_require__(/*! ./modules/animation */ 132);
	
	function startAutoRotate(store) {
	  var player = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
	  var id = player && player.autoRotateNode;
	
	  if (!player || !player.autoRotate || !id) return false;
	
	  var increment = player.autoRotateDirection === '+' ? 360 : -360;
	  var path = (0, _scene.find)(store, { id: id, plug: 'Transform', property: 'rotation' });
	  var rotation = (0, _scene.get)(store, { id: id, plug: 'Transform', property: 'rotation' });
	
	  if (path && rotation) {
	    store.dispatch((0, _animation.queueAnimation)({
	      name: 'autoRotate',
	      autoplay: true,
	      iterations: Infinity,
	      easingDuration: 3000,
	      tracks: [{
	        path: path,
	        start: 0,
	        duration: player.autoRotateSpeed * 1000,
	        value: { x: rotation.x, y: rotation.y + increment, z: rotation.z }
	      }]
	    }));
	  }
	};
	
	function stopAutoRotate(store) {
	  store.dispatch((0, _animation.removeAnimation)('autoRotate'));
	};
	
	function autoRotateTool(store) {
	  var startingTimeout = undefined;
	
	  var tool = {
	    start: function start() {
	      var timeout = arguments.length <= 0 || arguments[0] === undefined ? 5000 : arguments[0];
	
	      startingTimeout = setTimeout(function () {
	        startAutoRotate(store);
	      }, timeout);
	    },
	    stop: function stop() {
	      stopAutoRotate(store);
	      clearTimeout(startingTimeout);
	    },
	    mousedown: function mousedown() {
	      return tool.stop();
	    },
	    mouseup: function mouseup() {
	      return tool.start();
	    }
	  };
	
	  return {
	    enabled: true,
	    tool: tool
	  };
	};

/***/ },
/* 356 */
/*!***********************!*\
  !*** ./src/player.js ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ 2);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _three = __webpack_require__(/*! three */ 64);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _rollbarBrowser = __webpack_require__(/*! rollbar-browser */ 65);
	
	var _rollbarBrowser2 = _interopRequireDefault(_rollbarBrowser);
	
	var _immutable = __webpack_require__(/*! immutable */ 66);
	
	var _immutable2 = _interopRequireDefault(_immutable);
	
	var _snabbdom = __webpack_require__(/*! snabbdom */ 67);
	
	var _snabbdom2 = _interopRequireDefault(_snabbdom);
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	var _class = __webpack_require__(/*! snabbdom/modules/class */ 71);
	
	var _class2 = _interopRequireDefault(_class);
	
	var _props = __webpack_require__(/*! snabbdom/modules/props */ 72);
	
	var _props2 = _interopRequireDefault(_props);
	
	var _attributes = __webpack_require__(/*! snabbdom/modules/attributes */ 73);
	
	var _attributes2 = _interopRequireDefault(_attributes);
	
	var _style = __webpack_require__(/*! snabbdom/modules/style */ 74);
	
	var _style2 = _interopRequireDefault(_style);
	
	var _eventlisteners = __webpack_require__(/*! snabbdom/modules/eventlisteners */ 75);
	
	var _eventlisteners2 = _interopRequireDefault(_eventlisteners);
	
	var _eventEmitter = __webpack_require__(/*! ./utils/eventEmitter */ 76);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _ramda = __webpack_require__(/*! ramda */ 77);
	
	var _ramda2 = _interopRequireDefault(_ramda);
	
	var _api = __webpack_require__(/*! ./store/api */ 78);
	
	var _api2 = _interopRequireDefault(_api);
	
	var _clientMiddleware = __webpack_require__(/*! ./store/clientMiddleware */ 112);
	
	var _clientMiddleware2 = _interopRequireDefault(_clientMiddleware);
	
	var _animation = __webpack_require__(/*! ./modules/animation */ 132);
	
	var _animation2 = _interopRequireDefault(_animation);
	
	var _annotations = __webpack_require__(/*! ./modules/annotations */ 264);
	
	var _annotations2 = _interopRequireDefault(_annotations);
	
	var _sceneGraph = __webpack_require__(/*! ./modules/sceneGraph */ 142);
	
	var _sceneGraph2 = _interopRequireDefault(_sceneGraph);
	
	var _sceneIO = __webpack_require__(/*! ./modules/sceneIO */ 255);
	
	var _sceneIO2 = _interopRequireDefault(_sceneIO);
	
	var _assets = __webpack_require__(/*! ./modules/assets */ 144);
	
	var _assets2 = _interopRequireDefault(_assets);
	
	var _player = __webpack_require__(/*! ./modules/player */ 265);
	
	var _player2 = _interopRequireDefault(_player);
	
	var _scene = __webpack_require__(/*! ./modules/scene */ 147);
	
	var _scene2 = _interopRequireDefault(_scene);
	
	var _plugins = __webpack_require__(/*! ./modules/plugins */ 280);
	
	var _plugins2 = _interopRequireDefault(_plugins);
	
	var _configuration = __webpack_require__(/*! ./modules/configuration */ 281);
	
	var _configuration2 = _interopRequireDefault(_configuration);
	
	var _selection = __webpack_require__(/*! ./modules/selection */ 282);
	
	var _selection2 = _interopRequireDefault(_selection);
	
	var _commands = __webpack_require__(/*! ./modules/commands */ 275);
	
	var _commands2 = _interopRequireDefault(_commands);
	
	var _operators = __webpack_require__(/*! ./operators */ 283);
	
	var _operators2 = _interopRequireDefault(_operators);
	
	var _primitives = __webpack_require__(/*! ./operators/primitives */ 297);
	
	var _primitives2 = _interopRequireDefault(_primitives);
	
	var _store = __webpack_require__(/*! ./store */ 298);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _bindActionCreatorsAndSelectors = __webpack_require__(/*! ./store/bindActionCreatorsAndSelectors */ 301);
	
	var _bindActionCreatorsAndSelectors2 = _interopRequireDefault(_bindActionCreatorsAndSelectors);
	
	var _player3 = __webpack_require__(/*! ./components/player */ 357);
	
	var _player4 = _interopRequireDefault(_player3);
	
	var _tools = __webpack_require__(/*! ./translators/tools */ 323);
	
	var _tools2 = _interopRequireDefault(_tools);
	
	var _three3 = __webpack_require__(/*! ./translators/three */ 343);
	
	var _three4 = _interopRequireDefault(_three3);
	
	var _autoRotate = __webpack_require__(/*! ./autoRotate */ 355);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// attaches event listeners
	// makes it easy to toggle classes
	var mapObjIndexed = _ramda2.default.mapObjIndexed; // handles styling on elements with support for animations
	// for setting properties on DOM elements
	
	// import createLogger from 'redux-logger';
	
	var Rollbar = ("74f3517e176d41cfa5e9c41f446b5531") && _rollbarBrowser2.default.init({
	  accessToken: ("74f3517e176d41cfa5e9c41f446b5531"),
	  verbose: true,
	  captureUncaught: true,
	  payload: {
	    environment: ("stationbuilder"),
	    context: 'playerv2'
	  }
	});
	
	if (true) {
	  window.WebVRConfig.CARDBOARD_UI_DISABLED = true;
	  window.WebVRConfig.ROTATE_INSTRUCTIONS_DISABLED = true;
	  window.WebVRConfig.BUFFER_SCALE = 1.0;
	}
	
	var reducers = {
	  animation: _animation2.default.reducer,
	  annotations: _annotations2.default.reducer,
	  assets: _assets2.default.reducer,
	  commands: _commands2.default.reducer,
	  sceneGraph: _sceneGraph2.default.reducer(_operators2.default),
	  sceneIO: _sceneIO2.default.reducer,
	  player: _player2.default.reducer,
	  plugins: _plugins2.default.reducer,
	  selection: _selection2.default.reducer
	};
	
	try {
	  (function () {
	
	    /**
	     * The main function. This function initializes the player for a given DOM Node.
	     *
	     * @param {(String|DOMNode)} elOrId - the DOM Node or String id of a DOM Node.
	     * @param {Function?} initializationFn - an optional initialization function that will be called (with api as argument) before the first render.
	     * @returns {API} The clara playera API.
	     * @public
	     */
	
	    var claraplayer = function claraplayer(elOrId, initializationFn) {
	      var parentEl = typeof elOrId === 'string' ? document.getElementById(elOrId) : elOrId;
	      parentEl.appendChild(document.createElement('div'));
	      var rect = parentEl.getBoundingClientRect();
	      if (!rect.height) {
	        throw new Error('Player element must have a height');
	      }
	
	      var store = (0, _store2.default)(reducers, _operators2.default, _primitives2.default, middleware);
	      if (Rollbar) store.useRollbar(Rollbar);
	      var dispatch = store.dispatch.bind(store);
	      var translator = (0, _three4.default)(store);
	      store.setTranslator(translator);
	      store.setApi(_api2.default);
	
	      var actions = (0, _bindActionCreatorsAndSelectors2.default)(store, {
	        animation: _animation2.default, annotations: _annotations2.default, assets: _assets2.default, commands: _commands2.default, configuration: _configuration2.default, scene: _scene2.default, sceneIO: _sceneIO2.default, sceneGraph: _sceneGraph2.default, player: _player2.default, plugins: _plugins2.default, selection: _selection2.default
	      });
	
	      var api = (0, _assign2.default)({}, (0, _eventEmitter2.default)(), {
	        deps: deps,
	        three: {
	          scene: translator.scene,
	          camera: translator.camera
	        },
	        _store: store
	      }, actions);
	
	      if (initializationFn && typeof initializationFn === 'function') initializationFn(api);
	
	      var el = parentEl.children[0];
	      var parentStyle = window.getComputedStyle(parentEl, null);
	      var isFlex = parentStyle.display === 'flex';
	      var isRelative = parentStyle.position === 'relative';
	      var vnode = patch(el, (0, _player4.default)(store, { isFlex: isFlex, isRelative: isRelative, parentEl: parentEl }));
	
	      store.subscribe(function (events) {
	        //try {
	        vnode = patch(vnode, (0, _player4.default)(store, { isFlex: isFlex, isRelative: isRelative, parentEl: parentEl }));
	        if (events.length) events.forEach(function (e) {
	          api.emit.apply(api, [e.type].concat((0, _toConsumableArray3.default)(e.args)));
	        });
	        api.emit('change');
	        //} catch (e) {
	        //  store.error(e);
	        //}
	      });
	
	      dispatch((0, _plugins.setApi)(api));
	
	      mapObjIndexed(function (tool, toolName) {
	        dispatch((0, _commands.addCommand)(typeof tool === 'function' ? tool(store, translator) : tool, toolName));
	      }, _tools2.default);
	
	      var autoRotateToolObj = (0, _autoRotate.autoRotateTool)(store);
	      dispatch((0, _commands.addCommand)(autoRotateToolObj, 'autoRotate'));
	
	      api.on('loaded', function () {
	        // TODO: zoom camera
	        autoRotateToolObj.tool.start(1000);
	      });
	
	      return api;
	    };
	
	    var patch = _snabbdom2.default.init([_class2.default, _props2.default, _attributes2.default, _style2.default, _eventlisteners2.default]);
	
	    // const middleware = [logger()];
	    // const loggerMiddleware = createLogger({
	    //   timestamp: true, duration: true, transformer: (state) => state.toJS()
	    // });
	    var middleware = [_clientMiddleware2.default];
	    // if (false) middleware.push(loggerMiddleware);
	
	    var deps = {
	      immutable: _immutable2.default,
	      patch: patch,
	      h: _h2.default,
	      ramda: _ramda2.default,
	      THREE: _three2.default
	    };;
	
	    claraplayer.deps = deps;
	
	    claraplayer.hasWebGL = function () {
	      var canvas = document.createElement('canvas');
	      return !!canvas.getContext('webgl') || !!canvas.getContext('experimental-webgl');
	    };
	
	    module.exports = claraplayer;
	  })();
	} catch (e) {
	  if (Rollbar) Rollbar.error(e);
	}

/***/ },
/* 357 */
/*!**********************************!*\
  !*** ./src/components/player.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = player;
	
	var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ 56);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _h = __webpack_require__(/*! snabbdom/h */ 70);
	
	var _h2 = _interopRequireDefault(_h);
	
	var _canvas = __webpack_require__(/*! ./canvas */ 315);
	
	var _canvas2 = _interopRequireDefault(_canvas);
	
	var _styles = __webpack_require__(/*! ./styles */ 303);
	
	var _styles2 = _interopRequireDefault(_styles);
	
	var _error = __webpack_require__(/*! ./error */ 313);
	
	var _error2 = _interopRequireDefault(_error);
	
	var _manipulatorTools = __webpack_require__(/*! ./manipulatorTools */ 317);
	
	var _manipulatorTools2 = _interopRequireDefault(_manipulatorTools);
	
	var _progress = __webpack_require__(/*! ./progress */ 314);
	
	var _progress2 = _interopRequireDefault(_progress);
	
	var _player = __webpack_require__(/*! ../modules/player */ 265);
	
	var _sceneIO = __webpack_require__(/*! ../modules/sceneIO */ 255);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var brokenThumbnails = {};
	
	function player(store, _ref) {
	  var isFlex = _ref.isFlex;
	  var isRelative = _ref.isRelative;
	  var parentEl = _ref.parentEl;
	
	  var rendered = (0, _sceneIO.isSceneRendered)(store);
	
	  var sceneId = store.getIn(['sceneIO', 'id']);
	  var hideThumbnail = rendered || !sceneId || !(0, _player.shouldDisplayThumbnail)(store);
	
	  var cssStyle = '\n  div.claraplayer canvas {\n    box-sizing: content-box;\n    -webkit-box-sizing: content-box;\n  }\n';
	  var children = [(0, _h2.default)('style', { props: { innerHTML: cssStyle } })];
	
	  var fullscreenBackgroundColor = store.getIn(['player', 'fullscreenBackgroundColor']);
	  var playerStyles = (0, _assign2.default)({}, _styles2.default.player, {
	    backgroundImage: hideThumbnail ? '' : 'url(' + ("https://editor.vimarket.io") + '/api/scenes/' + sceneId + '/v2thumbnail)',
	    backgroundRepeat: 'no-repeat',
	    backgroundSize: 'auto 100%',
	    backgroundPosition: 'center',
	    position: isFlex || isRelative ? 'absolute' : 'relative',
	    boxSizing: 'border-box',
	    backgroundColor: (0, _player.isFullscreen)(store) ? fullscreenBackgroundColor : 'transparent',
	    overflow: 'hidden'
	  });
	
	  if ((0, _sceneIO.numErrors)(store)) {
	    children.push((0, _error2.default)(store));
	  } else {
	    children.push((0, _canvas2.default)(store, 'player'));
	    if (rendered) children.push((0, _manipulatorTools2.default)(store));else children.push((0, _progress2.default)(store));
	  }
	
	  return (0, _h2.default)('div.claraplayer', { style: playerStyles, hook: {
	      insert: attachFullscreenHandlers(store)
	    } }, children);
	}
	
	function attachFullscreenHandlers(store) {
	  return function () {
	    [// ['fullscreenChange', 'fullscreenElement'],
	    ['webkitfullscreenchange', 'webkitIsFullScreen'], ['mozfullscreenchange', 'mozFullScreen'], ['MSFullscreenChange', 'msFullscreenElement']].forEach(function (info) {
	      document.addEventListener(info[0], function () {
	        //console.log('FULLSCREEN', info[0], !!document[info[1]]);
	        store.dispatch((0, _player.setFullscreen)(!!document[info[1]]));
	      });
	    });
	  };
	}
	
	/*function statsReporter() {
	  var pageLoadTime, toRenderedTime;
	  if (typeof performace === 'undefined') return function() {};
	
	  return function(store, pct) {
	    if (pageLoadTime && toRenderedTime) return;
	    if (!pageLoadTime) pageLoadTime = new Date().getTime() - performance.timing.navigationStart;
	    if (pct < 1) return;
	    toRenderedTime = new Date().getTime() - performance.timing.navigationStart;
	    console.log(`Page loaded in ${pageLoadTime}ms and rendered in ${toRenderedTime}ms`);
	  };
	};
	
	//
	//
	var circleDiv = {
	  flex: '0 0 25%'
	};
	
	var r = 90;
	var PIR2 = Math.PI * r * 2;
	
	var outer = {
	  r, cx: 100, cy: 100,
	  fill: 'transparent',
	  'stroke-dasharray': PIR2,
	  'stroke-dashoffset': 0,
	  'stroke-width': '1em',
	  stroke: '#eee'
	};
	var inner = {
	  r, cx: 100, cy: 100,
	  fill: 'transparent',
	  stroke: colour,
	  transition: 'stroke-dashoffset 1s linear',
	  'stroke-width': '1em',
	  'stroke-dashoffset': PIR2,
	  'stroke-dasharray': PIR2
	};
	var svg = {
	  height: '100%',
	  width: '100%',
	  viewport: '0 0 100 100',
	  viewBox: '0 0 200 200',
	};
	
	function progress(store, pct) {
	  var r = 90;
	  var degrees = PIR2*(1-pct);
	
	  return h('div', {style: {...styles.absoluteMaxCentered, backgroundColor: 'transparent', boxSizing: 'border-box' }}, [
	    h('div', {style: circleDiv}, [
	      h('svg', {attrs: svg}, [
	        h('circle', {attrs: outer}),
	        h('circle', {props: {id: 'bar'}, attrs: {...inner, 'stroke-dashoffset': degrees}}),
	      ])
	    ])
	  ]);
	};*/

/***/ }
/******/ ])
});
;
//# sourceMappingURL=claraplayer-2.0.12.js.map